[
    {
        "title": "Buddy Strings",
        "question_content": "Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\nSwapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j].\n\n\tFor example, swapping at indices 0 and 2 in \"abcd\" results in \"cbad\".\n\n&nbsp;\nExample 1:\n\nInput: s = \"ab\", goal = \"ba\"\nOutput: true\nExplanation: You can swap s[0] = 'a' and s[1] = 'b' to get \"ba\", which is equal to goal.\n\nExample 2:\n\nInput: s = \"ab\", goal = \"ab\"\nOutput: false\nExplanation: The only letters you can swap are s[0] = 'a' and s[1] = 'b', which results in \"ba\" != goal.\n\nExample 3:\n\nInput: s = \"aa\", goal = \"aa\"\nOutput: true\nExplanation: You can swap s[0] = 'a' and s[1] = 'a' to get \"aa\", which is equal to goal.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length, goal.length <= 2 * 104\n\ts and goal consist of lowercase letters.",
        "solutions": [
            {
                "id": 141780,
                "title": "easy-understood",
                "content": "If `A.length() != B.length()`: no possible swap\\n\\nIf `A == B`, we need swap two same characters. Check is duplicated char in `A`.\\n\\nIn other cases, we find index for `A[i] != B[i]`. There should be only 2 diffs and it\\'s our one swap.\\n\\n**C++:**\\n```\\n    bool buddyStrings(string A, string B) {\\n        if (A.length() != B.length()) return false;\\n        if (A == B && set<char>(A.begin(), A.end()).size() < A.size()) return true;\\n        vector<int> dif;\\n        for (int i = 0; i < A.length(); ++i) if (A[i] != B[i]) dif.push_back(i);\\n        return dif.size() == 2 && A[dif[0]] == B[dif[1]] && A[dif[1]] == B[dif[0]];\\n    }\\n```\\n\\n**Java:**\\n```\\n    public boolean buddyStrings(String A, String B) {\\n        if (A.length() != B.length()) return false;\\n        if (A.equals(B)) {\\n            Set<Character> s = new HashSet<Character>();\\n            for (char c : A.toCharArray()) s.add(c);\\n            return s.size() < A.length();\\n        }\\n        List<Integer> dif = new ArrayList<>();\\n        for (int i = 0; i < A.length(); ++i) if (A.charAt(i) != B.charAt(i)) dif.add(i);\\n        return dif.size() == 2 && A.charAt(dif.get(0)) == B.charAt(dif.get(1)) && A.charAt(dif.get(1)) == B.charAt(dif.get(0));\\n    }\\n```\\n**Python:**\\n```\\n    def buddyStrings(self, A, B):\\n        if len(A) != len(B): return False\\n        if A == B and len(set(A)) < len(A): return True\\n        dif = [(a, b) for a, b in zip(A, B) if a != b]\\n        return len(dif) == 2 and dif[0] == dif[1][::-1]\\n```",
                "solutionTags": [],
                "code": "```\\n    bool buddyStrings(string A, string B) {\\n        if (A.length() != B.length()) return false;\\n        if (A == B && set<char>(A.begin(), A.end()).size() < A.size()) return true;\\n        vector<int> dif;\\n        for (int i = 0; i < A.length(); ++i) if (A[i] != B[i]) dif.push_back(i);\\n        return dif.size() == 2 && A[dif[0]] == B[dif[1]] && A[dif[1]] == B[dif[0]];\\n    }\\n```\n```\\n    public boolean buddyStrings(String A, String B) {\\n        if (A.length() != B.length()) return false;\\n        if (A.equals(B)) {\\n            Set<Character> s = new HashSet<Character>();\\n            for (char c : A.toCharArray()) s.add(c);\\n            return s.size() < A.length();\\n        }\\n        List<Integer> dif = new ArrayList<>();\\n        for (int i = 0; i < A.length(); ++i) if (A.charAt(i) != B.charAt(i)) dif.add(i);\\n        return dif.size() == 2 && A.charAt(dif.get(0)) == B.charAt(dif.get(1)) && A.charAt(dif.get(1)) == B.charAt(dif.get(0));\\n    }\\n```\n```\\n    def buddyStrings(self, A, B):\\n        if len(A) != len(B): return False\\n        if A == B and len(set(A)) < len(A): return True\\n        dif = [(a, b) for a, b in zip(A, B) if a != b]\\n        return len(dif) == 2 and dif[0] == dif[1][::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3710426,
                "title": "beat-s-100-c-java-python-beginner-friendly",
                "content": "# Intuition:\\nThe Intuition is to check if it is possible to swap two characters in string `s` to make it equal to string `goal`. It first handles the case where `s` and `goal` are identical by checking for duplicate characters. If they are not identical, it looks for the first pair of mismatched characters and tries swapping them to achieve equality. The code provides a solution by considering these two scenarios and returns `true` if swapping is successful, otherwise `false`.\\n\\n# Explanation:\\n1. First, it checks if `s` is equal to `goal` using the `==` operator. If they are equal, it means the strings are identical.\\n\\n2. If `s` is equal to `goal`, the code creates a temporary set called `temp` to store the unique characters present in `s`. It does this by converting the string `s` to a set of characters using the `set` constructor.\\n\\n3. The code then returns the result of the comparison `temp.size() < goal.size()`. This comparison checks if the size of the set `temp` (number of unique characters in `s`) is less than the size of the string `goal`. If it is, it means there are duplicate characters in `s`, and swapping any two of them would result in `s` becoming equal to `goal`. In this case, the function returns `true`; otherwise, it returns `false`.\\n\\n4. If `s` is not equal to `goal`, the code proceeds to find the indices `i` and `j` such that `s[i]` and `goal[i]` are the first pair of characters that are different from each other when scanning from the left, and `s[j]` and `goal[j]` are the first pair of characters that are different from each other when scanning from the right.\\n5. The code uses a `while` loop to increment the `i` index from left to right until it finds a mismatch between `s[i]` and `goal[i]`. Similarly, it uses another `while` loop to decrement the `j` index from right to left until it finds a mismatch between `s[j]` and `goal[j]`.\\n6. After finding the mismatched indices, the code checks if `i` is less than `j`. If it is, it means there is a pair of characters that can be swapped to make `s` equal to `goal`. In this case, the code uses the `swap` function to swap the characters `s[i]` and `s[j]`.\\n\\n7. Finally, the code checks if `s` is equal to `goal` after the potential swap. If they are equal, it means we have successfully swapped two characters to make `s` equal to `goal`, and the function returns `true`. Otherwise, it returns `false`.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int n = s.length();\\n        \\n        if(goal.length() != n){\\n            return false;\\n        }\\n\\n        if(s == goal){\\n            set<char> temp(s.begin(), s.end());\\n            return temp.size() < goal.size(); // Swapping same characters\\n        }\\n\\n        int i = 0;\\n        int j = n - 1;\\n\\n        while(i < j && s[i] == goal[i]){\\n            i++;\\n        }\\n\\n        while(j >= 0 && s[j] == goal[j]){\\n            j--;\\n        }\\n\\n        if(i < j){\\n            swap(s[i], s[j]);\\n        }\\n\\n        return s == goal;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length() != goal.length()){\\n            return false;\\n        }\\n\\n        int n = s.length();\\n        if (s.equals(goal)) {\\n            Set<Character> temp = new HashSet<>();\\n            for (char c : s.toCharArray()) {\\n                temp.add(c);\\n            }\\n            return temp.size() < goal.length(); // Swapping same characters\\n        }\\n\\n        int i = 0;\\n        int j = n - 1;\\n\\n        while (i < j && s.charAt(i) == goal.charAt(i)) {\\n            i++;\\n        }\\n\\n        while (j >= 0 && s.charAt(j) == goal.charAt(j)) {\\n            j--;\\n        }\\n\\n        if (i < j) {\\n            char[] sArr = s.toCharArray();\\n            char temp = sArr[i];\\n            sArr[i] = sArr[j];\\n            sArr[j] = temp;\\n            s = new String(sArr);\\n        }\\n\\n        return s.equals(goal);\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        n = len(s)\\n\\n        if len(goal) != n:\\n            return False;\\n\\n        if s == goal:\\n            temp = set(s)\\n            return len(temp) < len(goal)  # Swapping same characters\\n\\n        i = 0\\n        j = n - 1\\n\\n        while i < j and s[i] == goal[i]:\\n            i += 1\\n\\n        while j >= 0 and s[j] == goal[j]:\\n            j -= 1\\n\\n        if i < j:\\n            s_list = list(s)\\n            s_list[i], s_list[j] = s_list[j], s_list[i]\\n            s = \\'\\'.join(s_list)\\n\\n        return s == goal\\n```\\n\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/afc18472-664c-4d6e-8370-25d5a4565caf_1688345134.3503385.png)\\n\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int n = s.length();\\n        \\n        if(goal.length() != n){\\n            return false;\\n        }\\n\\n        if(s == goal){\\n            set<char> temp(s.begin(), s.end());\\n            return temp.size() < goal.size(); // Swapping same characters\\n        }\\n\\n        int i = 0;\\n        int j = n - 1;\\n\\n        while(i < j && s[i] == goal[i]){\\n            i++;\\n        }\\n\\n        while(j >= 0 && s[j] == goal[j]){\\n            j--;\\n        }\\n\\n        if(i < j){\\n            swap(s[i], s[j]);\\n        }\\n\\n        return s == goal;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length() != goal.length()){\\n            return false;\\n        }\\n\\n        int n = s.length();\\n        if (s.equals(goal)) {\\n            Set<Character> temp = new HashSet<>();\\n            for (char c : s.toCharArray()) {\\n                temp.add(c);\\n            }\\n            return temp.size() < goal.length(); // Swapping same characters\\n        }\\n\\n        int i = 0;\\n        int j = n - 1;\\n\\n        while (i < j && s.charAt(i) == goal.charAt(i)) {\\n            i++;\\n        }\\n\\n        while (j >= 0 && s.charAt(j) == goal.charAt(j)) {\\n            j--;\\n        }\\n\\n        if (i < j) {\\n            char[] sArr = s.toCharArray();\\n            char temp = sArr[i];\\n            sArr[i] = sArr[j];\\n            sArr[j] = temp;\\n            s = new String(sArr);\\n        }\\n\\n        return s.equals(goal);\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        n = len(s)\\n\\n        if len(goal) != n:\\n            return False;\\n\\n        if s == goal:\\n            temp = set(s)\\n            return len(temp) < len(goal)  # Swapping same characters\\n\\n        i = 0\\n        j = n - 1\\n\\n        while i < j and s[i] == goal[i]:\\n            i += 1\\n\\n        while j >= 0 and s[j] == goal[j]:\\n            j -= 1\\n\\n        if i < j:\\n            s_list = list(s)\\n            s_list[i], s_list[j] = s_list[j], s_list[i]\\n            s = \\'\\'.join(s_list)\\n\\n        return s == goal\\n```",
                "codeTag": "Java"
            },
            {
                "id": 891469,
                "title": "c-java-python-one-pass-clean-concise-o-n",
                "content": "**Idea**\\n- Using 2 indices `diff1`, `diff2` to store up to 2 different places between string `A` and string `B`.\\n- If there are more than 2 different places -> Invalid.\\n- If there are 2 different places -> Compare A[diff1] vs B[diff2] and A[diff2] vs B[diff1].\\n- If there is only 1 different places -> Invalid.\\n- If no difference between A and B then check if `A` contains at least 1 duplicate letters so that we can swap them.\\n\\t- Example 1: `A = \"ab\"`, `B = \"ab\"`\\n\\t- Example 2: `A = \"aab\"`, `B = \"aab\"`, \\n\\n<iframe src=\"https://leetcode.com/playground/QSYJiwkN/shared\" frameBorder=\"0\" width=\"100%\" height=\"460\"></iframe>\\n\\n**Complexity:**\\n- Time: `O(N)`\\n- Space: `O(26)`, `A_letters` stores up to 26 characters\\n\\nIf you like this solution, I\\'m happy if you give this post a **vote**.\\nHappy coding!",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "**Idea**\\n- Using 2 indices `diff1`, `diff2` to store up to 2 different places between string `A` and string `B`.\\n- If there are more than 2 different places -> Invalid.\\n- If there are 2 different places -> Compare A[diff1] vs B[diff2] and A[diff2] vs B[diff1].\\n- If there is only 1 different places -> Invalid.\\n- If no difference between A and B then check if `A` contains at least 1 duplicate letters so that we can swap them.\\n\\t- Example 1: `A = \"ab\"`, `B = \"ab\"`\\n\\t- Example 2: `A = \"aab\"`, `B = \"aab\"`, \\n\\n<iframe src=\"https://leetcode.com/playground/QSYJiwkN/shared\" frameBorder=\"0\" width=\"100%\" height=\"460\"></iframe>\\n\\n**Complexity:**\\n- Time: `O(N)`\\n- Space: `O(26)`, `A_letters` stores up to 26 characters\\n\\nIf you like this solution, I\\'m happy if you give this post a **vote**.\\nHappy coding!",
                "codeTag": "Unknown"
            },
            {
                "id": 891275,
                "title": "python-best-simple-and-clean-explained-solution-o-n-o-1",
                "content": "```\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n        # check same length\\n        if len(A) != len(B): return False\\n        \\n        # if strings are equal - check if there is a double to swap\\n        if A == B:\\n            return True if len(A) - len(set(A)) >= 1 else False\\n        \\n        # count differences between strings\\n        diff = []\\n        for i in range(len(A)):\\n            if A[i] != B[i]:\\n                diff.append(i)\\n                if len(diff) > 2: return False\\n                \\n        # not exactly two differences\\n        if len(diff) != 2: return False\\n        \\n        # check if can be swapped\\n        if A[diff[0]] == B[diff[1]] and A[diff[1]] == B[diff[0]]:\\n            return True\\n        \\n        return False\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n        # check same length\\n        if len(A) != len(B): return False\\n        \\n        # if strings are equal - check if there is a double to swap\\n        if A == B:\\n            return True if len(A) - len(set(A)) >= 1 else False\\n        \\n        # count differences between strings\\n        diff = []\\n        for i in range(len(A)):\\n            if A[i] != B[i]:\\n                diff.append(i)\\n                if len(diff) > 2: return False\\n                \\n        # not exactly two differences\\n        if len(diff) != 2: return False\\n        \\n        # check if can be swapped\\n        if A[diff[0]] == B[diff[1]] and A[diff[1]] == B[diff[0]]:\\n            return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 142647,
                "title": "clear-c-solution",
                "content": "```\\n    bool buddyStrings(string A, string B) {\\n        // Same length\\n        int len_A = A.size(), len_B = B.size();\\n        if (len_A != len_B) return false;\\n        \\n        // Repeat: same string, A needs repeated char, like \"aab\" \"aab\"\\n        int numChar_A = unordered_set<char>(A.begin(), A.end()).size();\\n        if (A == B && numChar_A < len_B) return true;\\n        \\n        // Swap: There should be only two to change\\n        vector<int> index_diff;\\n                        \\n        for (int i = 0; i < len_A; i++) {\\n          if (A[i] != B[i]) index_diff.push_back(i);\\n          if (index_diff.size() > 2) return false;\\n        } \\n        \\n        return index_diff.size() == 2 &&\\n               A[index_diff[0]] == B[index_diff[1]] &&\\n               A[index_diff[1]] == B[index_diff[0]];        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool buddyStrings(string A, string B) {\\n        // Same length\\n        int len_A = A.size(), len_B = B.size();\\n        if (len_A != len_B) return false;\\n        \\n        // Repeat: same string, A needs repeated char, like \"aab\" \"aab\"\\n        int numChar_A = unordered_set<char>(A.begin(), A.end()).size();\\n        if (A == B && numChar_A < len_B) return true;\\n        \\n        // Swap: There should be only two to change\\n        vector<int> index_diff;\\n                        \\n        for (int i = 0; i < len_A; i++) {\\n          if (A[i] != B[i]) index_diff.push_back(i);\\n          if (index_diff.size() > 2) return false;\\n        } \\n        \\n        return index_diff.size() == 2 &&\\n               A[index_diff[0]] == B[index_diff[1]] &&\\n               A[index_diff[1]] == B[index_diff[0]];        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 171410,
                "title": "python-simple-and-intuitive",
                "content": "1. if length differs or set of characters differ, return False directly\\n2. if A and B are equal, returns if we have at least 1 repetitive character in the list\\n3.  if two list have more than 2 indices with different characters, return false\\n4.  In the end check if the swap can happen\\n```\\nclass Solution:\\n    def buddyStrings(self, A, B):\\n        if len(A) != len(B) or set(A) != set(B): return False       \\n        if A == B:\\n            return len(A) - len(set(A)) >= 1\\n        else:     \\n            indices = []\\n            counter = 0\\n            for i in range(len(A)):\\n                if A[i] != B[i]:\\n                    counter += 1\\n                    indices.append(i)       \\n                if counter > 2:\\n                    return False       \\n            return A[indices[0]] == B[indices[1]] and A[indices[1]] == B[indices[0]]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, A, B):\\n        if len(A) != len(B) or set(A) != set(B): return False       \\n        if A == B:\\n            return len(A) - len(set(A)) >= 1\\n        else:     \\n            indices = []\\n            counter = 0\\n            for i in range(len(A)):\\n                if A[i] != B[i]:\\n                    counter += 1\\n                    indices.append(i)       \\n                if counter > 2:\\n                    return False       \\n            return A[indices[0]] == B[indices[1]] and A[indices[1]] == B[indices[0]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141794,
                "title": "java-o-1-space-o-n-time",
                "content": "```\\npublic boolean buddyStrings(String A, String B) {\\n    if (A == null || B == null || A.length() != B.length())  return false;\\n    int a = -1, b = -1, diff = 0;\\n    int[] count = new int[26];\\n    // check if able to switch with the same character.\\n    boolean canSwitch = false;\\n    for (int i = 0; i < A.length(); i++) {\\n      if (++count[A.charAt(i) - \\'a\\'] >= 2)  canSwitch = true;\\n      if (A.charAt(i) != B.charAt(i)) {\\n        diff++;\\n        if (a == -1)  a = i;\\n        else if (b == -1)  b = i;\\n      }\\n    }\\n    return (diff == 0 && canSwitch) || (diff == 2 && A.charAt(a) == B.charAt(b) && A.charAt(b) == B.charAt(a));\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean buddyStrings(String A, String B) {\\n    if (A == null || B == null || A.length() != B.length())  return false;\\n    int a = -1, b = -1, diff = 0;\\n    int[] count = new int[26];\\n    // check if able to switch with the same character.\\n    boolean canSwitch = false;\\n    for (int i = 0; i < A.length(); i++) {\\n      if (++count[A.charAt(i) - \\'a\\'] >= 2)  canSwitch = true;\\n      if (A.charAt(i) != B.charAt(i)) {\\n        diff++;\\n        if (a == -1)  a = i;\\n        else if (b == -1)  b = i;\\n      }\\n    }\\n    return (diff == 0 && canSwitch) || (diff == 2 && A.charAt(a) == B.charAt(b) && A.charAt(b) == B.charAt(a));\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3710591,
                "title": "easy-code-100-fast-strings-explanation-in-video-c-java-python",
                "content": "For detailed explanation you can refer to my youtube channel (Hindi Language)\\nhttps://youtube.com/@LetsCodeTogether72?sub_confirmation=1\\n or link in comment.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\nor\\nsearch \\uD83D\\uDC49`Buddy Strings` on youtube\\n\\n#  C++ Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n         int ns=s.size(),ng=goal.size();\\n        if(ns != ng ) {\\n            return 0;\\n        }\\n        if(s == goal ) {\\n            vector<int>farr(26,0);\\n            for(auto &x:s){\\n                farr[x-\\'a\\']++;\\n                if(farr[x-\\'a\\']==2)\\n                return true;\\n            }\\n            return false;;\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<ns;i++)\\n        {\\n            if(s[i] != goal[i]) {\\n                ans.push_back(i);\\n            }\\n            if(ans.size()>2)\\n            return false;\\n        }\\n        \\n        return  ans.size()==2&&s[ans[0]]==goal[ans[1]] && s[ans[1]]==goal[ans[0]];\\n    }\\n};\\n```\\n#  Java Code\\n```\\n\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        int ns = s.length();\\n        int ng = goal.length();\\n        \\n        if (ns != ng) {\\n            return false;\\n        }\\n        \\n        if (s.equals(goal)) {\\n            int[] farr = new int[26];\\n            for (char ch : s.toCharArray()) {\\n                farr[ch - \\'a\\']++;\\n                if (farr[ch - \\'a\\'] == 2) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        ArrayList<Integer>ans=new ArrayList<>();\\n        //int count = 0;\\n        for (int i = 0; i < ns; i++) {\\n            if (s.charAt(i) != goal.charAt(i)) {\\n               ans.add(i);\\n                if (ans.size()> 2) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return ans.size() == 2 && s.charAt(ans.get(0)) == goal.charAt(ans.get(1)) && s.charAt(ans.get(1)) == goal.charAt(ans.get(0));\\n    }\\n}\\n```\\n#  Python3 Code\\n\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        ns = len(s)\\n        ng = len(goal)\\n\\n        if ns != ng:\\n            return False\\n\\n        if s == goal:\\n            farr = [0] * 26\\n            for ch in s:\\n                farr[ord(ch) - ord(\\'a\\')] += 1\\n            \\n            for count in farr:\\n                if count > 1:\\n                    return True\\n            \\n            return False\\n\\n        ans = []\\n        for i in range(ns):\\n            if s[i] != goal[i]:\\n                ans.append(i)\\n                if len(ans) > 2:\\n                    return False\\n\\n        return len(ans) == 2 and s[ans[0]] == goal[ans[1]] and s[ans[1]] == goal[ans[0]]\\n\\n````\\n# please upvote if u like this",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n         int ns=s.size(),ng=goal.size();\\n        if(ns != ng ) {\\n            return 0;\\n        }\\n        if(s == goal ) {\\n            vector<int>farr(26,0);\\n            for(auto &x:s){\\n                farr[x-\\'a\\']++;\\n                if(farr[x-\\'a\\']==2)\\n                return true;\\n            }\\n            return false;;\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<ns;i++)\\n        {\\n            if(s[i] != goal[i]) {\\n                ans.push_back(i);\\n            }\\n            if(ans.size()>2)\\n            return false;\\n        }\\n        \\n        return  ans.size()==2&&s[ans[0]]==goal[ans[1]] && s[ans[1]]==goal[ans[0]];\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        int ns = s.length();\\n        int ng = goal.length();\\n        \\n        if (ns != ng) {\\n            return false;\\n        }\\n        \\n        if (s.equals(goal)) {\\n            int[] farr = new int[26];\\n            for (char ch : s.toCharArray()) {\\n                farr[ch - \\'a\\']++;\\n                if (farr[ch - \\'a\\'] == 2) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        ArrayList<Integer>ans=new ArrayList<>();\\n        //int count = 0;\\n        for (int i = 0; i < ns; i++) {\\n            if (s.charAt(i) != goal.charAt(i)) {\\n               ans.add(i);\\n                if (ans.size()> 2) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return ans.size() == 2 && s.charAt(ans.get(0)) == goal.charAt(ans.get(1)) && s.charAt(ans.get(1)) == goal.charAt(ans.get(0));\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        ns = len(s)\\n        ng = len(goal)\\n\\n        if ns != ng:\\n            return False\\n\\n        if s == goal:\\n            farr = [0] * 26\\n            for ch in s:\\n                farr[ord(ch) - ord(\\'a\\')] += 1\\n            \\n            for count in farr:\\n                if count > 1:\\n                    return True\\n            \\n            return False\\n\\n        ans = []\\n        for i in range(ns):\\n            if s[i] != goal[i]:\\n                ans.append(i)\\n                if len(ans) > 2:\\n                    return False\\n\\n        return len(ans) == 2 and s[ans[0]] == goal[ans[1]] and s[ans[1]] == goal[ans[0]]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 891021,
                "title": "python-o-n-solution-explained",
                "content": "Let us carefully cover all possible cases in this problem:\\n1. If lengths of strings are different, we immedietly return `False`.\\n2. If counters of strings are different, we also return `False`.\\n3. Let us also evaluate for each place if symbols in `A` and `B` are equal. We can afford to have only `2` symbols which are not equal or `0`: in first case we change two different symbols and in second two equal. So, if number of not equal symbols is not `0` or `2`, we return `False`.\\n4. Also, if we have number `diff_places == 0`, it means that we changed two equal symbols. We can not do it if all string has different symbols, like `abtlpe`, so we return `False` in this case.\\n5. If we have `diff_places == 2`, it means that we changed two different symbols. We can not do it if string is just one symbols repeated, like `ddddddd`, so we return `False` in this case.\\n6. Finally, if we did not return anything yet, we return `True`.\\n\\n**Complexity** is `O(n)`, because we use counters, which is linear and number of not equal symbols which is linear as well.\\n\\n```\\nclass Solution:\\n    def buddyStrings(self, A, B):\\n        if len(A) != len(B): return False\\n        Count_A, Count_B = Counter(A), Counter(B)\\n        if Count_A != Count_B: return False\\n        diff_places = sum([i!=j for i,j in zip(A,B)])\\n        if diff_places not in [0, 2]: return False\\n        if diff_places == 0 and len(Count_A) == len(A): return False\\n        if diff_places == 2 and len(Count_A) == 1: return False\\n        return True\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, A, B):\\n        if len(A) != len(B): return False\\n        Count_A, Count_B = Counter(A), Counter(B)\\n        if Count_A != Count_B: return False\\n        diff_places = sum([i!=j for i,j in zip(A,B)])\\n        if diff_places not in [0, 2]: return False\\n        if diff_places == 0 and len(Count_A) == len(A): return False\\n        if diff_places == 2 and len(Count_A) == 1: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786309,
                "title": "javascript-clean-and-intuitive-solution",
                "content": "```javascript\\nvar buddyStrings = function(A, B) {\\n    if(A.length != B.length) return false;\\n    const diff = [];\\n    \\n    for(let i = 0; i < A.length; i++) {\\n        if(A[i] != B[i]) diff.push(i);\\n        if(diff.length > 2) return false;\\n    }\\n    if(!diff.length) return A.length != [...new Set(A)].length;\\n    const [i, j] = diff; \\n    return A[i] == B[j] && B[i] == A[j];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar buddyStrings = function(A, B) {\\n    if(A.length != B.length) return false;\\n    const diff = [];\\n    \\n    for(let i = 0; i < A.length; i++) {\\n        if(A[i] != B[i]) diff.push(i);\\n        if(diff.length > 2) return false;\\n    }\\n    if(!diff.length) return A.length != [...new Set(A)].length;\\n    const [i, j] = diff; \\n    return A[i] == B[j] && B[i] == A[j];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 405603,
                "title": "python-clear-8-lines-easy-understand",
                "content": "```\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n        A = list(A)\\n        B = list(B)\\n        if len(A)!=len(B): return False\\n        C = [i for i in range(len(A)) if A[i] != B[i]]\\n        if len(C)==2 and A[C[0]]==B[C[1]] and A[C[1]]==B[C[0]]: return True\\n        if not C:\\n            if len(A)>len(set(A)): return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n        A = list(A)\\n        B = list(B)\\n        if len(A)!=len(B): return False\\n        C = [i for i in range(len(A)) if A[i] != B[i]]\\n        if len(C)==2 and A[C[0]]==B[C[1]] and A[C[1]]==B[C[0]]: return True\\n        if not C:\\n            if len(A)>len(set(A)): return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711198,
                "title": "c-easy-explanation-self-explanatory-code-beats-100",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach of the code is as follows:\\n\\n1. First, the code checks if the lengths of the two input strings, `s` and `goal`, are not equal or if the length of `s` is less than or equal to 1. If either of these conditions is true, the function returns `false`. This is because for the two strings to be buddy strings, they must have the same length and contain at least two differing characters.\\n\\n2. Next, the code checks if `s` and `goal` are identical. If they are, it means that all characters are the same. In this case, the code creates an set, `distinctChars`, to store the distinct characters from `s`. If the size of `distinctChars` is less than the length of `s`, it means there are duplicate characters, and we can swap two of them to make `s` and `goal` equal. The function returns `true` in this case.\\n\\n3. If the previous conditions are not met, it means that `s` and `goal` are different strings, and we need to check if they can be made equal by swapping exactly two characters.\\n\\n4. The code iterates through each character of `s` and `goal` simultaneously, comparing the characters at each index. Whenever a pair of characters at the same index is different, the index is added to the `index` vector.\\n\\n5. After iterating through both strings, the code checks if the size of `index` is exactly 2. If it\\'s not, it means there are either more or fewer than two differing characters, and the strings cannot be made equal by swapping two characters. In this case, the function returns `false`.\\n\\n6. If there are exactly two differing characters, the code proceeds to swap these characters in `s` by using the indices stored in the `index` vector.\\n\\n7. Finally, the code checks if `s` is now equal to `goal` after the swap. If they are equal, it means that `s` and `goal` can be made equal by swapping two characters, and the function returns `true`. Otherwise, it means the swap did not result in `s` becoming equal to `goal`, and the function returns `false`.\\n\\n\\n# Complexity\\n- Time complexity:    $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if (s.length() != goal.length() || s.length() <= 1) {\\n            return false;\\n        }\\n\\n        if (s == goal) {\\n            unordered_set<char> distinctChars(s.begin(), s.end());\\n            return distinctChars.size() < s.length();\\n        }\\n\\n        vector<int> index;\\n        for (int i=0;i<s.length();i++) {\\n            if (s[i] != goal[i]) {\\n                index.push_back(i);\\n            }\\n        }\\n\\n        if (index.size() != 2) {\\n            return false;\\n        }\\n\\n        swap(s[index[0]], s[index[1]]);\\n        return s == goal;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if (s.length() != goal.length() || s.length() <= 1) {\\n            return false;\\n        }\\n\\n        if (s == goal) {\\n            unordered_set<char> distinctChars(s.begin(), s.end());\\n            return distinctChars.size() < s.length();\\n        }\\n\\n        vector<int> index;\\n        for (int i=0;i<s.length();i++) {\\n            if (s[i] != goal[i]) {\\n                index.push_back(i);\\n            }\\n        }\\n\\n        if (index.size() != 2) {\\n            return false;\\n        }\\n\\n        swap(s[index[0]], s[index[1]]);\\n        return s == goal;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 445324,
                "title": "c-using-two-pointers-and-set",
                "content": "If the strings are initially equal, just check whether A contains some duplicate letters you can swap to meet the one-swap condition. \\n\\nFor ex., for A= \"aba\" and B=\"aba\" two \"a\"s in A are swappable to leave A equal to B. \\nIn the same manner equal A=\"ab\" and B=\"ab\" strings will fail to meet the condition as A contains only non-duplicate letters, thus making one-swap impossible.\\n \\n The other case is when A != B. In such case look for one-swap possibility running two pointers from two ends. \\n If the swap was done check whether A became equal to B now.\\n \\n```\\nbool buddyStrings(string A, string B) {        \\n        if (A == B)\\n            return (set<char>(A.begin(), A.end()).size() < A.size()); // swap same letters in A\\n        \\n        int n = A.length();\\n        int l = 0, r = n-1;\\n        \\n        while(l < n && A[l] == B[l])\\n            l++;\\n        while(r >= 0 && A[r] == B[r])\\n            r--;\\n        if(l < r)\\n            swap(A[l], A[r]);\\n        \\n        return A == B;                \\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nbool buddyStrings(string A, string B) {        \\n        if (A == B)\\n            return (set<char>(A.begin(), A.end()).size() < A.size()); // swap same letters in A\\n        \\n        int n = A.length();\\n        int l = 0, r = n-1;\\n        \\n        while(l < n && A[l] == B[l])\\n            l++;\\n        while(r >= 0 && A[r] == B[r])\\n            r--;\\n        if(l < r)\\n            swap(A[l], A[r]);\\n        \\n        return A == B;                \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 320883,
                "title": "javascript-solution",
                "content": "```\\nvar buddyStrings = function(A, B) {\\n    if (A.length != B.length) {\\n        return false;\\n    }\\n    \\n    if (A == B) {\\n        let s = new Set();\\n        \\n        for (let i = 0; i < A.length; i++) {\\n            s.add(A.charAt(i));\\n        }\\n        \\n        return s.size < A.length;\\n    }\\n    \\n    let diff = [];\\n    for (let i = 0; i < A.length; i++) {\\n        if (A.charAt(i) != B.charAt(i)) {\\n            diff.push(i);\\n        }\\n    }\\n    \\n    return diff.length == 2 && A.charAt(diff[0]) == B.charAt(diff[1]) && A.charAt(diff[1]) == B.charAt(diff[0]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar buddyStrings = function(A, B) {\\n    if (A.length != B.length) {\\n        return false;\\n    }\\n    \\n    if (A == B) {\\n        let s = new Set();\\n        \\n        for (let i = 0; i < A.length; i++) {\\n            s.add(A.charAt(i));\\n        }\\n        \\n        return s.size < A.length;\\n    }\\n    \\n    let diff = [];\\n    for (let i = 0; i < A.length; i++) {\\n        if (A.charAt(i) != B.charAt(i)) {\\n            diff.push(i);\\n        }\\n    }\\n    \\n    return diff.length == 2 && A.charAt(diff[0]) == B.charAt(diff[1]) && A.charAt(diff[1]) == B.charAt(diff[0]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1728856,
                "title": "set-two-pointer-easy-100-faster-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n         if (A == B)\\n            return (set<char>(A.begin(), A.end()).size() < A.size());\\n        int n = A.length();\\n        int l = 0, r = n-1;\\n        \\n        while(l < n && A[l] == B[l])\\n            l++;\\n        while(r >= 0 && A[r] == B[r])\\n            r--;\\n        if(l < r)\\n            swap(A[l], A[r]);\\n        \\n        return A == B; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n         if (A == B)\\n            return (set<char>(A.begin(), A.end()).size() < A.size());\\n        int n = A.length();\\n        int l = 0, r = n-1;\\n        \\n        while(l < n && A[l] == B[l])\\n            l++;\\n        while(r >= 0 && A[r] == B[r])\\n            r--;\\n        if(l < r)\\n            swap(A[l], A[r]);\\n        \\n        return A == B; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711923,
                "title": "o-n-easy-python-soln-with-steps",
                "content": "# Complexity\\n- Time complexity: O(n) time, as it iterates through the characters of both strings once.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        # Step 1: Check if the lengths of s and goal are different\\n        if len(s) != len(goal):\\n            return False\\n        \\n        # Step 2: Check if s and goal are exactly the same\\n        # and there are duplicate characters in s\\n        if s == goal and len(set(s)) < len(s):\\n            return True\\n        \\n        # Step 3: Find the pairs of different characters in s and goal\\n        diffs = [(a, b) for a, b in zip(s, goal) if a != b]\\n        \\n        # Step 4: Check if there are exactly two different pairs of characters\\n        # and the first pair can be transformed into the second pair by flipping it\\n        return len(diffs) == 2 and diffs[0] == diffs[1][::-1]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        # Step 1: Check if the lengths of s and goal are different\\n        if len(s) != len(goal):\\n            return False\\n        \\n        # Step 2: Check if s and goal are exactly the same\\n        # and there are duplicate characters in s\\n        if s == goal and len(set(s)) < len(s):\\n            return True\\n        \\n        # Step 3: Find the pairs of different characters in s and goal\\n        diffs = [(a, b) for a, b in zip(s, goal) if a != b]\\n        \\n        # Step 4: Check if there are exactly two different pairs of characters\\n        # and the first pair can be transformed into the second pair by flipping it\\n        return len(diffs) == 2 and diffs[0] == diffs[1][::-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711866,
                "title": "easiest-c-code-explained-in-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int i,j,k,c=0,a=0;\\n        unordered_map<char,int>map;\\n        for(auto x:s)\\n        map[x]++;\\n\\n        if(map.size()<s.size())\\n        a=1;\\n\\n        for(auto x:goal){                    //comparing that both strings have same number of alphabets\\n            if(map.find(x)==map.end())        //if different alphabets \\n            return 0;                            //return 0;\\n            if(map[x]==1)\\n            map.erase(x);                       //else erase from map\\n            else\\n            map[x]--;\\n        }\\n\\n        if(map.size()>0)                        //if map not empty return 0\\n        return 0;\\n\\n        for(i=0;i<s.size();i++){                  //comparing alphabets at all indexes\\n            if(s[i]!=goal[i])\\n            c++;\\n        }\\n\\n    if(c==2)                                     //if c==2 only 2 alphabets are displaced return 1;\\n    return 1;\\n    if(a==1 and c==0)                            //if any 2 characters are repeating then if c==0 return 1;\\n    return 1;                               //return 0\\n    \\n    return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int i,j,k,c=0,a=0;\\n        unordered_map<char,int>map;\\n        for(auto x:s)\\n        map[x]++;\\n\\n        if(map.size()<s.size())\\n        a=1;\\n\\n        for(auto x:goal){                    //comparing that both strings have same number of alphabets\\n            if(map.find(x)==map.end())        //if different alphabets \\n            return 0;                            //return 0;\\n            if(map[x]==1)\\n            map.erase(x);                       //else erase from map\\n            else\\n            map[x]--;\\n        }\\n\\n        if(map.size()>0)                        //if map not empty return 0\\n        return 0;\\n\\n        for(i=0;i<s.size();i++){                  //comparing alphabets at all indexes\\n            if(s[i]!=goal[i])\\n            c++;\\n        }\\n\\n    if(c==2)                                     //if c==2 only 2 alphabets are displaced return 1;\\n    return 1;\\n    if(a==1 and c==0)                            //if any 2 characters are repeating then if c==0 return 1;\\n    return 1;                               //return 0\\n    \\n    return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274825,
                "title": "python-o-n-simple",
                "content": "More concise\\n\\n```python\\ndef buddyStrings(self, A: str, B: str) -> bool:                \\n        if A == B and len(A) != len(set(A)):\\n            return True\\n        \\n        diffs = [i for i in range(len(A)) if A[i] != B[i]]\\n        \\n        return len(A) == len(B) and len(diffs) == 2 and A[diffs[0]] == B[diffs[1]] and A[diffs[1]] == B[diffs[0]]\\n```\\n\\nLess concise but slightly more efficient (breaks early in for loop).\\n\\n```python\\ndef buddyStrings(self, A: str, B: str) -> bool:                \\n        if len(A) != len(B):\\n            return False\\n        \\n        if A == B and len(A) != len(set(A)):\\n            return True\\n        \\n        diffs = []\\n        for i in range(len(A)):\\n            if A[i] != B[i]:\\n                diffs.append(i)\\n                if len(diffs) > 2:\\n                    return False\\n                \\n        return len(diffs) == 2 and A[diffs[0]] == B[diffs[1]] and A[diffs[1]] == B[diffs[0]]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef buddyStrings(self, A: str, B: str) -> bool:                \\n        if A == B and len(A) != len(set(A)):\\n            return True\\n        \\n        diffs = [i for i in range(len(A)) if A[i] != B[i]]\\n        \\n        return len(A) == len(B) and len(diffs) == 2 and A[diffs[0]] == B[diffs[1]] and A[diffs[1]] == B[diffs[0]]\\n```\n```python\\ndef buddyStrings(self, A: str, B: str) -> bool:                \\n        if len(A) != len(B):\\n            return False\\n        \\n        if A == B and len(A) != len(set(A)):\\n            return True\\n        \\n        diffs = []\\n        for i in range(len(A)):\\n            if A[i] != B[i]:\\n                diffs.append(i)\\n                if len(diffs) > 2:\\n                    return False\\n                \\n        return len(diffs) == 2 and A[diffs[0]] == B[diffs[1]] and A[diffs[1]] == B[diffs[0]]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1081402,
                "title": "java-solution-with-set",
                "content": "```\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        if (A.length() != B.length()) return false;\\n        if (A.equals(B)){\\n            Set<Character> set = new HashSet<>();\\n            for (char c : A.toCharArray())\\n                set.add(c);\\n            return set.size() < A.length();\\n        }\\n        else{\\n            List<Integer> list = new ArrayList<>();\\n            for (int i = 0;i<A.length();i++)\\n                if (A.charAt(i) != B.charAt(i)) list.add(i);\\n            return list.size() == 2 && A.charAt(list.get(0)) == B.charAt(list.get(1)) && B.charAt(list.get(0)) == A.charAt(list.get(1));\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        if (A.length() != B.length()) return false;\\n        if (A.equals(B)){\\n            Set<Character> set = new HashSet<>();\\n            for (char c : A.toCharArray())\\n                set.add(c);\\n            return set.size() < A.length();\\n        }\\n        else{\\n            List<Integer> list = new ArrayList<>();\\n            for (int i = 0;i<A.length();i++)\\n                if (A.charAt(i) != B.charAt(i)) list.add(i);\\n            return list.size() == 2 && A.charAt(list.get(0)) == B.charAt(list.get(1)) && B.charAt(list.get(0)) == A.charAt(list.get(1));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 402286,
                "title": "java-1-ms-beats-97-8",
                "content": "```\\nclass Solution {    \\n    public boolean buddyStrings(String A, String B) {\\n        if (A.length() != B.length())\\n            return false;\\n\\n        if (A.equals(B)) {\\n            Set set = new HashSet();\\n            for (int i = 0; i < A.length(); i++) {\\n                if (set.contains(A.charAt(i)))\\n                    return true;\\n                else set.add(A.charAt(i));\\n            }\\n            return false;\\n        }\\n\\n        int counter = 0;\\n        int aChars = 0;\\n        int bChars = 0;\\n        for (int i = 0; i < A.length(); i++) {\\n            aChars += A.charAt(i);\\n            bChars += B.charAt(i);\\n            if (A.charAt(i) != B.charAt(i))\\n                counter++;\\n            if (counter > 2)\\n                return false;\\n        }\\n        return counter <= 2 && aChars == bChars;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {    \\n    public boolean buddyStrings(String A, String B) {\\n        if (A.length() != B.length())\\n            return false;\\n\\n        if (A.equals(B)) {\\n            Set set = new HashSet();\\n            for (int i = 0; i < A.length(); i++) {\\n                if (set.contains(A.charAt(i)))\\n                    return true;\\n                else set.add(A.charAt(i));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3713315,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length()!=goal.length())\\n        {\\n            return false;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)!=goal.charAt(i))\\n            {\\n                count++;\\n            }\\n        }\\n        int a[]=new int[26];\\n        int b[]=new int[26];\\n        for(char c:s.toCharArray())\\n        {\\n            a[c-\\'a\\']++;\\n        }\\n        for(char c:goal.toCharArray())\\n        {\\n            b[c-\\'a\\']++;\\n        }\\n        if(count>2)\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(a[i]!=b[i])\\n            {\\n                return false;\\n            }\\n        }\\n        if(count==2)\\n        {\\n            return true;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(a[i]>=2)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length()!=goal.length())\\n        {\\n            return false;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)!=goal.charAt(i))\\n            {\\n                count++;\\n            }\\n        }\\n        int a[]=new int[26];\\n        int b[]=new int[26];\\n        for(char c:s.toCharArray())\\n        {\\n            a[c-\\'a\\']++;\\n        }\\n        for(char c:goal.toCharArray())\\n        {\\n            b[c-\\'a\\']++;\\n        }\\n        if(count>2)\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(a[i]!=b[i])\\n            {\\n                return false;\\n            }\\n        }\\n        if(count==2)\\n        {\\n            return true;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(a[i]>=2)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710555,
                "title": "beats-100-video-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/pL902JiXA6E\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\nThe key idea in any String problem is to come up with many examples before hand and draw the observations.\\n\\ns = abcde g = adbce\\ns = adcbe g = abxde\\ns = abcd g = abcd\\ns = aabc g = aabc\\ns = abc g = ab\\ns = abcd g = abed\\n\\nOnce we understand the above examples, the implementation is quite straight forward.\\n\\n```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length()!=goal.length()) return false;\\n        if(s.equals(goal)){\\n            int [] count = new int[26];\\n            int c;\\n            for(int i = 0;i<s.length();i++){\\n                c = s.charAt(i)-\\'a\\';\\n                count[c]++;\\n                if(count[c]==2)return true;\\n            }\\n            return false;\\n        }\\n        \\n        int index1 = -1;\\n        int index2 = -1;\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i) != goal.charAt(i)){\\n                if(index1 == -1) index1 = i;\\n                else if(index2 == -1) index2 = i;\\n                else return false;\\n            }\\n        }\\n        if(index2==-1) return false;\\n        return (s.charAt(index1) == goal.charAt(index2) && s.charAt(index2) == goal.charAt(index1));\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if (s.length() != goal.length())\\n            return false;\\n        \\n        if (s == goal) {\\n            vector<int> count(26, 0);\\n            \\n            for (int i = 0; i < s.length(); i++) {\\n                int c = s[i] - \\'a\\';\\n                count[c]++;\\n                if (count[c] == 2)\\n                    return true;\\n            }\\n            \\n            return false;\\n        }\\n        \\n        int index1 = -1;\\n        int index2 = -1;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] != goal[i]) {\\n                if (index1 == -1)\\n                    index1 = i;\\n                else if (index2 == -1)\\n                    index2 = i;\\n                else\\n                    return false;\\n            }\\n        }\\n        \\n        if (index2 == -1)\\n            return false;\\n        \\n        return (s[index1] == goal[index2] && s[index2] == goal[index1]);\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def buddyStrings(self, s, goal):\\n        if len(s) != len(goal):\\n            return False\\n\\n        if s == goal:\\n            count = [0] * 26\\n\\n            for i in range(len(s)):\\n                c = ord(s[i]) - ord(\\'a\\')\\n                count[c] += 1\\n                if count[c] == 2:\\n                    return True\\n\\n            return False\\n\\n        index1 = -1\\n        index2 = -1\\n\\n        for i in range(len(s)):\\n            if s[i] != goal[i]:\\n                if index1 == -1:\\n                    index1 = i\\n                elif index2 == -1:\\n                    index2 = i\\n                else:\\n                    return False\\n\\n        if index2 == -1:\\n            return False\\n\\n        return s[index1] == goal[index2] and s[index2] == goal[index1]\\n        \\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length()!=goal.length()) return false;\\n        if(s.equals(goal)){\\n            int [] count = new int[26];\\n            int c;\\n            for(int i = 0;i<s.length();i++){\\n                c = s.charAt(i)-\\'a\\';\\n                count[c]++;\\n                if(count[c]==2)return true;\\n            }\\n            return false;\\n        }\\n        \\n        int index1 = -1;\\n        int index2 = -1;\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i) != goal.charAt(i)){\\n                if(index1 == -1) index1 = i;\\n                else if(index2 == -1) index2 = i;\\n                else return false;\\n            }\\n        }\\n        if(index2==-1) return false;\\n        return (s.charAt(index1) == goal.charAt(index2) && s.charAt(index2) == goal.charAt(index1));\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if (s.length() != goal.length())\\n            return false;\\n        \\n        if (s == goal) {\\n            vector<int> count(26, 0);\\n            \\n            for (int i = 0; i < s.length(); i++) {\\n                int c = s[i] - \\'a\\';\\n                count[c]++;\\n                if (count[c] == 2)\\n                    return true;\\n            }\\n            \\n            return false;\\n        }\\n        \\n        int index1 = -1;\\n        int index2 = -1;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] != goal[i]) {\\n                if (index1 == -1)\\n                    index1 = i;\\n                else if (index2 == -1)\\n                    index2 = i;\\n                else\\n                    return false;\\n            }\\n        }\\n        \\n        if (index2 == -1)\\n            return false;\\n        \\n        return (s[index1] == goal[index2] && s[index2] == goal[index1]);\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def buddyStrings(self, s, goal):\\n        if len(s) != len(goal):\\n            return False\\n\\n        if s == goal:\\n            count = [0] * 26\\n\\n            for i in range(len(s)):\\n                c = ord(s[i]) - ord(\\'a\\')\\n                count[c] += 1\\n                if count[c] == 2:\\n                    return True\\n\\n            return False\\n\\n        index1 = -1\\n        index2 = -1\\n\\n        for i in range(len(s)):\\n            if s[i] != goal[i]:\\n                if index1 == -1:\\n                    index1 = i\\n                elif index2 == -1:\\n                    index2 = i\\n                else:\\n                    return False\\n\\n        if index2 == -1:\\n            return False\\n\\n        return s[index1] == goal[index2] and s[index2] == goal[index1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 891255,
                "title": "c-best-simple-and-clear-explained-solution-o-n-o-1-faster-than-98",
                "content": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        // check same length\\n        if (A.size() != B.size()) \\n            return false;\\n        \\n        // if strings are equal - check if there is a double to swap\\n        if (A == B) { \\n            unordered_map<char, int> count;\\n            for (auto l:A){\\n                count[l]++;\\n                if (count[l] > 1)\\n                    return true;\\n            }\\n            return false;\\n        }\\n        \\n        // count differences between strings\\n        vector<int> diff;\\n        for (int i=0; i<A.size(); i++) {\\n            if (A[i] != B[i]) {\\n                diff.push_back(i);\\n                if (diff.size() > 2)\\n                    return false;\\n            }\\n        }\\n        // not exactly two differences\\n        if (diff.size() != 2)\\n            return false;\\n        \\n        // check if can be swapped\\n        if ((A[diff[0]] == B[diff[1]]) && (A[diff[1]] == B[diff[0]]))\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        // check same length\\n        if (A.size() != B.size()) \\n            return false;\\n        \\n        // if strings are equal - check if there is a double to swap\\n        if (A == B) { \\n            unordered_map<char, int> count;\\n            for (auto l:A){\\n                count[l]++;\\n                if (count[l] > 1)\\n                    return true;\\n            }\\n            return false;\\n        }\\n        \\n        // count differences between strings\\n        vector<int> diff;\\n        for (int i=0; i<A.size(); i++) {\\n            if (A[i] != B[i]) {\\n                diff.push_back(i);\\n                if (diff.size() > 2)\\n                    return false;\\n            }\\n        }\\n        // not exactly two differences\\n        if (diff.size() != 2)\\n            return false;\\n        \\n        // check if can be swapped\\n        if ((A[diff[0]] == B[diff[1]]) && (A[diff[1]] == B[diff[0]]))\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712600,
                "title": "python-3-solution-with-explanation-time-complexity-o-n",
                "content": "# Algorithm :\\n* if len(s) != len(goal) then return false\\n* if s and g are equal then:\\n    * If we have 2 same characters in string \\'s\\', we can swap them and still the strings will remain equal.\\n    * Otherwise, if we swap any two characters, it will make the strings unequal.\\n* Lastly we will iterate and check for 2 indexes in string s :\\n    * if we have at least 3 indices with different characters then, we can never make the strings equal with only one swap.\\n    * Also we can\\'t swap if the character at only one index is different.\\n    * We can only return true when all characters of both strings are the same except two indices.\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n# Video Explanation\\nhttps://youtu.be/t6Y8xY95gL4\\n# Code\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal):\\n            return False\\n        if s == goal :\\n            frequency = [0]*26\\n            for ch in s:\\n                frequency[ord(ch)-ord(\\'a\\')] += 1\\n                if frequency[ord(ch)-ord(\\'a\\')] == 2:\\n                    return True\\n            return False\\n        first_index = -1\\n        second_index = -1\\n        for i in range(len(s)):\\n            if s[i] != goal[i]:\\n                if first_index == -1:\\n                    first_index = i\\n                elif second_index == -1:\\n                    second_index = i\\n                else:\\n                    return False\\n        if second_index == -1:\\n            return False\\n        return s[first_index]==goal[second_index] and s[second_index] == goal[first_index]\\n```\\n#### Upvote if find this solution useful \\uD83D\\uDE01\\uD83D\\uDC4D\\uD83C\\uDFFB",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal):\\n            return False\\n        if s == goal :\\n            frequency = [0]*26\\n            for ch in s:\\n                frequency[ord(ch)-ord(\\'a\\')] += 1\\n                if frequency[ord(ch)-ord(\\'a\\')] == 2:\\n                    return True\\n            return False\\n        first_index = -1\\n        second_index = -1\\n        for i in range(len(s)):\\n            if s[i] != goal[i]:\\n                if first_index == -1:\\n                    first_index = i\\n                elif second_index == -1:\\n                    second_index = i\\n                else:\\n                    return False\\n        if second_index == -1:\\n            return False\\n        return s[first_index]==goal[second_index] and s[second_index] == goal[first_index]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661091,
                "title": "python-3-one-pass-solution",
                "content": "The code almost the same in both cases, **but**:\\nIn **1** variant logic for finding duplicate called at the end of execution, if the edge-case is happened.\\nIt\\'s also possible to use concise variant for checking duplicates like: ```len(s) == set(s)```, but it\\'s less optimal.\\nIn **2** variant duplicate value is searching in the first iteration, but not always will be used.\\n\\n```python3 []\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal):\\n            return False\\n\\n        # swapStage: 2 - not swapped, 1 - ready to swap, 0 - swapped\\n        swapStage, swapIdx = 2, None\\n        \\n        for i, (a, b) in enumerate(zip(s, goal)):\\n            if a != b:\\n                if swapStage == 2:\\n                    swapIdx, swapStage = i, 1\\n                elif swapStage == 1:\\n                    if a != goal[swapIdx] or b != s[swapIdx]: return False\\n                    swapStage = 0\\n                else: return False\\n        \\n        # need find any duplicate for case if all symbols are equal for two strings\\n        def isDuplicate():\\n            # len(s) == set(s)\\n            seen = set()\\n            for c in s:\\n                if c in seen: return True\\n                seen.add(c)\\n            return False\\n\\n        return swapStage == 0 or (swapStage == 2 and isDuplicate())\\n```\\n```python3 []\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal):\\n            return False\\n\\n        # swapStage: 2 - not swapped, 1 - ready to swap, 0 - swapped\\n        swapStage, swapIdx, isDup, seen = 2, None, False, set()\\n        \\n        # need find any duplicate for case if all symbols are equal for two strings\\n        def searchDuplicate(a):\\n            nonlocal isDup\\n            if isDup is False:\\n                if a not in seen:\\n                    seen.add(a)\\n                else:\\n                    isDup = True\\n                    seen.clear()\\n        \\n        for i, (a, b) in enumerate(zip(s, goal)):\\n            searchDuplicate(a)\\n            if a != b:\\n                if swapStage == 2:\\n                    swapIdx, swapStage = i, 1\\n                elif swapStage == 1:\\n                    if a != goal[swapIdx] or b != s[swapIdx]: return False\\n                    swapStage = 0\\n                else: return False\\n\\n        return swapStage == 0 or (swapStage == 2 and isDup)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```len(s) == set(s)```\n```python3 []\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal):\\n            return False\\n\\n        # swapStage: 2 - not swapped, 1 - ready to swap, 0 - swapped\\n        swapStage, swapIdx = 2, None\\n        \\n        for i, (a, b) in enumerate(zip(s, goal)):\\n            if a != b:\\n                if swapStage == 2:\\n                    swapIdx, swapStage = i, 1\\n                elif swapStage == 1:\\n                    if a != goal[swapIdx] or b != s[swapIdx]: return False\\n                    swapStage = 0\\n                else: return False\\n        \\n        # need find any duplicate for case if all symbols are equal for two strings\\n        def isDuplicate():\\n            # len(s) == set(s)\\n            seen = set()\\n            for c in s:\\n                if c in seen: return True\\n                seen.add(c)\\n            return False\\n\\n        return swapStage == 0 or (swapStage == 2 and isDuplicate())\\n```\n```python3 []\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal):\\n            return False\\n\\n        # swapStage: 2 - not swapped, 1 - ready to swap, 0 - swapped\\n        swapStage, swapIdx, isDup, seen = 2, None, False, set()\\n        \\n        # need find any duplicate for case if all symbols are equal for two strings\\n        def searchDuplicate(a):\\n            nonlocal isDup\\n            if isDup is False:\\n                if a not in seen:\\n                    seen.add(a)\\n                else:\\n                    isDup = True\\n                    seen.clear()\\n        \\n        for i, (a, b) in enumerate(zip(s, goal)):\\n            searchDuplicate(a)\\n            if a != b:\\n                if swapStage == 2:\\n                    swapIdx, swapStage = i, 1\\n                elif swapStage == 1:\\n                    if a != goal[swapIdx] or b != s[swapIdx]: return False\\n                    swapStage = 0\\n                else: return False\\n\\n        return swapStage == 0 or (swapStage == 2 and isDup)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 891209,
                "title": "python-solution-explained-beats-98-video-code",
                "content": "[](https://www.youtube.com/watch?v=5DNijHoMjzg)\\nhttps://www.youtube.com/watch?v=5DNijHoMjzg\\n```\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n        # goal: make one swap to A sp that A == B\\n        \\n        # length\\n        if len(A) != len(B):\\n            return False\\n        \\n        # A == B condition\\n        if A == B and len(set(A)) < len(A):\\n            return True\\n        \\n        # The length is same so now we check weather or not we can reach B by making a single swap\\n        differences = []\\n        for x in range(len(B)):\\n            if A[x] != B[x]:\\n                differences.append([A[x], B[x]])\\n\\n        if len(differences) == 2 and differences[0] == differences[-1][::-1]:\\n            return True\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n        # goal: make one swap to A sp that A == B\\n        \\n        # length\\n        if len(A) != len(B):\\n            return False\\n        \\n        # A == B condition\\n        if A == B and len(set(A)) < len(A):\\n            return True\\n        \\n        # The length is same so now we check weather or not we can reach B by making a single swap\\n        differences = []\\n        for x in range(len(B)):\\n            if A[x] != B[x]:\\n                differences.append([A[x], B[x]])\\n\\n        if len(differences) == 2 and differences[0] == differences[-1][::-1]:\\n            return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141838,
                "title": "javascript-straightforward",
                "content": "```\\nvar buddyStrings = function(A, B) {\\n    if (A.length != B.length) {\\n        return false;\\n    }\\n    let [dif, chars] = [[], new Set(A)];\\n    for (i in A) {\\n        if (A[i] != B[i]) {\\n            dif.push([A[i], B[i]]);\\n        }\\n    }\\n    return dif.length == 2 && dif[0].join() == dif[1].reverse().join() || (dif.length == 0 && chars.size != A.length);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar buddyStrings = function(A, B) {\\n    if (A.length != B.length) {\\n        return false;\\n    }\\n    let [dif, chars] = [[], new Set(A)];\\n    for (i in A) {\\n        if (A[i] != B[i]) {\\n            dif.push([A[i], B[i]]);\\n        }\\n    }\\n    return dif.length == 2 && dif[0].join() == dif[1].reverse().join() || (dif.length == 0 && chars.size != A.length);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 891362,
                "title": "step-by-step-explanation-of-logic-c-code",
                "content": "Base Cases:\\n* if length of both string is not same-----> return false\\n* if length of strings is less than 2--------> return false\\n\\nBoth strings are same initially\\n* search if any duplicate character present in string\\n\\nBoth strings are different initially\\n* search number of indexes where given strings have different character\\n* if there are two such indexes then check if it is possible that by swapping we make both strings same\\n\\n\\n```\\nclass Solution {\\npublic:\\n\\n    bool buddyStrings(string A, string B) {\\n        //Base Case\\n        if(A.size()!=B.size())         // if length of both strings are different\\n            return false;\\n        \\n        if(A.size()==0 || A.size()==1) // if length of strings is ess than 2 \\n            return false;\\n        \\n        // If both strings are same already then we search if any duplicate character present in string... \\n        if(A==B)\\n        {\\n            set<char> S(A.begin(),A.end());\\n            if(A.size()!=S.size())\\n                return true;\\n            return false;\\n        }\\n        \\n        //if both strings are not same initially then we search if there are two indexes which can be swapped to make both string same\\n        \\n        int first=-1;\\n        int second=-1;\\n        int diff=0;           //to store number of indexes having different character in given strings\\n        for(int i=0;i<A.size();i++)\\n        {\\n            if(A[i]!=B[i])\\n            {\\n                diff++;\\n                if(first==-1)\\n                    first=i;\\n                else if(second==-1)\\n                    second=i;\\n                \\n                if(diff>2)\\n                    return false;\\n            }\\n        }\\n        \\n        if(diff==2)             \\n        {\\n            if(A[first]==B[second] && A[second]==B[first])  // possible to make both string same by swap\\n                 return true;\\n        }\\n        return false;\\n    }\\n}; \\n```\\n\\n**If you like the soution , please Upvote...**\\n**Also comment if any modification required in solution.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool buddyStrings(string A, string B) {\\n        //Base Case\\n        if(A.size()!=B.size())         // if length of both strings are different\\n            return false;\\n        \\n        if(A.size()==0 || A.size()==1) // if length of strings is ess than 2 \\n            return false;\\n        \\n        // If both strings are same already then we search if any duplicate character present in string... \\n        if(A==B)\\n        {\\n            set<char> S(A.begin(),A.end());\\n            if(A.size()!=S.size())\\n                return true;\\n            return false;\\n        }\\n        \\n        //if both strings are not same initially then we search if there are two indexes which can be swapped to make both string same\\n        \\n        int first=-1;\\n        int second=-1;\\n        int diff=0;           //to store number of indexes having different character in given strings\\n        for(int i=0;i<A.size();i++)\\n        {\\n            if(A[i]!=B[i])\\n            {\\n                diff++;\\n                if(first==-1)\\n                    first=i;\\n                else if(second==-1)\\n                    second=i;\\n                \\n                if(diff>2)\\n                    return false;\\n            }\\n        }\\n        \\n        if(diff==2)             \\n        {\\n            if(A[first]==B[second] && A[second]==B[first])  // possible to make both string same by swap\\n                 return true;\\n        }\\n        return false;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 141935,
                "title": "very-simple-python-solution-with-detailed-explanation-o-n-time-o-n-space-with-40-ms-runtime",
                "content": "Hey guys, I thought my solution was pretty good so I decided to share it with an explanation of how it works. I numbered each part so it\\'d be easier to follow. When I refer to \"N\", I mean the length of A and B (since they\\'re the same). Please leave any feedback on my code or explanation in the comments!  \\n\\t\\n        # 1\\n        if len(A) != len(B):\\n            return False\\n        \\n        # 2\\n        differences = 0\\n        differentIndices = [-1, -1]\\n        differentIndicesCur = 0\\n        for i in range(len(A)):\\n            if A[i] != B[i]:\\n                differentIndices[differentIndicesCur % 2] = i\\n                differentIndicesCur += 1\\n                differences += 1\\n\\n        if differences > 2 or differences == 1:\\n            return False\\n        # 3\\n        elif differences == 2:\\n            return A[differentIndices[0]] == B[differentIndices[1]] and B[differentIndices[0]] == A[differentIndices[1]]\\n        # 4\\n        else:\\n            return len(set(A)) != len(A)\\n\\t\\t\\t\\t\\t\\t\\n#1: If the length of the arrays is unequal, then obviously we won\\'t be able to make the arrays equal without adding or removing a character. We\\'re limited to swapping two characters exactly one time, so this is out of our scope and results in immediate failure. O(1) time and space.\\n\\n#2: A simple run through the array, marking how many differences we encounter along the way. We do this because it is only possible to return \"true\" if there are either **two differences or no differences**. If there is only one difference, then every character is the same between both strings at every index except for one; moving the character at this index to some other index would ruin the equality of the target index, so it is impossible to do. We\\'re only allowed to swap two characters, so obviously if there are three or more differences we have no shot of making them equal. O(N) time, O(1) space.\\n*(06-26-18 update) Additionally, I save two numbers in a 2-array called \"differentIndices\" - as you might expect, this is where I save the indices where A and B differ. This is still O(1) space because the size of the array doesn\\'t depend on any variable - it\\'s always size 2. The reason I only worry about two indices is because, like I said, we\\'ll return false if there are more than two differences anyway.*\\n\\n#3: **(UPDATED 06-26-2018)** Previously, I checked `set(A) == set(B)` here - however, user MonnaGotIt mentioned that `A = \"abcaa\"` and `B = \"abcbb\"` would incorrectly return true at this juncture, so it needed to be changed. Instead, I take the two indices I recorded earlier (both will be initialized to something other than -1 since `differences` is equal to 2 here), and I make sure the characters would be equal if they were swapped. It\\'s not sufficient to just check `A[differentIndices[0]] == B[differentIndices[1]]` or `B[differentIndices[0]] == A[differentIndices[1]]`, because then `A = \"abcab\"` and `B = \"abcbb\"` would incorrectly return true. They must both be checked. O(1) time, O(1) space.\\n`set(A) == set(B)` is what I had before, and it was O(N) time and O(1) space. More specifically, it was O(3N) time - O(N) to make a set out of A, O(N) to make a set out of B, and O(N) to compare the two in the worst case. Thanks to MonnaGotIt for pointing out the issue with this line.\\n\\n#4: Finally, if there are no differences between A and B (the strings are equal), we can only return true if there\\'s at least one character in A and B that repeats at least once. It doesn\\'t matter how many times it repeats or how many characters repeat, but we need to be able to make a meaningless change if we return true. For example, in `A = B = \\'aabacd\\'`, we can swap any of the two \\'a\\' and return true. However, in `A = B = abcd`, swapping any character would result in the strings losing their equality, so we return false. We check this by comparing the length of set(A) and A: like I said before, converting A to a set will remove all duplicate elements. Therefore, if any duplicate element exists in A, the length of set(A) will be less than the length of A. In this case, we return true. If they\\'re equal, then there were no duplicates in A whatsoever, and we return false. O(N) time, O(N) space.\\n\\nThat\\'s about the size of it. I feel like I went way overkill on this explanation, but sometimes that\\'s helpful for people who are lost. Let me know if you thought it was helpful, if there\\'s anything confusing or unclear about my explanation, or if I got anything wrong. Thanks for reading!",
                "solutionTags": [],
                "code": "Hey guys, I thought my solution was pretty good so I decided to share it with an explanation of how it works. I numbered each part so it\\'d be easier to follow. When I refer to \"N\", I mean the length of A and B (since they\\'re the same). Please leave any feedback on my code or explanation in the comments!  \\n\\t\\n        # 1\\n        if len(A) != len(B):\\n            return False\\n        \\n        # 2\\n        differences = 0\\n        differentIndices = [-1, -1]\\n        differentIndicesCur = 0\\n        for i in range(len(A)):\\n            if A[i] != B[i]:\\n                differentIndices[differentIndicesCur % 2] = i\\n                differentIndicesCur += 1\\n                differences += 1\\n\\n        if differences > 2 or differences == 1:\\n            return False\\n        # 3\\n        elif differences == 2:\\n            return A[differentIndices[0]] == B[differentIndices[1]] and B[differentIndices[0]] == A[differentIndices[1]]\\n        # 4\\n        else:\\n            return len(set(A)) != len(A)\\n\\t\\t\\t\\t\\t\\t\\n#1: If the length of the arrays is unequal, then obviously we won\\'t be able to make the arrays equal without adding or removing a character. We\\'re limited to swapping two characters exactly one time, so this is out of our scope and results in immediate failure. O(1) time and space.\\n\\n#2: A simple run through the array, marking how many differences we encounter along the way. We do this because it is only possible to return \"true\" if there are either **two differences or no differences**. If there is only one difference, then every character is the same between both strings at every index except for one; moving the character at this index to some other index would ruin the equality of the target index, so it is impossible to do. We\\'re only allowed to swap two characters, so obviously if there are three or more differences we have no shot of making them equal. O(N) time, O(1) space.\\n*(06-26-18 update) Additionally, I save two numbers in a 2-array called \"differentIndices\" - as you might expect, this is where I save the indices where A and B differ. This is still O(1) space because the size of the array doesn\\'t depend on any variable - it\\'s always size 2. The reason I only worry about two indices is because, like I said, we\\'ll return false if there are more than two differences anyway.*\\n\\n#3: **(UPDATED 06-26-2018)** Previously, I checked `set(A) == set(B)` here - however, user MonnaGotIt mentioned that `A = \"abcaa\"` and `B = \"abcbb\"` would incorrectly return true at this juncture, so it needed to be changed. Instead, I take the two indices I recorded earlier (both will be initialized to something other than -1 since `differences` is equal to 2 here), and I make sure the characters would be equal if they were swapped. It\\'s not sufficient to just check `A[differentIndices[0]] == B[differentIndices[1]]` or `B[differentIndices[0]] == A[differentIndices[1]]`, because then `A = \"abcab\"` and `B = \"abcbb\"` would incorrectly return true. They must both be checked. O(1) time, O(1) space.\\n`set(A) == set(B)` is what I had before, and it was O(N) time and O(1) space. More specifically, it was O(3N) time - O(N) to make a set out of A, O(N) to make a set out of B, and O(N) to compare the two in the worst case. Thanks to MonnaGotIt for pointing out the issue with this line.\\n\\n#4: Finally, if there are no differences between A and B (the strings are equal), we can only return true if there\\'s at least one character in A and B that repeats at least once. It doesn\\'t matter how many times it repeats or how many characters repeat, but we need to be able to make a meaningless change if we return true. For example, in `A = B = \\'aabacd\\'`, we can swap any of the two \\'a\\' and return true. However, in `A = B = abcd`, swapping any character would result in the strings losing their equality, so we return false. We check this by comparing the length of set(A) and A: like I said before, converting A to a set will remove all duplicate elements. Therefore, if any duplicate element exists in A, the length of set(A) will be less than the length of A. In this case, we return true. If they\\'re equal, then there were no duplicates in A whatsoever, and we return false. O(N) time, O(N) space.\\n\\nThat\\'s about the size of it. I feel like I went way overkill on this explanation, but sometimes that\\'s helpful for people who are lost. Let me know if you thought it was helpful, if there\\'s anything confusing or unclear about my explanation, or if I got anything wrong. Thanks for reading!",
                "codeTag": "Unknown"
            },
            {
                "id": 3711393,
                "title": "simple-o-n-solution-passed-99-1-ms-o-1-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        char a=\\'a\\',b=\\'a\\';\\n        int count=0;\\n        int [] chars=new int [26];\\n        char [] schar=s.toCharArray();\\n        char [] goalchar=goal.toCharArray();\\n        if(s.length()!=goal.length()) return false;\\n        for(int i=0;i<schar.length;i++)\\n        {\\n            chars[schar[i]-\\'a\\']++;\\n            if(schar[i]!=goalchar[i])\\n            {\\n                if(count==0)\\n                {\\n                    a=schar[i];\\n                    b=goalchar[i];\\n                    count++;\\n                }\\n                else if(a==goalchar[i] && b==schar[i])\\n                    count++;\\n\\n                //if more than 1 swap occurs then return false\\n                else return false;\\n                } \\n            }\\n        }\\n       \\n        if(count==0)\\n            for(int i:chars) \\n              if(i>1) return true;\\n        \\n\\n        return count==2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        char a=\\'a\\',b=\\'a\\';\\n        int count=0;\\n        int [] chars=new int [26];\\n        char [] schar=s.toCharArray();\\n        char [] goalchar=goal.toCharArray();\\n        if(s.length()!=goal.length()) return false;\\n        for(int i=0;i<schar.length;i++)\\n        {\\n            chars[schar[i]-\\'a\\']++;\\n            if(schar[i]!=goalchar[i])\\n            {\\n                if(count==0)\\n                {\\n                    a=schar[i];\\n                    b=goalchar[i];\\n                    count++;\\n                }\\n                else if(a==goalchar[i] && b==schar[i])\\n                    count++;\\n\\n                //if more than 1 swap occurs then return false\\n                else return false;\\n                } \\n            }\\n        }\\n       \\n        if(count==0)\\n            for(int i:chars) \\n              if(i>1) return true;\\n        \\n\\n        return count==2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710526,
                "title": "beats-100-c-python-solutions-using-frequency-table-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem may appear simple at first, but it is more complex than a textbook example. It involves handling several edge cases and considering various scenarios. There are multiple cases that need to be carefully checked.\\n1. check the lengths of both s & goal\\n2. Set some variables: diff denotes  the number of different places. The array freq is the table for  the frequency of  26 alphabets in word s. hasDuplicates denotes whether s has duplicates for any character and needSwap is the array for the indexes need swap\\n3.  Proceed the iteration and check\\n4. According to each different case to determine whether s is convertible to goal or not.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(1)$\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int len=s.size(), glen=goal.size();\\n        if (len!=glen) return 0;\\n        int diff=0;\\n        vector<int> freq(26, 0);\\n        bool hasDuplicates=0;\\n        vector<int> needSwap;\\n        for(int i=0; i<len; i++){\\n            if (s[i]!=goal[i]){\\n                 diff++;\\n                 needSwap.push_back(i);\\n            }\\n            freq[s[i]-\\'a\\']++;\\n            if (!hasDuplicates &&freq[s[i]-\\'a\\']>=2) \\n                hasDuplicates=1;\\n        }\\n        if (s==goal && hasDuplicates) return 1;\\n        if (s!=goal && diff==2){\\n            swap(s[needSwap[0]], s[needSwap[1]]);\\n            if (s==goal) return 1;\\n            else return 0;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        l=len(s)\\n        glen=len(goal)\\n        if l!=glen: return 0\\n        diff=0\\n        freq=[0]*26\\n        hasDuplicates=False\\n        needSwap=[]\\n        for i in range(l):\\n            if s[i]!=goal[i]:\\n                diff+=1\\n                needSwap.append(i)\\n            freq[ord(s[i])-ord(\\'a\\')]+=1\\n            if hasDuplicates==False and freq[ord(s[i])-ord(\\'a\\')]>=2:\\n                hasDuplicates=True\\n        if s==goal and hasDuplicates: return True\\n        if s!=goal and diff==2:\\n            slist = list(s)\\n            # Swap the characters at the indices stored in needSwap\\n            slist[needSwap[0]], slist[needSwap[1]]=slist[needSwap[1]], slist[needSwap[0]]\\n            # Convert s_list back to a string\\n            s = \"\".join(slist)\\n\\n            if s==goal: return 1\\n            else: return 0\\n        return 0\\n```\\n\\n# Code with Explanation in Comments\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        // Get the lengths of the input strings\\n        int len = s.size();\\n        int glen = goal.size();\\n        \\n        // If the lengths are different, return false\\n        if (len != glen)\\n            return 0;\\n        \\n        // Initialize a variable to keep track of the number of differences between s and goal\\n        int diff = 0;\\n        \\n        // Initialize a frequency array to count the occurrences of each character in s\\n        vector<int> freq(26, 0);\\n        \\n        // Initialize a flag to check if s has any duplicate characters\\n        bool hasDuplicates = 0;\\n        \\n        // Initialize a vector to store the indices where characters need to be swapped\\n        vector<int> needSwap;\\n        \\n        // Iterate over the characters of s and goal\\n        for(int i = 0; i < len; i++){\\n            // If the characters at the current position are different, increment the difference count\\n            // and add the index to the needSwap vector\\n            if (s[i] != goal[i]){\\n                diff++;\\n                needSwap.push_back(i);\\n            }\\n            \\n            // Increment the frequency of the current character in s\\n            freq[s[i]-\\'a\\']++;\\n            \\n            // If there are no duplicates yet and the frequency of the current character is 2 or more,\\n            // set the hasDuplicates flag to true\\n            if (!hasDuplicates && freq[s[i]-\\'a\\'] >= 2) \\n                hasDuplicates = 1;\\n        }\\n        \\n        // If s is equal to goal and it has duplicates, return true\\n        if (s == goal && hasDuplicates)\\n            return 1;\\n        \\n        // If s is not equal to goal and there are exactly 2 differences, try swapping the characters\\n        if (s != goal && diff == 2){\\n            // Swap the characters at the indices stored in needSwap\\n            swap(s[needSwap[0]], s[needSwap[1]]);\\n            \\n            // If the resulting string is equal to goal, return true\\n            if (s == goal)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        \\n        // If none of the above conditions are satisfied, return false\\n        return 0;\\n    }\\n};\\n\\n```\\n# Optimized Code runtime 0 ms beats 100%\\nThe code utilizes an unordered_set called alphabet to quickly check for duplicates in s when s == goal. If duplicates are found or if s has more characters than the size of alphabet, the function returns true.\\n\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int len = s.size(), glen = goal.size();        \\n        // If the lengths are different, return false\\n        if (len != glen)\\n            return 0;       \\n        if (s == goal) {\\n            unordered_set<char> alphabet;\\n            for (char c : s) {\\n                if (alphabet.count(c) > 0)\\n                    return true;\\n                else\\n                    alphabet.insert(c);\\n            }\\n            return s.size() > alphabet.size();\\n        } \\n        else {\\n            int diff = 0;\\n            vector<int> needSwap;\\n            for (int i = 0; i < len; i++) {\\n                if (s[i] != goal[i]) {\\n                    diff++;\\n                    needSwap.push_back(i);\\n                }\\n            }           \\n            //If there are more than two differences, or no differences, return false\\n            if (diff != 2)\\n                return 0;          \\n            swap(s[needSwap[0]], s[needSwap[1]]);          \\n            if (s == goal)\\n                return 1;\\n            else\\n                return 0;\\n        }       \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int len=s.size(), glen=goal.size();\\n        if (len!=glen) return 0;\\n        int diff=0;\\n        vector<int> freq(26, 0);\\n        bool hasDuplicates=0;\\n        vector<int> needSwap;\\n        for(int i=0; i<len; i++){\\n            if (s[i]!=goal[i]){\\n                 diff++;\\n                 needSwap.push_back(i);\\n            }\\n            freq[s[i]-\\'a\\']++;\\n            if (!hasDuplicates &&freq[s[i]-\\'a\\']>=2) \\n                hasDuplicates=1;\\n        }\\n        if (s==goal && hasDuplicates) return 1;\\n        if (s!=goal && diff==2){\\n            swap(s[needSwap[0]], s[needSwap[1]]);\\n            if (s==goal) return 1;\\n            else return 0;\\n        }\\n        return 0;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        l=len(s)\\n        glen=len(goal)\\n        if l!=glen: return 0\\n        diff=0\\n        freq=[0]*26\\n        hasDuplicates=False\\n        needSwap=[]\\n        for i in range(l):\\n            if s[i]!=goal[i]:\\n                diff+=1\\n                needSwap.append(i)\\n            freq[ord(s[i])-ord(\\'a\\')]+=1\\n            if hasDuplicates==False and freq[ord(s[i])-ord(\\'a\\')]>=2:\\n                hasDuplicates=True\\n        if s==goal and hasDuplicates: return True\\n        if s!=goal and diff==2:\\n            slist = list(s)\\n            # Swap the characters at the indices stored in needSwap\\n            slist[needSwap[0]], slist[needSwap[1]]=slist[needSwap[1]], slist[needSwap[0]]\\n            # Convert s_list back to a string\\n            s = \"\".join(slist)\\n\\n            if s==goal: return 1\\n            else: return 0\\n        return 0\\n```\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        // Get the lengths of the input strings\\n        int len = s.size();\\n        int glen = goal.size();\\n        \\n        // If the lengths are different, return false\\n        if (len != glen)\\n            return 0;\\n        \\n        // Initialize a variable to keep track of the number of differences between s and goal\\n        int diff = 0;\\n        \\n        // Initialize a frequency array to count the occurrences of each character in s\\n        vector<int> freq(26, 0);\\n        \\n        // Initialize a flag to check if s has any duplicate characters\\n        bool hasDuplicates = 0;\\n        \\n        // Initialize a vector to store the indices where characters need to be swapped\\n        vector<int> needSwap;\\n        \\n        // Iterate over the characters of s and goal\\n        for(int i = 0; i < len; i++){\\n            // If the characters at the current position are different, increment the difference count\\n            // and add the index to the needSwap vector\\n            if (s[i] != goal[i]){\\n                diff++;\\n                needSwap.push_back(i);\\n            }\\n            \\n            // Increment the frequency of the current character in s\\n            freq[s[i]-\\'a\\']++;\\n            \\n            // If there are no duplicates yet and the frequency of the current character is 2 or more,\\n            // set the hasDuplicates flag to true\\n            if (!hasDuplicates && freq[s[i]-\\'a\\'] >= 2) \\n                hasDuplicates = 1;\\n        }\\n        \\n        // If s is equal to goal and it has duplicates, return true\\n        if (s == goal && hasDuplicates)\\n            return 1;\\n        \\n        // If s is not equal to goal and there are exactly 2 differences, try swapping the characters\\n        if (s != goal && diff == 2){\\n            // Swap the characters at the indices stored in needSwap\\n            swap(s[needSwap[0]], s[needSwap[1]]);\\n            \\n            // If the resulting string is equal to goal, return true\\n            if (s == goal)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        \\n        // If none of the above conditions are satisfied, return false\\n        return 0;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int len = s.size(), glen = goal.size();        \\n        // If the lengths are different, return false\\n        if (len != glen)\\n            return 0;       \\n        if (s == goal) {\\n            unordered_set<char> alphabet;\\n            for (char c : s) {\\n                if (alphabet.count(c) > 0)\\n                    return true;\\n                else\\n                    alphabet.insert(c);\\n            }\\n            return s.size() > alphabet.size();\\n        } \\n        else {\\n            int diff = 0;\\n            vector<int> needSwap;\\n            for (int i = 0; i < len; i++) {\\n                if (s[i] != goal[i]) {\\n                    diff++;\\n                    needSwap.push_back(i);\\n                }\\n            }           \\n            //If there are more than two differences, or no differences, return false\\n            if (diff != 2)\\n                return 0;          \\n            swap(s[needSwap[0]], s[needSwap[1]]);          \\n            if (s == goal)\\n                return 1;\\n            else\\n                return 0;\\n        }       \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682224,
                "title": "java-simple-explained",
                "content": "**Idea:**\\n* If strings are inequal in lengths, they\\'re not buddies\\n* If strings are the same, they\\'re buddies if it has duplicate chars which can be swapped\\n* For all other cases, there should be exactly 2 different chars and they swap to be make the strings equal\\n> **T/S:** O(n)/O(1), where n = size(s)\\n```\\npublic boolean buddyStrings(String s, String goal) {\\n\\tif (s.length() != goal.length())\\n\\t\\treturn false;\\n\\tif (s.equals(goal) && hasDuplicateChars(s))\\n\\t\\treturn true;\\n\\n\\tvar diffs = findDiffs(s, goal);\\n\\treturn diffs.size() == 2 &&\\n\\t\\t   s.charAt(diffs.getFirst()) == goal.charAt(diffs.getLast()) &&\\n\\t\\t   s.charAt(diffs.getLast()) == goal.charAt(diffs.getFirst());\\n}\\n\\nprivate boolean hasDuplicateChars(String s) {\\n\\tvar chars = new HashSet<Character>();\\n\\treturn IntStream.range(0, s.length())\\n\\t\\t\\t\\t\\t.anyMatch(i -> !chars.add(s.charAt(i)));\\n}\\n\\nprivate Deque<Integer> findDiffs(String s, String goal) {\\n\\tvar diffs = new ArrayDeque<Integer>();\\n\\n\\tfor (var i = 0; i < s.length(); i++)\\n\\t\\tif (s.charAt(i) != goal.charAt(i)) {\\n\\t\\t\\tdiffs.add(i);\\n\\t\\t\\tif (diffs.size() > 2)\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\treturn diffs;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean buddyStrings(String s, String goal) {\\n\\tif (s.length() != goal.length())\\n\\t\\treturn false;\\n\\tif (s.equals(goal) && hasDuplicateChars(s))\\n\\t\\treturn true;\\n\\n\\tvar diffs = findDiffs(s, goal);\\n\\treturn diffs.size() == 2 &&\\n\\t\\t   s.charAt(diffs.getFirst()) == goal.charAt(diffs.getLast()) &&\\n\\t\\t   s.charAt(diffs.getLast()) == goal.charAt(diffs.getFirst());\\n}\\n\\nprivate boolean hasDuplicateChars(String s) {\\n\\tvar chars = new HashSet<Character>();\\n\\treturn IntStream.range(0, s.length())\\n\\t\\t\\t\\t\\t.anyMatch(i -> !chars.add(s.charAt(i)));\\n}\\n\\nprivate Deque<Integer> findDiffs(String s, String goal) {\\n\\tvar diffs = new ArrayDeque<Integer>();\\n\\n\\tfor (var i = 0; i < s.length(); i++)\\n\\t\\tif (s.charAt(i) != goal.charAt(i)) {\\n\\t\\t\\tdiffs.add(i);\\n\\t\\t\\tif (diffs.size() > 2)\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\treturn diffs;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 890967,
                "title": "buddy-strings-java-c-kotlin-o-n",
                "content": "1. If the lengths are not equal, return false\\n2. If the two strings are not the same, there must be only two positions that the char are different and they can be swapped.\\n3. If the two strings are the same, we need to find a duplicate character. \\n\\nNote: \\n1. For 3, if the string length is greater than **26**, it must be **true** and no need to check. \\n2. I don\\'t use set or list to reduce the unnecessary overhead\\n3. Adding a Kotlin solution.  I am kind of new to Kotlin and welcome to all suggestions. \\n\\nIf you like it, please upvote it. Thanks.\\n\\n**java**\\n```\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        if (A.length() != B.length() || A.isEmpty()) return false;\\n        \\n        if (!A.equals(B))\\n        {\\n            int count = 0;\\n\\t\\t\\t// The value doesn\\'t matter. If no initial value, the compiler will complain\\n            char first = \\'a\\', second = \\'a\\';\\n            for (int i = 0; i < A.length(); i++)\\n            {\\n                if (A.charAt(i) == B.charAt(i)) continue;\\n                if (count >= 2) return false;\\n                if (count == 0)\\n                {\\n                    first = A.charAt(i);\\n                    second = B.charAt(i);\\n                    count++;\\n                    continue;\\n                }\\n                if (A.charAt(i) != second || B.charAt(i) != first) return false;\\n                count++;\\n            }\\n            return count == 2;\\n        }\\n\\n        // there must be at least one duplicated char if the length is greater than 26\\n        if (A.length() > 26) return true;\\n        int [] fre = new int[26];\\n        for (char c : A.toCharArray())\\n        {\\n            if (fre[c-\\'a\\'] == 1) return true;\\n            fre[c-\\'a\\']++;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n**c++**\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        if (A.size() != B.size() || A.empty()) return false;\\n        \\n        if (A != B)\\n        {\\n            int count = 0;\\n            char first = \\'a\\', second = \\'a\\';\\n            for (int i = 0; i < A.size(); i++)\\n            {\\n                if (A[i] == B[i]) continue;\\n                if (count >= 2) return false;\\n                if (count == 0)\\n                {\\n                    first = A[i];\\n                    second = B[i];\\n                    count++;\\n                    continue;\\n                }\\n                if (A[i] != second || B[i] != first) return false;\\n                count++;\\n            }\\n            return count == 2;\\n        }\\n        \\n        // there must be at least one duplicated char if the length is greater than 26\\n        if (A.size() > 26) return true;\\n        int freq[26] = {};\\n        for (auto c: A)\\n        {\\n            if (freq[c - \\'a\\'] == 1) return true;\\n            freq[c - \\'a\\'] = 1;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n**kotlin**\\n```\\nclass Solution {\\n    fun buddyStrings(A: String, B: String): Boolean {\\n        if (A.length != B.length || A.isEmpty()) return false\\n        if (A != B)\\n        {\\n            var count = 0;\\n            var first = \\'a\\'\\n            var second = \\'a\\'\\n            for (i in A.indices)\\n            {\\n                if (A[i] == B[i]) continue;\\n                if (count >= 2) return false;\\n                if (count == 0)\\n                {\\n                    first = A[i];\\n                    second = B[i];\\n                    count++;\\n                    continue;\\n                }\\n                if (A[i] != second || B[i] != first) return false;\\n                count++;\\n            }\\n            return count == 2;\\n        }\\n        if (A.length > 26) return true;\\n        var fre = Array(26){0};\\n        for (i in A.indices)\\n        {\\n            if (fre[A[i]-\\'a\\'] == 1) return true;\\n            fre[A[i] - \\'a\\']++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        if (A.length() != B.length() || A.isEmpty()) return false;\\n        \\n        if (!A.equals(B))\\n        {\\n            int count = 0;\\n\\t\\t\\t// The value doesn\\'t matter. If no initial value, the compiler will complain\\n            char first = \\'a\\', second = \\'a\\';\\n            for (int i = 0; i < A.length(); i++)\\n            {\\n                if (A.charAt(i) == B.charAt(i)) continue;\\n                if (count >= 2) return false;\\n                if (count == 0)\\n                {\\n                    first = A.charAt(i);\\n                    second = B.charAt(i);\\n                    count++;\\n                    continue;\\n                }\\n                if (A.charAt(i) != second || B.charAt(i) != first) return false;\\n                count++;\\n            }\\n            return count == 2;\\n        }\\n\\n        // there must be at least one duplicated char if the length is greater than 26\\n        if (A.length() > 26) return true;\\n        int [] fre = new int[26];\\n        for (char c : A.toCharArray())\\n        {\\n            if (fre[c-\\'a\\'] == 1) return true;\\n            fre[c-\\'a\\']++;\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        if (A.size() != B.size() || A.empty()) return false;\\n        \\n        if (A != B)\\n        {\\n            int count = 0;\\n            char first = \\'a\\', second = \\'a\\';\\n            for (int i = 0; i < A.size(); i++)\\n            {\\n                if (A[i] == B[i]) continue;\\n                if (count >= 2) return false;\\n                if (count == 0)\\n                {\\n                    first = A[i];\\n                    second = B[i];\\n                    count++;\\n                    continue;\\n                }\\n                if (A[i] != second || B[i] != first) return false;\\n                count++;\\n            }\\n            return count == 2;\\n        }\\n        \\n        // there must be at least one duplicated char if the length is greater than 26\\n        if (A.size() > 26) return true;\\n        int freq[26] = {};\\n        for (auto c: A)\\n        {\\n            if (freq[c - \\'a\\'] == 1) return true;\\n            freq[c - \\'a\\'] = 1;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun buddyStrings(A: String, B: String): Boolean {\\n        if (A.length != B.length || A.isEmpty()) return false\\n        if (A != B)\\n        {\\n            var count = 0;\\n            var first = \\'a\\'\\n            var second = \\'a\\'\\n            for (i in A.indices)\\n            {\\n                if (A[i] == B[i]) continue;\\n                if (count >= 2) return false;\\n                if (count == 0)\\n                {\\n                    first = A[i];\\n                    second = B[i];\\n                    count++;\\n                    continue;\\n                }\\n                if (A[i] != second || B[i] != first) return false;\\n                count++;\\n            }\\n            return count == 2;\\n        }\\n        if (A.length > 26) return true;\\n        var fre = Array(26){0};\\n        for (i in A.indices)\\n        {\\n            if (fre[A[i]-\\'a\\'] == 1) return true;\\n            fre[A[i] - \\'a\\']++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711799,
                "title": "python-one-liner-beginner-friendly-simple",
                "content": "# Code\\n```\\ndic = [[a,b] for a,b in zip(s,goal) if a!=b]        \\nreturn len(s)==len(goal) and (len(dic)==2 and dic[0][0]==dic[1][1] and dic[1][0]==dic[0][1] or (len(dic)==0 and len(set(s))<len(goal)))\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/4ff36693-09e4-4f10-94fb-43169f427dbc_1688372006.5884976.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndic = [[a,b] for a,b in zip(s,goal) if a!=b]        \\nreturn len(s)==len(goal) and (len(dic)==2 and dic[0][0]==dic[1][1] and dic[1][0]==dic[0][1] or (len(dic)==0 and len(set(s))<len(goal)))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3710430,
                "title": "java-frequency-check",
                "content": "## If it was helpful please upvote for motivation*\\n**Java Solution if you need explanation please let me know!!**\\n\\n![image](https://assets.leetcode.com/users/images/19e57c4e-6995-46cc-bb07-29ac3c579ed5_1688345204.5127478.jpeg)\\n\\n\\n```\\nclass Solution {\\n    public boolean buddyStrings(String str, String goal) {\\n        if (str.length() != goal.length()) {\\n            return false;\\n        }\\n        if (str.equals(goal)) {\\n            int[] frequency = new int[26];\\n            for (char ch : str.toCharArray()) {\\n                frequency[ch - \\'a\\']++;\\n                if (frequency[ch - \\'a\\'] == 2) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        int f = -1;\\n        int s = -1;\\n        for (int i = 0; i < str.length(); ++i) {\\n            if (str.charAt(i) != goal.charAt(i)) {\\n                if (f == -1) {\\n                    f = i;\\n                } \\n                else if (s == -1) {\\n                    s = i;\\n                } \\n                else {\\n                    return false;\\n                }\\n            }\\n        }\\n        if (s == -1) {\\n            return false;\\n        }\\n        boolean ans = str.charAt(f) == goal.charAt(s) && str.charAt(s) == goal.charAt(f);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String str, String goal) {\\n        if (str.length() != goal.length()) {\\n            return false;\\n        }\\n        if (str.equals(goal)) {\\n            int[] frequency = new int[26];\\n            for (char ch : str.toCharArray()) {\\n                frequency[ch - \\'a\\']++;\\n                if (frequency[ch - \\'a\\'] == 2) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        int f = -1;\\n        int s = -1;\\n        for (int i = 0; i < str.length(); ++i) {\\n            if (str.charAt(i) != goal.charAt(i)) {\\n                if (f == -1) {\\n                    f = i;\\n                } \\n                else if (s == -1) {\\n                    s = i;\\n                } \\n                else {\\n                    return false;\\n                }\\n            }\\n        }\\n        if (s == -1) {\\n            return false;\\n        }\\n        boolean ans = str.charAt(f) == goal.charAt(s) && str.charAt(s) == goal.charAt(f);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234318,
                "title": "easiest-ever-python",
                "content": "```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n\\n        count = 0\\n        k=[]\\n        if len(s)!= len(goal): return False\\n        for i in range(len(s)):\\n            if s[i]!= goal[i]:\\n                count +=1\\n                k.append(i)\\n                    \\n        if count >2 : return False\\n        elif count == 2 and s[k[0]] == goal[k[1]] and s[k[1]] == goal[k[0]]: return True\\n            \\n        elif count == 0 and len(set(s)) < len(s): return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n\\n        count = 0\\n        k=[]\\n        if len(s)!= len(goal): return False\\n        for i in range(len(s)):\\n            if s[i]!= goal[i]:\\n                count +=1\\n                k.append(i)\\n                    \\n        if count >2 : return False\\n        elif count == 2 and s[k[0]] == goal[k[1]] and s[k[1]] == goal[k[0]]: return True\\n            \\n        elif count == 0 and len(set(s)) < len(s): return True",
                "codeTag": "Java"
            },
            {
                "id": 753270,
                "title": "java-2ms-beats-79-by-counting-number-of-mismatches-and-what-characters-are-mismatched",
                "content": "```\\nclass Solution {\\n  public boolean buddyStrings(String A, String B) {\\n    \\n    // strategy: count the Character mismatches between the Strings, and see whether the mismatch can be fixed by a swap\\n\\n    /*\\n    Runtime: 2 ms, faster than 78.62% of Java online submissions for Buddy Strings.\\n    Memory Usage: 39.5 MB, less than 30.81% of Java online submissions for Buddy Strings.\\n    */\\n\\n    // edge case: one or more input Strings are empty\\n    if (A.length() == 0 || B.length() == 0) {\\n      return false; // no swap is possible with empty strings\\n    }\\n\\n    // edge case: input Strings are different lengths\\n    if (A.length() != B.length()) {\\n      return false; // Strings of different length can\\'t be made equal with a Character swap\\n    }\\n\\n    List<Character> charactersInMismatchesInA = new ArrayList<>();\\n    List<Character> charactersInMismatchesInB = new ArrayList<>();\\n    for (int index = 0; index < A.length(); ++index) {\\n      if (A.charAt(index) != B.charAt(index)) {\\n        charactersInMismatchesInA.add(A.charAt(index));\\n        charactersInMismatchesInB.add(B.charAt(index));\\n      }\\n    }\\n\\n    int numberOfMismatches = charactersInMismatchesInA.size();\\n\\n    switch(numberOfMismatches) {\\n      case 0:\\n        // identical Strings, but check whether we have two occurrences of same Character that we can swap\\n        Set<Character> s = new HashSet<>();\\n        for (char c : A.toCharArray()) {\\n          if (s.contains(c)) { // if Set already contains this Character, then String contains 2, so return true\\n            return true;\\n          } else {\\n            s.add(c); // add Character to Set in case we see another one later in String\\n          }\\n        }\\n        return false; // Strings A and B are equal, and there are no duplicate letters for us to swap, so return false\\n      case 1:\\n        return false; // if Strings A and B don\\'t match, we need exactly 2 mismatches for us to swap, so return false\\n      case 2:\\n        if (charactersInMismatchesInA.get(0) == charactersInMismatchesInB.get(1) && charactersInMismatchesInA.get(1) == charactersInMismatchesInB.get(0)) { // if we have same two Characters in the two mismatches, then we can swap\\n          return true;\\n        } else {\\n          return false; // there must be 3 or more Characters in these mismatches, so return false\\n        }\\n      case 3:\\n        // fall through to default\\n      default: // if there are 3 or more mismatches, return false, since a single swap can\\'t make the Strings equal\\n        return false;\\n    }\\n\\n\\n    // note: we return from switch block above\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public boolean buddyStrings(String A, String B) {\\n    \\n    // strategy: count the Character mismatches between the Strings, and see whether the mismatch can be fixed by a swap\\n\\n    /*\\n    Runtime: 2 ms, faster than 78.62% of Java online submissions for Buddy Strings.\\n    Memory Usage: 39.5 MB, less than 30.81% of Java online submissions for Buddy Strings.\\n    */\\n\\n    // edge case: one or more input Strings are empty\\n    if (A.length() == 0 || B.length() == 0) {\\n      return false; // no swap is possible with empty strings\\n    }\\n\\n    // edge case: input Strings are different lengths\\n    if (A.length() != B.length()) {\\n      return false; // Strings of different length can\\'t be made equal with a Character swap\\n    }\\n\\n    List<Character> charactersInMismatchesInA = new ArrayList<>();\\n    List<Character> charactersInMismatchesInB = new ArrayList<>();\\n    for (int index = 0; index < A.length(); ++index) {\\n      if (A.charAt(index) != B.charAt(index)) {\\n        charactersInMismatchesInA.add(A.charAt(index));\\n        charactersInMismatchesInB.add(B.charAt(index));\\n      }\\n    }\\n\\n    int numberOfMismatches = charactersInMismatchesInA.size();\\n\\n    switch(numberOfMismatches) {\\n      case 0:\\n        // identical Strings, but check whether we have two occurrences of same Character that we can swap\\n        Set<Character> s = new HashSet<>();\\n        for (char c : A.toCharArray()) {\\n          if (s.contains(c)) { // if Set already contains this Character, then String contains 2, so return true\\n            return true;\\n          } else {\\n            s.add(c); // add Character to Set in case we see another one later in String\\n          }\\n        }\\n        return false; // Strings A and B are equal, and there are no duplicate letters for us to swap, so return false\\n      case 1:\\n        return false; // if Strings A and B don\\'t match, we need exactly 2 mismatches for us to swap, so return false\\n      case 2:\\n        if (charactersInMismatchesInA.get(0) == charactersInMismatchesInB.get(1) && charactersInMismatchesInA.get(1) == charactersInMismatchesInB.get(0)) { // if we have same two Characters in the two mismatches, then we can swap\\n          return true;\\n        } else {\\n          return false; // there must be 3 or more Characters in these mismatches, so return false\\n        }\\n      case 3:\\n        // fall through to default\\n      default: // if there are 3 or more mismatches, return false, since a single swap can\\'t make the Strings equal\\n        return false;\\n    }\\n\\n\\n    // note: we return from switch block above\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 143647,
                "title": "easy-javascript",
                "content": "```\\nvar buddyStrings = function(A, B) {\\n    if(A.length!=B.length || A.length<2 || B.length<2 ) return false;\\n    \\n    if(A==B) {\\n        let setA = new Set(A.split(\\'\\'));\\n        return setA.size<A.length;\\n    }\\n    \\n    let index = [];\\n    for(let i =0; i<A.length; ++i) {\\n        if(A[i]!=B[i]) index.push(i);\\n    }\\n    if(index.length!=2) return false;\\n    \\n    return A[index[0]]==B[index[1]] && A[index[1]]==B[index[0]];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar buddyStrings = function(A, B) {\\n    if(A.length!=B.length || A.length<2 || B.length<2 ) return false;\\n    \\n    if(A==B) {\\n        let setA = new Set(A.split(\\'\\'));\\n        return setA.size<A.length;\\n    }\\n    \\n    let index = [];\\n    for(let i =0; i<A.length; ++i) {\\n        if(A[i]!=B[i]) index.push(i);\\n    }\\n    if(index.length!=2) return false;\\n    \\n    return A[index[0]]==B[index[1]] && A[index[1]]==B[index[0]];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3710765,
                "title": "c-o-n-frequency-map",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string p) {\\n        int n=s.length(), m=p.length();\\n        if(n!=m) return false;\\n        \\n        vector<int> freq(26,0);\\n        \\n        int first=-1, second=-1;\\n        for(int i=0;i<n;i++){\\n            if(s[i] != p[i]){\\n                if(first==-1){\\n                    first=i;\\n                }else if(second==-1){\\n                    second=i;\\n                }else{\\n                    return false; // more than 2 mismatching characters\\n                }\\n            }\\n            freq[s[i]-\\'a\\']++;\\n        }\\n        \\n\\t\\t// similar strings\\n        if(first == -1 && second == -1){\\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\\n            return false; // all characters occur only once\\n        }else if(second == -1){\\n            return false; // exactly 1 mismatch\\n        }\\n        \\n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string p) {\\n        int n=s.length(), m=p.length();\\n        if(n!=m) return false;\\n        \\n        vector<int> freq(26,0);\\n        \\n        int first=-1, second=-1;\\n        for(int i=0;i<n;i++){\\n            if(s[i] != p[i]){\\n                if(first==-1){\\n                    first=i;\\n                }else if(second==-1){\\n                    second=i;\\n                }else{\\n                    return false; // more than 2 mismatching characters\\n                }\\n            }\\n            freq[s[i]-\\'a\\']++;\\n        }\\n        \\n\\t\\t// similar strings\\n        if(first == -1 && second == -1){\\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\\n            return false; // all characters occur only once\\n        }else if(second == -1){\\n            return false; // exactly 1 mismatch\\n        }\\n        \\n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710745,
                "title": "c-beginner-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size() || s.size()==1)return false;\\n        vector<int>different;\\n        vector<int>ct(26,0);\\n        bool f=false;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i])different.push_back(i);\\n            else{\\n                ct[s[i]-\\'a\\']++;\\n                if(ct[s[i]-\\'a\\']>=2)f=true;\\n            }\\n        }\\n        if(different.size()>2)return false;\\n        if(different.size()==1)return false;\\n         if(different.size()==0){\\n             return f;\\n         }\\n        int in1,in2;\\n        in1 = different[0];\\n        in2 = different[1];\\n        swap(s[in1],s[in2]);\\n        return s==goal;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/54b36830-9ed3-4c8a-8928-a351c0059d04_1688355853.402244.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size() || s.size()==1)return false;\\n        vector<int>different;\\n        vector<int>ct(26,0);\\n        bool f=false;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i])different.push_back(i);\\n            else{\\n                ct[s[i]-\\'a\\']++;\\n                if(ct[s[i]-\\'a\\']>=2)f=true;\\n            }\\n        }\\n        if(different.size()>2)return false;\\n        if(different.size()==1)return false;\\n         if(different.size()==0){\\n             return f;\\n         }\\n        int in1,in2;\\n        in1 = different[0];\\n        in2 = different[1];\\n        swap(s[in1],s[in2]);\\n        return s==goal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758409,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      bool buddyStrings(string s, string goal) {\\n        if (s.size() != goal.size()) return false;\\n        vector<int> count1(26, 0);\\n        vector<int> count2(26, 0);\\n        int diffs = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] != goal[i]) diffs++;\\n            count1[s[i] - \\'a\\']++;\\n            count2[goal[i] - \\'a\\']++;\\n        }\\n\\n        int allUniqueChars = true;\\n        for (int i = 0; i < count1.size(); i++) {\\n            if (count1[i] != count2[i]) return false;\\n            if (count1[i] > 1) allUniqueChars = false;\\n        }\\n\\n        return diffs == 2 || (diffs == 0 && !allUniqueChars);\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      bool buddyStrings(string s, string goal) {\\n        if (s.size() != goal.size()) return false;\\n        vector<int> count1(26, 0);\\n        vector<int> count2(26, 0);\\n        int diffs = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] != goal[i]) diffs++;\\n            count1[s[i] - \\'a\\']++;\\n            count2[goal[i] - \\'a\\']++;\\n        }\\n\\n        int allUniqueChars = true;\\n        for (int i = 0; i < count1.size(); i++) {\\n            if (count1[i] != count2[i]) return false;\\n            if (count1[i] > 1) allUniqueChars = false;\\n        }\\n\\n        return diffs == 2 || (diffs == 0 && !allUniqueChars);\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313464,
                "title": "easy-c-using-two-pointers-and-set",
                "content": "```\\nclass Solution {\\npublic:\\n  bool buddyStrings(string A, string B) {        \\n        if (A == B)\\n            return (set<char>(A.begin(), A.end()).size() < A.size()); // swap same letters in A\\n        \\n        int n = A.length();\\n        int l = 0, r = n-1;\\n        \\n        while(l < n && A[l] == B[l])\\n            l++;\\n        while(r >= 0 && A[r] == B[r])\\n            r--;\\n        if(l < r)\\n            swap(A[l], A[r]);\\n        \\n        return A == B;                \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  bool buddyStrings(string A, string B) {        \\n        if (A == B)\\n            return (set<char>(A.begin(), A.end()).size() < A.size()); // swap same letters in A\\n        \\n        int n = A.length();\\n        int l = 0, r = n-1;\\n        \\n        while(l < n && A[l] == B[l])\\n            l++;\\n        while(r >= 0 && A[r] == B[r])\\n            r--;\\n        if(l < r)\\n            swap(A[l], A[r]);\\n        \\n        return A == B;                \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068810,
                "title": "c-solution",
                "content": "```\\nbool buddyStrings(string A, string B) {\\n\\tif (A.size() != B.size())\\n\\t\\treturn false;\\n\\n\\tif (A == B && set<char>(A.begin(), A.end()).size() < A.size())\\n\\t\\treturn true;\\n\\n\\tvector<int> diff {};\\n\\tfor (int i = 0; i < A.size(); i++)\\n\\t\\tif (A[i] != B[i])\\n\\t\\t\\tdiff.push_back(i);\\n\\n\\treturn (diff.size() == 2 && A[diff[0]] == B[diff[1]] && A[diff[1]] == B[diff[0]]);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool buddyStrings(string A, string B) {\\n\\tif (A.size() != B.size())\\n\\t\\treturn false;\\n\\n\\tif (A == B && set<char>(A.begin(), A.end()).size() < A.size())\\n\\t\\treturn true;\\n\\n\\tvector<int> diff {};\\n\\tfor (int i = 0; i < A.size(); i++)\\n\\t\\tif (A[i] != B[i])\\n\\t\\t\\tdiff.push_back(i);\\n\\n\\treturn (diff.size() == 2 && A[diff[0]] == B[diff[1]] && A[diff[1]] == B[diff[0]]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 891233,
                "title": "java-o-n-3-cases-with-comments",
                "content": "```\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        //case 1: if the lengths are not equal, return false\\n        if(A.length()!=B.length())\\n            return false;\\n        //case 2: if strings are equal we have to make sure that \\n        // atleast there are two instances of any char.\\n        // for example \\'a\\' \\'a\\' returns false but \\'aa\\' \\'aa\\' returns true\\n        if(A.equals(B)) {\\n            Set<Character> set = new HashSet<>();\\n            for(char c : A.toCharArray()) {\\n                if(set.contains(c))\\n                    return true;\\n                set.add(c);   \\n            }\\n            return false;\\n        }\\n        //case 3: check if the strings only differ at only two indexes and\\n        //chars at those diff indexes are equal.\\\\\\n        // for example: aabc , aacb returns true.\\n        // aabc, aace -> return false.\\n        List<Integer> diff = new ArrayList<>();\\n        for(int i=0;i<A.length();i++) {\\n            if(A.charAt(i)!=B.charAt(i))\\n                diff.add(i);\\n        }\\n        return diff.size()==2 && (A.charAt(diff.get(0)) == B.charAt(diff.get(1))  &&\\n                                  B.charAt(diff.get(0)) == A.charAt(diff.get(1)));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        //case 1: if the lengths are not equal, return false\\n        if(A.length()!=B.length())\\n            return false;\\n        //case 2: if strings are equal we have to make sure that \\n        // atleast there are two instances of any char.\\n        // for example \\'a\\' \\'a\\' returns false but \\'aa\\' \\'aa\\' returns true\\n        if(A.equals(B)) {\\n            Set<Character> set = new HashSet<>();\\n            for(char c : A.toCharArray()) {\\n                if(set.contains(c))\\n                    return true;\\n                set.add(c);   \\n            }\\n            return false;\\n        }\\n        //case 3: check if the strings only differ at only two indexes and\\n        //chars at those diff indexes are equal.\\\\\\n        // for example: aabc , aacb returns true.\\n        // aabc, aace -> return false.\\n        List<Integer> diff = new ArrayList<>();\\n        for(int i=0;i<A.length();i++) {\\n            if(A.charAt(i)!=B.charAt(i))\\n                diff.add(i);\\n        }\\n        return diff.size()==2 && (A.charAt(diff.get(0)) == B.charAt(diff.get(1))  &&\\n                                  B.charAt(diff.get(0)) == A.charAt(diff.get(1)));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558821,
                "title": "python-different-from-the-included-solution-explained",
                "content": "```\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n        if A and B and len(A) == len(B):\\n            \\n            a,b = [],[]\\n            \\n            for i in range(len(A)):\\n                if A[i]!=B[i]:\\n                    a.append(A[i])\\n                    b.append(B[i])\\n            \\n            if set(a)==set(b):\\n                if len(a) == len(b) == 2:\\n                    return True\\n                else:\\n                    ca,cb = collections.Counter(A), collections.Counter(B)\\n                    if A==B  and cb.most_common(1)[0][1]>1:\\n                        return True\\n        \\n        return False\\n```\\n\\nA lot of posts here repeat the provided solution, so tried to do something different ...\\n\\nThe code is a head on approach:\\n\\n```\\n        if A and B and len(A) == len(B):\\n```\\n\\nsome sanity check first ...\\n\\n```\\n            a,b = [],[]\\n            \\n            for i in range(len(A)):\\n                if A[i]!=B[i]:\\n                    a.append(A[i])\\n                    b.append(B[i]))\\n```\\n\\nHere we count characters different between A and B.\\n\\nOk, if `a` is not equal to `b`, that means our string A and B are using different characters, so it\\'s impossible to make them to be the same by reordering characters. But if `a` and `b` are the same, we have two options:\\n\\n1. They are off by exactly 2 same characters:\\n\\n```\\n            if set(a)==set(b):\\n                if len(a) == len(b) == 2:\\n                    return True\\n```\\n\\nThen we can simply swap those 2 characters.\\n\\n2. The strings are completely identical. Then we need to make sure those string have at least 2 instances of some character so they can be swapped (for example \"aa\" and \"aa\", while swapping first a and second a don\\'t change the string, they can still be swapped). So we find the most common character and make sure it\\'s the same and there is more than one in each string:\\n```\\n                else:\\n                    ca,cb = collections.Counter(A), collections.Counter(B)\\n                    if A==B  and cb.most_common(1)[0][1]>1:\\n                        return True\\n```\\n\\nOtherwise - return False.\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n        if A and B and len(A) == len(B):\\n            \\n            a,b = [],[]\\n            \\n            for i in range(len(A)):\\n                if A[i]!=B[i]:\\n                    a.append(A[i])\\n                    b.append(B[i])\\n            \\n            if set(a)==set(b):\\n                if len(a) == len(b) == 2:\\n                    return True\\n                else:\\n                    ca,cb = collections.Counter(A), collections.Counter(B)\\n                    if A==B  and cb.most_common(1)[0][1]>1:\\n                        return True\\n        \\n        return False\\n```\n```\\n        if A and B and len(A) == len(B):\\n```\n```\\n            a,b = [],[]\\n            \\n            for i in range(len(A)):\\n                if A[i]!=B[i]:\\n                    a.append(A[i])\\n                    b.append(B[i]))\\n```\n```\\n            if set(a)==set(b):\\n                if len(a) == len(b) == 2:\\n                    return True\\n```\n```\\n                else:\\n                    ca,cb = collections.Counter(A), collections.Counter(B)\\n                    if A==B  and cb.most_common(1)[0][1]>1:\\n                        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394976,
                "title": "python3-solution-with-explanation",
                "content": "In another word, A and B are buddy strings iff one of the below two conditions is true\\n1) A == B and A has repetitive letters (so that by swapping them, A is still A)\\n2) A != B but there are exactly 2 different letters (at position m and n) and A[m] = B[n], A[n] = B[m] \\n\\n```\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n        if len(A) != len(B): return False \\n        if A == B:\\n            return len(A) > len(set(A))\\n        else:\\n            pairs = []\\n            for a, b in zip(A, B):\\n                if a != b: pairs.append((a, b))\\n                if len(pairs) > 2: return False \\n            return len(pairs) == 2 and pairs[0] == pairs[1][::-1]\\n```\\n\\nEdited on 10/13/2020\\nAdded a 3-line solution \\n```\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n        if A == B: return len(A) > len(set(A)) # duplicates in A\\n        stack = [(a, b) for a, b in zip_longest(A, B) if a != b]\\n        return len(stack) == 2 and stack[0] == stack[-1][::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n        if len(A) != len(B): return False \\n        if A == B:\\n            return len(A) > len(set(A))\\n        else:\\n            pairs = []\\n            for a, b in zip(A, B):\\n                if a != b: pairs.append((a, b))\\n                if len(pairs) > 2: return False \\n            return len(pairs) == 2 and pairs[0] == pairs[1][::-1]\\n```\n```\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n        if A == B: return len(A) > len(set(A)) # duplicates in A\\n        stack = [(a, b) for a, b in zip_longest(A, B) if a != b]\\n        return len(stack) == 2 and stack[0] == stack[-1][::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711914,
                "title": "python-elegant-short-counting",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal):\\n            return False\\n\\n        different_letters = [\\n            (a, b)\\n            for a, b in zip(s, goal)\\n            if a != b\\n        ]\\n\\n        if len(different_letters) != 2:\\n            # If two strings are the same, then we just need to swap duplicates\\n            return not different_letters and len(set(s)) < len(s)\\n\\n        (a1, b1), (a2, b2) = different_letters\\n        return a1 == b2 and b1 == a2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal):\\n            return False\\n\\n        different_letters = [\\n            (a, b)\\n            for a, b in zip(s, goal)\\n            if a != b\\n        ]\\n\\n        if len(different_letters) != 2:\\n            # If two strings are the same, then we just need to swap duplicates\\n            return not different_letters and len(set(s)) < len(s)\\n\\n        (a1, b1), (a2, b2) = different_letters\\n        return a1 == b2 and b1 == a2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711757,
                "title": "easy-c-approach-easy-to-understand",
                "content": "# Intuition\\nJust count the the characters which does not match in the given two strings. If cnt is greater than equal to 3 or equal to 1 then it is not possible. \\n\\n\\nIf the cnt is still 0, there can be 2 cases that either it contains all character different or at least one character repetitive. if all characters are different then again it is not possible else for at least one, it is possible.\\n\\nFinally,we arrive at last possibility i.e. we can have two different characters in the string. we can check easily that by swapping these two characters, we can get goal or not. If yes we can return true else return false.\\n# Approach\\ninitilalize cnt variable to check no. of different characters\\n\\nuse a map to check the frequeny of characters in the string which is equal to goal string\\n\\nFinally swap the chars in the string s and check its possibility of being equal to goal.\\n\\n# Complexity\\n- Time complexity:\\no(n): where n is the size of the string s.\\n\\n- Space complexity:\\no(k): where k is the number of unique characters in the string s.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int cnt=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i]) cnt++;\\n        }\\n        if(cnt>=3 || cnt==1) return false;\\n        if(cnt==0){\\n            map<char, int> m;\\n            for(auto it: s){\\n                m[it]++;\\n            }\\n            for(auto it:m){\\n                if(it.second>1) return true;\\n            }\\n            return false;\\n\\n        }\\n        vector<int> ind;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i]){\\n                ind.push_back(i);\\n            }\\n        }\\n        swap(s[ind[0]],s[ind[1]]);\\n        cout<<ind[0]<<\" \"<<ind[1]<<endl;\\n        if(s==goal) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int cnt=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i]) cnt++;\\n        }\\n        if(cnt>=3 || cnt==1) return false;\\n        if(cnt==0){\\n            map<char, int> m;\\n            for(auto it: s){\\n                m[it]++;\\n            }\\n            for(auto it:m){\\n                if(it.second>1) return true;\\n            }\\n            return false;\\n\\n        }\\n        vector<int> ind;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i]){\\n                ind.push_back(i);\\n            }\\n        }\\n        swap(s[ind[0]],s[ind[1]]);\\n        cout<<ind[0]<<\" \"<<ind[1]<<endl;\\n        if(s==goal) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3710800,
                "title": "c-easy-implementation-commented",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        // check same length\\n        if (A.size() != B.size()) \\n            return false;\\n        \\n        // if strings are equal - check if there is a double to swap\\n        if (A == B) { \\n            unordered_map<char, int> count;\\n            for (auto l:A){\\n                count[l]++;\\n                if (count[l] > 1)\\n                    return true;\\n            }\\n            return false;\\n        }\\n        \\n        // count differences between strings\\n        vector<int> diff;\\n        for (int i=0; i<A.size(); i++) {\\n            if (A[i] != B[i]) {\\n                diff.push_back(i);\\n                if (diff.size() > 2)\\n                    return false;\\n            }\\n        }\\n        // not exactly two differences\\n        if (diff.size() != 2)\\n            return false;\\n        \\n        // check if can be swapped\\n        if ((A[diff[0]] == B[diff[1]]) && (A[diff[1]] == B[diff[0]]))\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        // check same length\\n        if (A.size() != B.size()) \\n            return false;\\n        \\n        // if strings are equal - check if there is a double to swap\\n        if (A == B) { \\n            unordered_map<char, int> count;\\n            for (auto l:A){\\n                count[l]++;\\n                if (count[l] > 1)\\n                    return true;\\n            }\\n            return false;\\n        }\\n        \\n        // count differences between strings\\n        vector<int> diff;\\n        for (int i=0; i<A.size(); i++) {\\n            if (A[i] != B[i]) {\\n                diff.push_back(i);\\n                if (diff.size() > 2)\\n                    return false;\\n            }\\n        }\\n        // not exactly two differences\\n        if (diff.size() != 2)\\n            return false;\\n        \\n        // check if can be swapped\\n        if ((A[diff[0]] == B[diff[1]]) && (A[diff[1]] == B[diff[0]]))\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710493,
                "title": "easy-to-understand-solution-with-intuitive-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The immediate thought is that $$s$$ and $$goal$$ must have the same length, and they must either be identical or differ in exactly two positions.\\n- If they are identical, $$s$$ must have at least one character that appears more than once, so we can swap the two instances of that character.\\n- If they differ in exactly two positions, the characters at those positions must be reversed.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The solution first checks the lengths of $$s$$ and $$goal$$. If they have different lengths, we immediately returns False. \\n- Then we checks if $$s$$ and $$goal$$ are identical and $$s$$ has a character that appears more than once. If both conditions are met, we returns $$True$$. \\n- Otherwise, using zip function, we creates a list of pairs of characters where $$s$$ and $$goal$$ differ. If the length of the list is 2 and the pairs are reversed versions of each other, we returns $$True$$. Otherwise, we returns $$False$$.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal):\\n            return False\\n        if s == goal and len(set(s)) < len(s):\\n            return True\\n        pairs = [(a, b) for a, b in zip(s, goal) if a != b]\\n        return len(pairs) == 2 and pairs[0] == pairs[1][::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal):\\n            return False\\n        if s == goal and len(set(s)) < len(s):\\n            return True\\n        pairs = [(a, b) for a, b in zip(s, goal) if a != b]\\n        return len(pairs) == 2 and pairs[0] == pairs[1][::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 890999,
                "title": "c-0ms-one-pass-concise-solution-no-extra-ds-needed",
                "content": "There are a few situations:\\n- A and B are with different lengths => false\\n- length < 2 => can\\'t swap, false\\n- only 1 or more than 2 unmatched indexes => false\\n- exactly 2 unmatched indexes, becomes the same after swap => true\\n- A and B are identical, and exists at least 1 letter appeared more than once in each string => true\\n\\nUpdate 2: I have improved it further! Now version 3 is about 3 times faster than version 1 on long strings, based on my benchmark. And there\\'s no any extra data structures used (set, string, array, etc.) You can even replace the bitset with an int and it will just work (but the code will be messier, see below)\\nExplain:\\n- We know `0 ^ x = x` and `x ^ x = 0`, if `x != y` then `x ^ y != 0`. So if we found `(x, y)` in string A and `(y, x)` in string B, `(x ^ y) ^ (y ^ x) == 0`. There is one exception: if we found `(x, x)` in string A and `(y, y)` in string B, `(x ^ x) ^ (y ^ y)` is also `0`, so we have to check the 2 letters found in same string `(x1, x2)` are not the same - `x1 & x2 != 0`.\\n- We are garanteed to be able to find duplicated letters within the first 27 letters, so don\\'t bother to do the checks if we have already found any.\\n#### Version 3\\n```cpp\\nbool buddyStrings(string A, string B) {\\n\\tif (A.size() != B.size() || A.size() < 2) return false;\\n\\tbitset<128> bits{0};\\n\\tuint8_t m1 = 0, m2 = 0, count = 0, dup = 0;\\n\\tfor (int i = 0; i < A.size() && count <= 2; ++i) {\\n\\t\\tif (A[i] != B[i]) m1 ^= A[i] ^ B[i], m2 ^= A[i], ++count;\\n\\t\\tif (!dup) dup = bits.test(A[i]), bits.set(A[i]);\\n\\t}\\n\\treturn (count == 2 && !m1 && m2) || (!count && dup);\\n}\\n```\\n### Version 3 ints only\\n```cpp\\nbool buddyStrings(string A, string B) {\\n\\tif (A.size() != B.size() || A.size() < 2) return false;\\n\\tuint32_t bits = 0, m1 = 0, m2 = 0, count = 0, dup = 0;\\n\\tfor (int i = 0; i < A.size() && count <= 2; ++i) {\\n\\t\\tif (A[i] != B[i]) m1 ^= A[i] ^ B[i], m2 ^= A[i], ++count;\\n\\t\\tif (!dup) dup = bits & (1 << (A[i] - \\'a\\')), bits |= (1 << (A[i] - \\'a\\'));\\n\\t}\\n\\treturn (count == 2 && !m1 && m2) || (!count && dup);\\n}\\n```\\n----\\nUpdate: I have improved the solution a little bit, and saved a few lines:\\n#### Version 2\\n```cpp\\nbool buddyStrings(string A, string B) {\\n    if (A.size() != B.size() || A.size() < 2) return false;\\n    string sa, sb;\\n    bitset<128> bits{0};\\n    bool dup = false;\\n    for (int i = 0; i < A.size() && sa.size() <= 2; ++i) {\\n        if (A[i] != B[i]) {\\n\\t\\t\\tsa += A[i];\\n\\t\\t\\tsb = B[i] + sb;\\n        } else {\\n\\t\\t\\tdup |= bits.test(A[i]);\\n\\t\\t\\tbits.set(A[i]);\\n\\t\\t}\\n    }\\n    return (sa.size() == 2 && sa == sb) || (sa.empty() && dup);\\n}\\n```\\n\\n----\\n#### Version 1\\n```cpp\\nbool buddyStrings(string A, string B) {\\n    if (A.size() != B.size() || A.size() < 2) return false;\\n    string sa, sb;\\n    bitset<128> bits{0};\\n    bool dup = false;\\n    for (int i = 0; i < A.size() && sa.size() <= 2; ++i) {\\n        if (A[i] != B[i]) {\\n\\t\\t\\tsa += A[i], sb += B[i];\\n        } else {\\n\\t\\t\\tdup |= bits.test(A[i]);\\n\\t\\t\\tbits.set(A[i]);\\n\\t\\t}\\n    }\\n    if (sa.size() == 2) {\\n        swap(sa[0], sa[1]);\\n        return sa == sb;\\n    }\\n    return sa.empty() && dup;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nbool buddyStrings(string A, string B) {\\n\\tif (A.size() != B.size() || A.size() < 2) return false;\\n\\tbitset<128> bits{0};\\n\\tuint8_t m1 = 0, m2 = 0, count = 0, dup = 0;\\n\\tfor (int i = 0; i < A.size() && count <= 2; ++i) {\\n\\t\\tif (A[i] != B[i]) m1 ^= A[i] ^ B[i], m2 ^= A[i], ++count;\\n\\t\\tif (!dup) dup = bits.test(A[i]), bits.set(A[i]);\\n\\t}\\n\\treturn (count == 2 && !m1 && m2) || (!count && dup);\\n}\\n```\n```cpp\\nbool buddyStrings(string A, string B) {\\n\\tif (A.size() != B.size() || A.size() < 2) return false;\\n\\tuint32_t bits = 0, m1 = 0, m2 = 0, count = 0, dup = 0;\\n\\tfor (int i = 0; i < A.size() && count <= 2; ++i) {\\n\\t\\tif (A[i] != B[i]) m1 ^= A[i] ^ B[i], m2 ^= A[i], ++count;\\n\\t\\tif (!dup) dup = bits & (1 << (A[i] - \\'a\\')), bits |= (1 << (A[i] - \\'a\\'));\\n\\t}\\n\\treturn (count == 2 && !m1 && m2) || (!count && dup);\\n}\\n```\n```cpp\\nbool buddyStrings(string A, string B) {\\n    if (A.size() != B.size() || A.size() < 2) return false;\\n    string sa, sb;\\n    bitset<128> bits{0};\\n    bool dup = false;\\n    for (int i = 0; i < A.size() && sa.size() <= 2; ++i) {\\n        if (A[i] != B[i]) {\\n\\t\\t\\tsa += A[i];\\n\\t\\t\\tsb = B[i] + sb;\\n        } else {\\n\\t\\t\\tdup |= bits.test(A[i]);\\n\\t\\t\\tbits.set(A[i]);\\n\\t\\t}\\n    }\\n    return (sa.size() == 2 && sa == sb) || (sa.empty() && dup);\\n}\\n```\n```cpp\\nbool buddyStrings(string A, string B) {\\n    if (A.size() != B.size() || A.size() < 2) return false;\\n    string sa, sb;\\n    bitset<128> bits{0};\\n    bool dup = false;\\n    for (int i = 0; i < A.size() && sa.size() <= 2; ++i) {\\n        if (A[i] != B[i]) {\\n\\t\\t\\tsa += A[i], sb += B[i];\\n        } else {\\n\\t\\t\\tdup |= bits.test(A[i]);\\n\\t\\t\\tbits.set(A[i]);\\n\\t\\t}\\n    }\\n    if (sa.size() == 2) {\\n        swap(sa[0], sa[1]);\\n        return sa == sb;\\n    }\\n    return sa.empty() && dup;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 554617,
                "title": "python-3-simple-solution-with-explanation",
                "content": "```\\n\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n\\t\\t# if lengths are different, then must be false\\n        if len(A) != len(B):\\n            return False\\n        # If A and B are same, then A must have duplicate character\\n        if A == B:  \\n            seen = set()\\n            for a in A:\\n                if a in seen: \\n                    return True\\n                seen.add(a)\\n            return False\\n\\n        pair = []\\n        # when A and B are not same\\n        for a, b in zip(A, B): \\n            if a != b:\\n                pair.append((a, b))\\n            if len(pair) > 2:\\n                return False\\n            \\n        return len(pair) == 2 and pair[0] == pair[1][::-1]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n\\t\\t# if lengths are different, then must be false\\n        if len(A) != len(B):\\n            return False\\n        # If A and B are same, then A must have duplicate character\\n        if A == B:  \\n            seen = set()\\n            for a in A:\\n                if a in seen: \\n                    return True\\n                seen.add(a)\\n            return False\\n\\n        pair = []\\n        # when A and B are not same\\n        for a, b in zip(A, B): \\n            if a != b:\\n                pair.append((a, b))\\n            if len(pair) > 2:\\n                return False\\n            \\n        return len(pair) == 2 and pair[0] == pair[1][::-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 537249,
                "title": "o-n-space-o-1-space-two-js-solutions",
                "content": "```\\n// O(N) space\\nvar buddyStrings = function(A, B) {\\n    if (A == \"\" || B == \"\" || A.length !== B.length) return false;\\n    if (A == B) {\\n        let set = new Set(A);\\n        return set.size !== A.length;\\n    }\\n    let a = \"\", b = \"\";\\n    for (i = 0; i < A.length; i++) {\\n        if (A[i] !== B[i]) {\\n            a += A[i];\\n            b += B[i];\\n        } \\n    }\\n    if (a.length == 2 && a.length == b.length) {\\n        return a[0] == b[1] && a[1] == b[0];    \\n    } \\n    return false; \\n\\t// T.C: O(M), M = length of s\\n\\t// S.C: O(M)\\n};\\n```\\n\\n```\\n// O(1) Space\\n/*\\nImportant Note: You are required to perform a swap of two letters. Exactly one. No less, No more.\\n\\n1. Check strings\\' lengths. If they are different, return false.\\n2. Iterate through both strings. If two characters are different, push the index to an array.\\n3. After iteration is done, array should contain exactly two indices (idx1 and idx2) and\\ns[idx1] == goal[idx2] and s[idx2] == goal[idx1]. Or, another case is that two strings are exactly the same.\\nIn this case, they should contain one same letter that occurs more than once so that strings stay unchanged after one swap.\\nFor all other cases, return false.\\n*/\\nvar buddyStrings = function(s, goal) {\\n    if (s.length !== goal.length) {\\n        return false;\\n    }\\n    let swapIdx = [], chars = new Array(26).fill(0), sameCharTwice = false;\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] !== goal[i]) {\\n            swapIdx.push(i);\\n            if (swapIdx.length > 2) return false;\\n        } else {\\n            let idx = s.charCodeAt(i) - 97;\\n            chars[idx]++;\\n            if (chars[idx] > 1) sameCharTwice = true;\\n        }\\n    }\\n    if (swapIdx.length === 2 &&\\n        s[swapIdx[0]] === goal[swapIdx[1]] &&\\n        s[swapIdx[1]] === goal[swapIdx[0]]) {\\n        return true;\\n    }\\n    if (swapIdx.length === 0 && sameCharTwice) {\\n        return true;\\n    }\\n    return false;\\n    // T.C: O(M), M = length of s\\n    // S.C: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// O(N) space\\nvar buddyStrings = function(A, B) {\\n    if (A == \"\" || B == \"\" || A.length !== B.length) return false;\\n    if (A == B) {\\n        let set = new Set(A);\\n        return set.size !== A.length;\\n    }\\n    let a = \"\", b = \"\";\\n    for (i = 0; i < A.length; i++) {\\n        if (A[i] !== B[i]) {\\n            a += A[i];\\n            b += B[i];\\n        } \\n    }\\n    if (a.length == 2 && a.length == b.length) {\\n        return a[0] == b[1] && a[1] == b[0];    \\n    } \\n    return false; \\n\\t// T.C: O(M), M = length of s\\n\\t// S.C: O(M)\\n};\\n```\n```\\n// O(1) Space\\n/*\\nImportant Note: You are required to perform a swap of two letters. Exactly one. No less, No more.\\n\\n1. Check strings\\' lengths. If they are different, return false.\\n2. Iterate through both strings. If two characters are different, push the index to an array.\\n3. After iteration is done, array should contain exactly two indices (idx1 and idx2) and\\ns[idx1] == goal[idx2] and s[idx2] == goal[idx1]. Or, another case is that two strings are exactly the same.\\nIn this case, they should contain one same letter that occurs more than once so that strings stay unchanged after one swap.\\nFor all other cases, return false.\\n*/\\nvar buddyStrings = function(s, goal) {\\n    if (s.length !== goal.length) {\\n        return false;\\n    }\\n    let swapIdx = [], chars = new Array(26).fill(0), sameCharTwice = false;\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] !== goal[i]) {\\n            swapIdx.push(i);\\n            if (swapIdx.length > 2) return false;\\n        } else {\\n            let idx = s.charCodeAt(i) - 97;\\n            chars[idx]++;\\n            if (chars[idx] > 1) sameCharTwice = true;\\n        }\\n    }\\n    if (swapIdx.length === 2 &&\\n        s[swapIdx[0]] === goal[swapIdx[1]] &&\\n        s[swapIdx[1]] === goal[swapIdx[0]]) {\\n        return true;\\n    }\\n    if (swapIdx.length === 0 && sameCharTwice) {\\n        return true;\\n    }\\n    return false;\\n    // T.C: O(M), M = length of s\\n    // S.C: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3711705,
                "title": "easy-beginer-friendly-cpp-solution-beats-100-with-stepwise-detailed-explanation-no-set-no-hashmap",
                "content": "\\n# Approach\\n1. Check if the lengths of `s` and `goal` are different. If they are not equal, the strings cannot be made equal through a swap. Return `false` in this case.\\n\\n2. Check if the length of the strings is less than 2. If it is, there are not enough characters to perform a valid swap. Return `false` because we need at least two characters to swap.\\n\\n3. Check if the strings `s` and `goal` are equal. If they are equal, there is a possibility of forming a buddy string by swapping two identical characters. Iterate through the string and check if there are any duplicate characters. If there are, return `true` because swapping any two identical characters will not change the string.\\n\\n4. If the strings are not equal, iterate through the strings character by character and find the first and second differing indices. These indices represent the positions where the characters differ between `s` and `goal`.\\n\\n5. If there are more than two differing indices, it is not possible to make the strings equal with a single swap. Return `false` because we can only perform a single swap.\\n\\n6. Check if the characters at the first and second differing indices of `s` and `goal` can be swapped to make the strings equal. If swapping the characters at these indices results in the strings becoming equal, return `true`. Otherwise, return `false`.\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\n - O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()) return false;\\n        if(s.size()<2) return false;\\n        \\n            if (s == goal) {\\n            for (int i = 0; i < s.length(); i++) {\\n                for (int j = i + 1; j < s.length(); j++) {\\n                    if (s[i] == s[j]) {\\n                        return true;\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        int first=-1,second=-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            \\n            if(s[i]!=goal[i])\\n            {\\n                if(first==-1)\\n                {\\n                    first=i;\\n                }\\n                else if(second==-1)\\n                {\\n                    second=i;\\n                }\\n                else return false;\\n            }\\n            \\n        }\\n        return (second != -1 && s[first] == goal[second] && s[second] == goal[first]);\\n    }\\n};\\n```\\n# Please upvote and feel free to ask if you face any difficulty in understanding",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()) return false;\\n        if(s.size()<2) return false;\\n        \\n            if (s == goal) {\\n            for (int i = 0; i < s.length(); i++) {\\n                for (int j = i + 1; j < s.length(); j++) {\\n                    if (s[i] == s[j]) {\\n                        return true;\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        int first=-1,second=-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            \\n            if(s[i]!=goal[i])\\n            {\\n                if(first==-1)\\n                {\\n                    first=i;\\n                }\\n                else if(second==-1)\\n                {\\n                    second=i;\\n                }\\n                else return false;\\n            }\\n            \\n        }\\n        return (second != -1 && s[first] == goal[second] && s[second] == goal[first]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711680,
                "title": "7ms-c-two-pointers-easy-to-understand-859-buddy-strings",
                "content": "# 7ms | C++ | Two-Pointers | Easy to Understand | 859. Buddy Strings\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        \\n        if(s == goal){\\n            return ((set<char>(s.begin(),s.end())).size() < s.size());\\n        }\\n        \\n        int n = s.size();\\n        int i=0;\\n        int j=n-1;\\n        while(i<n&& s[i]==goal[i]){\\n            i++;\\n        }\\n        while(j>0 && s[j] == goal[j]){\\n            j--;\\n        }\\n        \\n        if(i<j){\\n            swap(s[i],s[j]);\\n        }\\n        \\n        return s == goal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        \\n        if(s == goal){\\n            return ((set<char>(s.begin(),s.end())).size() < s.size());\\n        }\\n        \\n        int n = s.size();\\n        int i=0;\\n        int j=n-1;\\n        while(i<n&& s[i]==goal[i]){\\n            i++;\\n        }\\n        while(j>0 && s[j] == goal[j]){\\n            j--;\\n        }\\n        \\n        if(i<j){\\n            swap(s[i],s[j]);\\n        }\\n        \\n        return s == goal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711095,
                "title": "brute-force-easy-and-simple-o-n-linear-complexity-unordered-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()) return false;\\n        if(s==goal){\\n            unordered_map<char,int>m;\\n            for(auto a:s){\\n                m[a]++;\\n                if(m[a]>1)return true;\\n            }\\n            return false;\\n        }\\n        int count=0;\\n        int prev=-1;\\n        int curr=-1;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i]){\\n                count++;\\n                if(prev==-1) prev=i;\\n                else curr=i;\\n            }\\n        }\\n        if(count!=2)return false;\\n        swap(s[prev],s[curr]);\\n        return s==goal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()) return false;\\n        if(s==goal){\\n            unordered_map<char,int>m;\\n            for(auto a:s){\\n                m[a]++;\\n                if(m[a]>1)return true;\\n            }\\n            return false;\\n        }\\n        int count=0;\\n        int prev=-1;\\n        int curr=-1;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i]){\\n                count++;\\n                if(prev==-1) prev=i;\\n                else curr=i;\\n            }\\n        }\\n        if(count!=2)return false;\\n        swap(s[prev],s[curr]);\\n        return s==goal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711093,
                "title": "c-stuck-noob-solution-beats-100-lol-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you pass all testcases in the first go, you must either be a **freak** or a **cheat**.\\nWell doesn\\'t matter, lemme explain my own thought process:\\n\\n- Count number of instances where `s[i]!=goal[i]`\\n- Each time `s[i]!=goal[i]`, store both unequal characters \\n    (Eg: `ab` & `ba`), then you\\'ll first store `{a,b}` and then `{b,a}`\\n\\nAfter doing this, you have 3 cases:\\n\\n- If $$instances \\u2260 2$$ then return false\\n- If $$instances = 2$$, check if:\\n<img src=\\'https://assets.leetcode.com/users/images/67b3b47a-3fc3-443f-a494-f7f45be8faf5_1688360971.7869503.png\\' width=\"200\"/>\\n- If $$instances = 0$$, like in case of `s=\"aa\"` and `goal=\"aa\"`,\\n    -> In this case, strings are same, if there is a character with frequency more than 1 (has duplicates), you can exchange the duplicates to get the same exact string!\\n\\n##### DONE, you have successfully understood the NOOB solution!\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool checkduplicate(vector<int>&freq){\\n        for(int i=0;i<26;i++)\\n            if(freq[i]>1)\\n                return true;\\n        return false;\\n    }\\n    bool buddyStrings(string s, string goal) {\\n        if(goal.length()!=s.length()) return false;\\n        vector<int> freq(26,0);\\n        vector<pair<char,char>> v;\\n        for(int i=0;i<s.length();i++){\\n            freq[s[i]-\\'a\\']++;\\n            if(s[i]!=goal[i])\\n                v.push_back({s[i],goal[i]});\\n        }\\n        if(v.size()==0) //same strings\\n            if(checkduplicate(freq)) return true;\\n        if(v.size()==2&&v[0].first==v[1].second&&v[1].first==v[0].second)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool checkduplicate(vector<int>&freq){\\n        for(int i=0;i<26;i++)\\n            if(freq[i]>1)\\n                return true;\\n        return false;\\n    }\\n    bool buddyStrings(string s, string goal) {\\n        if(goal.length()!=s.length()) return false;\\n        vector<int> freq(26,0);\\n        vector<pair<char,char>> v;\\n        for(int i=0;i<s.length();i++){\\n            freq[s[i]-\\'a\\']++;\\n            if(s[i]!=goal[i])\\n                v.push_back({s[i],goal[i]});\\n        }\\n        if(v.size()==0) //same strings\\n            if(checkduplicate(freq)) return true;\\n        if(v.size()==2&&v[0].first==v[1].second&&v[1].first==v[0].second)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711018,
                "title": "daily-coding-challenge-java-solution-using-hash-set-arraylist",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length()!= goal.length()){\\n            return false;\\n        }\\n        HashSet<Character> set=new HashSet<>();\\n        if(s.equals(goal)){\\n           for(char c:s.toCharArray()){\\n               set.add(c);\\n           }\\n           if(set.size()<s.length()){\\n               return true;\\n           }\\n           return false;\\n        }\\n        ArrayList<Integer> diff=new ArrayList<>();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=goal.charAt(i)) {\\n                diff.add(i);\\n            }\\n        }\\n        if(diff.size()==2 && s.charAt(diff.get(0))==goal.charAt(diff.get(1)) &&  s.charAt(diff.get(1))==goal.charAt(diff.get(0)) ){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length()!= goal.length()){\\n            return false;\\n        }\\n        HashSet<Character> set=new HashSet<>();\\n        if(s.equals(goal)){\\n           for(char c:s.toCharArray()){\\n               set.add(c);\\n           }\\n           if(set.size()<s.length()){\\n               return true;\\n           }\\n           return false;\\n        }\\n        ArrayList<Integer> diff=new ArrayList<>();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=goal.charAt(i)) {\\n                diff.add(i);\\n            }\\n        }\\n        if(diff.size()==2 && s.charAt(diff.get(0))==goal.charAt(diff.get(1)) &&  s.charAt(diff.get(1))==goal.charAt(diff.get(0)) ){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710903,
                "title": "c-character-comparison-and-swapping-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Upon initial analysis of the code, here are my thoughts on how to solve the problem:\\n\\n1. The function `buddyStrings` takes two strings, `s` and `goal`, and determines if it is possible to swap two characters in `s` to make it equal to `goal`. The function returns a boolean value indicating whether this is possible.\\n\\n2. The first condition checks if the sizes of `s` and `goal` are different or if the size is 1. If either of these conditions is true, it immediately returns `false` because it is not possible to swap characters in these cases.\\n\\n3. The code uses two vectors, `different` and `ct`. The `different` vector stores the indices where the characters in `s` and `goal` are different. The `ct` vector is used to count the occurrences of each character in `s`.\\n\\n4. The loop iterates over each character in `s` and checks if it is different from the corresponding character in `goal`. If they are different, the index is added to the `different` vector. Otherwise, the count of that character in `s` is incremented in the `ct` vector. If a character occurs more than or equal to twice, the flag `f` is set to true.\\n\\n5. After the loop, several conditions are checked:\\n\\n   - If there are more than 2 different characters, it is not possible to swap two characters to make `s` equal to `goal`. In this case, the function returns `false`.\\n   - If there is only 1 different character, it is also not possible to perform the swap. The function returns `false`.\\n   - If there are no different characters (`different.size() == 0`), the function returns the value of `f`, which indicates whether there are duplicate characters in `s`.\\n\\n6. If the code reaches this point, it means there are exactly 2 different characters in `s`. The code swaps these characters in `s` using the indices stored in `different`.\\n\\n7. Finally, the code checks if the swapped string `s` is equal to `goal`. If they are equal, the function returns `true`; otherwise, it returns `false`.\\n\\nThese are my initial thoughts on how the code solves the problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Based on the provided code, the approach to solving the problem can be summarized as follows:\\n\\n1. The initial checks ensure that the sizes of the input strings are compatible for swapping characters and that they are not trivial cases where swapping is not possible.\\n\\n2. The code iterates through each character of the strings `s` and `goal`. It identifies the indices where the characters differ and stores them in the `different` vector. Additionally, it keeps track of the count of each character in `s` using the `ct` vector and sets the flag `f` if any character occurs more than or equal to twice.\\n\\n3. After the loop, several conditions are checked to determine if swapping is possible or not. If there are more than 2 different characters or if there is only 1 different character, it is not possible to perform the swap, and the function returns `false`. If there are no different characters, the function returns the value of the `f` flag, indicating whether there are duplicate characters in `s`.\\n\\n4. If there are exactly 2 different characters, the code swaps these characters in `s` using the indices stored in the `different` vector.\\n\\n5. Finally, the code checks if the swapped string `s` is equal to the `goal` string. If they are equal, the function returns `true`; otherwise, it returns `false`.\\n\\nOverall, the approach involves identifying the differences between the input strings, handling various edge cases, and determining if the strings can be made equal by swapping two characters.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        // Check if the sizes of the strings are different or if the size is 1\\n        // In such cases, it\\'s not possible to swap characters to make the strings equal\\n        if (s.size() != goal.size() || s.size() == 1)\\n            return false;\\n        \\n        vector<int> different; // Store the indices where the characters are different\\n        vector<int> ct(26, 0); // Store the count of each character in string s\\n        bool f = false; // Flag to check if there are duplicate characters in string s\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] != goal[i])\\n                different.push_back(i); // Add index to the different vector\\n            else {\\n                ct[s[i] - \\'a\\']++; // Increment the count of character s[i]\\n                if (ct[s[i] - \\'a\\'] >= 2)\\n                    f = true; // Set flag to true if character s[i] is repeated\\n            }\\n        }\\n        \\n        if (different.size() > 2)\\n            return false; // If there are more than 2 different characters, swapping is not possible\\n        \\n        if (different.size() == 1)\\n            return false; // If there is only 1 different character, swapping is not possible\\n        \\n        if (different.size() == 0)\\n            return f; // If there are no different characters, return whether there are duplicate characters\\n        \\n        // There are exactly 2 different characters, so swap them in string s\\n        int in1, in2;\\n        in1 = different[0];\\n        in2 = different[1];\\n        swap(s[in1], s[in2]);\\n        \\n        // Check if the swapped string is equal to the goal string\\n        return s == goal;\\n    }\\n};\\n\\n```\\n![Leetcode.jpeg](https://assets.leetcode.com/users/images/7ab32acb-7f72-480e-817d-8eb12f49e71b_1688358519.6356623.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        // Check if the sizes of the strings are different or if the size is 1\\n        // In such cases, it\\'s not possible to swap characters to make the strings equal\\n        if (s.size() != goal.size() || s.size() == 1)\\n            return false;\\n        \\n        vector<int> different; // Store the indices where the characters are different\\n        vector<int> ct(26, 0); // Store the count of each character in string s\\n        bool f = false; // Flag to check if there are duplicate characters in string s\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] != goal[i])\\n                different.push_back(i); // Add index to the different vector\\n            else {\\n                ct[s[i] - \\'a\\']++; // Increment the count of character s[i]\\n                if (ct[s[i] - \\'a\\'] >= 2)\\n                    f = true; // Set flag to true if character s[i] is repeated\\n            }\\n        }\\n        \\n        if (different.size() > 2)\\n            return false; // If there are more than 2 different characters, swapping is not possible\\n        \\n        if (different.size() == 1)\\n            return false; // If there is only 1 different character, swapping is not possible\\n        \\n        if (different.size() == 0)\\n            return f; // If there are no different characters, return whether there are duplicate characters\\n        \\n        // There are exactly 2 different characters, so swap them in string s\\n        int in1, in2;\\n        in1 = different[0];\\n        in2 = different[1];\\n        swap(s[in1], s[in2]);\\n        \\n        // Check if the swapped string is equal to the goal string\\n        return s == goal;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710770,
                "title": "c-easy-solution-using-vectors",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLooping through the string and storing frequency count of each character, if its note same return false. While looping checking if there are more than 2 places with different characters, then return false. Finally checking if there is difference if exactly 2 places then return true and if difference is of 0 places then checking if there is a character with frequency >=2 , if yes return true else return false\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.length()!=goal.length())\\n        return false;\\n        vector<int> temp(26,0);\\n        vector<int> temp2(26,0);\\n        int diff=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            temp[s[i]-\\'a\\']++;\\n            temp2[goal[i]-\\'a\\']++;\\n            if(s[i]!=goal[i])\\n            diff++;\\n\\n            if(diff>2)\\n            return false;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(temp[i]!=temp2[i])\\n            return false;\\n        }\\n        if(diff==2)\\n        return true;\\n        else\\n        {\\n            for(int i=0;i<26;i++)\\n            {\\n                if(temp[i]==0)\\n                continue;\\n                if(temp[i]>=2)\\n                return true;\\n            }\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.length()!=goal.length())\\n        return false;\\n        vector<int> temp(26,0);\\n        vector<int> temp2(26,0);\\n        int diff=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            temp[s[i]-\\'a\\']++;\\n            temp2[goal[i]-\\'a\\']++;\\n            if(s[i]!=goal[i])\\n            diff++;\\n\\n            if(diff>2)\\n            return false;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(temp[i]!=temp2[i])\\n            return false;\\n        }\\n        if(diff==2)\\n        return true;\\n        else\\n        {\\n            for(int i=0;i<26;i++)\\n            {\\n                if(temp[i]==0)\\n                continue;\\n                if(temp[i]>=2)\\n                return true;\\n            }\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710761,
                "title": "simple-c-100-ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()) return 0;\\n        int c=0;\\n        unordered_map<char,int> m;\\n        char prev1=\\'@\\',prev2=\\'@\\';\\n        int t=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i]) t++;\\n            if(s[i]!=goal[i] && ((goal[i]==prev1 && s[i]==prev2) || prev1==\\'@\\')){\\n                c++;\\n                prev1=s[i];\\n                prev2=goal[i];\\n            } \\n            m[s[i]]++;\\n        }\\n        int flag=0;\\n        for(auto i:m){\\n            if(i.second>1) {flag=1;\\n            break;\\n        }\\n        }\\n        if((c==2 && t==2) || (t==0 && flag==1)) return 1;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()) return 0;\\n        int c=0;\\n        unordered_map<char,int> m;\\n        char prev1=\\'@\\',prev2=\\'@\\';\\n        int t=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i]) t++;\\n            if(s[i]!=goal[i] && ((goal[i]==prev1 && s[i]==prev2) || prev1==\\'@\\')){\\n                c++;\\n                prev1=s[i];\\n                prev2=goal[i];\\n            } \\n            m[s[i]]++;\\n        }\\n        int flag=0;\\n        for(auto i:m){\\n            if(i.second>1) {flag=1;\\n            break;\\n        }\\n        }\\n        if((c==2 && t==2) || (t==0 && flag==1)) return 1;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710429,
                "title": "c-easiest-2-approaches-map-two-pointers",
                "content": "# Approach\\n- Using hash function \\n    - check hash and swap \\n- Two pointers \\n    - Loop high and low and swap and check if them don\\'t match \\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        unordered_map<char,int>mp;\\n        for(int i =0; i<s.length(); i++) mp[s[i]] = i;\\n        for(int i =0; i<goal.length(); i++){\\n            if(mp.find(goal[i]) == mp.end()) return false;\\n            if(mp[goal[i]] != i){\\n                swap(s[i], s[mp[goal[i]]]);\\n                if(s == goal) return true;\\n                swap(s[i], s[mp[goal[i]]]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n# Two Pointers \\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.length() != goal.length()) return 0;\\n        if(s == goal) return (set<char>(s.begin(), s.end())).size()<s.length();\\n        int low =0, high = s.length()-1;\\n        while(low<=high && s[low] == goal[low]){\\n            low++;\\n        }\\n        while(high >=0 && s[high]== goal[high]){\\n            high--;\\n        }\\n        if(low<high){\\n            swap(s[low], s[high]);\\n        }\\n        return s==goal;\\n    }\\n};\\n```\\n\\nPlease Upvote \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F \\uD83E\\uDD1C\\uD83E\\uDD1B",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        unordered_map<char,int>mp;\\n        for(int i =0; i<s.length(); i++) mp[s[i]] = i;\\n        for(int i =0; i<goal.length(); i++){\\n            if(mp.find(goal[i]) == mp.end()) return false;\\n            if(mp[goal[i]] != i){\\n                swap(s[i], s[mp[goal[i]]]);\\n                if(s == goal) return true;\\n                swap(s[i], s[mp[goal[i]]]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.length() != goal.length()) return 0;\\n        if(s == goal) return (set<char>(s.begin(), s.end())).size()<s.length();\\n        int low =0, high = s.length()-1;\\n        while(low<=high && s[low] == goal[low]){\\n            low++;\\n        }\\n        while(high >=0 && s[high]== goal[high]){\\n            high--;\\n        }\\n        if(low<high){\\n            swap(s[low], s[high]);\\n        }\\n        return s==goal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710369,
                "title": "daily-leetcoding-challenge-july-day-3",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/buddy-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/buddy-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3645284,
                "title": "very-easy-approach-in-c-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        unordered_map<char, int> mp;\\n        for(int i=0;i<s.length();i++) mp[s[i]] = i;\\n        for(int i=0;i<goal.length();i++){\\n            //if(mp.find(goal[i]) == mp.end()) return false;\\n            if(mp[goal[i]] != i){\\n                swap(s[i], s[mp[goal[i]]]);\\n                if(s == goal) return true;\\n                swap(s[i], s[mp[goal[i]]]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n# Upvote if helped",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        unordered_map<char, int> mp;\\n        for(int i=0;i<s.length();i++) mp[s[i]] = i;\\n        for(int i=0;i<goal.length();i++){\\n            //if(mp.find(goal[i]) == mp.end()) return false;\\n            if(mp[goal[i]] != i){\\n                swap(s[i], s[mp[goal[i]]]);\\n                if(s == goal) return true;\\n                swap(s[i], s[mp[goal[i]]]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884790,
                "title": "java-easiest-solution-posiible",
                "content": "\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        int m = s.length(), n = goal.length();\\n        if (m != n) {\\n            return false;\\n        }\\n        int diff = 0;\\n        int[] cnt1 = new int[26];\\n        int[] cnt2 = new int[26];\\n        for (int i = 0; i < n; ++i) {\\n            int a = s.charAt(i), b = goal.charAt(i);\\n            ++cnt1[a - \\'a\\'];\\n            ++cnt2[b - \\'a\\'];\\n            if (a != b) {\\n                ++diff;\\n            }\\n        }\\n        boolean f = false;\\n        for (int i = 0; i < 26; ++i) {\\n            if (cnt1[i] != cnt2[i]) {\\n                return false;\\n            }\\n            if (cnt1[i] > 1) {\\n                f = true;\\n            }\\n        }\\n        return diff == 2 || (diff == 0 && f);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        int m = s.length(), n = goal.length();\\n        if (m != n) {\\n            return false;\\n        }\\n        int diff = 0;\\n        int[] cnt1 = new int[26];\\n        int[] cnt2 = new int[26];\\n        for (int i = 0; i < n; ++i) {\\n            int a = s.charAt(i), b = goal.charAt(i);\\n            ++cnt1[a - \\'a\\'];\\n            ++cnt2[b - \\'a\\'];\\n            if (a != b) {\\n                ++diff;\\n            }\\n        }\\n        boolean f = false;\\n        for (int i = 0; i < 26; ++i) {\\n            if (cnt1[i] != cnt2[i]) {\\n                return false;\\n            }\\n            if (cnt1[i] > 1) {\\n                f = true;\\n            }\\n        }\\n        return diff == 2 || (diff == 0 && f);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347659,
                "title": "python-easy-explanation",
                "content": "Success\\nDetails \\nRuntime: 35 ms, faster than **91.06%** of Python3 online submissions.\\nMemory Usage: 14.1 MB, less than **96.20%** of Python3 online submissions.\\n\\n1. If Length of s and goal is not same the it is not possible to make s equal to goal\\n\\n2. If s and goal are already same then there should be atleast on element in s which apprears two times so that we can replace that element. If no such element is present then return False\\n3. Finally we append all the indexes for wich elemnts of s is not equal to element of goal\\n4. If there are more than 2 such index return False since we are allowed to do only on swap.\\n5. If the element of s present at index l[0] is equal to element of goal present at index [l[1]] and vice versa return true\\n\\n***Leave an upvote if this helps***\\n\\n```\\nclass Solution:\\n    def buddyStrings(self, s, goal):\\n        l=[]\\n        if len(s)!=len(goal):\\n            return False\\n        if s==goal and len(set(s))<len(s):\\n            return True\\n        for i in range(len(s)):\\n            if s[i]!=goal[i]:\\n                l.append(i)\\n        if len(l)==2 and s[l[0]]==goal[l[1]] and s[l[1]]==goal[l[0]]:\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, s, goal):\\n        l=[]\\n        if len(s)!=len(goal):\\n            return False\\n        if s==goal and len(set(s))<len(s):\\n            return True\\n        for i in range(len(s)):\\n            if s[i]!=goal[i]:\\n                l.append(i)\\n        if len(l)==2 and s[l[0]]==goal[l[1]] and s[l[1]]==goal[l[0]]:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363721,
                "title": "easily-understandable-c-solution",
                "content": "``\\nMost important point: One swap is necessary in this question...\\nFirstly we sort both the strings ,if they aren\\'t equal then there\\'s no chance of getting the same string by swapping as well ,so we return false;\\nthen we check for the no.of elements at corresponding indices which are different from one another,if it becomes 2 then we can swap s string once  to become same as goal...\\nif count is greater than 2 then there is no way we can convert s into goal just by performing one swap so it will obviously be false;\\nOnly one catch that is present is if we are given two equal strings e.g s=\"aabc\" goal=\"aabc\" the  count will be 0 but after swapping a with a we will be having the same string,hence we have to return true and that is why i have taken map to track if any element is repeating...\\nWe can\\'t return count<=2, because in case of s=\"ab\" goal=\"ab\" we have to return false because one swap is necessary and we can\\'t perform a swap in ab to make it equal to ab and henceforth we can\\'t return count<=2. \\n        \\n    \\n\\t\\n\\tstring s1=s;\\n    string s2=goal;\\n\\tsort(s1.begin(),s1.end());    \\n    sort(s2.begin(),s2.end());    \\n    map<int,int>m;\\n        \\n    if(s1!=s2){\\n        return false;\\n    }    \\n    int count=0; \\n    bool d=false;\\n    for(int i=0;i<s.size();i++){\\n    if(s[i]!=goal[i]){\\n    count++;\\n    }    \\n    m[s[i]]++;\\n    if(m[s[i]]==2){\\n    d=true;    \\n    }    \\n        \\n    }\\n        \\n        if(count==0&&d==true){\\n            return true;\\n        }\\n        return count==2;",
                "solutionTags": [],
                "code": "``\\nMost important point: One swap is necessary in this question...\\nFirstly we sort both the strings ,if they aren\\'t equal then there\\'s no chance of getting the same string by swapping as well ,so we return false;\\nthen we check for the no.of elements at corresponding indices which are different from one another,if it becomes 2 then we can swap s string once  to become same as goal...\\nif count is greater than 2 then there is no way we can convert s into goal just by performing one swap so it will obviously be false;\\nOnly one catch that is present is if we are given two equal strings e.g s=\"aabc\" goal=\"aabc\" the  count will be 0 but after swapping a with a we will be having the same string,hence we have to return true and that is why i have taken map to track if any element is repeating...\\nWe can\\'t return count<=2, because in case of s=\"ab\" goal=\"ab\" we have to return false because one swap is necessary and we can\\'t perform a swap in ab to make it equal to ab and henceforth we can\\'t return count<=2. \\n        \\n    \\n\\t\\n\\tstring s1=s;\\n    string s2=goal;\\n\\tsort(s1.begin(),s1.end());    \\n    sort(s2.begin(),s2.end());    \\n    map<int,int>m;\\n        \\n    if(s1!=s2){\\n        return false;\\n    }    \\n    int count=0; \\n    bool d=false;\\n    for(int i=0;i<s.size();i++){\\n    if(s[i]!=goal[i]){\\n    count++;\\n    }    \\n    m[s[i]]++;\\n    if(m[s[i]]==2){\\n    d=true;    \\n    }    \\n        \\n    }\\n        \\n        if(count==0&&d==true){\\n            return true;\\n        }\\n        return count==2;",
                "codeTag": "Unknown"
            },
            {
                "id": 1281630,
                "title": "simple-easy-to-understand-c-code",
                "content": "```\\nbool buddyStrings(string s, string goal) \\n    {\\n        if(s.length()!=goal.length())  // if unequal length then return false \\n            return false;\\n        \\n        if(s==goal)\\n        {\\n            unordered_set<char> a=unordered_set<char>(s.begin(),s.end());  \\n            return a.size()<s.length();  // checking if string is madeup of same character eg. \" aa\" or not eg. \"ab\"\\n        }\\n        \\n        vector<int> v;\\n        for(int i=0;i<s.length();i++)  //chech index where the character are unequal.\\n        {\\n            if(s[i]!=goal[i])    \\n            v.push_back(i);\\n        }\\n        \\n        return (v.size()==2 && s[v[0]]==goal[v[1]] && s[v[1]]==goal[v[0]]); \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool buddyStrings(string s, string goal) \\n    {\\n        if(s.length()!=goal.length())  // if unequal length then return false \\n            return false;\\n        \\n        if(s==goal)\\n        {\\n            unordered_set<char> a=unordered_set<char>(s.begin(),s.end());  \\n            return a.size()<s.length();  // checking if string is madeup of same character eg. \" aa\" or not eg. \"ab\"\\n        }\\n        \\n        vector<int> v;\\n        for(int i=0;i<s.length();i++)  //chech index where the character are unequal.\\n        {\\n            if(s[i]!=goal[i])    \\n            v.push_back(i);\\n        }\\n        \\n        return (v.size()==2 && s[v[0]]==goal[v[1]] && s[v[1]]==goal[v[0]]); \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 891116,
                "title": "c-efficient-solution-explained-100-time-10-space",
                "content": "I have to admit I lowered my guard and this tricky one threw a few tricky edge jabs in my face; I still managed to reach my goal - to solve it using as little extra variables/space as possible.\\n\\nWell, good experience and good learning then :)!\\n\\nOkay, first of all I declared just 2 support variables:\\n* `lenA` that, you guessed it, will store the length of the first string;\\n* `diff` that will store how many mismatches we found in the string and/or where (basically acting as 2 variables in 1, to save memory):\\n\\t* a negative value, like `-1`, the initial value, or `-2` means that we found an even number of mismatches (`0` or `2`, respectively);\\n\\t* a non-negative value, means we found a single mismatch and the value itself is the index of said difference among the 2 strings.\\n\\nNext step: getting rid of some edge cases, returning `false` when either:\\n* the 2 strings have different length;\\n* the 2 strings are too short (you cannot swap anything with less than 2 characters).\\n\\nThe first condition guarantees us that if we are proceeding, now we know both strings have the same size.\\n\\nAnd proceding we go, looping through each character with the index `i`, so that every time we find a mismatch between `a[i]` and `b[i]`, we go and check `diff`\\'s value:\\n* `-1` means that we did not find any mismatch so far, so we just updated it to be the `i`, storing where the mismatch happened;\\n* `-2` means we already found 2 mismatches, so this is the third and we just have to return `false`;\\n* a non negative value means we found one previous mismatch, so now we go and check:\\n\\t* if `a[diff] == b[i] && a[i] == b[diff]` it means that they values are no swappable, so again we can just return `false`;\\n\\t* otherwise we are fine and just update `diff` to `-2`.\\n\\nOnce the loop is done, we will return `true` if we either:\\n* found 2 mismatches (`diff == -2`), which is the ideal case;\\n* or we found 0 mismatches (`diff == -1`), but only if we had at least 2 equal characters we might have swapped, so only if `lenA > 26` (since having only lower case letters would imply that a greater length has to repeat characters) or if `unordered_set(begin(a), end(a)).size() != lenA` - note that this option to check all the characters is more expensive, but it gets lazy evaluated only when the other condition for `diff == -1` fails, so it never runs for long strings :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool buddyStrings(string &a, string &b) {\\n        // support variables\\n        int lenA = a.size(), diff = -1;\\n        // edge cases, out: different sizes or too short\\n        if (lenA != b.size() || lenA < 2) return false; \\n        for (int i = 0; i < lenA; i++) {\\n            // acting only when a difference is found\\n            if (a[i] != b[i]) {\\n                // checking if it is the first difference we found and in case storing i\\n                if (diff == -1) {\\n                    diff = i;\\n                }\\n                // exiting if it was the third mismatch\\n                else if (diff == -2) return false;\\n                // checking if it is a valid or invalid second match\\n                else {\\n                    // valid match\\n                    if (a[diff] == b[i] && a[i] == b[diff]) diff = -2;\\n                    // invalid match\\n                    else return false;\\n                }\\n            }\\n        }\\n        // checking if we found only 2 mismatches or if we found 1 and the string was\\n        // long enough or not made of all different characters\\n        return diff == -2 || diff == -1 && (lenA > 26 || unordered_set(begin(a), end(a)).size() != lenA);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool buddyStrings(string &a, string &b) {\\n        // support variables\\n        int lenA = a.size(), diff = -1;\\n        // edge cases, out: different sizes or too short\\n        if (lenA != b.size() || lenA < 2) return false; \\n        for (int i = 0; i < lenA; i++) {\\n            // acting only when a difference is found\\n            if (a[i] != b[i]) {\\n                // checking if it is the first difference we found and in case storing i\\n                if (diff == -1) {\\n                    diff = i;\\n                }\\n                // exiting if it was the third mismatch\\n                else if (diff == -2) return false;\\n                // checking if it is a valid or invalid second match\\n                else {\\n                    // valid match\\n                    if (a[diff] == b[i] && a[i] == b[diff]) diff = -2;\\n                    // invalid match\\n                    else return false;\\n                }\\n            }\\n        }\\n        // checking if we found only 2 mismatches or if we found 1 and the string was\\n        // long enough or not made of all different characters\\n        return diff == -2 || diff == -1 && (lenA > 26 || unordered_set(begin(a), end(a)).size() != lenA);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 890941,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        //Base case\\n        if(A.length() != B.length()){\\n            return false;\\n        }\\n        //Two Cases :\\n        //Case 1: if both strings are same\\n        if(A.equals(B)){\\n            //get character count\\n            int[] count = new int[26];\\n            for(char c : A.toCharArray()){\\n                count[c - \\'a\\']++;\\n            }\\n            //check if there are characters of frequency greater than 1\\n            //Eg : A = aaaabc , B = aaaabc\\n            //since freq(a) > 1 , we can swap two a\\'s\\n            for(int freq : count){\\n                if(freq > 1){\\n                    return true;\\n                }\\n            }\\n            //no character has frequency greater than 1\\n            //Eg : A = abcd , B = abcd\\n            return false;\\n        }\\n        //Case 2 : if A and B are not equal\\n        else{\\n            //get pos of elements to swap\\n            int first = -1;\\n            int second = -1;\\n            for(int i=0;i<A.length();i++){\\n                if(A.charAt(i) != B.charAt(i)){\\n                    //check if we filled first index\\n                    if(first == -1){\\n                        first = i;\\n                    }\\n                    //check if we filled first index\\n                    else if(second == -1){\\n                        second = i;\\n                    }\\n                    //both first and second are filled and there exists a third diff\\n                    else{\\n                        return false;\\n                    }\\n                }\\n            }\\n            //check if second pos is not filled\\n            if(second == -1){\\n                return false;\\n            }\\n            //check id characters at pos are same\\n            return (A.charAt(first) == B.charAt(second)) && (A.charAt(second) == B.charAt(first));\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        //Base case\\n        if(A.length() != B.length()){\\n            return false;\\n        }\\n        //Two Cases :\\n        //Case 1: if both strings are same\\n        if(A.equals(B)){\\n            //get character count\\n            int[] count = new int[26];\\n            for(char c : A.toCharArray()){\\n                count[c - \\'a\\']++;\\n            }\\n            //check if there are characters of frequency greater than 1\\n            //Eg : A = aaaabc , B = aaaabc\\n            //since freq(a) > 1 , we can swap two a\\'s\\n            for(int freq : count){\\n                if(freq > 1){\\n                    return true;\\n                }\\n            }\\n            //no character has frequency greater than 1\\n            //Eg : A = abcd , B = abcd\\n            return false;\\n        }\\n        //Case 2 : if A and B are not equal\\n        else{\\n            //get pos of elements to swap\\n            int first = -1;\\n            int second = -1;\\n            for(int i=0;i<A.length();i++){\\n                if(A.charAt(i) != B.charAt(i)){\\n                    //check if we filled first index\\n                    if(first == -1){\\n                        first = i;\\n                    }\\n                    //check if we filled first index\\n                    else if(second == -1){\\n                        second = i;\\n                    }\\n                    //both first and second are filled and there exists a third diff\\n                    else{\\n                        return false;\\n                    }\\n                }\\n            }\\n            //check if second pos is not filled\\n            if(second == -1){\\n                return false;\\n            }\\n            //check id characters at pos are same\\n            return (A.charAt(first) == B.charAt(second)) && (A.charAt(second) == B.charAt(first));\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762258,
                "title": "java-solution-clear-explanation-simple-fast-directly-check-swap",
                "content": "```\\n/*\\nsituation1:A B different length\\nsituation2:same length&&A equals to B\\n    if A contains the duplicate letters,after swapping the duplicate letters,A and B are Buddy Strings.\\nsituation3: the rest: same length,A differ from B    \\n    the ONLY true situation here: A only have 2 different char,A equals to B after swap.                        \\n*/\\n\\nclass Solution {\\n     public boolean buddyStrings(String A, String B) {\\n        \\n        int A_length = A.length();\\n        char Achar[] = A.toCharArray();\\n         \\n        if (A_length != B.length())             //situation1\\n            return false;\\n        \\n        if(A.equals(B)){                        //situation2\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\tSet set1=new HashSet();                   \\n\\t\\t\\t\\tfor(int i=0;i < A_length ;i++){        \\n                if(set1.contains(Achar[i]))              \\n                    return true;                \\n                else\\n                    set1.add(Achar[i]);        \\n            }     \\n            return false;\\n        }\\n                                                \\n                                             // situation3: the rest :\\n        char Bchar[] = B.toCharArray();\\n        char A1=0,B1=0;                       // when the 1st Discrepancy happen,A1 is Achar[i], B1 is Bchar[i]\\n        int j=0;                              //j :count the number of Achar[i]!=Bchar[i]\\n        for(int i=0; i< A_length &&j<3;i++){                \\n           if(Achar[i]!=Bchar[i]){                   \\n                j++;                                           \\n               if(j==1){\\n                    A1=Achar[i];               // record Achar[i] and Bchar[i] in A1, B1.\\n                    B1=Bchar[i];                             \\n               }                                                                             \\n               if(j==2 && (Achar[i]!=B1 || Bchar[i]!=A1) )  //when the 2st Discrepancy happen :            \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t                        //the only false situation here when j==2\\n\\t\\t\\t\\t\\treturn false;\\t\\t       \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t          \\n           }            \\n        }                       \\n        return j==2;      //the rest situation:\\n\\t\\t\\t\\t\\t\\t\\t    //all the other j==2 situation is true after loop,\\n\\t\\t\\t\\t\\t\\t\\t\\t//j=1 false, because unable to swap.\\n                                //j>2 false, because we can swap only 2 letters.\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nsituation1:A B different length\\nsituation2:same length&&A equals to B\\n    if A contains the duplicate letters,after swapping the duplicate letters,A and B are Buddy Strings.\\nsituation3: the rest: same length,A differ from B    \\n    the ONLY true situation here: A only have 2 different char,A equals to B after swap.                        \\n*/\\n\\nclass Solution {\\n     public boolean buddyStrings(String A, String B) {\\n        \\n        int A_length = A.length();\\n        char Achar[] = A.toCharArray();\\n         \\n        if (A_length != B.length())             //situation1\\n            return false;\\n        \\n        if(A.equals(B)){                        //situation2\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\tSet set1=new HashSet();                   \\n\\t\\t\\t\\tfor(int i=0;i < A_length ;i++){        \\n                if(set1.contains(Achar[i]))              \\n                    return true;                \\n                else\\n                    set1.add(Achar[i]);        \\n            }     \\n            return false;\\n        }\\n                                                \\n                                             // situation3: the rest :\\n        char Bchar[] = B.toCharArray();\\n        char A1=0,B1=0;                       // when the 1st Discrepancy happen,A1 is Achar[i], B1 is Bchar[i]\\n        int j=0;                              //j :count the number of Achar[i]!=Bchar[i]\\n        for(int i=0; i< A_length &&j<3;i++){                \\n           if(Achar[i]!=Bchar[i]){                   \\n                j++;                                           \\n               if(j==1){\\n                    A1=Achar[i];               // record Achar[i] and Bchar[i] in A1, B1.\\n                    B1=Bchar[i];                             \\n               }                                                                             \\n               if(j==2 && (Achar[i]!=B1 || Bchar[i]!=A1) )  //when the 2st Discrepancy happen :            \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t                        //the only false situation here when j==2\\n\\t\\t\\t\\t\\treturn false;\\t\\t       \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t          \\n           }            \\n        }                       \\n        return j==2;      //the rest situation:\\n\\t\\t\\t\\t\\t\\t\\t    //all the other j==2 situation is true after loop,\\n\\t\\t\\t\\t\\t\\t\\t\\t//j=1 false, because unable to swap.\\n                                //j>2 false, because we can swap only 2 letters.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 456125,
                "title": "java-another-solution-with-explanation",
                "content": "2 cases for String to be buddy\\n-> only 2 unequal pairs in String which are inverted.\\n-> all equal pairs and a atleast a char with freq > 2 which we can swap\\n```\\npublic boolean buddyStrings(String A, String B) {\\n\\n\\tif(A.length()!=B.length()) return false;            //if length not equal Strings ain\\'t buddy\\n\\n\\tHashMap<Character, Character> hm = new HashMap();   //stores unequal char pairs\\n\\tint counts[] = new int[26], count = 0;              //counts will store frequency, count stores unequal char freq\\n\\n\\tfor(int i=0; i<A.length(); i++) {\\n\\t\\tchar a = A.charAt(i), b = B.charAt(i);\\n\\t\\tcounts[a-\\'a\\']++;                                //store counts of all characters in A (we just need a char with freq >2)\\n\\t\\tif(a!=b) {\\n\\t\\t\\tif(++count>2)                               //if count of unequal chars > 2 strings ain\\'t buddy\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\thm.put(a,b);    \\n\\t\\t}\\n\\t}\\n\\n\\tfor(Map.Entry<Character, Character> e : hm.entrySet()) \\n\\t\\treturn hm.get(e.getValue())==e.getKey();        //check if unequal pairs are inverted\\n\\n\\tboolean flag = false;\\n\\tfor(int i : counts)\\n\\t\\tif(i>=2) {                                      //check if any char occurs more than twice\\n\\t\\t\\tflag = true;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\treturn count==0 && flag;                            //check if no unequal pair and atleast a char with freq>2\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean buddyStrings(String A, String B) {\\n\\n\\tif(A.length()!=B.length()) return false;            //if length not equal Strings ain\\'t buddy\\n\\n\\tHashMap<Character, Character> hm = new HashMap();   //stores unequal char pairs\\n\\tint counts[] = new int[26], count = 0;              //counts will store frequency, count stores unequal char freq\\n\\n\\tfor(int i=0; i<A.length(); i++) {\\n\\t\\tchar a = A.charAt(i), b = B.charAt(i);\\n\\t\\tcounts[a-\\'a\\']++;                                //store counts of all characters in A (we just need a char with freq >2)\\n\\t\\tif(a!=b) {\\n\\t\\t\\tif(++count>2)                               //if count of unequal chars > 2 strings ain\\'t buddy\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\thm.put(a,b);    \\n\\t\\t}\\n\\t}\\n\\n\\tfor(Map.Entry<Character, Character> e : hm.entrySet()) \\n\\t\\treturn hm.get(e.getValue())==e.getKey();        //check if unequal pairs are inverted\\n\\n\\tboolean flag = false;\\n\\tfor(int i : counts)\\n\\t\\tif(i>=2) {                                      //check if any char occurs more than twice\\n\\t\\t\\tflag = true;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\treturn count==0 && flag;                            //check if no unequal pair and atleast a char with freq>2\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3713901,
                "title": "set-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int n = s.size();\\n        if(goal.size() != n) return false;\\n\\n       if(s == goal) {\\n           unordered_set<char> seen;\\n           for(char c : s) {\\n               if(seen.find(c) != seen.end()) return true;\\n               seen.insert(c);\\n           }\\n           return false;\\n       }\\n\\n       vector<int> idx;\\n       for(int i=0; i<n; i++) {\\n           if(s[i] != goal[i]) idx.push_back(i);\\n       }\\n\\n       if(idx.size() == 2) {\\n           if(s[idx[0]] == goal[idx[1]] && s[idx[1]] == goal[idx[0]]) return true;\\n       }\\n       return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int n = s.size();\\n        if(goal.size() != n) return false;\\n\\n       if(s == goal) {\\n           unordered_set<char> seen;\\n           for(char c : s) {\\n               if(seen.find(c) != seen.end()) return true;\\n               seen.insert(c);\\n           }\\n           return false;\\n       }\\n\\n       vector<int> idx;\\n       for(int i=0; i<n; i++) {\\n           if(s[i] != goal[i]) idx.push_back(i);\\n       }\\n\\n       if(idx.size() == 2) {\\n           if(s[idx[0]] == goal[idx[1]] && s[idx[1]] == goal[idx[0]]) return true;\\n       }\\n       return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713851,
                "title": "potd-buddy-strings-easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAlways try to solve by brute force approach and then go for optimal solution but in this case test case is so high so it causes TLE.\\nSo I try with help of Set and then a vector to solve this question.\\nI hope you will love it.\\nAny Suggestion will be appreciated. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        // TLE SOLUTION:\\n        // for(int i=0;i<s.size();i++){\\n        //     for(int j=i+1;j<s.size();j++){\\n        //         swap(s[i],s[j]);\\n        //         if(s==goal) return true;\\n        //         else swap(s[i],s[j]);\\n        //     }\\n        // }\\n        // return false;\\n\\n      if(s.size()!=goal.size() || s.size()<=1) {\\n          return false;\\n      }\\n      if(s==goal){\\n      set<char>st(s.begin(),s.end());\\n      return  st.size()<s.size();\\n      }\\n      vector<int>v;\\n      for(int i=0;i<s.size();i++){\\n          if(s[i]!=goal[i]){\\n              v.push_back(i);\\n          }\\n      }\\n      if(v.size()!=2) {\\n      return false;\\n      }\\n        swap(s[v[0]],s[v[1]]);\\n        return s==goal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        // TLE SOLUTION:\\n        // for(int i=0;i<s.size();i++){\\n        //     for(int j=i+1;j<s.size();j++){\\n        //         swap(s[i],s[j]);\\n        //         if(s==goal) return true;\\n        //         else swap(s[i],s[j]);\\n        //     }\\n        // }\\n        // return false;\\n\\n      if(s.size()!=goal.size() || s.size()<=1) {\\n          return false;\\n      }\\n      if(s==goal){\\n      set<char>st(s.begin(),s.end());\\n      return  st.size()<s.size();\\n      }\\n      vector<int>v;\\n      for(int i=0;i<s.size();i++){\\n          if(s[i]!=goal[i]){\\n              v.push_back(i);\\n          }\\n      }\\n      if(v.size()!=2) {\\n      return false;\\n      }\\n        swap(s[v[0]],s[v[1]]);\\n        return s==goal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713803,
                "title": "simple-self-explanatory-code",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf the size of the string is not same return false and if the strings are exactly same make a map and store all the characters if you find the same character which means one letter occurs two times so simply return true other wise return false and if the strings are same size and not equal maintain a counter and two strings a and b in which not same characters of s and goal will be appended then at end check if counter is 2 and string a is equal of reverse of b, if so return true..otherwise return false\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()) return false;\\n       if(s==goal){\\n           unordered_map<char,int>mp;\\n           for(int i=0;i<s.size();i++){\\n               if(mp.find(s[i])!=mp.end()){\\n                   return true;\\n               }\\n               mp[s[i]]++;\\n           }\\n           return false;\\n       }\\n       int mini = min(s.size(),goal.size());\\n       int ct = 0;\\n       int ct1=0;\\n       string a=\"\";\\n       string b=\"\";\\n       for(int i=0;i<mini;i++){\\n           if(s[i]!=goal[i]){\\n               a=a+s[i];\\n               b=b+goal[i];\\n               ct++;\\n           }\\n\\n       }\\n       reverse(b.begin(),b.end());\\n       if(ct==2 && a==b) return true;\\n       return false;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()) return false;\\n       if(s==goal){\\n           unordered_map<char,int>mp;\\n           for(int i=0;i<s.size();i++){\\n               if(mp.find(s[i])!=mp.end()){\\n                   return true;\\n               }\\n               mp[s[i]]++;\\n           }\\n           return false;\\n       }\\n       int mini = min(s.size(),goal.size());\\n       int ct = 0;\\n       int ct1=0;\\n       string a=\"\";\\n       string b=\"\";\\n       for(int i=0;i<mini;i++){\\n           if(s[i]!=goal[i]){\\n               a=a+s[i];\\n               b=b+goal[i];\\n               ct++;\\n           }\\n\\n       }\\n       reverse(b.begin(),b.end());\\n       if(ct==2 && a==b) return true;\\n       return false;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713261,
                "title": "python-solution-beats-70",
                "content": "# Intuition\\nWhen the problem mentions swapping two characters in a string to make it equal to another string, it\\'s clear that the two strings must have almost the same characters. There are two scenarios where this is possible: \\n1. The strings are already equal, and there is at least one character that occurs more than once (so that we can swap it with itself).\\n2. The strings have exactly two characters at different positions, and swapping them makes the strings equal.\\n\\n# Approach\\n1. If the lengths of `s` and `goal` are different, we can immediately return `False` because it\\'s impossible for them to be equal.\\n2. If `s` is equal to `goal`, check if there is at least one character that occurs more than once in `s`. If so, return `True`; otherwise, return `False`.\\n3. If `s` is not equal to `goal`, iterate through the characters in `s` and `goal` and keep track of the indices where the characters are different.\\n4. If there are exactly two indices where the characters are different, check if swapping the characters at these indices in `s` would make `s` equal to `goal`. If so, return `True`; otherwise, return `False`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where $$n$$ is the length of the input strings. This is because we iterate through each character in the strings once.\\n- Space complexity: $$O(1)$$, because the extra space used by the `diff_indices` list is constant (it can have at most 2 elements) and the set creation in the case where `s` is equal to `goal` also takes constant space.\\n\\n# Code\\n```python\\nclass Solution:\\n    def buddyStrings(self, s, goal):\\n        if len(s) != len(goal):\\n            return False\\n        \\n        if s == goal:\\n            return len(set(s)) < len(s)\\n        \\n        diff_indices = []\\n        for i in range(len(s)):\\n            if s[i] != goal[i]:\\n                diff_indices.append(i)\\n                if len(diff_indices) > 2:\\n                    return False\\n        \\n        return len(diff_indices) == 2 and s[diff_indices[0]] == goal[diff_indices[1]] and s[diff_indices[1]] == goal[diff_indices[0]]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def buddyStrings(self, s, goal):\\n        if len(s) != len(goal):\\n            return False\\n        \\n        if s == goal:\\n            return len(set(s)) < len(s)\\n        \\n        diff_indices = []\\n        for i in range(len(s)):\\n            if s[i] != goal[i]:\\n                diff_indices.append(i)\\n                if len(diff_indices) > 2:\\n                    return False\\n        \\n        return len(diff_indices) == 2 and s[diff_indices[0]] == goal[diff_indices[1]] and s[diff_indices[1]] == goal[diff_indices[0]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712774,
                "title": "no-map-and-no-vector-o-1-space-complexity-o-n-time-complexity-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreedy and Basic case making.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*log(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n       int n = s.size();\\n       if(s.size()!=goal.size()) return false;\\n       int s1=-1, s2=-1, cnt=0;\\n       for(int i = 0; i < s.size(); i++){\\n           if(s[i]!=goal[i] and s1==-1){\\n               s1=i;\\n               cnt++;\\n           }\\n           if(s[i]!=goal[i] and s1!=-1){\\n               s2=i;\\n               cnt++;\\n           }\\n       }\\n       if(cnt>3) return false;\\n       if(s==goal){\\n           sort(s.begin(),s.end());\\n           bool f = 0;\\n           for(int i = 1; i < n; i++) if(s[i]==s[i-1]){f=1;break;}\\n           return f;\\n       }\\n       if(s1==-1 and s2==-1) return true;\\n       cout<<cnt<<endl;\\n       cout<<s[s1]<<\" \"<<goal[s2]<<endl<<s[s2]<<\" \"<<goal[s1]<<endl;\\n       if(s[s1]==goal[s2] and s[s2]==goal[s1]) return true;\\n       return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n       int n = s.size();\\n       if(s.size()!=goal.size()) return false;\\n       int s1=-1, s2=-1, cnt=0;\\n       for(int i = 0; i < s.size(); i++){\\n           if(s[i]!=goal[i] and s1==-1){\\n               s1=i;\\n               cnt++;\\n           }\\n           if(s[i]!=goal[i] and s1!=-1){\\n               s2=i;\\n               cnt++;\\n           }\\n       }\\n       if(cnt>3) return false;\\n       if(s==goal){\\n           sort(s.begin(),s.end());\\n           bool f = 0;\\n           for(int i = 1; i < n; i++) if(s[i]==s[i-1]){f=1;break;}\\n           return f;\\n       }\\n       if(s1==-1 and s2==-1) return true;\\n       cout<<cnt<<endl;\\n       cout<<s[s1]<<\" \"<<goal[s2]<<endl<<s[s2]<<\" \"<<goal[s1]<<endl;\\n       if(s[s1]==goal[s2] and s[s2]==goal[s1]) return true;\\n       return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3712367,
                "title": "no-hashing-unique-and-simple-approach",
                "content": "# Intuition\\nJUST CHECK IN WHICH CASES WE CAN GET FALSE . HERE DIVIDE IT IN 4 PARTS . \\nIT BECOME SO EASY TO UNDERSTAND. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n First We can simply check the S and Goal if they have different size then return false.\\n1. PART : Store both The strings in 2 different strings thensort them and check whether they are Equal or Not .\\n    - Since IF they are not equal after sorting simply \\'S\\' Can Never change in \\'Goal\\' .\\n    - SO Return false if Not equal simply.\\n 1. PART : In this I am checking whether is there are any Repeating character.\\n     - If they have then simply make \\'flag=1\\' and break it will used further\\n>      - Eg : S= \"abba\" -- Goal= \"abba\" ; then this is TRUE\\n>      - But  S= \"abcd\" -- Goal= \"abcd\" ; then this is FALSE   \\n-  this Example will used to explain further.\\n\\n3. PART: In this Part we check with the original strings i.e How much character they differ.\\n    - If they differn more than 2 character then we cant Achieve our goal.\\n    - So make a count nd if > 2 then return False immediately.\\n1. Final Check : Sinc they all surpasses These Parts Means having .\\n - Same size , same characters  and Either 0 OR 2 characters are differing.\\n - If `cnt=2` means True simply and IF `cnt=0` then have to check **\\n>   Take  above eg: S= \"abba\" -- Goal= \"abba\"; Here `Cnt=0 but flag=1` So this is true becoz we can change indx(0,3) or index(1,2) we can achive goal.\\nBUT... S= \"abcd\" -- Goal= \"abcd\" ; `Cnt=0 but flag=0` so this is false since we cant change any indexes.\\n- Thts why i am mark a flag to to check whether have repeating char or not simply .\\n\\nDRY RUN WITH FEW MORE U WILL GET IT.\\n\\n**TIP : In comments**\\n   \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        // if both have different size \\n        if(s.size()!=goal.size()) return false; \\n\\n        //---PART_1-------------------------------------------------------//\\n        string str1= s;\\n        string str2 = goal;\\n        sort(str1.begin(),str1.end());\\n        sort(str2.begin(),str2.end());\\n        if(str1 != str2) return false;\\n\\n        //---PART_2------------------------------------------------------//\\n        int flag=0;\\n        for(int i =0; i<str1.size()-1;i++)\\n        {\\n            if(str1[i]==str1[i+1])\\n            {\\n                flag=1;\\n                break;\\n            }\\n        }\\n\\n        //---PART3-------------------------------------------------------//\\n        int cnt=0;\\n        for(int i =0 ; i < s.size();i++)\\n        {\\n            if(s[i]!=goal[i])cnt++;\\n            if(cnt>2) return false;\\n        }\\n\\n        //---FINAL_CHECK----------------------------------------------------//\\n        if(cnt==0 && flag==0) return false;\\n\\n        return true;\\n    }\\n};\\n```\\n# **UPVOTE !**\\n![Screenshot 2023-07-23 001111.png](https://assets.leetcode.com/users/images/689f6326-8b12-4bda-a126-6a170b08225b_1690052016.6477008.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        // if both have different size \\n        if(s.size()!=goal.size()) return false; \\n\\n        //---PART_1-------------------------------------------------------//\\n        string str1= s;\\n        string str2 = goal;\\n        sort(str1.begin(),str1.end());\\n        sort(str2.begin(),str2.end());\\n        if(str1 != str2) return false;\\n\\n        //---PART_2------------------------------------------------------//\\n        int flag=0;\\n        for(int i =0; i<str1.size()-1;i++)\\n        {\\n            if(str1[i]==str1[i+1])\\n            {\\n                flag=1;\\n                break;\\n            }\\n        }\\n\\n        //---PART3-------------------------------------------------------//\\n        int cnt=0;\\n        for(int i =0 ; i < s.size();i++)\\n        {\\n            if(s[i]!=goal[i])cnt++;\\n            if(cnt>2) return false;\\n        }\\n\\n        //---FINAL_CHECK----------------------------------------------------//\\n        if(cnt==0 && flag==0) return false;\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712176,
                "title": "super-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if (s.length() != goal.length() || s.length() <= 1) {\\n            return false;\\n        }\\n\\n        if (s == goal) {\\n            unordered_set<char> distinctChars(s.begin(), s.end());\\n            return distinctChars.size() < s.length();\\n        }\\n\\n        vector<int> index;\\n        for (int i=0;i<s.length();i++) {\\n            if (s[i] != goal[i]) {\\n                index.push_back(i);\\n            }\\n        }\\n\\n        if (index.size() != 2) {\\n            return false;\\n        }\\n\\n        swap(s[index[0]], s[index[1]]);\\n        return s == goal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if (s.length() != goal.length() || s.length() <= 1) {\\n            return false;\\n        }\\n\\n        if (s == goal) {\\n            unordered_set<char> distinctChars(s.begin(), s.end());\\n            return distinctChars.size() < s.length();\\n        }\\n\\n        vector<int> index;\\n        for (int i=0;i<s.length();i++) {\\n            if (s[i] != goal[i]) {\\n                index.push_back(i);\\n            }\\n        }\\n\\n        if (index.size() != 2) {\\n            return false;\\n        }\\n\\n        swap(s[index[0]], s[index[1]]);\\n        return s == goal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711727,
                "title": "simple-kotlin-tc-o-n-sc-o-1",
                "content": "# Intuition\\nTo determine if two strings `s` and `goal` can be made equal by swapping two characters, we need to consider various cases. If `s` and `goal` are equal, we can swap two occurrences of the same character in `s` to make the strings equal. If `s` and `goal` have exactly two differing characters, we can check if swapping them would make the strings equal. By analyzing these cases, we can devise an approach to solve the problem efficiently.\\n\\n# Approach\\n1. If the lengths of `s` and `goal` are not equal or if they have fewer than two differing characters, return `false` immediately.\\n2. If `s` is equal to `goal`, check if there are any duplicate characters in `s` by converting it to a set. If the size of the set is smaller than the length of `s`, return `true` since we can swap two occurrences of the same character.\\n3. Find the indices of the differing characters in `s` and `goal` and store them in `diffIndices`.\\n4. If `diffIndices` has more than two or fewer than two elements, return `false`.\\n5. Check if swapping the characters at `diffIndices[0]` and `diffIndices[1]` in `s` would make it equal to `goal`. If the characters can be swapped successfully, return `true`; otherwise, return `false`.\\n\\n# Edge Cases\\nThe solution handles the following edge cases:\\n- If `s` and `goal` have lengths that are not equal, the function returns `false` immediately.\\n- If `s` and `goal` have lengths less than 2, the function returns `false` since we need at least two differing characters to swap.\\n- If `s` is equal to `goal`, the function checks if there are duplicate characters in `s` and returns `true` if there are since we can swap two occurrences of the same character.\\n\\n# Algorithm\\n1. Check the lengths of `s` and `goal` and return `false` if they are not equal or if the length is less than 2.\\n2. If `s` is equal to `goal`, convert `s` to a set and return `true` if the size of the set is smaller than the length of `s`.\\n3. Initialize an array `diffIndices` of size 2 to store the indices of the differing characters.\\n4. Iterate through the characters of `s` and `goal` simultaneously.\\n    - If the characters at the current index differ, store the index in `diffIndices` and increment `diffCount`.\\n    - If `diffCount` exceeds 2, return `false`.\\n5. If `diffCount` is not equal to 2, return `false`.\\n6. Get the values at indices 0 and 1 from `diffIndices` as `index1` and `index2`.\\n7. Return `true` if swapping the characters at `index1` and `index2` in `s` would make it equal to `goal`; otherwise, return `false`.\\n\\n\\n# Complexity\\n**Time Complexity:** $$O(n)$$\\nThe time complexity of this solution is $$O(n)$$, where n is the length of the input strings `s` and `goal`. This is because we iterate through the strings once to find differing characters and perform constant-time operations for comparisons.\\n\\n**Space Complexity:** $$O(1)$$\\nThe space complexity is $$O(1)$$ since we use a fixed-size array and a constant amount of extra space for variables.\\n\\n# Code\\n```\\nclass Solution {\\n    fun buddyStrings(s: String, goal: String): Boolean {\\n        if (s.length != goal.length || s.length < 2) {\\n            return false\\n        }\\n\\n        if (s == goal) {\\n            val charSet = s.toSet()\\n            return charSet.size < s.length\\n        }\\n\\n        val diffIndices = IntArray(2)\\n        var diffCount = 0\\n\\n        for (i in s.indices) {\\n            if (s[i] != goal[i]) {\\n                if (diffCount >= 2) {\\n                    return false\\n                }\\n                diffIndices[diffCount] = i\\n                diffCount++\\n            }\\n        }\\n\\n        if (diffCount != 2) {\\n            return false\\n        }\\n\\n        val (index1, index2) = diffIndices\\n\\n        return s[index1] == goal[index2] && s[index2] == goal[index1]\\n    }\\n}\\n\\n```\\n\\n# Conclusion:\\nThe solution uses a systematic approach to determine if two strings can be made equal by swapping two characters. It handles different cases efficiently and has a linear time complexity. By following the provided algorithm and code, the `buddyStrings` problem can be solved effectively.\\n\\n\\n## \\uD83D\\uDC4D Please upvote this solution on LeetCode if you found it helpful! \\uD83D\\uDE4C\\uD83D\\uDCAF\\uD83D\\uDD25",
                "solutionTags": [
                    "Kotlin",
                    "Hash Table",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    fun buddyStrings(s: String, goal: String): Boolean {\\n        if (s.length != goal.length || s.length < 2) {\\n            return false\\n        }\\n\\n        if (s == goal) {\\n            val charSet = s.toSet()\\n            return charSet.size < s.length\\n        }\\n\\n        val diffIndices = IntArray(2)\\n        var diffCount = 0\\n\\n        for (i in s.indices) {\\n            if (s[i] != goal[i]) {\\n                if (diffCount >= 2) {\\n                    return false\\n                }\\n                diffIndices[diffCount] = i\\n                diffCount++\\n            }\\n        }\\n\\n        if (diffCount != 2) {\\n            return false\\n        }\\n\\n        val (index1, index2) = diffIndices\\n\\n        return s[index1] == goal[index2] && s[index2] == goal[index1]\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711591,
                "title": "kotlin-use-pair",
                "content": "# Intuition\\n1. Compares two strings and stores the different characters in the Pair List.\\n2. Check size of Pair List\\n2.1 if size is 0 then Checks if a string has the same character.\\n2.2 if size is 1 then impossible.\\n2.3 if size is 2 then Cross compare first and second of two pairs.\\n\\n# Code\\n```\\nclass Solution {\\n    fun buddyStrings(s: String, goal: String): Boolean {\\n        if(s.length != goal.length) return false\\n        \\n        var list = mutableListOf<Pair<Char,Char>>()\\n        for(i in s.indices){\\n            if(s[i]!=goal[i]){\\n                list.add(Pair(s[i],goal[i]))\\n                if(list.size > 2) return false\\n            }\\n        }\\n        when(list.size){\\n            0-> {\\n                return (s.length != s.toSet().size)\\n                }\\n            1->{\\n                return false\\n            }\\n            2->{\\n                return (list[0].first == list[1].second && list[0].second == list[1].first)\\n            }\\n            \\n        }\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun buddyStrings(s: String, goal: String): Boolean {\\n        if(s.length != goal.length) return false\\n        \\n        var list = mutableListOf<Pair<Char,Char>>()\\n        for(i in s.indices){\\n            if(s[i]!=goal[i]){\\n                list.add(Pair(s[i],goal[i]))\\n                if(list.size > 2) return false\\n            }\\n        }\\n        when(list.size){\\n            0-> {\\n                return (s.length != s.toSet().size)\\n                }\\n            1->{\\n                return false\\n            }\\n            2->{\\n                return (list[0].first == list[1].second && list[0].second == list[1].first)\\n            }\\n            \\n        }\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711435,
                "title": "java-bitmask-o-1-space-o-n-time",
                "content": "# Explanation\\n\\nIt is a straight forward problem. This problem only has three cases:\\n\\n1. If the `lengths` of the strings are `unequal`, answer is `no`.\\n2. If the strings are already `equal` and all the `characters` are `unique` then answer is `no`, otherwise it is `yes`.\\n3. If the strings are `not equal` then we just have to check they `differ` at `exactly two indices` `i` and `j` such that :\\n\\n                    s[i] == goal[j] and s[j] == goal[i]\\n\\n    if this is `true`, answer is `yes` otherwise answer is `no`.\\n\\n\\nWe can use `bit masking` to check the above conditions efficiently without need of frequency array. Here is how :\\n\\n1. For checking if all characters are unique or not, we can take an `integer` and assign its `bits` to each `character`. We can assign the $1_{st}$ bit of the integer to `a`, the $2_{nd}$ bit to `b` and so on. If while assigning, if a bit was already set, this implies that we have found a duplicate.\\n\\n2. For checking the swap condition mentioned above, we can take `two integer`, one for string `s` and other for string `goal`. Also, we will need a `count` variable. Whenever the characters of both strings are `unequal` at an `index`, `increment` the `count` and also `set` the `bit` corresponding to the `characters` in the respective `integers`. Then we just have to check the `XOR` of these two integers. If it is `0` then answer is `yes`, else it is `no`.\\n\\n\\n\\n---\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n\\n- Space complexity: $O(1)$\\n# Code\\n```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length() != goal.length()) return false;\\n        if(s.equals(goal)) {\\n            int mask = 0;\\n            for(int i = 0; i < s.length(); i ++) {\\n                int ind = 1 << (s.charAt(i) - \\'a\\');\\n                if((mask & ind) != 0) return true;\\n                mask |= ind;\\n            }\\n            return false;\\n        }\\n        int ct = 0;\\n        int mask1 = 0;\\n        int mask2 = 0;\\n        for(int i = 0; i < goal.length(); i ++) {\\n            if(goal.charAt(i) != s.charAt(i)) {\\n                ct ++;\\n                int ind = 1 << (s.charAt(i) - \\'a\\');\\n                if((mask1 & ind) != 0) return false;\\n                mask1 += ind;\\n                ind = 1 << (goal.charAt(i) - \\'a\\');\\n                if((mask2 & ind) != 0) return false;\\n                mask2 += ind;\\n            }\\n            if(ct > 2) return false;\\n        }\\n        if(ct != 2) return false;\\n        return (mask1 ^ mask2) == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length() != goal.length()) return false;\\n        if(s.equals(goal)) {\\n            int mask = 0;\\n            for(int i = 0; i < s.length(); i ++) {\\n                int ind = 1 << (s.charAt(i) - \\'a\\');\\n                if((mask & ind) != 0) return true;\\n                mask |= ind;\\n            }\\n            return false;\\n        }\\n        int ct = 0;\\n        int mask1 = 0;\\n        int mask2 = 0;\\n        for(int i = 0; i < goal.length(); i ++) {\\n            if(goal.charAt(i) != s.charAt(i)) {\\n                ct ++;\\n                int ind = 1 << (s.charAt(i) - \\'a\\');\\n                if((mask1 & ind) != 0) return false;\\n                mask1 += ind;\\n                ind = 1 << (goal.charAt(i) - \\'a\\');\\n                if((mask2 & ind) != 0) return false;\\n                mask2 += ind;\\n            }\\n            if(ct > 2) return false;\\n        }\\n        if(ct != 2) return false;\\n        return (mask1 ^ mask2) == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711122,
                "title": "easy-c-explained",
                "content": "If the strings are of different size then direct NO\\nFrom example 2 and 3, it\\'s clear that from equal strings you need atleast one repeating elements as swap operation is mandatory. \\nThen we count the number of different characters in a string. If the diffcount is equal to 2, then we can do a potential swap else the answer is direct NO.\\nIf difcount is 2, then you have to do operation such that after swapping they become equal, so to avoid complex solution, I directly store in two string and sorted them and if they are equal then answer is YES else NO.\\nEg: ab and ba, after sorting both strings become ab and they should be equal.\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string t) {\\n        int n=s.size(),m=t.size();\\n        if(m-n) return 0;\\n        if(s==t) {\\n            map<int,int> mp;\\n            for(auto x:s) mp[x]++;\\n            for(auto x:mp) if(x.second>1) return 1;\\n            return 0;\\n        }\\n        int dif=0;\\n        string s1,t1;\\n        for(auto i=0;i<n;i++) if(s[i]-t[i]) {\\n            dif++; s1+=s[i], t1+=t[i];\\n        }\\n        if(dif!=2) return 0;\\n        sort(s1.begin(),s1.end());\\n        sort(t1.begin(),t1.end());\\n        if(s1==t1) return 1;\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool buddyStrings(string s, string t) {\\n        int n=s.size(),m=t.size();\\n        if(m-n) return 0;\\n        if(s==t) {\\n            map<int,int> mp;\\n            for(auto x:s) mp[x]++;\\n            for(auto x:mp) if(x.second>1) return 1;\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3710746,
                "title": "c-solution-for-buddy-strings-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to identify whether it is possible to swap two letters in string s to obtain string goal.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- If the lengths of s and goal are not equal or they are shorter than 2 characters, it is not possible to swap two letters, so the function returns false.\\n- If s is already equal to goal, we check if there are any repeated characters in s. If there are, we can swap them to obtain goal, so the function returns true.\\n- We iterate through s and goal simultaneously and keep track of the differing indices in the diffIndices list.\\n- If the number of differing indices is not exactly 2, it means that more than two letters need to be swapped, which is not allowed. So, the function returns false.\\n- Finally, we check if swapping the characters at the differing indices in s results in s being equal to goal. If it does, the function returns true; otherwise, it returns false.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n), where n is the length of the input strings s and goal. This is because we iterate through the strings once to compare the characters and find the differing indices.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(1), as it uses a constant amount of extra space to store the differing indices and the unique characters in s. The space used does not depend on the input size.\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool BuddyStrings(string s, string goal) {\\n        if (s.Length != goal.Length || s.Length < 2 || goal.Length < 2)\\n        return false;\\n\\n        if (s.Equals(goal)) {\\n            // Check if there are any repeated characters in s\\n            HashSet<char> uniqueChars = new HashSet<char>(s);\\n            return uniqueChars.Count < s.Length;\\n        }\\n\\n        List<int> diffIndices = new List<int>();\\n        for (int i = 0; i < s.Length; i++) {\\n            if (s[i] != goal[i])\\n                diffIndices.Add(i);\\n            if (diffIndices.Count > 2)\\n                return false;\\n        }\\n\\n        if (diffIndices.Count != 2)\\n            return false;\\n\\n        return s[diffIndices[0]] == goal[diffIndices[1]] && s[diffIndices[1]] == goal[diffIndices[0]];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool BuddyStrings(string s, string goal) {\\n        if (s.Length != goal.Length || s.Length < 2 || goal.Length < 2)\\n        return false;\\n\\n        if (s.Equals(goal)) {\\n            // Check if there are any repeated characters in s\\n            HashSet<char> uniqueChars = new HashSet<char>(s);\\n            return uniqueChars.Count < s.Length;\\n        }\\n\\n        List<int> diffIndices = new List<int>();\\n        for (int i = 0; i < s.Length; i++) {\\n            if (s[i] != goal[i])\\n                diffIndices.Add(i);\\n            if (diffIndices.Count > 2)\\n                return false;\\n        }\\n\\n        if (diffIndices.Count != 2)\\n            return false;\\n\\n        return s[diffIndices[0]] == goal[diffIndices[1]] && s[diffIndices[1]] == goal[diffIndices[0]];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710481,
                "title": "simple-approach-with-explaination-using-frequency-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHere we calculate the frequency of both strings. \\n1. If there is difference in frequency then simply its not possible to form goal string. \\nexample s=\"aabc\" goal=\"abbc\"  -> false\\n2. now if frequencies are same, we must ensure that there is atleast one freq of char which is greater than 2 and the diff in string is 0.\\nexample s=\"abca\" goal=\"aacb\" -> true( diff==2 )\\nexample s=\"aabc\" goal=\"aabc\" -> true(diff==0 and cnt=true)\\n\\n\\n# Complexity\\n- Time complexity: O(N) Traversing the string\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) we use 2 constant size array so space complexity is constant.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()) return false;\\n        int diff=0;\\n        vector<int> freq1(26,0);\\n        vector<int> freq2(26,0);\\n\\n        for(int i=0;i<s.size();i++){\\n            char ch1= s[i];\\n            char ch2= goal[i];\\n            freq1[ch1-\\'a\\']++;\\n            freq2[ch2-\\'a\\']++;\\n        }\\n        \\n        bool cnt=false;\\n        for(int i=0;i<26;i++){\\n            if(freq1[i]!=freq2[i]) return false;\\n            if(freq1[i]>=2) cnt=true;\\n        }\\n\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i]) diff++;\\n        }\\n        return (diff==2  ||  (cnt==true && diff==0));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()) return false;\\n        int diff=0;\\n        vector<int> freq1(26,0);\\n        vector<int> freq2(26,0);\\n\\n        for(int i=0;i<s.size();i++){\\n            char ch1= s[i];\\n            char ch2= goal[i];\\n            freq1[ch1-\\'a\\']++;\\n            freq2[ch2-\\'a\\']++;\\n        }\\n        \\n        bool cnt=false;\\n        for(int i=0;i<26;i++){\\n            if(freq1[i]!=freq2[i]) return false;\\n            if(freq1[i]>=2) cnt=true;\\n        }\\n\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i]) diff++;\\n        }\\n        return (diff==2  ||  (cnt==true && diff==0));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710459,
                "title": "set-approach-python-js-solution",
                "content": "Hello **Tenno Leetcoders**,\\n\\nFor this problem, we are given two strings `s` and `goal`, return `true` if you can swap `two letters` in `s` so the result is `equal` to `goal`, otherwise, return `false`.\\n\\n### Explanation\\n\\nThe problem wants us to determine whether it is possible to swap two letters in string `s` such that it will become equal to string `goal`. \\n\\nThere are three base cases we need to consider:\\n\\n 1) If the length of s and goal string are not equal, we can immediately return False/false as this will be impossible to make two unique strings equal by swapping their character\\n       \\n  2) If s is already equal to goal, like in example 2. We need to check if at least one character appears more than once in s That is because swapping two identical strings will not change their values. Therefore, we will be using Hashset to help us to compare the length of set characters in s with the length of s. If length of this set is less than the length of s, then there is at least one character that appears more than once in s.\\n  \\n      - Once we find at least one repeating character in s, it will return True/true as we can still perform a swap by choosing any two occurrences of the repeated characters. The result of s will remain the same, but it will satisfy the condition of being able to swap two letters\\n      \\n      - If there are no repeating characters is s, it will return False/false as it will be impossible to make a non-repeated string any different from itself by swapping the two letters \\n       \\n  3) Next we check if there are exactly two differing positions as swapping the characters at those positions will make s equal to goal. \\n  \\n      - IFF the first differing character position of `differences[0]` is equal to second differing character position `differences[1]` in reverse it will return True/true. Otherwise False/false\\n\\n\\n\\n# Code\\n**Python**\\n\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        differences = [(s[i], goal[i]) for i in range(len(s)) if s[i] != goal[i] ]\\n    \\n        if len(s) != len(goal): return\\n\\n        if s == goal:\\n            return len(set(s)) < len(s)\\n\\n        if len(differences) == 2:\\n            return differences[0] == differences[1][::-1]\\n        \\n        return False\\n```\\n\\n**JavaScript**\\n```\\n/**\\n * @param {string} s\\n * @param {string} goal\\n * @return {boolean}\\n */\\nvar buddyStrings = function(s, goal) {\\n    let differences = []\\n    let sSet = new Set(s)\\n    for(let i = 0; i < s.length; i++){\\n        if(s[i] !== goal[i]) differences.push([s[i], goal[i]])\\n    }\\n\\n    if(s.length !== goal.length) return false\\n\\n    if(s === goal) return sSet.size < s.length\\n \\n    if(differences.length === 2) return differences[0].toString() === differences[1].reverse().toString()\\n    \\n    return false\\n};\\n```\\n### Time Complexity: O(n)\\n### Space Complexity: O(n)\\n\\n \\n***Warframe\\'s Darvo wants you to upvote this post  \\uD83D\\uDE4F\\uD83C\\uDFFB \\u2764\\uFE0F\\u200D\\uD83D\\uDD25***\\n![image](https://assets.leetcode.com/users/images/814f5668-c966-46d7-ba42-e5435c4c1761_1675302761.3081913.gif)",
                "solutionTags": [
                    "Python3",
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        differences = [(s[i], goal[i]) for i in range(len(s)) if s[i] != goal[i] ]\\n    \\n        if len(s) != len(goal): return\\n\\n        if s == goal:\\n            return len(set(s)) < len(s)\\n\\n        if len(differences) == 2:\\n            return differences[0] == differences[1][::-1]\\n        \\n        return False\\n```\n```\\n/**\\n * @param {string} s\\n * @param {string} goal\\n * @return {boolean}\\n */\\nvar buddyStrings = function(s, goal) {\\n    let differences = []\\n    let sSet = new Set(s)\\n    for(let i = 0; i < s.length; i++){\\n        if(s[i] !== goal[i]) differences.push([s[i], goal[i]])\\n    }\\n\\n    if(s.length !== goal.length) return false\\n\\n    if(s === goal) return sSet.size < s.length\\n \\n    if(differences.length === 2) return differences[0].toString() === differences[1].reverse().toString()\\n    \\n    return false\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710401,
                "title": "swift-explained-solution",
                "content": "# Approach\\n\\nFirst, if the strings lengths are not equal, no swap can help with that, return false.\\n\\nNext, find all differences between the strings.\\n\\nIf there are exactly two positions with non-matching symbols, check whether swapping characters on these two positions will make them equal.\\n\\nIf it turns out that there are no differences, it means that the strings are already equal\\u2026 but by the problem conditions we have to perform a swap. So we check if there are any repeating characters in `s`, so we can swap them without changing the string.\\n\\nThese are all cases where it\\'s possible to obtain equality by a single swap. For the rest, the answer is false.\\n\\n## Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$\\n\\n## Code\\n```\\nclass Solution {\\n    func buddyStrings(_ s: String, _ goal: String) -> Bool\\n    {\\n        if s.count != goal.count { return false }\\n\\n        let diffs = s.indices.filter { s[$0] != goal[$0] }\\n        \\n        if diffs.count == 2 // try swap these two\\n        {\\n            return s[diffs[0]] == goal[diffs[1]] \\n                && s[diffs[1]] == goal[diffs[0]]\\n        }\\n        else if diffs.count == 0 // check if there are any repeats in s  \\n        {                        // that could be swapped with each other\\n            var charSet: Set<Character> = []\\n            return s.contains { !charSet.insert($0).inserted }\\n        }\\n        else { return false }\\n    }\\n}\\n```\\n\\n# Optimization of the above approach\\n\\nIt can be noted that if during the process of locating the differences their number exceeds 2, further search is not necessary, the answer is already unambiguously false.\\nSo, let\\'s implement the early termination for that case.\\nThe simplest would be just fill the `diffs` array in a loop, but let\\'s do it a little differently.\\nJust to show how one can break out of the execution of such functions as `map`, `filter`, `reduce`, where normally is no way to stop, we\\'ll calculate the differences with the `reduce` function using *exceptions* for early termination.\\n\\n## Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(1)$\\nGenerally speaking, the space complexity is $O(c)$, where $c$ is the amount of allowed symbols. As in our case the number of lowercase letters is limited to 26, we consider it a constant.\\n\\n```\\nclass Solution {\\n    func buddyStrings(_ s: String, _ goal: String) -> Bool\\n    {\\n        if s.count != goal.count { return false }\\n\\n        let diffs: [String.Index]\\n        do {\\n            diffs = try s.indices.reduce(into: [])\\n            {\\n                diffsArray, index in\\n                if s[index] != goal[index] { diffsArray.append(index) }\\n                if diffsArray.count > 2 { throw \"Too many diffs\" }\\n            }\\n        }\\n        catch { return false }\\n        \\n        if diffs.count == 2 // try swap these two\\n        {\\n            return s[diffs[0]] == goal[diffs[1]] \\n                && s[diffs[1]] == goal[diffs[0]]\\n        }\\n        else if diffs.count == 0 // check if there are any repeats in s  \\n        {                        // that could be swapped with each other\\n            var charSet: Set<Character> = []\\n            return s.contains { !charSet.insert($0).inserted }\\n        }\\n        else { return false }\\n    }\\n}\\nextension String: Error {}\\n```",
                "solutionTags": [
                    "Swift",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    func buddyStrings(_ s: String, _ goal: String) -> Bool\\n    {\\n        if s.count != goal.count { return false }\\n\\n        let diffs = s.indices.filter { s[$0] != goal[$0] }\\n        \\n        if diffs.count == 2 // try swap these two\\n        {\\n            return s[diffs[0]] == goal[diffs[1]] \\n                && s[diffs[1]] == goal[diffs[0]]\\n        }\\n        else if diffs.count == 0 // check if there are any repeats in s  \\n        {                        // that could be swapped with each other\\n            var charSet: Set<Character> = []\\n            return s.contains { !charSet.insert($0).inserted }\\n        }\\n        else { return false }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func buddyStrings(_ s: String, _ goal: String) -> Bool\\n    {\\n        if s.count != goal.count { return false }\\n\\n        let diffs: [String.Index]\\n        do {\\n            diffs = try s.indices.reduce(into: [])\\n            {\\n                diffsArray, index in\\n                if s[index] != goal[index] { diffsArray.append(index) }\\n                if diffsArray.count > 2 { throw \"Too many diffs\" }\\n            }\\n        }\\n        catch { return false }\\n        \\n        if diffs.count == 2 // try swap these two\\n        {\\n            return s[diffs[0]] == goal[diffs[1]] \\n                && s[diffs[1]] == goal[diffs[0]]\\n        }\\n        else if diffs.count == 0 // check if there are any repeats in s  \\n        {                        // that could be swapped with each other\\n            var charSet: Set<Character> = []\\n            return s.contains { !charSet.insert($0).inserted }\\n        }\\n        else { return false }\\n    }\\n}\\nextension String: Error {}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688377,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        cnt=0\\n        if (len(goal)!=len(s)) or len(s)==1:\\n            return 0\\n        a,b=list(s),list(goal)\\n        a.sort()\\n        b.sort()\\n        if a!=b:\\n            return 0\\n        if s==s[::-1]:\\n            return 1\\n        dic=dict()\\n        for i in s:\\n            if i in dic:\\n                dic[i]+=1\\n            else:\\n                dic[i]=1\\n    \\n        for i in range(len(s)):\\n            if s[i]!=goal[i]:\\n                cnt+=1\\n        if cnt==0:\\n            for i in dic:\\n                if dic[i]>=2:\\n                    return 1\\n        if cnt==2:\\n            return 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        cnt=0\\n        if (len(goal)!=len(s)) or len(s)==1:\\n            return 0\\n        a,b=list(s),list(goal)\\n        a.sort()\\n        b.sort()\\n        if a!=b:\\n            return 0\\n        if s==s[::-1]:\\n            return 1\\n        dic=dict()\\n        for i in s:\\n            if i in dic:\\n                dic[i]+=1\\n            else:\\n                dic[i]=1\\n    \\n        for i in range(len(s)):\\n            if s[i]!=goal[i]:\\n                cnt+=1\\n        if cnt==0:\\n            for i in dic:\\n                if dic[i]>=2:\\n                    return 1\\n        if cnt==2:\\n            return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495376,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if (s.size() != goal.size()) return false;\\n\\n        vector<int> count1(26, 0), count2(26, 0);\\n        int temp = 0;\\n\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] != goal[i]) temp++;\\n\\n            count1[s[i] - \\'a\\']++;\\n            count2[goal[i] - \\'a\\']++;\\n        }\\n        int allUniqueChars = true;\\n        for (int i = 0; i < count1.size(); i++) {\\n            if (count1[i] != count2[i]) return false;\\n            if (count1[i] > 1) allUniqueChars = false;\\n        }\\n        return ((temp == 2) || (temp == 0 && !allUniqueChars));\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        \\n        if len(s) != len(goal):\\n            return False\\n        if s == goal:\\n            return len(set(s)) < len(s)\\n        diffs = []\\n        for i in range(len(s)):\\n            if s[i] != goal[i]:\\n                diffs.append((s[i], goal[i]))\\n        return len(diffs) == 2 and diffs[0] == diffs[1][::-1]\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s == null || goal == null || s.length() != goal.length() || s.length() < 2){\\n            return false;\\n        }\\n        if(s.equals(goal)){\\n            int[] map = new int[26];\\n            for(int i = 0; i < s.length(); i++){\\n                if(map[s.charAt(i) - \\'a\\'] == 1){\\n                    return true;\\n                }else{\\n                    map[s.charAt(i) - \\'a\\'] = 1;\\n                }\\n            }\\n        }\\n        char[] s1 = s.toCharArray();\\n        char[] s2 = goal.toCharArray();\\n        char s1_1 = \\'1\\', s1_2 = \\'2\\', s2_1 = \\'3\\', s2_2 = \\'4\\';\\n        boolean found1stDiff = false;\\n        boolean found2ndDiff = false;\\n\\n        for(int i = 0; i < s1.length; i++){\\n            if(s1[i] != s2[i]){\\n                if(!found1stDiff){\\n                    found1stDiff = true;\\n                    s1_1 = s1[i];\\n                    s2_1 = s2[i];\\n                }else if(!found2ndDiff){\\n                    found2ndDiff = true;\\n                    s1_2 = s1[i];\\n                    s2_2 = s2[i];\\n                    if(s1_2 != s2_1 || s1_1 != s2_2){\\n                        return false;\\n                    }\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return found1stDiff && found2ndDiff;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if (s.size() != goal.size()) return false;\\n\\n        vector<int> count1(26, 0), count2(26, 0);\\n        int temp = 0;\\n\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] != goal[i]) temp++;\\n\\n            count1[s[i] - \\'a\\']++;\\n            count2[goal[i] - \\'a\\']++;\\n        }\\n        int allUniqueChars = true;\\n        for (int i = 0; i < count1.size(); i++) {\\n            if (count1[i] != count2[i]) return false;\\n            if (count1[i] > 1) allUniqueChars = false;\\n        }\\n        return ((temp == 2) || (temp == 0 && !allUniqueChars));\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        \\n        if len(s) != len(goal):\\n            return False\\n        if s == goal:\\n            return len(set(s)) < len(s)\\n        diffs = []\\n        for i in range(len(s)):\\n            if s[i] != goal[i]:\\n                diffs.append((s[i], goal[i]))\\n        return len(diffs) == 2 and diffs[0] == diffs[1][::-1]\\n```\n```Java []\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s == null || goal == null || s.length() != goal.length() || s.length() < 2){\\n            return false;\\n        }\\n        if(s.equals(goal)){\\n            int[] map = new int[26];\\n            for(int i = 0; i < s.length(); i++){\\n                if(map[s.charAt(i) - \\'a\\'] == 1){\\n                    return true;\\n                }else{\\n                    map[s.charAt(i) - \\'a\\'] = 1;\\n                }\\n            }\\n        }\\n        char[] s1 = s.toCharArray();\\n        char[] s2 = goal.toCharArray();\\n        char s1_1 = \\'1\\', s1_2 = \\'2\\', s2_1 = \\'3\\', s2_2 = \\'4\\';\\n        boolean found1stDiff = false;\\n        boolean found2ndDiff = false;\\n\\n        for(int i = 0; i < s1.length; i++){\\n            if(s1[i] != s2[i]){\\n                if(!found1stDiff){\\n                    found1stDiff = true;\\n                    s1_1 = s1[i];\\n                    s2_1 = s2[i];\\n                }else if(!found2ndDiff){\\n                    found2ndDiff = true;\\n                    s1_2 = s1[i];\\n                    s2_2 = s2[i];\\n                    if(s1_2 != s2_1 || s1_1 != s2_2){\\n                        return false;\\n                    }\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return found1stDiff && found2ndDiff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871114,
                "title": "c-o-n-easy-to-understand-with-explanation",
                "content": "#### Table of Contents\\n\\n- [TL;DR](#tldr)\\n  - [Code](#code)\\n  - [Complexity](#complexity)\\n- [In Depth Analysis](#in-depth-analysis)\\n  - [Intuition](#intuition)\\n  - [Approach](#approach)\\n  - [Example](#example)\\n    - [Example 1 - Strings Equal](#example-1---strings-equal)\\n    - [Example 2 - Strings Not Equal](#example-2---strings-not-equal)\\n\\n# TL;DR\\n\\nBreak the problem into its individual cases and solve each one:\\n\\n* If the strings are not equal length, return `false`\\n* If the string are the same: check if there is a character with a frequency >1 so that we can just swap those\\n* If the strings aren\\'t the same: check to see if they differ in AT MOST 2 locations\\n\\n## Code\\n\\n```c++\\n#define LOWERCASE_TO_INDEX(c) (c - \\'a\\')\\n\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        const int n = s.size();\\n        if (n != goal.size()) return false;\\n\\n        if (s == goal) {\\n            vector<int> char_freq(26, 0);\\n\\n            for (int i = 0; i < n; i++)\\n                if (++char_freq[LOWERCASE_TO_INDEX(s[i])] > 1)\\n                    return true;\\n\\n            return false;\\n        }\\n\\n        int first_diff_idx = -1, second_diff_idx = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (s[i] != goal[i]) {\\n                if (first_diff_idx == -1)\\n                    first_diff_idx = i;\\n                else if (second_diff_idx == -1)\\n                    second_diff_idx = i;\\n                else \\n                    return false;\\n            }\\n        }\\n\\n        return second_diff_idx != -1 && \\n               s[first_diff_idx] == goal[second_diff_idx] && \\n               s[second_diff_idx] == goal[first_diff_idx];\\n    }\\n};\\n```\\n\\n## Complexity\\n\\n**Time Complexity:** $$O(N)$$ where $$N$$ is the length of the string\\n**Space Complexity:** $$O(1)$$ since the frequency array is the only thing initialized and it has a constant size\\n\\n**PLEASE UPVOTE IF YOU FIND MY POST HELPFUL!! \\uD83E\\uDD7A\\uD83D\\uDE01**\\n\\n---\\n\\n# In Depth Analysis\\n\\n## Intuition\\n\\nThe basic idea that I followed is breaking it up into 2 cases:\\n1. If the strings aren\\'t the same length\\n2. If the strings are equal\\n3. If the strings aren\\'t equal\\n\\n### Case 1: Not Equal Length <!-- omit from toc -->\\nIf the strings aren\\'t equal, there is no way to get a buddy strings using the swap operation, so we just return false\\n\\n### Case 2: Equal Strings <!-- omit from toc -->\\nIf the strings are equal, then we need to determine if there is a character with a frequency of >1. If that is the case, then we can swap the same character and still have buddy strings.\\n\\nFor example, if s = \"aba\" and goal = \"aba\", then you could swap the two \\'a\\' characters to then have buddy strings. Remember that you MUST swap at least once\\n\\n### Case 3: Not Equal Strings <!-- omit from toc -->\\nIf the strings aren\\'t equal, we want to figure out if they differ in only 2 locations and where those locations are. If they differ in more than 2 locations, then they can\\'t be buddy strings. If they only differ in two locations, we need to ensure that if we swap those characters that the strings would be equal.\\n\\n## Approach \\n\\nWe want to break it up by checking if the strings are equal since we need two different approaches for those two cases.\\n\\nIf the strings are equal, then I used a frequency array to keep track of the frequency of letters. If I encounter a character that has occured more than once, then I return true since we could just swap those characters. If we do not find any character with a frequency of more than 1, then return false.\\n\\nIf the strings aren\\'t equal, then I want to find the locations where the two strings differ using 2 pointers. The first time that they differ, I store the index in the first pointer. The second time that they differ, I store the index in the second pointer. If they differ more than that, I know that the strings cannot be equal by swapping only 2 characters, so I return false. At the end of the iteration, I have to see if there were two differences (`second_diff_idx != -1`) and that the locations where they differ have\\nthe same character in each of them so the swap could be done and have equal strings afterwards (`s[first_diff_idx] == goal[second_diff_idx] && s[second_diff_idx] == goal[first_diff_idx]`)\\n\\n### Tricky Portion of Code <!-- omit from toc -->\\n\\n```c++\\nif (++char_freq[LOWERCASE_TO_INDEX(s[i])] > 1)\\n```\\n\\nOn line 13, I used this to shorter my code. Notice that I am using a macro named `LOWERCASE_TO_INDEX` to convert the lowercase letter to an index in the frequency array. Also, since I am using the pre-pended `++` operator, it adds 1 to the value prior to doing the comparison. That way, if the character has been seen before, it must have a value of 1 before this statement. Then, it will be increamented to 2 prior to the comparison, which is exactly what we want. Please follow up below if this was confusing to you!\\n\\n## Example\\n\\nLets do 2 different examples since there are 2 cases to consider:\\n\\n### Example 1 - Strings Equal\\n\\nLets use an example where `s = \"aba\"` and `t = \"aba\"`. Since `s == t`, we enter the equal case.\\n\\nWe find the frequency of all the characters in one of the strings since they are the same. In our case, we have `\\'a\\' = 2` and `\\'b\\' = 1`.  Since the frequency of `\\'a\\'` is >1, we could swap those characters to keep them buddy strings so we return `true`\\n\\n### Example 2 - Strings Not Equal\\n\\nLets use an example where `s = \"abb\"` and `t = \"bba\"`. We must iterate through all the characters.\\n\\n* i = 0\\n\\n`s[i] != goal[i]`, so we update `first_index = 0`\\n\\n* i = 1\\n\\n`s[i] == goal[i]` so we don\\'t do anything and continue\\n\\n* i = 2\\n\\n`s[i] != goal[i]` so we update `second_index = 2` since `first_index` was already mapped\\n\\n* Aftermath\\n\\nWe know that they only differ in two locations, so we need to check if `s[0] == t[2]` and `s[2] == t[0]`: `s[0] = t[2] = \\'a\\'` and `s[2] = t[0] = \\'b\\'`, so we return `true`\\n\\n**PLEASE UPVOTE IF YOU FIND MY POST HELPFUL!! \\uD83E\\uDD7A\\uD83D\\uDE01**",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```c++\\n#define LOWERCASE_TO_INDEX(c) (c - \\'a\\')\\n\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        const int n = s.size();\\n        if (n != goal.size()) return false;\\n\\n        if (s == goal) {\\n            vector<int> char_freq(26, 0);\\n\\n            for (int i = 0; i < n; i++)\\n                if (++char_freq[LOWERCASE_TO_INDEX(s[i])] > 1)\\n                    return true;\\n\\n            return false;\\n        }\\n\\n        int first_diff_idx = -1, second_diff_idx = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (s[i] != goal[i]) {\\n                if (first_diff_idx == -1)\\n                    first_diff_idx = i;\\n                else if (second_diff_idx == -1)\\n                    second_diff_idx = i;\\n                else \\n                    return false;\\n            }\\n        }\\n\\n        return second_diff_idx != -1 && \\n               s[first_diff_idx] == goal[second_diff_idx] && \\n               s[second_diff_idx] == goal[first_diff_idx];\\n    }\\n};\\n```\n```c++\\nif (++char_freq[LOWERCASE_TO_INDEX(s[i])] > 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683789,
                "title": "clean-concise-one-pass-o-n-c",
                "content": "**Please upvote! Thank you!**\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if (s.size() != goal.size()) return false;\\n        vector<int> count1(26, 0);\\n        vector<int> count2(26, 0);\\n        int diffs = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] != goal[i]) diffs++;\\n            count1[s[i] - \\'a\\']++;\\n            count2[goal[i] - \\'a\\']++;\\n        }\\n\\n        int allUniqueChars = true;\\n        for (int i = 0; i < count1.size(); i++) {\\n            if (count1[i] != count2[i]) return false;\\n            if (count1[i] > 1) allUniqueChars = false;\\n        }\\n\\n        return diffs == 2 || (diffs == 0 && !allUniqueChars);\\n    }\\n};\\n```\\n**Please upvote! Thank you!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if (s.size() != goal.size()) return false;\\n        vector<int> count1(26, 0);\\n        vector<int> count2(26, 0);\\n        int diffs = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] != goal[i]) diffs++;\\n            count1[s[i] - \\'a\\']++;\\n            count2[goal[i] - \\'a\\']++;\\n        }\\n\\n        int allUniqueChars = true;\\n        for (int i = 0; i < count1.size(); i++) {\\n            if (count1[i] != count2[i]) return false;\\n            if (count1[i] > 1) allUniqueChars = false;\\n        }\\n\\n        return diffs == 2 || (diffs == 0 && !allUniqueChars);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585565,
                "title": "java-o-n-99-faster-two-pointer-solution",
                "content": "```\\n        // Lengths do not match, they will never be equal\\n        if (s.length() != goal.length()) {\\n            return false;\\n        }\\n\\n        char[] sArray = s.toCharArray();\\n        char[] goalArray = goal.toCharArray();\\n        int[] count = new int[26];\\n        int l = 0, r = s.length() - 1;\\n\\n        // If s and goal are equal and there is even a single duplicate in s, return true. \\n\\t\\t// We can just swap the duplicates to achieve the goal.\\n        if (s.equals(goal)) {\\n            for (int i = 0; i < s.length(); i++) {\\n                count[sArray[i] - \\'a\\']++;\\n                if (count[sArray[i] - \\'a\\'] > 1) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n\\n        // If s and goal are not equal, use the two pointers l and r to find the mismatch and swap.\\n        while (sArray[l] == goalArray[l] && l < r) {\\n            l++;\\n        }\\n\\n        while (sArray[r] == goalArray[r] && l < r) {\\n            r--;\\n        }\\n\\n        // Swap contents of l and r\\n        char temp = sArray[l];\\n        sArray[l] = sArray[r];\\n        sArray[r] = temp;\\n\\n        // If after swapping, the goal and s characters  do not match, return false\\n        if (sArray[l] != goalArray[l] || sArray[r] != goalArray[r]) {\\n            return false;\\n        }\\n\\n        // Keep going to ensure that there are no more mismatches after swapping.\\n        while (l < r) {\\n            l++;\\n            r--;\\n\\n            if (sArray[l] != goalArray[l] || sArray[r] != goalArray[r]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n        // Lengths do not match, they will never be equal\\n        if (s.length() != goal.length()) {\\n            return false;\\n        }\\n\\n        char[] sArray = s.toCharArray();\\n        char[] goalArray = goal.toCharArray();\\n        int[] count = new int[26];\\n        int l = 0, r = s.length() - 1;\\n\\n        // If s and goal are equal and there is even a single duplicate in s, return true. \\n\\t\\t// We can just swap the duplicates to achieve the goal.\\n        if (s.equals(goal)) {\\n            for (int i = 0; i < s.length(); i++) {\\n                count[sArray[i] - \\'a\\']++;\\n                if (count[sArray[i] - \\'a\\'] > 1) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n\\n        // If s and goal are not equal, use the two pointers l and r to find the mismatch and swap.\\n        while (sArray[l] == goalArray[l] && l < r) {\\n            l++;\\n        }\\n\\n        while (sArray[r] == goalArray[r] && l < r) {\\n            r--;\\n        }\\n\\n        // Swap contents of l and r\\n        char temp = sArray[l];\\n        sArray[l] = sArray[r];\\n        sArray[r] = temp;\\n\\n        // If after swapping, the goal and s characters  do not match, return false\\n        if (sArray[l] != goalArray[l] || sArray[r] != goalArray[r]) {\\n            return false;\\n        }\\n\\n        // Keep going to ensure that there are no more mismatches after swapping.\\n        while (l < r) {\\n            l++;\\n            r--;\\n\\n            if (sArray[l] != goalArray[l] || sArray[r] != goalArray[r]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2557094,
                "title": "js-best-solution-with-o-n-100",
                "content": "```\\nvar buddyStrings = function(s, goal) {   \\n    const hashmap = {};\\n    let indexOfFirstWrong;\\n    let output = false;\\n    let hasDuplicate = false;\\n    let numberOfWrongCharacter = 0;\\n    \\n    for (let i = 0; i < goal.length; i++) {\\n        if (goal[i] !== s[i] && indexOfFirstWrong === undefined) {\\n            indexOfFirstWrong = i;\\n            numberOfWrongCharacter++;\\n        } else if (goal[i] !== s[i] && indexOfFirstWrong !== undefined) {\\n            output = goal[i] === s[indexOfFirstWrong] && goal[indexOfFirstWrong] === s[i];\\n            numberOfWrongCharacter++;\\n            if (numberOfWrongCharacter > 2) return false;\\n        }\\n        \\n        if (hashmap[s[i]]) hasDuplicate = true;\\n        \\n        hashmap[s[i]] = 1;\\n    }\\n    \\n    if (!numberOfWrongCharacter && hasDuplicate) return true;\\n\\n     return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar buddyStrings = function(s, goal) {   \\n    const hashmap = {};\\n    let indexOfFirstWrong;\\n    let output = false;\\n    let hasDuplicate = false;\\n    let numberOfWrongCharacter = 0;\\n    \\n    for (let i = 0; i < goal.length; i++) {\\n        if (goal[i] !== s[i] && indexOfFirstWrong === undefined) {\\n            indexOfFirstWrong = i;\\n            numberOfWrongCharacter++;\\n        } else if (goal[i] !== s[i] && indexOfFirstWrong !== undefined) {\\n            output = goal[i] === s[indexOfFirstWrong] && goal[indexOfFirstWrong] === s[i];\\n            numberOfWrongCharacter++;\\n            if (numberOfWrongCharacter > 2) return false;\\n        }\\n        \\n        if (hashmap[s[i]]) hasDuplicate = true;\\n        \\n        hashmap[s[i]] = 1;\\n    }\\n    \\n    if (!numberOfWrongCharacter && hasDuplicate) return true;\\n\\n     return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2186221,
                "title": "python3-o-n-o-26-runtime-40ms-78-04-memory-14-2mb-60-39",
                "content": "```\\nclass Solution:\\n#     O(n) || O(26)\\n# Runtime: 40ms 78.04% memory: 14.2mb 60.39%\\n    def buddyStrings(self, string: str, goal: str) -> bool:\\n        left, right = 0, len(string) - 1\\n\\n        if len(string) != len(goal):\\n            return False\\n\\n        if string == goal and len(set(string)) < len(string):\\n            return True\\n\\n\\n        difference = []\\n\\n        for i in range(len(string)):\\n            if string[i] != goal[i]:\\n                difference.append((string[i], goal[i]))\\n\\n\\n        if len(difference) == 2 and difference[0] == difference[-1][::-1]: \\n            return True\\n\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n#     O(n) || O(26)\\n# Runtime: 40ms 78.04% memory: 14.2mb 60.39%\\n    def buddyStrings(self, string: str, goal: str) -> bool:\\n        left, right = 0, len(string) - 1\\n\\n        if len(string) != len(goal):\\n            return False\\n\\n        if string == goal and len(set(string)) < len(string):\\n            return True\\n\\n\\n        difference = []\\n\\n        for i in range(len(string)):\\n            if string[i] != goal[i]:\\n                difference.append((string[i], goal[i]))\\n\\n\\n        if len(difference) == 2 and difference[0] == difference[-1][::-1]: \\n            return True\\n\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094840,
                "title": "clean-simple-cpp-solution",
                "content": "```\\nbool buddyStrings(string s, string goal) {\\n        if(s.length() != goal.length())\\n            return false;\\n        int temp=-1;\\n        unordered_set<char> uset;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i] != goal[i] && temp == -1)\\n                temp = i;\\n            else if(s[i] != goal[i])\\n            {\\n                char ch = s[i];\\n                s[i] = s[temp];\\n                s[temp] = ch;\\n                return s == goal;\\n            }\\n            uset.insert(s[i]);\\n        }\\n        if(s==goal)\\n            return uset.size()<s.length();\\n        return false;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool buddyStrings(string s, string goal) {\\n        if(s.length() != goal.length())\\n            return false;\\n        int temp=-1;\\n        unordered_set<char> uset;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i] != goal[i] && temp == -1)\\n                temp = i;\\n            else if(s[i] != goal[i])\\n            {\\n                char ch = s[i];\\n                s[i] = s[temp];\\n                s[temp] = ch;\\n                return s == goal;\\n            }\\n            uset.insert(s[i]);\\n        }\\n        if(s==goal)\\n            return uset.size()<s.length();\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2047315,
                "title": "3ms-simple-and-fastest-java-solution",
                "content": "java code is:\\n```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length()!=goal.length())return false;\\n        int f[]=new int[26];\\n       List<Integer>list=new ArrayList<>();\\n       for(int i=0;i<s.length();i++){\\n           if(s.charAt(i)!=goal.charAt(i))list.add(i);\\n           if(list.size()>2)return false;\\n           f[s.charAt(i)-\\'a\\']++;\\n       }\\n       if(list.size()==0){\\n         for(int i=0;i<26;i++)if(f[i]>=2)return true;\\n           return false;\\n       }\\n       return list.size()==2&&s.charAt(list.get(0))==goal.charAt(list.get(1))&&s.charAt(list.get(1))==goal.charAt(list.get(0)); \\n           \\n    }\\n}\\n# ```\\n# Time : O(n) linear\\n# Space : O(1) constant extra space\\n# \\n# Please Upvote if this is helpful",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length()!=goal.length())return false;\\n        int f[]=new int[26];\\n       List<Integer>list=new ArrayList<>();\\n       for(int i=0;i<s.length();i++){\\n           if(s.charAt(i)!=goal.charAt(i))list.add(i);\\n           if(list.size()>2)return false;\\n           f[s.charAt(i)-\\'a\\']++;\\n       }\\n       if(list.size()==0){\\n         for(int i=0;i<26;i++)if(f[i]>=2)return true;\\n           return false;\\n       }\\n       return list.size()==2&&s.charAt(list.get(0))==goal.charAt(list.get(1))&&s.charAt(list.get(1))==goal.charAt(list.get(0)); \\n           \\n    }\\n}\\n# ```",
                "codeTag": "Java"
            },
            {
                "id": 1844958,
                "title": "c-o-n-two-pointer",
                "content": "```\\nclass Solution {\\npublic: \\n    bool buddyStrings(string s, string goal) {\\n        \\n        //Creating Hashmaps\\n        unordered_map<char, int> smp; \\n        unordered_map<char, int>  gmp;  \\n        \\n        //Initializing each key with frequencies\\n        for(char c : s) { \\n            smp[c]++;\\n        }     \\n        \\n        for (char c : goal) { \\n            gmp[c]++;\\n        } \\n        \\n        //If they don\\'t have same chars and frequencies return false\\n        if (smp != gmp) {   \\n            return false;\\n        } \\n        \\n        //If strings are equal and has a duplicate char then return true\\n        if (s == goal) { \\n            for (auto c : smp) { \\n                if (c.second >= 2) {  \\n                    return true;\\n                }\\n            }    \\n            \\n            //if all chars are unique return false\\n            return false;\\n        }\\n        \\n        //Two pointerapproach we have to just swap two chars not more than 2\\n        int i = 0; \\n        int j = 0; \\n        int ctr = 0;\\n        \\n        while (i < s.length()) { \\n            if (ctr > 2) { \\n                return false;\\n            } \\n            \\n            if (s[i] != goal[j]) { \\n                ctr++;\\n            } \\n            \\n            i++; \\n            j++;\\n        } \\n        \\n        return (ctr > 2) ? false : true; \\n   }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    bool buddyStrings(string s, string goal) {\\n        \\n        //Creating Hashmaps\\n        unordered_map<char, int> smp; \\n        unordered_map<char, int>  gmp;  \\n        \\n        //Initializing each key with frequencies\\n        for(char c : s) { \\n            smp[c]++;\\n        }     \\n        \\n        for (char c : goal) { \\n            gmp[c]++;\\n        } \\n        \\n        //If they don\\'t have same chars and frequencies return false\\n        if (smp != gmp) {   \\n            return false;\\n        } \\n        \\n        //If strings are equal and has a duplicate char then return true\\n        if (s == goal) { \\n            for (auto c : smp) { \\n                if (c.second >= 2) {  \\n                    return true;\\n                }\\n            }    \\n            \\n            //if all chars are unique return false\\n            return false;\\n        }\\n        \\n        //Two pointerapproach we have to just swap two chars not more than 2\\n        int i = 0; \\n        int j = 0; \\n        int ctr = 0;\\n        \\n        while (i < s.length()) { \\n            if (ctr > 2) { \\n                return false;\\n            } \\n            \\n            if (s[i] != goal[j]) { \\n                ctr++;\\n            } \\n            \\n            i++; \\n            j++;\\n        } \\n        \\n        return (ctr > 2) ? false : true; \\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675326,
                "title": "c-easy-logic-hashmap",
                "content": "**Upvote if you found solution helpful**\\n```C++\\nclass Solution\\n{\\npublic:\\n    bool buddyStrings(string s, string goal)\\n    {\\n        if (s.length() != goal.length())\\n            return false;\\n        if (s == goal)\\n        {\\n            unordered_map<char, int> m;\\n            for (auto x : s)\\n            {\\n                m[x]++;\\n            }\\n            for (auto x : m)\\n            {\\n                if (x.second > 1)\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else\\n        {\\n            int first = -1, second = -1;\\n            for (int i = 0; i < s.length(); ++i)\\n            {\\n                if (s[i] != goal[i])\\n                {\\n                    if (first == -1)\\n                        first = i;\\n                    else if (second == -1)\\n                        second = i;\\n                    else\\n                        return false;\\n                }\\n            }\\n\\n            return (second != -1 && s[first] == goal[second] &&\\n                    s[second] == goal[first]);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution\\n{\\npublic:\\n    bool buddyStrings(string s, string goal)\\n    {\\n        if (s.length() != goal.length())\\n            return false;\\n        if (s == goal)\\n        {\\n            unordered_map<char, int> m;\\n            for (auto x : s)\\n            {\\n                m[x]++;\\n            }\\n            for (auto x : m)\\n            {\\n                if (x.second > 1)\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else\\n        {\\n            int first = -1, second = -1;\\n            for (int i = 0; i < s.length(); ++i)\\n            {\\n                if (s[i] != goal[i])\\n                {\\n                    if (first == -1)\\n                        first = i;\\n                    else if (second == -1)\\n                        second = i;\\n                    else\\n                        return false;\\n                }\\n            }\\n\\n            return (second != -1 && s[first] == goal[second] &&\\n                    s[second] == goal[first]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1595770,
                "title": "python-o-n-3-rules",
                "content": "```\\nclass Solution:\\n    def can_be_replaced(self, s1, s2):        \\n        diff_chars = []                        \\n        for i in range(len(s1)):\\n            if s1[i] != s2[i]:\\n                diff_chars.append((s1[i], s2[i]))\\n        \\n        if len(diff_chars) != 2: return False\\n                        \\n        return diff_chars[0][0] == diff_chars[1][1] and diff_chars[0][1] == diff_chars[1][0]\\n        ## alternative\\n        #return diff_chars[0] == diff_chars[1][::-1]\\n        \\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal): return False\\n        \\n        if s == goal:  return max(Counter(s).values()) > 1        \\n        \\n        return self.can_be_replaced(s, goal)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def can_be_replaced(self, s1, s2):        \\n        diff_chars = []                        \\n        for i in range(len(s1)):\\n            if s1[i] != s2[i]:\\n                diff_chars.append((s1[i], s2[i]))\\n        \\n        if len(diff_chars) != 2: return False\\n                        \\n        return diff_chars[0][0] == diff_chars[1][1] and diff_chars[0][1] == diff_chars[1][0]\\n        ## alternative\\n        #return diff_chars[0] == diff_chars[1][::-1]\\n        \\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal): return False\\n        \\n        if s == goal:  return max(Counter(s).values()) > 1        \\n        \\n        return self.can_be_replaced(s, goal)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1553216,
                "title": "fast-python-solution-using-list-comprehension",
                "content": "```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        \\n        if len(s) != len(goal): return False\\n        \\n        comparisson = [i for i in range(len(s)) if s[i]!=goal[i]]\\n        \\n        if len(comparisson) > 2:\\n            return False\\n        if len(comparisson) == 2 and s[comparisson[0]]==goal[comparisson[1]] and s[comparisson[1]]==goal[comparisson[0]]: \\n            return True\\n        if len(comparisson) == 0 and len(s) > len(set(list(s))): #check if there are duplicate characters for swap\\n            return True\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        \\n        if len(s) != len(goal): return False\\n        \\n        comparisson = [i for i in range(len(s)) if s[i]!=goal[i]]\\n        \\n        if len(comparisson) > 2:\\n            return False\\n        if len(comparisson) == 2 and s[comparisson[0]]==goal[comparisson[1]] and s[comparisson[1]]==goal[comparisson[0]]: \\n            return True\\n        if len(comparisson) == 0 and len(s) > len(set(list(s))): #check if there are duplicate characters for swap\\n            return True\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497715,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n\\tpublic boolean buddyStrings(String s, String goal) {\\n        if (s.length() < 2 ) return false;\\n\\t\\telse if (s.replace(String.valueOf(s.charAt(0)), \"\").length() == 0) return true;\\n\\t\\telse if (s.equals(goal)) return Arrays.stream(s.toLowerCase().split(\"\")).distinct().count() != s.length();\\n\\t\\telse if (countDiff(s,goal) != 2 ) return false;\\n\\t\\telse {\\n\\t\\t\\tint[] arr = new int[2];\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int j = 0; j < s.length(); j++)\\n\\t\\t\\t\\tif (s.charAt(j) != goal.charAt(j)) {\\n\\t\\t\\t\\t\\tarr[count] = j;\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\tchar[] c = s.toCharArray();\\n\\t\\t\\tchar temp = c[arr[0]];\\n\\t\\t\\tc[arr[0]] = c[arr[1]];\\n\\t\\t\\tc[arr[1]] = temp;\\n\\t\\t\\treturn new String(c).equals(goal);\\n\\t\\t}\\n\\t}\\n\\n\\tpublic static int countDiff(String s, String goal) {\\n\\t\\tint count = 0;\\n\\t\\tfor (int j = 0; j < s.length(); j++)\\n\\t\\t\\tif (s.charAt(j) != goal.charAt(j)) count++;\\n\\t\\treturn count;\\n\\t}\\n}\\n```\\nif you want to get it more clear DM me on insta (im_krgs)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tpublic boolean buddyStrings(String s, String goal) {\\n        if (s.length() < 2 ) return false;\\n\\t\\telse if (s.replace(String.valueOf(s.charAt(0)), \"\").length() == 0) return true;\\n\\t\\telse if (s.equals(goal)) return Arrays.stream(s.toLowerCase().split(\"\")).distinct().count() != s.length();\\n\\t\\telse if (countDiff(s,goal) != 2 ) return false;\\n\\t\\telse {\\n\\t\\t\\tint[] arr = new int[2];\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int j = 0; j < s.length(); j++)\\n\\t\\t\\t\\tif (s.charAt(j) != goal.charAt(j)) {\\n\\t\\t\\t\\t\\tarr[count] = j;\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\tchar[] c = s.toCharArray();\\n\\t\\t\\tchar temp = c[arr[0]];\\n\\t\\t\\tc[arr[0]] = c[arr[1]];\\n\\t\\t\\tc[arr[1]] = temp;\\n\\t\\t\\treturn new String(c).equals(goal);\\n\\t\\t}\\n\\t}\\n\\n\\tpublic static int countDiff(String s, String goal) {\\n\\t\\tint count = 0;\\n\\t\\tfor (int j = 0; j < s.length(); j++)\\n\\t\\t\\tif (s.charAt(j) != goal.charAt(j)) count++;\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1364580,
                "title": "c-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        \\n        if(s == goal){\\n            return ((set<char>(s.begin(),s.end())).size() < s.size());\\n        }\\n        \\n        int n = s.size();\\n        int i=0;\\n        int j=n-1;\\n        while(i<n&& s[i]==goal[i]){\\n            i++;\\n        }\\n        while(j>0 && s[j] == goal[j]){\\n            j--;\\n        }\\n        \\n        if(i<j){\\n            swap(s[i],s[j]);\\n        }\\n        \\n        return s == goal;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        \\n        if(s == goal){\\n            return ((set<char>(s.begin(),s.end())).size() < s.size());\\n        }\\n        \\n        int n = s.size();\\n        int i=0;\\n        int j=n-1;\\n        while(i<n&& s[i]==goal[i]){\\n            i++;\\n        }\\n        while(j>0 && s[j] == goal[j]){\\n            j--;\\n        }\\n        \\n        if(i<j){\\n            swap(s[i],s[j]);\\n        }\\n        \\n        return s == goal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1358742,
                "title": "c",
                "content": "```\\n bool buddyStrings(string s, string goal) {\\n        \\n        \\n        if(s.length()!=goal.length()){\\n            return false;\\n        }\\n        \\n        map<char,int>M;\\n        vector<int>V;\\n        for(int i=0;i<s.length();i++){\\n            M[s[i]]++;\\n            if(s[i]!=goal[i]){\\n                V.push_back(i);\\n                if(V.size()==2){\\n                    swap(s[V[0]],s[V[1]]);\\n                    if(s==goal){\\n                       return true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        for(auto it:M){\\n            if(it.second>=2&&s==goal){\\n                return true;\\n            }\\n        }\\n        \\n        \\n        return false;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n bool buddyStrings(string s, string goal) {\\n        \\n        \\n        if(s.length()!=goal.length()){\\n            return false;\\n        }\\n        \\n        map<char,int>M;\\n        vector<int>V;\\n        for(int i=0;i<s.length();i++){\\n            M[s[i]]++;\\n            if(s[i]!=goal[i]){\\n                V.push_back(i);\\n                if(V.size()==2){\\n                    swap(s[V[0]],s[V[1]]);\\n                    if(s==goal){\\n                       return true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        for(auto it:M){\\n            if(it.second>=2&&s==goal){\\n                return true;\\n            }\\n        }\\n        \\n        \\n        return false;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1305422,
                "title": "100-faster-c-solution",
                "content": "**If you like it then please upvote**\\n\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        \\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        if(s==goal){\\n            unordered_map<char,int> m;\\n            for(auto i:s){\\n                m[i]++;\\n            }\\n            for(auto itr=m.begin(); itr!=m.end();itr++){\\n                if(itr->second>1){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        vector<int> v;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]!=goal[i]){\\n                v.push_back(i);\\n            }\\n        }\\n        if(v.size()==2){\\n            if(s[v[0]]==goal[v[1]]&&s[v[1]]==goal[v[0]]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        \\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        if(s==goal){\\n            unordered_map<char,int> m;\\n            for(auto i:s){\\n                m[i]++;\\n            }\\n            for(auto itr=m.begin(); itr!=m.end();itr++){\\n                if(itr->second>1){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        vector<int> v;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]!=goal[i]){\\n                v.push_back(i);\\n            }\\n        }\\n        if(v.size()==2){\\n            if(s[v[0]]==goal[v[1]]&&s[v[1]]==goal[v[0]]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1174190,
                "title": "simple-python-straight-forward-solution",
                "content": "Stats- Runtime: 28 ms, faster than 91.80% of Python3 online submissions for Buddy Strings.\\nMemory Usage: 14.4 MB, less than 72.02% of Python3 online submissions for Buddy Strings.\\n\\n```\\ndef buddyStrings(a, b):\\n\\t#compare length, if lenght is different, there is no way strings could be similar\\n\\tif len(a) != len(b):\\n\\t\\treturn False\\n\\t\\t\\n\\t#lists for elements different in string a and string b\\n\\tnotSimilarA = []\\n\\tnotSimilarB = []\\n\\t\\n\\t#pull out different character in both strings\\n\\tfor swi in range(len(a)):\\n\\t\\tif a[swi] != b[swi]:\\n\\t\\t\\tnotSimilarA.append(a[swi])\\n\\t\\t\\tnotSimilarB.append(b[swi])\\n\\t\\t\\t\\n\\t#print(f\"notSimilarA: {notSimilarA}\")\\n\\t#print(f\"notSimilarB: {notSimilarB}\")\\n\\t\\n\\t#if more than 2 characters are different then swapping one pair wont be suffice\\n\\tif len(notSimilarA) > 2:\\n\\t\\treturn False\\n\\t\\n\\t#if both strings are similar, then check if there is any pair of similar characters that can be swapped without changing string literally\\n\\tif not notSimilarA:\\n\\t\\tif len(set(a)) == len(a):\\n\\t\\t\\treturn False\\n\\telse:\\n\\t\\tfor swi in range(len(notSimilarA)):\\n\\t\\t\\tif notSimilarA[swi] not in notSimilarB:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\n\\treturn True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef buddyStrings(a, b):\\n\\t#compare length, if lenght is different, there is no way strings could be similar\\n\\tif len(a) != len(b):\\n\\t\\treturn False\\n\\t\\t\\n\\t#lists for elements different in string a and string b\\n\\tnotSimilarA = []\\n\\tnotSimilarB = []\\n\\t\\n\\t#pull out different character in both strings\\n\\tfor swi in range(len(a)):\\n\\t\\tif a[swi] != b[swi]:\\n\\t\\t\\tnotSimilarA.append(a[swi])\\n\\t\\t\\tnotSimilarB.append(b[swi])\\n\\t\\t\\t\\n\\t#print(f\"notSimilarA: {notSimilarA}\")\\n\\t#print(f\"notSimilarB: {notSimilarB}\")\\n\\t\\n\\t#if more than 2 characters are different then swapping one pair wont be suffice\\n\\tif len(notSimilarA) > 2:\\n\\t\\treturn False\\n\\t\\n\\t#if both strings are similar, then check if there is any pair of similar characters that can be swapped without changing string literally\\n\\tif not notSimilarA:\\n\\t\\tif len(set(a)) == len(a):\\n\\t\\t\\treturn False\\n\\telse:\\n\\t\\tfor swi in range(len(notSimilarA)):\\n\\t\\t\\tif notSimilarA[swi] not in notSimilarB:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1164321,
                "title": "java-string-one-pass-beats-99-1ms-t-c-o-n-s-c-o-1",
                "content": "\\n    public boolean buddyStrings(String a, String b) {\\n        int len1 = a.length(), len2 = b.length();\\n\\t\\tif (len1 != len2)\\n\\t\\t\\treturn false;\\n\\n\\t\\tint count = 0;\\n\\t\\tchar ch1 = \\'\\\\0\\', ch2 = \\'\\\\0\\', ch3 = \\'\\\\0\\', ch4 = \\'\\\\0\\';\\n\\t\\tboolean flag = false;\\n\\t\\tboolean[] map = new boolean[26];\\n\\t\\tfor (int i = 0; i < len1; i++) {\\n\\t\\t\\tchar ch11 = a.charAt(i), ch22 = b.charAt(i);\\n\\t\\t\\tif (ch11 != ch22) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tif (count == 1) {\\n\\t\\t\\t\\t\\tch1 = ch11;\\n\\t\\t\\t\\t\\tch2 = ch22;\\n\\t\\t\\t\\t} else if (count == 2) {\\n\\t\\t\\t\\t\\tch3 = ch11;\\n\\t\\t\\t\\t\\tch4 = ch22;\\n\\t\\t\\t\\t}\\n                else\\n                    return false;\\n\\t\\t\\t}\\n\\t\\t\\tif (map[ch11 - \\'a\\'])\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\tmap[ch11 - \\'a\\'] = true;\\n\\t\\t}\\n\\n\\t\\tif (count == 0 && flag)\\n\\t\\t\\treturn true;\\n\\n\\t\\tif (count == 2 && ch1 == ch4 && ch2 == ch3)\\n\\t\\t\\treturn true;\\n\\n\\t\\treturn false;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public boolean buddyStrings(String a, String b) {\\n        int len1 = a.length(), len2 = b.length();\\n\\t\\tif (len1 != len2)\\n\\t\\t\\treturn false;\\n\\n\\t\\tint count = 0;\\n\\t\\tchar ch1 = \\'\\\\0\\', ch2 = \\'\\\\0\\', ch3 = \\'\\\\0\\', ch4 = \\'\\\\0\\';\\n\\t\\tboolean flag = false;\\n\\t\\tboolean[] map = new boolean[26];\\n\\t\\tfor (int i = 0; i < len1; i++) {\\n\\t\\t\\tchar ch11 = a.charAt(i), ch22 = b.charAt(i);\\n\\t\\t\\tif (ch11 != ch22) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tif (count == 1) {\\n\\t\\t\\t\\t\\tch1 = ch11;\\n\\t\\t\\t\\t\\tch2 = ch22;\\n\\t\\t\\t\\t} else if (count == 2) {\\n\\t\\t\\t\\t\\tch3 = ch11;\\n\\t\\t\\t\\t\\tch4 = ch22;\\n\\t\\t\\t\\t}\\n                else\\n                    return false;\\n\\t\\t\\t}\\n\\t\\t\\tif (map[ch11 - \\'a\\'])\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\tmap[ch11 - \\'a\\'] = true;\\n\\t\\t}\\n\\n\\t\\tif (count == 0 && flag)\\n\\t\\t\\treturn true;\\n\\n\\t\\tif (count == 2 && ch1 == ch4 && ch2 == ch3)\\n\\t\\t\\treturn true;\\n\\n\\t\\treturn false;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 906614,
                "title": "c-beats-100",
                "content": "**Explanation**\\nMy first thought process was to build an O(N^2) solution, by creating all possible strings from A by swapping any two characters. However, I noticed that if I compare each position in two Buddy Strings A and B, then (N-2) positions will correspond, and exactly 2 will be unequal. If the 2 positions which have different characters in A and B be i and j respectively, then further we must have A[i] = B[j] & A[j] = B[i].\\n\\nFor eg. ABCDBA and ADCBBA. Here i = 1, j = 3. All the remaining indices are such that A[k] = B[k].\\n\\nAlso if we have two equal strings, then we won\\'t have any indices i such that A[i] != B[i]. Two equal strings will be buddy strings, only if I have atleast one duplicate character, because I could then swap the duplicate characters.\\nFor eg. ABCDBA and ABCDBA, we can swap (A, A) or (B, B).\\n\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        if (A.length() != B.length()) {\\n            return false;\\n        }\\n        \\n\\t\\t// Stores i  and j.\\n        vector<int> index;\\n\\n\\t\\t// To count for Duplicate Character.\\n        vector<int> freq(26, 0);\\n\\n\\t\\t// Stores whether Duplicate Character Exists.\\n        bool dup = false;\\n        \\n        for (int i=0; i<A.length(); ++i) {\\n\\t\\t\\t// Found the Duplicate. \\n            if (++freq[A[i]-\\'a\\'] > 1) {\\n                dup = true;\\n            }\\n\\n            if (A[i] != B[i]) {\\n                index.push_back(i);\\n\\t\\t\\t\\t// More than 2 Different Characters.\\n                if (index.size() > 2)\\n                    return false;\\n            }\\n        }\\n        \\n        if (index.size() < 2) {\\n            if (index.size() == 1)\\n                return false;\\n        \\n            // 0 means identical, if i have duplicates, then True.\\n            return dup;\\n        }\\n        \\n        return (A[index[0]] == B[index[1]] && A[index[1]] == B[index[0]]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        if (A.length() != B.length()) {\\n            return false;\\n        }\\n        \\n\\t\\t// Stores i  and j.\\n        vector<int> index;\\n\\n\\t\\t// To count for Duplicate Character.\\n        vector<int> freq(26, 0);\\n\\n\\t\\t// Stores whether Duplicate Character Exists.\\n        bool dup = false;\\n        \\n        for (int i=0; i<A.length(); ++i) {\\n\\t\\t\\t// Found the Duplicate. \\n            if (++freq[A[i]-\\'a\\'] > 1) {\\n                dup = true;\\n            }\\n\\n            if (A[i] != B[i]) {\\n                index.push_back(i);\\n\\t\\t\\t\\t// More than 2 Different Characters.\\n                if (index.size() > 2)\\n                    return false;\\n            }\\n        }\\n        \\n        if (index.size() < 2) {\\n            if (index.size() == 1)\\n                return false;\\n        \\n            // 0 means identical, if i have duplicates, then True.\\n            return dup;\\n        }\\n        \\n        return (A[index[0]] == B[index[1]] && A[index[1]] == B[index[0]]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 891512,
                "title": "swift-solution",
                "content": "**Solution**\\n```swift\\nfunc buddyStrings(_ A: String, _ B: String) -> Bool {\\n\\tguard A.count == B.count else { return false }\\n\\n\\t// 1. Strings are equal. Is there a duplicate we can swap? \\n\\tif A == B {\\n\\t\\tvar set = Set<Character>() \\n\\t\\tfor char in A {\\n\\t\\t\\tif set.contains(char)  {\\n\\t\\t\\t\\treturn true \\n\\t\\t\\t}\\n\\t\\t\\tset.insert(char)\\n\\t\\t}\\n\\t\\treturn false \\n\\t}\\n\\n\\t// 2. Strings are different. Ensure swapping maintains equality.\\n\\tvar pairs = [[Character]]()\\n\\tfor (a, b) in zip(A, B) {\\n\\t\\tif a != b {\\n\\t\\t\\tpairs.append([a, b])\\n\\t\\t}\\n\\t\\tif pairs.count > 2 {\\n\\t\\t\\treturn false \\n\\t\\t}\\n\\t}\\n\\n\\treturn pairs.count == 2 && pairs[0] == pairs[1].reversed()\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nfunc buddyStrings(_ A: String, _ B: String) -> Bool {\\n\\tguard A.count == B.count else { return false }\\n\\n\\t// 1. Strings are equal. Is there a duplicate we can swap? \\n\\tif A == B {\\n\\t\\tvar set = Set<Character>() \\n\\t\\tfor char in A {\\n\\t\\t\\tif set.contains(char)  {\\n\\t\\t\\t\\treturn true \\n\\t\\t\\t}\\n\\t\\t\\tset.insert(char)\\n\\t\\t}\\n\\t\\treturn false \\n\\t}\\n\\n\\t// 2. Strings are different. Ensure swapping maintains equality.\\n\\tvar pairs = [[Character]]()\\n\\tfor (a, b) in zip(A, B) {\\n\\t\\tif a != b {\\n\\t\\t\\tpairs.append([a, b])\\n\\t\\t}\\n\\t\\tif pairs.count > 2 {\\n\\t\\t\\treturn false \\n\\t\\t}\\n\\t}\\n\\n\\treturn pairs.count == 2 && pairs[0] == pairs[1].reversed()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 891486,
                "title": "clear-c-solution-with-comments-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        \\n        int n=A.length(),m=B.length();\\n        \\n        if(n!=m)              // if both length is not equal then it is not a buddy string \\n            return false;\\n        else\\n        {\\n            int f1[26]={0};\\n            int f2[26]={0};\\n            int count=0;\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                if(A[i]!=B[i])  //check the number of unequal characters\\n                    count++;\\n                f1[A[i]-\\'a\\']++; //frequency of characters in A\\n                f2[B[i]-\\'a\\']++; //frequency of characters in B\\n            }\\n            \\n            if(count==0) // if string A is equal to string B\\n            {\\n                for(int i=0;i<26;i++)  // if frequency of any character is greater than 1\\n                {                      // then we can swap between them\\n                    if(f1[i]>=2)\\n                        return true;\\n                }    \\n                return false;\\n            }\\n            else if(count==2)         //if different characters in both strings are 2  \\n            {\\n                for(int i=0;i<26;i++) // then if frequency of each characters in both string is equal then \\n                {\\n                    if(f1[i]!=f2[i])  // is acceptable or unacceptable \\n                        return false;       \\n                }\\n                return true;\\n            }\\n            else                     // else in any case the string is unacceptable\\n                return false;\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        \\n        int n=A.length(),m=B.length();\\n        \\n        if(n!=m)              // if both length is not equal then it is not a buddy string \\n            return false;\\n        else\\n        {\\n            int f1[26]={0}",
                "codeTag": "Java"
            },
            {
                "id": 891172,
                "title": "efficient-scala-solution",
                "content": "```scala\\n  def buddyStrings(A: String, B: String): Boolean =\\n    if (A.length != B.length) false\\n    else {\\n      val diff = A.indices.filter(i => A(i) != B(i))\\n      (diff.isEmpty && A.length > A.toSet.size) || (diff.length == 2 && diff.map(A(_)) == diff.map(B(_)).reverse)\\n    }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\n  def buddyStrings(A: String, B: String): Boolean =\\n    if (A.length != B.length) false\\n    else {\\n      val diff = A.indices.filter(i => A(i) != B(i))\\n      (diff.isEmpty && A.length > A.toSet.size) || (diff.length == 2 && diff.map(A(_)) == diff.map(B(_)).reverse)\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 890987,
                "title": "c-solution-100-fast-explained",
                "content": "EXPLANATION\\n1.  if string lenght is different -> return false;\\n2.  iterate strings and count the occurencies of each char and memorize if a duplicate is found;\\n3.  Count the differencesies, if bigger than 2 -> return false\\n4.  Compare occurencies arrays and if they are different -> return false\\n5.  If occurencies are the same and differencies (count) == 2 -> return true\\n6.  if count == 0 but there is a duplicate letter to swap with no effect -> return true;\\n\\n```\\nbool buddyStrings(char * A, char * B){\\n    int lenA = strlen(A), count=0, alphabetA[26] = {0},alphabetB[26] = {0}, duplicate = 0,i;\\n    int lenB = strlen(B);\\n    if(lenA != lenB) return false;\\n    for(i =0; i<lenA; i++){\\n        alphabetA[A[i]-\\'a\\']++;\\n        alphabetB[B[i]-\\'a\\']++;\\n        if(alphabetA[A[i]-\\'a\\']>1)\\n            duplicate = 1;\\n        if(A[i] != B[i]) \\n            count++;\\n        if(count >2) return false;\\n    }\\n    for(i=0;i<26;i++){\\n        if(alphabetA[i] != alphabetB[i])\\n            return false;\\n    }\\n    if(count == 2) return true;\\n    \\n    if(count == 0 && duplicate == 1) return true;\\n    return false;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "EXPLANATION\\n1.  if string lenght is different -> return false;\\n2.  iterate strings and count the occurencies of each char and memorize if a duplicate is found;\\n3.  Count the differencesies, if bigger than 2 -> return false\\n4.  Compare occurencies arrays and if they are different -> return false\\n5.  If occurencies are the same and differencies (count) == 2 -> return true\\n6.  if count == 0 but there is a duplicate letter to swap with no effect -> return true;\\n\\n```\\nbool buddyStrings(char * A, char * B){\\n    int lenA = strlen(A), count=0, alphabetA[26] = {0},alphabetB[26] = {0}, duplicate = 0,i;\\n    int lenB = strlen(B);\\n    if(lenA != lenB) return false;\\n    for(i =0; i<lenA; i++){\\n        alphabetA[A[i]-\\'a\\']++;\\n        alphabetB[B[i]-\\'a\\']++;\\n        if(alphabetA[A[i]-\\'a\\']>1)\\n            duplicate = 1;\\n        if(A[i] != B[i]) \\n            count++;\\n        if(count >2) return false;\\n    }\\n    for(i=0;i<26;i++){\\n        if(alphabetA[i] != alphabetB[i])\\n            return false;\\n    }\\n    if(count == 2) return true;\\n    \\n    if(count == 0 && duplicate == 1) return true;\\n    return false;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 872736,
                "title": "ruby-o-n-56ms-70-easy-to-understand",
                "content": "```\\ndef buddy_strings(a, b)\\n  # Obviously, the answer is no if strings have different lengths\\n  return false if a.length != b.length\\n  \\n  # Let\\'s find all indices where a[i] != b[i]\\n  incorrect_indices = (0..a.length - 1).select {|i| a[i] != b[i]}\\n  \\n  # How many mismatching indices do we have?\\n  case incorrect_indices.length\\n    # If it\\'s 0, then strings are identical. \\n\\t# In this case, we need to have two same characters in the string to be able to swap them without changing the string\\n\\t# For example, in string \\'aa\\' we can swap the characters and it will still be \\'aa\\'\\n\\t# Let\\'s just check if there are any duplicate characters using .uniq \\n    when 0\\n      a.split(\\'\\').uniq.length < a.length\\n    \\n\\t# If it\\'s 2, then there are two mismatching characters. Let\\'s check if they are actually two swapped characters\\n    when 2\\n      ind1, ind2 = incorrect_indices\\n      a[ind1] == b[ind2] && a[ind2] == b[ind1]\\n    \\n\\t# Otherwise, the answer is no\\n    else\\n      false\\n  end\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef buddy_strings(a, b)\\n  # Obviously, the answer is no if strings have different lengths\\n  return false if a.length != b.length\\n  \\n  # Let\\'s find all indices where a[i] != b[i]\\n  incorrect_indices = (0..a.length - 1).select {|i| a[i] != b[i]}\\n  \\n  # How many mismatching indices do we have?\\n  case incorrect_indices.length\\n    # If it\\'s 0, then strings are identical. \\n\\t# In this case, we need to have two same characters in the string to be able to swap them without changing the string\\n\\t# For example, in string \\'aa\\' we can swap the characters and it will still be \\'aa\\'\\n\\t# Let\\'s just check if there are any duplicate characters using .uniq \\n    when 0\\n      a.split(\\'\\').uniq.length < a.length\\n    \\n\\t# If it\\'s 2, then there are two mismatching characters. Let\\'s check if they are actually two swapped characters\\n    when 2\\n      ind1, ind2 = incorrect_indices\\n      a[ind1] == b[ind2] && a[ind2] == b[ind1]\\n    \\n\\t# Otherwise, the answer is no\\n    else\\n      false\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 832817,
                "title": "c-two-solutions",
                "content": "**Solution 1**\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        if (A.size() != B.size()) {\\n            return false;\\n        }\\n        unordered_map<char, int> aFreq, bFreq;\\n        for (int i = 0; i < A.size(); i++) {\\n            aFreq[A[i]]++;\\n            bFreq[B[i]]++;\\n        }\\n        if (aFreq != bFreq) {\\n            return false;\\n        }\\n        int misCnt = 0;\\n        for (int i = 0; i < A.size(); i++) {\\n            if (A[i] != B[i]) {\\n                misCnt++;\\n            }\\n            if (misCnt > 2) {\\n                return false;\\n            }\\n        }\\n        if (misCnt == 2) {\\n            return true;\\n        }\\n        if (misCnt == 1 || !consecutiveLetterCheck(aFreq)) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool consecutiveLetterCheck(unordered_map<char, int> mp) {\\n        for (auto elem : mp) {\\n            if (elem.second > 1) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n**Solution 2 (Better)**\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        if (A.size() != B.size()) {\\n            return false;\\n        }\\n        \\n        // If A & B are equal and A has duplicates -> A = \"aba\", B = \"aba\", we can swap a\\'s\\n        if (A == B && set<char>(A.begin(), A.end()).size() < A.size()) {\\n            return true;\\n        }\\n        \\n        // Save indices where letters are different\\n        vector<int> diff;\\n        for (int i = 0; i < A.size(); i++) {\\n            if (A[i] != B[i]) {\\n                diff.push_back(i);\\n            }\\n        }\\n        return (diff.size() == 2 && A[diff[0]] == B[diff[1]] && A[diff[1]] == B[diff[0]]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        if (A.size() != B.size()) {\\n            return false;\\n        }\\n        unordered_map<char, int> aFreq, bFreq;\\n        for (int i = 0; i < A.size(); i++) {\\n            aFreq[A[i]]++;\\n            bFreq[B[i]]++;\\n        }\\n        if (aFreq != bFreq) {\\n            return false;\\n        }\\n        int misCnt = 0;\\n        for (int i = 0; i < A.size(); i++) {\\n            if (A[i] != B[i]) {\\n                misCnt++;\\n            }\\n            if (misCnt > 2) {\\n                return false;\\n            }\\n        }\\n        if (misCnt == 2) {\\n            return true;\\n        }\\n        if (misCnt == 1 || !consecutiveLetterCheck(aFreq)) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool consecutiveLetterCheck(unordered_map<char, int> mp) {\\n        for (auto elem : mp) {\\n            if (elem.second > 1) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        if (A.size() != B.size()) {\\n            return false;\\n        }\\n        \\n        // If A & B are equal and A has duplicates -> A = \"aba\", B = \"aba\", we can swap a\\'s\\n        if (A == B && set<char>(A.begin(), A.end()).size() < A.size()) {\\n            return true;\\n        }\\n        \\n        // Save indices where letters are different\\n        vector<int> diff;\\n        for (int i = 0; i < A.size(); i++) {\\n            if (A[i] != B[i]) {\\n                diff.push_back(i);\\n            }\\n        }\\n        return (diff.size() == 2 && A[diff[0]] == B[diff[1]] && A[diff[1]] == B[diff[0]]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 804174,
                "title": "clean-and-understandable-java-solution-in-o-n",
                "content": "```\\nimport java.util.Set;\\nimport java.util.HashSet;\\n\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        if (A.length() != B.length()) return false;\\n        \\n        // Idea: find indices where charAt\\'s are different\\n        int diffIndex1 = -1;\\n        int diffIndex2 = -1;\\n        \\n        int length = A.length();\\n        for (int i = 0; i < length; i++) {\\n            if (A.charAt(i) != B.charAt(i)) {\\n                if (diffIndex1 == -1) diffIndex1 = i;\\n                else if (diffIndex2 == -1) diffIndex2 = i;\\n                else return false;  // More than two differences\\n            }\\n        }\\n        \\n        // No differences: return true only if some letter has frequency > 1\\n        //     since we can just swap that letter with itself\\n        if (diffIndex1 == -1) {\\n            final Set<Character> charsSeen = new HashSet<>();\\n            for (char c : A.toCharArray()) {\\n                if (charsSeen.add(c) == false) return true;\\n            }\\n            return false;\\n        }\\n        \\n        // Exactly one difference\\n        if (diffIndex2 == -1) return false;\\n        \\n        // Exactly two differences, see if it can be swapped\\n        return (A.charAt(diffIndex1) == B.charAt(diffIndex2) && \\n                A.charAt(diffIndex2) == B.charAt(diffIndex1));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Set;\\nimport java.util.HashSet;\\n\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        if (A.length() != B.length()) return false;\\n        \\n        // Idea: find indices where charAt\\'s are different\\n        int diffIndex1 = -1;\\n        int diffIndex2 = -1;\\n        \\n        int length = A.length();\\n        for (int i = 0; i < length; i++) {\\n            if (A.charAt(i) != B.charAt(i)) {\\n                if (diffIndex1 == -1) diffIndex1 = i;\\n                else if (diffIndex2 == -1) diffIndex2 = i;\\n                else return false;  // More than two differences\\n            }\\n        }\\n        \\n        // No differences: return true only if some letter has frequency > 1\\n        //     since we can just swap that letter with itself\\n        if (diffIndex1 == -1) {\\n            final Set<Character> charsSeen = new HashSet<>();\\n            for (char c : A.toCharArray()) {\\n                if (charsSeen.add(c) == false) return true;\\n            }\\n            return false;\\n        }\\n        \\n        // Exactly one difference\\n        if (diffIndex2 == -1) return false;\\n        \\n        // Exactly two differences, see if it can be swapped\\n        return (A.charAt(diffIndex1) == B.charAt(diffIndex2) && \\n                A.charAt(diffIndex2) == B.charAt(diffIndex1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 742068,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        \\n        if(A.length()!=B.length())\\n          return false;\\n        \\n        int i,count=0;;\\n        \\n        if(A.equals(B))\\n        {\\n            Set<Character> hs = new HashSet<>();\\n            for(i=0;i<A.length();i++)\\n               hs.add(A.charAt(i));\\n            \\n            if(hs.size()==A.length())\\n                return false;\\n        }\\n        \\n         \\n        List<Character> arr = new ArrayList<>();\\n     \\n        for(i=0;i<A.length();i++)\\n            if(A.charAt(i)!=B.charAt(i))\\n            {\\n                 arr.add(A.charAt(i));\\n                 arr.add(B.charAt(i));\\n                 count++;\\n            }\\n        \\n        if(count==0)\\n            return true;\\n        \\n        if(count==2 && arr.get(0).equals(arr.get(3)) && arr.get(1).equals(arr.get(2)))\\n           return true;\\n                                         \\n        return false;                                 \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        \\n        if(A.length()!=B.length())\\n          return false;\\n        \\n        int i,count=0;;\\n        \\n        if(A.equals(B))\\n        {\\n            Set<Character> hs = new HashSet<>();\\n            for(i=0;i<A.length();i++)\\n               hs.add(A.charAt(i));\\n            \\n            if(hs.size()==A.length())\\n                return false;\\n        }\\n        \\n         \\n        List<Character> arr = new ArrayList<>();\\n     \\n        for(i=0;i<A.length();i++)\\n            if(A.charAt(i)!=B.charAt(i))\\n            {\\n                 arr.add(A.charAt(i));\\n                 arr.add(B.charAt(i));\\n                 count++;\\n            }\\n        \\n        if(count==0)\\n            return true;\\n        \\n        if(count==2 && arr.get(0).equals(arr.get(3)) && arr.get(1).equals(arr.get(2)))\\n           return true;\\n                                         \\n        return false;                                 \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662260,
                "title": "java-o-n",
                "content": "```\\npublic boolean buddyStrings(String A, String B) {\\n\\tint[] aFreq = new int[26], bFreq = new int[26];\\n\\tint count = 0;\\n\\tfor (int i=0;i<A.length();i++) {\\n\\t\\tif(A.charAt(i) != B.charAt(i)) count ++;\\n\\t\\taFreq[A.charAt(i) - \\'a\\']++;\\n\\t\\tbFreq[B.charAt(i) - \\'a\\']++;\\n\\t}\\n\\tboolean hasDuplicates = false;\\n\\tfor (int i=0;i<26;i++) {\\n\\t\\tif(aFreq[i] != bFreq[i]) return false;\\n\\t\\tif(aFreq[i] > 1) hasDuplicates = true;\\n\\t}\\n\\tif(count != 2 && (count != 0 || !hasDuplicates)) return false;\\n\\treturn true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean buddyStrings(String A, String B) {\\n\\tint[] aFreq = new int[26], bFreq = new int[26];\\n\\tint count = 0;\\n\\tfor (int i=0;i<A.length();i++) {\\n\\t\\tif(A.charAt(i) != B.charAt(i)) count ++;\\n\\t\\taFreq[A.charAt(i) - \\'a\\']++;\\n\\t\\tbFreq[B.charAt(i) - \\'a\\']++;\\n\\t}\\n\\tboolean hasDuplicates = false;\\n\\tfor (int i=0;i<26;i++) {\\n\\t\\tif(aFreq[i] != bFreq[i]) return false;\\n\\t\\tif(aFreq[i] > 1) hasDuplicates = true;\\n\\t}\\n\\tif(count != 2 && (count != 0 || !hasDuplicates)) return false;\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 638400,
                "title": "rust-more-functional-style",
                "content": "``` rust\\nimpl Solution{\\n    pub fn buddy_strings(a: String, b: String) -> bool {\\n        if a.len() != b.len() {\\n            return false;\\n        }\\n        let diff = a\\n            .chars()\\n            .zip(b.chars())\\n            .filter(|(c, d)| c != d)\\n            .collect::<Vec<(char, char)>>();\\n        if diff.len() == 0 {\\n            let mut set = std::collections::HashSet::new();\\n            for i in 0..a.len() {\\n                if set.contains(&a[i..(i + 1)]) {\\n                    return true;\\n                }\\n                set.insert(&a[i..(i + 1)]);\\n            }\\n            false\\n        } else if diff.len() == 2 {\\n            let diff_a = diff[0];\\n            let diff_b = diff[1];\\n            diff_a.0 == diff_b.1 && diff_a.1 == diff_b.0 && diff_b.0 != diff_a.0\\n        } else {\\n            false\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` rust\\nimpl Solution{\\n    pub fn buddy_strings(a: String, b: String) -> bool {\\n        if a.len() != b.len() {\\n            return false;\\n        }\\n        let diff = a\\n            .chars()\\n            .zip(b.chars())\\n            .filter(|(c, d)| c != d)\\n            .collect::<Vec<(char, char)>>();\\n        if diff.len() == 0 {\\n            let mut set = std::collections::HashSet::new();\\n            for i in 0..a.len() {\\n                if set.contains(&a[i..(i + 1)]) {\\n                    return true;\\n                }\\n                set.insert(&a[i..(i + 1)]);\\n            }\\n            false\\n        } else if diff.len() == 2 {\\n            let diff_a = diff[0];\\n            let diff_b = diff[1];\\n            diff_a.0 == diff_b.1 && diff_a.1 == diff_b.0 && diff_b.0 != diff_a.0\\n        } else {\\n            false\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 488637,
                "title": "4-liner",
                "content": "```\\nbool buddyStrings(string A, string B) \\n{            \\n\\tunordered_set<char> s;\\n\\tint bad_swaps{0}, difs{0}; \\n\\tfor(int i{0}; i<min(size(A), size(B)); bad_swaps+=A[i]-B[i], difs+=A[i]!=B[i], s.insert(A[i++]));        \\n\\treturn A.size()==B.size() and difs==2 and !bad_swaps or !difs and size(s)<size(A);\\n}\\n```\\n```\\n||\\n```\\n```\\nbool buddyStrings(string A, string B) \\n{            \\n\\tint mem[256] = {0,};\\n\\tint reps(0), misses(0), delta(0);\\n\\tfor(int i{0}; i<size(A) and size(A)==size(B); misses+=A[i]!=B[i], delta+=A[i]-B[i++])\\n\\t\\treps = reps or exchange(mem[A[i]], 1);\\n\\treturn misses==2 and !delta or !misses and reps; \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool buddyStrings(string A, string B) \\n{            \\n\\tunordered_set<char> s;\\n\\tint bad_swaps{0}, difs{0}; \\n\\tfor(int i{0}; i<min(size(A), size(B)); bad_swaps+=A[i]-B[i], difs+=A[i]!=B[i], s.insert(A[i++]));        \\n\\treturn A.size()==B.size() and difs==2 and !bad_swaps or !difs and size(s)<size(A);\\n}\\n```\n```\\n||\\n```\n```\\nbool buddyStrings(string A, string B) \\n{            \\n\\tint mem[256] = {0,};\\n\\tint reps(0), misses(0), delta(0);\\n\\tfor(int i{0}; i<size(A) and size(A)==size(B); misses+=A[i]!=B[i], delta+=A[i]-B[i++])\\n\\t\\treps = reps or exchange(mem[A[i]], 1);\\n\\treturn misses==2 and !delta or !misses and reps; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 280680,
                "title": "multiple-python-solutions-longest-to-shortest",
                "content": "```\\ndef buddyStrings(self, A, B):\\n        if not A or not B:\\n            return False\\n        n, m = len(A), len(B)\\n        if n < m:\\n            return False\\n        if A == B:\\n            if len(A) % 2 != 0:\\n                return A[:int(n / 2)] == A[int(n / 2) + 1::]\\n            else:\\n                return A[:int(n / 2)] == A[int(n / 2)::]\\n        for i in range(n):\\n            if A[i] == B[i]:\\n                i += 1\\n            else:\\n                j = A[i + 1:].find(B[i])\\n                if j < 0:\\n                    return False\\n                else:\\n                    s = A[i + 1:][j] + A[i + 1:i + j + 1] + A[i] + A[i + j + 2:]\\n                    if s == B[i:]:\\n                        return True\\n                    return False\\n\\n        return True\\n\\ndef buddyStringsSol2(self, A, B):\\n\\tif not A or not B:\\n\\t\\treturn False\\n\\tn, m = len(A), len(B)\\n\\tif n != m:\\n\\t\\treturn False\\n\\tif A == B:\\n\\t\\tj = int(n / 2) + (1 if len(A) % 2 != 0 else 0)\\n\\t\\treturn A[:int(n / 2)] == A[j::]\\n\\tdiffPairs = [(a, b) for a, b in zip(A, B) if a != b]\\n\\tif len(diffPairs) > 2:\\n\\t\\treturn False\\n\\treturn diffPairs[0] == diffPairs[1][::-1]\\n\\ndef buddyStringsSol3(self, A, B):\\n\\tif len(A) != len(B):\\n\\t\\treturn False\\n\\tif A == B and len(set(A)) < len(A):\\n\\t\\treturn True\\n\\tpairs = [(a, b) for a, b in zip(A, B) if a != b]\\n\\treturn len(pairs) == 2 and pairs[0] == pairs[1][::-1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef buddyStrings(self, A, B):\\n        if not A or not B:\\n            return False\\n        n, m = len(A), len(B)\\n        if n < m:\\n            return False\\n        if A == B:\\n            if len(A) % 2 != 0:\\n                return A[:int(n / 2)] == A[int(n / 2) + 1::]\\n            else:\\n                return A[:int(n / 2)] == A[int(n / 2)::]\\n        for i in range(n):\\n            if A[i] == B[i]:\\n                i += 1\\n            else:\\n                j = A[i + 1:].find(B[i])\\n                if j < 0:\\n                    return False\\n                else:\\n                    s = A[i + 1:][j] + A[i + 1:i + j + 1] + A[i] + A[i + j + 2:]\\n                    if s == B[i:]:\\n                        return True\\n                    return False\\n\\n        return True\\n\\ndef buddyStringsSol2(self, A, B):\\n\\tif not A or not B:\\n\\t\\treturn False\\n\\tn, m = len(A), len(B)\\n\\tif n != m:\\n\\t\\treturn False\\n\\tif A == B:\\n\\t\\tj = int(n / 2) + (1 if len(A) % 2 != 0 else 0)\\n\\t\\treturn A[:int(n / 2)] == A[j::]\\n\\tdiffPairs = [(a, b) for a, b in zip(A, B) if a != b]\\n\\tif len(diffPairs) > 2:\\n\\t\\treturn False\\n\\treturn diffPairs[0] == diffPairs[1][::-1]\\n\\ndef buddyStringsSol3(self, A, B):\\n\\tif len(A) != len(B):\\n\\t\\treturn False\\n\\tif A == B and len(set(A)) < len(A):\\n\\t\\treturn True\\n\\tpairs = [(a, b) for a, b in zip(A, B) if a != b]\\n\\treturn len(pairs) == 2 and pairs[0] == pairs[1][::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 259780,
                "title": "c-using-dictionary-and-list",
                "content": "All my leetcode solution with C#(.NetCore) is at [Github](https://github.com/user3301/leetcodesln)\\n\\n```\\n public bool BuddyStringsSln(string A, string B)\\n        {\\n            if (A.Length != B.Length) return false;\\n\\n            if (A == B && A.Length >= 2)\\n            {\\n                var dict = new Dictionary<char, int>();\\n                foreach (var chr in A)\\n                {\\n                    if (dict.ContainsKey(chr))\\n                    {\\n                        return true;\\n                    }\\n                    else dict.Add(chr, 1);\\n                }\\n                return false;\\n\\n            }\\n            else\\n            {\\n                var list = new List<char>();\\n\\n                for (int i = 0; i < A.Length; i++)\\n                {\\n                    if (A[i] != B[i])\\n                    {\\n                        list.Add(A[i]);\\n                        list.Add(B[i]);\\n                    }\\n                }\\n                return list.Count == 4 && list[1] == list[2] && list[0] == list[3];\\n            }\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n public bool BuddyStringsSln(string A, string B)\\n        {\\n            if (A.Length != B.Length) return false;\\n\\n            if (A == B && A.Length >= 2)\\n            {\\n                var dict = new Dictionary<char, int>();\\n                foreach (var chr in A)\\n                {\\n                    if (dict.ContainsKey(chr))\\n                    {\\n                        return true;\\n                    }\\n                    else dict.Add(chr, 1);\\n                }\\n                return false;\\n\\n            }\\n            else\\n            {\\n                var list = new List<char>();\\n\\n                for (int i = 0; i < A.Length; i++)\\n                {\\n                    if (A[i] != B[i])\\n                    {\\n                        list.Add(A[i]);\\n                        list.Add(B[i]);\\n                    }\\n                }\\n                return list.Count == 4 && list[1] == list[2] && list[0] == list[3];\\n            }\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 215149,
                "title": "c-straightforward-solution",
                "content": "```\\nbool buddyStrings(string A, string B) {\\n        set<char> s;\\n        bool du=false;\\n        int i,j,size_A=A.size(),size_B=B.size();\\n        if(size_A<2||size_B<2||size_A!=size_B)return false;\\n        for(auto i:A) if(s.count(i)){du=true;break;} else s.insert(i);\\n        if(!du&&A==B)return false;\\n        else if(du&&A==B) return true;\\n        for(i=0;i<size_A;i++) if(A[i]!=B[i])break;\\n        for(j=size_A-1;j>-1;j--) if(A[j]!=B[j])break;\\n        swap(A[i],A[j]);\\n        return A==B;     \\n    }\\n\\t",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool buddyStrings(string A, string B) {\\n        set<char> s;\\n        bool du=false;\\n        int i,j,size_A=A.size(),size_B=B.size();\\n        if(size_A<2||size_B<2||size_A!=size_B)return false;\\n        for(auto i:A) if(s.count(i)){du=true;break;} else s.insert(i);\\n        if(!du&&A==B)return false;\\n        else if(du&&A==B) return true;\\n        for(i=0;i<size_A;i++) if(A[i]!=B[i])break;\\n        for(j=size_A-1;j>-1;j--) if(A[j]!=B[j])break;\\n        swap(A[i],A[j]);\\n        return A==B;     \\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 206701,
                "title": "easy-to-understand-python-solution-with-44ms",
                "content": "```\\nclass Solution:\\n    def buddyStrings(self, A, B):\\n        if len(A) != len(B):\\n            return False\\n        a=b=\\'\\'\\n        if A==B:\\n            return len(set(A))<len(A)\\n        for i in range(len(A)):\\n            if A[i] != B[i]:\\n                a = a+A[i]\\n                b = b+B[i]\\n        \\n        if len(a) != 2 or a != b[::-1]:\\n            return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, A, B):\\n        if len(A) != len(B):\\n            return False\\n        a=b=\\'\\'\\n        if A==B:\\n            return len(set(A))<len(A)\\n        for i in range(len(A)):\\n            if A[i] != B[i]:\\n                a = a+A[i]\\n                b = b+B[i]\\n        \\n        if len(a) != 2 or a != b[::-1]:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 173578,
                "title": "a-simple-c-solution-runtime-beats-100-00-accepted",
                "content": "```\\nbool buddyStrings(char* A, char* B) {\\n    int Alen=strlen(A);\\n    int Blen=strlen(B);\\n    int map[26]={0};\\n    if(Alen!=Blen||Alen<2||Blen<2){\\n        return false;\\n    }\\n    char array[2][2]={0};\\n    int count=0;\\n    for(int i=0;i<Alen;i++){\\n        map[A[i]-\\'a\\']++;\\n        if(A[i]!=B[i]){\\n            if(count>=2){\\n                return false;\\n            }\\n            array[count][0]=A[i];\\n            array[count][1]=B[i];\\n            count++;\\n        }\\n    }\\n    if(count==0){\\n        for(int i=0;i<26;i++){\\n            if(map[i]>1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    if(array[0][0]==array[1][1]&&array[1][0]==array[0][1]){\\n        return true;\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool buddyStrings(char* A, char* B) {\\n    int Alen=strlen(A);\\n    int Blen=strlen(B);\\n    int map[26]={0};\\n    if(Alen!=Blen||Alen<2||Blen<2){\\n        return false;\\n    }\\n    char array[2][2]={0};\\n    int count=0;\\n    for(int i=0;i<Alen;i++){\\n        map[A[i]-\\'a\\']++;\\n        if(A[i]!=B[i]){\\n            if(count>=2){\\n                return false;\\n            }\\n            array[count][0]=A[i];\\n            array[count][1]=B[i];\\n            count++;\\n        }\\n    }\\n    if(count==0){\\n        for(int i=0;i<26;i++){\\n            if(map[i]>1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    if(array[0][0]==array[1][1]&&array[1][0]==array[0][1]){\\n        return true;\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165597,
                "title": "2-line-scala-solution",
                "content": "```\\ndef buddyStrings(A: String, B: String): Boolean = {\\n    val abDiff = A.zip(B).filter(ab => ab._1 != ab._2).map(ab => ab._1.toString + ab._2).mkString(\"\")\\n    (abDiff.isEmpty && A != A.distinct) || (abDiff.size == 4 && abDiff == abDiff.reverse)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndef buddyStrings(A: String, B: String): Boolean = {\\n    val abDiff = A.zip(B).filter(ab => ab._1 != ab._2).map(ab => ab._1.toString + ab._2).mkString(\"\")\\n    (abDiff.isEmpty && A != A.distinct) || (abDiff.size == 4 && abDiff == abDiff.reverse)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 142089,
                "title": "naive-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        if (A.length() != B.length())   return false;\\n        \\n        if (A.equals(B)) {\\n            Set<Character> set = new HashSet();\\n            for (char ch : A.toCharArray()) set.add(ch);\\n            return set.size() < A.length();\\n        }\\n        \\n        List<Integer> diff = new ArrayList();\\n        \\n        for (int i = 0; i < A.length(); i++) {\\n            if (A.charAt(i) != B.charAt(i)) {\\n                diff.add(i);\\n                if (diff.size() > 2)    return false;\\n            }\\n        }\\n        \\n        return diff.size() == 2 && \\n            A.charAt(diff.get(0)) == B.charAt(diff.get(1)) && \\n            A.charAt(diff.get(1)) == B.charAt(diff.get(0));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        if (A.length() != B.length())   return false;\\n        \\n        if (A.equals(B)) {\\n            Set<Character> set = new HashSet();\\n            for (char ch : A.toCharArray()) set.add(ch);\\n            return set.size() < A.length();\\n        }\\n        \\n        List<Integer> diff = new ArrayList();\\n        \\n        for (int i = 0; i < A.length(); i++) {\\n            if (A.charAt(i) != B.charAt(i)) {\\n                diff.add(i);\\n                if (diff.size() > 2)    return false;\\n            }\\n        }\\n        \\n        return diff.size() == 2 && \\n            A.charAt(diff.get(0)) == B.charAt(diff.get(1)) && \\n            A.charAt(diff.get(1)) == B.charAt(diff.get(0));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141992,
                "title": "python",
                "content": "\\u601D\\u8DEF\\u662F\\u627E\\u5230\\u5BF9\\u5E94Index\\u7684mismatch\\uFF0C\\u7136\\u540E\\u5BF9Str1\\u6362\\u4F4D\\u7F6E\\uFF0C\\u5728\\u548CStr2\\u8FDB\\u884C\\u6BD4\\u8F83\\u3002\\u76F8\\u7B49\\u5219\\u8FD4\\u56DETrue\\n\\n\\u9700\\u8981\\u6CE8\\u610F\\u7684Edge Case\\u6BD4\\u5982\\uFF1A\\n```\\nstr1 = \\'ab\\' \\nstr2 = \\'ab\\'\\n```\\n\\u8FD9\\u79CD\\u867D\\u7136str1\\u548Cstr2\\u5BF9\\u7B49\\uFF0C\\u7136\\u5E76\\u6CA1\\u5375\\uFF0C\\u56E0\\u4E3A\\u5B9E\\u9645\\u4E0A\\u5E76\\u6CA1\\u6709\\u79FB\\u4F4D\\uFF0C\\u518D\\u770B\\u770B\\u4E0B\\u9762\\u53E6\\u4E00\\u4E2AEdge Case\\n\\n```\\nstr1 = \\'abab\\'\\nstr2 = \\'abab\\'\\n```\\n\\u8FD9\\u79CD\\u4E24\\u4E2AString\\u5BF9\\u7B49\\uFF0C\\u4F46\\u5176\\u4E2D\\u5982\\u679C\\u4E24\\u4E2Aa\\u7684\\u4F4D\\u7F6E\\u5BF9\\u8C03\\uFF0C\\u7B54\\u6848\\u4E5F\\u6210\\u7ACB\\u5E76\\u8FD4\\u56DETrue\\n\\n\\u6700\\u7EC8\\u7528\\u4E86\\u4E00\\u4E2A\\u7EFC\\u5408\\u65B9\\u6CD5\\u5904\\u7406\\u4E86\\u4E0A\\u8FF0\\u4E24\\u79CD\\u7684Edge\\uFF0C\\u8FD0\\u7528Python\\u91CC\\u9762\\u7684Set\\n```\\nif str1 == str2: \\n    return len(set(str1)) < len(str1)\\n```\\n1. \\u5982\\u679CSet\\u957F\\u5EA6\\u5BF9\\u7B49String\\u539F\\u957F\\u5EA6\\uFF0C\\u5219\\u8868\\u660EString\\u91CC\\u9762\\u6CA1\\u6709\\u91CD\\u590D\\u5B57\\u7B26\\uFF0C\\u5C31\\u5982Edge Case\\u91CC\\u9762\\u7684ab\\uFF0C\\u8FD9\\u79CD\\u65F6\\u5019\\u8FD4\\u56DEFalse\\n2. \\u5982\\u679CSet\\u957F\\u5EA6\\u5C0F\\u4E8EString\\u5143\\u957F\\u5EA6\\uFF0C\\u90A3\\u5C31\\u662FEdge Case2\\u8FD9\\u79CD\\uFF0C\\u8FD4\\u56DETrue\\n\\n\\u5269\\u4E0B\\u7684\\u5C31\\u662F\\u6362\\u6362\\u4F4D\\u7F6E\\uFF0C\\u4E0D\\u591A\\u8BB2\\u4E86\\u3002\\n\\n\\n```\\nclass Solution:\\n    def buddyStrings(self, str1, str2):\\n        \"\"\"\\n        Grab index where there is a mismatch, return the string comparison after reversing\\n        Time O(N)\\n        Space O(1) \\n        :rtype: bool\\n        \"\"\"\\n        if len(str1) != len(str2):\\n            return False\\n        if str1 == str2:\\n            return len(set(str1)) < len(str1)\\n\\n        arr = []\\n        for i, char in enumerate(str1):\\n            if char != str2[i]:\\n                arr.append(i)\\n        \\n        l = list(str1)\\n        l[arr[0]], l[arr[1]] = l[arr[1]], l[arr[0]]\\n        return \\'\\'.join(l) == str2\\n```",
                "solutionTags": [],
                "code": "```\\nstr1 = \\'ab\\' \\nstr2 = \\'ab\\'\\n```\n```\\nstr1 = \\'abab\\'\\nstr2 = \\'abab\\'\\n```\n```\\nif str1 == str2: \\n    return len(set(str1)) < len(str1)\\n```\n```\\nclass Solution:\\n    def buddyStrings(self, str1, str2):\\n        \"\"\"\\n        Grab index where there is a mismatch, return the string comparison after reversing\\n        Time O(N)\\n        Space O(1) \\n        :rtype: bool\\n        \"\"\"\\n        if len(str1) != len(str2):\\n            return False\\n        if str1 == str2:\\n            return len(set(str1)) < len(str1)\\n\\n        arr = []\\n        for i, char in enumerate(str1):\\n            if char != str2[i]:\\n                arr.append(i)\\n        \\n        l = list(str1)\\n        l[arr[0]], l[arr[1]] = l[arr[1]], l[arr[0]]\\n        return \\'\\'.join(l) == str2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141769,
                "title": "a-few-solutions",
                "content": "If `|s| != |t|` (ie. the cardinality of `s` != the cardinality of `t`), then it is *impossible* for `s == t` with one swap, thus we return `false` immediately.\\n\\nIf `s == t`, then we *must* have an \"auxillary\" (same character) we can swap, thus we return `true` if-and-only-if the cardinality of the **set** of characters from each input string is *strictly less-than* the cardinality of characters from each input string correspondingly.\\n\\nOtherwise, we perform a linear scan of the input strings source `s` and target `t` using the array `I` to store each index `i` where `s[i] != t[i]`.  Return `true` if-and-only-if there are two indices `i`which can be swapped such that `s == t`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun buddyStrings(s: String, t: String): Boolean {\\n        if (s.length != t.length)\\n            return false\\n        if (s == t)\\n            return s.toCharArray().toSet().size < s.length && t.toCharArray().toSet().size < t.length\\n        var I = mutableListOf<Int>()\\n        for (i in 0 until s.length)\\n            if (s[i] != t[i])\\n                I.add(i)\\n        return I.size == 2 && s[I[0]] == t[I[1]] && s[I[1]] == t[I[0]]\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet buddyStrings = (s, t) => {\\n    if (s.length != t.length)\\n        return false;\\n    s = s.split(\\'\\');\\n    t = t.split(\\'\\');\\n    if (s.join(\\'\\') == t.join(\\'\\'))\\n        return new Set(s).size < s.length && new Set(t).size < t.length;\\n    let I = _.zip((s, t)).map((_, i) => s[i] != t[i] ? i : -1).filter(i => 0 <= i);\\n    return I.length == 2 && s[I[0]] == t[I[1]] && s[I[1]] == t[I[0]];\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        if s == t:\\n            return len(set(s)) < len(s) and len(set(t)) < len(t)\\n        I = [i for i in range(len(s)) if s[i] != t[i]]\\n        return len(I) == 2 and s[I[0]] == t[I[1]] and s[I[1]] == t[I[0]]\\n```\\n\\n*Rust*\\n```\\ntype VC = Vec<char>;\\nuse std::collections::HashSet;\\ntype Set = HashSet<char>;\\nimpl Solution {\\n    pub fn buddy_strings(s: String, t: String) -> bool {\\n        let s = s.chars().collect::<VC>();\\n        let t = t.chars().collect::<VC>();\\n        if s.len() != t.len() {\\n            return false;\\n        }\\n        if s == t {\\n            return s.clone().into_iter().collect::<Set>().len() < s.len() && t.clone().into_iter().collect::<Set>().len() < t.len();\\n        }\\n        let mut I = vec![];\\n        for i in 0..s.len() {\\n            if s[i] != t[i] {\\n                I.push(i);\\n            }\\n        }\\n        I.len() == 2 && s[I[0]] == t[I[1]] && s[I[1]] == t[I[0]]\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = unordered_set<char>;\\n    bool buddyStrings(string s, string t, VI I = {}) {\\n        if (s.size() != t.size())\\n            return false;\\n        if (s == t)\\n            return Set{ s.begin(), s.end() }.size() < s.size() && Set{ t.begin(), t.end() }.size() < t.size();\\n        for (auto i{ 0 }; i < s.size(); ++i)\\n            if (s[i] != t[i])\\n                I.push_back(i);\\n        return I.size() == 2 && s[I[0]] == t[I[1]] && s[I[1]] == t[I[0]];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun buddyStrings(s: String, t: String): Boolean {\\n        if (s.length != t.length)\\n            return false\\n        if (s == t)\\n            return s.toCharArray().toSet().size < s.length && t.toCharArray().toSet().size < t.length\\n        var I = mutableListOf<Int>()\\n        for (i in 0 until s.length)\\n            if (s[i] != t[i])\\n                I.add(i)\\n        return I.size == 2 && s[I[0]] == t[I[1]] && s[I[1]] == t[I[0]]\\n    }\\n}\\n```\n```\\nlet buddyStrings = (s, t) => {\\n    if (s.length != t.length)\\n        return false;\\n    s = s.split(\\'\\');\\n    t = t.split(\\'\\');\\n    if (s.join(\\'\\') == t.join(\\'\\'))\\n        return new Set(s).size < s.length && new Set(t).size < t.length;\\n    let I = _.zip((s, t)).map((_, i) => s[i] != t[i] ? i : -1).filter(i => 0 <= i);\\n    return I.length == 2 && s[I[0]] == t[I[1]] && s[I[1]] == t[I[0]];\\n};\\n```\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        if s == t:\\n            return len(set(s)) < len(s) and len(set(t)) < len(t)\\n        I = [i for i in range(len(s)) if s[i] != t[i]]\\n        return len(I) == 2 and s[I[0]] == t[I[1]] and s[I[1]] == t[I[0]]\\n```\n```\\ntype VC = Vec<char>;\\nuse std::collections::HashSet;\\ntype Set = HashSet<char>;\\nimpl Solution {\\n    pub fn buddy_strings(s: String, t: String) -> bool {\\n        let s = s.chars().collect::<VC>();\\n        let t = t.chars().collect::<VC>();\\n        if s.len() != t.len() {\\n            return false;\\n        }\\n        if s == t {\\n            return s.clone().into_iter().collect::<Set>().len() < s.len() && t.clone().into_iter().collect::<Set>().len() < t.len();\\n        }\\n        let mut I = vec![];\\n        for i in 0..s.len() {\\n            if s[i] != t[i] {\\n                I.push(i);\\n            }\\n        }\\n        I.len() == 2 && s[I[0]] == t[I[1]] && s[I[1]] == t[I[0]]\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = unordered_set<char>;\\n    bool buddyStrings(string s, string t, VI I = {}) {\\n        if (s.size() != t.size())\\n            return false;\\n        if (s == t)\\n            return Set{ s.begin(), s.end() }.size() < s.size() && Set{ t.begin(), t.end() }.size() < t.size();\\n        for (auto i{ 0 }; i < s.size(); ++i)\\n            if (s[i] != t[i])\\n                I.push_back(i);\\n        return I.size() == 2 && s[I[0]] == t[I[1]] && s[I[1]] == t[I[0]];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045040,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length() != goal.length()) return false;\\n\\n        int diff = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) != goal.charAt(i)) diff++;\\n        }\\n\\n        System.out.print(diff);\\n        if(diff == 2) {\\n            int firstIndex = 0;\\n            int secondIndex = 0;\\n\\n            for(int i = 0; i < s.length(); i++) {\\n                if(s.charAt(i) != goal.charAt(i)) {\\n                    firstIndex = i; break;\\n                } \\n            }\\n\\n            for(int i = s.length() - 1; i >= 0; i--) {\\n                if(s.charAt(i) != goal.charAt(i)) {\\n                    secondIndex = i; break;\\n                } \\n            }\\n\\n            if(s.charAt(secondIndex) == goal.charAt(firstIndex) && s.charAt(firstIndex) == goal.charAt(secondIndex)) {\\n                System.out.print(\"first\");\\n                return true;\\n            } \\n        }\\n\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < s.length(); i++) set.add(s.charAt(i));\\n\\n        if(diff == 0 && s.length() != set.size()) {\\n            System.out.print(\"second\");\\n            return true;\\n        }\\n\\n        System.out.print(\"third\");\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length() != goal.length()) return false;\\n\\n        int diff = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) != goal.charAt(i)) diff++;\\n        }\\n\\n        System.out.print(diff);\\n        if(diff == 2) {\\n            int firstIndex = 0;\\n            int secondIndex = 0;\\n\\n            for(int i = 0; i < s.length(); i++) {\\n                if(s.charAt(i) != goal.charAt(i)) {\\n                    firstIndex = i; break;\\n                } \\n            }\\n\\n            for(int i = s.length() - 1; i >= 0; i--) {\\n                if(s.charAt(i) != goal.charAt(i)) {\\n                    secondIndex = i; break;\\n                } \\n            }\\n\\n            if(s.charAt(secondIndex) == goal.charAt(firstIndex) && s.charAt(firstIndex) == goal.charAt(secondIndex)) {\\n                System.out.print(\"first\");\\n                return true;\\n            } \\n        }\\n\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < s.length(); i++) set.add(s.charAt(i));\\n\\n        if(diff == 0 && s.length() != set.size()) {\\n            System.out.print(\"second\");\\n            return true;\\n        }\\n\\n        System.out.print(\"third\");\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722422,
                "title": "no-map-just-simple-logic",
                "content": "\\n# Approach\\nThere is only **ONE** main approach which will solve the entire question that is ***If there is any duplicate in string \"s\" then check for that ,*** otherwise ***Use two pointer in a simple manner***.\\n\\n# Explained the Code with comments!\\n\\n\\n```\\nclass Solution {\\npublic:\\nbool checkDuplicate(string &s)\\n{\\n    int CountOfEachCharacter[26] = {0}; // let count of all element is 0\\n    for(auto &it : s)\\n    {\\n        CountOfEachCharacter[it-\\'a\\']++; // Add the count of each character\\n        if(CountOfEachCharacter[it-\\'a\\'] > 1) // If any element have more than one count, it implies we have a duplicate\\n            return true;\\n    }\\n    return false; // No duplicate found\\n}\\n    bool buddyStrings(string s, string goal) {\\n        if(s.length() != goal.length()) return false; // If the length of both strings are not same , then fasle;\\n\\n        if(s == goal){  // if both strings are identical i.e abab and abab\\n            return checkDuplicate(s);\\n        }\\n        vector<int> index; // To contain the index of elements to be swapped \\n        int count = 0;\\n        for(int i = 0 ; i < s.length() ; i++)\\n        {\\n            if(s[i] != goal[i])\\n                index.push_back(i),count++;  // Store the index of element where ele are not same like s= abc and goal= acb\\n                                        // now element at index at 1 and 2 are not same , so we will store them \\n            if(count > 2)\\n                break;\\n        }\\n        if(index.size() != 2)  // If there are more than 2 elements to swap we will return false,as only 1 swap is allowed     \\n            return false; \\n        swap(s[index[0]],s[index[1]]); // Swap those elements .. i.e s = acb ( swapped b and c)\\n        return s == goal; // check if s == goal  i.e acb == acb , return true. if not same then return false\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool checkDuplicate(string &s)\\n{\\n    int CountOfEachCharacter[26] = {0}; // let count of all element is 0\\n    for(auto &it : s)\\n    {\\n        CountOfEachCharacter[it-\\'a\\']++; // Add the count of each character\\n        if(CountOfEachCharacter[it-\\'a\\'] > 1) // If any element have more than one count, it implies we have a duplicate\\n            return true;\\n    }\\n    return false; // No duplicate found\\n}\\n    bool buddyStrings(string s, string goal) {\\n        if(s.length() != goal.length()) return false; // If the length of both strings are not same , then fasle;\\n\\n        if(s == goal){  // if both strings are identical i.e abab and abab\\n            return checkDuplicate(s);\\n        }\\n        vector<int> index; // To contain the index of elements to be swapped \\n        int count = 0;\\n        for(int i = 0 ; i < s.length() ; i++)\\n        {\\n            if(s[i] != goal[i])\\n                index.push_back(i),count++;  // Store the index of element where ele are not same like s= abc and goal= acb\\n                                        // now element at index at 1 and 2 are not same , so we will store them \\n            if(count > 2)\\n                break;\\n        }\\n        if(index.size() != 2)  // If there are more than 2 elements to swap we will return false,as only 1 swap is allowed     \\n            return false; \\n        swap(s[index[0]],s[index[1]]); // Swap those elements .. i.e s = acb ( swapped b and c)\\n        return s == goal; // check if s == goal  i.e acb == acb , return true. if not same then return false\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720425,
                "title": "python-solution",
                "content": "# Approach\\nIn the question, the condition was that only two letters will be swapped to get the goal string.\\n\\nFirst step is to get the index positions where the string \\'s\\' is not equal to \\'goal\\' string.\\n\\nIf the no.of index positions received was greater than 1, then we should swap those positions in s and compare the result with the goal. If they were equal we should return True, else False.\\neg: s=\"abcd\", goal=\"cbad\", index pos = [0,2]\\n\\nIf only letter in \\'s\\' is not equal to \\'goal\\', then there\\'s no possibility to swap. So we should return False.\\neg: s=\"abcd\", goal=\"abce\", index pos = [3]\\n\\nIf \\'s\\' is equal to \\'goal\\' and if one of the letters in \\'s\\' is repeated more than once, then there\\'s a possibility for swapping those same letters. So we should return True.\\neg: s=\"abad\", goal=\"abad\", s[0] & s[2] can be swapped\\n\\nIf \\'s\\' is equal to \\'goal\\' and there is no characters repeated in \\'s\\', then we should return False.\\neg: s=\"abcd\", goal=\"abcd\", result = False\\n\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def buddyStrings(self, s, goal):\\n        ind = []\\n\\n        for x in range(len(s)):\\n            if s[x]!=goal[x]:\\n                ind.append(x)\\n\\n        if ind:\\n            s = list(s)\\n            \\n            if len(ind)>1:\\n                s[ind[0]],s[ind[1]]=s[ind[1]],s[ind[0]]\\n                s = \"\".join(s)\\n                \\n                if s==goal:\\n                    return (True)\\n                else:\\n                    return False\\n            else:\\n                return False\\n\\n        elif s==goal:\\n            for x in s:\\n                if s.count(x)>1:\\n                    return (True)\\n            else:\\n                return False\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def buddyStrings(self, s, goal):\\n        ind = []\\n\\n        for x in range(len(s)):\\n            if s[x]!=goal[x]:\\n                ind.append(x)\\n\\n        if ind:\\n            s = list(s)\\n            \\n            if len(ind)>1:\\n                s[ind[0]],s[ind[1]]=s[ind[1]],s[ind[0]]\\n                s = \"\".join(s)\\n                \\n                if s==goal:\\n                    return (True)\\n                else:\\n                    return False\\n            else:\\n                return False\\n\\n        elif s==goal:\\n            for x in s:\\n                if s.count(x)>1:\\n                    return (True)\\n            else:\\n                return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714750,
                "title": "java-solution-of-naresh-gupta-sir",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length() != goal.length()) return false;\\n        if(s.equals(goal)){\\n            Set<Character> st = new HashSet<>();\\n            for(char c : s.toCharArray()){\\n                if(st.contains(c)) return true;\\n                st.add(c);\\n            }\\n            return false;\\n        }\\n        else {\\n            List<Integer> al = new ArrayList<>();\\n            for(int i = 0; i<s.length();i++){\\n                if(s.charAt(i) != goal.charAt(i)) al.add(i);\\n            }\\n            return al.size() == 2 && s.charAt(al.get(0)) == goal.charAt(al.get(1)) && s.charAt(al.get(1)) == goal.charAt(al.get(0));\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length() != goal.length()) return false;\\n        if(s.equals(goal)){\\n            Set<Character> st = new HashSet<>();\\n            for(char c : s.toCharArray()){\\n                if(st.contains(c)) return true;\\n                st.add(c);\\n            }\\n            return false;\\n        }\\n        else {\\n            List<Integer> al = new ArrayList<>();\\n            for(int i = 0; i<s.length();i++){\\n                if(s.charAt(i) != goal.charAt(i)) al.add(i);\\n            }\\n            return al.size() == 2 && s.charAt(al.get(0)) == goal.charAt(al.get(1)) && s.charAt(al.get(1)) == goal.charAt(al.get(0));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714714,
                "title": "99-98-java-easiest-solution",
                "content": "```\\nclass Solution {\\n    \\n    public boolean buddyStrings(String s, String goal) {\\n        if (s.length() != goal.length()) {\\n            return false;\\n        }\\n\\n        if (s.equals(goal)) {\\n            HashSet<Character> set = new HashSet<>();\\n            for (char c: s.toCharArray()) {\\n                if (!set.add(c)) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n\\n        int dif = 0;\\n        Character swapS = null;\\n        Character swapG = null;\\n        for (int i = 0; i < s.length(); i++) {\\n            char sChar = s.charAt(i);\\n            char gChar = goal.charAt(i);\\n            if (sChar != gChar) {\\n                if (dif == 2 || (dif == 1 && (swapS != gChar || swapG != sChar))) {\\n                    return false;\\n                }\\n                swapS = sChar;\\n                swapG = gChar;\\n                dif++;\\n            }\\n        }\\n        return dif == 2;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/427827f8-4195-4cf2-b126-469d43f1d508_1688420417.250366.png)\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public boolean buddyStrings(String s, String goal) {\\n        if (s.length() != goal.length()) {\\n            return false;\\n        }\\n\\n        if (s.equals(goal)) {\\n            HashSet<Character> set = new HashSet<>();\\n            for (char c: s.toCharArray()) {\\n                if (!set.add(c)) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n\\n        int dif = 0;\\n        Character swapS = null;\\n        Character swapG = null;\\n        for (int i = 0; i < s.length(); i++) {\\n            char sChar = s.charAt(i);\\n            char gChar = goal.charAt(i);\\n            if (sChar != gChar) {\\n                if (dif == 2 || (dif == 1 && (swapS != gChar || swapG != sChar))) {\\n                    return false;\\n                }\\n                swapS = sChar;\\n                swapG = gChar;\\n                dif++;\\n            }\\n        }\\n        return dif == 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714671,
                "title": "asked-by-google-microsoft-simple-approach-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length()!=goal.length()) return false;\\n        \\n        if(s.equals(goal)){\\n            HashMap<Character,Integer> hm = new HashMap<>();\\n            for(char ch : s.toCharArray()){\\n                hm.put(ch,hm.getOrDefault(ch,0)+1);\\n            }\\n            for(char ch:hm.keySet()){\\n                if(hm.get(ch)>1){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else{\\n            ArrayList<Integer> in = new ArrayList<>();\\n            for(int i=0;i<s.length();i++){\\n                char ch = s.charAt(i);\\n                char ch1 = goal.charAt(i);\\n                if(ch!= ch1 && hm.containsKey(ch1)) in.add(i);\\n            }\\n            if(in.size()==2){\\n                    //Checking by Swapping\\n                    StringBuilder s1 = new StringBuilder(s);\\n                    char ch2 = s1.charAt(in.get(0));\\n                    s1.setCharAt(in.get(0),s1.charAt(in.get(1)));\\n                    s1.setCharAt(in.get(1),ch2);\\n                    System.out.print(s1);\\n                    if(s1.toString().equals(goal)) return true;\\n            } \\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length()!=goal.length()) return false;\\n        \\n        if(s.equals(goal)){\\n            HashMap<Character,Integer> hm = new HashMap<>();\\n            for(char ch : s.toCharArray()){\\n                hm.put(ch,hm.getOrDefault(ch,0)+1);\\n            }\\n            for(char ch:hm.keySet()){\\n                if(hm.get(ch)>1){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else{\\n            ArrayList<Integer> in = new ArrayList<>();\\n            for(int i=0;i<s.length();i++){\\n                char ch = s.charAt(i);\\n                char ch1 = goal.charAt(i);\\n                if(ch!= ch1 && hm.containsKey(ch1)) in.add(i);\\n            }\\n            if(in.size()==2){\\n                    //Checking by Swapping\\n                    StringBuilder s1 = new StringBuilder(s);\\n                    char ch2 = s1.charAt(in.get(0));\\n                    s1.setCharAt(in.get(0),s1.charAt(in.get(1)));\\n                    s1.setCharAt(in.get(1),ch2);\\n                    System.out.print(s1);\\n                    if(s1.toString().equals(goal)) return true;\\n            } \\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714161,
                "title": "c-explanation-comments-in-code-beats-100",
                "content": "# \\u2728Approach\\n- We know it should return true if there is only one mismatch and can should be resolved by swapping the elements.\\n- and also if both string are same but have repeating characters in them.\\n\\n# \\u2728Code\\n```\\n\\n\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) \\n    {\\n       if(s.length()!=goal.length())\\n       return false; // not possible if lengths are not same\\n\\n       unordered_map<char,int> freq; // for counting frequency of char in strings\\n       vector<char> index; // \\n       int count = 0;\\n\\n       for(int i=0;i<s.length();i++)\\n       {\\n            freq[s[i]]++;\\n            freq[goal[i]]++;\\n           if(s[i]!=goal[i])\\n           {\\n            count++;\\n            if(count>2)\\n            return false;\\n            index.push_back(s[i]);\\n            index.push_back(goal[i]);\\n           }\\n       }\\n            if(index.size() >= 4 && index[0]==index[3] && index[1]==index[2]) // if 1st occurence in 1st string is same as 2nd occurence in 2nd string and if 2nd occurence in first string is same as 1st occurence in 2nd string\\n            return true;\\n            \\n            if(index.size() >= 4 && (index[0]!=index[3] || index[1]!=index[2] ))\\n            return false; // if there are more than equal to 2 mismatches but cannot be resolved by swapping\\n            \\n            int flag = 0;\\n            for(auto i:freq)\\n            {\\n                if(i.second%2!=0) // if occurence is not even means there is presence in and not the other\\n                return false;\\n\\n                if(i.second >= 4) // if there is repeating chars in string \\n                flag = 1;   \\n            }\\n\\n            if(flag==1)\\n            return true;\\n\\n       return false;\\n       }       \\n};\\n```\\n![tu2.gif](https://assets.leetcode.com/users/images/9c8afe91-6e0f-4e58-b9de-2004b92a3c3a_1688407815.1381857.gif)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) \\n    {\\n       if(s.length()!=goal.length())\\n       return false; // not possible if lengths are not same\\n\\n       unordered_map<char,int> freq; // for counting frequency of char in strings\\n       vector<char> index; // \\n       int count = 0;\\n\\n       for(int i=0;i<s.length();i++)\\n       {\\n            freq[s[i]]++;\\n            freq[goal[i]]++;\\n           if(s[i]!=goal[i])\\n           {\\n            count++;\\n            if(count>2)\\n            return false;\\n            index.push_back(s[i]);\\n            index.push_back(goal[i]);\\n           }\\n       }\\n            if(index.size() >= 4 && index[0]==index[3] && index[1]==index[2]) // if 1st occurence in 1st string is same as 2nd occurence in 2nd string and if 2nd occurence in first string is same as 1st occurence in 2nd string\\n            return true;\\n            \\n            if(index.size() >= 4 && (index[0]!=index[3] || index[1]!=index[2] ))\\n            return false; // if there are more than equal to 2 mismatches but cannot be resolved by swapping\\n            \\n            int flag = 0;\\n            for(auto i:freq)\\n            {\\n                if(i.second%2!=0) // if occurence is not even means there is presence in and not the other\\n                return false;\\n\\n                if(i.second >= 4) // if there is repeating chars in string \\n                flag = 1;   \\n            }\\n\\n            if(flag==1)\\n            return true;\\n\\n       return false;\\n       }       \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714157,
                "title": "different-approach-easy-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.length() != goal.size())return false;\\n        // now traversing the whole string and count the unmatched elements\\n        // if that count is eqauls to 2 then true otherwise false\\n        int count=0, trav=0;\\n        vector<int> v(26,0), g(26,0);\\n        set<char> ss;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] != goal[i]) trav++;\\n            v[s[i]-\\'a\\']++;\\n            g[goal[i]-\\'a\\']++;\\n            ss.insert(s[i]);\\n        }\\n        for(int i=0;i<26;i++){\\n            if(v[i] != g[i])\\n            count += abs(v[i]-g[i]);\\n        }\\n        if(count!=0)return false; // means all elements having same frequency\\n        if(s==goal){\\n            if(ss.size()<s.size())return true; // duplicate present\\n            return false;\\n        }\\n        else if(trav==2 || trav==0) return true; // exactly 2 swaps needed\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.length() != goal.size())return false;\\n        // now traversing the whole string and count the unmatched elements\\n        // if that count is eqauls to 2 then true otherwise false\\n        int count=0, trav=0;\\n        vector<int> v(26,0), g(26,0);\\n        set<char> ss;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] != goal[i]) trav++;\\n            v[s[i]-\\'a\\']++;\\n            g[goal[i]-\\'a\\']++;\\n            ss.insert(s[i]);\\n        }\\n        for(int i=0;i<26;i++){\\n            if(v[i] != g[i])\\n            count += abs(v[i]-g[i]);\\n        }\\n        if(count!=0)return false; // means all elements having same frequency\\n        if(s==goal){\\n            if(ss.size()<s.size())return true; // duplicate present\\n            return false;\\n        }\\n        else if(trav==2 || trav==0) return true; // exactly 2 swaps needed\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714125,
                "title": "python-short-and-clean-match-statement-functional-programming",
                "content": "# Approach\\n1. Iterate simultaneously through `s` and `goal` and select (`filter`) non matching pairs.\\n\\n2. If there are no such pairs, we can\\'t swap. Unless there is atleast one repeated character in the strings. This can be done by returning `len(set(s)) != len(s)`.\\n\\n3. If not any of the above case, return `False`.\\n\\n# Complexity\\n- Time complexity: $$O(max(n, m))$$\\n\\n- Space complexity: $$O(max(n, m))$$\\n\\nwhere,\\n`n is length of s`,\\n`m is length of goal`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        match tuple(filter(lambda pair: ne(*pair), zip_longest(s, goal))):\\n            case (): return len(set(s)) != len(s)\\n            case ((a1, b1), (a2, b2)): return (a1, b1) == (b2, a2)\\n            case other: return False\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```python\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        match tuple(filter(lambda pair: ne(*pair), zip_longest(s, goal))):\\n            case (): return len(set(s)) != len(s)\\n            case ((a1, b1), (a2, b2)): return (a1, b1) == (b2, a2)\\n            case other: return False\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714055,
                "title": "easy-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if (s.length() != goal.length())\\n            return false;\\n\\n        if (s.equals(goal)) {\\n            \\n            HashMap<Character, Integer> frequency = new HashMap<>();\\n            for (char c : s.toCharArray()) {\\n                frequency.put(c, frequency.getOrDefault(c, 0) + 1);\\n            }\\n\\n            for (int count : frequency.values()) {\\n                if (count >= 2)\\n                    return true;\\n            }\\n        }\\n\\n        int mismatchCount = 0;\\n        int firstIndex = -1;\\n        int secondIndex = -1;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) != goal.charAt(i)) {\\n                mismatchCount++;\\n\\n                if (mismatchCount > 2)\\n                    return false;\\n\\n                if (firstIndex == -1) {\\n                    firstIndex = i;\\n                } else {\\n                    secondIndex = i;\\n                }\\n            }\\n        }\\n\\n        if (mismatchCount == 2) {\\n            return (s.charAt(firstIndex) == goal.charAt(secondIndex))\\n                    && (s.charAt(secondIndex) == goal.charAt(firstIndex));\\n        }\\n\\n        return false;\\n    }\\n}\\n        \\n    \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if (s.length() != goal.length())\\n            return false;\\n\\n        if (s.equals(goal)) {\\n            \\n            HashMap<Character, Integer> frequency = new HashMap<>();\\n            for (char c : s.toCharArray()) {\\n                frequency.put(c, frequency.getOrDefault(c, 0) + 1);\\n            }\\n\\n            for (int count : frequency.values()) {\\n                if (count >= 2)\\n                    return true;\\n            }\\n        }\\n\\n        int mismatchCount = 0;\\n        int firstIndex = -1;\\n        int secondIndex = -1;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) != goal.charAt(i)) {\\n                mismatchCount++;\\n\\n                if (mismatchCount > 2)\\n                    return false;\\n\\n                if (firstIndex == -1) {\\n                    firstIndex = i;\\n                } else {\\n                    secondIndex = i;\\n                }\\n            }\\n        }\\n\\n        if (mismatchCount == 2) {\\n            return (s.charAt(firstIndex) == goal.charAt(secondIndex))\\n                    && (s.charAt(secondIndex) == goal.charAt(firstIndex));\\n        }\\n\\n        return false;\\n    }\\n}\\n        \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713961,
                "title": "python3-o-n-time-o-1-space-3-line-solution-short-and-dense",
                "content": "# Intuition\\nIt is as in the editorial, just condensed\\n\\n# Approach\\nExactly the same concept as editorial, but with slight changes in order and execution.\\nIf the lengths are different it must be false.\\nWe collect differences first instead of comparing string equivalence.\\n\\nAnother way to test equivalence is checking that differences equal 0. When that is true, the answer depends on duplicate letters. Instead of iterating, comparing to dictonary and storing, we compare set length to string length. Since sets don\\'t store duplicates, if duplicates are present it will be shorter. Credit to @RottenDoom for the set suggestion.\\n\\nThe only condition left to test for is that there are exactly 2 differences, and they are the reverse of each other. We test for this using slice with -1 increment to reverse one of them and check equivalence.\\n\\nJob done.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal): return False\\n        differences = [(s[i], goal[i]) for i in range(len(s)) if s[i] != goal[i]]\\n        return (len(differences) == 0 and len(set(s)) < len(s)) or (len(differences) == 2 and differences[0] ==  differences[1][::-1])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal): return False\\n        differences = [(s[i], goal[i]) for i in range(len(s)) if s[i] != goal[i]]\\n        return (len(differences) == 0 and len(set(s)) < len(s)) or (len(differences) == 2 and differences[0] ==  differences[1][::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713951,
                "title": "c-o-n-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size() != goal.size()) return false;\\n        if(s == goal && unordered_set<char>(s.begin(), s.end()).size() < s.size()) {\\n            return true;\\n        }\\n        unordered_map<char, int> a, b;\\n        for(auto i : s) a[i]++;\\n        for(auto i : goal) b[i]++;\\n\\n        int count = 0; // not_equal count\\n        for(int i = 0; i < s.size(); i++) {\\n            if(a[goal[i]] == 0 || b[s[i]] == 0) {\\n                return false;\\n            }\\n            if(s[i] != goal[i]) {\\n                count++;\\n                a[goal[i]]--;\\n                b[s[i]]--;\\n            }\\n            if(count > 2) return false;\\n        }\\n        return count == 2 ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size() != goal.size()) return false;\\n        if(s == goal && unordered_set<char>(s.begin(), s.end()).size() < s.size()) {\\n            return true;\\n        }\\n        unordered_map<char, int> a, b;\\n        for(auto i : s) a[i]++;\\n        for(auto i : goal) b[i]++;\\n\\n        int count = 0; // not_equal count\\n        for(int i = 0; i < s.size(); i++) {\\n            if(a[goal[i]] == 0 || b[s[i]] == 0) {\\n                return false;\\n            }\\n            if(s[i] != goal[i]) {\\n                count++;\\n                a[goal[i]]--;\\n                b[s[i]]--;\\n            }\\n            if(count > 2) return false;\\n        }\\n        return count == 2 ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713906,
                "title": "buddy-strings",
                "content": "**Approach I**\\n*Brute-Force: O(N^2)*\\n\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int n=s.length();\\n        // if(s==goal) return true;\\n        for(int i=0;i<n;i++)\\n        {\\n            string ss=s;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                swap(ss[i],ss[j]);\\n                if(ss==goal) return true; \\n                swap(ss[i],ss[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n**Approach II**\\n\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n         int n = s.length();\\n        if(s == goal){\\n            set<char> temp(s.begin(), s.end());\\n            return temp.size() < goal.size(); // Swapping same characters\\n        }\\n\\n        int i = 0;\\n        int j = n - 1;\\n\\n        while(i < j && s[i] == goal[i]){\\n            i++;\\n        }\\n\\n        while(j >= 0 && s[j] == goal[j]){\\n            j--;\\n        }\\n\\n        if(i < j){\\n            swap(s[i], s[j]);\\n        }\\n\\n        return s == goal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int n=s.length();\\n        // if(s==goal) return true;\\n        for(int i=0;i<n;i++)\\n        {\\n            string ss=s;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                swap(ss[i],ss[j]);\\n                if(ss==goal) return true; \\n                swap(ss[i],ss[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n         int n = s.length();\\n        if(s == goal){\\n            set<char> temp(s.begin(), s.end());\\n            return temp.size() < goal.size(); // Swapping same characters\\n        }\\n\\n        int i = 0;\\n        int j = n - 1;\\n\\n        while(i < j && s[i] == goal[i]){\\n            i++;\\n        }\\n\\n        while(j >= 0 && s[j] == goal[j]){\\n            j--;\\n        }\\n\\n        if(i < j){\\n            swap(s[i], s[j]);\\n        }\\n\\n        return s == goal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713903,
                "title": "keeping-track-of-previous-occurrences-of-goal-s-char-c-map-stack-tc-o-n-sc-o-n",
                "content": "# Intuition\\nThe problem requires checking whether two strings can be made equal by swapping two characters. To solve this, we can iterate over the strings and compare the characters at each position. If we find two positions i and j such that s[i] != goal[i] and s[j] != goal[j], and s[i] == goal[j] and s[j] == goal[i], then it is possible to swap two letters to make the strings equal.\\n\\n# Approach\\n1. Initialize an unordered map mp to store the characters of string s as keys and a stack of indices where each character occurs as values.\\n2. Initialize variables n and i to store the size of string s and initialize i as 0.\\n3. Iterate over the string s using a while loop until i reaches n.\\n4. If s[i] is not equal to goal[i], check if goal[i] exists in the map mp.\\n5. If it exists, swap s[i] with s[mp[goal[i]].top()] to perform the character swap.\\n6. Create a stack st and assign the stack of indices for the character goal[i] from the map mp.\\n7. While the stack st is not empty and s is still not equal to goal, perform the character swap by swapping s[i] with s[st.top()] and pop the top element of st.\\n8. Push the index i onto the stack for the character s[i] in the map mp.\\n9. Increment i by 1.\\n10. After the loop, check if s is equal to goal and the size of the map mp is less than n.\\n11. If both conditions are satisfied, return true; otherwise, return false.\\n\\n# Complexity\\n- Time complexity: The while loop iterates over the string s, resulting in a time complexity of O(n), where n is the length of the string.\\n- Space complexity: The space complexity is O(n), where n is the length of the string s, as we are using a map to store the characters and their indices.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        \\n        unordered_map<char,stack<int>> mp ;\\n        int n = s.size();\\n        int i=0;\\n        \\n        while(i<n){                \\n            if(s[i]!=goal[i]){\\n                if(mp.find(goal[i])!=mp.end()){\\n                    swap(s[i],s[mp[goal[i]].top()]);\\n                    stack<int> st = mp[goal[i]];\\n                    while(!st.empty() and s!=goal){\\n                        swap(s[i],s[st.top()]);\\n                        st.pop();\\n                    }\\n                }\\n            }\\n            mp[s[i]].push(i);\\n            i++;\\n        }\\n        if(s==goal and mp.size()<n) return true;\\n        return false;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        \\n        unordered_map<char,stack<int>> mp ;\\n        int n = s.size();\\n        int i=0;\\n        \\n        while(i<n){                \\n            if(s[i]!=goal[i]){\\n                if(mp.find(goal[i])!=mp.end()){\\n                    swap(s[i],s[mp[goal[i]].top()]);\\n                    stack<int> st = mp[goal[i]];\\n                    while(!st.empty() and s!=goal){\\n                        swap(s[i],s[st.top()]);\\n                        st.pop();\\n                    }\\n                }\\n            }\\n            mp[s[i]].push(i);\\n            i++;\\n        }\\n        if(s==goal and mp.size()<n) return true;\\n        return false;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713656,
                "title": "c-super-easy-clean-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int n = s.size();\\n        if(n != goal.size()) return false;\\n\\n        if(s == goal){\\n            int freq[26] = {0};\\n            for(int i=0; i<n; i++){\\n                freq[s[i]-\\'a\\']++;\\n            }\\n            for(int i=0; i<26; i++){\\n                if(freq[i] > 1) return true;\\n            }\\n            return false;\\n        }\\n\\n        int first = -1;\\n        int second = -1;\\n\\n        for(int i=0; i<n; i++){\\n            if(s[i] != goal[i]){\\n                second = first;\\n                first = i;\\n            }\\n            if(second > -1){\\n                swap(s[first],s[second]);\\n                break;\\n            }\\n        }\\n        if(first == -1 || second == -1) return false;\\n\\n        return s == goal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int n = s.size();\\n        if(n != goal.size()) return false;\\n\\n        if(s == goal){\\n            int freq[26] = {0};\\n            for(int i=0; i<n; i++){\\n                freq[s[i]-\\'a\\']++;\\n            }\\n            for(int i=0; i<26; i++){\\n                if(freq[i] > 1) return true;\\n            }\\n            return false;\\n        }\\n\\n        int first = -1;\\n        int second = -1;\\n\\n        for(int i=0; i<n; i++){\\n            if(s[i] != goal[i]){\\n                second = first;\\n                first = i;\\n            }\\n            if(second > -1){\\n                swap(s[first],s[second]);\\n                break;\\n            }\\n        }\\n        if(first == -1 || second == -1) return false;\\n\\n        return s == goal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713530,
                "title": "solution-python-easy-to-understand",
                "content": "# Intuition\\nThe problem description states that you need to swap exactly two characters in s to make it equal to goal.\\n\\n# Approach\\nIn the modified code, we handle the case where s and goal are equal separately. We also check for the condition where the lengths of s and goal are not equal, in which case it is not possible to make them equal through swaps.\\n\\nIf there are exactly two differing indices, we check if swapping the characters at those indices will make s equal to goal. If it does, we return True; otherwise, we return False.\\n\\n# Complexity\\n- Time complexity:\\nThe overall time complexity of the solution is O(n).\\n\\n- Space complexity:\\nThe space complexity of the solution is O(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def buddyStrings(self, s, goal):\\n        if s == goal:\\n            # Check if s and goal are equal\\n            # If they are, check if there are any repeated characters in s\\n            # If there are, we can swap two of them to make s equal to goal\\n            # Otherwise, we cannot make any swaps, so return False\\n            return len(set(s)) < len(s)\\n\\n        if len(s) != len(goal):\\n            # If the lengths of s and goal are not equal, we cannot make them equal through swaps\\n            return False\\n\\n        # Find the indices where s and goal differ\\n        indices = [i for i in range(len(s)) if s[i] != goal[i]]\\n\\n        # If there are exactly two differing indices, we can swap the characters at those indices\\n        if len(indices) == 2:\\n            i, j = indices\\n            if s[i] == goal[j] and s[j] == goal[i]:\\n                return True\\n\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def buddyStrings(self, s, goal):\\n        if s == goal:\\n            # Check if s and goal are equal\\n            # If they are, check if there are any repeated characters in s\\n            # If there are, we can swap two of them to make s equal to goal\\n            # Otherwise, we cannot make any swaps, so return False\\n            return len(set(s)) < len(s)\\n\\n        if len(s) != len(goal):\\n            # If the lengths of s and goal are not equal, we cannot make them equal through swaps\\n            return False\\n\\n        # Find the indices where s and goal differ\\n        indices = [i for i in range(len(s)) if s[i] != goal[i]]\\n\\n        # If there are exactly two differing indices, we can swap the characters at those indices\\n        if len(indices) == 2:\\n            i, j = indices\\n            if s[i] == goal[j] and s[j] == goal[i]:\\n                return True\\n\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713504,
                "title": "c-accepted-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public bool BuddyStrings(string s, string goal) {\\n        if(s.Length!=goal.Length)\\n            return false;\\n        // iterate over s\\n        // if diff put in dict\\n        // if dict is empty by the end check if there is repeated letters using hashset\\n        Dictionary<char,char> dict=new();\\n        HashSet<char> set=new();\\n        bool duplicates=false;\\n        for(int i=0;i<s.Length;i++){\\n            if(s[i]!=goal[i]){\\n                if(dict.Count>1)\\n                    return false;\\n                else if (dict.Count==1){\\n                    if(!dict.ContainsKey(s[i]))\\n                        return false;\\n                    if(dict[s[i]]!=goal[i])\\n                        return false;\\n                    dict[goal[i]]=s[i];\\n                }\\n                else{\\n                    dict[goal[i]]=s[i];\\n                }\\n            }\\n            if(set.Contains(s[i])){\\n                duplicates=true;\\n            }\\n            set.Add(s[i]);\\n        }\\n        return (dict.Count!=1) && (dict.Count>0 || duplicates) ? true:false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool BuddyStrings(string s, string goal) {\\n        if(s.Length!=goal.Length)\\n            return false;\\n        // iterate over s\\n        // if diff put in dict\\n        // if dict is empty by the end check if there is repeated letters using hashset\\n        Dictionary<char,char> dict=new();\\n        HashSet<char> set=new();\\n        bool duplicates=false;\\n        for(int i=0;i<s.Length;i++){\\n            if(s[i]!=goal[i]){\\n                if(dict.Count>1)\\n                    return false;\\n                else if (dict.Count==1){\\n                    if(!dict.ContainsKey(s[i]))\\n                        return false;\\n                    if(dict[s[i]]!=goal[i])\\n                        return false;\\n                    dict[goal[i]]=s[i];\\n                }\\n                else{\\n                    dict[goal[i]]=s[i];\\n                }\\n            }\\n            if(set.Contains(s[i])){\\n                duplicates=true;\\n            }\\n            set.Add(s[i]);\\n        }\\n        return (dict.Count!=1) && (dict.Count>0 || duplicates) ? true:false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713434,
                "title": "beats-100-easy-explanation-explained-line-by-line-comments",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        \\n        int count = 0; //counts the number of different characters\\n        int f_ind = -1, s_ind = -1; //stores first index and second index of different characters\\n        \\n        if(s.size()!=goal.size()) return false; //if the two strings are of unequal length, then no swapping can make them equal\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i])\\n            {\\n                count++;\\n                if(count>2) return false; //more than two different characters are present\\n                if(f_ind==-1) f_ind=i;\\n                else s_ind=i;\\n            }\\n        }\\n        \\n        if(count == 0){ //equal strings\\n            int freq[26] = {0};\\n            for(int i=0;i<s.size();i++){\\n                freq[s[i]-\\'a\\']++;\\n                if(freq[s[i]-\\'a\\']==2){\\n                    return true; //since we found two same elements which can be swapped\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        //only one unequal character is present which cannot be swapped with any other\\n        else if(count==1) \\n            return false;\\n        \\n        swap(s[f_ind], s[s_ind]);\\n        if(s==goal) return true;\\n        else return false;\\n        \\n    }\\n};\\n```\\n\\n\\n**P.S: Do give it an upvote if this helped! Feel free to comment below in case of any queries or suggestions :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        \\n        int count = 0; //counts the number of different characters\\n        int f_ind = -1, s_ind = -1; //stores first index and second index of different characters\\n        \\n        if(s.size()!=goal.size()) return false; //if the two strings are of unequal length, then no swapping can make them equal\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i])\\n            {\\n                count++;\\n                if(count>2) return false; //more than two different characters are present\\n                if(f_ind==-1) f_ind=i;\\n                else s_ind=i;\\n            }\\n        }\\n        \\n        if(count == 0){ //equal strings\\n            int freq[26] = {0};\\n            for(int i=0;i<s.size();i++){\\n                freq[s[i]-\\'a\\']++;\\n                if(freq[s[i]-\\'a\\']==2){\\n                    return true; //since we found two same elements which can be swapped\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        //only one unequal character is present which cannot be swapped with any other\\n        else if(count==1) \\n            return false;\\n        \\n        swap(s[f_ind], s[s_ind]);\\n        if(s==goal) return true;\\n        else return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713399,
                "title": "simple-c-solution-using-constant-space",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int count =  0;\\n        unordered_map<int,int>m1, m2;\\n        if(s.length() != goal.length())\\n            return 0;\\n        if(s == goal)\\n        {\\n            for(int i = 0 ; i < s.length() ; i++)\\n            {\\n                m1[s[i]]++;\\n                if(m1[s[i]] >=2)\\n                    return 1;\\n            }\\n            return 0;\\n        }\\n        else\\n        {\\n            for(int i = 0 ; i < s.length(); i++)\\n            {\\n                if(s[i] != goal[i])\\n                {\\n                    count++;\\n                    if(count > 2)\\n                        return 0;\\n                    m2[goal[i]]++;\\n                    m1[s[i]]++;\\n                }\\n            }\\n            for(auto i = m1.begin() ; i != m1.end() ; i++)\\n            {\\n                if(m2.find(i->first) == m2.end())\\n                    return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int count =  0;\\n        unordered_map<int,int>m1, m2;\\n        if(s.length() != goal.length())\\n            return 0;\\n        if(s == goal)\\n        {\\n            for(int i = 0 ; i < s.length() ; i++)\\n            {\\n                m1[s[i]]++;\\n                if(m1[s[i]] >=2)\\n                    return 1;\\n            }\\n            return 0;\\n        }\\n        else\\n        {\\n            for(int i = 0 ; i < s.length(); i++)\\n            {\\n                if(s[i] != goal[i])\\n                {\\n                    count++;\\n                    if(count > 2)\\n                        return 0;\\n                    m2[goal[i]]++;\\n                    m1[s[i]]++;\\n                }\\n            }\\n            for(auto i = m1.begin() ; i != m1.end() ; i++)\\n            {\\n                if(m2.find(i->first) == m2.end())\\n                    return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713283,
                "title": "beginner-friendly-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) \\n    {\\n        if(s.size()!=goal.size())\\n        {\\n            return false;\\n        }\\n\\n        if(s==goal)\\n        {\\n            sort(s.begin(),s.end());\\n            for(int i=0;i<s.size()-1;i++)\\n            {\\n                if(s[i]==s[i+1])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    \\n        int n=s.size();\\n        int i = 0;\\n        int j = n - 1;\\n\\n        while(i < j && s[i] == goal[i])\\n        {\\n            i++;\\n        }\\n\\n        while(j >= 0 && s[j] == goal[j])\\n        {\\n            j--;\\n        }\\n\\n        if(i < j)\\n        {\\n            swap(s[i], s[j]);\\n        }\\n\\n        return s == goal;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) \\n    {\\n        if(s.size()!=goal.size())\\n        {\\n            return false;\\n        }\\n\\n        if(s==goal)\\n        {\\n            sort(s.begin(),s.end());\\n            for(int i=0;i<s.size()-1;i++)\\n            {\\n                if(s[i]==s[i+1])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    \\n        int n=s.size();\\n        int i = 0;\\n        int j = n - 1;\\n\\n        while(i < j && s[i] == goal[i])\\n        {\\n            i++;\\n        }\\n\\n        while(j >= 0 && s[j] == goal[j])\\n        {\\n            j--;\\n        }\\n\\n        if(i < j)\\n        {\\n            swap(s[i], s[j]);\\n        }\\n\\n        return s == goal;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713059,
                "title": "simple-c-solution-string-easy-to-understand-video-solution",
                "content": "# Video solution \\n\\nhttps://youtu.be/5FzWI6avR-A\\n\\n# Intuition\\nWe have to check for some cases which can give us correct answer.\\n\\n# Approach\\n1. Case 1: **If both string s and goal are equal**\\n    Answer is possible only when any character in s or goal is repeated. So for this we inserted all character in set of char and if the size of set is less than size of string then we will get our answer as true. Else answer is false.\\n\\n2. Case 2: **Size of both string different**:\\n    In this case answer is not possible. So return false;\\n3. Case 3: **Rest cases:**\\n    There should be only two posistions such that char at both the position is different. If we have more than two such positions or less than two position answer will be ```false``` else ```true```\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n**Please upvote if you liked!!!**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s==goal){\\n            set<char>st;\\n            for(auto ele:s){\\n                st.insert(ele);\\n            }\\n            return (st.size()!=s.size());\\n        }\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int cnt=0;\\n        for(int i=0;i<s.size();i++){\\n            cnt+=(s[i]!=goal[i]);\\n        }\\n        if(cnt!=2){\\n            return false;\\n        }\\n        int ind1=-1,ind2=-1;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i]){\\n                ind1=i;\\n                break;\\n            }\\n        }\\n        for(int i=ind1+1;i<s.size();i++){\\n            if(s[i]!=goal[i]){\\n                ind2=i;\\n                break;\\n            }\\n        }\\n        swap(s[ind1],s[ind2]);\\n        return s==goal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```false```\n```true```\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s==goal){\\n            set<char>st;\\n            for(auto ele:s){\\n                st.insert(ele);\\n            }\\n            return (st.size()!=s.size());\\n        }\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int cnt=0;\\n        for(int i=0;i<s.size();i++){\\n            cnt+=(s[i]!=goal[i]);\\n        }\\n        if(cnt!=2){\\n            return false;\\n        }\\n        int ind1=-1,ind2=-1;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i]){\\n                ind1=i;\\n                break;\\n            }\\n        }\\n        for(int i=ind1+1;i<s.size();i++){\\n            if(s[i]!=goal[i]){\\n                ind2=i;\\n                break;\\n            }\\n        }\\n        swap(s[ind1],s[ind2]);\\n        return s==goal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712949,
                "title": "kotlin-simple-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThere are 4 cases.\\n\\n1. When string s and goal has different length -> We cannot make string s like goal with just swap, return false.\\n\\n2. When s and goal has more than 2 diffrence -> We cannot make string s like goal with just swap, return false.\\n\\n3. When s and goal is same string -> If there are more than one duplicate char in s, we can swap them. so, return duplicate or not.\\n\\n4. When s and goal has only one diffrence -> swap it. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    fun buddyStrings(s: String, goal: String): Boolean {\\n        if (s.length != goal.length) {\\n            return false\\n        }\\n\\n        val charSet = HashSet<Char>(26)\\n\\n        var diffIndex = -1\\n        var hasDuplicate = false\\n\\n        var i = 0\\n\\n        while (i < s.length) {\\n            if (s[i] != goal[i]) {\\n                if (diffIndex == -1) {\\n                    diffIndex = i\\n                } else {\\n                    if (s[diffIndex] == goal[i] && s[i] == goal[diffIndex]) {\\n                        i++\\n                        return s.substring(i) == goal.substring(i)\\n                    }\\n                    return false\\n                }\\n            }\\n            if (!charSet.add(s[i])) {\\n                hasDuplicate = true\\n            }\\n            i++\\n        }\\n\\n        return diffIndex == -1 && hasDuplicate\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    \\n    fun buddyStrings(s: String, goal: String): Boolean {\\n        if (s.length != goal.length) {\\n            return false\\n        }\\n\\n        val charSet = HashSet<Char>(26)\\n\\n        var diffIndex = -1\\n        var hasDuplicate = false\\n\\n        var i = 0\\n\\n        while (i < s.length) {\\n            if (s[i] != goal[i]) {\\n                if (diffIndex == -1) {\\n                    diffIndex = i\\n                } else {\\n                    if (s[diffIndex] == goal[i] && s[i] == goal[diffIndex]) {\\n                        i++\\n                        return s.substring(i) == goal.substring(i)\\n                    }\\n                    return false\\n                }\\n            }\\n            if (!charSet.add(s[i])) {\\n                hasDuplicate = true\\n            }\\n            i++\\n        }\\n\\n        return diffIndex == -1 && hasDuplicate\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712865,
                "title": "simple-c-solution-best-for-beginners-beats-100-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->We can only swap two elements (Not less not more).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- If the length of s is smaller than 2 return false.\\n- If the lengths of the s and the goal are not same return false.\\n- If s and goal are same check whether the s has any character that repeats. So that we can swap the same characters. If yes, return true else return false.\\n- If s and goal are not same count the number of characters (var nod in code) that are not same in s and goal at position i.\\n- If nod is not 2, return false.\\n- If nod is 2, then swap the characters and check whether it becomes equal to goal or not.\\n\\n\\n**Upvote** **if** **Useful**\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.length() == 1){\\n            return false;\\n        }\\n        if(s.length() != goal.length()){\\n            return false;\\n        }\\n        if(s == goal){\\n            vector<int> alpha(26, 0);\\n            for(int i = 0; i < s.length(); i++){\\n                char cur = s[i];\\n                if(alpha[cur - \\'a\\'] == 1){\\n                    return true;\\n                }else{\\n                    alpha[cur - \\'a\\']++;\\n                }\\n            }\\n            return false;\\n        }else{\\n            int j, k;\\n            int nod = 0;\\n            for(int i = 0; i < s.length(); i++){\\n                if(s[i] != goal[i]){\\n                    if(nod < 2){\\n                        nod++;\\n                        if(nod == 1){\\n                            j = i;\\n                        }else{\\n                            k = i;\\n                        }\\n                    }else{\\n                        return false;\\n                    }\\n                }\\n            }\\n            if(nod == 1){\\n                return false;\\n            }\\n            char temp = s[j];\\n            s[j] = s[k];\\n            s[k] = temp;\\n            return s == goal;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.length() == 1){\\n            return false;\\n        }\\n        if(s.length() != goal.length()){\\n            return false;\\n        }\\n        if(s == goal){\\n            vector<int> alpha(26, 0);\\n            for(int i = 0; i < s.length(); i++){\\n                char cur = s[i];\\n                if(alpha[cur - \\'a\\'] == 1){\\n                    return true;\\n                }else{\\n                    alpha[cur - \\'a\\']++;\\n                }\\n            }\\n            return false;\\n        }else{\\n            int j, k;\\n            int nod = 0;\\n            for(int i = 0; i < s.length(); i++){\\n                if(s[i] != goal[i]){\\n                    if(nod < 2){\\n                        nod++;\\n                        if(nod == 1){\\n                            j = i;\\n                        }else{\\n                            k = i;\\n                        }\\n                    }else{\\n                        return false;\\n                    }\\n                }\\n            }\\n            if(nod == 1){\\n                return false;\\n            }\\n            char temp = s[j];\\n            s[j] = s[k];\\n            s[k] = temp;\\n            return s == goal;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1954003,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1686093,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1897609,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1953963,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1950987,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1953996,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1954034,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1566551,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1953972,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1953975,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1954003,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1686093,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1897609,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1953963,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1950987,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1953996,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1954034,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1566551,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1953972,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1953975,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1954030,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "It is an easy question, but not so easy, unless you find a tricky way! There are some different cases need to check:\ncheck the lengths of both s & goal\nSet some variables, for example variable denotes the number for different places, frequency table for characters etc.\nProceed the iteration and check\nAccording to each different case to determine whether s is convertible to goal or not."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "The guy who wrote the description for this problem deserves a hard spank in the butt"
                    },
                    {
                        "username": "gray_yarg",
                        "content": "sounds hot"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "SPANKBANG \\uD83D\\uDE09"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Haha, did I just completed it in one go.\\nToday is nice day."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=MzjGv9fQtM4"
                    },
                    {
                        "username": "bourne29",
                        "content": "![image](https://assets.leetcode.com/users/bourne29/image_1565367656.png)\\nAs per LeetCode testcases, A = \"abab\"  and B = \"abab\".\\nI can swap \"a\" at index 0 and index 2 --> That gives me B\\nBut I can also swap \"b\" at index 1 and index 3 --> That gives me B as well.\\n\\nWhen the questions says: \"if and only if we can swap two letters in A so that the result equals B\", it seems like only one swapping should be allowed. As per which the above test case should return : False\\n\\nPlease let me know if I am missing something."
                    },
                    {
                        "username": "serkora",
                        "content": "I don't think even the original quoted description can be understood the way you did. The word \"only\" refers to the ability/necessity to swap, not to \"only two letters\". Yes, only one swap is allowed to make the string in any single solution, but not \"only one possible swap\" / \"only one possible solution\"."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "YOU CAN SWAP ANY TWO letters like we can replace a at 0 with a at 2 or b at 0 or b at 3 it will return true."
                    },
                    {
                        "username": "Tharun49",
                        "content": "Updated description of the question goes this way \\n\"Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\"\\nI think this should help you!"
                    },
                    {
                        "username": "as9vd2",
                        "content": "There\\'s no way this is an easy."
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case that hasn\\u2019t been mentioned yet:\\n```text\\n\"abcaa\"\\n\"abcbb\"\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "false"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Run it. Encounter an edge case correct it. Same cycle till u pass all the test cases xD"
                    },
                    {
                        "username": "_drigger",
                        "content": " beware of the test case `aabssdf` and `aassbdf`, this is last one and my code fails in this as i didn\\'t consider when char occur more than once like `s` in this case, i am replacing with first `s` i found but we need to traverse complete string to see others also...it\\'s like backtracking."
                    },
                    {
                        "username": "user7478F",
                        "content": "Dear Leetcode, you don\\'t need to disguise questions\\n"
                    }
                ]
            },
            {
                "id": 1954253,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "It is an easy question, but not so easy, unless you find a tricky way! There are some different cases need to check:\ncheck the lengths of both s & goal\nSet some variables, for example variable denotes the number for different places, frequency table for characters etc.\nProceed the iteration and check\nAccording to each different case to determine whether s is convertible to goal or not."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "The guy who wrote the description for this problem deserves a hard spank in the butt"
                    },
                    {
                        "username": "gray_yarg",
                        "content": "sounds hot"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "SPANKBANG \\uD83D\\uDE09"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Haha, did I just completed it in one go.\\nToday is nice day."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=MzjGv9fQtM4"
                    },
                    {
                        "username": "bourne29",
                        "content": "![image](https://assets.leetcode.com/users/bourne29/image_1565367656.png)\\nAs per LeetCode testcases, A = \"abab\"  and B = \"abab\".\\nI can swap \"a\" at index 0 and index 2 --> That gives me B\\nBut I can also swap \"b\" at index 1 and index 3 --> That gives me B as well.\\n\\nWhen the questions says: \"if and only if we can swap two letters in A so that the result equals B\", it seems like only one swapping should be allowed. As per which the above test case should return : False\\n\\nPlease let me know if I am missing something."
                    },
                    {
                        "username": "serkora",
                        "content": "I don't think even the original quoted description can be understood the way you did. The word \"only\" refers to the ability/necessity to swap, not to \"only two letters\". Yes, only one swap is allowed to make the string in any single solution, but not \"only one possible swap\" / \"only one possible solution\"."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "YOU CAN SWAP ANY TWO letters like we can replace a at 0 with a at 2 or b at 0 or b at 3 it will return true."
                    },
                    {
                        "username": "Tharun49",
                        "content": "Updated description of the question goes this way \\n\"Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\"\\nI think this should help you!"
                    },
                    {
                        "username": "as9vd2",
                        "content": "There\\'s no way this is an easy."
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case that hasn\\u2019t been mentioned yet:\\n```text\\n\"abcaa\"\\n\"abcbb\"\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "false"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Run it. Encounter an edge case correct it. Same cycle till u pass all the test cases xD"
                    },
                    {
                        "username": "_drigger",
                        "content": " beware of the test case `aabssdf` and `aassbdf`, this is last one and my code fails in this as i didn\\'t consider when char occur more than once like `s` in this case, i am replacing with first `s` i found but we need to traverse complete string to see others also...it\\'s like backtracking."
                    },
                    {
                        "username": "user7478F",
                        "content": "Dear Leetcode, you don\\'t need to disguise questions\\n"
                    }
                ]
            },
            {
                "id": 1954162,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "It is an easy question, but not so easy, unless you find a tricky way! There are some different cases need to check:\ncheck the lengths of both s & goal\nSet some variables, for example variable denotes the number for different places, frequency table for characters etc.\nProceed the iteration and check\nAccording to each different case to determine whether s is convertible to goal or not."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "The guy who wrote the description for this problem deserves a hard spank in the butt"
                    },
                    {
                        "username": "gray_yarg",
                        "content": "sounds hot"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "SPANKBANG \\uD83D\\uDE09"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Haha, did I just completed it in one go.\\nToday is nice day."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=MzjGv9fQtM4"
                    },
                    {
                        "username": "bourne29",
                        "content": "![image](https://assets.leetcode.com/users/bourne29/image_1565367656.png)\\nAs per LeetCode testcases, A = \"abab\"  and B = \"abab\".\\nI can swap \"a\" at index 0 and index 2 --> That gives me B\\nBut I can also swap \"b\" at index 1 and index 3 --> That gives me B as well.\\n\\nWhen the questions says: \"if and only if we can swap two letters in A so that the result equals B\", it seems like only one swapping should be allowed. As per which the above test case should return : False\\n\\nPlease let me know if I am missing something."
                    },
                    {
                        "username": "serkora",
                        "content": "I don't think even the original quoted description can be understood the way you did. The word \"only\" refers to the ability/necessity to swap, not to \"only two letters\". Yes, only one swap is allowed to make the string in any single solution, but not \"only one possible swap\" / \"only one possible solution\"."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "YOU CAN SWAP ANY TWO letters like we can replace a at 0 with a at 2 or b at 0 or b at 3 it will return true."
                    },
                    {
                        "username": "Tharun49",
                        "content": "Updated description of the question goes this way \\n\"Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\"\\nI think this should help you!"
                    },
                    {
                        "username": "as9vd2",
                        "content": "There\\'s no way this is an easy."
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case that hasn\\u2019t been mentioned yet:\\n```text\\n\"abcaa\"\\n\"abcbb\"\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "false"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Run it. Encounter an edge case correct it. Same cycle till u pass all the test cases xD"
                    },
                    {
                        "username": "_drigger",
                        "content": " beware of the test case `aabssdf` and `aassbdf`, this is last one and my code fails in this as i didn\\'t consider when char occur more than once like `s` in this case, i am replacing with first `s` i found but we need to traverse complete string to see others also...it\\'s like backtracking."
                    },
                    {
                        "username": "user7478F",
                        "content": "Dear Leetcode, you don\\'t need to disguise questions\\n"
                    }
                ]
            },
            {
                "id": 1954345,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "It is an easy question, but not so easy, unless you find a tricky way! There are some different cases need to check:\ncheck the lengths of both s & goal\nSet some variables, for example variable denotes the number for different places, frequency table for characters etc.\nProceed the iteration and check\nAccording to each different case to determine whether s is convertible to goal or not."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "The guy who wrote the description for this problem deserves a hard spank in the butt"
                    },
                    {
                        "username": "gray_yarg",
                        "content": "sounds hot"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "SPANKBANG \\uD83D\\uDE09"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Haha, did I just completed it in one go.\\nToday is nice day."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=MzjGv9fQtM4"
                    },
                    {
                        "username": "bourne29",
                        "content": "![image](https://assets.leetcode.com/users/bourne29/image_1565367656.png)\\nAs per LeetCode testcases, A = \"abab\"  and B = \"abab\".\\nI can swap \"a\" at index 0 and index 2 --> That gives me B\\nBut I can also swap \"b\" at index 1 and index 3 --> That gives me B as well.\\n\\nWhen the questions says: \"if and only if we can swap two letters in A so that the result equals B\", it seems like only one swapping should be allowed. As per which the above test case should return : False\\n\\nPlease let me know if I am missing something."
                    },
                    {
                        "username": "serkora",
                        "content": "I don't think even the original quoted description can be understood the way you did. The word \"only\" refers to the ability/necessity to swap, not to \"only two letters\". Yes, only one swap is allowed to make the string in any single solution, but not \"only one possible swap\" / \"only one possible solution\"."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "YOU CAN SWAP ANY TWO letters like we can replace a at 0 with a at 2 or b at 0 or b at 3 it will return true."
                    },
                    {
                        "username": "Tharun49",
                        "content": "Updated description of the question goes this way \\n\"Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\"\\nI think this should help you!"
                    },
                    {
                        "username": "as9vd2",
                        "content": "There\\'s no way this is an easy."
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case that hasn\\u2019t been mentioned yet:\\n```text\\n\"abcaa\"\\n\"abcbb\"\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "false"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Run it. Encounter an edge case correct it. Same cycle till u pass all the test cases xD"
                    },
                    {
                        "username": "_drigger",
                        "content": " beware of the test case `aabssdf` and `aassbdf`, this is last one and my code fails in this as i didn\\'t consider when char occur more than once like `s` in this case, i am replacing with first `s` i found but we need to traverse complete string to see others also...it\\'s like backtracking."
                    },
                    {
                        "username": "user7478F",
                        "content": "Dear Leetcode, you don\\'t need to disguise questions\\n"
                    }
                ]
            },
            {
                "id": 1567403,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "It is an easy question, but not so easy, unless you find a tricky way! There are some different cases need to check:\ncheck the lengths of both s & goal\nSet some variables, for example variable denotes the number for different places, frequency table for characters etc.\nProceed the iteration and check\nAccording to each different case to determine whether s is convertible to goal or not."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "The guy who wrote the description for this problem deserves a hard spank in the butt"
                    },
                    {
                        "username": "gray_yarg",
                        "content": "sounds hot"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "SPANKBANG \\uD83D\\uDE09"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Haha, did I just completed it in one go.\\nToday is nice day."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=MzjGv9fQtM4"
                    },
                    {
                        "username": "bourne29",
                        "content": "![image](https://assets.leetcode.com/users/bourne29/image_1565367656.png)\\nAs per LeetCode testcases, A = \"abab\"  and B = \"abab\".\\nI can swap \"a\" at index 0 and index 2 --> That gives me B\\nBut I can also swap \"b\" at index 1 and index 3 --> That gives me B as well.\\n\\nWhen the questions says: \"if and only if we can swap two letters in A so that the result equals B\", it seems like only one swapping should be allowed. As per which the above test case should return : False\\n\\nPlease let me know if I am missing something."
                    },
                    {
                        "username": "serkora",
                        "content": "I don't think even the original quoted description can be understood the way you did. The word \"only\" refers to the ability/necessity to swap, not to \"only two letters\". Yes, only one swap is allowed to make the string in any single solution, but not \"only one possible swap\" / \"only one possible solution\"."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "YOU CAN SWAP ANY TWO letters like we can replace a at 0 with a at 2 or b at 0 or b at 3 it will return true."
                    },
                    {
                        "username": "Tharun49",
                        "content": "Updated description of the question goes this way \\n\"Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\"\\nI think this should help you!"
                    },
                    {
                        "username": "as9vd2",
                        "content": "There\\'s no way this is an easy."
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case that hasn\\u2019t been mentioned yet:\\n```text\\n\"abcaa\"\\n\"abcbb\"\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "false"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Run it. Encounter an edge case correct it. Same cycle till u pass all the test cases xD"
                    },
                    {
                        "username": "_drigger",
                        "content": " beware of the test case `aabssdf` and `aassbdf`, this is last one and my code fails in this as i didn\\'t consider when char occur more than once like `s` in this case, i am replacing with first `s` i found but we need to traverse complete string to see others also...it\\'s like backtracking."
                    },
                    {
                        "username": "user7478F",
                        "content": "Dear Leetcode, you don\\'t need to disguise questions\\n"
                    }
                ]
            },
            {
                "id": 1954015,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "It is an easy question, but not so easy, unless you find a tricky way! There are some different cases need to check:\ncheck the lengths of both s & goal\nSet some variables, for example variable denotes the number for different places, frequency table for characters etc.\nProceed the iteration and check\nAccording to each different case to determine whether s is convertible to goal or not."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "The guy who wrote the description for this problem deserves a hard spank in the butt"
                    },
                    {
                        "username": "gray_yarg",
                        "content": "sounds hot"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "SPANKBANG \\uD83D\\uDE09"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Haha, did I just completed it in one go.\\nToday is nice day."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=MzjGv9fQtM4"
                    },
                    {
                        "username": "bourne29",
                        "content": "![image](https://assets.leetcode.com/users/bourne29/image_1565367656.png)\\nAs per LeetCode testcases, A = \"abab\"  and B = \"abab\".\\nI can swap \"a\" at index 0 and index 2 --> That gives me B\\nBut I can also swap \"b\" at index 1 and index 3 --> That gives me B as well.\\n\\nWhen the questions says: \"if and only if we can swap two letters in A so that the result equals B\", it seems like only one swapping should be allowed. As per which the above test case should return : False\\n\\nPlease let me know if I am missing something."
                    },
                    {
                        "username": "serkora",
                        "content": "I don't think even the original quoted description can be understood the way you did. The word \"only\" refers to the ability/necessity to swap, not to \"only two letters\". Yes, only one swap is allowed to make the string in any single solution, but not \"only one possible swap\" / \"only one possible solution\"."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "YOU CAN SWAP ANY TWO letters like we can replace a at 0 with a at 2 or b at 0 or b at 3 it will return true."
                    },
                    {
                        "username": "Tharun49",
                        "content": "Updated description of the question goes this way \\n\"Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\"\\nI think this should help you!"
                    },
                    {
                        "username": "as9vd2",
                        "content": "There\\'s no way this is an easy."
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case that hasn\\u2019t been mentioned yet:\\n```text\\n\"abcaa\"\\n\"abcbb\"\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "false"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Run it. Encounter an edge case correct it. Same cycle till u pass all the test cases xD"
                    },
                    {
                        "username": "_drigger",
                        "content": " beware of the test case `aabssdf` and `aassbdf`, this is last one and my code fails in this as i didn\\'t consider when char occur more than once like `s` in this case, i am replacing with first `s` i found but we need to traverse complete string to see others also...it\\'s like backtracking."
                    },
                    {
                        "username": "user7478F",
                        "content": "Dear Leetcode, you don\\'t need to disguise questions\\n"
                    }
                ]
            },
            {
                "id": 1953967,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "It is an easy question, but not so easy, unless you find a tricky way! There are some different cases need to check:\ncheck the lengths of both s & goal\nSet some variables, for example variable denotes the number for different places, frequency table for characters etc.\nProceed the iteration and check\nAccording to each different case to determine whether s is convertible to goal or not."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "The guy who wrote the description for this problem deserves a hard spank in the butt"
                    },
                    {
                        "username": "gray_yarg",
                        "content": "sounds hot"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "SPANKBANG \\uD83D\\uDE09"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Haha, did I just completed it in one go.\\nToday is nice day."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=MzjGv9fQtM4"
                    },
                    {
                        "username": "bourne29",
                        "content": "![image](https://assets.leetcode.com/users/bourne29/image_1565367656.png)\\nAs per LeetCode testcases, A = \"abab\"  and B = \"abab\".\\nI can swap \"a\" at index 0 and index 2 --> That gives me B\\nBut I can also swap \"b\" at index 1 and index 3 --> That gives me B as well.\\n\\nWhen the questions says: \"if and only if we can swap two letters in A so that the result equals B\", it seems like only one swapping should be allowed. As per which the above test case should return : False\\n\\nPlease let me know if I am missing something."
                    },
                    {
                        "username": "serkora",
                        "content": "I don't think even the original quoted description can be understood the way you did. The word \"only\" refers to the ability/necessity to swap, not to \"only two letters\". Yes, only one swap is allowed to make the string in any single solution, but not \"only one possible swap\" / \"only one possible solution\"."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "YOU CAN SWAP ANY TWO letters like we can replace a at 0 with a at 2 or b at 0 or b at 3 it will return true."
                    },
                    {
                        "username": "Tharun49",
                        "content": "Updated description of the question goes this way \\n\"Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\"\\nI think this should help you!"
                    },
                    {
                        "username": "as9vd2",
                        "content": "There\\'s no way this is an easy."
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case that hasn\\u2019t been mentioned yet:\\n```text\\n\"abcaa\"\\n\"abcbb\"\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "false"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Run it. Encounter an edge case correct it. Same cycle till u pass all the test cases xD"
                    },
                    {
                        "username": "_drigger",
                        "content": " beware of the test case `aabssdf` and `aassbdf`, this is last one and my code fails in this as i didn\\'t consider when char occur more than once like `s` in this case, i am replacing with first `s` i found but we need to traverse complete string to see others also...it\\'s like backtracking."
                    },
                    {
                        "username": "user7478F",
                        "content": "Dear Leetcode, you don\\'t need to disguise questions\\n"
                    }
                ]
            },
            {
                "id": 1953956,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "It is an easy question, but not so easy, unless you find a tricky way! There are some different cases need to check:\ncheck the lengths of both s & goal\nSet some variables, for example variable denotes the number for different places, frequency table for characters etc.\nProceed the iteration and check\nAccording to each different case to determine whether s is convertible to goal or not."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "The guy who wrote the description for this problem deserves a hard spank in the butt"
                    },
                    {
                        "username": "gray_yarg",
                        "content": "sounds hot"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "SPANKBANG \\uD83D\\uDE09"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Haha, did I just completed it in one go.\\nToday is nice day."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=MzjGv9fQtM4"
                    },
                    {
                        "username": "bourne29",
                        "content": "![image](https://assets.leetcode.com/users/bourne29/image_1565367656.png)\\nAs per LeetCode testcases, A = \"abab\"  and B = \"abab\".\\nI can swap \"a\" at index 0 and index 2 --> That gives me B\\nBut I can also swap \"b\" at index 1 and index 3 --> That gives me B as well.\\n\\nWhen the questions says: \"if and only if we can swap two letters in A so that the result equals B\", it seems like only one swapping should be allowed. As per which the above test case should return : False\\n\\nPlease let me know if I am missing something."
                    },
                    {
                        "username": "serkora",
                        "content": "I don't think even the original quoted description can be understood the way you did. The word \"only\" refers to the ability/necessity to swap, not to \"only two letters\". Yes, only one swap is allowed to make the string in any single solution, but not \"only one possible swap\" / \"only one possible solution\"."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "YOU CAN SWAP ANY TWO letters like we can replace a at 0 with a at 2 or b at 0 or b at 3 it will return true."
                    },
                    {
                        "username": "Tharun49",
                        "content": "Updated description of the question goes this way \\n\"Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\"\\nI think this should help you!"
                    },
                    {
                        "username": "as9vd2",
                        "content": "There\\'s no way this is an easy."
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case that hasn\\u2019t been mentioned yet:\\n```text\\n\"abcaa\"\\n\"abcbb\"\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "false"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Run it. Encounter an edge case correct it. Same cycle till u pass all the test cases xD"
                    },
                    {
                        "username": "_drigger",
                        "content": " beware of the test case `aabssdf` and `aassbdf`, this is last one and my code fails in this as i didn\\'t consider when char occur more than once like `s` in this case, i am replacing with first `s` i found but we need to traverse complete string to see others also...it\\'s like backtracking."
                    },
                    {
                        "username": "user7478F",
                        "content": "Dear Leetcode, you don\\'t need to disguise questions\\n"
                    }
                ]
            },
            {
                "id": 1954143,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "It is an easy question, but not so easy, unless you find a tricky way! There are some different cases need to check:\ncheck the lengths of both s & goal\nSet some variables, for example variable denotes the number for different places, frequency table for characters etc.\nProceed the iteration and check\nAccording to each different case to determine whether s is convertible to goal or not."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "The guy who wrote the description for this problem deserves a hard spank in the butt"
                    },
                    {
                        "username": "gray_yarg",
                        "content": "sounds hot"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "SPANKBANG \\uD83D\\uDE09"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Haha, did I just completed it in one go.\\nToday is nice day."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=MzjGv9fQtM4"
                    },
                    {
                        "username": "bourne29",
                        "content": "![image](https://assets.leetcode.com/users/bourne29/image_1565367656.png)\\nAs per LeetCode testcases, A = \"abab\"  and B = \"abab\".\\nI can swap \"a\" at index 0 and index 2 --> That gives me B\\nBut I can also swap \"b\" at index 1 and index 3 --> That gives me B as well.\\n\\nWhen the questions says: \"if and only if we can swap two letters in A so that the result equals B\", it seems like only one swapping should be allowed. As per which the above test case should return : False\\n\\nPlease let me know if I am missing something."
                    },
                    {
                        "username": "serkora",
                        "content": "I don't think even the original quoted description can be understood the way you did. The word \"only\" refers to the ability/necessity to swap, not to \"only two letters\". Yes, only one swap is allowed to make the string in any single solution, but not \"only one possible swap\" / \"only one possible solution\"."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "YOU CAN SWAP ANY TWO letters like we can replace a at 0 with a at 2 or b at 0 or b at 3 it will return true."
                    },
                    {
                        "username": "Tharun49",
                        "content": "Updated description of the question goes this way \\n\"Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\"\\nI think this should help you!"
                    },
                    {
                        "username": "as9vd2",
                        "content": "There\\'s no way this is an easy."
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case that hasn\\u2019t been mentioned yet:\\n```text\\n\"abcaa\"\\n\"abcbb\"\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "false"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Run it. Encounter an edge case correct it. Same cycle till u pass all the test cases xD"
                    },
                    {
                        "username": "_drigger",
                        "content": " beware of the test case `aabssdf` and `aassbdf`, this is last one and my code fails in this as i didn\\'t consider when char occur more than once like `s` in this case, i am replacing with first `s` i found but we need to traverse complete string to see others also...it\\'s like backtracking."
                    },
                    {
                        "username": "user7478F",
                        "content": "Dear Leetcode, you don\\'t need to disguise questions\\n"
                    }
                ]
            },
            {
                "id": 1955119,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "It is an easy question, but not so easy, unless you find a tricky way! There are some different cases need to check:\ncheck the lengths of both s & goal\nSet some variables, for example variable denotes the number for different places, frequency table for characters etc.\nProceed the iteration and check\nAccording to each different case to determine whether s is convertible to goal or not."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "The guy who wrote the description for this problem deserves a hard spank in the butt"
                    },
                    {
                        "username": "gray_yarg",
                        "content": "sounds hot"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "SPANKBANG \\uD83D\\uDE09"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Haha, did I just completed it in one go.\\nToday is nice day."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=MzjGv9fQtM4"
                    },
                    {
                        "username": "bourne29",
                        "content": "![image](https://assets.leetcode.com/users/bourne29/image_1565367656.png)\\nAs per LeetCode testcases, A = \"abab\"  and B = \"abab\".\\nI can swap \"a\" at index 0 and index 2 --> That gives me B\\nBut I can also swap \"b\" at index 1 and index 3 --> That gives me B as well.\\n\\nWhen the questions says: \"if and only if we can swap two letters in A so that the result equals B\", it seems like only one swapping should be allowed. As per which the above test case should return : False\\n\\nPlease let me know if I am missing something."
                    },
                    {
                        "username": "serkora",
                        "content": "I don't think even the original quoted description can be understood the way you did. The word \"only\" refers to the ability/necessity to swap, not to \"only two letters\". Yes, only one swap is allowed to make the string in any single solution, but not \"only one possible swap\" / \"only one possible solution\"."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "YOU CAN SWAP ANY TWO letters like we can replace a at 0 with a at 2 or b at 0 or b at 3 it will return true."
                    },
                    {
                        "username": "Tharun49",
                        "content": "Updated description of the question goes this way \\n\"Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\"\\nI think this should help you!"
                    },
                    {
                        "username": "as9vd2",
                        "content": "There\\'s no way this is an easy."
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case that hasn\\u2019t been mentioned yet:\\n```text\\n\"abcaa\"\\n\"abcbb\"\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "false"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Run it. Encounter an edge case correct it. Same cycle till u pass all the test cases xD"
                    },
                    {
                        "username": "_drigger",
                        "content": " beware of the test case `aabssdf` and `aassbdf`, this is last one and my code fails in this as i didn\\'t consider when char occur more than once like `s` in this case, i am replacing with first `s` i found but we need to traverse complete string to see others also...it\\'s like backtracking."
                    },
                    {
                        "username": "user7478F",
                        "content": "Dear Leetcode, you don\\'t need to disguise questions\\n"
                    }
                ]
            },
            {
                "id": 1954730,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "Its a trick boys, Its the calm before the storm of hard questions."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This is definitely not an easy problem.\nYou have to look at all three examples very carefully. They explain all possible scenarios.\n<hr>\n\n**-If s and goal are not equal then you have to find number of index whose character are not same in s and goal.**\n <p>For example s = \"ab\", goal = \"ba\"\nHere at 0th index, there is different character in s and goal , also same for 1st index , so we are having exactly 2 index , which can can be swap and if after swapping if s and goal are equal return true else return false.</p>\n\n\n**-If s and goal are equal then you just have to store the frequency of each character in s and look out for character whose frequency is greater than 1.**\n<div>For example s = \"ab\", goal = \"ab\"  here none of the characters of s has  the frequency greater then 1. which mean there is no way we can achieve the goal by swapping characters in s so we return false other return true (Example-3).</div>\n<hr>\n\nSolutions --> https://leetcode.com/problems/buddy-strings/submissions/985169070/"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Ashish_4k](/Ashish_4k)  Yup, I thought there no need to mention here that\\'s why. Otherwise that\\'s the first thing we need check\\uD83D\\uDE00"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "one more scenario if lengths are unequal"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally an easy question "
                    },
                    {
                        "username": "lovely08",
                        "content": "Did this question on my own after getting 7 times TLE. Feeling okay.\\n"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "This problem seems piece of cake but edge cases sucks "
                    },
                    {
                        "username": "fahad_sait",
                        "content": "WTF!!!!!!! is wrong with test case 24/34??? My code was so simple and efficient. The test cases always fucks up!!\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Even I got headache I thought the testcases are not that bad."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "it\\'s just that we have lot of corner cases to handle hint: 1) lengths 2) duplicates and 3) is the problem wheather swap is possible that is no. of unequal places"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "HR: \\n\\\\- Of course we have a lot of interesting tasks for you!\\nTeamlead:\\n\\\\- Okay, man, here is the deal..."
                    },
                    {
                        "username": "ross8888",
                        "content": "You should celebrate a little if done this in one go!!\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "easy but tricky one \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cool. I got all of the edge cases before submitting my code. At first I suspected that I was over-engineering my solution by checking for unequal string lengths (the description doesn\\'t say that the strings must have the same length) but it is gratifying to see that in some test cases, the strings do indeed have unequal lengths.\\n\\nHad the requirement been that there could be more than 1 swap needed to make the strings equal then this might have been a more interesting challenge."
                    }
                ]
            },
            {
                "id": 1954459,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "Its a trick boys, Its the calm before the storm of hard questions."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This is definitely not an easy problem.\nYou have to look at all three examples very carefully. They explain all possible scenarios.\n<hr>\n\n**-If s and goal are not equal then you have to find number of index whose character are not same in s and goal.**\n <p>For example s = \"ab\", goal = \"ba\"\nHere at 0th index, there is different character in s and goal , also same for 1st index , so we are having exactly 2 index , which can can be swap and if after swapping if s and goal are equal return true else return false.</p>\n\n\n**-If s and goal are equal then you just have to store the frequency of each character in s and look out for character whose frequency is greater than 1.**\n<div>For example s = \"ab\", goal = \"ab\"  here none of the characters of s has  the frequency greater then 1. which mean there is no way we can achieve the goal by swapping characters in s so we return false other return true (Example-3).</div>\n<hr>\n\nSolutions --> https://leetcode.com/problems/buddy-strings/submissions/985169070/"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Ashish_4k](/Ashish_4k)  Yup, I thought there no need to mention here that\\'s why. Otherwise that\\'s the first thing we need check\\uD83D\\uDE00"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "one more scenario if lengths are unequal"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally an easy question "
                    },
                    {
                        "username": "lovely08",
                        "content": "Did this question on my own after getting 7 times TLE. Feeling okay.\\n"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "This problem seems piece of cake but edge cases sucks "
                    },
                    {
                        "username": "fahad_sait",
                        "content": "WTF!!!!!!! is wrong with test case 24/34??? My code was so simple and efficient. The test cases always fucks up!!\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Even I got headache I thought the testcases are not that bad."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "it\\'s just that we have lot of corner cases to handle hint: 1) lengths 2) duplicates and 3) is the problem wheather swap is possible that is no. of unequal places"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "HR: \\n\\\\- Of course we have a lot of interesting tasks for you!\\nTeamlead:\\n\\\\- Okay, man, here is the deal..."
                    },
                    {
                        "username": "ross8888",
                        "content": "You should celebrate a little if done this in one go!!\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "easy but tricky one \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cool. I got all of the edge cases before submitting my code. At first I suspected that I was over-engineering my solution by checking for unequal string lengths (the description doesn\\'t say that the strings must have the same length) but it is gratifying to see that in some test cases, the strings do indeed have unequal lengths.\\n\\nHad the requirement been that there could be more than 1 swap needed to make the strings equal then this might have been a more interesting challenge."
                    }
                ]
            },
            {
                "id": 1953995,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "Its a trick boys, Its the calm before the storm of hard questions."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This is definitely not an easy problem.\nYou have to look at all three examples very carefully. They explain all possible scenarios.\n<hr>\n\n**-If s and goal are not equal then you have to find number of index whose character are not same in s and goal.**\n <p>For example s = \"ab\", goal = \"ba\"\nHere at 0th index, there is different character in s and goal , also same for 1st index , so we are having exactly 2 index , which can can be swap and if after swapping if s and goal are equal return true else return false.</p>\n\n\n**-If s and goal are equal then you just have to store the frequency of each character in s and look out for character whose frequency is greater than 1.**\n<div>For example s = \"ab\", goal = \"ab\"  here none of the characters of s has  the frequency greater then 1. which mean there is no way we can achieve the goal by swapping characters in s so we return false other return true (Example-3).</div>\n<hr>\n\nSolutions --> https://leetcode.com/problems/buddy-strings/submissions/985169070/"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Ashish_4k](/Ashish_4k)  Yup, I thought there no need to mention here that\\'s why. Otherwise that\\'s the first thing we need check\\uD83D\\uDE00"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "one more scenario if lengths are unequal"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally an easy question "
                    },
                    {
                        "username": "lovely08",
                        "content": "Did this question on my own after getting 7 times TLE. Feeling okay.\\n"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "This problem seems piece of cake but edge cases sucks "
                    },
                    {
                        "username": "fahad_sait",
                        "content": "WTF!!!!!!! is wrong with test case 24/34??? My code was so simple and efficient. The test cases always fucks up!!\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Even I got headache I thought the testcases are not that bad."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "it\\'s just that we have lot of corner cases to handle hint: 1) lengths 2) duplicates and 3) is the problem wheather swap is possible that is no. of unequal places"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "HR: \\n\\\\- Of course we have a lot of interesting tasks for you!\\nTeamlead:\\n\\\\- Okay, man, here is the deal..."
                    },
                    {
                        "username": "ross8888",
                        "content": "You should celebrate a little if done this in one go!!\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "easy but tricky one \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cool. I got all of the edge cases before submitting my code. At first I suspected that I was over-engineering my solution by checking for unequal string lengths (the description doesn\\'t say that the strings must have the same length) but it is gratifying to see that in some test cases, the strings do indeed have unequal lengths.\\n\\nHad the requirement been that there could be more than 1 swap needed to make the strings equal then this might have been a more interesting challenge."
                    }
                ]
            },
            {
                "id": 1955371,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "Its a trick boys, Its the calm before the storm of hard questions."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This is definitely not an easy problem.\nYou have to look at all three examples very carefully. They explain all possible scenarios.\n<hr>\n\n**-If s and goal are not equal then you have to find number of index whose character are not same in s and goal.**\n <p>For example s = \"ab\", goal = \"ba\"\nHere at 0th index, there is different character in s and goal , also same for 1st index , so we are having exactly 2 index , which can can be swap and if after swapping if s and goal are equal return true else return false.</p>\n\n\n**-If s and goal are equal then you just have to store the frequency of each character in s and look out for character whose frequency is greater than 1.**\n<div>For example s = \"ab\", goal = \"ab\"  here none of the characters of s has  the frequency greater then 1. which mean there is no way we can achieve the goal by swapping characters in s so we return false other return true (Example-3).</div>\n<hr>\n\nSolutions --> https://leetcode.com/problems/buddy-strings/submissions/985169070/"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Ashish_4k](/Ashish_4k)  Yup, I thought there no need to mention here that\\'s why. Otherwise that\\'s the first thing we need check\\uD83D\\uDE00"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "one more scenario if lengths are unequal"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally an easy question "
                    },
                    {
                        "username": "lovely08",
                        "content": "Did this question on my own after getting 7 times TLE. Feeling okay.\\n"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "This problem seems piece of cake but edge cases sucks "
                    },
                    {
                        "username": "fahad_sait",
                        "content": "WTF!!!!!!! is wrong with test case 24/34??? My code was so simple and efficient. The test cases always fucks up!!\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Even I got headache I thought the testcases are not that bad."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "it\\'s just that we have lot of corner cases to handle hint: 1) lengths 2) duplicates and 3) is the problem wheather swap is possible that is no. of unequal places"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "HR: \\n\\\\- Of course we have a lot of interesting tasks for you!\\nTeamlead:\\n\\\\- Okay, man, here is the deal..."
                    },
                    {
                        "username": "ross8888",
                        "content": "You should celebrate a little if done this in one go!!\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "easy but tricky one \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cool. I got all of the edge cases before submitting my code. At first I suspected that I was over-engineering my solution by checking for unequal string lengths (the description doesn\\'t say that the strings must have the same length) but it is gratifying to see that in some test cases, the strings do indeed have unequal lengths.\\n\\nHad the requirement been that there could be more than 1 swap needed to make the strings equal then this might have been a more interesting challenge."
                    }
                ]
            },
            {
                "id": 1955249,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "Its a trick boys, Its the calm before the storm of hard questions."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This is definitely not an easy problem.\nYou have to look at all three examples very carefully. They explain all possible scenarios.\n<hr>\n\n**-If s and goal are not equal then you have to find number of index whose character are not same in s and goal.**\n <p>For example s = \"ab\", goal = \"ba\"\nHere at 0th index, there is different character in s and goal , also same for 1st index , so we are having exactly 2 index , which can can be swap and if after swapping if s and goal are equal return true else return false.</p>\n\n\n**-If s and goal are equal then you just have to store the frequency of each character in s and look out for character whose frequency is greater than 1.**\n<div>For example s = \"ab\", goal = \"ab\"  here none of the characters of s has  the frequency greater then 1. which mean there is no way we can achieve the goal by swapping characters in s so we return false other return true (Example-3).</div>\n<hr>\n\nSolutions --> https://leetcode.com/problems/buddy-strings/submissions/985169070/"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Ashish_4k](/Ashish_4k)  Yup, I thought there no need to mention here that\\'s why. Otherwise that\\'s the first thing we need check\\uD83D\\uDE00"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "one more scenario if lengths are unequal"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally an easy question "
                    },
                    {
                        "username": "lovely08",
                        "content": "Did this question on my own after getting 7 times TLE. Feeling okay.\\n"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "This problem seems piece of cake but edge cases sucks "
                    },
                    {
                        "username": "fahad_sait",
                        "content": "WTF!!!!!!! is wrong with test case 24/34??? My code was so simple and efficient. The test cases always fucks up!!\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Even I got headache I thought the testcases are not that bad."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "it\\'s just that we have lot of corner cases to handle hint: 1) lengths 2) duplicates and 3) is the problem wheather swap is possible that is no. of unequal places"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "HR: \\n\\\\- Of course we have a lot of interesting tasks for you!\\nTeamlead:\\n\\\\- Okay, man, here is the deal..."
                    },
                    {
                        "username": "ross8888",
                        "content": "You should celebrate a little if done this in one go!!\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "easy but tricky one \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cool. I got all of the edge cases before submitting my code. At first I suspected that I was over-engineering my solution by checking for unequal string lengths (the description doesn\\'t say that the strings must have the same length) but it is gratifying to see that in some test cases, the strings do indeed have unequal lengths.\\n\\nHad the requirement been that there could be more than 1 swap needed to make the strings equal then this might have been a more interesting challenge."
                    }
                ]
            },
            {
                "id": 1954914,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "Its a trick boys, Its the calm before the storm of hard questions."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This is definitely not an easy problem.\nYou have to look at all three examples very carefully. They explain all possible scenarios.\n<hr>\n\n**-If s and goal are not equal then you have to find number of index whose character are not same in s and goal.**\n <p>For example s = \"ab\", goal = \"ba\"\nHere at 0th index, there is different character in s and goal , also same for 1st index , so we are having exactly 2 index , which can can be swap and if after swapping if s and goal are equal return true else return false.</p>\n\n\n**-If s and goal are equal then you just have to store the frequency of each character in s and look out for character whose frequency is greater than 1.**\n<div>For example s = \"ab\", goal = \"ab\"  here none of the characters of s has  the frequency greater then 1. which mean there is no way we can achieve the goal by swapping characters in s so we return false other return true (Example-3).</div>\n<hr>\n\nSolutions --> https://leetcode.com/problems/buddy-strings/submissions/985169070/"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Ashish_4k](/Ashish_4k)  Yup, I thought there no need to mention here that\\'s why. Otherwise that\\'s the first thing we need check\\uD83D\\uDE00"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "one more scenario if lengths are unequal"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally an easy question "
                    },
                    {
                        "username": "lovely08",
                        "content": "Did this question on my own after getting 7 times TLE. Feeling okay.\\n"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "This problem seems piece of cake but edge cases sucks "
                    },
                    {
                        "username": "fahad_sait",
                        "content": "WTF!!!!!!! is wrong with test case 24/34??? My code was so simple and efficient. The test cases always fucks up!!\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Even I got headache I thought the testcases are not that bad."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "it\\'s just that we have lot of corner cases to handle hint: 1) lengths 2) duplicates and 3) is the problem wheather swap is possible that is no. of unequal places"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "HR: \\n\\\\- Of course we have a lot of interesting tasks for you!\\nTeamlead:\\n\\\\- Okay, man, here is the deal..."
                    },
                    {
                        "username": "ross8888",
                        "content": "You should celebrate a little if done this in one go!!\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "easy but tricky one \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cool. I got all of the edge cases before submitting my code. At first I suspected that I was over-engineering my solution by checking for unequal string lengths (the description doesn\\'t say that the strings must have the same length) but it is gratifying to see that in some test cases, the strings do indeed have unequal lengths.\\n\\nHad the requirement been that there could be more than 1 swap needed to make the strings equal then this might have been a more interesting challenge."
                    }
                ]
            },
            {
                "id": 1954267,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "Its a trick boys, Its the calm before the storm of hard questions."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This is definitely not an easy problem.\nYou have to look at all three examples very carefully. They explain all possible scenarios.\n<hr>\n\n**-If s and goal are not equal then you have to find number of index whose character are not same in s and goal.**\n <p>For example s = \"ab\", goal = \"ba\"\nHere at 0th index, there is different character in s and goal , also same for 1st index , so we are having exactly 2 index , which can can be swap and if after swapping if s and goal are equal return true else return false.</p>\n\n\n**-If s and goal are equal then you just have to store the frequency of each character in s and look out for character whose frequency is greater than 1.**\n<div>For example s = \"ab\", goal = \"ab\"  here none of the characters of s has  the frequency greater then 1. which mean there is no way we can achieve the goal by swapping characters in s so we return false other return true (Example-3).</div>\n<hr>\n\nSolutions --> https://leetcode.com/problems/buddy-strings/submissions/985169070/"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Ashish_4k](/Ashish_4k)  Yup, I thought there no need to mention here that\\'s why. Otherwise that\\'s the first thing we need check\\uD83D\\uDE00"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "one more scenario if lengths are unequal"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally an easy question "
                    },
                    {
                        "username": "lovely08",
                        "content": "Did this question on my own after getting 7 times TLE. Feeling okay.\\n"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "This problem seems piece of cake but edge cases sucks "
                    },
                    {
                        "username": "fahad_sait",
                        "content": "WTF!!!!!!! is wrong with test case 24/34??? My code was so simple and efficient. The test cases always fucks up!!\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Even I got headache I thought the testcases are not that bad."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "it\\'s just that we have lot of corner cases to handle hint: 1) lengths 2) duplicates and 3) is the problem wheather swap is possible that is no. of unequal places"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "HR: \\n\\\\- Of course we have a lot of interesting tasks for you!\\nTeamlead:\\n\\\\- Okay, man, here is the deal..."
                    },
                    {
                        "username": "ross8888",
                        "content": "You should celebrate a little if done this in one go!!\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "easy but tricky one \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cool. I got all of the edge cases before submitting my code. At first I suspected that I was over-engineering my solution by checking for unequal string lengths (the description doesn\\'t say that the strings must have the same length) but it is gratifying to see that in some test cases, the strings do indeed have unequal lengths.\\n\\nHad the requirement been that there could be more than 1 swap needed to make the strings equal then this might have been a more interesting challenge."
                    }
                ]
            },
            {
                "id": 1954215,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "Its a trick boys, Its the calm before the storm of hard questions."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This is definitely not an easy problem.\nYou have to look at all three examples very carefully. They explain all possible scenarios.\n<hr>\n\n**-If s and goal are not equal then you have to find number of index whose character are not same in s and goal.**\n <p>For example s = \"ab\", goal = \"ba\"\nHere at 0th index, there is different character in s and goal , also same for 1st index , so we are having exactly 2 index , which can can be swap and if after swapping if s and goal are equal return true else return false.</p>\n\n\n**-If s and goal are equal then you just have to store the frequency of each character in s and look out for character whose frequency is greater than 1.**\n<div>For example s = \"ab\", goal = \"ab\"  here none of the characters of s has  the frequency greater then 1. which mean there is no way we can achieve the goal by swapping characters in s so we return false other return true (Example-3).</div>\n<hr>\n\nSolutions --> https://leetcode.com/problems/buddy-strings/submissions/985169070/"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Ashish_4k](/Ashish_4k)  Yup, I thought there no need to mention here that\\'s why. Otherwise that\\'s the first thing we need check\\uD83D\\uDE00"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "one more scenario if lengths are unequal"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally an easy question "
                    },
                    {
                        "username": "lovely08",
                        "content": "Did this question on my own after getting 7 times TLE. Feeling okay.\\n"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "This problem seems piece of cake but edge cases sucks "
                    },
                    {
                        "username": "fahad_sait",
                        "content": "WTF!!!!!!! is wrong with test case 24/34??? My code was so simple and efficient. The test cases always fucks up!!\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Even I got headache I thought the testcases are not that bad."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "it\\'s just that we have lot of corner cases to handle hint: 1) lengths 2) duplicates and 3) is the problem wheather swap is possible that is no. of unequal places"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "HR: \\n\\\\- Of course we have a lot of interesting tasks for you!\\nTeamlead:\\n\\\\- Okay, man, here is the deal..."
                    },
                    {
                        "username": "ross8888",
                        "content": "You should celebrate a little if done this in one go!!\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "easy but tricky one \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cool. I got all of the edge cases before submitting my code. At first I suspected that I was over-engineering my solution by checking for unequal string lengths (the description doesn\\'t say that the strings must have the same length) but it is gratifying to see that in some test cases, the strings do indeed have unequal lengths.\\n\\nHad the requirement been that there could be more than 1 swap needed to make the strings equal then this might have been a more interesting challenge."
                    }
                ]
            },
            {
                "id": 1954133,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "Its a trick boys, Its the calm before the storm of hard questions."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This is definitely not an easy problem.\nYou have to look at all three examples very carefully. They explain all possible scenarios.\n<hr>\n\n**-If s and goal are not equal then you have to find number of index whose character are not same in s and goal.**\n <p>For example s = \"ab\", goal = \"ba\"\nHere at 0th index, there is different character in s and goal , also same for 1st index , so we are having exactly 2 index , which can can be swap and if after swapping if s and goal are equal return true else return false.</p>\n\n\n**-If s and goal are equal then you just have to store the frequency of each character in s and look out for character whose frequency is greater than 1.**\n<div>For example s = \"ab\", goal = \"ab\"  here none of the characters of s has  the frequency greater then 1. which mean there is no way we can achieve the goal by swapping characters in s so we return false other return true (Example-3).</div>\n<hr>\n\nSolutions --> https://leetcode.com/problems/buddy-strings/submissions/985169070/"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Ashish_4k](/Ashish_4k)  Yup, I thought there no need to mention here that\\'s why. Otherwise that\\'s the first thing we need check\\uD83D\\uDE00"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "one more scenario if lengths are unequal"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally an easy question "
                    },
                    {
                        "username": "lovely08",
                        "content": "Did this question on my own after getting 7 times TLE. Feeling okay.\\n"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "This problem seems piece of cake but edge cases sucks "
                    },
                    {
                        "username": "fahad_sait",
                        "content": "WTF!!!!!!! is wrong with test case 24/34??? My code was so simple and efficient. The test cases always fucks up!!\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Even I got headache I thought the testcases are not that bad."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "it\\'s just that we have lot of corner cases to handle hint: 1) lengths 2) duplicates and 3) is the problem wheather swap is possible that is no. of unequal places"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "HR: \\n\\\\- Of course we have a lot of interesting tasks for you!\\nTeamlead:\\n\\\\- Okay, man, here is the deal..."
                    },
                    {
                        "username": "ross8888",
                        "content": "You should celebrate a little if done this in one go!!\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "easy but tricky one \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cool. I got all of the edge cases before submitting my code. At first I suspected that I was over-engineering my solution by checking for unequal string lengths (the description doesn\\'t say that the strings must have the same length) but it is gratifying to see that in some test cases, the strings do indeed have unequal lengths.\\n\\nHad the requirement been that there could be more than 1 swap needed to make the strings equal then this might have been a more interesting challenge."
                    }
                ]
            },
            {
                "id": 1954095,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "Its a trick boys, Its the calm before the storm of hard questions."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This is definitely not an easy problem.\nYou have to look at all three examples very carefully. They explain all possible scenarios.\n<hr>\n\n**-If s and goal are not equal then you have to find number of index whose character are not same in s and goal.**\n <p>For example s = \"ab\", goal = \"ba\"\nHere at 0th index, there is different character in s and goal , also same for 1st index , so we are having exactly 2 index , which can can be swap and if after swapping if s and goal are equal return true else return false.</p>\n\n\n**-If s and goal are equal then you just have to store the frequency of each character in s and look out for character whose frequency is greater than 1.**\n<div>For example s = \"ab\", goal = \"ab\"  here none of the characters of s has  the frequency greater then 1. which mean there is no way we can achieve the goal by swapping characters in s so we return false other return true (Example-3).</div>\n<hr>\n\nSolutions --> https://leetcode.com/problems/buddy-strings/submissions/985169070/"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Ashish_4k](/Ashish_4k)  Yup, I thought there no need to mention here that\\'s why. Otherwise that\\'s the first thing we need check\\uD83D\\uDE00"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "one more scenario if lengths are unequal"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally an easy question "
                    },
                    {
                        "username": "lovely08",
                        "content": "Did this question on my own after getting 7 times TLE. Feeling okay.\\n"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "This problem seems piece of cake but edge cases sucks "
                    },
                    {
                        "username": "fahad_sait",
                        "content": "WTF!!!!!!! is wrong with test case 24/34??? My code was so simple and efficient. The test cases always fucks up!!\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Even I got headache I thought the testcases are not that bad."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "it\\'s just that we have lot of corner cases to handle hint: 1) lengths 2) duplicates and 3) is the problem wheather swap is possible that is no. of unequal places"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "HR: \\n\\\\- Of course we have a lot of interesting tasks for you!\\nTeamlead:\\n\\\\- Okay, man, here is the deal..."
                    },
                    {
                        "username": "ross8888",
                        "content": "You should celebrate a little if done this in one go!!\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "easy but tricky one \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cool. I got all of the edge cases before submitting my code. At first I suspected that I was over-engineering my solution by checking for unequal string lengths (the description doesn\\'t say that the strings must have the same length) but it is gratifying to see that in some test cases, the strings do indeed have unequal lengths.\\n\\nHad the requirement been that there could be more than 1 swap needed to make the strings equal then this might have been a more interesting challenge."
                    }
                ]
            },
            {
                "id": 1953961,
                "content": [
                    {
                        "username": "Shi-Yueyang",
                        "content": "I hate this type of problem"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be careful with the test case \"ab\" and \"babbb\".\\n\\nIn my humble opinion, adding test cases for inputs with different lengths does not add any value to this problem because it is extremely easy to solve but it is quite annoying to see submission failing because of this \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "sheikh_abir_ali",
                        "content": "**Working Fine Everywhere but giving false in TC 15 :!**\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if s == goal[::-1]:\\n            return \"true\"\\n        else:\\n            return \"false\"\\n```"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "You are simply checking if `s` and `goal` are palindrome or not. How does that check for buddy condition?"
                    },
                    {
                        "username": "Carlosx7",
                        "content": "could you post which is the input for TC 15??"
                    },
                    {
                        "username": "cracy",
                        "content": "For example \"aa\", \"ab\". My first submission didn\\'t check for that but still got accepted."
                    },
                    {
                        "username": "ursachu",
                        "content": "I dont like this question. It seems irrelevant"
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was asshole"
                    },
                    {
                        "username": "kiduse0911",
                        "content": "man, this is a confusing question. Plus the test cases are not that helpful"
                    },
                    {
                        "username": "woofer_employ_0r",
                        "content": "are we allowed to swap letters more than once?\\nit\\'s confusing"
                    },
                    {
                        "username": "user7784PS",
                        "content": "Cringe."
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "A pretty decent question\\nReally forced me to think about many edge cases that I initially missed."
                    }
                ]
            },
            {
                "id": 1779804,
                "content": [
                    {
                        "username": "Shi-Yueyang",
                        "content": "I hate this type of problem"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be careful with the test case \"ab\" and \"babbb\".\\n\\nIn my humble opinion, adding test cases for inputs with different lengths does not add any value to this problem because it is extremely easy to solve but it is quite annoying to see submission failing because of this \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "sheikh_abir_ali",
                        "content": "**Working Fine Everywhere but giving false in TC 15 :!**\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if s == goal[::-1]:\\n            return \"true\"\\n        else:\\n            return \"false\"\\n```"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "You are simply checking if `s` and `goal` are palindrome or not. How does that check for buddy condition?"
                    },
                    {
                        "username": "Carlosx7",
                        "content": "could you post which is the input for TC 15??"
                    },
                    {
                        "username": "cracy",
                        "content": "For example \"aa\", \"ab\". My first submission didn\\'t check for that but still got accepted."
                    },
                    {
                        "username": "ursachu",
                        "content": "I dont like this question. It seems irrelevant"
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was asshole"
                    },
                    {
                        "username": "kiduse0911",
                        "content": "man, this is a confusing question. Plus the test cases are not that helpful"
                    },
                    {
                        "username": "woofer_employ_0r",
                        "content": "are we allowed to swap letters more than once?\\nit\\'s confusing"
                    },
                    {
                        "username": "user7784PS",
                        "content": "Cringe."
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "A pretty decent question\\nReally forced me to think about many edge cases that I initially missed."
                    }
                ]
            },
            {
                "id": 1703322,
                "content": [
                    {
                        "username": "Shi-Yueyang",
                        "content": "I hate this type of problem"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be careful with the test case \"ab\" and \"babbb\".\\n\\nIn my humble opinion, adding test cases for inputs with different lengths does not add any value to this problem because it is extremely easy to solve but it is quite annoying to see submission failing because of this \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "sheikh_abir_ali",
                        "content": "**Working Fine Everywhere but giving false in TC 15 :!**\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if s == goal[::-1]:\\n            return \"true\"\\n        else:\\n            return \"false\"\\n```"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "You are simply checking if `s` and `goal` are palindrome or not. How does that check for buddy condition?"
                    },
                    {
                        "username": "Carlosx7",
                        "content": "could you post which is the input for TC 15??"
                    },
                    {
                        "username": "cracy",
                        "content": "For example \"aa\", \"ab\". My first submission didn\\'t check for that but still got accepted."
                    },
                    {
                        "username": "ursachu",
                        "content": "I dont like this question. It seems irrelevant"
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was asshole"
                    },
                    {
                        "username": "kiduse0911",
                        "content": "man, this is a confusing question. Plus the test cases are not that helpful"
                    },
                    {
                        "username": "woofer_employ_0r",
                        "content": "are we allowed to swap letters more than once?\\nit\\'s confusing"
                    },
                    {
                        "username": "user7784PS",
                        "content": "Cringe."
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "A pretty decent question\\nReally forced me to think about many edge cases that I initially missed."
                    }
                ]
            },
            {
                "id": 1572155,
                "content": [
                    {
                        "username": "Shi-Yueyang",
                        "content": "I hate this type of problem"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be careful with the test case \"ab\" and \"babbb\".\\n\\nIn my humble opinion, adding test cases for inputs with different lengths does not add any value to this problem because it is extremely easy to solve but it is quite annoying to see submission failing because of this \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "sheikh_abir_ali",
                        "content": "**Working Fine Everywhere but giving false in TC 15 :!**\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if s == goal[::-1]:\\n            return \"true\"\\n        else:\\n            return \"false\"\\n```"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "You are simply checking if `s` and `goal` are palindrome or not. How does that check for buddy condition?"
                    },
                    {
                        "username": "Carlosx7",
                        "content": "could you post which is the input for TC 15??"
                    },
                    {
                        "username": "cracy",
                        "content": "For example \"aa\", \"ab\". My first submission didn\\'t check for that but still got accepted."
                    },
                    {
                        "username": "ursachu",
                        "content": "I dont like this question. It seems irrelevant"
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was asshole"
                    },
                    {
                        "username": "kiduse0911",
                        "content": "man, this is a confusing question. Plus the test cases are not that helpful"
                    },
                    {
                        "username": "woofer_employ_0r",
                        "content": "are we allowed to swap letters more than once?\\nit\\'s confusing"
                    },
                    {
                        "username": "user7784PS",
                        "content": "Cringe."
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "A pretty decent question\\nReally forced me to think about many edge cases that I initially missed."
                    }
                ]
            },
            {
                "id": 1950110,
                "content": [
                    {
                        "username": "Shi-Yueyang",
                        "content": "I hate this type of problem"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be careful with the test case \"ab\" and \"babbb\".\\n\\nIn my humble opinion, adding test cases for inputs with different lengths does not add any value to this problem because it is extremely easy to solve but it is quite annoying to see submission failing because of this \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "sheikh_abir_ali",
                        "content": "**Working Fine Everywhere but giving false in TC 15 :!**\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if s == goal[::-1]:\\n            return \"true\"\\n        else:\\n            return \"false\"\\n```"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "You are simply checking if `s` and `goal` are palindrome or not. How does that check for buddy condition?"
                    },
                    {
                        "username": "Carlosx7",
                        "content": "could you post which is the input for TC 15??"
                    },
                    {
                        "username": "cracy",
                        "content": "For example \"aa\", \"ab\". My first submission didn\\'t check for that but still got accepted."
                    },
                    {
                        "username": "ursachu",
                        "content": "I dont like this question. It seems irrelevant"
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was asshole"
                    },
                    {
                        "username": "kiduse0911",
                        "content": "man, this is a confusing question. Plus the test cases are not that helpful"
                    },
                    {
                        "username": "woofer_employ_0r",
                        "content": "are we allowed to swap letters more than once?\\nit\\'s confusing"
                    },
                    {
                        "username": "user7784PS",
                        "content": "Cringe."
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "A pretty decent question\\nReally forced me to think about many edge cases that I initially missed."
                    }
                ]
            },
            {
                "id": 2068882,
                "content": [
                    {
                        "username": "Shi-Yueyang",
                        "content": "I hate this type of problem"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be careful with the test case \"ab\" and \"babbb\".\\n\\nIn my humble opinion, adding test cases for inputs with different lengths does not add any value to this problem because it is extremely easy to solve but it is quite annoying to see submission failing because of this \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "sheikh_abir_ali",
                        "content": "**Working Fine Everywhere but giving false in TC 15 :!**\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if s == goal[::-1]:\\n            return \"true\"\\n        else:\\n            return \"false\"\\n```"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "You are simply checking if `s` and `goal` are palindrome or not. How does that check for buddy condition?"
                    },
                    {
                        "username": "Carlosx7",
                        "content": "could you post which is the input for TC 15??"
                    },
                    {
                        "username": "cracy",
                        "content": "For example \"aa\", \"ab\". My first submission didn\\'t check for that but still got accepted."
                    },
                    {
                        "username": "ursachu",
                        "content": "I dont like this question. It seems irrelevant"
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was asshole"
                    },
                    {
                        "username": "kiduse0911",
                        "content": "man, this is a confusing question. Plus the test cases are not that helpful"
                    },
                    {
                        "username": "woofer_employ_0r",
                        "content": "are we allowed to swap letters more than once?\\nit\\'s confusing"
                    },
                    {
                        "username": "user7784PS",
                        "content": "Cringe."
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "A pretty decent question\\nReally forced me to think about many edge cases that I initially missed."
                    }
                ]
            },
            {
                "id": 2034906,
                "content": [
                    {
                        "username": "Shi-Yueyang",
                        "content": "I hate this type of problem"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be careful with the test case \"ab\" and \"babbb\".\\n\\nIn my humble opinion, adding test cases for inputs with different lengths does not add any value to this problem because it is extremely easy to solve but it is quite annoying to see submission failing because of this \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "sheikh_abir_ali",
                        "content": "**Working Fine Everywhere but giving false in TC 15 :!**\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if s == goal[::-1]:\\n            return \"true\"\\n        else:\\n            return \"false\"\\n```"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "You are simply checking if `s` and `goal` are palindrome or not. How does that check for buddy condition?"
                    },
                    {
                        "username": "Carlosx7",
                        "content": "could you post which is the input for TC 15??"
                    },
                    {
                        "username": "cracy",
                        "content": "For example \"aa\", \"ab\". My first submission didn\\'t check for that but still got accepted."
                    },
                    {
                        "username": "ursachu",
                        "content": "I dont like this question. It seems irrelevant"
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was asshole"
                    },
                    {
                        "username": "kiduse0911",
                        "content": "man, this is a confusing question. Plus the test cases are not that helpful"
                    },
                    {
                        "username": "woofer_employ_0r",
                        "content": "are we allowed to swap letters more than once?\\nit\\'s confusing"
                    },
                    {
                        "username": "user7784PS",
                        "content": "Cringe."
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "A pretty decent question\\nReally forced me to think about many edge cases that I initially missed."
                    }
                ]
            },
            {
                "id": 2010200,
                "content": [
                    {
                        "username": "Shi-Yueyang",
                        "content": "I hate this type of problem"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be careful with the test case \"ab\" and \"babbb\".\\n\\nIn my humble opinion, adding test cases for inputs with different lengths does not add any value to this problem because it is extremely easy to solve but it is quite annoying to see submission failing because of this \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "sheikh_abir_ali",
                        "content": "**Working Fine Everywhere but giving false in TC 15 :!**\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if s == goal[::-1]:\\n            return \"true\"\\n        else:\\n            return \"false\"\\n```"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "You are simply checking if `s` and `goal` are palindrome or not. How does that check for buddy condition?"
                    },
                    {
                        "username": "Carlosx7",
                        "content": "could you post which is the input for TC 15??"
                    },
                    {
                        "username": "cracy",
                        "content": "For example \"aa\", \"ab\". My first submission didn\\'t check for that but still got accepted."
                    },
                    {
                        "username": "ursachu",
                        "content": "I dont like this question. It seems irrelevant"
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was asshole"
                    },
                    {
                        "username": "kiduse0911",
                        "content": "man, this is a confusing question. Plus the test cases are not that helpful"
                    },
                    {
                        "username": "woofer_employ_0r",
                        "content": "are we allowed to swap letters more than once?\\nit\\'s confusing"
                    },
                    {
                        "username": "user7784PS",
                        "content": "Cringe."
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "A pretty decent question\\nReally forced me to think about many edge cases that I initially missed."
                    }
                ]
            },
            {
                "id": 1986372,
                "content": [
                    {
                        "username": "Shi-Yueyang",
                        "content": "I hate this type of problem"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be careful with the test case \"ab\" and \"babbb\".\\n\\nIn my humble opinion, adding test cases for inputs with different lengths does not add any value to this problem because it is extremely easy to solve but it is quite annoying to see submission failing because of this \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "sheikh_abir_ali",
                        "content": "**Working Fine Everywhere but giving false in TC 15 :!**\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if s == goal[::-1]:\\n            return \"true\"\\n        else:\\n            return \"false\"\\n```"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "You are simply checking if `s` and `goal` are palindrome or not. How does that check for buddy condition?"
                    },
                    {
                        "username": "Carlosx7",
                        "content": "could you post which is the input for TC 15??"
                    },
                    {
                        "username": "cracy",
                        "content": "For example \"aa\", \"ab\". My first submission didn\\'t check for that but still got accepted."
                    },
                    {
                        "username": "ursachu",
                        "content": "I dont like this question. It seems irrelevant"
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was asshole"
                    },
                    {
                        "username": "kiduse0911",
                        "content": "man, this is a confusing question. Plus the test cases are not that helpful"
                    },
                    {
                        "username": "woofer_employ_0r",
                        "content": "are we allowed to swap letters more than once?\\nit\\'s confusing"
                    },
                    {
                        "username": "user7784PS",
                        "content": "Cringe."
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "A pretty decent question\\nReally forced me to think about many edge cases that I initially missed."
                    }
                ]
            },
            {
                "id": 1985664,
                "content": [
                    {
                        "username": "Shi-Yueyang",
                        "content": "I hate this type of problem"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be careful with the test case \"ab\" and \"babbb\".\\n\\nIn my humble opinion, adding test cases for inputs with different lengths does not add any value to this problem because it is extremely easy to solve but it is quite annoying to see submission failing because of this \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "sheikh_abir_ali",
                        "content": "**Working Fine Everywhere but giving false in TC 15 :!**\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if s == goal[::-1]:\\n            return \"true\"\\n        else:\\n            return \"false\"\\n```"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "You are simply checking if `s` and `goal` are palindrome or not. How does that check for buddy condition?"
                    },
                    {
                        "username": "Carlosx7",
                        "content": "could you post which is the input for TC 15??"
                    },
                    {
                        "username": "cracy",
                        "content": "For example \"aa\", \"ab\". My first submission didn\\'t check for that but still got accepted."
                    },
                    {
                        "username": "ursachu",
                        "content": "I dont like this question. It seems irrelevant"
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was asshole"
                    },
                    {
                        "username": "kiduse0911",
                        "content": "man, this is a confusing question. Plus the test cases are not that helpful"
                    },
                    {
                        "username": "woofer_employ_0r",
                        "content": "are we allowed to swap letters more than once?\\nit\\'s confusing"
                    },
                    {
                        "username": "user7784PS",
                        "content": "Cringe."
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "A pretty decent question\\nReally forced me to think about many edge cases that I initially missed."
                    }
                ]
            },
            {
                "id": 1984496,
                "content": [
                    {
                        "username": "steuxnet",
                        "content": "This is a good Question and surely doesn\\'t qualify for easy, it is medium."
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "Anyone having issue with aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "keithdtyler",
                        "content": "There is zero algorithmic reason for the arbitrary time limit on execution time. This is just a hackishly designed exercise criteria -- UNSTATED mind you -- to stymie the obvious solution.\\n\\nThere is no reason why the obvious solution is not suitable. It\\'s a cheap, dirty, unnecessary, and unrealistic trap. If the target system was expected to handle large strings with large similarities, the system would be designed accordingly. The \"gotcha\" test is hidden until submission.\\n\\nJust plain dirty pool and the creator of the exercise should be ashamed, but probably thinks they\\'re clever."
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "This questions has lot of edge cases"
                    },
                    {
                        "username": "sandthorn",
                        "content": "I find that the submission profiling inconsistent in both speed and memory measures. Is that normal?"
                    },
                    {
                        "username": "Bhaskybaba",
                        "content": "I do not understand why my solution is failing in leetcode but working fine in ide:\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because leetcode have Time and memory constraints "
                    },
                    {
                        "username": "aftab0711",
                        "content": "I solved this question in one my first attempt only, but this question should me marked as medium level."
                    },
                    {
                        "username": "Belyua",
                        "content": "why Input: s = \"ab\", goal = \"ab\" should give False, but s =\"abab\" goal = \"abab\" should give true???"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Ashish_4k](/Ashish_4k)  since we need to do one swap and in 2nd string you can swap a with a which is not possible in 1st string "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Because we need at least one char to swap so for no duplicate string it will always return false "
                    },
                    {
                        "username": "t_Mz",
                        "content": "finally submitted in 4th attempt.... lesssgoooo"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "what should be the optimial run time complexity?"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I guess linear"
                    }
                ]
            },
            {
                "id": 1961057,
                "content": [
                    {
                        "username": "steuxnet",
                        "content": "This is a good Question and surely doesn\\'t qualify for easy, it is medium."
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "Anyone having issue with aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "keithdtyler",
                        "content": "There is zero algorithmic reason for the arbitrary time limit on execution time. This is just a hackishly designed exercise criteria -- UNSTATED mind you -- to stymie the obvious solution.\\n\\nThere is no reason why the obvious solution is not suitable. It\\'s a cheap, dirty, unnecessary, and unrealistic trap. If the target system was expected to handle large strings with large similarities, the system would be designed accordingly. The \"gotcha\" test is hidden until submission.\\n\\nJust plain dirty pool and the creator of the exercise should be ashamed, but probably thinks they\\'re clever."
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "This questions has lot of edge cases"
                    },
                    {
                        "username": "sandthorn",
                        "content": "I find that the submission profiling inconsistent in both speed and memory measures. Is that normal?"
                    },
                    {
                        "username": "Bhaskybaba",
                        "content": "I do not understand why my solution is failing in leetcode but working fine in ide:\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because leetcode have Time and memory constraints "
                    },
                    {
                        "username": "aftab0711",
                        "content": "I solved this question in one my first attempt only, but this question should me marked as medium level."
                    },
                    {
                        "username": "Belyua",
                        "content": "why Input: s = \"ab\", goal = \"ab\" should give False, but s =\"abab\" goal = \"abab\" should give true???"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Ashish_4k](/Ashish_4k)  since we need to do one swap and in 2nd string you can swap a with a which is not possible in 1st string "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Because we need at least one char to swap so for no duplicate string it will always return false "
                    },
                    {
                        "username": "t_Mz",
                        "content": "finally submitted in 4th attempt.... lesssgoooo"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "what should be the optimial run time complexity?"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I guess linear"
                    }
                ]
            },
            {
                "id": 1958339,
                "content": [
                    {
                        "username": "steuxnet",
                        "content": "This is a good Question and surely doesn\\'t qualify for easy, it is medium."
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "Anyone having issue with aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "keithdtyler",
                        "content": "There is zero algorithmic reason for the arbitrary time limit on execution time. This is just a hackishly designed exercise criteria -- UNSTATED mind you -- to stymie the obvious solution.\\n\\nThere is no reason why the obvious solution is not suitable. It\\'s a cheap, dirty, unnecessary, and unrealistic trap. If the target system was expected to handle large strings with large similarities, the system would be designed accordingly. The \"gotcha\" test is hidden until submission.\\n\\nJust plain dirty pool and the creator of the exercise should be ashamed, but probably thinks they\\'re clever."
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "This questions has lot of edge cases"
                    },
                    {
                        "username": "sandthorn",
                        "content": "I find that the submission profiling inconsistent in both speed and memory measures. Is that normal?"
                    },
                    {
                        "username": "Bhaskybaba",
                        "content": "I do not understand why my solution is failing in leetcode but working fine in ide:\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because leetcode have Time and memory constraints "
                    },
                    {
                        "username": "aftab0711",
                        "content": "I solved this question in one my first attempt only, but this question should me marked as medium level."
                    },
                    {
                        "username": "Belyua",
                        "content": "why Input: s = \"ab\", goal = \"ab\" should give False, but s =\"abab\" goal = \"abab\" should give true???"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Ashish_4k](/Ashish_4k)  since we need to do one swap and in 2nd string you can swap a with a which is not possible in 1st string "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Because we need at least one char to swap so for no duplicate string it will always return false "
                    },
                    {
                        "username": "t_Mz",
                        "content": "finally submitted in 4th attempt.... lesssgoooo"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "what should be the optimial run time complexity?"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I guess linear"
                    }
                ]
            },
            {
                "id": 1956134,
                "content": [
                    {
                        "username": "steuxnet",
                        "content": "This is a good Question and surely doesn\\'t qualify for easy, it is medium."
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "Anyone having issue with aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "keithdtyler",
                        "content": "There is zero algorithmic reason for the arbitrary time limit on execution time. This is just a hackishly designed exercise criteria -- UNSTATED mind you -- to stymie the obvious solution.\\n\\nThere is no reason why the obvious solution is not suitable. It\\'s a cheap, dirty, unnecessary, and unrealistic trap. If the target system was expected to handle large strings with large similarities, the system would be designed accordingly. The \"gotcha\" test is hidden until submission.\\n\\nJust plain dirty pool and the creator of the exercise should be ashamed, but probably thinks they\\'re clever."
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "This questions has lot of edge cases"
                    },
                    {
                        "username": "sandthorn",
                        "content": "I find that the submission profiling inconsistent in both speed and memory measures. Is that normal?"
                    },
                    {
                        "username": "Bhaskybaba",
                        "content": "I do not understand why my solution is failing in leetcode but working fine in ide:\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because leetcode have Time and memory constraints "
                    },
                    {
                        "username": "aftab0711",
                        "content": "I solved this question in one my first attempt only, but this question should me marked as medium level."
                    },
                    {
                        "username": "Belyua",
                        "content": "why Input: s = \"ab\", goal = \"ab\" should give False, but s =\"abab\" goal = \"abab\" should give true???"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Ashish_4k](/Ashish_4k)  since we need to do one swap and in 2nd string you can swap a with a which is not possible in 1st string "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Because we need at least one char to swap so for no duplicate string it will always return false "
                    },
                    {
                        "username": "t_Mz",
                        "content": "finally submitted in 4th attempt.... lesssgoooo"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "what should be the optimial run time complexity?"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I guess linear"
                    }
                ]
            },
            {
                "id": 1955523,
                "content": [
                    {
                        "username": "steuxnet",
                        "content": "This is a good Question and surely doesn\\'t qualify for easy, it is medium."
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "Anyone having issue with aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "keithdtyler",
                        "content": "There is zero algorithmic reason for the arbitrary time limit on execution time. This is just a hackishly designed exercise criteria -- UNSTATED mind you -- to stymie the obvious solution.\\n\\nThere is no reason why the obvious solution is not suitable. It\\'s a cheap, dirty, unnecessary, and unrealistic trap. If the target system was expected to handle large strings with large similarities, the system would be designed accordingly. The \"gotcha\" test is hidden until submission.\\n\\nJust plain dirty pool and the creator of the exercise should be ashamed, but probably thinks they\\'re clever."
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "This questions has lot of edge cases"
                    },
                    {
                        "username": "sandthorn",
                        "content": "I find that the submission profiling inconsistent in both speed and memory measures. Is that normal?"
                    },
                    {
                        "username": "Bhaskybaba",
                        "content": "I do not understand why my solution is failing in leetcode but working fine in ide:\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because leetcode have Time and memory constraints "
                    },
                    {
                        "username": "aftab0711",
                        "content": "I solved this question in one my first attempt only, but this question should me marked as medium level."
                    },
                    {
                        "username": "Belyua",
                        "content": "why Input: s = \"ab\", goal = \"ab\" should give False, but s =\"abab\" goal = \"abab\" should give true???"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Ashish_4k](/Ashish_4k)  since we need to do one swap and in 2nd string you can swap a with a which is not possible in 1st string "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Because we need at least one char to swap so for no duplicate string it will always return false "
                    },
                    {
                        "username": "t_Mz",
                        "content": "finally submitted in 4th attempt.... lesssgoooo"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "what should be the optimial run time complexity?"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I guess linear"
                    }
                ]
            },
            {
                "id": 1955246,
                "content": [
                    {
                        "username": "steuxnet",
                        "content": "This is a good Question and surely doesn\\'t qualify for easy, it is medium."
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "Anyone having issue with aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "keithdtyler",
                        "content": "There is zero algorithmic reason for the arbitrary time limit on execution time. This is just a hackishly designed exercise criteria -- UNSTATED mind you -- to stymie the obvious solution.\\n\\nThere is no reason why the obvious solution is not suitable. It\\'s a cheap, dirty, unnecessary, and unrealistic trap. If the target system was expected to handle large strings with large similarities, the system would be designed accordingly. The \"gotcha\" test is hidden until submission.\\n\\nJust plain dirty pool and the creator of the exercise should be ashamed, but probably thinks they\\'re clever."
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "This questions has lot of edge cases"
                    },
                    {
                        "username": "sandthorn",
                        "content": "I find that the submission profiling inconsistent in both speed and memory measures. Is that normal?"
                    },
                    {
                        "username": "Bhaskybaba",
                        "content": "I do not understand why my solution is failing in leetcode but working fine in ide:\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because leetcode have Time and memory constraints "
                    },
                    {
                        "username": "aftab0711",
                        "content": "I solved this question in one my first attempt only, but this question should me marked as medium level."
                    },
                    {
                        "username": "Belyua",
                        "content": "why Input: s = \"ab\", goal = \"ab\" should give False, but s =\"abab\" goal = \"abab\" should give true???"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Ashish_4k](/Ashish_4k)  since we need to do one swap and in 2nd string you can swap a with a which is not possible in 1st string "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Because we need at least one char to swap so for no duplicate string it will always return false "
                    },
                    {
                        "username": "t_Mz",
                        "content": "finally submitted in 4th attempt.... lesssgoooo"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "what should be the optimial run time complexity?"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I guess linear"
                    }
                ]
            },
            {
                "id": 1955208,
                "content": [
                    {
                        "username": "steuxnet",
                        "content": "This is a good Question and surely doesn\\'t qualify for easy, it is medium."
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "Anyone having issue with aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "keithdtyler",
                        "content": "There is zero algorithmic reason for the arbitrary time limit on execution time. This is just a hackishly designed exercise criteria -- UNSTATED mind you -- to stymie the obvious solution.\\n\\nThere is no reason why the obvious solution is not suitable. It\\'s a cheap, dirty, unnecessary, and unrealistic trap. If the target system was expected to handle large strings with large similarities, the system would be designed accordingly. The \"gotcha\" test is hidden until submission.\\n\\nJust plain dirty pool and the creator of the exercise should be ashamed, but probably thinks they\\'re clever."
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "This questions has lot of edge cases"
                    },
                    {
                        "username": "sandthorn",
                        "content": "I find that the submission profiling inconsistent in both speed and memory measures. Is that normal?"
                    },
                    {
                        "username": "Bhaskybaba",
                        "content": "I do not understand why my solution is failing in leetcode but working fine in ide:\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because leetcode have Time and memory constraints "
                    },
                    {
                        "username": "aftab0711",
                        "content": "I solved this question in one my first attempt only, but this question should me marked as medium level."
                    },
                    {
                        "username": "Belyua",
                        "content": "why Input: s = \"ab\", goal = \"ab\" should give False, but s =\"abab\" goal = \"abab\" should give true???"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Ashish_4k](/Ashish_4k)  since we need to do one swap and in 2nd string you can swap a with a which is not possible in 1st string "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Because we need at least one char to swap so for no duplicate string it will always return false "
                    },
                    {
                        "username": "t_Mz",
                        "content": "finally submitted in 4th attempt.... lesssgoooo"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "what should be the optimial run time complexity?"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I guess linear"
                    }
                ]
            },
            {
                "id": 1955162,
                "content": [
                    {
                        "username": "steuxnet",
                        "content": "This is a good Question and surely doesn\\'t qualify for easy, it is medium."
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "Anyone having issue with aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "keithdtyler",
                        "content": "There is zero algorithmic reason for the arbitrary time limit on execution time. This is just a hackishly designed exercise criteria -- UNSTATED mind you -- to stymie the obvious solution.\\n\\nThere is no reason why the obvious solution is not suitable. It\\'s a cheap, dirty, unnecessary, and unrealistic trap. If the target system was expected to handle large strings with large similarities, the system would be designed accordingly. The \"gotcha\" test is hidden until submission.\\n\\nJust plain dirty pool and the creator of the exercise should be ashamed, but probably thinks they\\'re clever."
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "This questions has lot of edge cases"
                    },
                    {
                        "username": "sandthorn",
                        "content": "I find that the submission profiling inconsistent in both speed and memory measures. Is that normal?"
                    },
                    {
                        "username": "Bhaskybaba",
                        "content": "I do not understand why my solution is failing in leetcode but working fine in ide:\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because leetcode have Time and memory constraints "
                    },
                    {
                        "username": "aftab0711",
                        "content": "I solved this question in one my first attempt only, but this question should me marked as medium level."
                    },
                    {
                        "username": "Belyua",
                        "content": "why Input: s = \"ab\", goal = \"ab\" should give False, but s =\"abab\" goal = \"abab\" should give true???"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Ashish_4k](/Ashish_4k)  since we need to do one swap and in 2nd string you can swap a with a which is not possible in 1st string "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Because we need at least one char to swap so for no duplicate string it will always return false "
                    },
                    {
                        "username": "t_Mz",
                        "content": "finally submitted in 4th attempt.... lesssgoooo"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "what should be the optimial run time complexity?"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I guess linear"
                    }
                ]
            },
            {
                "id": 1955108,
                "content": [
                    {
                        "username": "steuxnet",
                        "content": "This is a good Question and surely doesn\\'t qualify for easy, it is medium."
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "Anyone having issue with aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "keithdtyler",
                        "content": "There is zero algorithmic reason for the arbitrary time limit on execution time. This is just a hackishly designed exercise criteria -- UNSTATED mind you -- to stymie the obvious solution.\\n\\nThere is no reason why the obvious solution is not suitable. It\\'s a cheap, dirty, unnecessary, and unrealistic trap. If the target system was expected to handle large strings with large similarities, the system would be designed accordingly. The \"gotcha\" test is hidden until submission.\\n\\nJust plain dirty pool and the creator of the exercise should be ashamed, but probably thinks they\\'re clever."
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "This questions has lot of edge cases"
                    },
                    {
                        "username": "sandthorn",
                        "content": "I find that the submission profiling inconsistent in both speed and memory measures. Is that normal?"
                    },
                    {
                        "username": "Bhaskybaba",
                        "content": "I do not understand why my solution is failing in leetcode but working fine in ide:\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because leetcode have Time and memory constraints "
                    },
                    {
                        "username": "aftab0711",
                        "content": "I solved this question in one my first attempt only, but this question should me marked as medium level."
                    },
                    {
                        "username": "Belyua",
                        "content": "why Input: s = \"ab\", goal = \"ab\" should give False, but s =\"abab\" goal = \"abab\" should give true???"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Ashish_4k](/Ashish_4k)  since we need to do one swap and in 2nd string you can swap a with a which is not possible in 1st string "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Because we need at least one char to swap so for no duplicate string it will always return false "
                    },
                    {
                        "username": "t_Mz",
                        "content": "finally submitted in 4th attempt.... lesssgoooo"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "what should be the optimial run time complexity?"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I guess linear"
                    }
                ]
            },
            {
                "id": 1954987,
                "content": [
                    {
                        "username": "steuxnet",
                        "content": "This is a good Question and surely doesn\\'t qualify for easy, it is medium."
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "Anyone having issue with aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "keithdtyler",
                        "content": "There is zero algorithmic reason for the arbitrary time limit on execution time. This is just a hackishly designed exercise criteria -- UNSTATED mind you -- to stymie the obvious solution.\\n\\nThere is no reason why the obvious solution is not suitable. It\\'s a cheap, dirty, unnecessary, and unrealistic trap. If the target system was expected to handle large strings with large similarities, the system would be designed accordingly. The \"gotcha\" test is hidden until submission.\\n\\nJust plain dirty pool and the creator of the exercise should be ashamed, but probably thinks they\\'re clever."
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "This questions has lot of edge cases"
                    },
                    {
                        "username": "sandthorn",
                        "content": "I find that the submission profiling inconsistent in both speed and memory measures. Is that normal?"
                    },
                    {
                        "username": "Bhaskybaba",
                        "content": "I do not understand why my solution is failing in leetcode but working fine in ide:\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because leetcode have Time and memory constraints "
                    },
                    {
                        "username": "aftab0711",
                        "content": "I solved this question in one my first attempt only, but this question should me marked as medium level."
                    },
                    {
                        "username": "Belyua",
                        "content": "why Input: s = \"ab\", goal = \"ab\" should give False, but s =\"abab\" goal = \"abab\" should give true???"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Ashish_4k](/Ashish_4k)  since we need to do one swap and in 2nd string you can swap a with a which is not possible in 1st string "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Because we need at least one char to swap so for no duplicate string it will always return false "
                    },
                    {
                        "username": "t_Mz",
                        "content": "finally submitted in 4th attempt.... lesssgoooo"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "what should be the optimial run time complexity?"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I guess linear"
                    }
                ]
            },
            {
                "id": 1954982,
                "content": [
                    {
                        "username": "qwsazi",
                        "content": "this submit testcases are torture"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I think its a easy question simply because of test cases . They are small to its easy to find error .\\nYou just have to take care of following condition:-\\n1. If strings are of different length return False\\n2. If string are exactly equal and all character are unique then return false, if there are repeating character then return True\\n3.If string are of same length but not equal than cheak if the number of different element is other than  2 , return False.\\nElse if it is 2 then cheak if swapping makes the two the string equal or not .\\nThanks and have a error free day."
                    },
                    {
                        "username": "patrickallard",
                        "content": "Do not let the Easy label fool you. Although the problem is accurately graded, it will require more thought and patience than what you might expect an easy problem to require. It took me awhile to come up with a solution--it ended up being more involved than I had anticipated. My issue was that I kept switching between two different methods, only until the end realizing that the solution required the use of both. "
                    },
                    {
                        "username": "ogcooke",
                        "content": "I got really confused about the output format in Python. Some type hints would be nice"
                    },
                    {
                        "username": "kareena29",
                        "content": "Calling it easy? Actuallyy? "
                    },
                    {
                        "username": "im-naime",
                        "content": "WOW, I cracked it on my initial try!"
                    },
                    {
                        "username": "mmtemel",
                        "content": "By the way it is not easy, not even closer!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Why the text tells me this is a DP problem.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "not really a dp but more corner cases to handle genrally we see problems with pre handled cases here it\\'s not there that\\'s why tricky."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "get ready for dp and graph questions. :)"
                    },
                    {
                        "username": "ulalit_2728",
                        "content": "We have to swap two letters at a time, so is swapping only allowed once or can swap multiple times?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "only once "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "only once"
                    }
                ]
            },
            {
                "id": 1954956,
                "content": [
                    {
                        "username": "qwsazi",
                        "content": "this submit testcases are torture"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I think its a easy question simply because of test cases . They are small to its easy to find error .\\nYou just have to take care of following condition:-\\n1. If strings are of different length return False\\n2. If string are exactly equal and all character are unique then return false, if there are repeating character then return True\\n3.If string are of same length but not equal than cheak if the number of different element is other than  2 , return False.\\nElse if it is 2 then cheak if swapping makes the two the string equal or not .\\nThanks and have a error free day."
                    },
                    {
                        "username": "patrickallard",
                        "content": "Do not let the Easy label fool you. Although the problem is accurately graded, it will require more thought and patience than what you might expect an easy problem to require. It took me awhile to come up with a solution--it ended up being more involved than I had anticipated. My issue was that I kept switching between two different methods, only until the end realizing that the solution required the use of both. "
                    },
                    {
                        "username": "ogcooke",
                        "content": "I got really confused about the output format in Python. Some type hints would be nice"
                    },
                    {
                        "username": "kareena29",
                        "content": "Calling it easy? Actuallyy? "
                    },
                    {
                        "username": "im-naime",
                        "content": "WOW, I cracked it on my initial try!"
                    },
                    {
                        "username": "mmtemel",
                        "content": "By the way it is not easy, not even closer!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Why the text tells me this is a DP problem.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "not really a dp but more corner cases to handle genrally we see problems with pre handled cases here it\\'s not there that\\'s why tricky."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "get ready for dp and graph questions. :)"
                    },
                    {
                        "username": "ulalit_2728",
                        "content": "We have to swap two letters at a time, so is swapping only allowed once or can swap multiple times?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "only once "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "only once"
                    }
                ]
            },
            {
                "id": 1954890,
                "content": [
                    {
                        "username": "qwsazi",
                        "content": "this submit testcases are torture"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I think its a easy question simply because of test cases . They are small to its easy to find error .\\nYou just have to take care of following condition:-\\n1. If strings are of different length return False\\n2. If string are exactly equal and all character are unique then return false, if there are repeating character then return True\\n3.If string are of same length but not equal than cheak if the number of different element is other than  2 , return False.\\nElse if it is 2 then cheak if swapping makes the two the string equal or not .\\nThanks and have a error free day."
                    },
                    {
                        "username": "patrickallard",
                        "content": "Do not let the Easy label fool you. Although the problem is accurately graded, it will require more thought and patience than what you might expect an easy problem to require. It took me awhile to come up with a solution--it ended up being more involved than I had anticipated. My issue was that I kept switching between two different methods, only until the end realizing that the solution required the use of both. "
                    },
                    {
                        "username": "ogcooke",
                        "content": "I got really confused about the output format in Python. Some type hints would be nice"
                    },
                    {
                        "username": "kareena29",
                        "content": "Calling it easy? Actuallyy? "
                    },
                    {
                        "username": "im-naime",
                        "content": "WOW, I cracked it on my initial try!"
                    },
                    {
                        "username": "mmtemel",
                        "content": "By the way it is not easy, not even closer!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Why the text tells me this is a DP problem.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "not really a dp but more corner cases to handle genrally we see problems with pre handled cases here it\\'s not there that\\'s why tricky."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "get ready for dp and graph questions. :)"
                    },
                    {
                        "username": "ulalit_2728",
                        "content": "We have to swap two letters at a time, so is swapping only allowed once or can swap multiple times?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "only once "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "only once"
                    }
                ]
            },
            {
                "id": 1954760,
                "content": [
                    {
                        "username": "qwsazi",
                        "content": "this submit testcases are torture"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I think its a easy question simply because of test cases . They are small to its easy to find error .\\nYou just have to take care of following condition:-\\n1. If strings are of different length return False\\n2. If string are exactly equal and all character are unique then return false, if there are repeating character then return True\\n3.If string are of same length but not equal than cheak if the number of different element is other than  2 , return False.\\nElse if it is 2 then cheak if swapping makes the two the string equal or not .\\nThanks and have a error free day."
                    },
                    {
                        "username": "patrickallard",
                        "content": "Do not let the Easy label fool you. Although the problem is accurately graded, it will require more thought and patience than what you might expect an easy problem to require. It took me awhile to come up with a solution--it ended up being more involved than I had anticipated. My issue was that I kept switching between two different methods, only until the end realizing that the solution required the use of both. "
                    },
                    {
                        "username": "ogcooke",
                        "content": "I got really confused about the output format in Python. Some type hints would be nice"
                    },
                    {
                        "username": "kareena29",
                        "content": "Calling it easy? Actuallyy? "
                    },
                    {
                        "username": "im-naime",
                        "content": "WOW, I cracked it on my initial try!"
                    },
                    {
                        "username": "mmtemel",
                        "content": "By the way it is not easy, not even closer!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Why the text tells me this is a DP problem.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "not really a dp but more corner cases to handle genrally we see problems with pre handled cases here it\\'s not there that\\'s why tricky."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "get ready for dp and graph questions. :)"
                    },
                    {
                        "username": "ulalit_2728",
                        "content": "We have to swap two letters at a time, so is swapping only allowed once or can swap multiple times?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "only once "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "only once"
                    }
                ]
            },
            {
                "id": 1954744,
                "content": [
                    {
                        "username": "qwsazi",
                        "content": "this submit testcases are torture"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I think its a easy question simply because of test cases . They are small to its easy to find error .\\nYou just have to take care of following condition:-\\n1. If strings are of different length return False\\n2. If string are exactly equal and all character are unique then return false, if there are repeating character then return True\\n3.If string are of same length but not equal than cheak if the number of different element is other than  2 , return False.\\nElse if it is 2 then cheak if swapping makes the two the string equal or not .\\nThanks and have a error free day."
                    },
                    {
                        "username": "patrickallard",
                        "content": "Do not let the Easy label fool you. Although the problem is accurately graded, it will require more thought and patience than what you might expect an easy problem to require. It took me awhile to come up with a solution--it ended up being more involved than I had anticipated. My issue was that I kept switching between two different methods, only until the end realizing that the solution required the use of both. "
                    },
                    {
                        "username": "ogcooke",
                        "content": "I got really confused about the output format in Python. Some type hints would be nice"
                    },
                    {
                        "username": "kareena29",
                        "content": "Calling it easy? Actuallyy? "
                    },
                    {
                        "username": "im-naime",
                        "content": "WOW, I cracked it on my initial try!"
                    },
                    {
                        "username": "mmtemel",
                        "content": "By the way it is not easy, not even closer!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Why the text tells me this is a DP problem.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "not really a dp but more corner cases to handle genrally we see problems with pre handled cases here it\\'s not there that\\'s why tricky."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "get ready for dp and graph questions. :)"
                    },
                    {
                        "username": "ulalit_2728",
                        "content": "We have to swap two letters at a time, so is swapping only allowed once or can swap multiple times?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "only once "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "only once"
                    }
                ]
            },
            {
                "id": 1954704,
                "content": [
                    {
                        "username": "qwsazi",
                        "content": "this submit testcases are torture"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I think its a easy question simply because of test cases . They are small to its easy to find error .\\nYou just have to take care of following condition:-\\n1. If strings are of different length return False\\n2. If string are exactly equal and all character are unique then return false, if there are repeating character then return True\\n3.If string are of same length but not equal than cheak if the number of different element is other than  2 , return False.\\nElse if it is 2 then cheak if swapping makes the two the string equal or not .\\nThanks and have a error free day."
                    },
                    {
                        "username": "patrickallard",
                        "content": "Do not let the Easy label fool you. Although the problem is accurately graded, it will require more thought and patience than what you might expect an easy problem to require. It took me awhile to come up with a solution--it ended up being more involved than I had anticipated. My issue was that I kept switching between two different methods, only until the end realizing that the solution required the use of both. "
                    },
                    {
                        "username": "ogcooke",
                        "content": "I got really confused about the output format in Python. Some type hints would be nice"
                    },
                    {
                        "username": "kareena29",
                        "content": "Calling it easy? Actuallyy? "
                    },
                    {
                        "username": "im-naime",
                        "content": "WOW, I cracked it on my initial try!"
                    },
                    {
                        "username": "mmtemel",
                        "content": "By the way it is not easy, not even closer!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Why the text tells me this is a DP problem.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "not really a dp but more corner cases to handle genrally we see problems with pre handled cases here it\\'s not there that\\'s why tricky."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "get ready for dp and graph questions. :)"
                    },
                    {
                        "username": "ulalit_2728",
                        "content": "We have to swap two letters at a time, so is swapping only allowed once or can swap multiple times?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "only once "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "only once"
                    }
                ]
            },
            {
                "id": 1954647,
                "content": [
                    {
                        "username": "qwsazi",
                        "content": "this submit testcases are torture"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I think its a easy question simply because of test cases . They are small to its easy to find error .\\nYou just have to take care of following condition:-\\n1. If strings are of different length return False\\n2. If string are exactly equal and all character are unique then return false, if there are repeating character then return True\\n3.If string are of same length but not equal than cheak if the number of different element is other than  2 , return False.\\nElse if it is 2 then cheak if swapping makes the two the string equal or not .\\nThanks and have a error free day."
                    },
                    {
                        "username": "patrickallard",
                        "content": "Do not let the Easy label fool you. Although the problem is accurately graded, it will require more thought and patience than what you might expect an easy problem to require. It took me awhile to come up with a solution--it ended up being more involved than I had anticipated. My issue was that I kept switching between two different methods, only until the end realizing that the solution required the use of both. "
                    },
                    {
                        "username": "ogcooke",
                        "content": "I got really confused about the output format in Python. Some type hints would be nice"
                    },
                    {
                        "username": "kareena29",
                        "content": "Calling it easy? Actuallyy? "
                    },
                    {
                        "username": "im-naime",
                        "content": "WOW, I cracked it on my initial try!"
                    },
                    {
                        "username": "mmtemel",
                        "content": "By the way it is not easy, not even closer!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Why the text tells me this is a DP problem.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "not really a dp but more corner cases to handle genrally we see problems with pre handled cases here it\\'s not there that\\'s why tricky."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "get ready for dp and graph questions. :)"
                    },
                    {
                        "username": "ulalit_2728",
                        "content": "We have to swap two letters at a time, so is swapping only allowed once or can swap multiple times?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "only once "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "only once"
                    }
                ]
            },
            {
                "id": 1954594,
                "content": [
                    {
                        "username": "qwsazi",
                        "content": "this submit testcases are torture"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I think its a easy question simply because of test cases . They are small to its easy to find error .\\nYou just have to take care of following condition:-\\n1. If strings are of different length return False\\n2. If string are exactly equal and all character are unique then return false, if there are repeating character then return True\\n3.If string are of same length but not equal than cheak if the number of different element is other than  2 , return False.\\nElse if it is 2 then cheak if swapping makes the two the string equal or not .\\nThanks and have a error free day."
                    },
                    {
                        "username": "patrickallard",
                        "content": "Do not let the Easy label fool you. Although the problem is accurately graded, it will require more thought and patience than what you might expect an easy problem to require. It took me awhile to come up with a solution--it ended up being more involved than I had anticipated. My issue was that I kept switching between two different methods, only until the end realizing that the solution required the use of both. "
                    },
                    {
                        "username": "ogcooke",
                        "content": "I got really confused about the output format in Python. Some type hints would be nice"
                    },
                    {
                        "username": "kareena29",
                        "content": "Calling it easy? Actuallyy? "
                    },
                    {
                        "username": "im-naime",
                        "content": "WOW, I cracked it on my initial try!"
                    },
                    {
                        "username": "mmtemel",
                        "content": "By the way it is not easy, not even closer!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Why the text tells me this is a DP problem.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "not really a dp but more corner cases to handle genrally we see problems with pre handled cases here it\\'s not there that\\'s why tricky."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "get ready for dp and graph questions. :)"
                    },
                    {
                        "username": "ulalit_2728",
                        "content": "We have to swap two letters at a time, so is swapping only allowed once or can swap multiple times?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "only once "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "only once"
                    }
                ]
            },
            {
                "id": 1954541,
                "content": [
                    {
                        "username": "qwsazi",
                        "content": "this submit testcases are torture"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I think its a easy question simply because of test cases . They are small to its easy to find error .\\nYou just have to take care of following condition:-\\n1. If strings are of different length return False\\n2. If string are exactly equal and all character are unique then return false, if there are repeating character then return True\\n3.If string are of same length but not equal than cheak if the number of different element is other than  2 , return False.\\nElse if it is 2 then cheak if swapping makes the two the string equal or not .\\nThanks and have a error free day."
                    },
                    {
                        "username": "patrickallard",
                        "content": "Do not let the Easy label fool you. Although the problem is accurately graded, it will require more thought and patience than what you might expect an easy problem to require. It took me awhile to come up with a solution--it ended up being more involved than I had anticipated. My issue was that I kept switching between two different methods, only until the end realizing that the solution required the use of both. "
                    },
                    {
                        "username": "ogcooke",
                        "content": "I got really confused about the output format in Python. Some type hints would be nice"
                    },
                    {
                        "username": "kareena29",
                        "content": "Calling it easy? Actuallyy? "
                    },
                    {
                        "username": "im-naime",
                        "content": "WOW, I cracked it on my initial try!"
                    },
                    {
                        "username": "mmtemel",
                        "content": "By the way it is not easy, not even closer!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Why the text tells me this is a DP problem.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "not really a dp but more corner cases to handle genrally we see problems with pre handled cases here it\\'s not there that\\'s why tricky."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "get ready for dp and graph questions. :)"
                    },
                    {
                        "username": "ulalit_2728",
                        "content": "We have to swap two letters at a time, so is swapping only allowed once or can swap multiple times?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "only once "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "only once"
                    }
                ]
            },
            {
                "id": 1954537,
                "content": [
                    {
                        "username": "qwsazi",
                        "content": "this submit testcases are torture"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I think its a easy question simply because of test cases . They are small to its easy to find error .\\nYou just have to take care of following condition:-\\n1. If strings are of different length return False\\n2. If string are exactly equal and all character are unique then return false, if there are repeating character then return True\\n3.If string are of same length but not equal than cheak if the number of different element is other than  2 , return False.\\nElse if it is 2 then cheak if swapping makes the two the string equal or not .\\nThanks and have a error free day."
                    },
                    {
                        "username": "patrickallard",
                        "content": "Do not let the Easy label fool you. Although the problem is accurately graded, it will require more thought and patience than what you might expect an easy problem to require. It took me awhile to come up with a solution--it ended up being more involved than I had anticipated. My issue was that I kept switching between two different methods, only until the end realizing that the solution required the use of both. "
                    },
                    {
                        "username": "ogcooke",
                        "content": "I got really confused about the output format in Python. Some type hints would be nice"
                    },
                    {
                        "username": "kareena29",
                        "content": "Calling it easy? Actuallyy? "
                    },
                    {
                        "username": "im-naime",
                        "content": "WOW, I cracked it on my initial try!"
                    },
                    {
                        "username": "mmtemel",
                        "content": "By the way it is not easy, not even closer!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Why the text tells me this is a DP problem.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "not really a dp but more corner cases to handle genrally we see problems with pre handled cases here it\\'s not there that\\'s why tricky."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "get ready for dp and graph questions. :)"
                    },
                    {
                        "username": "ulalit_2728",
                        "content": "We have to swap two letters at a time, so is swapping only allowed once or can swap multiple times?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "only once "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "only once"
                    }
                ]
            },
            {
                "id": 1954521,
                "content": [
                    {
                        "username": "_vishalverma",
                        "content": "Input : \"abcd\"\ngoal : \"badc\"\nWhy this is not true, we can swap 'a' with 'b' and 'c' with 'd' to achieve this?\nCan anyone help me with it?\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we can swap only once that\\'s why"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can swap only once  not twice"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "Too Many edge cases...  T - T"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "You have to perform swap operation exactly once.\\neg: s = \"abcd\" goal = \"abcd\" |  output : false (because you cannot swap any character here)\\n\\neg: s = \"aabb\" goal = \"aabb\" | output: true (because you can swap either \"aa\" or \"bb\"\\n\\neg: s = \"abc\" goal = \"ab\" | output: false (because sizes are not equal)\\n\\neg : \"abcd\" goal = \"abed\" | output: false (because \"c\" is not present in goal)\\n\\neg : s = \"abdcgf\" goal = \"abcdfg\" | output: false (cannot perform swap operation two times)\\n\\nHandle these cases. "
                    },
                    {
                        "username": "tliu0c",
                        "content": "s =\"abab\"\\ngoal =\"baba\" \\n\\nOMG"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "its a wierd problem :["
                    },
                    {
                        "username": "201132",
                        "content": "Easy not really easy :)\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "nice problem ! nice test cases ! nice headache !\\n"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "abcd\\nbadc\\nhow is it false should it be true as we can swap two times and get it?"
                    },
                    {
                        "username": "rohanny_",
                        "content": "they should atleast mention, \"u cant swap more than once\""
                    },
                    {
                        "username": "Brindha_A",
                        "content": "[@kumaraashish118](/kumaraashish118)  How to do that? \\n"
                    },
                    {
                        "username": "Brindha_A",
                        "content": "same doubt... \\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "You will need to swap more than 2 letters i.e a with b and c with d to make the strings equal. It should require exactly 2 letters to be swapped to return true."
                    },
                    {
                        "username": "rahulkottak",
                        "content": "s =\\n\"aaaaaaabc\"\\ngoal =\\n\"aaaaaaacb\"... lol how is this returning true!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "you can swap b and c to get goal and it\\'s done only once"
                    },
                    {
                        "username": "rahulkottak",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) [@kumaraashish118](/kumaraashish118) got it now ! thanks\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Swap b and c in the string and they become equal.\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just swap bc in 2nd string it will become eaual"
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "https://leetcode.com/problems/buddy-strings/solutions/3711580/daily-challenge-solution-3rd-july/\\nsolution"
                    }
                ]
            },
            {
                "id": 1954509,
                "content": [
                    {
                        "username": "_vishalverma",
                        "content": "Input : \"abcd\"\ngoal : \"badc\"\nWhy this is not true, we can swap 'a' with 'b' and 'c' with 'd' to achieve this?\nCan anyone help me with it?\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we can swap only once that\\'s why"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can swap only once  not twice"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "Too Many edge cases...  T - T"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "You have to perform swap operation exactly once.\\neg: s = \"abcd\" goal = \"abcd\" |  output : false (because you cannot swap any character here)\\n\\neg: s = \"aabb\" goal = \"aabb\" | output: true (because you can swap either \"aa\" or \"bb\"\\n\\neg: s = \"abc\" goal = \"ab\" | output: false (because sizes are not equal)\\n\\neg : \"abcd\" goal = \"abed\" | output: false (because \"c\" is not present in goal)\\n\\neg : s = \"abdcgf\" goal = \"abcdfg\" | output: false (cannot perform swap operation two times)\\n\\nHandle these cases. "
                    },
                    {
                        "username": "tliu0c",
                        "content": "s =\"abab\"\\ngoal =\"baba\" \\n\\nOMG"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "its a wierd problem :["
                    },
                    {
                        "username": "201132",
                        "content": "Easy not really easy :)\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "nice problem ! nice test cases ! nice headache !\\n"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "abcd\\nbadc\\nhow is it false should it be true as we can swap two times and get it?"
                    },
                    {
                        "username": "rohanny_",
                        "content": "they should atleast mention, \"u cant swap more than once\""
                    },
                    {
                        "username": "Brindha_A",
                        "content": "[@kumaraashish118](/kumaraashish118)  How to do that? \\n"
                    },
                    {
                        "username": "Brindha_A",
                        "content": "same doubt... \\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "You will need to swap more than 2 letters i.e a with b and c with d to make the strings equal. It should require exactly 2 letters to be swapped to return true."
                    },
                    {
                        "username": "rahulkottak",
                        "content": "s =\\n\"aaaaaaabc\"\\ngoal =\\n\"aaaaaaacb\"... lol how is this returning true!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "you can swap b and c to get goal and it\\'s done only once"
                    },
                    {
                        "username": "rahulkottak",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) [@kumaraashish118](/kumaraashish118) got it now ! thanks\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Swap b and c in the string and they become equal.\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just swap bc in 2nd string it will become eaual"
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "https://leetcode.com/problems/buddy-strings/solutions/3711580/daily-challenge-solution-3rd-july/\\nsolution"
                    }
                ]
            },
            {
                "id": 1954496,
                "content": [
                    {
                        "username": "_vishalverma",
                        "content": "Input : \"abcd\"\ngoal : \"badc\"\nWhy this is not true, we can swap 'a' with 'b' and 'c' with 'd' to achieve this?\nCan anyone help me with it?\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we can swap only once that\\'s why"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can swap only once  not twice"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "Too Many edge cases...  T - T"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "You have to perform swap operation exactly once.\\neg: s = \"abcd\" goal = \"abcd\" |  output : false (because you cannot swap any character here)\\n\\neg: s = \"aabb\" goal = \"aabb\" | output: true (because you can swap either \"aa\" or \"bb\"\\n\\neg: s = \"abc\" goal = \"ab\" | output: false (because sizes are not equal)\\n\\neg : \"abcd\" goal = \"abed\" | output: false (because \"c\" is not present in goal)\\n\\neg : s = \"abdcgf\" goal = \"abcdfg\" | output: false (cannot perform swap operation two times)\\n\\nHandle these cases. "
                    },
                    {
                        "username": "tliu0c",
                        "content": "s =\"abab\"\\ngoal =\"baba\" \\n\\nOMG"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "its a wierd problem :["
                    },
                    {
                        "username": "201132",
                        "content": "Easy not really easy :)\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "nice problem ! nice test cases ! nice headache !\\n"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "abcd\\nbadc\\nhow is it false should it be true as we can swap two times and get it?"
                    },
                    {
                        "username": "rohanny_",
                        "content": "they should atleast mention, \"u cant swap more than once\""
                    },
                    {
                        "username": "Brindha_A",
                        "content": "[@kumaraashish118](/kumaraashish118)  How to do that? \\n"
                    },
                    {
                        "username": "Brindha_A",
                        "content": "same doubt... \\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "You will need to swap more than 2 letters i.e a with b and c with d to make the strings equal. It should require exactly 2 letters to be swapped to return true."
                    },
                    {
                        "username": "rahulkottak",
                        "content": "s =\\n\"aaaaaaabc\"\\ngoal =\\n\"aaaaaaacb\"... lol how is this returning true!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "you can swap b and c to get goal and it\\'s done only once"
                    },
                    {
                        "username": "rahulkottak",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) [@kumaraashish118](/kumaraashish118) got it now ! thanks\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Swap b and c in the string and they become equal.\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just swap bc in 2nd string it will become eaual"
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "https://leetcode.com/problems/buddy-strings/solutions/3711580/daily-challenge-solution-3rd-july/\\nsolution"
                    }
                ]
            },
            {
                "id": 1954435,
                "content": [
                    {
                        "username": "_vishalverma",
                        "content": "Input : \"abcd\"\ngoal : \"badc\"\nWhy this is not true, we can swap 'a' with 'b' and 'c' with 'd' to achieve this?\nCan anyone help me with it?\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we can swap only once that\\'s why"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can swap only once  not twice"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "Too Many edge cases...  T - T"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "You have to perform swap operation exactly once.\\neg: s = \"abcd\" goal = \"abcd\" |  output : false (because you cannot swap any character here)\\n\\neg: s = \"aabb\" goal = \"aabb\" | output: true (because you can swap either \"aa\" or \"bb\"\\n\\neg: s = \"abc\" goal = \"ab\" | output: false (because sizes are not equal)\\n\\neg : \"abcd\" goal = \"abed\" | output: false (because \"c\" is not present in goal)\\n\\neg : s = \"abdcgf\" goal = \"abcdfg\" | output: false (cannot perform swap operation two times)\\n\\nHandle these cases. "
                    },
                    {
                        "username": "tliu0c",
                        "content": "s =\"abab\"\\ngoal =\"baba\" \\n\\nOMG"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "its a wierd problem :["
                    },
                    {
                        "username": "201132",
                        "content": "Easy not really easy :)\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "nice problem ! nice test cases ! nice headache !\\n"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "abcd\\nbadc\\nhow is it false should it be true as we can swap two times and get it?"
                    },
                    {
                        "username": "rohanny_",
                        "content": "they should atleast mention, \"u cant swap more than once\""
                    },
                    {
                        "username": "Brindha_A",
                        "content": "[@kumaraashish118](/kumaraashish118)  How to do that? \\n"
                    },
                    {
                        "username": "Brindha_A",
                        "content": "same doubt... \\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "You will need to swap more than 2 letters i.e a with b and c with d to make the strings equal. It should require exactly 2 letters to be swapped to return true."
                    },
                    {
                        "username": "rahulkottak",
                        "content": "s =\\n\"aaaaaaabc\"\\ngoal =\\n\"aaaaaaacb\"... lol how is this returning true!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "you can swap b and c to get goal and it\\'s done only once"
                    },
                    {
                        "username": "rahulkottak",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) [@kumaraashish118](/kumaraashish118) got it now ! thanks\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Swap b and c in the string and they become equal.\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just swap bc in 2nd string it will become eaual"
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "https://leetcode.com/problems/buddy-strings/solutions/3711580/daily-challenge-solution-3rd-july/\\nsolution"
                    }
                ]
            },
            {
                "id": 1954362,
                "content": [
                    {
                        "username": "_vishalverma",
                        "content": "Input : \"abcd\"\ngoal : \"badc\"\nWhy this is not true, we can swap 'a' with 'b' and 'c' with 'd' to achieve this?\nCan anyone help me with it?\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we can swap only once that\\'s why"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can swap only once  not twice"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "Too Many edge cases...  T - T"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "You have to perform swap operation exactly once.\\neg: s = \"abcd\" goal = \"abcd\" |  output : false (because you cannot swap any character here)\\n\\neg: s = \"aabb\" goal = \"aabb\" | output: true (because you can swap either \"aa\" or \"bb\"\\n\\neg: s = \"abc\" goal = \"ab\" | output: false (because sizes are not equal)\\n\\neg : \"abcd\" goal = \"abed\" | output: false (because \"c\" is not present in goal)\\n\\neg : s = \"abdcgf\" goal = \"abcdfg\" | output: false (cannot perform swap operation two times)\\n\\nHandle these cases. "
                    },
                    {
                        "username": "tliu0c",
                        "content": "s =\"abab\"\\ngoal =\"baba\" \\n\\nOMG"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "its a wierd problem :["
                    },
                    {
                        "username": "201132",
                        "content": "Easy not really easy :)\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "nice problem ! nice test cases ! nice headache !\\n"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "abcd\\nbadc\\nhow is it false should it be true as we can swap two times and get it?"
                    },
                    {
                        "username": "rohanny_",
                        "content": "they should atleast mention, \"u cant swap more than once\""
                    },
                    {
                        "username": "Brindha_A",
                        "content": "[@kumaraashish118](/kumaraashish118)  How to do that? \\n"
                    },
                    {
                        "username": "Brindha_A",
                        "content": "same doubt... \\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "You will need to swap more than 2 letters i.e a with b and c with d to make the strings equal. It should require exactly 2 letters to be swapped to return true."
                    },
                    {
                        "username": "rahulkottak",
                        "content": "s =\\n\"aaaaaaabc\"\\ngoal =\\n\"aaaaaaacb\"... lol how is this returning true!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "you can swap b and c to get goal and it\\'s done only once"
                    },
                    {
                        "username": "rahulkottak",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) [@kumaraashish118](/kumaraashish118) got it now ! thanks\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Swap b and c in the string and they become equal.\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just swap bc in 2nd string it will become eaual"
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "https://leetcode.com/problems/buddy-strings/solutions/3711580/daily-challenge-solution-3rd-july/\\nsolution"
                    }
                ]
            },
            {
                "id": 1954358,
                "content": [
                    {
                        "username": "_vishalverma",
                        "content": "Input : \"abcd\"\ngoal : \"badc\"\nWhy this is not true, we can swap 'a' with 'b' and 'c' with 'd' to achieve this?\nCan anyone help me with it?\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we can swap only once that\\'s why"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can swap only once  not twice"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "Too Many edge cases...  T - T"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "You have to perform swap operation exactly once.\\neg: s = \"abcd\" goal = \"abcd\" |  output : false (because you cannot swap any character here)\\n\\neg: s = \"aabb\" goal = \"aabb\" | output: true (because you can swap either \"aa\" or \"bb\"\\n\\neg: s = \"abc\" goal = \"ab\" | output: false (because sizes are not equal)\\n\\neg : \"abcd\" goal = \"abed\" | output: false (because \"c\" is not present in goal)\\n\\neg : s = \"abdcgf\" goal = \"abcdfg\" | output: false (cannot perform swap operation two times)\\n\\nHandle these cases. "
                    },
                    {
                        "username": "tliu0c",
                        "content": "s =\"abab\"\\ngoal =\"baba\" \\n\\nOMG"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "its a wierd problem :["
                    },
                    {
                        "username": "201132",
                        "content": "Easy not really easy :)\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "nice problem ! nice test cases ! nice headache !\\n"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "abcd\\nbadc\\nhow is it false should it be true as we can swap two times and get it?"
                    },
                    {
                        "username": "rohanny_",
                        "content": "they should atleast mention, \"u cant swap more than once\""
                    },
                    {
                        "username": "Brindha_A",
                        "content": "[@kumaraashish118](/kumaraashish118)  How to do that? \\n"
                    },
                    {
                        "username": "Brindha_A",
                        "content": "same doubt... \\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "You will need to swap more than 2 letters i.e a with b and c with d to make the strings equal. It should require exactly 2 letters to be swapped to return true."
                    },
                    {
                        "username": "rahulkottak",
                        "content": "s =\\n\"aaaaaaabc\"\\ngoal =\\n\"aaaaaaacb\"... lol how is this returning true!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "you can swap b and c to get goal and it\\'s done only once"
                    },
                    {
                        "username": "rahulkottak",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) [@kumaraashish118](/kumaraashish118) got it now ! thanks\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Swap b and c in the string and they become equal.\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just swap bc in 2nd string it will become eaual"
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "https://leetcode.com/problems/buddy-strings/solutions/3711580/daily-challenge-solution-3rd-july/\\nsolution"
                    }
                ]
            },
            {
                "id": 1954347,
                "content": [
                    {
                        "username": "_vishalverma",
                        "content": "Input : \"abcd\"\ngoal : \"badc\"\nWhy this is not true, we can swap 'a' with 'b' and 'c' with 'd' to achieve this?\nCan anyone help me with it?\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we can swap only once that\\'s why"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can swap only once  not twice"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "Too Many edge cases...  T - T"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "You have to perform swap operation exactly once.\\neg: s = \"abcd\" goal = \"abcd\" |  output : false (because you cannot swap any character here)\\n\\neg: s = \"aabb\" goal = \"aabb\" | output: true (because you can swap either \"aa\" or \"bb\"\\n\\neg: s = \"abc\" goal = \"ab\" | output: false (because sizes are not equal)\\n\\neg : \"abcd\" goal = \"abed\" | output: false (because \"c\" is not present in goal)\\n\\neg : s = \"abdcgf\" goal = \"abcdfg\" | output: false (cannot perform swap operation two times)\\n\\nHandle these cases. "
                    },
                    {
                        "username": "tliu0c",
                        "content": "s =\"abab\"\\ngoal =\"baba\" \\n\\nOMG"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "its a wierd problem :["
                    },
                    {
                        "username": "201132",
                        "content": "Easy not really easy :)\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "nice problem ! nice test cases ! nice headache !\\n"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "abcd\\nbadc\\nhow is it false should it be true as we can swap two times and get it?"
                    },
                    {
                        "username": "rohanny_",
                        "content": "they should atleast mention, \"u cant swap more than once\""
                    },
                    {
                        "username": "Brindha_A",
                        "content": "[@kumaraashish118](/kumaraashish118)  How to do that? \\n"
                    },
                    {
                        "username": "Brindha_A",
                        "content": "same doubt... \\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "You will need to swap more than 2 letters i.e a with b and c with d to make the strings equal. It should require exactly 2 letters to be swapped to return true."
                    },
                    {
                        "username": "rahulkottak",
                        "content": "s =\\n\"aaaaaaabc\"\\ngoal =\\n\"aaaaaaacb\"... lol how is this returning true!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "you can swap b and c to get goal and it\\'s done only once"
                    },
                    {
                        "username": "rahulkottak",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) [@kumaraashish118](/kumaraashish118) got it now ! thanks\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Swap b and c in the string and they become equal.\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just swap bc in 2nd string it will become eaual"
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "https://leetcode.com/problems/buddy-strings/solutions/3711580/daily-challenge-solution-3rd-july/\\nsolution"
                    }
                ]
            },
            {
                "id": 1954316,
                "content": [
                    {
                        "username": "_vishalverma",
                        "content": "Input : \"abcd\"\ngoal : \"badc\"\nWhy this is not true, we can swap 'a' with 'b' and 'c' with 'd' to achieve this?\nCan anyone help me with it?\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we can swap only once that\\'s why"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can swap only once  not twice"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "Too Many edge cases...  T - T"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "You have to perform swap operation exactly once.\\neg: s = \"abcd\" goal = \"abcd\" |  output : false (because you cannot swap any character here)\\n\\neg: s = \"aabb\" goal = \"aabb\" | output: true (because you can swap either \"aa\" or \"bb\"\\n\\neg: s = \"abc\" goal = \"ab\" | output: false (because sizes are not equal)\\n\\neg : \"abcd\" goal = \"abed\" | output: false (because \"c\" is not present in goal)\\n\\neg : s = \"abdcgf\" goal = \"abcdfg\" | output: false (cannot perform swap operation two times)\\n\\nHandle these cases. "
                    },
                    {
                        "username": "tliu0c",
                        "content": "s =\"abab\"\\ngoal =\"baba\" \\n\\nOMG"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "its a wierd problem :["
                    },
                    {
                        "username": "201132",
                        "content": "Easy not really easy :)\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "nice problem ! nice test cases ! nice headache !\\n"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "abcd\\nbadc\\nhow is it false should it be true as we can swap two times and get it?"
                    },
                    {
                        "username": "rohanny_",
                        "content": "they should atleast mention, \"u cant swap more than once\""
                    },
                    {
                        "username": "Brindha_A",
                        "content": "[@kumaraashish118](/kumaraashish118)  How to do that? \\n"
                    },
                    {
                        "username": "Brindha_A",
                        "content": "same doubt... \\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "You will need to swap more than 2 letters i.e a with b and c with d to make the strings equal. It should require exactly 2 letters to be swapped to return true."
                    },
                    {
                        "username": "rahulkottak",
                        "content": "s =\\n\"aaaaaaabc\"\\ngoal =\\n\"aaaaaaacb\"... lol how is this returning true!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "you can swap b and c to get goal and it\\'s done only once"
                    },
                    {
                        "username": "rahulkottak",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) [@kumaraashish118](/kumaraashish118) got it now ! thanks\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Swap b and c in the string and they become equal.\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just swap bc in 2nd string it will become eaual"
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "https://leetcode.com/problems/buddy-strings/solutions/3711580/daily-challenge-solution-3rd-july/\\nsolution"
                    }
                ]
            },
            {
                "id": 1954315,
                "content": [
                    {
                        "username": "_vishalverma",
                        "content": "Input : \"abcd\"\ngoal : \"badc\"\nWhy this is not true, we can swap 'a' with 'b' and 'c' with 'd' to achieve this?\nCan anyone help me with it?\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we can swap only once that\\'s why"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can swap only once  not twice"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "Too Many edge cases...  T - T"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "You have to perform swap operation exactly once.\\neg: s = \"abcd\" goal = \"abcd\" |  output : false (because you cannot swap any character here)\\n\\neg: s = \"aabb\" goal = \"aabb\" | output: true (because you can swap either \"aa\" or \"bb\"\\n\\neg: s = \"abc\" goal = \"ab\" | output: false (because sizes are not equal)\\n\\neg : \"abcd\" goal = \"abed\" | output: false (because \"c\" is not present in goal)\\n\\neg : s = \"abdcgf\" goal = \"abcdfg\" | output: false (cannot perform swap operation two times)\\n\\nHandle these cases. "
                    },
                    {
                        "username": "tliu0c",
                        "content": "s =\"abab\"\\ngoal =\"baba\" \\n\\nOMG"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "its a wierd problem :["
                    },
                    {
                        "username": "201132",
                        "content": "Easy not really easy :)\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "nice problem ! nice test cases ! nice headache !\\n"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "abcd\\nbadc\\nhow is it false should it be true as we can swap two times and get it?"
                    },
                    {
                        "username": "rohanny_",
                        "content": "they should atleast mention, \"u cant swap more than once\""
                    },
                    {
                        "username": "Brindha_A",
                        "content": "[@kumaraashish118](/kumaraashish118)  How to do that? \\n"
                    },
                    {
                        "username": "Brindha_A",
                        "content": "same doubt... \\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "You will need to swap more than 2 letters i.e a with b and c with d to make the strings equal. It should require exactly 2 letters to be swapped to return true."
                    },
                    {
                        "username": "rahulkottak",
                        "content": "s =\\n\"aaaaaaabc\"\\ngoal =\\n\"aaaaaaacb\"... lol how is this returning true!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "you can swap b and c to get goal and it\\'s done only once"
                    },
                    {
                        "username": "rahulkottak",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) [@kumaraashish118](/kumaraashish118) got it now ! thanks\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Swap b and c in the string and they become equal.\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just swap bc in 2nd string it will become eaual"
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "https://leetcode.com/problems/buddy-strings/solutions/3711580/daily-challenge-solution-3rd-july/\\nsolution"
                    }
                ]
            },
            {
                "id": 1954300,
                "content": [
                    {
                        "username": "_vishalverma",
                        "content": "Input : \"abcd\"\ngoal : \"badc\"\nWhy this is not true, we can swap 'a' with 'b' and 'c' with 'd' to achieve this?\nCan anyone help me with it?\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we can swap only once that\\'s why"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can swap only once  not twice"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "Too Many edge cases...  T - T"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "You have to perform swap operation exactly once.\\neg: s = \"abcd\" goal = \"abcd\" |  output : false (because you cannot swap any character here)\\n\\neg: s = \"aabb\" goal = \"aabb\" | output: true (because you can swap either \"aa\" or \"bb\"\\n\\neg: s = \"abc\" goal = \"ab\" | output: false (because sizes are not equal)\\n\\neg : \"abcd\" goal = \"abed\" | output: false (because \"c\" is not present in goal)\\n\\neg : s = \"abdcgf\" goal = \"abcdfg\" | output: false (cannot perform swap operation two times)\\n\\nHandle these cases. "
                    },
                    {
                        "username": "tliu0c",
                        "content": "s =\"abab\"\\ngoal =\"baba\" \\n\\nOMG"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "its a wierd problem :["
                    },
                    {
                        "username": "201132",
                        "content": "Easy not really easy :)\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "nice problem ! nice test cases ! nice headache !\\n"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "abcd\\nbadc\\nhow is it false should it be true as we can swap two times and get it?"
                    },
                    {
                        "username": "rohanny_",
                        "content": "they should atleast mention, \"u cant swap more than once\""
                    },
                    {
                        "username": "Brindha_A",
                        "content": "[@kumaraashish118](/kumaraashish118)  How to do that? \\n"
                    },
                    {
                        "username": "Brindha_A",
                        "content": "same doubt... \\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "You will need to swap more than 2 letters i.e a with b and c with d to make the strings equal. It should require exactly 2 letters to be swapped to return true."
                    },
                    {
                        "username": "rahulkottak",
                        "content": "s =\\n\"aaaaaaabc\"\\ngoal =\\n\"aaaaaaacb\"... lol how is this returning true!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "you can swap b and c to get goal and it\\'s done only once"
                    },
                    {
                        "username": "rahulkottak",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) [@kumaraashish118](/kumaraashish118) got it now ! thanks\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Swap b and c in the string and they become equal.\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just swap bc in 2nd string it will become eaual"
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "https://leetcode.com/problems/buddy-strings/solutions/3711580/daily-challenge-solution-3rd-july/\\nsolution"
                    }
                ]
            },
            {
                "id": 1954294,
                "content": [
                    {
                        "username": "wusi2cool",
                        "content": "should have made it clear we could only do a single swap and multiple swap is not allowed."
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "HINT ALERT\\n\\n- check lengths and counts of each character in  `s` and `goal`\\n- check if a character has a `copy`, so if the strings are equal, its still possible.\\n- if counts don\\'t line up, return.\\n- if `difference` then its possible.\\n- if no `difference` but `copy` is true, its still possible."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "After being destoryed by pre hard problems, it is easy..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "such a vague description"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "s =\"aaaaaaabc\" goal=\"aaaaaaacb\" \\nshould return false or true.\\nATQ => it should return false.\\ntestcase expecting true. \\nAny solution why is it happening?"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "[@abukafq](/abukafq) Yes I got it, I was only swaping the first two characters."
                    },
                    {
                        "username": "abukafq",
                        "content": "last 2 position can be swap.\\nHence, true"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**This string is  bad buddy .**"
                    },
                    {
                        "username": "Hariom51",
                        "content": "what is a sense of having a string of length 1 ? "
                    },
                    {
                        "username": "programmer0073",
                        "content": "Finally easy with 30% Acceptance Rate. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Easy with the lower acceptance are the worst ones!"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Edge Cases\\n1) The length of s and goal can be different. (In this case return false)\\n2) If the two strings are identical return true only if they contain a repeated letter. Eg: s = aab, goal =aab ,Here index of 0 and 1 can be swapped to get goal."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "This is actually a simple counting problem :) . Count the difference of alphabets if it\\'s 2 easy swap and if it\\'s more require multiple swap and if there is no difference between s and goal check for repeating alphabet in s"
                    }
                ]
            },
            {
                "id": 1954284,
                "content": [
                    {
                        "username": "wusi2cool",
                        "content": "should have made it clear we could only do a single swap and multiple swap is not allowed."
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "HINT ALERT\\n\\n- check lengths and counts of each character in  `s` and `goal`\\n- check if a character has a `copy`, so if the strings are equal, its still possible.\\n- if counts don\\'t line up, return.\\n- if `difference` then its possible.\\n- if no `difference` but `copy` is true, its still possible."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "After being destoryed by pre hard problems, it is easy..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "such a vague description"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "s =\"aaaaaaabc\" goal=\"aaaaaaacb\" \\nshould return false or true.\\nATQ => it should return false.\\ntestcase expecting true. \\nAny solution why is it happening?"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "[@abukafq](/abukafq) Yes I got it, I was only swaping the first two characters."
                    },
                    {
                        "username": "abukafq",
                        "content": "last 2 position can be swap.\\nHence, true"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**This string is  bad buddy .**"
                    },
                    {
                        "username": "Hariom51",
                        "content": "what is a sense of having a string of length 1 ? "
                    },
                    {
                        "username": "programmer0073",
                        "content": "Finally easy with 30% Acceptance Rate. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Easy with the lower acceptance are the worst ones!"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Edge Cases\\n1) The length of s and goal can be different. (In this case return false)\\n2) If the two strings are identical return true only if they contain a repeated letter. Eg: s = aab, goal =aab ,Here index of 0 and 1 can be swapped to get goal."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "This is actually a simple counting problem :) . Count the difference of alphabets if it\\'s 2 easy swap and if it\\'s more require multiple swap and if there is no difference between s and goal check for repeating alphabet in s"
                    }
                ]
            },
            {
                "id": 1954272,
                "content": [
                    {
                        "username": "wusi2cool",
                        "content": "should have made it clear we could only do a single swap and multiple swap is not allowed."
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "HINT ALERT\\n\\n- check lengths and counts of each character in  `s` and `goal`\\n- check if a character has a `copy`, so if the strings are equal, its still possible.\\n- if counts don\\'t line up, return.\\n- if `difference` then its possible.\\n- if no `difference` but `copy` is true, its still possible."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "After being destoryed by pre hard problems, it is easy..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "such a vague description"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "s =\"aaaaaaabc\" goal=\"aaaaaaacb\" \\nshould return false or true.\\nATQ => it should return false.\\ntestcase expecting true. \\nAny solution why is it happening?"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "[@abukafq](/abukafq) Yes I got it, I was only swaping the first two characters."
                    },
                    {
                        "username": "abukafq",
                        "content": "last 2 position can be swap.\\nHence, true"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**This string is  bad buddy .**"
                    },
                    {
                        "username": "Hariom51",
                        "content": "what is a sense of having a string of length 1 ? "
                    },
                    {
                        "username": "programmer0073",
                        "content": "Finally easy with 30% Acceptance Rate. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Easy with the lower acceptance are the worst ones!"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Edge Cases\\n1) The length of s and goal can be different. (In this case return false)\\n2) If the two strings are identical return true only if they contain a repeated letter. Eg: s = aab, goal =aab ,Here index of 0 and 1 can be swapped to get goal."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "This is actually a simple counting problem :) . Count the difference of alphabets if it\\'s 2 easy swap and if it\\'s more require multiple swap and if there is no difference between s and goal check for repeating alphabet in s"
                    }
                ]
            },
            {
                "id": 1954255,
                "content": [
                    {
                        "username": "wusi2cool",
                        "content": "should have made it clear we could only do a single swap and multiple swap is not allowed."
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "HINT ALERT\\n\\n- check lengths and counts of each character in  `s` and `goal`\\n- check if a character has a `copy`, so if the strings are equal, its still possible.\\n- if counts don\\'t line up, return.\\n- if `difference` then its possible.\\n- if no `difference` but `copy` is true, its still possible."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "After being destoryed by pre hard problems, it is easy..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "such a vague description"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "s =\"aaaaaaabc\" goal=\"aaaaaaacb\" \\nshould return false or true.\\nATQ => it should return false.\\ntestcase expecting true. \\nAny solution why is it happening?"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "[@abukafq](/abukafq) Yes I got it, I was only swaping the first two characters."
                    },
                    {
                        "username": "abukafq",
                        "content": "last 2 position can be swap.\\nHence, true"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**This string is  bad buddy .**"
                    },
                    {
                        "username": "Hariom51",
                        "content": "what is a sense of having a string of length 1 ? "
                    },
                    {
                        "username": "programmer0073",
                        "content": "Finally easy with 30% Acceptance Rate. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Easy with the lower acceptance are the worst ones!"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Edge Cases\\n1) The length of s and goal can be different. (In this case return false)\\n2) If the two strings are identical return true only if they contain a repeated letter. Eg: s = aab, goal =aab ,Here index of 0 and 1 can be swapped to get goal."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "This is actually a simple counting problem :) . Count the difference of alphabets if it\\'s 2 easy swap and if it\\'s more require multiple swap and if there is no difference between s and goal check for repeating alphabet in s"
                    }
                ]
            },
            {
                "id": 1954223,
                "content": [
                    {
                        "username": "wusi2cool",
                        "content": "should have made it clear we could only do a single swap and multiple swap is not allowed."
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "HINT ALERT\\n\\n- check lengths and counts of each character in  `s` and `goal`\\n- check if a character has a `copy`, so if the strings are equal, its still possible.\\n- if counts don\\'t line up, return.\\n- if `difference` then its possible.\\n- if no `difference` but `copy` is true, its still possible."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "After being destoryed by pre hard problems, it is easy..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "such a vague description"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "s =\"aaaaaaabc\" goal=\"aaaaaaacb\" \\nshould return false or true.\\nATQ => it should return false.\\ntestcase expecting true. \\nAny solution why is it happening?"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "[@abukafq](/abukafq) Yes I got it, I was only swaping the first two characters."
                    },
                    {
                        "username": "abukafq",
                        "content": "last 2 position can be swap.\\nHence, true"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**This string is  bad buddy .**"
                    },
                    {
                        "username": "Hariom51",
                        "content": "what is a sense of having a string of length 1 ? "
                    },
                    {
                        "username": "programmer0073",
                        "content": "Finally easy with 30% Acceptance Rate. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Easy with the lower acceptance are the worst ones!"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Edge Cases\\n1) The length of s and goal can be different. (In this case return false)\\n2) If the two strings are identical return true only if they contain a repeated letter. Eg: s = aab, goal =aab ,Here index of 0 and 1 can be swapped to get goal."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "This is actually a simple counting problem :) . Count the difference of alphabets if it\\'s 2 easy swap and if it\\'s more require multiple swap and if there is no difference between s and goal check for repeating alphabet in s"
                    }
                ]
            },
            {
                "id": 1954194,
                "content": [
                    {
                        "username": "wusi2cool",
                        "content": "should have made it clear we could only do a single swap and multiple swap is not allowed."
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "HINT ALERT\\n\\n- check lengths and counts of each character in  `s` and `goal`\\n- check if a character has a `copy`, so if the strings are equal, its still possible.\\n- if counts don\\'t line up, return.\\n- if `difference` then its possible.\\n- if no `difference` but `copy` is true, its still possible."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "After being destoryed by pre hard problems, it is easy..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "such a vague description"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "s =\"aaaaaaabc\" goal=\"aaaaaaacb\" \\nshould return false or true.\\nATQ => it should return false.\\ntestcase expecting true. \\nAny solution why is it happening?"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "[@abukafq](/abukafq) Yes I got it, I was only swaping the first two characters."
                    },
                    {
                        "username": "abukafq",
                        "content": "last 2 position can be swap.\\nHence, true"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**This string is  bad buddy .**"
                    },
                    {
                        "username": "Hariom51",
                        "content": "what is a sense of having a string of length 1 ? "
                    },
                    {
                        "username": "programmer0073",
                        "content": "Finally easy with 30% Acceptance Rate. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Easy with the lower acceptance are the worst ones!"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Edge Cases\\n1) The length of s and goal can be different. (In this case return false)\\n2) If the two strings are identical return true only if they contain a repeated letter. Eg: s = aab, goal =aab ,Here index of 0 and 1 can be swapped to get goal."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "This is actually a simple counting problem :) . Count the difference of alphabets if it\\'s 2 easy swap and if it\\'s more require multiple swap and if there is no difference between s and goal check for repeating alphabet in s"
                    }
                ]
            },
            {
                "id": 1954163,
                "content": [
                    {
                        "username": "wusi2cool",
                        "content": "should have made it clear we could only do a single swap and multiple swap is not allowed."
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "HINT ALERT\\n\\n- check lengths and counts of each character in  `s` and `goal`\\n- check if a character has a `copy`, so if the strings are equal, its still possible.\\n- if counts don\\'t line up, return.\\n- if `difference` then its possible.\\n- if no `difference` but `copy` is true, its still possible."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "After being destoryed by pre hard problems, it is easy..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "such a vague description"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "s =\"aaaaaaabc\" goal=\"aaaaaaacb\" \\nshould return false or true.\\nATQ => it should return false.\\ntestcase expecting true. \\nAny solution why is it happening?"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "[@abukafq](/abukafq) Yes I got it, I was only swaping the first two characters."
                    },
                    {
                        "username": "abukafq",
                        "content": "last 2 position can be swap.\\nHence, true"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**This string is  bad buddy .**"
                    },
                    {
                        "username": "Hariom51",
                        "content": "what is a sense of having a string of length 1 ? "
                    },
                    {
                        "username": "programmer0073",
                        "content": "Finally easy with 30% Acceptance Rate. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Easy with the lower acceptance are the worst ones!"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Edge Cases\\n1) The length of s and goal can be different. (In this case return false)\\n2) If the two strings are identical return true only if they contain a repeated letter. Eg: s = aab, goal =aab ,Here index of 0 and 1 can be swapped to get goal."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "This is actually a simple counting problem :) . Count the difference of alphabets if it\\'s 2 easy swap and if it\\'s more require multiple swap and if there is no difference between s and goal check for repeating alphabet in s"
                    }
                ]
            },
            {
                "id": 1954146,
                "content": [
                    {
                        "username": "wusi2cool",
                        "content": "should have made it clear we could only do a single swap and multiple swap is not allowed."
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "HINT ALERT\\n\\n- check lengths and counts of each character in  `s` and `goal`\\n- check if a character has a `copy`, so if the strings are equal, its still possible.\\n- if counts don\\'t line up, return.\\n- if `difference` then its possible.\\n- if no `difference` but `copy` is true, its still possible."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "After being destoryed by pre hard problems, it is easy..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "such a vague description"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "s =\"aaaaaaabc\" goal=\"aaaaaaacb\" \\nshould return false or true.\\nATQ => it should return false.\\ntestcase expecting true. \\nAny solution why is it happening?"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "[@abukafq](/abukafq) Yes I got it, I was only swaping the first two characters."
                    },
                    {
                        "username": "abukafq",
                        "content": "last 2 position can be swap.\\nHence, true"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**This string is  bad buddy .**"
                    },
                    {
                        "username": "Hariom51",
                        "content": "what is a sense of having a string of length 1 ? "
                    },
                    {
                        "username": "programmer0073",
                        "content": "Finally easy with 30% Acceptance Rate. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Easy with the lower acceptance are the worst ones!"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Edge Cases\\n1) The length of s and goal can be different. (In this case return false)\\n2) If the two strings are identical return true only if they contain a repeated letter. Eg: s = aab, goal =aab ,Here index of 0 and 1 can be swapped to get goal."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "This is actually a simple counting problem :) . Count the difference of alphabets if it\\'s 2 easy swap and if it\\'s more require multiple swap and if there is no difference between s and goal check for repeating alphabet in s"
                    }
                ]
            },
            {
                "id": 1954145,
                "content": [
                    {
                        "username": "wusi2cool",
                        "content": "should have made it clear we could only do a single swap and multiple swap is not allowed."
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "HINT ALERT\\n\\n- check lengths and counts of each character in  `s` and `goal`\\n- check if a character has a `copy`, so if the strings are equal, its still possible.\\n- if counts don\\'t line up, return.\\n- if `difference` then its possible.\\n- if no `difference` but `copy` is true, its still possible."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "After being destoryed by pre hard problems, it is easy..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "such a vague description"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "s =\"aaaaaaabc\" goal=\"aaaaaaacb\" \\nshould return false or true.\\nATQ => it should return false.\\ntestcase expecting true. \\nAny solution why is it happening?"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "[@abukafq](/abukafq) Yes I got it, I was only swaping the first two characters."
                    },
                    {
                        "username": "abukafq",
                        "content": "last 2 position can be swap.\\nHence, true"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**This string is  bad buddy .**"
                    },
                    {
                        "username": "Hariom51",
                        "content": "what is a sense of having a string of length 1 ? "
                    },
                    {
                        "username": "programmer0073",
                        "content": "Finally easy with 30% Acceptance Rate. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Easy with the lower acceptance are the worst ones!"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Edge Cases\\n1) The length of s and goal can be different. (In this case return false)\\n2) If the two strings are identical return true only if they contain a repeated letter. Eg: s = aab, goal =aab ,Here index of 0 and 1 can be swapped to get goal."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "This is actually a simple counting problem :) . Count the difference of alphabets if it\\'s 2 easy swap and if it\\'s more require multiple swap and if there is no difference between s and goal check for repeating alphabet in s"
                    }
                ]
            },
            {
                "id": 1954116,
                "content": [
                    {
                        "username": "wusi2cool",
                        "content": "should have made it clear we could only do a single swap and multiple swap is not allowed."
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "HINT ALERT\\n\\n- check lengths and counts of each character in  `s` and `goal`\\n- check if a character has a `copy`, so if the strings are equal, its still possible.\\n- if counts don\\'t line up, return.\\n- if `difference` then its possible.\\n- if no `difference` but `copy` is true, its still possible."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "After being destoryed by pre hard problems, it is easy..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "such a vague description"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "s =\"aaaaaaabc\" goal=\"aaaaaaacb\" \\nshould return false or true.\\nATQ => it should return false.\\ntestcase expecting true. \\nAny solution why is it happening?"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "[@abukafq](/abukafq) Yes I got it, I was only swaping the first two characters."
                    },
                    {
                        "username": "abukafq",
                        "content": "last 2 position can be swap.\\nHence, true"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**This string is  bad buddy .**"
                    },
                    {
                        "username": "Hariom51",
                        "content": "what is a sense of having a string of length 1 ? "
                    },
                    {
                        "username": "programmer0073",
                        "content": "Finally easy with 30% Acceptance Rate. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Easy with the lower acceptance are the worst ones!"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Edge Cases\\n1) The length of s and goal can be different. (In this case return false)\\n2) If the two strings are identical return true only if they contain a repeated letter. Eg: s = aab, goal =aab ,Here index of 0 and 1 can be swapped to get goal."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "This is actually a simple counting problem :) . Count the difference of alphabets if it\\'s 2 easy swap and if it\\'s more require multiple swap and if there is no difference between s and goal check for repeating alphabet in s"
                    }
                ]
            },
            {
                "id": 1954112,
                "content": [
                    {
                        "username": "aDDyy",
                        "content": "So stupid type question!!!!\\uD83D\\uDE44\\uD83D\\uDE2B"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Almost a medium I think. Almost."
                    },
                    {
                        "username": "Prajju22",
                        "content": "finally a streak of 260! after struggling the whole weeek."
                    },
                    {
                        "username": "Aadil42",
                        "content": "The edge cases are such a bitch!"
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "This is not easy for me !!"
                    },
                    {
                        "username": "letrung",
                        "content": "This is not a really easy one, we have to cover a few of edge cases that are not shown in the description example."
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "finally, an easy one"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Who\\'s gonna mention, how many times we can do this operation\\uD83D\\uDE44"
                    },
                    {
                        "username": "omkarsase",
                        "content": "for s = \"ccaa\" and goal = \"aacc\"\\n\\nwe can convert \\'s\\' to \\'goal\\' by swapping characters present at (0, 2) and (1,3).\\nthen why it expects answer to be false ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Swapping `s[0]` with `goal[2]` is one operation, swapping `s[1]` with `goal[3]` is another operation.  \\nBut you must perform exactly one operation."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Can anyone explain why test case 30 is like this :\\ns = \"abcd\"\\ngoal = \"badc\"\\n\\nthe expected result is false. Shouldn\\'t it be true??"
                    },
                    {
                        "username": "anjali_01p",
                        "content": "question says to have only one swap, here to get the goal, it will need two swaps (one between 0th and 1st index and other between 2nd and 3rd index), so that\\'s why it\\'s false"
                    }
                ]
            },
            {
                "id": 1954105,
                "content": [
                    {
                        "username": "aDDyy",
                        "content": "So stupid type question!!!!\\uD83D\\uDE44\\uD83D\\uDE2B"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Almost a medium I think. Almost."
                    },
                    {
                        "username": "Prajju22",
                        "content": "finally a streak of 260! after struggling the whole weeek."
                    },
                    {
                        "username": "Aadil42",
                        "content": "The edge cases are such a bitch!"
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "This is not easy for me !!"
                    },
                    {
                        "username": "letrung",
                        "content": "This is not a really easy one, we have to cover a few of edge cases that are not shown in the description example."
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "finally, an easy one"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Who\\'s gonna mention, how many times we can do this operation\\uD83D\\uDE44"
                    },
                    {
                        "username": "omkarsase",
                        "content": "for s = \"ccaa\" and goal = \"aacc\"\\n\\nwe can convert \\'s\\' to \\'goal\\' by swapping characters present at (0, 2) and (1,3).\\nthen why it expects answer to be false ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Swapping `s[0]` with `goal[2]` is one operation, swapping `s[1]` with `goal[3]` is another operation.  \\nBut you must perform exactly one operation."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Can anyone explain why test case 30 is like this :\\ns = \"abcd\"\\ngoal = \"badc\"\\n\\nthe expected result is false. Shouldn\\'t it be true??"
                    },
                    {
                        "username": "anjali_01p",
                        "content": "question says to have only one swap, here to get the goal, it will need two swaps (one between 0th and 1st index and other between 2nd and 3rd index), so that\\'s why it\\'s false"
                    }
                ]
            },
            {
                "id": 1954088,
                "content": [
                    {
                        "username": "aDDyy",
                        "content": "So stupid type question!!!!\\uD83D\\uDE44\\uD83D\\uDE2B"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Almost a medium I think. Almost."
                    },
                    {
                        "username": "Prajju22",
                        "content": "finally a streak of 260! after struggling the whole weeek."
                    },
                    {
                        "username": "Aadil42",
                        "content": "The edge cases are such a bitch!"
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "This is not easy for me !!"
                    },
                    {
                        "username": "letrung",
                        "content": "This is not a really easy one, we have to cover a few of edge cases that are not shown in the description example."
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "finally, an easy one"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Who\\'s gonna mention, how many times we can do this operation\\uD83D\\uDE44"
                    },
                    {
                        "username": "omkarsase",
                        "content": "for s = \"ccaa\" and goal = \"aacc\"\\n\\nwe can convert \\'s\\' to \\'goal\\' by swapping characters present at (0, 2) and (1,3).\\nthen why it expects answer to be false ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Swapping `s[0]` with `goal[2]` is one operation, swapping `s[1]` with `goal[3]` is another operation.  \\nBut you must perform exactly one operation."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Can anyone explain why test case 30 is like this :\\ns = \"abcd\"\\ngoal = \"badc\"\\n\\nthe expected result is false. Shouldn\\'t it be true??"
                    },
                    {
                        "username": "anjali_01p",
                        "content": "question says to have only one swap, here to get the goal, it will need two swaps (one between 0th and 1st index and other between 2nd and 3rd index), so that\\'s why it\\'s false"
                    }
                ]
            },
            {
                "id": 1954086,
                "content": [
                    {
                        "username": "aDDyy",
                        "content": "So stupid type question!!!!\\uD83D\\uDE44\\uD83D\\uDE2B"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Almost a medium I think. Almost."
                    },
                    {
                        "username": "Prajju22",
                        "content": "finally a streak of 260! after struggling the whole weeek."
                    },
                    {
                        "username": "Aadil42",
                        "content": "The edge cases are such a bitch!"
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "This is not easy for me !!"
                    },
                    {
                        "username": "letrung",
                        "content": "This is not a really easy one, we have to cover a few of edge cases that are not shown in the description example."
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "finally, an easy one"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Who\\'s gonna mention, how many times we can do this operation\\uD83D\\uDE44"
                    },
                    {
                        "username": "omkarsase",
                        "content": "for s = \"ccaa\" and goal = \"aacc\"\\n\\nwe can convert \\'s\\' to \\'goal\\' by swapping characters present at (0, 2) and (1,3).\\nthen why it expects answer to be false ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Swapping `s[0]` with `goal[2]` is one operation, swapping `s[1]` with `goal[3]` is another operation.  \\nBut you must perform exactly one operation."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Can anyone explain why test case 30 is like this :\\ns = \"abcd\"\\ngoal = \"badc\"\\n\\nthe expected result is false. Shouldn\\'t it be true??"
                    },
                    {
                        "username": "anjali_01p",
                        "content": "question says to have only one swap, here to get the goal, it will need two swaps (one between 0th and 1st index and other between 2nd and 3rd index), so that\\'s why it\\'s false"
                    }
                ]
            },
            {
                "id": 1954081,
                "content": [
                    {
                        "username": "aDDyy",
                        "content": "So stupid type question!!!!\\uD83D\\uDE44\\uD83D\\uDE2B"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Almost a medium I think. Almost."
                    },
                    {
                        "username": "Prajju22",
                        "content": "finally a streak of 260! after struggling the whole weeek."
                    },
                    {
                        "username": "Aadil42",
                        "content": "The edge cases are such a bitch!"
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "This is not easy for me !!"
                    },
                    {
                        "username": "letrung",
                        "content": "This is not a really easy one, we have to cover a few of edge cases that are not shown in the description example."
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "finally, an easy one"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Who\\'s gonna mention, how many times we can do this operation\\uD83D\\uDE44"
                    },
                    {
                        "username": "omkarsase",
                        "content": "for s = \"ccaa\" and goal = \"aacc\"\\n\\nwe can convert \\'s\\' to \\'goal\\' by swapping characters present at (0, 2) and (1,3).\\nthen why it expects answer to be false ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Swapping `s[0]` with `goal[2]` is one operation, swapping `s[1]` with `goal[3]` is another operation.  \\nBut you must perform exactly one operation."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Can anyone explain why test case 30 is like this :\\ns = \"abcd\"\\ngoal = \"badc\"\\n\\nthe expected result is false. Shouldn\\'t it be true??"
                    },
                    {
                        "username": "anjali_01p",
                        "content": "question says to have only one swap, here to get the goal, it will need two swaps (one between 0th and 1st index and other between 2nd and 3rd index), so that\\'s why it\\'s false"
                    }
                ]
            },
            {
                "id": 1954067,
                "content": [
                    {
                        "username": "aDDyy",
                        "content": "So stupid type question!!!!\\uD83D\\uDE44\\uD83D\\uDE2B"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Almost a medium I think. Almost."
                    },
                    {
                        "username": "Prajju22",
                        "content": "finally a streak of 260! after struggling the whole weeek."
                    },
                    {
                        "username": "Aadil42",
                        "content": "The edge cases are such a bitch!"
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "This is not easy for me !!"
                    },
                    {
                        "username": "letrung",
                        "content": "This is not a really easy one, we have to cover a few of edge cases that are not shown in the description example."
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "finally, an easy one"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Who\\'s gonna mention, how many times we can do this operation\\uD83D\\uDE44"
                    },
                    {
                        "username": "omkarsase",
                        "content": "for s = \"ccaa\" and goal = \"aacc\"\\n\\nwe can convert \\'s\\' to \\'goal\\' by swapping characters present at (0, 2) and (1,3).\\nthen why it expects answer to be false ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Swapping `s[0]` with `goal[2]` is one operation, swapping `s[1]` with `goal[3]` is another operation.  \\nBut you must perform exactly one operation."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Can anyone explain why test case 30 is like this :\\ns = \"abcd\"\\ngoal = \"badc\"\\n\\nthe expected result is false. Shouldn\\'t it be true??"
                    },
                    {
                        "username": "anjali_01p",
                        "content": "question says to have only one swap, here to get the goal, it will need two swaps (one between 0th and 1st index and other between 2nd and 3rd index), so that\\'s why it\\'s false"
                    }
                ]
            },
            {
                "id": 1954059,
                "content": [
                    {
                        "username": "aDDyy",
                        "content": "So stupid type question!!!!\\uD83D\\uDE44\\uD83D\\uDE2B"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Almost a medium I think. Almost."
                    },
                    {
                        "username": "Prajju22",
                        "content": "finally a streak of 260! after struggling the whole weeek."
                    },
                    {
                        "username": "Aadil42",
                        "content": "The edge cases are such a bitch!"
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "This is not easy for me !!"
                    },
                    {
                        "username": "letrung",
                        "content": "This is not a really easy one, we have to cover a few of edge cases that are not shown in the description example."
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "finally, an easy one"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Who\\'s gonna mention, how many times we can do this operation\\uD83D\\uDE44"
                    },
                    {
                        "username": "omkarsase",
                        "content": "for s = \"ccaa\" and goal = \"aacc\"\\n\\nwe can convert \\'s\\' to \\'goal\\' by swapping characters present at (0, 2) and (1,3).\\nthen why it expects answer to be false ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Swapping `s[0]` with `goal[2]` is one operation, swapping `s[1]` with `goal[3]` is another operation.  \\nBut you must perform exactly one operation."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Can anyone explain why test case 30 is like this :\\ns = \"abcd\"\\ngoal = \"badc\"\\n\\nthe expected result is false. Shouldn\\'t it be true??"
                    },
                    {
                        "username": "anjali_01p",
                        "content": "question says to have only one swap, here to get the goal, it will need two swaps (one between 0th and 1st index and other between 2nd and 3rd index), so that\\'s why it\\'s false"
                    }
                ]
            },
            {
                "id": 1954057,
                "content": [
                    {
                        "username": "aDDyy",
                        "content": "So stupid type question!!!!\\uD83D\\uDE44\\uD83D\\uDE2B"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Almost a medium I think. Almost."
                    },
                    {
                        "username": "Prajju22",
                        "content": "finally a streak of 260! after struggling the whole weeek."
                    },
                    {
                        "username": "Aadil42",
                        "content": "The edge cases are such a bitch!"
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "This is not easy for me !!"
                    },
                    {
                        "username": "letrung",
                        "content": "This is not a really easy one, we have to cover a few of edge cases that are not shown in the description example."
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "finally, an easy one"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Who\\'s gonna mention, how many times we can do this operation\\uD83D\\uDE44"
                    },
                    {
                        "username": "omkarsase",
                        "content": "for s = \"ccaa\" and goal = \"aacc\"\\n\\nwe can convert \\'s\\' to \\'goal\\' by swapping characters present at (0, 2) and (1,3).\\nthen why it expects answer to be false ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Swapping `s[0]` with `goal[2]` is one operation, swapping `s[1]` with `goal[3]` is another operation.  \\nBut you must perform exactly one operation."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Can anyone explain why test case 30 is like this :\\ns = \"abcd\"\\ngoal = \"badc\"\\n\\nthe expected result is false. Shouldn\\'t it be true??"
                    },
                    {
                        "username": "anjali_01p",
                        "content": "question says to have only one swap, here to get the goal, it will need two swaps (one between 0th and 1st index and other between 2nd and 3rd index), so that\\'s why it\\'s false"
                    }
                ]
            },
            {
                "id": 1954009,
                "content": [
                    {
                        "username": "aDDyy",
                        "content": "So stupid type question!!!!\\uD83D\\uDE44\\uD83D\\uDE2B"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Almost a medium I think. Almost."
                    },
                    {
                        "username": "Prajju22",
                        "content": "finally a streak of 260! after struggling the whole weeek."
                    },
                    {
                        "username": "Aadil42",
                        "content": "The edge cases are such a bitch!"
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "This is not easy for me !!"
                    },
                    {
                        "username": "letrung",
                        "content": "This is not a really easy one, we have to cover a few of edge cases that are not shown in the description example."
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "finally, an easy one"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Who\\'s gonna mention, how many times we can do this operation\\uD83D\\uDE44"
                    },
                    {
                        "username": "omkarsase",
                        "content": "for s = \"ccaa\" and goal = \"aacc\"\\n\\nwe can convert \\'s\\' to \\'goal\\' by swapping characters present at (0, 2) and (1,3).\\nthen why it expects answer to be false ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Swapping `s[0]` with `goal[2]` is one operation, swapping `s[1]` with `goal[3]` is another operation.  \\nBut you must perform exactly one operation."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Can anyone explain why test case 30 is like this :\\ns = \"abcd\"\\ngoal = \"badc\"\\n\\nthe expected result is false. Shouldn\\'t it be true??"
                    },
                    {
                        "username": "anjali_01p",
                        "content": "question says to have only one swap, here to get the goal, it will need two swaps (one between 0th and 1st index and other between 2nd and 3rd index), so that\\'s why it\\'s false"
                    }
                ]
            },
            {
                "id": 1849542,
                "content": [
                    {
                        "username": "aDDyy",
                        "content": "So stupid type question!!!!\\uD83D\\uDE44\\uD83D\\uDE2B"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Almost a medium I think. Almost."
                    },
                    {
                        "username": "Prajju22",
                        "content": "finally a streak of 260! after struggling the whole weeek."
                    },
                    {
                        "username": "Aadil42",
                        "content": "The edge cases are such a bitch!"
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "This is not easy for me !!"
                    },
                    {
                        "username": "letrung",
                        "content": "This is not a really easy one, we have to cover a few of edge cases that are not shown in the description example."
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "finally, an easy one"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Who\\'s gonna mention, how many times we can do this operation\\uD83D\\uDE44"
                    },
                    {
                        "username": "omkarsase",
                        "content": "for s = \"ccaa\" and goal = \"aacc\"\\n\\nwe can convert \\'s\\' to \\'goal\\' by swapping characters present at (0, 2) and (1,3).\\nthen why it expects answer to be false ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Swapping `s[0]` with `goal[2]` is one operation, swapping `s[1]` with `goal[3]` is another operation.  \\nBut you must perform exactly one operation."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Can anyone explain why test case 30 is like this :\\ns = \"abcd\"\\ngoal = \"badc\"\\n\\nthe expected result is false. Shouldn\\'t it be true??"
                    },
                    {
                        "username": "anjali_01p",
                        "content": "question says to have only one swap, here to get the goal, it will need two swaps (one between 0th and 1st index and other between 2nd and 3rd index), so that\\'s why it\\'s false"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Remove to Make Valid Parentheses",
        "question_content": "<p>Given a string <font face=\"monospace\">s</font> of <code>&#39;(&#39;</code> , <code>&#39;)&#39;</code> and lowercase English characters.</p>\n\n<p>Your task is to remove the minimum number of parentheses ( <code>&#39;(&#39;</code> or <code>&#39;)&#39;</code>, in any positions ) so that the resulting <em>parentheses string</em> is valid and return <strong>any</strong> valid string.</p>\n\n<p>Formally, a <em>parentheses string</em> is valid if and only if:</p>\n\n<ul>\n\t<li>It is the empty string, contains only lowercase characters, or</li>\n\t<li>It can be written as <code>AB</code> (<code>A</code> concatenated with <code>B</code>), where <code>A</code> and <code>B</code> are valid strings, or</li>\n\t<li>It can be written as <code>(A)</code>, where <code>A</code> is a valid string.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;lee(t(c)o)de)&quot;\n<strong>Output:</strong> &quot;lee(t(c)o)de&quot;\n<strong>Explanation:</strong> &quot;lee(t(co)de)&quot; , &quot;lee(t(c)ode)&quot; would also be accepted.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a)b(c)d&quot;\n<strong>Output:</strong> &quot;ab(c)d&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;))((&quot;\n<strong>Output:</strong> &quot;&quot;\n<strong>Explanation:</strong> An empty string is also valid.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is either<code>&#39;(&#39;</code> , <code>&#39;)&#39;</code>, or lowercase English letter<code>.</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1850411,
                "title": "python-javascript-easy-solution-with-very-clear-explanation",
                "content": "**Please dont downvote guys if cannot support,We are putting lot of effort in it\\uD83D\\uDE42**\\n\\n```\\nWhat the Question asking us to do \\uD83E\\uDD14 ?\\nYour task is to remove the minimum number of parentheses ( \\'(\\' or \\')\\', in any positions )\\nso that the resulting parentheses string is valid and return any valid string\\n```\\n\\n![image](https://assets.leetcode.com/users/images/bd148e51-991a-4cea-9683-831cc402b696_1647314863.6571114.gif)\\n\\n![image](https://assets.leetcode.com/users/images/a56af075-c77d-476b-9105-996c19fe3d8e_1647314916.9967928.gif)\\n\\n\\n![image](https://assets.leetcode.com/users/images/d8f0c7fd-88a3-467a-aded-c698cb73b595_1647320162.3985708.gif)\\n\\n\\n```\\nBig o:\\n    n-->size of the s\\n    Time: O(n)\\n    Space: O(n)\\n```\\n\\n`Javascript`\\n\\n```\\nconst minRemoveToMakeValid = (str)=> {\\n     const stack = [];\\n  const splitted_str = str.split(\"\");\\n  for (let i = 0; i < str.length; i++) {\\n    const char = str[i];\\n    if (char === \"(\") stack.push(i); // if curr char is (  then we will push into our stack\\n    else if (char === \")\") {\\n      if (stack.length === 0) {\\n          // if out stack is empty then we will make ) as \\'\\'\\n        splitted_str[i] = \"\";\\n      } else {\\n          //! if stack is not empty then we will pop top of the stack\\n        stack.pop();\\n      }\\n    }\\n  }\\n    // if we have extra ( bracket we will remove it by making it as \\'\\'\\n  for (let i = 0; i < stack.length; i++) {\\n    const char = stack[i];\\n    splitted_str[char] = \"\";\\n  }\\n\\n  return splitted_str.join(\"\"); // at last we will join the splitted_str\\n};\\n```\\n\\n`Python`\\n\\n```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s) :\\n        stack=[]\\n        split_str=list(s)\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                # if current char is \\'(\\' then push it to stack\\n                stack.append(i)\\n            elif s[i]==\\')\\':\\n                # if current char is \\')\\' then pop top of the stack\\n                if len(stack) !=0:\\n                    stack.pop()\\n                else:\\n                    # if our stack is empty then we can\\'t pop so make  current char as \\'\\'\\n                    split_str[i]=\"\"\\n        for i in stack:\\n            split_str[i]=\"\"\\n        return \\'\\' .join(split_str)\\n```\\n\\n```\\nUPVOTE if you like \\uD83D\\uDE03 , If you have any question, feel free to ask.\\n```",
                "solutionTags": [
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nWhat the Question asking us to do \\uD83E\\uDD14 ?\\nYour task is to remove the minimum number of parentheses ( \\'(\\' or \\')\\', in any positions )\\nso that the resulting parentheses string is valid and return any valid string\\n```\n```\\nBig o:\\n    n-->size of the s\\n    Time: O(n)\\n    Space: O(n)\\n```\n```\\nconst minRemoveToMakeValid = (str)=> {\\n     const stack = [];\\n  const splitted_str = str.split(\"\");\\n  for (let i = 0; i < str.length; i++) {\\n    const char = str[i];\\n    if (char === \"(\") stack.push(i); // if curr char is (  then we will push into our stack\\n    else if (char === \")\") {\\n      if (stack.length === 0) {\\n          // if out stack is empty then we will make ) as \\'\\'\\n        splitted_str[i] = \"\";\\n      } else {\\n          //! if stack is not empty then we will pop top of the stack\\n        stack.pop();\\n      }\\n    }\\n  }\\n    // if we have extra ( bracket we will remove it by making it as \\'\\'\\n  for (let i = 0; i < stack.length; i++) {\\n    const char = stack[i];\\n    splitted_str[char] = \"\";\\n  }\\n\\n  return splitted_str.join(\"\"); // at last we will join the splitted_str\\n};\\n```\n```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s) :\\n        stack=[]\\n        split_str=list(s)\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                # if current char is \\'(\\' then push it to stack\\n                stack.append(i)\\n            elif s[i]==\\')\\':\\n                # if current char is \\')\\' then pop top of the stack\\n                if len(stack) !=0:\\n                    stack.pop()\\n                else:\\n                    # if our stack is empty then we can\\'t pop so make  current char as \\'\\'\\n                    split_str[i]=\"\"\\n        for i in stack:\\n            split_str[i]=\"\"\\n        return \\'\\' .join(split_str)\\n```\n```\\nUPVOTE if you like \\uD83D\\uDE03 , If you have any question, feel free to ask.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850228,
                "title": "java-4-solutions-with-slight-optimisations",
                "content": "\\uD83D\\uDCCE A similar question to this is :\\n\\n[Min swaps to make string balanced](https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/discuss/1676045/Java-4-Solutions-or-Intuition-or-O(n)-or-O(1)-Solutions)\\n\\n****\\n\\n\\u2318 Given statement : \\n* Your task is to remove the minimum number of parentheses.\\n* return any valid string.\\n\\n\\u2318 Observations : \\n\\nIt is quite obvious to get a hunch of using stack when we see a parenthesis problem but we can for sure optimise the space in such a case where the input is limited. [ eg: `here s[i] is either\\'(\\' , \\')\\', or lowercase English letter` ].\\n\\n****\\n# Solution 1 : Stack\\n```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i=0;i<s.length();i++) {\\n            char ch = s.charAt(i);\\n            if(Character.isAlphabetic(ch))\\n                continue;\\n            if(ch == \\'(\\')\\n                stack.push(i);\\n            else {\\n                if(!stack.isEmpty() && s.charAt(stack.peek()) == \\'(\\')\\n                    stack.pop();\\n                else stack.push(i);\\n            }\\n        }\\n        \\n        // if(stack.size() == 0) return \"\";\\n        \\n        StringBuilder result = new StringBuilder();\\n        HashSet<Integer> set = new HashSet<>(stack);\\n        for(int i=0;i<s.length();i++)\\n            if(!set.contains(i))\\n                result.append(s.charAt(i));\\n        \\n        return result.toString();\\n    }\\n}\\n```\\n\\n****\\n# Solution 2 : Using Deque\\n```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n\\t\\tif (s == null || s.length() == 0) {\\n            return s;\\n        }\\n        \\n        char[] chars = s.toCharArray();\\n        Deque<Integer> deque = new ArrayDeque<>();\\n\\t\\t\\n\\t\\t// push invalid indices in deque\\n        for (int i = 0; i < chars.length; i++) {\\n            char c = chars[i];\\n            if (c == \\'(\\') {\\n                deque.push(i);\\n            } else if (c == \\')\\') {\\n                if (deque.isEmpty()) {\\n                    chars[i] = \\'#\\';\\n                } else {\\n                    deque.pop();\\n                }\\n            } \\n        }\\n        // mark invalid indices\\n        while (!deque.isEmpty()) {\\n            chars[deque.pop()] = \\'#\\';\\n        }\\n        \\n        StringBuilder ans = new StringBuilder();\\n        for (char c : chars) {\\n            if (c != \\'#\\') {\\n                ans.append(c);\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\n```\\n\\n# Constant Solutions : \\n\\u2318 Constant Solution 1 : [ ` Slow as we are using insert() function ` ]\\n\\n\\u2714\\uFE0F Logic : [ `2 steps` ]\\n * remove invalid close parenthesis\\n * remove invalid open parenthesis\\n\\n```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        StringBuilder R = new StringBuilder();\\n        int open = 0, close = 0;\\n        \\n        // remove invalid close parenthesis\\n        for(char ch : s.toCharArray()) {\\n            if(Character.isAlphabetic(ch)) {\\n                R.append(ch);\\n            }\\n            else if(ch==\\'(\\') {\\n                open++;\\n                R.append(ch);\\n            }\\n            else {\\n                if(open > close) { // if there is an \\'(\\' to be considered for a valid pair\\n                    R.append(ch);\\n                    close++;\\n                }\\n                else {\\n                    open = open < 0 ? 0 : open--;\\n                }\\n            }\\n        }\\n\\n        s = R.toString();\\n        R.setLength(0); // reset ans\\n        int n = s.length();\\n        open = close = 0;\\n\\t\\t\\n\\t\\t// remove invalid open parenthesis\\n\\t\\t\\n        for(int i=n-1;i>=0;i--) {\\n            char ch = s.charAt(i);\\n            if(Character.isAlphabetic(ch)) {\\n                R.insert(0, ch);\\n            }\\n            else if(ch == \\')\\') {\\n                R.insert(0, ch);\\n                close++;\\n            }\\n            else {\\n                if(close > open) {\\n                    R.insert(0, ch);\\n                    open++;\\n                }\\n                else {\\n                    close = close < 0 ? 0 : close--;\\n                }\\n            }\\n        }        \\n        return R.toString();\\n    }\\n}\\n```\\n****\\n\\n\\u2318 A not so contant solution : [ `used a char [] ` ]\\n```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        StringBuilder R = new StringBuilder();\\n        int open = 0, close = 0;\\n        \\n        // remove invalid close parenthesis\\n        for(char ch : s.toCharArray()) {\\n            if(Character.isAlphabetic(ch)) {\\n                R.append(ch);\\n            }\\n            else if(ch==\\'(\\') {\\n                open++;\\n                R.append(ch);\\n            }\\n            else {\\n                if(open > close) {\\n                    R.append(ch);\\n                    close++;\\n                }\\n                else {\\n                    open = open < 0 ? 0 : open--;\\n                }\\n            }\\n        }\\n\\n        // remove invalid open parenthesis\\n        s = R.toString();\\n        int n = s.length();\\n        R.setLength(0);\\n        open = close = 0;\\n        char[] A = s.toCharArray();\\n        \\n        for(int i=n-1;i>=0;i--) {\\n            char ch = s.charAt(i);\\n            if(Character.isAlphabetic(ch)) {\\n                continue;\\n            }\\n            else if(ch == \\')\\') {\\n                close++;\\n            }\\n            else {\\n                if(close > open) {\\n                    open++;\\n                }\\n                else {\\n                    A[i] = \\'*\\';\\n                    close = close < 0 ? 0 : close--;\\n                }\\n            }\\n        }\\n        \\n        for(char ch : A) \\n            if(ch!=\\'*\\')\\n                R.append(ch);\\n        \\n        return R.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i=0;i<s.length();i++) {\\n            char ch = s.charAt(i);\\n            if(Character.isAlphabetic(ch))\\n                continue;\\n            if(ch == \\'(\\')\\n                stack.push(i);\\n            else {\\n                if(!stack.isEmpty() && s.charAt(stack.peek()) == \\'(\\')\\n                    stack.pop();\\n                else stack.push(i);\\n            }\\n        }\\n        \\n        // if(stack.size() == 0) return \"\";\\n        \\n        StringBuilder result = new StringBuilder();\\n        HashSet<Integer> set = new HashSet<>(stack);\\n        for(int i=0;i<s.length();i++)\\n            if(!set.contains(i))\\n                result.append(s.charAt(i));\\n        \\n        return result.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n\\t\\tif (s == null || s.length() == 0) {\\n            return s;\\n        }\\n        \\n        char[] chars = s.toCharArray();\\n        Deque<Integer> deque = new ArrayDeque<>();\\n\\t\\t\\n\\t\\t// push invalid indices in deque\\n        for (int i = 0; i < chars.length; i++) {\\n            char c = chars[i];\\n            if (c == \\'(\\') {\\n                deque.push(i);\\n            } else if (c == \\')\\') {\\n                if (deque.isEmpty()) {\\n                    chars[i] = \\'#\\';\\n                } else {\\n                    deque.pop();\\n                }\\n            } \\n        }\\n        // mark invalid indices\\n        while (!deque.isEmpty()) {\\n            chars[deque.pop()] = \\'#\\';\\n        }\\n        \\n        StringBuilder ans = new StringBuilder();\\n        for (char c : chars) {\\n            if (c != \\'#\\') {\\n                ans.append(c);\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        StringBuilder R = new StringBuilder();\\n        int open = 0, close = 0;\\n        \\n        // remove invalid close parenthesis\\n        for(char ch : s.toCharArray()) {\\n            if(Character.isAlphabetic(ch)) {\\n                R.append(ch);\\n            }\\n            else if(ch==\\'(\\') {\\n                open++;\\n                R.append(ch);\\n            }\\n            else {\\n                if(open > close) { // if there is an \\'(\\' to be considered for a valid pair\\n                    R.append(ch);\\n                    close++;\\n                }\\n                else {\\n                    open = open < 0 ? 0 : open--;\\n                }\\n            }\\n        }\\n\\n        s = R.toString();\\n        R.setLength(0); // reset ans\\n        int n = s.length();\\n        open = close = 0;\\n\\t\\t\\n\\t\\t// remove invalid open parenthesis\\n\\t\\t\\n        for(int i=n-1;i>=0;i--) {\\n            char ch = s.charAt(i);\\n            if(Character.isAlphabetic(ch)) {\\n                R.insert(0, ch);\\n            }\\n            else if(ch == \\')\\') {\\n                R.insert(0, ch);\\n                close++;\\n            }\\n            else {\\n                if(close > open) {\\n                    R.insert(0, ch);\\n                    open++;\\n                }\\n                else {\\n                    close = close < 0 ? 0 : close--;\\n                }\\n            }\\n        }        \\n        return R.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        StringBuilder R = new StringBuilder();\\n        int open = 0, close = 0;\\n        \\n        // remove invalid close parenthesis\\n        for(char ch : s.toCharArray()) {\\n            if(Character.isAlphabetic(ch)) {\\n                R.append(ch);\\n            }\\n            else if(ch==\\'(\\') {\\n                open++;\\n                R.append(ch);\\n            }\\n            else {\\n                if(open > close) {\\n                    R.append(ch);\\n                    close++;\\n                }\\n                else {\\n                    open = open < 0 ? 0 : open--;\\n                }\\n            }\\n        }\\n\\n        // remove invalid open parenthesis\\n        s = R.toString();\\n        int n = s.length();\\n        R.setLength(0);\\n        open = close = 0;\\n        char[] A = s.toCharArray();\\n        \\n        for(int i=n-1;i>=0;i--) {\\n            char ch = s.charAt(i);\\n            if(Character.isAlphabetic(ch)) {\\n                continue;\\n            }\\n            else if(ch == \\')\\') {\\n                close++;\\n            }\\n            else {\\n                if(close > open) {\\n                    open++;\\n                }\\n                else {\\n                    A[i] = \\'*\\';\\n                    close = close < 0 ? 0 : close--;\\n                }\\n            }\\n        }\\n        \\n        for(char ch : A) \\n            if(ch!=\\'*\\')\\n                R.append(ch);\\n        \\n        return R.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419402,
                "title": "java-c-stack",
                "content": "#### Intuition\\nTo make the string valid with minimum removals, we need to get rid of all parentheses that do not have a matching pair.\\n\\n1. Push char index into the stack when we see `\\'(\\'`.\\n\\n2. Pop from the stack when we see `\\')\\'`.\\n\\n\\t- If the stack is empty, then we have `\\')\\'` without the pair, and it needs to be removed.\\n\\n3. In the end, the stack will contain indexes of `\\'(\\'` without the pair, if any. We need to remove all of them too. \\n\\n**Update:** check out the new approach 2 that collects indexes of all mismatched parentheses, and removes them right-to-left.\\n\\n#### Approach 1: Stack and Placeholder\\n\\nWe mark removed parentheses with `\\'*\\'`, and erase all of them in the end.\\n\\n**Java**\\n```Java\\npublic String minRemoveToMakeValid(String s) {\\n  StringBuilder sb = new StringBuilder(s);\\n  Stack<Integer> st = new Stack<>();\\n  for (int i = 0; i < sb.length(); ++i) {\\n    if (sb.charAt(i) == \\'(\\') st.add(i);\\n    if (sb.charAt(i) == \\')\\') {\\n      if (!st.empty()) st.pop();\\n      else sb.setCharAt(i, \\'*\\');\\n    }\\n  }\\n  while (!st.empty())\\n    sb.setCharAt(st.pop(), \\'*\\');\\n  return sb.toString().replaceAll(\"\\\\\\\\*\", \"\");\\n}\\n```\\n**C++**\\n```CPP\\nstring minRemoveToMakeValid(string s) {\\n  stack<int> st;\\n  for (auto i = 0; i < s.size(); ++i) {\\n    if (s[i] == \\'(\\') st.push(i);\\n    if (s[i] == \\')\\') {\\n      if (!st.empty()) st.pop();\\n      else s[i] = \\'*\\';\\n    }\\n  }\\n  while (!st.empty()) {\\n    s[st.top()] = \\'*\\';\\n    st.pop();\\n  }\\n  s.erase(remove(s.begin(), s.end(), \\'*\\'), s.end());\\n  return s;\\n}\\n```\\n#### Approach 2: Stack with Tracking\\n\\nInstead of using placeholders, we can track indexes of all mismatched parentheses, and erase them in the end going right-to-left. This idea was inspired by [dibdidib](https://leetcode.com/dibdidib/).\\n\\nWe can introduce another stack to collect indexes of mismatched `\\')\\'`, or we can use the same stack and mark mismatched `\\')\\'` somehow. Here, we just negate the index to indicate `\\')\\'`.\\n\\n> Note that I am adding `1` to make the index `1`-based. You cannot tell if zero is negated :)\\n\\n**Java**\\n```Java\\npublic String minRemoveToMakeValid(String s) {\\n  StringBuilder sb = new StringBuilder(s);\\n  Stack<Integer> st = new Stack();\\n  for (int i = 0; i < sb.length(); ++i) {\\n    if (sb.charAt(i) == \\'(\\') st.add(i + 1);\\n    if (sb.charAt(i) == \\')\\') {\\n      if (!st.empty() && st.peek() >= 0) st.pop();\\n      else st.add(-(i + 1));\\n    }\\n  }\\n  while (!st.empty())\\n    sb.deleteCharAt(Math.abs(st.pop()) - 1);\\n  return sb.toString();\\n}\\n```\\nIf we want to optimize for the worst-case scenario, we should avoid `deleteCharAt` inside the loop. Instead, we can copy characters that do not appear in the stack into another string builder. Since characters in the stack are naturally sorted, we can use two-pointer technique to do it in the linear time.\\n> Note that for the OJ test cases, the runtime of this solution is a bit worse than for `deleteCharAt`.\\n```\\npublic String minRemoveToMakeValid(String s) {\\n  StringBuilder sb = new StringBuilder(s), sb1 = new StringBuilder();\\n  Stack<Integer> st = new Stack();\\n  for (int i = 0; i < sb.length(); ++i) {\\n    if (sb.charAt(i) == \\'(\\') st.add(i + 1);\\n    if (sb.charAt(i) == \\')\\') {\\n      if (!st.empty() && st.peek() >= 0) st.pop();\\n      else st.add(-(i + 1));\\n    }\\n  }\\n  for(int i = 0, j = 0; i < sb.length(); ++i) {\\n      if (j >= st.size() || i != Math.abs(st.elementAt(j)) - 1) {\\n        sb1.append(sb.charAt(i));\\n      } else ++j;\\n  }\\n  return sb1.toString();\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n). We process each character once, or twice for \\'single\\' `\\'(\\'`.\\n- Memory: O(n) for the stack.",
                "solutionTags": [],
                "code": "```Java\\npublic String minRemoveToMakeValid(String s) {\\n  StringBuilder sb = new StringBuilder(s);\\n  Stack<Integer> st = new Stack<>();\\n  for (int i = 0; i < sb.length(); ++i) {\\n    if (sb.charAt(i) == \\'(\\') st.add(i);\\n    if (sb.charAt(i) == \\')\\') {\\n      if (!st.empty()) st.pop();\\n      else sb.setCharAt(i, \\'*\\');\\n    }\\n  }\\n  while (!st.empty())\\n    sb.setCharAt(st.pop(), \\'*\\');\\n  return sb.toString().replaceAll(\"\\\\\\\\*\", \"\");\\n}\\n```\n```CPP\\nstring minRemoveToMakeValid(string s) {\\n  stack<int> st;\\n  for (auto i = 0; i < s.size(); ++i) {\\n    if (s[i] == \\'(\\') st.push(i);\\n    if (s[i] == \\')\\') {\\n      if (!st.empty()) st.pop();\\n      else s[i] = \\'*\\';\\n    }\\n  }\\n  while (!st.empty()) {\\n    s[st.top()] = \\'*\\';\\n    st.pop();\\n  }\\n  s.erase(remove(s.begin(), s.end(), \\'*\\'), s.end());\\n  return s;\\n}\\n```\n```Java\\npublic String minRemoveToMakeValid(String s) {\\n  StringBuilder sb = new StringBuilder(s);\\n  Stack<Integer> st = new Stack();\\n  for (int i = 0; i < sb.length(); ++i) {\\n    if (sb.charAt(i) == \\'(\\') st.add(i + 1);\\n    if (sb.charAt(i) == \\')\\') {\\n      if (!st.empty() && st.peek() >= 0) st.pop();\\n      else st.add(-(i + 1));\\n    }\\n  }\\n  while (!st.empty())\\n    sb.deleteCharAt(Math.abs(st.pop()) - 1);\\n  return sb.toString();\\n}\\n```\n```\\npublic String minRemoveToMakeValid(String s) {\\n  StringBuilder sb = new StringBuilder(s), sb1 = new StringBuilder();\\n  Stack<Integer> st = new Stack();\\n  for (int i = 0; i < sb.length(); ++i) {\\n    if (sb.charAt(i) == \\'(\\') st.add(i + 1);\\n    if (sb.charAt(i) == \\')\\') {\\n      if (!st.empty() && st.peek() >= 0) st.pop();\\n      else st.add(-(i + 1));\\n    }\\n  }\\n  for(int i = 0, j = 0; i < sb.length(); ++i) {\\n      if (j >= st.size() || i != Math.abs(st.elementAt(j)) - 1) {\\n        sb1.append(sb.charAt(i));\\n      } else ++j;\\n  }\\n  return sb1.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 663204,
                "title": "super-simple-python-solution-with-explanation-faster-than-100-memory-usage-less-than-100",
                "content": "1. Convert string to list, because String is an immutable data structure in Python and it\\'s much easier and memory-efficient to deal with a list for this task.\\n2. Iterate through list\\n3. Keep track of indices with open parentheses in the stack. In other words, when we come across open parenthesis we add an index to the stack.\\n4. When we come across close parenthesis we pop an element from the stack. If the stack is empty we replace current list element with an empty string\\n5. After iteration, we replace all indices we have in the stack with empty strings, because we don\\'t have close parentheses for them.\\n6. Convert list to string and return\\n\\n```\\ndef minRemoveToMakeValid(self, s: str) -> str:\\n    s = list(s)\\n    stack = []\\n    for i, char in enumerate(s):\\n        if char == \\'(\\':\\n            stack.append(i)\\n        elif char == \\')\\':\\n            if stack:\\n                stack.pop()\\n            else:\\n                s[i] = \\'\\'\\n    while stack:\\n        s[stack.pop()] = \\'\\'\\n    return \\'\\'.join(s)\\n```\\n\\nTime complexity is O(n)\\nMemory complexity is O(n)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef minRemoveToMakeValid(self, s: str) -> str:\\n    s = list(s)\\n    stack = []\\n    for i, char in enumerate(s):\\n        if char == \\'(\\':\\n            stack.append(i)\\n        elif char == \\')\\':\\n            if stack:\\n                stack.pop()\\n            else:\\n                s[i] = \\'\\'\\n    while stack:\\n        s[stack.pop()] = \\'\\'\\n    return \\'\\'.join(s)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1073189,
                "title": "c-2-approaches-o-n-beats-100-no-extra-space-best-explanation",
                "content": "**APPROACH 1**\\nHere, we will use a **stack** for checking the validity of parentheses, and later remove the indexes of invalid parentheses from the string `s`. Thanks [@harmxnkhurana](https://leetcode.com/harmxnkhurana) for the suggestion of directly marking the invalid parentheses in string `s` rather than redundant storing it in a different vector. \\n- First, iterate the string `s` and mark the index of those characters which need to be removed to make it *parentheses string* using a special symbol **`\\'#\\'`**.\\n- Here, a **stack** is used for finding the **valid** pair of parentheses, and while doing so also **mark** the indexes of **invalid parentheses** in ```s```.\\n- Finally, iterate `s` again and append **non-marked symbol** (`#`) to `ans`.\\n\\n**COMPLETE CODE**\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        \\n        stack<int>st; // helper stack for finding matching parentheses\\n        \\n        for(int i=0;i<s.length();++i){\\n            if(s[i]==\\'(\\'){ // for open parentheses push into stack\\n                st.push(i);\\n            }\\n            else if(s[i]==\\')\\'){ // for closing parentheses\\n                // if no matching previous open parentheses found, we need to remove the index of that open parentheses from \"s\" so for now we are marking it with special character \\'#\\'\\n                if(st.empty()){ \\n                    s[i]=\\'#\\';\\n                }\\n                else{\\n                    // if matching open parentheses found remove that from the stack\\n                    st.pop();\\n                }\\n            }\\n        }\\n\\n        // if stack is not empty, that means it contains open parentheses indexes which don\\'t have any matching closing parentheses\\n        while(!st.empty()){\\n            s[st.top()]=\\'#\\';\\n            st.pop();\\n        }\\n        \\n        string ans=\"\";\\n        for(int i=0;i<s.length();++i){\\n            if(s[i]!=\\'#\\'){ // append not marked character to the end of \"ans\"\\n                ans.push_back(s[i]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**TIME COMPLEXITY**\\n**O(n)**\\n\\n**SPACE COMPLEXITY**\\n**O(n)** [ *For stack* ]\\n\\n---\\n\\n**APPROACH 2 ( Better Approach )**\\nIn this approach, we don\\'t need a stack so **no extra space** will be used. Thanks [@Ajna2](https://leetcode.com/Ajna2) for the suggestion of keeping a count variable instead of using a stack.\\n- First, create a `count` variable for storing the number of **opening** or **closing** brackets as per our need.\\n- **STEP 1:**\\n\\t- Initialize `count=0`. For this step, we will use `count` for storing the number of **open** brackets.\\n\\t- Then, iterate the string `s` from **start** and at each iteration:\\n\\t\\t- if **open bracket** found, then **increase** `count`.\\n\\t\\t- if **close bracket** found, then check *if* **no. of close brackets > no. of open brackets**, then mark that character in `s` by *replacing* it by **`#`**, *else* **decrease** the `count` ( as **matching parentheses** found ).\\n\\t```\\n\\tint count=0; \\n\\tfor(int i=0;i<n;++i){\\n\\t\\tif(s[i]==\\'(\\'){ // for open bracket\\n\\t\\t\\t++count;\\n\\t\\t}\\n\\t\\telse if(s[i]==\\')\\'){ // for close bracket\\n\\t\\t\\tif(count==0){  // if no. of close brackets > no. of open brackets\\n\\t\\t\\t\\ts[i]=\\'#\\';\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\t// if matching parentheses found decrease count\\n\\t\\t\\t\\t--count;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t```\\n- **STEP 2  ( Reverse of STEP 1 )**\\n\\t- Again, make `count=0`. For this step, we will use `count` for storing the number of **close** brackets.\\n\\t- Then, iterate the string `s` from the **end** and at each iteration:\\n\\t\\t- if **close bracket** found, then **increase** `count`.\\n\\t\\t- if **open bracket** found, then check *if* **no. of open brackets > no. of close brackets**, then mark that character in `s` by *replacing* it by **`#`**, *else* **decrease** the `count` ( as **matching parentheses** found ). \\n\\t```\\n\\tcount=0;\\n\\tfor(int i=n-1;i>=0;--i){\\n\\t\\tif(s[i]==\\')\\'){ // for close bracket\\n\\t\\t\\t++count;\\n\\t\\t}\\n\\t\\telse if(s[i]==\\'(\\'){ // for open bracket\\n\\t\\t\\tif(count==0){ // if no. of open brackets > no. of close brackets\\n\\t\\t\\t\\ts[i]=\\'#\\';\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\t// if matching parentheses found decrease count\\n\\t\\t\\t\\t--count;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t```\\n- **STEP 3:**\\n\\t- Iterate the string `s` and append each non - marked character (`#`) to `ans` string.\\n\\t- return `ans`.\\n\\t```\\n\\tstring ans=\"\";\\n\\tfor(int i=0;i<n;++i){\\n\\t\\tif(s[i]!=\\'#\\'){ \\n\\t\\t\\tans.push_back(s[i]);\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n\\t```\\n\\n**COMPLETE CODE**\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int n=s.length();\\n        // Step 1 : Iterate from start\\n        int count=0; \\n        for(int i=0;i<n;++i){\\n            if(s[i]==\\'(\\'){ // for open bracket\\n                ++count;\\n            }\\n            else if(s[i]==\\')\\'){ // for close bracket\\n                if(count==0){  // if no. of close brackets > no. of open brackets\\n                    s[i]=\\'#\\';\\n                }\\n                else{\\n                    // if matching parentheses found decrease count\\n                    --count;\\n                }\\n            }\\n        }\\n        \\n        // Step 2 : Iterate from end\\n        count=0;\\n        for(int i=n-1;i>=0;--i){\\n            if(s[i]==\\')\\'){ // for close bracket\\n                ++count;\\n            }\\n            else if(s[i]==\\'(\\'){ // for open bracket\\n                if(count==0){ // if no. of open brackets > no. of close brackets\\n                    s[i]=\\'#\\';\\n                }\\n                else{\\n                    // if matching parentheses found decrease count\\n                    --count;\\n                }\\n            }\\n        }\\n        \\n        // Step 3 : Create \"ans\" by ignoring the special characters \\'#\\'\\n        string ans=\"\";\\n        for(int i=0;i<n;++i){\\n            if(s[i]!=\\'#\\'){ \\n                ans.push_back(s[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**TIME COMPLEXITY**\\n**O(n+n+n) = O(n)** [ *Each step takes O(n) time* ]\\n\\n**SPACE COMPLEXITY**\\n**O(1)** [ *No extra space used, ignoring \"ans\"* ]",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```s```\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        \\n        stack<int>st; // helper stack for finding matching parentheses\\n        \\n        for(int i=0;i<s.length();++i){\\n            if(s[i]==\\'(\\'){ // for open parentheses push into stack\\n                st.push(i);\\n            }\\n            else if(s[i]==\\')\\'){ // for closing parentheses\\n                // if no matching previous open parentheses found, we need to remove the index of that open parentheses from \"s\" so for now we are marking it with special character \\'#\\'\\n                if(st.empty()){ \\n                    s[i]=\\'#\\';\\n                }\\n                else{\\n                    // if matching open parentheses found remove that from the stack\\n                    st.pop();\\n                }\\n            }\\n        }\\n\\n        // if stack is not empty, that means it contains open parentheses indexes which don\\'t have any matching closing parentheses\\n        while(!st.empty()){\\n            s[st.top()]=\\'#\\';\\n            st.pop();\\n        }\\n        \\n        string ans=\"\";\\n        for(int i=0;i<s.length();++i){\\n            if(s[i]!=\\'#\\'){ // append not marked character to the end of \"ans\"\\n                ans.push_back(s[i]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\n\\tint count=0; \\n\\tfor(int i=0;i<n;++i){\\n\\t\\tif(s[i]==\\'(\\'){ // for open bracket\\n\\t\\t\\t++count;\\n\\t\\t}\\n\\t\\telse if(s[i]==\\')\\'){ // for close bracket\\n\\t\\t\\tif(count==0){  // if no. of close brackets > no. of open brackets\\n\\t\\t\\t\\ts[i]=\\'#\\';\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\t// if matching parentheses found decrease count\\n\\t\\t\\t\\t--count;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t```\n```\\n\\tcount=0;\\n\\tfor(int i=n-1;i>=0;--i){\\n\\t\\tif(s[i]==\\')\\'){ // for close bracket\\n\\t\\t\\t++count;\\n\\t\\t}\\n\\t\\telse if(s[i]==\\'(\\'){ // for open bracket\\n\\t\\t\\tif(count==0){ // if no. of open brackets > no. of close brackets\\n\\t\\t\\t\\ts[i]=\\'#\\';\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\t// if matching parentheses found decrease count\\n\\t\\t\\t\\t--count;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t```\n```\\n\\tstring ans=\"\";\\n\\tfor(int i=0;i<n;++i){\\n\\t\\tif(s[i]!=\\'#\\'){ \\n\\t\\t\\tans.push_back(s[i]);\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n\\t```\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int n=s.length();\\n        // Step 1 : Iterate from start\\n        int count=0; \\n        for(int i=0;i<n;++i){\\n            if(s[i]==\\'(\\'){ // for open bracket\\n                ++count;\\n            }\\n            else if(s[i]==\\')\\'){ // for close bracket\\n                if(count==0){  // if no. of close brackets > no. of open brackets\\n                    s[i]=\\'#\\';\\n                }\\n                else{\\n                    // if matching parentheses found decrease count\\n                    --count;\\n                }\\n            }\\n        }\\n        \\n        // Step 2 : Iterate from end\\n        count=0;\\n        for(int i=n-1;i>=0;--i){\\n            if(s[i]==\\')\\'){ // for close bracket\\n                ++count;\\n            }\\n            else if(s[i]==\\'(\\'){ // for open bracket\\n                if(count==0){ // if no. of open brackets > no. of close brackets\\n                    s[i]=\\'#\\';\\n                }\\n                else{\\n                    // if matching parentheses found decrease count\\n                    --count;\\n                }\\n            }\\n        }\\n        \\n        // Step 3 : Create \"ans\" by ignoring the special characters \\'#\\'\\n        string ans=\"\";\\n        for(int i=0;i<n;++i){\\n            if(s[i]!=\\'#\\'){ \\n                ans.push_back(s[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 474353,
                "title": "stack-based-easy-to-understand-faster-than-99-javascript-solution",
                "content": "```\\nvar minRemoveToMakeValid = function(str) {\\n    str = str.split(\"\");\\n\\tlet stack = [];\\n    for(let i = 0; i<str.length; i++){\\n        if(str[i]===\"(\")\\n            stack.push(i);\\n        else if(str[i]===\")\"){\\n            if(stack.length) stack.pop();\\n            else str[i]=\"\";\\n        }\\n    }\\n    \\n    for(let i of stack) str[i] = \"\";\\n    \\n    return str.join(\"\");\\n\\t\\n}\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38\\n\\n**This is by far my most upvoted solution \\uD83C\\uDF89 ! Thanks Guys \\uD83D\\uDC9A**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minRemoveToMakeValid = function(str) {\\n    str = str.split(\"\");\\n\\tlet stack = [];\\n    for(let i = 0; i<str.length; i++){\\n        if(str[i]===\"(\")\\n            stack.push(i);\\n        else if(str[i]===\")\"){\\n            if(stack.length) stack.pop();\\n            else str[i]=\"\";\\n        }\\n    }\\n    \\n    for(let i of stack) str[i] = \"\";\\n    \\n    return str.join(\"\");\\n\\t\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 419466,
                "title": "constant-space-solution",
                "content": "```\\n    public String minRemoveToMakeValid(String s) {\\n\\t\\tint openCloseCount = 0;\\n\\t\\tint close = 0;\\n\\t\\tfor (int i = 0; i < s.length(); i++)  if (s.charAt(i) == \\')\\') close++;\\n\\t\\t\\n        StringBuilder sb = new StringBuilder();\\n\\t\\t\\n\\t\\tfor (char c: s.toCharArray()) {\\n\\t\\t\\tif (c == \\'(\\') {\\n\\t\\t\\t\\tif (openCloseCount == close) continue;\\n\\t\\t\\t\\topenCloseCount++;\\n\\t\\t\\t} else if (c == \\')\\') {\\n\\t\\t\\t\\tclose--;\\n\\t\\t\\t\\tif (openCloseCount == 0) continue;\\n\\t\\t\\t\\topenCloseCount--;\\n\\t\\t\\t} \\n\\n\\t\\t\\t\\tsb.append(c);\\n\\t\\t}\\n\\t\\treturn sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String minRemoveToMakeValid(String s) {\\n\\t\\tint openCloseCount = 0;\\n\\t\\tint close = 0;\\n\\t\\tfor (int i = 0; i < s.length(); i++)  if (s.charAt(i) == \\')\\') close++;\\n\\t\\t\\n        StringBuilder sb = new StringBuilder();\\n\\t\\t\\n\\t\\tfor (char c: s.toCharArray()) {\\n\\t\\t\\tif (c == \\'(\\') {\\n\\t\\t\\t\\tif (openCloseCount == close) continue;\\n\\t\\t\\t\\topenCloseCount++;\\n\\t\\t\\t} else if (c == \\')\\') {\\n\\t\\t\\t\\tclose--;\\n\\t\\t\\t\\tif (openCloseCount == 0) continue;\\n\\t\\t\\t\\topenCloseCount--;\\n\\t\\t\\t} \\n\\n\\t\\t\\t\\tsb.append(c);\\n\\t\\t}\\n\\t\\treturn sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1850237,
                "title": "c-2-appraches-explained-with-algorithm-easy-simple",
                "content": "# 1249. Minimum Remove to Make Valid Parentheses\\n**KNOCKCAT**\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. 2 Appraoches with initution.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n[LeetCode](http://github.com/knockcat/Leetcode) **LINK TO LEETCODE REPOSITORY**\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n``` ```\\n**APPROACH 1     O(n) & O(1)**\\n\\n* **ALGORITHM**\\n* **Iterating the string from beginning.**\\n\\t* **take a cnt variable**, and **increase the cnt when you find an open parenthesis \\'(\\'.**\\n\\t* when you **find a close parenthiesis**, **2 cases were checked.**\\n\\t* i**f cnt is 0** , that **means no open parenthesis has occured earlier**.\\n\\t* therefore **replace the string index with \\'#\\'.**\\n\\t* **otherwise decrease the cnt**, as a **valid pair has found**.\\n\\t\\n* Now **iterate the string from behind** and **repeat the same steps** , but **this time check for closing parenthisis**.\\n\\t* if **closing parenthesis occur increase the cnt**.\\n\\t* if **open parenthesis occur**, now **again 2 cases are need to check.**\\n\\t* if the **cnt == 0, that means no closing parenthisis occur** before **therfore replace that string index with \\'#\\'.**\\n\\t* Otherwise **decrease the cnt.**\\n* **At end make the resultant string by excluding \\'#\\'**\\n* **Time Complexity** is O(n+n+n) = **O(n)**  for each 3 steps\\n* **Space Complexity** is **O(1)** , No extra space taken excluding result string.\\n```\\n```\\n\\n**CODE WITH EXPLANATION**\\n```\\n\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution\\n{\\npublic:\\n    string minRemoveToMakeValid(string s)\\n    {\\n        int n = s.length();\\n        string res = \"\";\\n\\n        int cnt = 0;\\n        // iterating from beginnning\\n        for (int i = 0; i < s.length(); ++i)\\n        {\\n            // if we find and open parenthesis increase the cnt\\n            if (s[i] == \\'(\\')\\n                ++cnt;\\n            // if we found an close parenthisis\\n            // check if cnt == 0 , that means we have no earlier open parenthesis,\\n            // therefore replace that index by \\'#\\'\\n            else if (s[i] == \\')\\')\\n            {\\n                if (cnt == 0)\\n                    s[i] = \\'#\\';\\n                // else decrease the cnt beacuse a valid pair is found\\n                else\\n                    --cnt;\\n            }\\n        }\\n\\n        cnt = 0;\\n        // iterating from the end\\n        for (int i = n - 1; i >= 0; --i)\\n        {\\n            // if we find and close parenthesis increase the cnt\\n            if (s[i] == \\')\\')\\n                ++cnt;\\n            // if we found an open parenthisis\\n            // check if cnt == 0 , that means we have no earlier close parenthesis,\\n            // therefore replace that index by \\'#\\'\\n            else if (s[i] == \\'(\\')\\n            {\\n                if (cnt == 0)\\n                    s[i] = \\'#\\';\\n                // else decrease the cnt beacuse a valid pair is found\\n                else\\n                    --cnt;\\n            }\\n        }\\n\\n        // making the resultant string by excluding \\'#\\'\\n        for (int i = 0; i < s.length(); ++i)\\n        {\\n            if (s[i] != \\'#\\')\\n                res.push_back(s[i]);\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\n**APPROACH 2 USING STACK**\\n\\n* **ALGORITHM**\\n``` ```\\n* **Using Stack** for **checking valadity of parenthesis**.\\n* first it**erate the string** and when you **find a open parenthesis push it into the stack**.\\n* if You **find and close parenthesis** , then **check if the stack is not empty**, if **stack is not empt**y that m**eans open parenthesis exist** **therefore pop the open parenthesis from the stack.**\\n* **if the stack is empty** that **means no open parenthesis exist first** therefore **replace that string index with \\'#\\'.**\\n* Now  there **may be a  case that string contain only open parenthesis** that is also an **invalid parenthesis.**\\n* therefore **while stack doesn\\'t become empty** **marked the indexes from the stack top with \\'#\\'.**\\n* **pop that parenthesis from the stack.**\\n* Now **at end** **create the resultant string excluding \\'#\\'**\\n* **Time Complexity** is = **O(n)** \\n* **Space Complexity** is **O(n)** , stack used.\\n```\\n```\\n\\n**CODE WITH EXPLANATION**\\n\\n```\\n\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution\\n{\\npublic:\\n    string minRemoveToMakeValid(string s)\\n    {\\n        stack<int> st;\\n        string res = \"\";\\n\\n        for (int i = 0; i < s.length(); ++i)\\n        {\\n            // if we find open parenthesis push it to stack\\n            if (s[i] == \\'(\\')\\n                st.push(i);\\n            // if we find close parenthisis check\\n            // if there is a open parenthisis or the stack is empty\\n            else if (s[i] == \\')\\')\\n            {\\n                // if stack  is empty then we need to remove that index from string\\n                // replacing it with \\'#\\' for our convenience\\n                if (st.empty())\\n                    s[i] = \\'#\\';\\n                else\\n                    // if there is an open parenthesis than remove that  from the stack\\n                    st.pop();\\n            }\\n        }\\n\\n        // now , if stack is not empty that means it has open parenthesis\\n        // which have no closing parenthesis.\\n        // so we have to replace that index of string with \\'#\\' for our convenience\\n        while (!st.empty())\\n        {\\n            s[st.top()] = \\'#\\';\\n            st.pop();\\n        }\\n\\n        // making the resultant string by excluding \\'#\\'\\n        for (int i = 0; i < s.length(); ++i)\\n        {\\n            if (s[i] != \\'#\\')\\n                res.push_back(s[i]);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. 2 Appraoches with initution.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n``` ```\n```\\n```\n```\\n\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution\\n{\\npublic:\\n    string minRemoveToMakeValid(string s)\\n    {\\n        int n = s.length();\\n        string res = \"\";\\n\\n        int cnt = 0;\\n        // iterating from beginnning\\n        for (int i = 0; i < s.length(); ++i)\\n        {\\n            // if we find and open parenthesis increase the cnt\\n            if (s[i] == \\'(\\')\\n                ++cnt;\\n            // if we found an close parenthisis\\n            // check if cnt == 0 , that means we have no earlier open parenthesis,\\n            // therefore replace that index by \\'#\\'\\n            else if (s[i] == \\')\\')\\n            {\\n                if (cnt == 0)\\n                    s[i] = \\'#\\';\\n                // else decrease the cnt beacuse a valid pair is found\\n                else\\n                    --cnt;\\n            }\\n        }\\n\\n        cnt = 0;\\n        // iterating from the end\\n        for (int i = n - 1; i >= 0; --i)\\n        {\\n            // if we find and close parenthesis increase the cnt\\n            if (s[i] == \\')\\')\\n                ++cnt;\\n            // if we found an open parenthisis\\n            // check if cnt == 0 , that means we have no earlier close parenthesis,\\n            // therefore replace that index by \\'#\\'\\n            else if (s[i] == \\'(\\')\\n            {\\n                if (cnt == 0)\\n                    s[i] = \\'#\\';\\n                // else decrease the cnt beacuse a valid pair is found\\n                else\\n                    --cnt;\\n            }\\n        }\\n\\n        // making the resultant string by excluding \\'#\\'\\n        for (int i = 0; i < s.length(); ++i)\\n        {\\n            if (s[i] != \\'#\\')\\n                res.push_back(s[i]);\\n        }\\n\\n        return res;\\n    }\\n};\\n```\n``` ```\n```\\n```\n```\\n\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution\\n{\\npublic:\\n    string minRemoveToMakeValid(string s)\\n    {\\n        stack<int> st;\\n        string res = \"\";\\n\\n        for (int i = 0; i < s.length(); ++i)\\n        {\\n            // if we find open parenthesis push it to stack\\n            if (s[i] == \\'(\\')\\n                st.push(i);\\n            // if we find close parenthisis check\\n            // if there is a open parenthisis or the stack is empty\\n            else if (s[i] == \\')\\')\\n            {\\n                // if stack  is empty then we need to remove that index from string\\n                // replacing it with \\'#\\' for our convenience\\n                if (st.empty())\\n                    s[i] = \\'#\\';\\n                else\\n                    // if there is an open parenthesis than remove that  from the stack\\n                    st.pop();\\n            }\\n        }\\n\\n        // now , if stack is not empty that means it has open parenthesis\\n        // which have no closing parenthesis.\\n        // so we have to replace that index of string with \\'#\\' for our convenience\\n        while (!st.empty())\\n        {\\n            s[st.top()] = \\'#\\';\\n            st.pop();\\n        }\\n\\n        // making the resultant string by excluding \\'#\\'\\n        for (int i = 0; i < s.length(); ++i)\\n        {\\n            if (s[i] != \\'#\\')\\n                res.push_back(s[i]);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419348,
                "title": "java-python-stack-solution-o-n-clean-concise",
                "content": "**Idea**\\n- Use stack to remove invalid mismatching parentheses, that is:\\n\\t- Currently, meet closing-parentheses but no opening-parenthesis in the previous -> remove current closing-parenthesis. For example: `s = \"())\"`.\\n\\t- If there are redundant opening-parenthesis at the end, for example: `s = \"((()\"`.\\n\\n<iframe src=\"https://leetcode.com/playground/R22sMX7c/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 10^5` is length of string `s`.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "**Idea**\\n- Use stack to remove invalid mismatching parentheses, that is:\\n\\t- Currently, meet closing-parentheses but no opening-parenthesis in the previous -> remove current closing-parenthesis. For example: `s = \"())\"`.\\n\\t- If there are redundant opening-parenthesis at the end, for example: `s = \"((()\"`.\\n\\n<iframe src=\"https://leetcode.com/playground/R22sMX7c/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 10^5` is length of string `s`.\\n- Space: `O(N)`",
                "codeTag": "Unknown"
            },
            {
                "id": 419443,
                "title": "java-clean-stringbuilder-solution",
                "content": "**O(N) Solution:**\\n\\nA pair of parentheses is consist of an open and a close. The open has to be before the close.\\nSo, we can remove the extra close parenthese then remove extra open parenthese\\n\\n the fist iteration, we remove the unwanted )\\n the second iteration, we remove the unwanted (\\n \\n```\\npublic String minRemoveToMakeValid(String s) {\\n    StringBuilder sb = new StringBuilder();\\n    int open = 0;\\n    for (char c : s.toCharArray()) {\\n        if (c == \\'(\\') \\n            open++;\\n        else if (c == \\')\\') {\\n            if (open == 0) continue; // remove invalid close parenthese\\n            open--;\\n        }\\n        sb.append(c);\\n    }\\n    \\n    StringBuilder result = new StringBuilder();\\n    for (int i = sb.length() - 1; i >= 0; i--) {\\n        if (sb.charAt(i) == \\'(\\' && open-- > 0) continue; // remove invalid open parenthese\\n        result.append(sb.charAt(i));\\n    }\\n    \\n    return result.reverse().toString();\\n}\\n```\\n\\n\\nCredit to @Sithis and @hamlet_fiis pointing out the time comlexity of `deleteCharAt(i)` being O(N) which makes this a O(N2) solution. \\nEdited the code to append all characters except those invalid open parentheses, then reverse the stringbuilder. This will achieve O(N) with slight headache.\\nA new `StringBuilder` is created for the result, but you could reuse the first one by replacing the `(` in place and prune the starting `open` number of chars.\\n\\n**Original O(N2) Solution:**\\n\\nThe intuition is counting the number of invalid `(` and removing the invalid `)` in the first pass.\\nIf there are `open` number of invalid `(` left, we just need to remove them from the end in the second pass.\\n\\n```\\npublic String minRemoveToMakeValid(String s) {\\n    StringBuilder sb = new StringBuilder();\\n    int open = 0;\\n    for (char c : s.toCharArray()) {\\n        if (c == \\'(\\') {\\n            open++;\\n        } else if (c == \\')\\') {\\n            if (open == 0) continue;\\n            open--;\\n        }\\n        sb.append(c);\\n    }\\n    \\n    for (int i = sb.length() - 1; i >= 0 && open > 0; i--) {\\n        if (sb.charAt(i) == \\'(\\') {\\n            sb.deleteCharAt(i);\\n            open--;\\n        }\\n    }\\n    \\n    return sb.toString();\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic String minRemoveToMakeValid(String s) {\\n    StringBuilder sb = new StringBuilder();\\n    int open = 0;\\n    for (char c : s.toCharArray()) {\\n        if (c == \\'(\\') \\n            open++;\\n        else if (c == \\')\\') {\\n            if (open == 0) continue; // remove invalid close parenthese\\n            open--;\\n        }\\n        sb.append(c);\\n    }\\n    \\n    StringBuilder result = new StringBuilder();\\n    for (int i = sb.length() - 1; i >= 0; i--) {\\n        if (sb.charAt(i) == \\'(\\' && open-- > 0) continue; // remove invalid open parenthese\\n        result.append(sb.charAt(i));\\n    }\\n    \\n    return result.reverse().toString();\\n}\\n```\n```\\npublic String minRemoveToMakeValid(String s) {\\n    StringBuilder sb = new StringBuilder();\\n    int open = 0;\\n    for (char c : s.toCharArray()) {\\n        if (c == \\'(\\') {\\n            open++;\\n        } else if (c == \\')\\') {\\n            if (open == 0) continue;\\n            open--;\\n        }\\n        sb.append(c);\\n    }\\n    \\n    for (int i = sb.length() - 1; i >= 0 && open > 0; i--) {\\n        if (sb.charAt(i) == \\'(\\') {\\n            sb.deleteCharAt(i);\\n            open--;\\n        }\\n    }\\n    \\n    return sb.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 419577,
                "title": "c-inplace-removal-o-n-time-o-1-space",
                "content": "```\\n    string minRemoveToMakeValid(string s)\\n    {\\n        int i = s.size();\\n        int balance = 0;\\n        for (int j = s.size() - 1; j >= 0; j--) {\\n            if (s[j] == \\')\\') balance++;\\n            else if (s[j] == \\'(\\') {\\n                if (balance == 0) continue;\\n                balance--;\\n            }\\n            s[--i] = s[j];\\n        }\\n        int len = 0;\\n        balance = 0;\\n        for (; i < s.size(); i++) {\\n            if (s[i] == \\'(\\') balance++;\\n            else if (s[i] == \\')\\') {\\n                if (balance == 0) continue;\\n                balance--;\\n            }\\n            s[len++] = s[i];\\n        }\\n        s.erase(len);\\n        return s;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    string minRemoveToMakeValid(string s)\\n    {\\n        int i = s.size();\\n        int balance = 0;\\n        for (int j = s.size() - 1; j >= 0; j--) {\\n            if (s[j] == \\')\\') balance++;\\n            else if (s[j] == \\'(\\') {\\n                if (balance == 0) continue;\\n                balance--;\\n            }\\n            s[--i] = s[j];\\n        }\\n        int len = 0;\\n        balance = 0;\\n        for (; i < s.size(); i++) {\\n            if (s[i] == \\'(\\') balance++;\\n            else if (s[i] == \\')\\') {\\n                if (balance == 0) continue;\\n                balance--;\\n            }\\n            s[len++] = s[i];\\n        }\\n        s.erase(len);\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 427981,
                "title": "python-stack-o-n",
                "content": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        \\n        stack, cur = [], \\'\\'\\n        for c in s:\\n            if c == \\'(\\':\\n                stack += [cur]\\n                cur = \\'\\'\\n            elif c == \\')\\':\\n                if stack:\\n                    cur = stack.pop() + \\'(\\' + cur + \\')\\' \\n            else:\\n                cur += c\\n        \\n        while stack:\\n            cur = stack.pop() + cur\\n        \\n        return cur\\n```\\n\\n@licaiuu also provided a good solution, which is really easy to understand. It is simplified as following:\\n```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        \\n        stack, res = [], [\\'\\'] * len(s)\\n        \\n        for i, x in enumerate(s):\\n            \\n            if x == \\'(\\':\\n                stack += [i]\\n                \\n            elif x == \\')\\':\\n                if stack:\\n                    res[stack.pop()] = \\'(\\'\\n                    res[i] = \\')\\'\\n                    \\n            else:\\n                res[i] = x\\n        return \\'\\'.join(res)\\n```\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        \\n        stack, cur = [], \\'\\'\\n        for c in s:\\n            if c == \\'(\\':\\n                stack += [cur]\\n                cur = \\'\\'\\n            elif c == \\')\\':\\n                if stack:\\n                    cur = stack.pop() + \\'(\\' + cur + \\')\\' \\n            else:\\n                cur += c\\n        \\n        while stack:\\n            cur = stack.pop() + cur\\n        \\n        return cur\\n```\n```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        \\n        stack, res = [], [\\'\\'] * len(s)\\n        \\n        for i, x in enumerate(s):\\n            \\n            if x == \\'(\\':\\n                stack += [i]\\n                \\n            elif x == \\')\\':\\n                if stack:\\n                    res[stack.pop()] = \\'(\\'\\n                    res[i] = \\')\\'\\n                    \\n            else:\\n                res[i] = x\\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564741,
                "title": "java-both-runtime-and-memory-beats-100-00-submissions",
                "content": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n\\n        char[] arr = s.toCharArray();\\n        int open = 0;\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == \\'(\\')\\n                open++;\\n            else if (arr[i] == \\')\\') {\\n                if (open == 0)\\n                    arr[i] = \\'*\\';\\n                else\\n                    open--;\\n            }\\n        }\\n\\n        for (int i = arr.length - 1; i >= 0; i--) {\\n            if (open > 0 && arr[i] == \\'(\\') {\\n                arr[i] = \\'*\\';\\n                open--;\\n            }\\n        }\\n\\n        int p = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] != \\'*\\')\\n                arr[p++] = arr[i];\\n        }\\n\\n        return new String(arr).substring(0, p);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n\\n        char[] arr = s.toCharArray();\\n        int open = 0;\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == \\'(\\')\\n                open++;\\n            else if (arr[i] == \\')\\') {\\n                if (open == 0)\\n                    arr[i] = \\'*\\';\\n                else\\n                    open--;\\n            }\\n        }\\n\\n        for (int i = arr.length - 1; i >= 0; i--) {\\n            if (open > 0 && arr[i] == \\'(\\') {\\n                arr[i] = \\'*\\';\\n                open--;\\n            }\\n        }\\n\\n        int p = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] != \\'*\\')\\n                arr[p++] = arr[i];\\n        }\\n\\n        return new String(arr).substring(0, p);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503754,
                "title": "python-memory-usage-less-than-100-faster-than-100",
                "content": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        \\n        open = 0\\n        s = list(s)\\n        \\n        for i, c in enumerate(s):\\n            if c == \\'(\\': open += 1\\n            elif c == \\')\\':\\n                if not open: s[i] = \"\"\\n                else: open -= 1\\n        \\n        for i in range(len(s)-1, -1, -1):\\n            if not open: break\\n            if s[i] == \\'(\\': s[i] = \"\"; open -= 1\\n        \\n        return \"\".join(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        \\n        open = 0\\n        s = list(s)\\n        \\n        for i, c in enumerate(s):\\n            if c == \\'(\\': open += 1\\n            elif c == \\')\\':\\n                if not open: s[i] = \"\"\\n                else: open -= 1\\n        \\n        for i in range(len(s)-1, -1, -1):\\n            if not open: break\\n            if s[i] == \\'(\\': s[i] = \"\"; open -= 1\\n        \\n        return \"\".join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419702,
                "title": "java-o-n-solution-without-stack",
                "content": "Time complexity: O(n).\\nSpace complexity: O(n).\\n\\n```\\npublic String minRemoveToMakeValid(String str) {\\n    int n = str.length();\\n    StringBuilder sb = new StringBuilder(n);\\n    boolean[] remove = new boolean[n];\\n    int open = 0;\\n    for (int i = 0; i < n; i++) {\\n        if (str.charAt(i) == \\'(\\') {\\n            open++;\\n        } else if (str.charAt(i) == \\')\\') {\\n            if (open > 0) {\\n                open--;\\n            } else {\\n                remove[i] = true;\\n            }\\n        }\\n    }\\n\\n    int close = 0;\\n    for (int i = n - 1; i >= 0; i--) {\\n        if (str.charAt(i) == \\')\\') {\\n            close++;\\n        } else if (str.charAt(i) == \\'(\\') {\\n            if (close > 0) {\\n                close--;\\n            } else {\\n                remove[i] = true;\\n            }\\n        }\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n        if (!remove[i]) sb.append(str.charAt(i));\\n    }\\n\\n    return sb.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String minRemoveToMakeValid(String str) {\\n    int n = str.length();\\n    StringBuilder sb = new StringBuilder(n);\\n    boolean[] remove = new boolean[n];\\n    int open = 0;\\n    for (int i = 0; i < n; i++) {\\n        if (str.charAt(i) == \\'(\\') {\\n            open++;\\n        } else if (str.charAt(i) == \\')\\') {\\n            if (open > 0) {\\n                open--;\\n            } else {\\n                remove[i] = true;\\n            }\\n        }\\n    }\\n\\n    int close = 0;\\n    for (int i = n - 1; i >= 0; i--) {\\n        if (str.charAt(i) == \\')\\') {\\n            close++;\\n        } else if (str.charAt(i) == \\'(\\') {\\n            if (close > 0) {\\n                close--;\\n            } else {\\n                remove[i] = true;\\n            }\\n        }\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n        if (!remove[i]) sb.append(str.charAt(i));\\n    }\\n\\n    return sb.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 763625,
                "title": "simple-and-short-c-solution",
                "content": "**Approach:**\\nPush every occurrence of \\'(\\' into a stack and whenever \\')\\' appears in the string, try to pop \\'(\\' from stack if exists. If \\'(\\' does not exist, then erase \\')\\' from string. After parsing the entire string, erase extra \\'(\\' present in stack from string.\\n\\n***Note***\\n*Store indices of string in stack instead of the character for easy access and less iteration.*\\n\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack<int> box;\\n        int n = s.length();\\n        \\n        for(int i=0; i<n; i++) {\\n            if(s[i] == \\')\\'){\\n                if(!box.empty() && s[box.top()] == \\'(\\'){\\n                    box.pop();\\n                }else{\\n                    s.erase(i,1);\\n                    i--;\\n                }\\n            }\\n            else if(s[i] == \\'(\\'){\\n                box.push(i);\\n            }\\n        }\\n        \\n        while(!box.empty()) {\\n            s.erase(box.top(),1);\\n            box.pop();\\n        }\\n        \\n        return s;\\n    }\\n};\\n```\\n\\n***Hope it helps. :)***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack<int> box;\\n        int n = s.length();\\n        \\n        for(int i=0; i<n; i++) {\\n            if(s[i] == \\')\\'){\\n                if(!box.empty() && s[box.top()] == \\'(\\'){\\n                    box.pop();\\n                }else{\\n                    s.erase(i,1);\\n                    i--;\\n                }\\n            }\\n            else if(s[i] == \\'(\\'){\\n                box.push(i);\\n            }\\n        }\\n        \\n        while(!box.empty()) {\\n            s.erase(box.top(),1);\\n            box.pop();\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850160,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Time Complexity : O(n)**\\n**Java**\\n```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++){\\n            if(sb.charAt(i) == \\'(\\')     stack.push(i);\\n            else if (sb.charAt(i) == \\')\\'){\\n                if(!stack.isEmpty())    stack.pop();\\n                else sb.setCharAt(i, \\'*\\');\\n            }\\n        }\\n        while(!stack.isEmpty()) sb.setCharAt(stack.pop(), \\'*\\');\\n        return sb.toString().replaceAll(\"\\\\\\\\*\", \"\");\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar minRemoveToMakeValid = function(s) {\\n    s = s.split(\"\")\\n    let stack = []\\n    for(let i=0; i<s.length; i++){\\n        if(s[i] == \"(\")     stack.push(i)\\n        else if (s[i] == \")\"){\\n            if(stack.length)    stack.pop()\\n            else s[i] = \"\"\\n        }\\n    }\\n    for(let i of stack) s[i] = \"\"\\n    return s.join(\"\")\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def minRemoveToMakeValid(self, s):\\n        s = list(s)\\n        stack = []\\n        for i in range(len(s)):\\n            if s[i] == \"(\":\\n                stack.append(i)\\n            elif s[i] == \")\":\\n                if len(stack):\\n                    stack.pop()\\n                else:\\n                    s[i] = \"\"\\n        for i in stack:\\n            s[i] = \"\"\\n        return \"\".join(s)\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++){\\n            if(sb.charAt(i) == \\'(\\')     stack.push(i);\\n            else if (sb.charAt(i) == \\')\\'){\\n                if(!stack.isEmpty())    stack.pop();\\n                else sb.setCharAt(i, \\'*\\');\\n            }\\n        }\\n        while(!stack.isEmpty()) sb.setCharAt(stack.pop(), \\'*\\');\\n        return sb.toString().replaceAll(\"\\\\\\\\*\", \"\");\\n    }\\n}\\n```\n```\\nvar minRemoveToMakeValid = function(s) {\\n    s = s.split(\"\")\\n    let stack = []\\n    for(let i=0; i<s.length; i++){\\n        if(s[i] == \"(\")     stack.push(i)\\n        else if (s[i] == \")\"){\\n            if(stack.length)    stack.pop()\\n            else s[i] = \"\"\\n        }\\n    }\\n    for(let i of stack) s[i] = \"\"\\n    return s.join(\"\")\\n};\\n```\n```\\nclass Solution(object):\\n    def minRemoveToMakeValid(self, s):\\n        s = list(s)\\n        stack = []\\n        for i in range(len(s)):\\n            if s[i] == \"(\":\\n                stack.append(i)\\n            elif s[i] == \")\":\\n                if len(stack):\\n                    stack.pop()\\n                else:\\n                    s[i] = \"\"\\n        for i in stack:\\n            s[i] = \"\"\\n        return \"\".join(s)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072876,
                "title": "js-python-java-c-stack-solution-w-explanation-beats-100",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n***Idea:***\\n\\nValid parentheses follow the **LIFO method** (last in, first out), so we should automatically be thinking of some kind of **stack** solution.\\n\\nTo check for valid parentheses, you push any **\"(\"** onto **stack**, then pop off the top stack element every time you find a matching **\")\"**. If you find a **\")\"** when **stack** is empty, that **\")\"** must be invalid. At the end of **S**, any leftover **\"(\"**\\'s left in **stack** must be invalid, as well. Since we\\'ll want to remove those **\"(\"**\\'s by index at the end, **stack** should contain said indexes, rather than just the **\"(\"**.\\n\\nNow that we\\'ve identified all the invalid parentheses, that leaves us with the problem of removing them from **S**. We could perform a lot of string slices and copies, but those are typically very slow and memory intensive, so we should probably find a data type that can be directly modified by index access and use that as an intermediary.\\n\\nThe most effective method varies by language, so I\\'ll discuss those in the *Implementation* section.\\n\\nThen we can make our removals and re-form and **return** our answer.\\n\\n---\\n\\n***Implementation:***\\n\\nJavascript has basic arrays, Python has lists, and Java has char arrays that will perform the job of a more flexible data type for this problem. C++ alone of the four languages has mutable strings, so we can just leave **S** as is.\\n\\nWhile Java has stack/deque/list structures, they\\'re not always terribly efficient, so we can just use a more basic int[] with a length fixed to the size of **S**, along with an index variable (**stIx**).\\n\\nJavascript conveniently allows us to directly delete an array element without screwing up our iteration, so we can use that on the initial pass for invalid **\"(\"**\\'s. Python can\\'t do that, but we can easily replace each character we want to delete with an empty string, which effectively does the same thing once the string has been joined again.\\n\\nJava and C++ won\\'t allow us to replace characters with empty strings, so we can just mark those characters with a **character mask** for later removal.\\n\\nOn the second pass through Javascript and Python can just repeat the same method while going through the remaining **stack**. Python is very fast with its appends and pops, so we can use that to our advantage.\\n\\nFor Java and C++, things are more difficult. We can\\'t change the length of the intermediary, but we *can* alter its contents by index assignment. That means we can use a two-pointer approach to rewrite the beginning portion of the intermediary before ultimately returning a subsection of it.\\n\\nSince we want to iterate through **stack** in opposite order (**FIFO**) this time, we can just tag a **-1** onto the end of the stack to avoid issues with going out-of-bounds, and then use **stIx** starting at **0**.\\n\\nThen, for every iteration, **j** will increment, but **i** will only increment if it\\'s not a character we want to remove (either by matching the character mask or the next stack entry), and we\\'ll overwrite the intermediary at **i** with **j**\\'s value.\\n\\nAt the end, the substring between **0** and **i** will represent the \"squeezed\" string with all invalid parentheses removed, so we should **return** it.\\n\\n---\\n\\n***Javascript Code:***\\n\\nThe best result for the code below is **76ms / 44.7MB** (beats 100% / 96%).\\n```javascript\\nvar minRemoveToMakeValid = function(S) {\\n    S = S.split(\"\")\\n    let len = S.length, stack = []\\n    for (let i = 0, c = S[0]; i < len; c = S[++i])\\n        if (c === \")\")\\n            if (stack.length) stack.pop()\\n            else delete S[i]\\n        else if (c === \"(\") stack.push(i)\\n    for (let i = 0; i < stack.length; i++)\\n        delete S[stack[i]]\\n    return S.join(\"\")\\n};\\n```\\n\\n---\\n\\n***Python Code:***\\n\\nThe best result for the code below is **72ms / 15.8MB** (beats 100% / 91%).\\n```python\\nclass Solution:\\n    def minRemoveToMakeValid(self, S: str) -> str:\\n        S, stack = list(S), []\\n        for i, c in enumerate(S):\\n            if c == \")\":\\n                if stack: stack.pop()\\n                else: S[i] = \"\"\\n            elif c == \"(\": stack.append(i)\\n        for i in stack: S[i] = \"\"\\n        return \"\".join(S)\\n```\\n\\n---\\n\\n***Java Code:***\\n\\nThe best result for the code below is **5ms / 39.1MB** (beats 100% / 99%).\\n```java\\nclass Solution {\\n    public String minRemoveToMakeValid(String S) {\\n        char[] ans = S.toCharArray();\\n        int len = S.length(), stIx = 0, i = 0, j = 0;\\n        int[] stack = new int[len+1];\\n        for (; i < len; i++)\\n            if (ans[i] == \\')\\')\\n                if (stIx > 0) stIx--;\\n                else ans[i] = \\'_\\';\\n            else if (ans[i] == \\'(\\') stack[stIx++] = i;\\n        for (i = 0, stack[stIx] = -1, stIx = 0; j < len; j++)\\n            if (j == stack[stIx]) stIx++;\\n            else if (ans[j] != \\'_\\') ans[i++] = ans[j];\\n        return new String(ans, 0, i);\\n    }\\n}\\n```\\n\\n---\\n\\n***C++ Code:***\\n\\nThe best result for the code below is **16ms / 10.2MB** (beats 99% / 91%).\\n```c++\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string S) {\\n        int len = S.size(), i = 0, j = 0, stIx = 0;\\n        vector<int> stack;\\n        for (; i < len; i++)\\n            if (S[i] == \\')\\')\\n                if (stack.size() > 0) stack.pop_back();\\n                else S[i] = \\'_\\';\\n            else if (S[i] == \\'(\\') stack.push_back(i);\\n        stack.push_back(-1);\\n        for (i = 0; j < len; j++)\\n            if (j == stack[stIx]) stIx++;\\n            else if (S[j] != \\'_\\') S[i++] = S[j];\\n        return S.substr(0, i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar minRemoveToMakeValid = function(S) {\\n    S = S.split(\"\")\\n    let len = S.length, stack = []\\n    for (let i = 0, c = S[0]; i < len; c = S[++i])\\n        if (c === \")\")\\n            if (stack.length) stack.pop()\\n            else delete S[i]\\n        else if (c === \"(\") stack.push(i)\\n    for (let i = 0; i < stack.length; i++)\\n        delete S[stack[i]]\\n    return S.join(\"\")\\n};\\n```\n```python\\nclass Solution:\\n    def minRemoveToMakeValid(self, S: str) -> str:\\n        S, stack = list(S), []\\n        for i, c in enumerate(S):\\n            if c == \")\":\\n                if stack: stack.pop()\\n                else: S[i] = \"\"\\n            elif c == \"(\": stack.append(i)\\n        for i in stack: S[i] = \"\"\\n        return \"\".join(S)\\n```\n```java\\nclass Solution {\\n    public String minRemoveToMakeValid(String S) {\\n        char[] ans = S.toCharArray();\\n        int len = S.length(), stIx = 0, i = 0, j = 0;\\n        int[] stack = new int[len+1];\\n        for (; i < len; i++)\\n            if (ans[i] == \\')\\')\\n                if (stIx > 0) stIx--;\\n                else ans[i] = \\'_\\';\\n            else if (ans[i] == \\'(\\') stack[stIx++] = i;\\n        for (i = 0, stack[stIx] = -1, stIx = 0; j < len; j++)\\n            if (j == stack[stIx]) stIx++;\\n            else if (ans[j] != \\'_\\') ans[i++] = ans[j];\\n        return new String(ans, 0, i);\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string S) {\\n        int len = S.size(), i = 0, j = 0, stIx = 0;\\n        vector<int> stack;\\n        for (; i < len; i++)\\n            if (S[i] == \\')\\')\\n                if (stack.size() > 0) stack.pop_back();\\n                else S[i] = \\'_\\';\\n            else if (S[i] == \\'(\\') stack.push_back(i);\\n        stack.push_back(-1);\\n        for (i = 0; j < len; j++)\\n            if (j == stack[stIx]) stIx++;\\n            else if (S[j] != \\'_\\') S[i++] = S[j];\\n        return S.substr(0, i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1073038,
                "title": "python-fast-easy-beats-98",
                "content": "Time complexity: O(n)\\n\\nBrief description:\\n\\nThere is one loop of searching parentheses in the string.  It\\'s important to use a stack to store the positions of open parentheses, because during iteration open parentheses are added and popped from the top of this data collection . In python the best implementation of the stack is using a list.\\n\\nThere are 2 reasons to remove parentheses:\\n1) If there is a valid parentheses string before a close parenthesis, remove this parenthesis.  This removal is done during the loop, so the string was converted to a list at the beginning.\\n2) If there are extra open parentheses (the stack is not empty), these parantheses should be deleted.\\n\\n\\nSolution:\\n```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        stack = []\\n        s = list(s)\\n        for i in range(len(s)):\\n            if s[i] == \"(\": stack.append(i)\\n            elif s[i] == \")\":\\n                if stack: stack.pop()\\n                else: s[i] = \"\"\\n        for i in stack:\\n            s[i] = \"\"\\n        return \"\".join(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        stack = []\\n        s = list(s)\\n        for i in range(len(s)):\\n            if s[i] == \"(\": stack.append(i)\\n            elif s[i] == \")\":\\n                if stack: stack.pop()\\n                else: s[i] = \"\"\\n        for i in stack:\\n            s[i] = \"\"\\n        return \"\".join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476921,
                "title": "java-easy-to-understand-using-stack-stringbuilder",
                "content": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        StringBuilder ans = new StringBuilder(s);\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i) == \\'(\\')\\n                st.push(i);\\n            else if(s.charAt(i) == \\')\\')\\n            {\\n                if(st.size() > 0 && s.charAt(st.peek()) == \\'(\\')\\n                    st.pop();\\n                else\\n                    st.push(i);\\n            }\\n        }\\n        \\n        while(st.size()>0)\\n            ans.deleteCharAt(st.pop());\\n        \\n        return ans.toString();\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        StringBuilder ans = new StringBuilder(s);\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i) == \\'(\\')\\n                st.push(i);\\n            else if(s.charAt(i) == \\')\\')\\n            {\\n                if(st.size() > 0 && s.charAt(st.peek()) == \\'(\\')\\n                    st.pop();\\n                else\\n                    st.push(i);\\n            }\\n        }\\n        \\n        while(st.size()>0)\\n            ans.deleteCharAt(st.pop());\\n        \\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228259,
                "title": "c-without-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s){\\n        int cnt=0;\\n        for(char &c: s){\\n            if(c==\\'(\\') cnt++;\\n            else if(c==\\')\\')\\n                if(cnt==0) c=\\'*\\';\\n                else cnt--;\\n        }\\n        cnt=0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\')\\') cnt++;\\n            else if(s[i]==\\'(\\')\\n                if(cnt==0) s[i]=\\'*\\';\\n                else cnt--;\\n        }\\n        s.erase(remove(s.begin(),s.end(),\\'*\\'),s.end());\\n        return s;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s){\\n        int cnt=0;\\n        for(char &c: s){\\n            if(c==\\'(\\') cnt++;\\n            else if(c==\\')\\')\\n                if(cnt==0) c=\\'*\\';\\n                else cnt--;\\n        }\\n        cnt=0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\')\\') cnt++;\\n            else if(s[i]==\\'(\\')\\n                if(cnt==0) s[i]=\\'*\\';\\n                else cnt--;\\n        }\\n        s.erase(remove(s.begin(),s.end(),\\'*\\'),s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420213,
                "title": "a-few-solutions",
                "content": "Perform a linear scan of the input string `s` and use a stack `S` to store each the index of each `\\'(\\'` character.  Whenever a `\\')\\'` character is seen, pop the index of the nearest corresponding match (if possible), otherwise if the stack is empty, then mark the current index to be deleted, ie. we add the index onto the set `X`.  Upon completion of the linear scan, we append \"leftover\" indices of the stack `S` onto `X` to be deleted.\\n\\nIn summary:\\n\\n1. we mark indices of `\\')\\'` to be deleted **during** the linear scan of the input string `s`\\n2. we mark indices of `\\'(\\'` to be deleted **after** the linear scan of the input string `s`\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minRemoveToMakeValid(s: String): String {\\n        var X = mutableSetOf<Int>()\\n        var S = mutableListOf<Int>()\\n        for ((i, c) in s.toCharArray().withIndex()) {\\n            if (c == \\'(\\')\\n                S.add(i)\\n            if (c == \\')\\') {\\n                if (0 < S.size)\\n                    S.removeAt(S.lastIndex)\\n                else\\n                    X.add(i)\\n            }\\n        }\\n        for (i in S) X.add(i)\\n        return s.toCharArray().withIndex().filter{ (i, c) -> !X.contains(i) }.map{ (_, c) -> c }.joinToString(\"\")\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minRemoveToMakeValid = (s, S = [], X = new Set()) => {\\n    for (let i = 0; i < s.length; ++i) {\\n        let c = s[i];\\n        if (c == \\'(\\')\\n            S.push(i);\\n        if (c == \\')\\') {\\n            if (S.length)\\n                S.pop();\\n            else\\n                X.add(i);\\n        }\\n    }\\n    S.forEach(i => X.add(i));\\n    return s.split(\\'\\').filter((_, i) => !X.has(i)).join(\\'\\');\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str, cnt = 0) -> str:\\n        S = []\\n        X = set()\\n        for i, c in enumerate(s):\\n            if c == \\'(\\':\\n                S.append(i)\\n            if c == \\')\\':\\n                if len(S):\\n                    S.pop()\\n                else:\\n                    X.add(i)\\n        [X.add(i) for i in S]\\n        return \\'\\'.join(c for i, c in enumerate(s) if i not in X)\\n```\\n\\n*Rust*\\n```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn min_remove_to_make_valid(s: String) -> String {\\n        let mut S = vec![];\\n        let mut R = HashSet::new();\\n        for (i, c) in s.chars().enumerate() {\\n            if c == \\'(\\' {\\n                S.push(i);\\n            }\\n            if c == \\')\\' {\\n                if 0 < S.len() {\\n                    S.pop();\\n                } else {\\n                    R.insert(i);\\n                }\\n            }\\n        }\\n        let L: HashSet<usize> = S.drain(..).collect();\\n        return s.chars().enumerate().filter(|(i, c)| !L.contains(i) && !R.contains(i)).map(|(i, c)| c).collect();\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<int>;\\n    using VI = vector<int>;\\n    string minRemoveToMakeValid(string s, string t = {}, VI S = {}, Set X = {}) {\\n        for (auto i{ 0 }; i < s.size(); ++i) {\\n            auto c = s[i];\\n            if (c == \\'(\\')\\n                S.push_back(i);\\n            if (c == \\')\\') {\\n                if (S.size())\\n                    S.pop_back();\\n                else\\n                    X.insert(i);\\n            }\\n        }\\n        X.insert(S.begin(), S.end());\\n        copy_if(s.begin(), s.end(), back_inserter(t), [&X, i = -1](auto c) mutable { return X.find(++i) == X.end(); });\\n        return t;\\n    }\\n};\\n```\\n\\n---\\n\\n**Legacy Solutions November 4, 2019:**\\nLet ```t``` be ```s``` transformed with minimum parens removed to make a valid paren string.  ```t``` is generated by iterating over each index ```i``` of ```s```:\\n* **Case 1:** if ```s[i]``` is ```(```, then push index ```i``` onto the stack since ```s[i]``` contains a potentially a \"leftover\" ```(```\\n* **Case 2:** if ```s[i]``` is ```)```, then the next step depends on the current stack state:\\n\\t* **either** the stack is empty and the ```)``` is superfluous and it\\'s index ```i``` is immediately marked for deletion\\n\\t* **or** the stack contains a matching ```(``` and it\\'s index ```i``` is popped off the stack [ie. the last seen ```(``` matches the current ```)```, thus the last seen ```(``` is *not* a potential \"leftover\"]\\n* **Case 3:** if ```s[i]``` is an alpha char, then no additional processing is needed [ie. it will be copied from ```s``` to ```t``` \"as is\"]\\n\\n**Notes:**\\n* For *case 1*, we do *not* know if each potential \"leftover\" ```(``` is actual \"leftover\" until ```s``` is completely processed since each potential future corresponding ```)``` found causes the index ```i``` associated with each potential \"leftover\" ```(``` to be popped off the stack.\\n* After ```s``` is completely processed all indices remaining in the stack are associated with \"leftover\" ```(```.  Mark all these indices for deletion.\\n\\n*Javascript*\\n```\\nvar minRemoveToMakeValid = (s, t=[], del=new Set(), stack=[]) => {\\n    for (let i=0; i < s.length; ++i) {\\n        if (s[i] == \\'(\\')\\n            stack.push(i);\\n        if (s[i] == \\')\\') {\\n            if (stack.length == 0)\\n                del.add(i);\\n            else\\n                stack.pop();\\n        }\\n    }\\n    stack.forEach(i => del.add(i));\\n    for (let i=0; i < s.length; ++i)\\n        if (!del.has(i))\\n            t.push(s[i]);\\n    return t.join(\\'\\');\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s, string t={}, unordered_set<int> del={}, vector<int> stack={}) {\\n        for (auto i=0; i < s.size(); ++i) {\\n            if (s[i] == \\'(\\')\\n                stack.push_back(i);\\n            if (s[i] == \\')\\') {\\n                if (stack.empty())\\n                    del.insert(i);\\n                else\\n                    stack.pop_back();\\n            }\\n        }\\n        del.insert(stack.begin(), stack.end());\\n        for (auto i=0; i < s.size(); ++i)\\n            if (del.find(i) == del.end())\\n                t.push_back(s[i]);\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minRemoveToMakeValid(s: String): String {\\n        var X = mutableSetOf<Int>()\\n        var S = mutableListOf<Int>()\\n        for ((i, c) in s.toCharArray().withIndex()) {\\n            if (c == \\'(\\')\\n                S.add(i)\\n            if (c == \\')\\') {\\n                if (0 < S.size)\\n                    S.removeAt(S.lastIndex)\\n                else\\n                    X.add(i)\\n            }\\n        }\\n        for (i in S) X.add(i)\\n        return s.toCharArray().withIndex().filter{ (i, c) -> !X.contains(i) }.map{ (_, c) -> c }.joinToString(\"\")\\n    }\\n}\\n```\n```\\nlet minRemoveToMakeValid = (s, S = [], X = new Set()) => {\\n    for (let i = 0; i < s.length; ++i) {\\n        let c = s[i];\\n        if (c == \\'(\\')\\n            S.push(i);\\n        if (c == \\')\\') {\\n            if (S.length)\\n                S.pop();\\n            else\\n                X.add(i);\\n        }\\n    }\\n    S.forEach(i => X.add(i));\\n    return s.split(\\'\\').filter((_, i) => !X.has(i)).join(\\'\\');\\n};\\n```\n```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str, cnt = 0) -> str:\\n        S = []\\n        X = set()\\n        for i, c in enumerate(s):\\n            if c == \\'(\\':\\n                S.append(i)\\n            if c == \\')\\':\\n                if len(S):\\n                    S.pop()\\n                else:\\n                    X.add(i)\\n        [X.add(i) for i in S]\\n        return \\'\\'.join(c for i, c in enumerate(s) if i not in X)\\n```\n```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn min_remove_to_make_valid(s: String) -> String {\\n        let mut S = vec![];\\n        let mut R = HashSet::new();\\n        for (i, c) in s.chars().enumerate() {\\n            if c == \\'(\\' {\\n                S.push(i);\\n            }\\n            if c == \\')\\' {\\n                if 0 < S.len() {\\n                    S.pop();\\n                } else {\\n                    R.insert(i);\\n                }\\n            }\\n        }\\n        let L: HashSet<usize> = S.drain(..).collect();\\n        return s.chars().enumerate().filter(|(i, c)| !L.contains(i) && !R.contains(i)).map(|(i, c)| c).collect();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<int>;\\n    using VI = vector<int>;\\n    string minRemoveToMakeValid(string s, string t = {}, VI S = {}, Set X = {}) {\\n        for (auto i{ 0 }; i < s.size(); ++i) {\\n            auto c = s[i];\\n            if (c == \\'(\\')\\n                S.push_back(i);\\n            if (c == \\')\\') {\\n                if (S.size())\\n                    S.pop_back();\\n                else\\n                    X.insert(i);\\n            }\\n        }\\n        X.insert(S.begin(), S.end());\\n        copy_if(s.begin(), s.end(), back_inserter(t), [&X, i = -1](auto c) mutable { return X.find(++i) == X.end(); });\\n        return t;\\n    }\\n};\\n```\n```t```\n```s```\n```t```\n```i```\n```s```\n```s[i]```\n```(```\n```i```\n```s[i]```\n```(```\n```s[i]```\n```)```\n```)```\n```i```\n```(```\n```i```\n```(```\n```)```\n```(```\n```s[i]```\n```s```\n```t```\n```(```\n```s```\n```)```\n```i```\n```(```\n```s```\n```(```\n```\\nvar minRemoveToMakeValid = (s, t=[], del=new Set(), stack=[]) => {\\n    for (let i=0; i < s.length; ++i) {\\n        if (s[i] == \\'(\\')\\n            stack.push(i);\\n        if (s[i] == \\')\\') {\\n            if (stack.length == 0)\\n                del.add(i);\\n            else\\n                stack.pop();\\n        }\\n    }\\n    stack.forEach(i => del.add(i));\\n    for (let i=0; i < s.length; ++i)\\n        if (!del.has(i))\\n            t.push(s[i]);\\n    return t.join(\\'\\');\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s, string t={}, unordered_set<int> del={}, vector<int> stack={}) {\\n        for (auto i=0; i < s.size(); ++i) {\\n            if (s[i] == \\'(\\')\\n                stack.push_back(i);\\n            if (s[i] == \\')\\') {\\n                if (stack.empty())\\n                    del.insert(i);\\n                else\\n                    stack.pop_back();\\n            }\\n        }\\n        del.insert(stack.begin(), stack.end());\\n        for (auto i=0; i < s.size(); ++i)\\n            if (del.find(i) == del.end())\\n                t.push_back(s[i]);\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419880,
                "title": "simply-simple-python-solution-with-comments",
                "content": "```\\ndef minRemoveToMakeValid(self, s: str) -> str:\\n        status_dict = {}\\n        stack = []\\n       \\n        # keep indexe\\'s status in status_dict. If a parenthesis is valid\\n        # mark it as True else False. use stack to check it\\'s validity\\n        for idx, ch in enumerate(s):\\n            if ch == \"(\":\\n                stack.append(idx)\\n            elif ch == \")\" and len(stack) > 0:\\n                    status_dict[idx] = True\\n                    status_dict[stack[-1]] = True\\n                    stack.pop()\\n       \\n        res = []\\n        for idx, ch in enumerate(s):\\n            if ch == \"(\" or ch == \")\":\\n                if idx in status_dict: # only append the parenthesis which are valid\\n                    res.append(ch)\\n            else:\\n                res.append(ch)\\n       \\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef minRemoveToMakeValid(self, s: str) -> str:\\n        status_dict = {}\\n        stack = []\\n       \\n        # keep indexe\\'s status in status_dict. If a parenthesis is valid\\n        # mark it as True else False. use stack to check it\\'s validity\\n        for idx, ch in enumerate(s):\\n            if ch == \"(\":\\n                stack.append(idx)\\n            elif ch == \")\" and len(stack) > 0:\\n                    status_dict[idx] = True\\n                    status_dict[stack[-1]] = True\\n                    stack.pop()\\n       \\n        res = []\\n        for idx, ch in enumerate(s):\\n            if ch == \"(\" or ch == \")\":\\n                if idx in status_dict: # only append the parenthesis which are valid\\n                    res.append(ch)\\n            else:\\n                res.append(ch)\\n       \\n        return \"\".join(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1072675,
                "title": "c-super-simple-o-n-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack<int> stack;\\n        int n = s.size();\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (s[i] == \\'(\\') \\n                stack.push(i);\\n            \\n            else if (s[i] == \\')\\') {\\n                \\n                if (!stack.empty()) {\\n                    stack.pop();\\n                }\\n                    \\n                else {\\n                    s.erase(i, 1);\\n                    i--;\\n                }\\n            }\\n        }\\n        \\n        while (!stack.empty()) {\\n            s.erase(stack.top(), 1);\\n            stack.pop();\\n        }\\n        return s;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack<int> stack;\\n        int n = s.size();\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (s[i] == \\'(\\') \\n                stack.push(i);\\n            \\n            else if (s[i] == \\')\\') {\\n                \\n                if (!stack.empty()) {\\n                    stack.pop();\\n                }\\n                    \\n                else {\\n                    s.erase(i, 1);\\n                    i--;\\n                }\\n            }\\n        }\\n        \\n        while (!stack.empty()) {\\n            s.erase(stack.top(), 1);\\n            stack.pop();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072642,
                "title": "python-two-pass-o-n-solution-explained",
                "content": "When you see in problem formulation, that it is something about valid parantheses, you should immedietly thing about **stack**, because the very classical problems in this topic uses stack.\\n\\nLet us traverse our string from left to right and make sure, that we do not have any problems with balance:\\n1. If symbol is `(`, then we increase balance by `1` and add this symbol to `ans`.\\n2. If symbol is `)`, then we can add this symbol only if balance is positive: if it is `0`, then we can not recover our string if we continue.\\n3. If symbol not `(` and not `)`, we add it to `ans`.\\n\\nHowever, it is not enough to do only one traverse: so far when we finished, we can say that:\\n1. Balance is never negative\\n2. But balance in the end should be equal to `0`.\\n\\nThese `2` conditions and **sufficient** and **enough** to have valid parentheses and at the moment only the fist one is fulfilled. What we can do now is to traverse string from the end and keep removing symbols until balance becomes equal to `0`. Or we can use our `clean` function and apply it to reversed string.\\n\\n**Complexity**: time complexity is `O(n)`, we traverse our string twice. Space complexity is also `O(n)`.\\n\\n```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s):\\n        def clean(s, op, cl):\\n            balance, ans = 0, \"\"\\n            for i in s:\\n                if i == op:\\n                    balance += 1\\n                    ans += i\\n                elif i == cl and balance > 0:\\n                    balance -= 1\\n                    ans += i\\n                elif i not in \"()\":\\n                    ans += i              \\n            return ans\\n        \\n        return clean(clean(s, \"(\", \")\")[::-1], \")\", \"(\")[::-1]\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s):\\n        def clean(s, op, cl):\\n            balance, ans = 0, \"\"\\n            for i in s:\\n                if i == op:\\n                    balance += 1\\n                    ans += i\\n                elif i == cl and balance > 0:\\n                    balance -= 1\\n                    ans += i\\n                elif i not in \"()\":\\n                    ans += i              \\n            return ans\\n        \\n        return clean(clean(s, \"(\", \")\")[::-1], \")\", \"(\")[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 443932,
                "title": "python-in-12-lines-to-solve-the-classic-parentheses-problem",
                "content": "#### 1st approach\\n\\nHere was my first approach using the way I solved [#921](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid) \\nNot the best but easy to come up with if you solved similar problem e.g. [#921](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid) [#20](https://leetcode.com/problems/valid-parentheses)  \\n\\n```py\\n\"\"\"\\n    1st: stack + hashtable\\n    - similar to lc921 but save the indices of the redundant opens & closes\\n    - construct the result by removing the characters at redundant indices\\n    - 12 lines\\n    \\n    Time    O(3N)\\n    Space   O(N)\\n    164 ms, faster than 79.33%\\n\"\"\"\\nclass Solution(object):\\n    def minRemoveToMakeValid(self, s):\\n        opens, closes = [], []\\n        for i in range(len(s)):\\n            c = s[i]\\n            if c == \\'(\\':\\n                opens.append(i)\\n            elif c == \\')\\':\\n                if len(opens) == 0:\\n                    closes.append(i)\\n                else:\\n                    opens.pop()\\n        hs = set(opens+closes)\\n        return \\'\\'.join(s[i] for i in range(len(s)) if i not in hs)\\n```\\n\\n#### 2nd approach\\n\\nIf you don\\'t like hashtable, we can just construct an array to save the redundant parentheses and solve the problem in the same way\\n\\n```py\\n\"\"\"\\n    2nd: similar logic without using a hashtable\\n\\t- 17 lines\\n\\n    Time    O(3N)\\n    Space   O(N)\\n    244 ms, faster than 45.31%\\n\"\"\"\\n\\n\\nclass Solution(object):\\n    def minRemoveToMakeValid(self, s):\\n        res, opens = [], []\\n        for i in range(len(s)):\\n            c = s[i]\\n            if c == \\'(\\':\\n                opens.append(i)\\n                res += c\\n            elif c == \\')\\':\\n                if len(opens) == 0:\\n                    res += \\'*\\'\\n                else:\\n                    opens.pop()\\n                    res += c\\n            else:\\n                res += c\\n        for x in opens:\\n            res[x] = \\'*\\'\\n        return \\'\\'.join(c for c in res if c != \\'*\\')\\n```",
                "solutionTags": [],
                "code": "```py\\n\"\"\"\\n    1st: stack + hashtable\\n    - similar to lc921 but save the indices of the redundant opens & closes\\n    - construct the result by removing the characters at redundant indices\\n    - 12 lines\\n    \\n    Time    O(3N)\\n    Space   O(N)\\n    164 ms, faster than 79.33%\\n\"\"\"\\nclass Solution(object):\\n    def minRemoveToMakeValid(self, s):\\n        opens, closes = [], []\\n        for i in range(len(s)):\\n            c = s[i]\\n            if c == \\'(\\':\\n                opens.append(i)\\n            elif c == \\')\\':\\n                if len(opens) == 0:\\n                    closes.append(i)\\n                else:\\n                    opens.pop()\\n        hs = set(opens+closes)\\n        return \\'\\'.join(s[i] for i in range(len(s)) if i not in hs)\\n```\n```py\\n\"\"\"\\n    2nd: similar logic without using a hashtable\\n\\t- 17 lines\\n\\n    Time    O(3N)\\n    Space   O(N)\\n    244 ms, faster than 45.31%\\n\"\"\"\\n\\n\\nclass Solution(object):\\n    def minRemoveToMakeValid(self, s):\\n        res, opens = [], []\\n        for i in range(len(s)):\\n            c = s[i]\\n            if c == \\'(\\':\\n                opens.append(i)\\n                res += c\\n            elif c == \\')\\':\\n                if len(opens) == 0:\\n                    res += \\'*\\'\\n                else:\\n                    opens.pop()\\n                    res += c\\n            else:\\n                res += c\\n        for x in opens:\\n            res[x] = \\'*\\'\\n        return \\'\\'.join(c for c in res if c != \\'*\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072577,
                "title": "min-remove-to-make-valid-parantheses-c-stack-code-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n\\t\\n\\t\\t// define a stack which holds the parantheses along with the position\\n        stack<pair<int, char> > stk;\\n\\t\\t\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == \\'(\\'){\\n\\t\\t\\t    // if opening braces, push into the stack\\n                stk.push(make_pair(i, \\'(\\'));\\n            }else if(s[i] == \\')\\'){\\n\\t\\t\\t    // If closing braces, check if opening present or not. If yes, pop it.\\n\\t\\t\\t\\t// Else mark that position of closing brace with \\'1\\' in the string.\\n\\t\\t\\t\\t// 1 suggest that it should get removed.\\n                if(stk.empty()){\\n                    s[i] = \\'1\\';\\n                }else{\\n                    stk.pop();\\n                }\\n            }\\n        }\\n        \\n\\t\\t// Now check for any leftover opening braces in the stack.\\n\\t\\t// Mark those position with \\'1\\'.\\n\\t\\t// That is they should get removed.\\n        while(!stk.empty()){\\n            pair<int, char> TOP = stk.top();\\n            s[TOP.first] = \\'1\\';\\n            stk.pop();\\n        }\\n        \\n\\t\\t\\n\\t\\t// Now push all the characters in a string which aren\\'t marked as \\'1\\'.\\n\\t\\tstring output = \"\";\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] != \\'1\\'){\\n                output.push_back(s[i]);\\n            }\\n        }\\n        \\n        return output;\\n    }\\n};\\n```\\n\\nWhy am using 1 to mark position?\\nCause it is previously said to us that input string will only contain \\'(\\' and \\')\\' and lower-case letters.\\n\\nPlease *upvote* if you like the solution.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n\\t\\n\\t\\t// define a stack which holds the parantheses along with the position\\n        stack<pair<int, char> > stk;\\n\\t\\t\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == \\'(\\'){\\n\\t\\t\\t    // if opening braces, push into the stack\\n                stk.push(make_pair(i, \\'(\\'));\\n            }else if(s[i] == \\')\\'){\\n\\t\\t\\t    // If closing braces, check if opening present or not. If yes, pop it.\\n\\t\\t\\t\\t// Else mark that position of closing brace with \\'1\\' in the string.\\n\\t\\t\\t\\t// 1 suggest that it should get removed.\\n                if(stk.empty()){\\n                    s[i] = \\'1\\';\\n                }else{\\n                    stk.pop();\\n                }\\n            }\\n        }\\n        \\n\\t\\t// Now check for any leftover opening braces in the stack.\\n\\t\\t// Mark those position with \\'1\\'.\\n\\t\\t// That is they should get removed.\\n        while(!stk.empty()){\\n            pair<int, char> TOP = stk.top();\\n            s[TOP.first] = \\'1\\';\\n            stk.pop();\\n        }\\n        \\n\\t\\t\\n\\t\\t// Now push all the characters in a string which aren\\'t marked as \\'1\\'.\\n\\t\\tstring output = \"\";\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] != \\'1\\'){\\n                output.push_back(s[i]);\\n            }\\n        }\\n        \\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060285,
                "title": "java-stack-stringbuilder",
                "content": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n         Stack<Integer> stack = new Stack<>();\\n       StringBuilder stringBuilder = new StringBuilder(s); //a)b(c)d\"\\n       for(int i = 1;i<=s.length();i++){\\n           if(s.charAt(i-1) == \\'(\\')\\n               stack.push(i);\\n           else if(s.charAt(i-1) == \\')\\' && !stack.empty())\\n               stack.pop();\\n           else if(s.charAt(i-1) ==\\')\\' && stack.empty()){//))((\\n               stringBuilder.replace(i-1,i, \"0\");\\n           }\\n       }\\n      \\n       while (!stack.empty()){\\n           stringBuilder.deleteCharAt(stack.pop()-1);\\n       }\\n       return stringBuilder.toString().\\n               replace(\\'0\\',\\' \\').\\n               replaceAll(\"\\\\\\\\s+\",\"\");\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public String minRemoveToMakeValid(String s) {\\n         Stack<Integer> stack = new Stack<>();\\n       StringBuilder stringBuilder = new StringBuilder(s); //a)b(c)d\"\\n       for(int i = 1;i<=s.length();i++){\\n           if(s.charAt(i-1) == \\'(\\')\\n               stack.push(i);\\n           else if(s.charAt(i-1) == \\')\\' && !stack.empty())\\n               stack.pop();\\n           else if(s.charAt(i-1) ==\\')\\' && stack.empty()){//))((\\n               stringBuilder.replace(i-1,i, \"0\");\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 1749660,
                "title": "c-solution-using-stack-in-o-n-time-complexity-with-explanation",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we\\u2019re using a stack to store the position of parentheses.\\n- If it is an open parenthesis then increase the count and push the index to stack.\\n- else if it\\u2019s a close parenthesis then check if the count is not 0 then decrease the count and pop the last element from the stack. if count=0 then push the index to stack.\\n- now iterate the stack and remove the elements from the index present in the stack\\n- **Time complexity:** O(n^2).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int n = s.size();\\n        stack<int> st;\\n        int i=0, count=0;\\n        while(i<n){\\n            if(s[i] == \\'(\\'){\\n                count++;\\n                st.push(i);\\n            }\\n            else if(s[i] == \\')\\'){\\n                if(count > 0){\\n                    count--;\\n                    st.pop();\\n                }\\n                else\\n                    st.push(i);\\n            }\\n            i++;\\n        }\\n        int m = st.size();\\n        while(m--){\\n            int temp= st.top();\\n            s.erase(temp,1);\\n            st.pop();\\n        }\\n        return s;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int n = s.size();\\n        stack<int> st;\\n        int i=0, count=0;\\n        while(i<n){\\n            if(s[i] == \\'(\\'){\\n                count++;\\n                st.push(i);\\n            }\\n            else if(s[i] == \\')\\'){\\n                if(count > 0){\\n                    count--;\\n                    st.pop();\\n                }\\n                else\\n                    st.push(i);\\n            }\\n            i++;\\n        }\\n        int m = st.size();\\n        while(m--){\\n            int temp= st.top();\\n            s.erase(temp,1);\\n            st.pop();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617633,
                "title": "easy-java-solution-o-n-time",
                "content": "**Upvote if you Got It** \\uD83D\\uDE42\\nclass Solution {\\n\\n    public String minRemoveToMakeValid(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        StringBuilder sb = new StringBuilder(s);\\n\\t\\t\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\')\\n                st.push(i);\\n            else if(s.charAt(i)==\\')\\'){\\n                if(!st.isEmpty() && s.charAt(st.peek())==\\'(\\')\\n                    st.pop();\\n                else\\n                    st.push(i);\\n            }\\n        }\\n        while(!st.isEmpty())\\n            sb.deleteCharAt(st.pop());\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n\\n    public String minRemoveToMakeValid(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        StringBuilder sb = new StringBuilder(s);\\n\\t\\t\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\')\\n                st.push(i);\\n            else if(s.charAt(i)==\\')\\'){\\n                if(!st.isEmpty() && s.charAt(st.peek())==\\'(\\')\\n                    st.pop();\\n                else\\n                    st.push(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 601783,
                "title": "c-o-n-explanation",
                "content": "```\\nThe way to tackle this question is to keep a varial lets say open that increments for every opening braces and decrements for every closing\\nbraces.\\nWe will first be considering mismatches of the closing brackets \\')\\'.\\nif open is equal to 0 and a closing bracket occurs ignore it.\\ns = \"lee(t(c)o)de)\"    open=0\\n         ^\\n         |\\n         i\\nopen = 1\\ns = \"lee(t(c)o)de)\"\\n          ^\\n          |\\n          i \\nopen = 2\\n\\ns = \"lee(t(c)o)de)\"\\n            ^\\n            |\\n            i\\nopen is not 0 \\nopen = 1\\n\\ns = \"lee(t(c)o)de)\"\\n              ^\\n              |\\n              i \\nopen not 0 \\nopen = 0\\n\\ns = \"lee(t(c)o)de)\"\\n                 ^\\n                 |\\n                 i \\nopen is 0 so ignore\\n\\nBut what if there are more opening braces than closing to handle this we first make sure the closing braces are taken care of\\n then with the same open we start from behind and check if open is > 0 if so we skip it and decremnt open.\\n\\n\\n     string minRemoveToMakeValid(string s) {\\n        int open=0;\\n        string t;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')open++;\\n            else if(s[i]==\\')\\')\\n            {\\n                if(open==0)continue;\\n                open--;\\n            }\\n            t+=s[i];\\n        }\\n        string ans;\\n        for(int i=t.size()-1;i>=0;i--)\\n        {\\n            if(t[i]==\\'(\\' && open>0)\\n            {\\n                open--;\\n                continue;\\n            }\\n            ans+=t[i];\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    } \\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nThe way to tackle this question is to keep a varial lets say open that increments for every opening braces and decrements for every closing\\nbraces.\\nWe will first be considering mismatches of the closing brackets \\')\\'.\\nif open is equal to 0 and a closing bracket occurs ignore it.\\ns = \"lee(t(c)o)de)\"    open=0\\n         ^\\n         |\\n         i\\nopen = 1\\ns = \"lee(t(c)o)de)\"\\n          ^\\n          |\\n          i \\nopen = 2\\n\\ns = \"lee(t(c)o)de)\"\\n            ^\\n            |\\n            i\\nopen is not 0 \\nopen = 1\\n\\ns = \"lee(t(c)o)de)\"\\n              ^\\n              |\\n              i \\nopen not 0 \\nopen = 0\\n\\ns = \"lee(t(c)o)de)\"\\n                 ^\\n                 |\\n                 i \\nopen is 0 so ignore\\n\\nBut what if there are more opening braces than closing to handle this we first make sure the closing braces are taken care of\\n then with the same open we start from behind and check if open is > 0 if so we skip it and decremnt open.\\n\\n\\n     string minRemoveToMakeValid(string s) {\\n        int open=0;\\n        string t;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')open++;\\n            else if(s[i]==\\')\\')\\n            {\\n                if(open==0)continue;\\n                open--;\\n            }\\n            t+=s[i];\\n        }\\n        string ans;\\n        for(int i=t.size()-1;i>=0;i--)\\n        {\\n            if(t[i]==\\'(\\' && open>0)\\n            {\\n                open--;\\n                continue;\\n            }\\n            ans+=t[i];\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    } \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1851762,
                "title": "easy-understanding-solution-using-stack-and-stringbuilder",
                "content": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        Stack<Integer> st = new Stack<>();\\n      StringBuilder ans = new StringBuilder(s);\\n      for(int i = 0; i < s.length(); i ++)\\n      {\\n        if(s.charAt(i) == \\'(\\')\\n          st.push(i);\\n        else if(s.charAt(i) == \\')\\')\\n        {\\n          if(st.size() > 0 && s.charAt(st.peek()) == \\'(\\')\\n            st.pop();\\n          else\\n            st.push(i);\\n        }\\n      }\\n      while(st.size() > 0)\\n        ans.deleteCharAt(st.pop());\\n      \\n      return ans.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "class Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        Stack<Integer> st = new Stack<>();\\n      StringBuilder ans = new StringBuilder(s);\\n      for(int i = 0; i < s.length(); i ++)\\n      {\\n        if(s.charAt(i) == \\'(\\')\\n          st.push(i);\\n        else if(s.charAt(i) == \\')\\')\\n        {\\n          if(st.size() > 0 && s.charAt(st.peek()) == \\'(\\')\\n            st.pop();\\n          else\\n            st.push(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1850262,
                "title": "buidling-intuition-step-by-step-comments-stack-based-c-proper-intuition",
                "content": "take the first taste case:  \"lee(t(c)o)de)\"\\n  answer should be : \"lee(t(c)o)de\"\\n  \\n  intuition: \\n    1) if we observe, the one who opens later need to closed first so stack comes into picture \\n    2) so here \\'(\\' at index 5 needs to closed first and then \\'(\\' at index 3 needs to closed subsequently\\n    3) simalarly we maintain the count for open_brackets and closed_brackets \\n    4) if (count of closed brackets becomes) > (the open_brackets) that means we don\\'t have any open bracket before this closed bracket so we need to eleminate this closed bracket from answer string\\n    \\n\\tso here in this first tast case \\n\\t1)closed bracket at index 7 will be satisfy with open bracket at index 5\\n\\t2)closed bracket at index 9 will be satisfy with open bracket at index 3\\n\\t3)but closed bracket at index 12 does not have any open bracket so we will not take that one in our answer\\n\\t\\nNow take second test case: \"a)b(c)d\"\\nanswer should be : \"ab(c)d\"\\n```\\nso here in second test case:\\n \\n 1)here closed bracket at index 1 does not have any open bracket before it so we will not take that in         our answer\\n 2)but closed bracket at index 5 have open brakcet before it to satisfy so we will take it\\n```\\n\\nNow take 3rd test case : \"))((\"\\nanswer: \"\"\\n\\n```\\nSo here int 3rd test case:\\n1)here closed brackets at index 0 and 1 are out from our answer\\n2)but open brackets at index 2 and 3 does not have any closed brackets to satisfy them so no need to      take them in answer \\n```\\n\\n\\n```\\nso Approach:\\n1. we will create empty stack\\n2. then tarverse the string from left to right\\n    1. if s[i]!=\\'(\\' && s[i]!=\\')\\' then add it into our stack\\n    2. else if  s[i]==\\'(\\' then add into stack and increase the count of open_brackets++\\n    3. else means closed bracket add it to stack increase the count of closed_brackets but \\n         1. if closed_brackets>open_brackets then remove the closed bracket from the stack and \\n                       decrese the count of closed bracket\\n3.so uptil now we have taken care of closed brackets but how to takel open brackets\\n4. so we have count of open_brackets and closed_brackets\\n5. if open_brackets are more then closed_brackets means their are more (open_brackets - closed_brackest) open brackets so to handle them we will remove first (open_bracket - closed_brackets) open brackest from stack \\n```\\n     \\n  \\n\\nThanks and if you liked please upvote\\n\\n```\\nstring minRemoveToMakeValid(string s) {\\n        \\n        int length_s=s.size();     //getting the length of string \\n        stack<char> stk;           //creating the empty stack for storing the characters\\n        \\n        int open_brackets=0;       //initizing the count for open_brackets\\n        int close_brackets=0;      ////initizing the count for close_brackets\\n        \\n        for(int i=0;i<length_s;i++) //traversing the string from left to right\\n        {\\n            if(s[i]!=\\'(\\' && s[i]!=\\')\\')  // if it character not equal to open and closed bracket \\n            {\\n                stk.push(s[i]);          //then add it to stack\\n            }\\n            else\\n            {\\n                if(s[i]==\\'(\\')          //if it is open bracket\\n                {\\n                    open_brackets++;   //increase the count of open_bracket\\n                    stk.push(s[i]);    //add it to stack \\n                }\\n                else\\n                {\\n                    close_brackets++;  //if it is closed bracket\\n                    stk.push(s[i]);    //add it to satck \\n                    if(close_brackets>open_brackets) //if closed brackets are more than open brackets then \\n                    {\\n                        stk.pop();                   //pop the closed bracket which we have added\\n                        close_brackets--;            //and decrease the count og close_bracket\\n                    }\\n                }\\n            }\\n        }\\n        string ans=\"\";                               //initilizing the answer string\\n        if(open_brackets>close_brackets)             //we have already taken care of closed brackets now need  to handle open brackets\\n        {\\n            int diff=open_brackets-close_brackets;  //number of open brackets more than closed brackets need to remove from answer string\\n            while(stk.empty()==false)\\n            {\\n                char top=stk.top();\\n                stk.pop();\\n                \\n                if(top==\\'(\\' && diff!=0)       \\n                {\\n                    diff--;\\n                }\\n                else\\n                {\\n                    ans+=top;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            while(stk.empty()==false)\\n            {\\n                char top=stk.top();\\n                stk.pop();\\n                ans+=top;\\n            }\\n        }\\n        reverse(ans.begin(),ans.end());                //reversing the string \\n        return(ans);\\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nso here in second test case:\\n \\n 1)here closed bracket at index 1 does not have any open bracket before it so we will not take that in         our answer\\n 2)but closed bracket at index 5 have open brakcet before it to satisfy so we will take it\\n```\n```\\nSo here int 3rd test case:\\n1)here closed brackets at index 0 and 1 are out from our answer\\n2)but open brackets at index 2 and 3 does not have any closed brackets to satisfy them so no need to      take them in answer \\n```\n```\\nso Approach:\\n1. we will create empty stack\\n2. then tarverse the string from left to right\\n    1. if s[i]!=\\'(\\' && s[i]!=\\')\\' then add it into our stack\\n    2. else if  s[i]==\\'(\\' then add into stack and increase the count of open_brackets++\\n    3. else means closed bracket add it to stack increase the count of closed_brackets but \\n         1. if closed_brackets>open_brackets then remove the closed bracket from the stack and \\n                       decrese the count of closed bracket\\n3.so uptil now we have taken care of closed brackets but how to takel open brackets\\n4. so we have count of open_brackets and closed_brackets\\n5. if open_brackets are more then closed_brackets means their are more (open_brackets - closed_brackest) open brackets so to handle them we will remove first (open_bracket - closed_brackets) open brackest from stack \\n```\n```\\nstring minRemoveToMakeValid(string s) {\\n        \\n        int length_s=s.size();     //getting the length of string \\n        stack<char> stk;           //creating the empty stack for storing the characters\\n        \\n        int open_brackets=0;       //initizing the count for open_brackets\\n        int close_brackets=0;      ////initizing the count for close_brackets\\n        \\n        for(int i=0;i<length_s;i++) //traversing the string from left to right\\n        {\\n            if(s[i]!=\\'(\\' && s[i]!=\\')\\')  // if it character not equal to open and closed bracket \\n            {\\n                stk.push(s[i]);          //then add it to stack\\n            }\\n            else\\n            {\\n                if(s[i]==\\'(\\')          //if it is open bracket\\n                {\\n                    open_brackets++;   //increase the count of open_bracket\\n                    stk.push(s[i]);    //add it to stack \\n                }\\n                else\\n                {\\n                    close_brackets++;  //if it is closed bracket\\n                    stk.push(s[i]);    //add it to satck \\n                    if(close_brackets>open_brackets) //if closed brackets are more than open brackets then \\n                    {\\n                        stk.pop();                   //pop the closed bracket which we have added\\n                        close_brackets--;            //and decrease the count og close_bracket\\n                    }\\n                }\\n            }\\n        }\\n        string ans=\"\";                               //initilizing the answer string\\n        if(open_brackets>close_brackets)             //we have already taken care of closed brackets now need  to handle open brackets\\n        {\\n            int diff=open_brackets-close_brackets;  //number of open brackets more than closed brackets need to remove from answer string\\n            while(stk.empty()==false)\\n            {\\n                char top=stk.top();\\n                stk.pop();\\n                \\n                if(top==\\'(\\' && diff!=0)       \\n                {\\n                    diff--;\\n                }\\n                else\\n                {\\n                    ans+=top;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            while(stk.empty()==false)\\n            {\\n                char top=stk.top();\\n                stk.pop();\\n                ans+=top;\\n            }\\n        }\\n        reverse(ans.begin(),ans.end());                //reversing the string \\n        return(ans);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1850209,
                "title": "c-easy-to-understand-with-proper-explanation",
                "content": "# Daily Challenge:-15/03/2022.\\n**Concept:**-We have to remove total of those braces which are invalid.\\n-->**Step1:-** With the Help of stack store the indices of invalid braces.\\n-->**Step2:-** Calculation to calculate the output result,by neglecting invalid braces indices which will present in stack.\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        /*Step1:-With the Help of Stack we are storing Indices of invalid braces.*/\\n        stack<pair<char,int>>st;\\n        string result=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\'||s[i]==\\')\\')\\n            {\\n                if(st.size()>0&&(st.top().first==\\'(\\'&&s[i]==\\')\\'))\\n                    st.pop();\\n                else\\n                    st.push({s[i],i});\\n            }\\n        }\\n        \\n/*Step2:-As we know after the step 1 calculation,Stack will store the indices of invalid braces from right to left. Means stack top have indices of invalid braces which is in right most.\\nThat\\'s why itrating from right to left in string.\\nIn side this Loop ,we are checking,wheather the ith index is invalid or not by comparing with stack top.\\nif it is invalid then we didn\\'t store it in our result,and we pop it from stack.\\nOtherwise we store it in our resut.*/\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(st.size()>0&&st.top().second==i)\\n            {\\n                st.pop();\\n                continue;\\n            }\\n            else\\n                result.push_back(s[i]);\\n        }\\n        \\n        reverse(result.begin(),result.end()); //At the end reverse the answer.\\n        return result; //return result \\n    }\\n};\\n```\\nIf you Find it helpful,please Upvote.",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        /*Step1:-With the Help of Stack we are storing Indices of invalid braces.*/\\n        stack<pair<char,int>>st;\\n        string result=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\'||s[i]==\\')\\')\\n            {\\n                if(st.size()>0&&(st.top().first==\\'(\\'&&s[i]==\\')\\'))\\n                    st.pop();\\n                else\\n                    st.push({s[i],i});\\n            }\\n        }\\n        \\n/*Step2:-As we know after the step 1 calculation,Stack will store the indices of invalid braces from right to left. Means stack top have indices of invalid braces which is in right most.\\nThat\\'s why itrating from right to left in string.\\nIn side this Loop ,we are checking,wheather the ith index is invalid or not by comparing with stack top.\\nif it is invalid then we didn\\'t store it in our result,and we pop it from stack.\\nOtherwise we store it in our resut.*/\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(st.size()>0&&st.top().second==i)\\n            {\\n                st.pop();\\n                continue;\\n            }\\n            else\\n                result.push_back(s[i]);\\n        }\\n        \\n        reverse(result.begin(),result.end()); //At the end reverse the answer.\\n        return result; //return result \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324888,
                "title": "easy-and-fast-javascript-solution-faster-than-90",
                "content": "```javascript\\nvar minRemoveToMakeValid = function(s) {\\n  let result = [...s];\\n  let open = [];\\n  \\n  for (let i = 0; i < s.length; i++) {\\n    if (s[i] === \"(\") open.push(i);\\n    else if (s[i] === \")\") {\\n      if (open.length > 0) open.pop();\\n      else result[i] = \"\";\\n    }\\n  }\\n\\n  while (open.length > 0) result[open.pop()] = \"\";\\n  \\n  return result.join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar minRemoveToMakeValid = function(s) {\\n  let result = [...s];\\n  let open = [];\\n  \\n  for (let i = 0; i < s.length; i++) {\\n    if (s[i] === \"(\") open.push(i);\\n    else if (s[i] === \")\") {\\n      if (open.length > 0) open.pop();\\n      else result[i] = \"\";\\n    }\\n  }\\n\\n  while (open.length > 0) result[open.pop()] = \"\";\\n  \\n  return result.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1130925,
                "title": "simple-java-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        if(s.length() == 0 || s == null){\\n            return \"\";\\n        }\\n        StringBuilder sb = new StringBuilder(s);\\n        \\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i = 0; i < s.length(); ++i){\\n            \\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'(\\'){\\n                st.push(i);\\n            }else if(ch == \\')\\'){\\n                if(st.size() == 0){\\n                    st.push(i);\\n                }else{\\n                    if(s.charAt(st.peek()) == \\'(\\'){\\n                        st.pop();// this makes a pair of valid parenthesis\\n                    }else{\\n                        st.push(i); // this makes \"))\"\\n                    }\\n                }\\n            }\\n        }\\n        \\n        while(st.size() > 0){\\n            sb.deleteCharAt(st.pop()); // remove invalid at the indices\\n        }\\n        \\n        return sb.toString();\\n        \\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        if(s.length() == 0 || s == null){\\n            return \"\";\\n        }\\n        StringBuilder sb = new StringBuilder(s);\\n        \\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i = 0; i < s.length(); ++i){\\n            \\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'(\\'){\\n                st.push(i);\\n            }else if(ch == \\')\\'){\\n                if(st.size() == 0){\\n                    st.push(i);\\n                }else{\\n                    if(s.charAt(st.peek()) == \\'(\\'){\\n                        st.pop();// this makes a pair of valid parenthesis\\n                    }else{\\n                        st.push(i); // this makes \"))\"\\n                    }\\n                }\\n            }\\n        }\\n        \\n        while(st.size() > 0){\\n            sb.deleteCharAt(st.pop()); // remove invalid at the indices\\n        }\\n        \\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555511,
                "title": "c-solution-with-explanation-t-c-o-n-s-c-o-n-stack",
                "content": "# Intuition\\nJust guessing which bracket is wrongly placed makes the problem more difficult as it can be anywhere.\\n\\nSo basic intuition could be, finding the wrong bracket\\'s or we can say unwanted bracket\\'s indices in the string.\\n\\n# Approach\\nApproach is very similar to that of finding valid parenthesis.\\n\\nSuppose we have ( ( ) ( ( ) ) ) ) ) (.\\n\\nNow lets try to find valid parenthesis using stack : - \\n- ( - pushed , idx = 0\\n- ( - pushed , idx = 1\\n- ) - valid match as top of stack \\'(\\' ,so popped last \\'(\\', idx = 2\\n\\nwe can continue this way and at the end we would be having only unwanded bracket.\\n\\n\\nIf you find a pair, that is valid one else it is invalid.\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n    \\n        stack<pair<char,int>> st;\\n\\n        for(int i = 0 ; i  < s.length() ; i++){\\n            if(s[i]==\\'(\\'){\\n                st.push({s[i],i});\\n            }else if(s[i]==\\')\\'){\\n                if(!st.empty() && st.top().first==\\'(\\')st.pop();\\n                else st.push({s[i],i});\\n            }\\n        }\\n\\n        string str = \"\";\\n\\n        for(int i = s.length()-1; i>=0 ; i--){\\n            if(!st.empty() && st.top().second == i){\\n                st.pop();\\n                continue;\\n            }else str+=s[i];\\n            \\n        }\\n\\n        reverse(str.begin(),str.end());\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n    \\n        stack<pair<char,int>> st;\\n\\n        for(int i = 0 ; i  < s.length() ; i++){\\n            if(s[i]==\\'(\\'){\\n                st.push({s[i],i});\\n            }else if(s[i]==\\')\\'){\\n                if(!st.empty() && st.top().first==\\'(\\')st.pop();\\n                else st.push({s[i],i});\\n            }\\n        }\\n\\n        string str = \"\";\\n\\n        for(int i = s.length()-1; i>=0 ; i--){\\n            if(!st.empty() && st.top().second == i){\\n                st.pop();\\n                continue;\\n            }else str+=s[i];\\n            \\n        }\\n\\n        reverse(str.begin(),str.end());\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850450,
                "title": "c-no-stack-beginner-friendly-fastest",
                "content": "*you can shorter this code i have written in easiet way so that everyone can understand \\uD83D\\uDE0A*\\n```\\n1. Make a variable count \\n2. increase count everytime we get  \\'(\\' \\n3. decrease count everytime we get \\')\\'\\n4. if count == 0 and we get \\')\\' this means there is no opening bracket dont do anywork else store\\ncharacters\\n5. if extra opening are found we can handle it after this work by removing from last and\\n decreasing count\\n```\\n**CODE**\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int n = s.size();\\n        int cnt = 0;\\n        string ans = \"\";\\n        for(int i = 0 ; i < n ; i++){\\n\\t\\t\\n\\t\\t// if we get opening bracket increase count as we get same number of \\n\\t\\t// closing bracket in a valid \\n            if(s[i] == \\'(\\'){\\n                cnt++;\\n                ans += s[i];\\n            }\\n\\t\\t\\t\\n\\t\\t// we get closing bracket now there can be 2 cases if count is 0 which means there is no \\n\\t\\t// opening found then dont do any work\\n            else if(s[i] == \\')\\'){\\n                if(cnt == 0){\\n                    \\n                }\\n\\t\\t\\t\\t\\n\\t\\t// 2nd case when cnt > 0 then decrease count and add char to ans\\n                else{\\n                    cnt--;\\n                    ans += s[i];\\n                }\\n            }\\n\\t\\t\\t\\n\\t// else lowercase found\\n            else{\\n                ans += s[i];\\n            }\\n        }\\n    \\n\\t\\n\\t\\n\\t// this is case when count > 0 which means only opening found\\n\\t\\n\\t// like s = \"abc((\" then after upper loop we get ans = \"abc((\" and cnt == 2 now we have to do some work to \\n\\t// remove opening brackets according to count\\n        if(cnt > 0){\\n            for(int i = ans.size()-1 ; i >= 0 ; i--){\\n                if(ans[i] == \\'(\\' and cnt > 0){\\n                    cnt--;\\n                }\\n                else{\\n                    res += ans[i];\\n                }\\n            }\\n            reverse(res.begin(),res.end());\\n            return res;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n*just code no comments*\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int n = s.size();\\n        int cnt = 0;\\n        string ans = \"\";\\n        for(int i = 0 ; i < n ; i++){\\n            if(s[i] == \\'(\\'){\\n                cnt++;\\n                ans += s[i];\\n            }\\n            else if(s[i] == \\')\\'){\\n                if(cnt == 0){\\n                    \\n                }\\n                else{\\n                    cnt--;\\n                    ans += s[i];\\n                }\\n            }\\n            else{\\n                ans += s[i];\\n            }\\n        }\\n        \\n        if(cnt > 0){\\n            for(int i = ans.size()-1 ; i >= 0 ; i--){\\n                if(ans[i] == \\'(\\' and cnt > 0){\\n                    cnt--;\\n                }\\n                else{\\n                    res += ans[i];\\n                }\\n            }\\n            reverse(res.begin(),res.end());\\n            return res;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n1. Make a variable count \\n2. increase count everytime we get  \\'(\\' \\n3. decrease count everytime we get \\')\\'\\n4. if count == 0 and we get \\')\\' this means there is no opening bracket dont do anywork else store\\ncharacters\\n5. if extra opening are found we can handle it after this work by removing from last and\\n decreasing count\\n```\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int n = s.size();\\n        int cnt = 0;\\n        string ans = \"\";\\n        for(int i = 0 ; i < n ; i++){\\n\\t\\t\\n\\t\\t// if we get opening bracket increase count as we get same number of \\n\\t\\t// closing bracket in a valid \\n            if(s[i] == \\'(\\'){\\n                cnt++;\\n                ans += s[i];\\n            }\\n\\t\\t\\t\\n\\t\\t// we get closing bracket now there can be 2 cases if count is 0 which means there is no \\n\\t\\t// opening found then dont do any work\\n            else if(s[i] == \\')\\'){\\n                if(cnt == 0){\\n                    \\n                }\\n\\t\\t\\t\\t\\n\\t\\t// 2nd case when cnt > 0 then decrease count and add char to ans\\n                else{\\n                    cnt--;\\n                    ans += s[i];\\n                }\\n            }\\n\\t\\t\\t\\n\\t// else lowercase found\\n            else{\\n                ans += s[i];\\n            }\\n        }\\n    \\n\\t\\n\\t\\n\\t// this is case when count > 0 which means only opening found\\n\\t\\n\\t// like s = \"abc((\" then after upper loop we get ans = \"abc((\" and cnt == 2 now we have to do some work to \\n\\t// remove opening brackets according to count\\n        if(cnt > 0){\\n            for(int i = ans.size()-1 ; i >= 0 ; i--){\\n                if(ans[i] == \\'(\\' and cnt > 0){\\n                    cnt--;\\n                }\\n                else{\\n                    res += ans[i];\\n                }\\n            }\\n            reverse(res.begin(),res.end());\\n            return res;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int n = s.size();\\n        int cnt = 0;\\n        string ans = \"\";\\n        for(int i = 0 ; i < n ; i++){\\n            if(s[i] == \\'(\\'){\\n                cnt++;\\n                ans += s[i];\\n            }\\n            else if(s[i] == \\')\\'){\\n                if(cnt == 0){\\n                    \\n                }\\n                else{\\n                    cnt--;\\n                    ans += s[i];\\n                }\\n            }\\n            else{\\n                ans += s[i];\\n            }\\n        }\\n        \\n        if(cnt > 0){\\n            for(int i = ans.size()-1 ; i >= 0 ; i--){\\n                if(ans[i] == \\'(\\' and cnt > 0){\\n                    cnt--;\\n                }\\n                else{\\n                    res += ans[i];\\n                }\\n            }\\n            reverse(res.begin(),res.end());\\n            return res;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1527107,
                "title": "facebook-followup-without-using-stack",
                "content": "```\\n    # without stack\\n        s = list(s)\\n        count = 0\\n        for i, char in enumerate(s):\\n            if char == \\'(\\':\\n                count += 1\\n            elif char == \\')\\':\\n                if count: count -= 1\\n                else: s[i] = \\'\\'\\n        if count:\\n            for i in range(len(s)-1, -1, -1):\\n                if count and s[i] == \\'(\\':\\n                    s[i] = \\'\\'\\n                    count -= 1\\n                if not count: break\\n        return \\'\\'.join(s)\\n```",
                "solutionTags": [],
                "code": "```\\n    # without stack\\n        s = list(s)\\n        count = 0\\n        for i, char in enumerate(s):\\n            if char == \\'(\\':\\n                count += 1\\n            elif char == \\')\\':\\n                if count: count -= 1\\n                else: s[i] = \\'\\'\\n        if count:\\n            for i in range(len(s)-1, -1, -1):\\n                if count and s[i] == \\'(\\':\\n                    s[i] = \\'\\'\\n                    count -= 1\\n                if not count: break\\n        return \\'\\'.join(s)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1073530,
                "title": "c-array-based-less-than-2-pass-solution-explained-100-time-90-space",
                "content": "So, the problem of the valid parentheses is a classic declined in several variations - like this one that has filler characters - nothing too complex, but still a minor hindrance to consider.\\n\\nTo solve this problem, we will first of all declare a few support variables:\\n* `tmp` is an array of chars, with the same size of `s`;\\n* `p` will count how many parentheses we opened, while `pos` will be the pointer we will use to work on `tmp` - both will be set to `0`.\\n\\nIn our first pass through all the characters in the input string, we will have 3 base case:\\n* `c == \\'(\\'` will make it add to `tmp` (and increase `pos`), on top of increasing the dedicated `p` counter;\\n* `c == \\')\\'` will add the character to `tmp` only if `p > 0` and we will do nothing otherwise (ie: the character is ignored);\\n* we will add any other character to `tmp`.\\n\\nOnce done, we will have stored `pos` character to compose a new, filtered string; but we might also have potentially `p` open parentheses that need to be removed.\\n\\nTo do so, we will generate out result variable `res` to be `pos - p` characters long and then proceed to fill it from the right, always adding each character that is not an opened parentheses, decreasing `p` otherwise and actually adding `\\'(\\'` only after `p` is `<= 0` - meaning we got rid of the extra `p` open parentheses we collected before (whereas we can be sure that `tmp` will never have any extra closed parentheses).\\n\\nOnce done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        // support variables\\n        char tmp[s.size()];\\n        int p = 0, pos = 0;\\n        for (char c: s) {\\n            switch(c) {\\n                case \\'(\\':\\n                    p++;\\n                    tmp[pos++] = c;\\n                    break;\\n                case \\')\\':\\n                    // inserting closing parentheses only with p > 0\\n                    if (p > 0) {\\n                        p--;\\n                    }\\n                    else break;\\n                default:\\n                    tmp[pos++] = c;\\n            }\\n        }\\n        // properly sizing res\\n        string res(pos - p, \\'*\\');\\n        for (int i = pos - 1, j = pos - p - 1; i >= 0; i--) {\\n            if (tmp[i] != \\'(\\' || p-- <= 0) res[j--] = tmp[i];\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nWant to save even more memory? Okay, then overwrite directly `s`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        // support variables\\n        char tmp[s.size()];\\n        int p = 0, pos = 0;\\n        for (char c: s) {\\n            switch(c) {\\n                case \\'(\\':\\n                    p++;\\n                    tmp[pos++] = c;\\n                    break;\\n                case \\')\\':\\n                    // inserting closing parentheses only with p > 0\\n                    if (p > 0) {\\n                        p--;\\n                    }\\n                    else break;\\n                default:\\n                    tmp[pos++] = c;\\n            }\\n        }\\n        // properly sizing s\\n        s.resize(pos - p);\\n        for (int i = pos - 1, j = pos - p - 1; i >= 0; i--) {\\n            if (tmp[i] != \\'(\\' || p-- <= 0) s[j--] = tmp[i];\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        // support variables\\n        char tmp[s.size()];\\n        int p = 0, pos = 0;\\n        for (char c: s) {\\n            switch(c) {\\n                case \\'(\\':\\n                    p++;\\n                    tmp[pos++] = c;\\n                    break;\\n                case \\')\\':\\n                    // inserting closing parentheses only with p > 0\\n                    if (p > 0) {\\n                        p--;\\n                    }\\n                    else break;\\n                default:\\n                    tmp[pos++] = c;\\n            }\\n        }\\n        // properly sizing res\\n        string res(pos - p, \\'*\\');\\n        for (int i = pos - 1, j = pos - p - 1; i >= 0; i--) {\\n            if (tmp[i] != \\'(\\' || p-- <= 0) res[j--] = tmp[i];\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        // support variables\\n        char tmp[s.size()];\\n        int p = 0, pos = 0;\\n        for (char c: s) {\\n            switch(c) {\\n                case \\'(\\':\\n                    p++;\\n                    tmp[pos++] = c;\\n                    break;\\n                case \\')\\':\\n                    // inserting closing parentheses only with p > 0\\n                    if (p > 0) {\\n                        p--;\\n                    }\\n                    else break;\\n                default:\\n                    tmp[pos++] = c;\\n            }\\n        }\\n        // properly sizing s\\n        s.resize(pos - p);\\n        for (int i = pos - 1, j = pos - p - 1; i >= 0; i--) {\\n            if (tmp[i] != \\'(\\' || p-- <= 0) s[j--] = tmp[i];\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072812,
                "title": "detailed-c-solution-with-stack-and-without-stack-easy-to-understand",
                "content": "**Solution Without stack**\\n**iterative soultion ----->\\n==> if whenever the string is not valid we replace it with (*) so that we do not add that character to out result.\\n==> we do the above operation from left side and than right side and finally return the string.\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int cnt = 0;\\n        // starting from left to right \\n        // check if string is valid or not\\n        // if not valid replace * with string\\n        for(int i=0; i<s.size(); i++) {\\n            if(s[i] == \\'(\\') cnt++;\\n            else if(s[i] == \\')\\') {\\n                cnt--;\\n                if(cnt < 0) {\\n                    s[i] = \\'*\\';\\n                    cnt = 0;\\n                }\\n            }\\n        }\\n        \\n        cnt =  0;\\n        // starting from right to left\\n        for(int i=s.size()-1; i>=0; i--) {\\n            if(s[i] == \\')\\') cnt++;\\n            else if(s[i] == \\'(\\') {\\n                cnt--;\\n                if(cnt < 0) {\\n                    s[i] = \\'*\\';\\n                    cnt = 0;\\n                }\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i=0; i<s.size(); i++) {\\n            if(s[i] != \\'*\\') ans += s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Solution With Stack**\\n==>Push \\'(\\' into a stack and whenever \\')\\' appears in the string, try to pop \\'(\\' from stackif exists.\\n==> If \\'(\\' does not exist, then erase \\')\\' from string.\\n==> After parsing the entire string, erase extra \\'(\\' present in stack from string.\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack<int> box;\\n        int n = s.size();\\n        \\n        for(int i=0; i<n; i++) {\\n            if(s[i] == \\')\\'){\\n                if(!box.empty() && s[box.top()] == \\'(\\'){\\n                    box.pop();\\n                }else{\\n                    s.erase(i,1);\\n                    i--;\\n                }\\n            }\\n            else if(s[i] == \\'(\\'){\\n                box.push(i);\\n            }\\n        }\\n        \\n        while(!box.empty()) {\\n            s.erase(box.top(),1);\\n            box.pop();\\n        }\\n        \\n        return s;\\n    }\\n};\\n```\\n\\nupvote if u like",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int cnt = 0;\\n        // starting from left to right \\n        // check if string is valid or not\\n        // if not valid replace * with string\\n        for(int i=0; i<s.size(); i++) {\\n            if(s[i] == \\'(\\') cnt++;\\n            else if(s[i] == \\')\\') {\\n                cnt--;\\n                if(cnt < 0) {\\n                    s[i] = \\'*\\';\\n                    cnt = 0;\\n                }\\n            }\\n        }\\n        \\n        cnt =  0;\\n        // starting from right to left\\n        for(int i=s.size()-1; i>=0; i--) {\\n            if(s[i] == \\')\\') cnt++;\\n            else if(s[i] == \\'(\\') {\\n                cnt--;\\n                if(cnt < 0) {\\n                    s[i] = \\'*\\';\\n                    cnt = 0;\\n                }\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i=0; i<s.size(); i++) {\\n            if(s[i] != \\'*\\') ans += s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack<int> box;\\n        int n = s.size();\\n        \\n        for(int i=0; i<n; i++) {\\n            if(s[i] == \\')\\'){\\n                if(!box.empty() && s[box.top()] == \\'(\\'){\\n                    box.pop();\\n                }else{\\n                    s.erase(i,1);\\n                    i--;\\n                }\\n            }\\n            else if(s[i] == \\'(\\'){\\n                box.push(i);\\n            }\\n        }\\n        \\n        while(!box.empty()) {\\n            s.erase(box.top(),1);\\n            box.pop();\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833414,
                "title": "general-parantheses-problem-python-interview-prep",
                "content": "1249. Minimum Remove to Make Valid Parentheses\\nhttps://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/\\n\\n```\\nclass Solution(object):\\n    def minRemoveToMakeValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        stack =[]\\n        \\n        s =list(s)\\n        for i, char in enumerate(s):\\n            if char == \"(\":\\n                stack.append(i)\\n            else:\\n                if char == \")\":\\n                    if stack:\\n                        stack.pop()\\n                    else:\\n                        s[i] = \"\"\\n        \\n        while stack:\\n            s[stack.pop()] = \"\" \\n        return \"\".join(s)\\n```\\n\\n921. Minimum Add to Make Parentheses Valid\\nhttps://leetcode.com/problems/minimum-add-to-make-parentheses-valid/\\n\\n```\\nclass Solution(object):\\n    def minAddToMakeValid(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        stack =[]\\n        for i in S:\\n            if i==\"(\":\\n                stack.append(i)\\n            \\n            else:\\n                if i == \")\":\\n                    \\n                    if stack and stack[-1]==\"(\":\\n                        stack.pop()\\n                    else:\\n                        stack.append(i)\\n        \\n        return len(stack)\\n```\\n\\n20. Valid Parentheses\\nhttps://leetcode.com/problems/valid-parentheses/\\n\\n```\\nclass Solution(object):\\n    def isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        dic ={\"{\":\"}\",\\n              \"[\":\"]\",\\n              \"(\":\")\"}\\n                \\n        stack = []\\n        \\n        for i in s:\\n            if i in dic:\\n                stack.append(i)\\n                \\n            # if there is input as \"]\", then we need to \\n            # check the if the length of stack is empty or not.\\n            elif len(stack) == 0 or dic[stack.pop()]!=i:\\n                    return False\\n        return len(stack)==0\\n```\\n\\n32. Longest Valid Parentheses\\nhttps://leetcode.com/problems/longest-valid-parentheses/\\n```\\nclass Solution(object):\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        stack =[]\\n        \\n        cur_long = 0\\n        max_long = 0\\n        \\n        for i in s:\\n            if i == \"(\":\\n                stack.append(cur_long)\\n                cur_long =0\\n            else:\\n                if stack:\\n                    cur_long += stack.pop() + 2\\n                    max_long = max(cur_long, max_long)\\n                else:\\n                    cur_long = 0\\n        \\n        return max_long\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minRemoveToMakeValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        stack =[]\\n        \\n        s =list(s)\\n        for i, char in enumerate(s):\\n            if char == \"(\":\\n                stack.append(i)\\n            else:\\n                if char == \")\":\\n                    if stack:\\n                        stack.pop()\\n                    else:\\n                        s[i] = \"\"\\n        \\n        while stack:\\n            s[stack.pop()] = \"\" \\n        return \"\".join(s)\\n```\n```\\nclass Solution(object):\\n    def minAddToMakeValid(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        stack =[]\\n        for i in S:\\n            if i==\"(\":\\n                stack.append(i)\\n            \\n            else:\\n                if i == \")\":\\n                    \\n                    if stack and stack[-1]==\"(\":\\n                        stack.pop()\\n                    else:\\n                        stack.append(i)\\n        \\n        return len(stack)\\n```\n```\\nclass Solution(object):\\n    def isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        dic ={\"{\":\"}\",\\n              \"[\":\"]\",\\n              \"(\":\")\"}\\n                \\n        stack = []\\n        \\n        for i in s:\\n            if i in dic:\\n                stack.append(i)\\n                \\n            # if there is input as \"]\", then we need to \\n            # check the if the length of stack is empty or not.\\n            elif len(stack) == 0 or dic[stack.pop()]!=i:\\n                    return False\\n        return len(stack)==0\\n```\n```\\nclass Solution(object):\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        stack =[]\\n        \\n        cur_long = 0\\n        max_long = 0\\n        \\n        for i in s:\\n            if i == \"(\":\\n                stack.append(cur_long)\\n                cur_long =0\\n            else:\\n                if stack:\\n                    cur_long += stack.pop() + 2\\n                    max_long = max(cur_long, max_long)\\n                else:\\n                    cur_long = 0\\n        \\n        return max_long\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524168,
                "title": "go-stack",
                "content": "https://github.com/iamslash/learntocode/blob/master/leetcode/MinimumRemovetoMakeValidParentheses/a.go\\n\\n```\\n// 4ms 98.97% 6MB 100.00%\\n// stack\\n// O(N) O(N)\\nfunc minRemoveToMakeValid(s string) string {\\n\\tstck := []int{}\\n\\tbs := []byte(s)\\n\\tfor i, b := range bs {\\n\\t\\tif b == \\'(\\' {\\n\\t\\t\\tstck = append(stck, i)\\n\\t\\t} else if b == \\')\\' {\\n\\t\\t\\tif len(stck) > 0 {\\n\\t\\t\\t\\tstck = stck[:len(stck)-1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbs[i] = \\'*\\'\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor len(stck) > 0 {\\n\\t\\tbs[stck[len(stck)-1]] = \\'*\\'\\n\\t\\tstck = stck[:len(stck)-1]\\n\\t}\\n\\treturn strings.ReplaceAll(string(bs), \"*\", \"\")\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// 4ms 98.97% 6MB 100.00%\\n// stack\\n// O(N) O(N)\\nfunc minRemoveToMakeValid(s string) string {\\n\\tstck := []int{}\\n\\tbs := []byte(s)\\n\\tfor i, b := range bs {\\n\\t\\tif b == \\'(\\' {\\n\\t\\t\\tstck = append(stck, i)\\n\\t\\t} else if b == \\')\\' {\\n\\t\\t\\tif len(stck) > 0 {\\n\\t\\t\\t\\tstck = stck[:len(stck)-1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbs[i] = \\'*\\'\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor len(stck) > 0 {\\n\\t\\tbs[stck[len(stck)-1]] = \\'*\\'\\n\\t\\tstck = stck[:len(stck)-1]\\n\\t}\\n\\treturn strings.ReplaceAll(string(bs), \"*\", \"\")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 470413,
                "title": "no-stack-no-hashmap-two-pass-solution-python",
                "content": "```\\nclass Solution(object):\\n    def minRemoveToMakeValid(self, s):   \\n        out = []\\n        left, right = 0,0\\n        include = [True] * len(s)\\n        for i in range(len(s)):\\n            if s[i] ==\\'(\\':\\n                left = left + 1\\n            elif s[i] ==\\')\\':\\n                right = right + 1\\n                \\n            if(right>left):\\n                left,right = 0,0\\n                include[i] = False\\n        \\n        left, right = 0,0\\n        for i in range(len(s)-1,-1,-1):\\n            if s[i] ==\\'(\\':\\n                left = left + 1\\n            elif s[i] ==\\')\\':\\n                right = right + 1\\n                \\n            if(left>right):\\n                left,right = 0,0\\n                include[i] = False\\n                 \\n            if include[i]==True:\\n                out.append(s[i])\\n       \\n\\t   \\n        return reversed(out)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minRemoveToMakeValid(self, s):   \\n        out = []\\n        left, right = 0,0\\n        include = [True] * len(s)\\n        for i in range(len(s)):\\n            if s[i] ==\\'(\\':\\n                left = left + 1\\n            elif s[i] ==\\')\\':\\n                right = right + 1\\n                \\n            if(right>left):\\n                left,right = 0,0\\n                include[i] = False\\n        \\n        left, right = 0,0\\n        for i in range(len(s)-1,-1,-1):\\n            if s[i] ==\\'(\\':\\n                left = left + 1\\n            elif s[i] ==\\')\\':\\n                right = right + 1\\n                \\n            if(left>right):\\n                left,right = 0,0\\n                include[i] = False\\n                 \\n            if include[i]==True:\\n                out.append(s[i])\\n       \\n\\t   \\n        return reversed(out)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455641,
                "title": "9-line-simple-c-solution-no-stack-no-deque",
                "content": "Please ***upvote*** if you find the code helpful!!!\\nThis solution is sort of a simili to a stack, but I am not using stack here.\\n```\\n// Without explanation -- for those who want to copy-paste my solution ;)\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int C = 0; string ans; vector<char> hehe;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'(\\') { C++; hehe.push_back(s[i]); } \\n            else if (s[i] == \\')\\') {if (C > 0) { C--; hehe.push_back(s[i]); }}\\n            else hehe.push_back(s[i]); \\n        }\\n        if (C > 0) for (int i = hehe.size() - 1; i >= 0; i--) if (hehe[i] == \\'(\\') { hehe.erase(hehe.begin() + i); C--; if (C == 0) break; }\\n        for (int i = 0; i < hehe.size(); i++) ans += hehe[i];\\n        return ans;\\n    }\\n};\\n```\\n```\\n// With explanation\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n\\t\\t// Defining the variables\\n        int C = 0; string ans; vector<char> hehe;\\n        for (int i = 0; i < s.size(); i++) {\\n\\t\\t\\t // add a \\'(\\' every time we encounter one\\n            if (s[i] == \\'(\\') { C++; hehe.push_back(s[i]); }\\n\\t\\t\\t// make sure that the number of \\'(\\' is equal to the number of \\')\\'; if there are more \\')\\' than \\'(\\', skip\\n            else if (s[i] == \\')\\') {if (C > 0) { C--; hehe.push_back(s[i]); }}\\n            // if char is a lowercase letter just add the letter\\n\\t\\t\\telse hehe.push_back(s[i]);\\n        }\\n\\t\\t// If there are more \\'(\\' than \\')\\' at the end, delete the \\'(\\' from right to left\\n\\t\\t// until when the number of \\'(\\' is equal to the number of \\')\\' (i.e. when C == 0)\\n        if (C > 0) for (int i = hehe.size() - 1; i >= 0; i--) if (hehe[i] == \\'(\\') { hehe.erase(hehe.begin() + i); C--; if (C == 0) break; }\\n\\t\\t// Add the remaining chars in the answer since we need to return a string\\n        for (int i = 0; i < hehe.size(); i++) ans += hehe[i];\\n\\t\\t// Return da answer!\\n        return ans;\\n    }\\n};\\n```\\n```\\n// Readable Version With explanation\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n\\t\\t// Defining the variables\\n        int C = 0;\\n        string ans;\\n        vector<char> hehe;\\n        for (int i = 0; i < s.size(); i++) {\\n\\t\\t\\t// add a \\'(\\' every time we encounter one\\n            if (s[i] == \\'(\\') {\\n                C++;\\n                hehe.push_back(s[i]);\\n            }\\n\\t\\t\\t// make sure that the number of \\'(\\' is equal to the number of \\')\\'; if there are more \\')\\' than \\'(\\', skip\\n            else if (s[i] == \\')\\') {\\n                if (C > 0) {\\n                    C--;\\n                    hehe.push_back(s[i]);\\n                }\\n            }\\n\\t\\t\\t// if char is a lowercase letter just add the letter\\n            else hehe.push_back(s[i]);\\n        }\\n\\t\\t// If there are more \\'(\\' than \\')\\' at the end, delete the \\'(\\' from right to left\\n\\t\\t// until when the number of \\'(\\' is equal to the number of \\')\\' (i.e. when C == 0)\\n        if (C > 0) {\\n            for (int i = hehe.size() - 1; i >= 0; i--) {\\n                if (hehe[i] == \\'(\\') {\\n                    hehe.erase(hehe.begin() + i); C--;\\n                    if (C == 0) break;\\n                }\\n            }\\n        }\\n\\t\\t// Add the remaining chars in the answer since we need to return a string\\n        for (int i = 0; i < hehe.size(); i++) ans += hehe[i];\\n\\t\\t// Return da answer!\\n        return ans;\\n    }\\n};\\n```\\nPlease ***upvote*** if you find the code helpful!!!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Without explanation -- for those who want to copy-paste my solution ;)\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int C = 0; string ans; vector<char> hehe;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'(\\') { C++; hehe.push_back(s[i]); } \\n            else if (s[i] == \\')\\') {if (C > 0) { C--; hehe.push_back(s[i]); }}\\n            else hehe.push_back(s[i]); \\n        }\\n        if (C > 0) for (int i = hehe.size() - 1; i >= 0; i--) if (hehe[i] == \\'(\\') { hehe.erase(hehe.begin() + i); C--; if (C == 0) break; }\\n        for (int i = 0; i < hehe.size(); i++) ans += hehe[i];\\n        return ans;\\n    }\\n};\\n```\n```\\n// With explanation\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n\\t\\t// Defining the variables\\n        int C = 0; string ans; vector<char> hehe;\\n        for (int i = 0; i < s.size(); i++) {\\n\\t\\t\\t // add a \\'(\\' every time we encounter one\\n            if (s[i] == \\'(\\') { C++; hehe.push_back(s[i]); }\\n\\t\\t\\t// make sure that the number of \\'(\\' is equal to the number of \\')\\'; if there are more \\')\\' than \\'(\\', skip\\n            else if (s[i] == \\')\\') {if (C > 0) { C--; hehe.push_back(s[i]); }}\\n            // if char is a lowercase letter just add the letter\\n\\t\\t\\telse hehe.push_back(s[i]);\\n        }\\n\\t\\t// If there are more \\'(\\' than \\')\\' at the end, delete the \\'(\\' from right to left\\n\\t\\t// until when the number of \\'(\\' is equal to the number of \\')\\' (i.e. when C == 0)\\n        if (C > 0) for (int i = hehe.size() - 1; i >= 0; i--) if (hehe[i] == \\'(\\') { hehe.erase(hehe.begin() + i); C--; if (C == 0) break; }\\n\\t\\t// Add the remaining chars in the answer since we need to return a string\\n        for (int i = 0; i < hehe.size(); i++) ans += hehe[i];\\n\\t\\t// Return da answer!\\n        return ans;\\n    }\\n};\\n```\n```\\n// Readable Version With explanation\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n\\t\\t// Defining the variables\\n        int C = 0;\\n        string ans;\\n        vector<char> hehe;\\n        for (int i = 0; i < s.size(); i++) {\\n\\t\\t\\t// add a \\'(\\' every time we encounter one\\n            if (s[i] == \\'(\\') {\\n                C++;\\n                hehe.push_back(s[i]);\\n            }\\n\\t\\t\\t// make sure that the number of \\'(\\' is equal to the number of \\')\\'; if there are more \\')\\' than \\'(\\', skip\\n            else if (s[i] == \\')\\') {\\n                if (C > 0) {\\n                    C--;\\n                    hehe.push_back(s[i]);\\n                }\\n            }\\n\\t\\t\\t// if char is a lowercase letter just add the letter\\n            else hehe.push_back(s[i]);\\n        }\\n\\t\\t// If there are more \\'(\\' than \\')\\' at the end, delete the \\'(\\' from right to left\\n\\t\\t// until when the number of \\'(\\' is equal to the number of \\')\\' (i.e. when C == 0)\\n        if (C > 0) {\\n            for (int i = hehe.size() - 1; i >= 0; i--) {\\n                if (hehe[i] == \\'(\\') {\\n                    hehe.erase(hehe.begin() + i); C--;\\n                    if (C == 0) break;\\n                }\\n            }\\n        }\\n\\t\\t// Add the remaining chars in the answer since we need to return a string\\n        for (int i = 0; i < hehe.size(); i++) ans += hehe[i];\\n\\t\\t// Return da answer!\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046302,
                "title": "python-easy-understanding",
                "content": "2 arrays to store the 1) index of `(` and 2) charactors of `str`\\n```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n\\t\\tstack = []\\n        res = []\\n        for i,v in enumerate(s):\\n            res.append(v)  # save the charactors to final resutls\\n            if v == \\'(\\':\\n                stack.append(i) # always save left \\'(\\' index, to decided if this need to remove or not \\n            if v == \\')\\':\\n                if stack:\\n                    stack.pop() # as stack saved left \\'(\\', so here is good to pop one no matter the index value, just pop the left as a pair\\n                else:\\n                    res[-1] = \\'\\'  # as stack is empty, now we see additional right \\')\\', need replace res[-1] with a empty str, \\n\\t\\t\\t\\t\\t                    # why not pop out? \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# if we do pop, once we loop to the end of the string\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# if we still have some  left \\'(\\' in stack, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# while we do replace array value, it may mess up. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# here, we need keep our res index consistent with the original str \\'s\\'.\\n\\t\\t\\n\\t\\t# if we have some left \\'(\\' index stack, which means not paired ones, let\\'s remove these ones\\n        while stack:\\n            res[stack.pop()] = \\'\\'\\n\\t\\t\\n        return \"\".join(res)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "2 arrays to store the 1) index of `(` and 2) charactors of `str`\\n```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n\\t\\tstack = []\\n        res = []\\n        for i,v in enumerate(s):\\n            res.append(v)  # save the charactors to final resutls\\n            if v == \\'(\\':\\n                stack.append(i) # always save left \\'(\\' index, to decided if this need to remove or not \\n            if v == \\')\\':\\n                if stack:\\n                    stack.pop() # as stack saved left \\'(\\', so here is good to pop one no matter the index value, just pop the left as a pair\\n                else:\\n                    res[-1] = \\'\\'  # as stack is empty, now we see additional right \\')\\', need replace res[-1] with a empty str, \\n\\t\\t\\t\\t\\t                    # why not pop out? \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# if we do pop, once we loop to the end of the string\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# if we still have some  left \\'(\\' in stack, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# while we do replace array value, it may mess up. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# here, we need keep our res index consistent with the original str \\'s\\'.\\n\\t\\t\\n\\t\\t# if we have some left \\'(\\' index stack, which means not paired ones, let\\'s remove these ones\\n        while stack:\\n            res[stack.pop()] = \\'\\'\\n\\t\\t\\n        return \"\".join(res)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1958001,
                "title": "c-sharing-my-o-1-space-complexity",
                "content": "The ideia here it\\'s to do all the operations in-place of the string `s`. \\n\\nLet\\'s divide the problem in three steps:\\n\\t1.  Mark all the extra closing parenthesis to be removed in the future, changing the values to a space.\\n\\t2.  Mark all the extra opening parenthesis to be remover in the future, changing the values to a space.\\n\\t3.  Erase the spaces in the string `s`, moving the non-space chars to the left.\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    void removeInvalid(string &s, char open, char close)\\n    {\\n        int count = 0;\\n\\n        for (auto &curr : s)\\n        {\\n            if (curr == open)\\n                count++;\\n            else if (curr != close)\\n                continue;\\n            else if (count == 0)\\n                curr = \\' \\';\\n            else\\n                count--;\\n        }\\n    }\\npublic:\\n    string& minRemoveToMakeValid(string &s) {\\n        //\"Removing\" the extra closing parenthesis.\\n        removeInvalid(s, \\'(\\', \\')\\');\\n        reverse(s.begin(), s.end());\\n\\n        //\"Removing\" the extra opening parenthesis.\\n        removeInvalid(s, \\')\\', \\'(\\');\\n        reverse(s.begin(), s.end());\\n\\n        //Removing the extra spaces in the string\\n        int lastIndex = 0;\\n        for (auto curr : s)\\n            if (curr != \\' \\')\\n                s[lastIndex++] = curr;\\n\\n        //Removing the extra chars remaing in the end\\n        s.resize(lastIndex);\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    void removeInvalid(string &s, char open, char close)\\n    {\\n        int count = 0;\\n\\n        for (auto &curr : s)\\n        {\\n            if (curr == open)\\n                count++;\\n            else if (curr != close)\\n                continue;\\n            else if (count == 0)\\n                curr = \\' \\';\\n            else\\n                count--;\\n        }\\n    }\\npublic:\\n    string& minRemoveToMakeValid(string &s) {\\n        //\"Removing\" the extra closing parenthesis.\\n        removeInvalid(s, \\'(\\', \\')\\');\\n        reverse(s.begin(), s.end());\\n\\n        //\"Removing\" the extra opening parenthesis.\\n        removeInvalid(s, \\')\\', \\'(\\');\\n        reverse(s.begin(), s.end());\\n\\n        //Removing the extra spaces in the string\\n        int lastIndex = 0;\\n        for (auto curr : s)\\n            if (curr != \\' \\')\\n                s[lastIndex++] = curr;\\n\\n        //Removing the extra chars remaing in the end\\n        s.resize(lastIndex);\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851915,
                "title": "stack-solution-using-python-intuition-code-easy-to-understand",
                "content": "# Intuition:\\n![image](https://assets.leetcode.com/users/images/1a1c38c9-f5fd-4d81-aad7-0b293d81f385_1647353741.1133804.jpeg)\\n\\n**Solution:**\\n```\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        string = list(s)\\n        stack = []\\n        for i in range(len(string)):\\n            if string[i] == \\'(\\':\\n                stack.append((\\'(\\',i))\\n            elif string[i] == \\')\\':\\n                if stack:\\n                    stack.pop()\\n                else:\\n                    string[i] = \"\"\\n        for i in range(len(stack)):\\n            string[stack[i][1]] = \"\"\\n            \\n        return \"\".join(string)\\n```\\n\\n- Hope you find this helpful. Feel free to comment your approachs and intuition.\\n",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        string = list(s)\\n        stack = []\\n        for i in range(len(string)):\\n            if string[i] == \\'(\\':\\n                stack.append((\\'(\\',i))\\n            elif string[i] == \\')\\':\\n                if stack:\\n                    stack.pop()\\n                else:\\n                    string[i] = \"\"\\n        for i in range(len(stack)):\\n            string[stack[i][1]] = \"\"\\n            \\n        return \"\".join(string)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1850854,
                "title": "1249-c-easy-o-n-solution-with-explanation",
                "content": "**Please upvote if you find this solution helpful :)**\\n\\n**Algorithm:**\\n* initialize count = 0 and result string\\n\\n**Start traversing from beginning**\\n* if we find open parenthesis then we increase the count by 1 that helps in find valid pair.\\n* if we find close parenthesis there may be 2 cases.\\n* \\tif count==0 it means there is no open parenthesis and this close parenthesis is invalid so we replace s[i] with \\'_\\'.\\n* \\telse decrease the count by 1 because we find one valid pair.\\n\\nNow, again initialze count = 0\\n\\n**and start traversing from the end.**\\n* \\tif we find close parenthesis then we increase the count by 1that helps in find valid pair.\\n* \\tif we find open parenthesis there may be 2 cases.\\n* \\tif count==0 it means this open parenthesis is invalid so we replace s[i] with \\'_\\'.\\n* \\telse decrease the count by 1 becuase we find valid pair.\\n\\t\\t\\n\\t\\t\\n**Now, we again traverse through string from beginning and if s[i] != \\'_ \\' we put that char into the result string.**\\n\\n**Time Complexity - O(N)\\nSpace Complexity - O(1).**\\n\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) \\n    {\\n        string res = \"\";\\n        int n = s.size(), count = 0;\\n        \\n        //iterate from beginning\\n        for(int i=0; i<n; i++)\\n        {\\n            //if get \\'(\\' increase count by 1\\n            if(s[i] == \\'(\\')\\n                count++;\\n            \\n            else if(s[i] == \\')\\')\\n            {\\n                // if count=0 replace \\')\\' with \\'_\\'\\n                if(count==0)\\n                    s[i] = \\'_\\';\\n                \\n                else \\n                    count--;\\n            }\\n        }\\n        \\n        count = 0;\\n        //Now iterate from end\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            //if get \\')\\' increase count by 1\\n            if(s[i] == \\')\\')\\n                count++;\\n            \\n            else if(s[i] == \\'(\\')\\n            {\\n                //if count=0 replace \\'(\\' with \\'_\\'\\n                if(count==0)\\n                    s[i] = \\'_\\';\\n                else \\n                    count--;\\n            }\\n        }\\n        \\n        //add all the char into res string except \\'_\\'\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i] != \\'_\\')\\n            {\\n                res.push_back(s[i]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n\\n**Please upvote if you find this solution helpful :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) \\n    {\\n        string res = \"\";\\n        int n = s.size(), count = 0;\\n        \\n        //iterate from beginning\\n        for(int i=0; i<n; i++)\\n        {\\n            //if get \\'(\\' increase count by 1\\n            if(s[i] == \\'(\\')\\n                count++;\\n            \\n            else if(s[i] == \\')\\')\\n            {\\n                // if count=0 replace \\')\\' with \\'_\\'\\n                if(count==0)\\n                    s[i] = \\'_\\';\\n                \\n                else \\n                    count--;\\n            }\\n        }\\n        \\n        count = 0;\\n        //Now iterate from end\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            //if get \\')\\' increase count by 1\\n            if(s[i] == \\')\\')\\n                count++;\\n            \\n            else if(s[i] == \\'(\\')\\n            {\\n                //if count=0 replace \\'(\\' with \\'_\\'\\n                if(count==0)\\n                    s[i] = \\'_\\';\\n                else \\n                    count--;\\n            }\\n        }\\n        \\n        //add all the char into res string except \\'_\\'\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i] != \\'_\\')\\n            {\\n                res.push_back(s[i]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850429,
                "title": "python-simple-python-solution-using-stack-and-iterative-approach",
                "content": "# If It is Useful to Understand Please Upvote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n\\tclass Solution:\\n\\t\\tdef minRemoveToMakeValid(self, s: str) -> str:\\n\\n\\t\\t\\ts=list(s)\\n\\n\\t\\t\\tstack = []\\n\\n\\t\\t\\tfor i in range(len(s)):\\n\\n\\t\\t\\t\\tif s[i]==\\'(\\':\\n\\n\\t\\t\\t\\t\\tstack.append(i)\\n\\n\\t\\t\\t\\telif s[i]==\\')\\':\\n\\n\\t\\t\\t\\t\\tif len(stack)>0:\\n\\n\\t\\t\\t\\t\\t\\tstack.pop()\\n\\n\\t\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\t\\ts[i] = \\'\\'\\n\\n\\t\\t\\twhile len(stack)>0:\\n\\n\\t\\t\\t\\ts[stack[-1]]=\\'\\'\\n\\n\\t\\t\\t\\tstack.pop()\\n\\n\\t\\t\\treturn \\'\\'.join(s)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "# If It is Useful to Understand Please Upvote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n\\tclass Solution:\\n\\t\\tdef minRemoveToMakeValid(self, s: str) -> str:\\n\\n\\t\\t\\ts=list(s)\\n\\n\\t\\t\\tstack = []\\n\\n\\t\\t\\tfor i in range(len(s)):\\n\\n\\t\\t\\t\\tif s[i]==\\'(\\':\\n\\n\\t\\t\\t\\t\\tstack.append(i)\\n\\n\\t\\t\\t\\telif s[i]==\\')\\':\\n\\n\\t\\t\\t\\t\\tif len(stack)>0:\\n\\n\\t\\t\\t\\t\\t\\tstack.pop()\\n\\n\\t\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\t\\ts[i] = \\'\\'\\n\\n\\t\\t\\twhile len(stack)>0:\\n\\n\\t\\t\\t\\ts[stack[-1]]=\\'\\'\\n\\n\\t\\t\\t\\tstack.pop()\\n\\n\\t\\t\\treturn \\'\\'.join(s)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1740893,
                "title": "c-without-using-stack-easy-to-understand",
                "content": "**Intution**\\n **1.** Add closing bracket to answer string when count of open bracket is greater than closing bracket.\\n **2.** Remove the extra open bracket from the answer string.\\n  \\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        string ans=\"\";                                        // Create Empty string to store characters \\n        int c1=0;                                              // store Count of open brackets\\n        int c2=0;                                             //Store count of closing bracket\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                c1++;\\n                ans+=s[i];\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                if(c1>c2)      //Adding closing bracket to asnwer string when count of opening bracket greater than the closing bracket\\n                {\\n                    ans+=s[i];\\n                    c2++;\\n                }\\n            }\\n            else{\\n                ans+=s[i];\\n            }\\n        }\\n\\t\\t/* Answer string may contain extra open brackets so we have to remove the extra open brackets*/\\n        string p=\"\";              \\n        c1=0;\\n        for(int i=0;i<ans.size();i++)        //For Example answer string may be ans=\"(a(a(b)vd)\"\\n        {\\n               if(ans[i]==\\'(\\' && c1<c2)      // Add only c2 no. of open brackets to the final string\\n               {\\n                   p+=ans[i];\\n                   c1++;\\n               }\\n               else if(ans[i]!=\\'(\\')\\n               {\\n                   p+=ans[i];\\n               }\\n               \\n        }\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        string ans=\"\";                                        // Create Empty string to store characters \\n        int c1=0;                                              // store Count of open brackets\\n        int c2=0;                                             //Store count of closing bracket\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                c1++;\\n                ans+=s[i];\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                if(c1>c2)      //Adding closing bracket to asnwer string when count of opening bracket greater than the closing bracket\\n                {\\n                    ans+=s[i];\\n                    c2++;\\n                }\\n            }\\n            else{\\n                ans+=s[i];\\n            }\\n        }\\n\\t\\t/* Answer string may contain extra open brackets so we have to remove the extra open brackets*/\\n        string p=\"\";              \\n        c1=0;\\n        for(int i=0;i<ans.size();i++)        //For Example answer string may be ans=\"(a(a(b)vd)\"\\n        {\\n               if(ans[i]==\\'(\\' && c1<c2)      // Add only c2 no. of open brackets to the final string\\n               {\\n                   p+=ans[i];\\n                   c1++;\\n               }\\n               else if(ans[i]!=\\'(\\')\\n               {\\n                   p+=ans[i];\\n               }\\n               \\n        }\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662000,
                "title": "c-stack-o-n",
                "content": "```\\nstring minRemoveToMakeValid(string s) {\\n\\tstack<int> st;\\n\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\tif (s[i] == \\'(\\') {\\n\\t\\t\\tst.push(i);\\n\\t\\t} else if (s[i] == \\')\\') {\\n\\t\\t\\tif (!st.empty())\\n\\t\\t\\t\\tst.pop();\\n\\t\\t\\telse\\n\\t\\t\\t\\ts[i] = \\'*\\';\\n\\t\\t}\\n\\t}\\n\\n\\twhile (!st.empty()) {\\n\\t\\ts[st.top()] = \\'*\\';\\n\\t\\tst.pop();\\n\\t}\\n\\n\\tstring ans;\\n\\tfor (auto ch : s) {\\n\\t\\tif (ch != \\'*\\') {\\n\\t\\t\\tans += ch;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nstring minRemoveToMakeValid(string s) {\\n\\tstack<int> st;\\n\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\tif (s[i] == \\'(\\') {\\n\\t\\t\\tst.push(i);\\n\\t\\t} else if (s[i] == \\')\\') {\\n\\t\\t\\tif (!st.empty())\\n\\t\\t\\t\\tst.pop();\\n\\t\\t\\telse\\n\\t\\t\\t\\ts[i] = \\'*\\';\\n\\t\\t}\\n\\t}\\n\\n\\twhile (!st.empty()) {\\n\\t\\ts[st.top()] = \\'*\\';\\n\\t\\tst.pop();\\n\\t}\\n\\n\\tstring ans;\\n\\tfor (auto ch : s) {\\n\\t\\tif (ch != \\'*\\') {\\n\\t\\t\\tans += ch;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1291344,
                "title": "fastest-solution-in-python-using-stack-easy",
                "content": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        s= list(s)\\n        stack= []\\n        \\n        \\n        for i in range(len(s)):\\n            \\n            if s[i]==\\'(\\':\\n                stack.append(i)\\n            elif s[i]==\\')\\':\\n                \\n                if stack:\\n                    stack.pop()\\n                else:\\n                    s[i]=\\'\\'\\n                    \\n        for i in stack:\\n            s[i]=\\'\\'\\n            \\n        return \\'\\'.join(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        s= list(s)\\n        stack= []\\n        \\n        \\n        for i in range(len(s)):\\n            \\n            if s[i]==\\'(\\':\\n                stack.append(i)\\n            elif s[i]==\\')\\':\\n                \\n                if stack:\\n                    stack.pop()\\n                else:\\n                    s[i]=\\'\\'\\n                    \\n        for i in stack:\\n            s[i]=\\'\\'\\n            \\n        return \\'\\'.join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072667,
                "title": "python-minimum-remove-to-make-valid-parentheses-solution-easy-way",
                "content": "Easy if else conditions\\n\\n```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        s = list(s)\\n        left_parr = 0\\n        left_ind = []\\n        for i in range(len(s)):\\n            if s[i] == \\')\\' and left_parr == 0:\\n                s[i] = \\'\\'\\n            elif s[i] == \\'(\\':\\n                left_parr += 1\\n                left_ind.append(i)\\n            elif s[i] == \\')\\' and left_parr > 0:\\n                left_parr -= 1\\n                left_ind.pop()\\n\\n        if len(left_ind) > 0:\\n            for j in left_ind:\\n                s[j] = \\'\\'\\n\\n        return \\'\\'.join(s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        s = list(s)\\n        left_parr = 0\\n        left_ind = []\\n        for i in range(len(s)):\\n            if s[i] == \\')\\' and left_parr == 0:\\n                s[i] = \\'\\'\\n            elif s[i] == \\'(\\':\\n                left_parr += 1\\n                left_ind.append(i)\\n            elif s[i] == \\')\\' and left_parr > 0:\\n                left_parr -= 1\\n                left_ind.pop()\\n\\n        if len(left_ind) > 0:\\n            for j in left_ind:\\n                s[j] = \\'\\'\\n\\n        return \\'\\'.join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028172,
                "title": "c-solution-faster-than-98-using-stack",
                "content": "```\\n string minRemoveToMakeValid(string s) \\n    {\\n        stack<int >st;   // stack to store the index to each paranthesis\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(i);\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                if(!st.empty())\\n                    st.pop();\\n                else\\n                    s[i]=\\'@\\';\\n            }\\n        }\\n        while(!st.empty())   \\n        {\\n            int temp=st.top(); st.pop();\\n            s[temp]=\\'@\\';    // updating the unbalanced paranthesis with \\'@\\'\\n        }\\n         s.erase(remove(s.begin(),s.end(),\\'@\\'),s.end()); // removing all occurence of \\'@\\'\\n        return s;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n string minRemoveToMakeValid(string s) \\n    {\\n        stack<int >st;   // stack to store the index to each paranthesis\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(i);\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                if(!st.empty())\\n                    st.pop();\\n                else\\n                    s[i]=\\'@\\';\\n            }\\n        }\\n        while(!st.empty())   \\n        {\\n            int temp=st.top(); st.pop();\\n            s[temp]=\\'@\\';    // updating the unbalanced paranthesis with \\'@\\'\\n        }\\n         s.erase(remove(s.begin(),s.end(),\\'@\\'),s.end()); // removing all occurence of \\'@\\'\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 926541,
                "title": "two-approaches-stack-without-stack-o-1-space",
                "content": "**1. Solution with Stack**\\nAdd `(` to stack index corresponding to the current length of `res` and skip adding of `)` if the stack is empty\\n\\n```\\nvar minRemoveToMakeValid = function(s) {\\n    let res = []\\n    let stack = []\\n\\t\\n    for(let i=0; i<s.length; i++){\\n        if(s[i] == \\'(\\') stack.push(res.length)\\n        else if(s[i] == \\')\\'){\\n            if(stack.length) stack.pop()\\n            else continue\\n        }\\n        res.push(s[i])\\n    }\\n    \\n    while(stack.length){\\n        res[stack.pop()] = \\'\\'\\n    }\\n\\n    return res.join(\\'\\')\\n};\\n```\\n\\n**2. Solution without Stack**\\nThis approach is O(1) space without considering the ouptput array\\n\\n```\\nvar minRemoveToMakeValid = function(s) {\\n    let res = []\\n    let r = 0\\n    let open = 0\\n    \\n    for(let char of s){\\n        if(char == \\')\\') r++\\n    }\\n    \\n    for(let i=0; i<s.length; i++){\\n        if(s[i] == \\')\\'){\\n            if(open > 0){\\n                res.push(s[i])\\n                open--\\n            }\\n            else r--\\n        } else if(s[i] == \\'(\\'){\\n            if(r>0){\\n                res.push(s[i])\\n                open++\\n                r--\\n            }\\n        } else res.push(s[i])\\n    }\\n    \\n    return res.join(\\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar minRemoveToMakeValid = function(s) {\\n    let res = []\\n    let stack = []\\n\\t\\n    for(let i=0; i<s.length; i++){\\n        if(s[i] == \\'(\\') stack.push(res.length)\\n        else if(s[i] == \\')\\'){\\n            if(stack.length) stack.pop()\\n            else continue\\n        }\\n        res.push(s[i])\\n    }\\n    \\n    while(stack.length){\\n        res[stack.pop()] = \\'\\'\\n    }\\n\\n    return res.join(\\'\\')\\n};\\n```\n```\\nvar minRemoveToMakeValid = function(s) {\\n    let res = []\\n    let r = 0\\n    let open = 0\\n    \\n    for(let char of s){\\n        if(char == \\')\\') r++\\n    }\\n    \\n    for(let i=0; i<s.length; i++){\\n        if(s[i] == \\')\\'){\\n            if(open > 0){\\n                res.push(s[i])\\n                open--\\n            }\\n            else r--\\n        } else if(s[i] == \\'(\\'){\\n            if(r>0){\\n                res.push(s[i])\\n                open++\\n                r--\\n            }\\n        } else res.push(s[i])\\n    }\\n    \\n    return res.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 785593,
                "title": "c-very-easy-solution-using-stack-commented",
                "content": "```\\n\\nclass Solution {\\n\\tpublic:\\n    string minRemoveToMakeValid(string s) {\\n        //to store value and its index\\n\\t\\t\\tstack<pair<int, int>> st;\\n        string temp;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            //if we have to remove symbol, store some other symbol instead of this:\\n            if(s[i] == \\')\\' && st.empty())\\n                s[i] = \\'{\\';\\n            else if(s[i] == \\')\\' && !st.empty())\\n                st.pop();\\n            else if(s[i] == \\'(\\')\\n                st.push({s[i], i});\\n                \\n        }\\n         \\n        while(!st.empty())\\n        {\\n            s[st.top().second] = \\'{\\';\\n            st.pop();\\n        }\\n        //store required string into some temp,don\\'t include symbols which we have to remove.\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            if(s[i] != \\'{\\')\\n                temp.push_back(s[i]);\\n        }\\n        return temp;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n\\nclass Solution {\\n\\tpublic:\\n    string minRemoveToMakeValid(string s) {\\n        //to store value and its index\\n\\t\\t\\tstack<pair<int, int>> st;\\n        string temp;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            //if we have to remove symbol, store some other symbol instead of this:\\n            if(s[i] == \\')\\' && st.empty())\\n                s[i] = \\'{\\';\\n            else if(s[i] == \\')\\' && !st.empty())\\n                st.pop();\\n            else if(s[i] == \\'(\\')\\n                st.push({s[i], i});\\n                \\n        }\\n         \\n        while(!st.empty())\\n        {\\n            s[st.top().second] = \\'{\\';\\n            st.pop();\\n        }\\n        //store required string into some temp,don\\'t include symbols which we have to remove.\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            if(s[i] != \\'{\\')\\n                temp.push_back(s[i]);\\n        }\\n        return temp;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 751584,
                "title": "java-stack-of-pairs-solution",
                "content": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        Stack<Pair<Character,Integer>> validStack = new Stack<>();\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'(\\' || s.charAt(i) == \\')\\'){\\n                char top = s.charAt(i);\\n                if(!validStack.isEmpty()) top = validStack.peek().getKey();\\n                char curr = s.charAt(i);\\n                if(validStack.isEmpty() || curr == top || (curr == \\'(\\' && top == \\')\\')){\\n                    Pair p = new Pair(curr,i);\\n                    validStack.add(p);\\n                }\\n                else if(curr == \\')\\' && top == \\'(\\'){\\n                    validStack.pop();\\n                }  \\n            }\\n        }\\n        StringBuilder sb = new StringBuilder(s);\\n        while(!validStack.isEmpty()){\\n            int index = validStack.peek().getValue();\\n            sb.deleteCharAt(index);\\n            validStack.pop();\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        Stack<Pair<Character,Integer>> validStack = new Stack<>();\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'(\\' || s.charAt(i) == \\')\\'){\\n                char top = s.charAt(i);\\n                if(!validStack.isEmpty()) top = validStack.peek().getKey();\\n                char curr = s.charAt(i);\\n                if(validStack.isEmpty() || curr == top || (curr == \\'(\\' && top == \\')\\')){\\n                    Pair p = new Pair(curr,i);\\n                    validStack.add(p);\\n                }\\n                else if(curr == \\')\\' && top == \\'(\\'){\\n                    validStack.pop();\\n                }  \\n            }\\n        }\\n        StringBuilder sb = new StringBuilder(s);\\n        while(!validStack.isEmpty()){\\n            int index = validStack.peek().getValue();\\n            sb.deleteCharAt(index);\\n            validStack.pop();\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508520,
                "title": "java-two-scans-no-stack-explained",
                "content": "We can find invalid paretheses in two scans - first one from left to right we\\'re finding \")\" without proper opening \"(\", remove those immidiately. On the second pass go from right to left and search for invalid \"(\" without proper \")\". \\nAs we need to return string we already have to create a new DS to store that result. It\\'s possible to use StringBuilder to append and remove characters.\\nO(n) time - two string scans. O(n) space - need a StringBuilder of length up to n.\\n\\n```\\n    public String minRemoveToMakeValid(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int c = 0;\\n        for (char ch : s.toCharArray()) {\\n            if (ch == \\')\\') {\\n                if (c == 0) continue;\\n                --c;\\n            }\\n            else if (ch == \\'(\\') ++c;\\n            sb.append(ch);\\n        }\\n        c = 0; int i = sb.length();\\n        while (--i >= 0) {\\n            if (sb.charAt(i) == \\')\\') ++c;\\n            else if (sb.charAt(i) == \\'(\\') {\\n                if (c == 0) {\\n                    sb.deleteCharAt(i);\\n                    continue;\\n                }\\n                --c;\\n            } \\n        }\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n    public String minRemoveToMakeValid(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int c = 0;\\n        for (char ch : s.toCharArray()) {\\n            if (ch == \\')\\') {\\n                if (c == 0) continue;\\n                --c;\\n            }\\n            else if (ch == \\'(\\') ++c;\\n            sb.append(ch);\\n        }\\n        c = 0; int i = sb.length();\\n        while (--i >= 0) {\\n            if (sb.charAt(i) == \\')\\') ++c;\\n            else if (sb.charAt(i) == \\'(\\') {\\n                if (c == 0) {\\n                    sb.deleteCharAt(i);\\n                    continue;\\n                }\\n                --c;\\n            } \\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 427702,
                "title": "swift-stack",
                "content": "```\\nclass Solution {\\n    \\n    func minRemoveToMakeValid(_ s: String) -> String {\\n        var arr = Array(s)\\n        var stack = [Int]()\\n        for (i, c) in arr.enumerated() {\\n            if c == \"(\" {\\n                stack.append(i)\\n            } else if c == \")\" {\\n                if !stack.isEmpty {\\n                    stack.removeLast()\\n                } else {\\n                    arr[i] = \"*\"\\n                }\\n            }\\n        }\\n        while !stack.isEmpty {\\n            let i = stack.removeLast()\\n            arr[i] = \"*\"\\n        }\\n        \\n        return String(arr).replacingOccurrences(of: \"*\", with: \"\")\\n      \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    func minRemoveToMakeValid(_ s: String) -> String {\\n        var arr = Array(s)\\n        var stack = [Int]()\\n        for (i, c) in arr.enumerated() {\\n            if c == \"(\" {\\n                stack.append(i)\\n            } else if c == \")\" {\\n                if !stack.isEmpty {\\n                    stack.removeLast()\\n                } else {\\n                    arr[i] = \"*\"\\n                }\\n            }\\n        }\\n        while !stack.isEmpty {\\n            let i = stack.removeLast()\\n            arr[i] = \"*\"\\n        }\\n        \\n        return String(arr).replacingOccurrences(of: \"*\", with: \"\")\\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419365,
                "title": "o-n-time-using-hashset-and-stack-java-solution",
                "content": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        \\n        int n = s.length();\\n        if(n == 0) return s;\\n        StringBuilder sb = new StringBuilder();\\n        \\n        HashSet<Integer> set = new HashSet<>();\\n        Stack<Integer> stack = new Stack<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            \\n            char curr = s.charAt(i);\\n            \\n            if(curr == \\'(\\'){\\n                stack.push(i);\\n            }\\n            \\n            else if(curr == \\')\\'){\\n                if(stack.size() > 0){\\n                    stack.pop();\\n                }\\n                else{\\n                    set.add(i);\\n                }\\n            }\\n            \\n            else continue;\\n        }\\n        \\n        while(stack.size() > 0){\\n            set.add(stack.pop());\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            if(!set.contains(i)){\\n                sb.append(\"\" + s.charAt(i));\\n            }\\n        }\\n        \\n        return sb.toString();\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        \\n        int n = s.length();\\n        if(n == 0) return s;\\n        StringBuilder sb = new StringBuilder();\\n        \\n        HashSet<Integer> set = new HashSet<>();\\n        Stack<Integer> stack = new Stack<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            \\n            char curr = s.charAt(i);\\n            \\n            if(curr == \\'(\\'){\\n                stack.push(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3932642,
                "title": "best-solution-without-stack-with-o-1-space-complexity-well-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to remove the minimum number of characters from a given string to make the parentheses valid. A valid parenthesis string is one in which each opening parenthesis \\'(\\' has a corresponding closing parenthesis \\')\\'. The basic idea to solve this problem is to iterate through the string while keeping track of the count of opening and closing brackets. Any closing bracket encountered when there are no available opening brackets to match with should be removed. Additionally, any leftover opening brackets after processing the entire string should be removed.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize a counter variable c to keep track of the unmatched opening brackets.\\n- Iterate through the string s character by character.\\n- - If the current character is an opening bracket \\'(\\', increment the counter c.\\n- - If the current character is a closing bracket \\')\\':\\n- - If the counter c is greater than 0, decrement the counter to indicate that an opening bracket has been matched.\\n- - If the counter c is 0, mark the current character with a special marker (\\'#\\') to indicate that it needs to be removed later.\\n- After the first iteration, we know the number of opening brackets that need to be removed to make the string valid. Also, determine whether the leftover characters should be \\'(\\' or \\')\\', based on the value of the counter c.\\n- Iterate through the string in reverse:\\nIf the current character is marked with \\'#\\', remove it from the string.\\n- If the current character is the leftover character (\\'(\\' or \\')\\') and the counter c is greater than 0, decrement the counter and remove the character from the string.\\nReturn the modified string as the result.\\n\\n# Complexity\\n- ## Time complexity: \\nThe algorithm iterates through the input string twice, once to mark the characters and once to remove the marked characters. Therefore, the time complexity is O(n), where n is the length of the input string.\\n\\n- ## Space complexity: \\nThe algorithm uses a constant amount of extra space for variables and markers, so the space complexity is O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int c=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                c++;\\n            }\\n            else\\n            if(s[i]==\\')\\') \\n            {\\n                if(c>0)\\n                {\\n                    c--;\\n                }\\n                else\\n                s[i]=\\'#\\';\\n            }\\n        }\\n        string w=\"\";\\n        char remchar= c>0? \\'(\\' : \\')\\';\\n        c=c>0 ? c : -c;\\n        for(int i=s.length()-1; i>=0 ;i--)\\n        {\\n            if(s[i]==\\'#\\') \\n            s.erase(s.begin()+i);\\n\\n            if(s[i]==remchar && c>0)\\n            {\\n                c--;\\n                s.erase(s.begin()+i);\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/37206f67-0c0f-499b-846d-efeb80f07ece_1692465910.9151525.png)\\n\\n# PLEASE UPVOTE THE SOLUTION IF IT HELPED YOU UNDERSTAND \\n\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int c=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                c++;\\n            }\\n            else\\n            if(s[i]==\\')\\') \\n            {\\n                if(c>0)\\n                {\\n                    c--;\\n                }\\n                else\\n                s[i]=\\'#\\';\\n            }\\n        }\\n        string w=\"\";\\n        char remchar= c>0? \\'(\\' : \\')\\';\\n        c=c>0 ? c : -c;\\n        for(int i=s.length()-1; i>=0 ;i--)\\n        {\\n            if(s[i]==\\'#\\') \\n            s.erase(s.begin()+i);\\n\\n            if(s[i]==remchar && c>0)\\n            {\\n                c--;\\n                s.erase(s.begin()+i);\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509872,
                "title": "100-c-solution-without-using-stack-time-complexity-o-n-space-complexity-o-1",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea is to fill up the extra brackets with garbage character using two different loops. \\n- The first loop fills up the extra ```)``` with ```$```. To fill up the ```)``` we need to hover from first to last to catch the extra ones. \\n- The second loop fulls up the extra ```(``` with ```$```. To fill up the ```(``` we need to hover from last to first to catch the extra ones.\\n- Then loop through the updated string and discard the ```$``` character. \\n\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int brackets=0,n=s.length();\\n        string res;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'(\\') brackets++;\\n            else if(s[i]==\\')\\'){\\n                if(brackets==0)s[i]=\\'$\\';\\n                else brackets--;\\n            }\\n        }\\n        brackets=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==\\')\\')brackets++;\\n            else if(s[i]==\\'(\\'){\\n                if(brackets==0) s[i]=\\'$\\';\\n                else brackets--;\\n            }\\n        }\\n        for(int i=0;i<s.length();i++)\\n            if(s[i]!=\\'$\\')res+=s[i];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```)```\n```$```\n```)```\n```(```\n```$```\n```(```\n```$```\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int brackets=0,n=s.length();\\n        string res;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'(\\') brackets++;\\n            else if(s[i]==\\')\\'){\\n                if(brackets==0)s[i]=\\'$\\';\\n                else brackets--;\\n            }\\n        }\\n        brackets=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==\\')\\')brackets++;\\n            else if(s[i]==\\'(\\'){\\n                if(brackets==0) s[i]=\\'$\\';\\n                else brackets--;\\n            }\\n        }\\n        for(int i=0;i<s.length();i++)\\n            if(s[i]!=\\'$\\')res+=s[i];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104565,
                "title": "python-simple-solution-beats-100-stack-explained",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def minRemoveToMakeValid(self, s):\\n        # split every characters in string \\n        array = [x for x in s]\\n        stack = []\\n        #Iterate through our array\\n        for i in range(len(array)):\\n            if array[i] == \\'(\\':\\n                stack.append(i)\\n            elif array[i] == \\')\\' and len(stack):\\n                stack.pop()\\n            elif array[i] == \\')\\':\\n                array[i] = \\'\\'\\n        while len(stack):\\n            current_index = stack.pop()\\n            array[current_index] = \\'\\'\\n        return \\'\\'.join(array)\\n```\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution(object):\\n    def minRemoveToMakeValid(self, s):\\n        # split every characters in string \\n        array = [x for x in s]\\n        stack = []\\n        #Iterate through our array\\n        for i in range(len(array)):\\n            if array[i] == \\'(\\':\\n                stack.append(i)\\n            elif array[i] == \\')\\' and len(stack):\\n                stack.pop()\\n            elif array[i] == \\')\\':\\n                array[i] = \\'\\'\\n        while len(stack):\\n            current_index = stack.pop()\\n            array[current_index] = \\'\\'\\n        return \\'\\'.join(array)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996112,
                "title": "c-solution-stack-very-easy-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfind an invalid bracket index and store in stack.\\nwhile traversing stack remove that bracket from string.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstack\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$o(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$o(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack<pair<char,int>> st;\\n        int n = s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'(\\'){\\n                st.push({s[i],i});\\n            }else if(s[i]==\\')\\') {\\n                if(!st.empty()&&st.top().first==\\'(\\'){\\n                    st.pop();\\n                }else{\\n                    st.push({s[i],i});\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            int top = st.top().second;\\n            s.erase(s.begin()+top);\\n            st.pop();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack<pair<char,int>> st;\\n        int n = s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'(\\'){\\n                st.push({s[i],i});\\n            }else if(s[i]==\\')\\') {\\n                if(!st.empty()&&st.top().first==\\'(\\'){\\n                    st.pop();\\n                }else{\\n                    st.push({s[i],i});\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            int top = st.top().second;\\n            s.erase(s.begin()+top);\\n            st.pop();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091947,
                "title": "c-easiest-solution-with-nice-explanation-tc-o-n-sc-o-n",
                "content": "```\\n// 1- We need to find out the index of parenthesis which is making string unbalance.\\n// 2- This can be done using stack pair (pair<char,int>) which will contain parenthesis and its index.\\n// 3- Simple idea is that if we are hitting any close parenthesis then check for open parenthesis on top of the stack, if it is present simply pop out, otherwise insert the current parenthesis with index into the stack.\\n// 4- traverse into the stack and remove all parenthesis from string having index equal to index into stack.\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack<pair<char,int>>st;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                st.push({s[i],i});\\n            else if(s[i]==\\')\\')\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                    st.pop();\\n                else st.push({s[i],i});\\n            }\\n        }\\n        if(st.empty()) return s;\\n        else\\n        {\\n            while(!st.empty())\\n            {\\n                int idx=st.top().second;\\n                s.erase(idx,1);\\n                st.pop();\\n            }\\n            return s;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\n// 1- We need to find out the index of parenthesis which is making string unbalance.\\n// 2- This can be done using stack pair (pair<char,int>) which will contain parenthesis and its index.\\n// 3- Simple idea is that if we are hitting any close parenthesis then check for open parenthesis on top of the stack, if it is present simply pop out, otherwise insert the current parenthesis with index into the stack.\\n// 4- traverse into the stack and remove all parenthesis from string having index equal to index into stack.\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack<pair<char,int>>st;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                st.push({s[i],i});\\n            else if(s[i]==\\')\\')\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                    st.pop();\\n                else st.push({s[i],i});\\n            }\\n        }\\n        if(st.empty()) return s;\\n        else\\n        {\\n            while(!st.empty())\\n            {\\n                int idx=st.top().second;\\n                s.erase(idx,1);\\n                st.pop();\\n            }\\n            return s;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871233,
                "title": "easy-python-solution-using-stack-o-n-faster-than-79-82",
                "content": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        stack = []\\n        ans = [\"\"]*len(s)                    # Declare the ans array\\n        for i in range(len(s)):\\n            if s[i].isalpha():               # If alphabet : Insert it into ans array\\n                ans[i] = s[i]\\n            else:\\n                if s[i]==\\'(\\':                # If \\'(\\' : Push it to the stack along with its index\\n                    stack.append((s[i],i))\\n                else:                        # If \\')\\' : Pop the top element of stack and insert into ans array at appropriate index\\n                    if stack:\\n                        ans[i] = s[i]\\n                        a = stack.pop()\\n                        ans[a[1]] = a[0]\\n        return \"\".join(ans)                  # Return the ans array\\n                        \\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        stack = []\\n        ans = [\"\"]*len(s)                    # Declare the ans array\\n        for i in range(len(s)):\\n            if s[i].isalpha():               # If alphabet : Insert it into ans array\\n                ans[i] = s[i]\\n            else:\\n                if s[i]==\\'(\\':                # If \\'(\\' : Push it to the stack along with its index\\n                    stack.append((s[i],i))\\n                else:                        # If \\')\\' : Pop the top element of stack and insert into ans array at appropriate index\\n                    if stack:\\n                        ans[i] = s[i]\\n                        a = stack.pop()\\n                        ans[a[1]] = a[0]\\n        return \"\".join(ans)                  # Return the ans array\\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852416,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public String minRemoveToMakeValid(String s) {\\n        char c[] = s.toCharArray();\\n        int l=c.length,p=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(c[i]==\\'(\\')\\n                p++;\\n            else if(c[i]==\\')\\')\\n            {\\n                if(p>0)\\n                    p--;\\n                else\\n                    c[i]=\\' \\';\\n            }\\n        }\\n        for(int i=l-1;i>=0 && p>0 ;i--)\\n        {\\n            if(c[i]==\\'(\\')\\n            {\\n                c[i]=\\' \\';\\n                p--;\\n            }\\n        }\\n        StringBuilder nm=new StringBuilder();\\n        for(char k : c)\\n        {\\n            if(k!=\\' \\')\\n                nm.append(k);\\n        }\\n        return nm.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public String minRemoveToMakeValid(String s) {\\n        char c[] = s.toCharArray();\\n        int l=c.length,p=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(c[i]==\\'(\\')\\n                p++;\\n            else if(c[i]==\\')\\')\\n            {\\n                if(p>0)\\n                    p--;\\n                else\\n                    c[i]=\\' \\';\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1851889,
                "title": "python-o-n-stack-simple-comments",
                "content": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        out = \\'\\'\\n        stk = []\\n        \\n        for i,c in enumerate(s):\\n            #characters other than ( and ) to be added to output\\n            if c not in(\\'(\\',\\')\\'):\\n                out+=c\\n            # for ( add it to output and add the index to stack\\n            elif c == \\'(\\':\\n                out+=c\\n                stk.append(len(out)-1)\\n            # for ) check if corresponding ( is there in stack.\\n            # if yes, then add the ) to output and remove the index from stack \\n\\t\\t\\t# if no, then do not add the \\')\\' as it will make the output invalid\\n            else:\\n                if len(stk)>0:\\n                    stk.pop()\\n                    out+=c\\n        # all the unmatched open brackets to be removed from stack as below\\n        while stk:\\n            idx = stk.pop()\\n            out = out[:idx] + out[idx+1:]\\n            \\n        return out\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        out = \\'\\'\\n        stk = []\\n        \\n        for i,c in enumerate(s):\\n            #characters other than ( and ) to be added to output\\n            if c not in(\\'(\\',\\')\\'):\\n                out+=c\\n            # for ( add it to output and add the index to stack\\n            elif c == \\'(\\':\\n                out+=c\\n                stk.append(len(out)-1)\\n            # for ) check if corresponding ( is there in stack.\\n            # if yes, then add the ) to output and remove the index from stack \\n\\t\\t\\t# if no, then do not add the \\')\\' as it will make the output invalid\\n            else:\\n                if len(stk)>0:\\n                    stk.pop()\\n                    out+=c\\n        # all the unmatched open brackets to be removed from stack as below\\n        while stk:\\n            idx = stk.pop()\\n            out = out[:idx] + out[idx+1:]\\n            \\n        return out\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851790,
                "title": "simple-java-stack-solution",
                "content": "Just counted number of opening brackets and used stack to solve this question.\\n```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        Stack<Character>s1=new Stack<>();\\n        int count_op=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\') {count_op++;s1.add(s.charAt(i));}\\n            else if(s.charAt(i)==\\')\\' && count_op>0) {count_op--;s1.add(s.charAt(i));}\\n            else if(s.charAt(i)!=\\')\\') {s1.add(s.charAt(i));}\\n        }\\n        StringBuilder sb=new StringBuilder(\"\");\\n        while(!s1.isEmpty()){\\n            if(s1.peek()==\\'(\\' && count_op>0) {count_op--;s1.pop();}\\n            else sb.append(s1.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        Stack<Character>s1=new Stack<>();\\n        int count_op=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\') {count_op++;s1.add(s.charAt(i));}\\n            else if(s.charAt(i)==\\')\\' && count_op>0) {count_op--;s1.add(s.charAt(i));}\\n            else if(s.charAt(i)!=\\')\\') {s1.add(s.charAt(i));}\\n        }\\n        StringBuilder sb=new StringBuilder(\"\");\\n        while(!s1.isEmpty()){\\n            if(s1.peek()==\\'(\\' && count_op>0) {count_op--;s1.pop();}\\n            else sb.append(s1.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851756,
                "title": "minimum-remove-to-make-valid-parentheses",
                "content": "//Input: s = \"lee(t(c)o)de)\"\\nOutput: \"lee(t(c)o)de\"\\nExplanation: \"lee(t(co)de)\" , \"lee(t(c)ode)\" would also be accepted.//\\n*********************************************Explanations************************************\\n-->In the given que we need to remove the extra \\'(\\' & \\')\\' (brackets).\\n-->first apporach in my mind that we use string , stack , map  and so on.\\n-->so , I m using the string .\\n-->firstly  iterate the loop from the starting and the secondly iterate the loop from the ending.\\n--> so , my apporach is that we iterate the loop from the starting  and if we find the \"(\"(opening bracket) , then increment it , and if we find the \")\"(closing bracket) is more then the \"(\" then we need to decrement it .(no. closing> no.opening)\\n--> thats why we are using the s[i]==\\'@\\', and decrement the count --;\\n--> second loop started from the end  . \\n--> if no. opening > the no. closing  , then decrement the \\'(\\' (opening)\\n--> at last run the  loop \\n\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int n=s.length();\\n        int count=0;\\n\\t\\t// first loop from the starting \\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'(\\'){\\n                count++;\\n            }\\n            else if(s[i]==\\')\\'){\\n                if(count==0){\\n                    s[i]=\\'@\\';\\n                }\\n                else{\\n                    count--;\\n                }\\n            }\\n        }\\n\\t\\t// second loop from the ending\\n        count=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==\\')\\'){\\n                count++;\\n            }\\n            else if(s[i]==\\'(\\'){\\n                if(count==0){\\n                    s[i]=\\'@\\';\\n                }\\n                else{\\n                    count--;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<n;i++){\\n            if(s[i]!=\\'@\\'){\\n                ans.push_back(s[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**If this code is helpful  then please upvote my solution and if any query then feel free to ask \\nTHANKU**",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int n=s.length();\\n        int count=0;\\n\\t\\t// first loop from the starting \\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'(\\'){\\n                count++;\\n            }\\n            else if(s[i]==\\')\\'){\\n                if(count==0){\\n                    s[i]=\\'@\\';\\n                }\\n                else{\\n                    count--;\\n                }\\n            }\\n        }\\n\\t\\t// second loop from the ending\\n        count=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==\\')\\'){\\n                count++;\\n            }\\n            else if(s[i]==\\'(\\'){\\n                if(count==0){\\n                    s[i]=\\'@\\';\\n                }\\n                else{\\n                    count--;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<n;i++){\\n            if(s[i]!=\\'@\\'){\\n                ans.push_back(s[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851299,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        string ans=\"\";\\n        stack<int>st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\')\\n                st.push(ans.length());\\n            else if(s[i]==\\')\\'){\\n                if(st.empty()){\\n                    continue;\\n                }\\n                else{\\n                    ans.insert(st.top(),\"(\");\\n                    st.pop();\\n                    ans+=\")\";\\n                }\\n            }\\n            else\\n                ans+=s[i];\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        string ans=\"\";\\n        stack<int>st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\')\\n                st.push(ans.length());\\n            else if(s[i]==\\')\\'){\\n                if(st.empty()){\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1850954,
                "title": "c-easy-solution-o-1-space",
                "content": "\\nTraverse into the string if open paranthesis occur then increment the open count \\nNow if close paranthesis occur then check if open count is greater than 0 then close paranthesis is valid else ignore it and move ahead \\n\\nAt the end remove extra open paranthesis so that all paranthesis become valid\\n\\n| PLEASE UPVOTE IF YOU LIKE THE SOLUTION |\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int open=0;\\n        string ans=\"\";\\n        for(char c:s){\\n            if(c==\\'(\\'){\\n                open++;\\n                ans+=c;\\n            }else if(c==\\')\\'){\\n                if(open>0){\\n                    open--;\\n                    ans+=c;\\n                }else{\\n                    continue;\\n                }\\n            }else{\\n                ans+=c;\\n            }\\n        }\\n        int n=ans.size();\\n        \\n        if(open>0){\\n            for(int i=n-1;i>=0;i--){\\n                if(ans[i]==\\'(\\' && open>0){\\n                    ans.erase(i,1);\\n                    open--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int open=0;\\n        string ans=\"\";\\n        for(char c:s){\\n            if(c==\\'(\\'){\\n                open++;\\n                ans+=c;\\n            }else if(c==\\')\\'){\\n                if(open>0){\\n                    open--;\\n                    ans+=c;\\n                }else{\\n                    continue;\\n                }\\n            }else{\\n                ans+=c;\\n            }\\n        }\\n        int n=ans.size();\\n        \\n        if(open>0){\\n            for(int i=n-1;i>=0;i--){\\n                if(ans[i]==\\'(\\' && open>0){\\n                    ans.erase(i,1);\\n                    open--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850624,
                "title": "java-stack-string-o-n-solution",
                "content": "1) I have used stack for validating the parentheses\\n2) Set for storing invalid parentheses\\n3) StringBuilder for fast append operation of a string\\n```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        Stack<Integer>stack=new Stack<>();\\n        Set<Integer>set=new HashSet<>();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                stack.push(i);\\n            }else if(s.charAt(i)==\\')\\'){\\n                if(stack.isEmpty())\\n                    set.add(i);\\n                else\\n                    stack.pop();\\n            }\\n        }\\n        while(!stack.isEmpty())\\n            set.add(stack.pop());\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<s.length();i++)\\n            if(!set.contains(i))\\n                sb.append(s.charAt(i));\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        Stack<Integer>stack=new Stack<>();\\n        Set<Integer>set=new HashSet<>();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                stack.push(i);\\n            }else if(s.charAt(i)==\\')\\'){\\n                if(stack.isEmpty())\\n                    set.add(i);\\n                else\\n                    stack.pop();\\n            }\\n        }\\n        while(!stack.isEmpty())\\n            set.add(stack.pop());\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<s.length();i++)\\n            if(!set.contains(i))\\n                sb.append(s.charAt(i));\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850464,
                "title": "c-easy-to-understand-without-stack-simple",
                "content": "**1249. Minimum Remove to Make Valid Parentheses**\\n\\n##### **APPROACH -**\\n* **Each prefix of a balanced parentheses has a number of open parentheses greater or equal than closed parentheses, similar idea with each suffix.**\\n\\n*Create **`count`** to keep track of the net number of parentheses\\nIterate from left to right to check for invalid **`\\')\\'`**\\nWhile maintaining the count, mark the invalid ones with **`\\'*\\'`**\\nReset count and again iterate from right to left to check for invalid **`\\'(\\'`**\\nWhile maintaining the count, mark the invalid ones with **`\\'*\\'`**\\nNow get the result removing all the invalid **`\\'*\\'`** we marked*\\n\\n**Note : Removing only the invalid parentheses ensures the minimum condition given in the problem statement**\\n\\n<br/>\\n\\n##### **COMPLEXITY -**\\n* **Time Complexity : O(N)**, where N = length of s\\n* **Space Complexity : O(1)**\\n\\n<br/>\\n\\n##### **CODE -**\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int count = 0;\\n        for(int i = 0; i < s.length(); ++i) {\\n            if(s[i] == \\'(\\')    ++count;\\n            else if(s[i] == \\')\\') {\\n                if(count > 0)   --count;\\n                else   s[i] = \\'*\\';  // invalid as number of \\'(\\' on left is less than the number of \\')\\'\\n            }\\n        }\\n        \\n        count = 0;\\n        for(int i = s.length()-1; i >= 0 ; --i) {\\n            if(s[i] == \\')\\')    ++count;\\n            else if(s[i] == \\'(\\') {\\n                if(count > 0)   --count;\\n                else   s[i] = \\'*\\';  // invalid as number of \\')\\' on right is less than the number of \\'(\\'\\n            }\\n        }\\n            \\n        string res;\\n        for(char c : s) {\\n            if(c != \\'*\\')    \\n                res.push_back(c);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**If you found this helpful, please Upvote \\u2B06\\uFE0F**",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int count = 0;\\n        for(int i = 0; i < s.length(); ++i) {\\n            if(s[i] == \\'(\\')    ++count;\\n            else if(s[i] == \\')\\') {\\n                if(count > 0)   --count;\\n                else   s[i] = \\'*\\';  // invalid as number of \\'(\\' on left is less than the number of \\')\\'\\n            }\\n        }\\n        \\n        count = 0;\\n        for(int i = s.length()-1; i >= 0 ; --i) {\\n            if(s[i] == \\')\\')    ++count;\\n            else if(s[i] == \\'(\\') {\\n                if(count > 0)   --count;\\n                else   s[i] = \\'*\\';  // invalid as number of \\')\\' on right is less than the number of \\'(\\'\\n            }\\n        }\\n            \\n        string res;\\n        for(char c : s) {\\n            if(c != \\'*\\')    \\n                res.push_back(c);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850419,
                "title": "my-thought",
                "content": "Task :- \\n1. Remove minimum no. of brackets to make a valid string(i.e take as many brackets as possible in our string).\\n\\nObservations :-\\n1. for every opening bracket a closing bracket should be present in a valid string.\\n\\nSteps :-\\n1. iterate over the string if the current character is not a bracket simply add this to our ans.\\n2. if it is an opening bracket we can simply check that whether a closing bracket is present for this opening bracket or not present.\\n3. if it is present we can add this opening bracket into our ans and we can mark that we have used this closing bracket for an opening bracket and now we can\\'t use this closing bracket for any other opening bracket.\\n4.  if its a closing bracket we can check that whether we have used this closing bracket for an opening bracket or not if yes we have to add this in our ans otherwise not.\\n\\nCode :-\\n\\n```\\npublic String minRemoveToMakeValid(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        boolean[] taken = new boolean[s.length()];\\n\\t\\t\\n        for(int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            \\n            if(ch != \\'(\\' && ch != \\')\\') {  // if the current character is not a bracket\\n                sb.append(ch);\\n            } else if(ch == \\'(\\') {  // if it is an opening bracket find the nearest closing bracket and mark it taken\\n                int j = i + 1;\\n                while(j < s.length() && (s.charAt(j) != \\')\\' || (taken[j] == true))) {\\n                    j++;\\n                }\\n                \\n                if(j < s.length()) {\\n                    taken[j] = true;\\n                    sb.append(ch);\\n                }\\n            } else { // if it is a closing bracket and we have used it for some opening bracket then add it into our ans\\n                if(taken[i] == true) {\\n                    sb.append(ch);\\n                }\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n```\\n\\nTime Complexity :- O(n^2)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String minRemoveToMakeValid(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        boolean[] taken = new boolean[s.length()];\\n\\t\\t\\n        for(int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            \\n            if(ch != \\'(\\' && ch != \\')\\') {  // if the current character is not a bracket\\n                sb.append(ch);\\n            } else if(ch == \\'(\\') {  // if it is an opening bracket find the nearest closing bracket and mark it taken\\n                int j = i + 1;\\n                while(j < s.length() && (s.charAt(j) != \\')\\' || (taken[j] == true))) {\\n                    j++;\\n                }\\n                \\n                if(j < s.length()) {\\n                    taken[j] = true;\\n                    sb.append(ch);\\n                }\\n            } else { // if it is a closing bracket and we have used it for some opening bracket then add it into our ans\\n                if(taken[i] == true) {\\n                    sb.append(ch);\\n                }\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1850238,
                "title": "simple-java-using-stack",
                "content": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        \\n        \\n        Stack<Integer> st= new Stack<>();  //to check for valid parentheses\\n        char[] ch=s.toCharArray();   \\n        \\n    //this for loop make valid ch array and containing \\'.\\' you can use anything for flag\\n        for(int i=0;i<ch.length;i++){\\n            \\n            if(ch[i]==\\'(\\'){\\n                st.push(i);\\n            }else if(ch[i] == \\')\\'){\\n                if(st.size()==0){\\n                    ch[i]=\\'.\\';\\n                }else\\n                    st.pop();\\n            }\\n            \\n                       \\n        }\\n        \\n        \\n        //remaining elements in stack\\n        while(st.size()>0){\\n            ch[st.pop()] =\\'.\\';\\n        }\\n        \\n        \\n        //store arrays ch int string for returning the valid string\\n        StringBuilder str = new StringBuilder();\\n        for(char c : ch){\\n            if(c!=\\'.\\'){\\n                str.append(c);\\n            }\\n        }\\n        \\n        \\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        \\n        \\n        Stack<Integer> st= new Stack<>();  //to check for valid parentheses\\n        char[] ch=s.toCharArray();   \\n        \\n    //this for loop make valid ch array and containing \\'.\\' you can use anything for flag\\n        for(int i=0;i<ch.length;i++){\\n            \\n            if(ch[i]==\\'(\\'){\\n                st.push(i);\\n            }else if(ch[i] == \\')\\'){\\n                if(st.size()==0){\\n                    ch[i]=\\'.\\';\\n                }else\\n                    st.pop();\\n            }\\n            \\n                       \\n        }\\n        \\n        \\n        //remaining elements in stack\\n        while(st.size()>0){\\n            ch[st.pop()] =\\'.\\';\\n        }\\n        \\n        \\n        //store arrays ch int string for returning the valid string\\n        StringBuilder str = new StringBuilder();\\n        for(char c : ch){\\n            if(c!=\\'.\\'){\\n                str.append(c);\\n            }\\n        }\\n        \\n        \\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1837353,
                "title": "c-common-error-memory-limit-exceeded",
                "content": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack<int> st; // int ~ index\\n        for(int i=0;i<s.size();i++){\\n            if(isalpha(s[i])) continue;\\n            \\n            // never insert a closing bracket in stack\\n            \\n            if(st.empty() && s[i]==\\'(\\'){\\n                st.push(i);\\n            }else if(st.empty() && s[i]==\\')\\'){\\n                // removeIdx.insert(i);\\n                st.push(i);\\n            }else if(s[st.top()]==\\'(\\' && s[i]==\\')\\'){\\n                st.pop();\\n            }else{\\n                st.push(i);\\n            }\\n        }\\n        \\n        // while(!st.empty()){\\n        //     removeIdx.insert(st.top());\\n        //     st.pop();\\n        // }\\n        \\n        string res = \"\";\\n        int size1 = s.size();\\n            // cout << st.size() << endl;\\n\\n        for(int i=size1-1;i>=0;i--){\\n            if(!st.empty() && i==st.top()){\\n                st.pop();\\n                continue;\\n            }\\n            res += s[i];\\n            // res = s[i] + res; if not commented will give Memory limited exceeded\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack<int> st; // int ~ index\\n        for(int i=0;i<s.size();i++){\\n            if(isalpha(s[i])) continue;\\n            \\n            // never insert a closing bracket in stack\\n            \\n            if(st.empty() && s[i]==\\'(\\'){\\n                st.push(i);\\n            }else if(st.empty() && s[i]==\\')\\'){\\n                // removeIdx.insert(i);\\n                st.push(i);\\n            }else if(s[st.top()]==\\'(\\' && s[i]==\\')\\'){\\n                st.pop();\\n            }else{\\n                st.push(i);\\n            }\\n        }\\n        \\n        // while(!st.empty()){\\n        //     removeIdx.insert(st.top());\\n        //     st.pop();\\n        // }\\n        \\n        string res = \"\";\\n        int size1 = s.size();\\n            // cout << st.size() << endl;\\n\\n        for(int i=size1-1;i>=0;i--){\\n            if(!st.empty() && i==st.top()){\\n                st.pop();\\n                continue;\\n            }\\n            res += s[i];\\n            // res = s[i] + res; if not commented will give Memory limited exceeded\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1695699,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack<pair<int,int>>st;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push({s[i],i});\\n                \\n            }\\n            else if(s[i]==\\')\\'){\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                    st.pop();\\n                else\\n                    st.push({s[i],i});//we can write make_pair(s[i],i) also\\n            }\\n        }\\n        while(!st.empty())\\n        {\\n            int a=st.top().second;\\n            s.erase(s.begin()+a);\\n            st.pop();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack<pair<int,int>>st;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push({s[i],i});\\n                \\n            }\\n            else if(s[i]==\\')\\'){\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                    st.pop();\\n                else\\n                    st.push({s[i],i});//we can write make_pair(s[i],i) also\\n            }\\n        }\\n        while(!st.empty())\\n        {\\n            int a=st.top().second;\\n            s.erase(s.begin()+a);\\n            st.pop();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683379,
                "title": "python-simple-solution-with-and-without-stack",
                "content": "Without Stack:\\n```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        \\n        ans=list()\\n        \\n        count_bracket=0\\n        \\n        for index,char in enumerate(s):\\n            if char ==\\'(\\':\\n                count_bracket+=1\\n                \\n            elif char ==\\')\\':\\n                if not count_bracket:\\n                    continue\\n                \\n                count_bracket-=1\\n            \\n            ans.append(char)\\n          \\n        \\n        for i in range(len(ans)-1,-1,-1):\\n            if ans[i]==\\'(\\' and count_bracket >0 :\\n                ans[i]=\\'\\'\\n                count_bracket-=1\\n            else:\\n                continue\\n                \\n        return \\'\\'.join(ans)\\n\\t\\t\\n```\\n\\nWith Stack:\\n\\n```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        \\n        stack=list()\\n        \\n        ans=list(s)\\n        \\n        for index,char in enumerate(s):\\n            \\n            if char ==\\'(\\': stack.append(index)\\n                \\n            elif char ==\\')\\':\\n                \\n                if stack: stack.pop()\\n                \\n                else: ans[index]=\\'\\'\\n  \\n        for left_index in stack:\\n            ans[left_index]=\\'\\'\\n            \\n        return \"\".join(ans)\\n            \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        \\n        ans=list()\\n        \\n        count_bracket=0\\n        \\n        for index,char in enumerate(s):\\n            if char ==\\'(\\':\\n                count_bracket+=1\\n                \\n            elif char ==\\')\\':\\n                if not count_bracket:\\n                    continue\\n                \\n                count_bracket-=1\\n            \\n            ans.append(char)\\n          \\n        \\n        for i in range(len(ans)-1,-1,-1):\\n            if ans[i]==\\'(\\' and count_bracket >0 :\\n                ans[i]=\\'\\'\\n                count_bracket-=1\\n            else:\\n                continue\\n                \\n        return \\'\\'.join(ans)\\n\\t\\t\\n```\n```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        \\n        stack=list()\\n        \\n        ans=list(s)\\n        \\n        for index,char in enumerate(s):\\n            \\n            if char ==\\'(\\': stack.append(index)\\n                \\n            elif char ==\\')\\':\\n                \\n                if stack: stack.pop()\\n                \\n                else: ans[index]=\\'\\'\\n  \\n        for left_index in stack:\\n            ans[left_index]=\\'\\'\\n            \\n        return \"\".join(ans)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1291234,
                "title": "constant-space-c-solution",
                "content": "```\\n//Every prefix should have no of \\'(\\' >= no. of \\')\\' and \\n    //every suffix should have no of \\')\\' >= no. of \\'(\\'\\n    \\n    string minRemoveToMakeValid(string s) {\\n        string ans;\\n        int c=0;   //count no of \\'(\\'\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\')\\n                c++;\\n            else if(s[i]==\\')\\'){\\n                if(c>0)\\n                    c--;\\n                else\\n                    s[i]=\\'*\\';\\n            }\\n        }\\n        c=0;    //count no of \\')\\'\\n        for(int i=s.length()-1;i>=0;i--){\\n            if(s[i]==\\')\\')\\n                c++;\\n            else if(s[i]==\\'(\\'){\\n                if(c>0)\\n                    c--;\\n                else\\n                    s[i]=\\'*\\';\\n            }\\n        }\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'*\\')\\n                continue;\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n//Every prefix should have no of \\'(\\' >= no. of \\')\\' and \\n    //every suffix should have no of \\')\\' >= no. of \\'(\\'\\n    \\n    string minRemoveToMakeValid(string s) {\\n        string ans;\\n        int c=0;   //count no of \\'(\\'\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\')\\n                c++;\\n            else if(s[i]==\\')\\'){\\n                if(c>0)\\n                    c--;\\n                else\\n                    s[i]=\\'*\\';\\n            }\\n        }\\n        c=0;    //count no of \\')\\'\\n        for(int i=s.length()-1;i>=0;i--){\\n            if(s[i]==\\')\\')\\n                c++;\\n            else if(s[i]==\\'(\\'){\\n                if(c>0)\\n                    c--;\\n                else\\n                    s[i]=\\'*\\';\\n            }\\n        }\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'*\\')\\n                continue;\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1232206,
                "title": "golang-stack-solution-with-explanation",
                "content": "[1249. Minimum Remove to Make Valid Parentheses](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/)\\n\\nThe idea of this solution is:\\n\\n* Loop through every character in `s`, and:\\n* If the current character is a `\\'(\\'` add the index of the `\\'(\\'` to a stack\\n* If the current character is a `\\')\\'`:\\n\\t* If the stack is not empty, we can pop off the stack\\n\\t* If the stack is empty, remove the character from the string\\n* After looping through every character, if the stack is not empty, we remove the characters at the values in the stack. We do this because the positions in the stack are there for the extra `\\'(\\'`.\\n* Then we can return `s`.\\n\\n``` go\\nfunc minRemoveToMakeValid(s string) string {\\n\\tstack := []int{}\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif s[i] == \\'(\\' {\\n\\t\\t\\tstack = append(stack, i)\\n\\t\\t} else if s[i] == \\')\\' {\\n\\t\\t\\tif len(stack) != 0 {\\n\\t\\t\\t\\tstack = stack[:len(stack)-1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ts = s[:i] + s[i+1:]\\n\\t\\t\\t\\ti--\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor len(stack) != 0 {\\n\\t\\tpop := stack[len(stack)-1]\\n\\t\\tstack = stack[:len(stack)-1]\\n\\t\\ts = s[:pop] + s[pop+1:]\\n\\t}\\n\\treturn s\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc minRemoveToMakeValid(s string) string {\\n\\tstack := []int{}\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif s[i] == \\'(\\' {\\n\\t\\t\\tstack = append(stack, i)\\n\\t\\t} else if s[i] == \\')\\' {\\n\\t\\t\\tif len(stack) != 0 {\\n\\t\\t\\t\\tstack = stack[:len(stack)-1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ts = s[:i] + s[i+1:]\\n\\t\\t\\t\\ti--\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor len(stack) != 0 {\\n\\t\\tpop := stack[len(stack)-1]\\n\\t\\tstack = stack[:len(stack)-1]\\n\\t\\ts = s[:pop] + s[pop+1:]\\n\\t}\\n\\treturn s\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1156686,
                "title": "very-easy-and-elegant-solution-in-java-using-one-stack",
                "content": "Algorithm: Simply traverse the string and push the brackets  in stack which are not balanced and at last remove those brackets from your string as we have only issues with brackets and not with alphabets. so we will focus on brackets\\n1. if you find opening bracket push its index in stack\\n2. if you find closing bracket then there can be two situations\\n2a if there is already opening bracket at top of stack then they make a pair(opening and closing) so remove the top element of stack(i.e opening bracket)(because it is not balanced).\\n2b if there is no opening bracket on the top for closing bracket then push it in stack\\n3 These indexes in the stack are the places where you have to remove the brackets because they are not balanced.\\n\\nPlease upvote if you understood the algorithm and liked it.\\n\\n```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        StringBuilder str = new StringBuilder(s);\\n        \\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i = 0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'(\\'){\\n                st.push(i);\\n            }else if(ch == \\')\\'){\\n                if(st.size() == 0){\\n                    st.push(i);\\n                }else{\\n                    if(str.charAt(st.peek()) == \\'(\\'){\\n                        st.pop();\\n                    }else{\\n                        st.push(i);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        while(st.size() > 0){\\n            str.deleteCharAt(st.pop());\\n        }\\n        \\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        StringBuilder str = new StringBuilder(s);\\n        \\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i = 0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'(\\'){\\n                st.push(i);\\n            }else if(ch == \\')\\'){\\n                if(st.size() == 0){\\n                    st.push(i);\\n                }else{\\n                    if(str.charAt(st.peek()) == \\'(\\'){\\n                        st.pop();\\n                    }else{\\n                        st.push(i);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        while(st.size() > 0){\\n            str.deleteCharAt(st.pop());\\n        }\\n        \\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155874,
                "title": "c-solution",
                "content": "C++\\n```\\nclass Solution {\\npublic:\\n    /**\\n    Idea:\\n    1. use a stack stores all left par, if we have a right par, pop stack if stack not empty, or mark it as \\'*\\'\\n    2. mark all redundant left as \\'*\\' placeholder, finally remove all \\'*\\'\\n    **/\\n    string minRemoveToMakeValid(string s) {\\n        stack<int> stk;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] == \\'(\\') stk.push(i);\\n            else if(s[i] == \\')\\'){\\n                if(stk.empty()) s[i] = \\'*\\';\\n                else stk.pop();\\n            }\\n        }\\n        while(!stk.empty()){\\n            s[stk.top()] = \\'*\\';\\n            stk.pop();\\n        }\\n        s.erase(remove(s.begin(),s.end(),\\'*\\'), s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /**\\n    Idea:\\n    1. use a stack stores all left par, if we have a right par, pop stack if stack not empty, or mark it as \\'*\\'\\n    2. mark all redundant left as \\'*\\' placeholder, finally remove all \\'*\\'\\n    **/\\n    string minRemoveToMakeValid(string s) {\\n        stack<int> stk;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] == \\'(\\') stk.push(i);\\n            else if(s[i] == \\')\\'){\\n                if(stk.empty()) s[i] = \\'*\\';\\n                else stk.pop();\\n            }\\n        }\\n        while(!stk.empty()){\\n            s[stk.top()] = \\'*\\';\\n            stk.pop();\\n        }\\n        s.erase(remove(s.begin(),s.end(),\\'*\\'), s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122294,
                "title": "javascript-100",
                "content": "```\\nvar minRemoveToMakeValid = function(s) {\\n    let result = s.split(\\'\\');\\n    const indexes = [];\\n    let balance = 0\\n     \\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \\'(\\') {\\n            indexes.push(i);\\n            balance++\\n        } else if (s[i] === \\')\\') {\\n            if (balance < 1) indexes.push(i);\\n            else {\\n                balance--;\\n                indexes.pop();\\n            }\\n        }\\n    }\\n \\n    for (let index of indexes) result[index] = \\'\\';\\n     \\n    return result.join(\\'\\');\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minRemoveToMakeValid = function(s) {\\n    let result = s.split(\\'\\');\\n    const indexes = [];\\n    let balance = 0\\n     \\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \\'(\\') {\\n            indexes.push(i);\\n            balance++\\n        } else if (s[i] === \\')\\') {\\n            if (balance < 1) indexes.push(i);\\n            else {\\n                balance--;\\n                indexes.pop();\\n            }\\n        }\\n    }\\n \\n    for (let index of indexes) result[index] = \\'\\';\\n     \\n    return result.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1106244,
                "title": "js-stack",
                "content": "```\\nvar minRemoveToMakeValid = function(s) {\\n    let op = []\\n    s = s.split(\\'\\')\\n    for(let i=0; i<s.length; i++){\\n        if(s[i]===\\'(\\') op.push(i)\\n        if(s[i]===\\')\\') {\\n            if(op.length) op.pop(); else s[i]=\\'\\'\\n        }\\n    }\\n    while(op.length) s[op.pop()]=\\'\\';\\n    return s.join(\\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minRemoveToMakeValid = function(s) {\\n    let op = []\\n    s = s.split(\\'\\')\\n    for(let i=0; i<s.length; i++){\\n        if(s[i]===\\'(\\') op.push(i)\\n        if(s[i]===\\')\\') {\\n            if(op.length) op.pop(); else s[i]=\\'\\'\\n        }\\n    }\\n    while(op.length) s[op.pop()]=\\'\\';\\n    return s.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1099450,
                "title": "simple-c-solution-without-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        // Marking extra ) as # \\n        int count=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\') count++;\\n            else if(s[i]==\\')\\'){\\n                if(count==0) s[i]=\\'#\\';\\n                else count--;\\n            }\\n        }\\n        // Marking extra ( as #\\n        count=0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\')\\') count++;\\n            else if(s[i]==\\'(\\'){\\n                if(count==0) s[i]=\\'#\\';\\n                else count--;\\n            }\\n        }\\n        //String without #\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\'#\\') ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        // Marking extra ) as # \\n        int count=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\') count++;\\n            else if(s[i]==\\')\\'){\\n                if(count==0) s[i]=\\'#\\';\\n                else count--;\\n            }\\n        }\\n        // Marking extra ( as #\\n        count=0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\')\\') count++;\\n            else if(s[i]==\\'(\\'){\\n                if(count==0) s[i]=\\'#\\';\\n                else count--;\\n            }\\n        }\\n        //String without #\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\'#\\') ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 986286,
                "title": "c-deque-stack-using-a-count-variable-time-o-n-space-o-1",
                "content": "**Deque Approach**\\n*Time Complexity: O (n)\\nSpace Complexity: O(n)*\\nIn this approach, I set up a deque which takes a pair of int and char and takes note of index of all ( & ) and pops if ( and ) are found. In the next loop of iteration, it checks if the index has been marked invalid (it is present in deque) and makes our result string.\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        deque <pair<int, char>> dq;\\n        string res;\\n        for (int i=0; i<s.size(); i++) {\\n            if (!dq.empty() && dq.back().second==\\'(\\' && s[i]==\\')\\') dq.pop_back();\\n            else if (s[i]==\\'(\\' || s[i]==\\')\\') dq.push_back({i, s[i]});\\n        }\\n        \\n        for (int i=0; i<s.size(); i++) {\\n        if (!dq.empty() && i==dq.front().first) dq.pop_front();\\n        else res+=s[i];\\n        }\\n        return res;\\n    }\\n};\\n```\\n**A better Deque Approach**\\n*Time Complexity: O (n)\\nSpace Complexity: O(n)*\\nThis approach doesn\\'t store the char ( or ) but just invalid indices.\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        deque <int> dq;\\n        string res;\\n        int count=0;\\n        for (int i=0; i<s.size(); i++) {\\n            if (s[i]==\\'(\\' || s[i]==\\')\\') {\\n                if (s[i]==\\'(\\') count++, dq.push_back(i);\\n                else if (count==0 && s[i]==\\')\\') dq.push_back(i);\\n                else if (s[i]==\\')\\') count--, dq.pop_back();\\n            }\\n        }\\n        for (int i=0; i<s.size(); i++) {\\n        if (!dq.empty() && i==dq.front()) dq.pop_front();\\n        else res+=s[i];\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Stack, but smarter**\\n*Time Complexity: O (n)\\nSpace Complexity: O(n)*\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack <int> stk;\\n        string res;\\n        for (int i=0; i<s.size(); i++) {\\n            if (s[i]==\\'(\\' || s[i]==\\')\\') {\\n                if (s[i]==\\'(\\') stk.push(i);\\n                else if (!stk.empty() && s[i]==\\')\\') stk.pop();\\n                else if (s[i]==\\')\\') s[i]=\\'#\\'; //We are making our close brackets as invalid\\n            }\\n        }\\n        while (!stk.empty()) {\\n            s[stk.top()]=\\'#\\';\\n            stk.pop();\\n        } //This loop marked open invalid brackets\\n        for (int i=0; i<s.size(); i++) {\\n            if (s[i]!=\\'#\\') res+=s[i];\\n        }\\n        return res;\\n    }\\n};\\n```\\n**No extra space**\\n*Time Complexity: O (n)\\nSpace Complexity: O(1)* \\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        string res;\\n        int count=0, i=0;\\n        for (i=0; i<s.size(); i++) {\\n            if (s[i]==\\'(\\' || s[i]==\\')\\') {\\n                if (s[i]==\\'(\\') count++;\\n                else if (count==0 && s[i]==\\')\\') s[i]=\\'#\\';\\n                else if (s[i]==\\')\\') count--;\\n            }\\n        }\\n\\t\\t\\t\\t//By now we ar done marking our close brackets as invalid\\n        i=s.size()-1; //We are now marking our invalid open brackets.\\n        cout<<s;\\n        while (count>0) {\\n            if (s[i]==\\'(\\') s[i]=\\'#\\', count--; \\n            i--;\\n        }\\n        for (int i=0; i<s.size(); i++) {\\n            if (s[i]!=\\'#\\') res+=s[i];\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        deque <pair<int, char>> dq;\\n        string res;\\n        for (int i=0; i<s.size(); i++) {\\n            if (!dq.empty() && dq.back().second==\\'(\\' && s[i]==\\')\\') dq.pop_back();\\n            else if (s[i]==\\'(\\' || s[i]==\\')\\') dq.push_back({i, s[i]});\\n        }\\n        \\n        for (int i=0; i<s.size(); i++) {\\n        if (!dq.empty() && i==dq.front().first) dq.pop_front();\\n        else res+=s[i];\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        deque <int> dq;\\n        string res;\\n        int count=0;\\n        for (int i=0; i<s.size(); i++) {\\n            if (s[i]==\\'(\\' || s[i]==\\')\\') {\\n                if (s[i]==\\'(\\') count++, dq.push_back(i);\\n                else if (count==0 && s[i]==\\')\\') dq.push_back(i);\\n                else if (s[i]==\\')\\') count--, dq.pop_back();\\n            }\\n        }\\n        for (int i=0; i<s.size(); i++) {\\n        if (!dq.empty() && i==dq.front()) dq.pop_front();\\n        else res+=s[i];\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack <int> stk;\\n        string res;\\n        for (int i=0; i<s.size(); i++) {\\n            if (s[i]==\\'(\\' || s[i]==\\')\\') {\\n                if (s[i]==\\'(\\') stk.push(i);\\n                else if (!stk.empty() && s[i]==\\')\\') stk.pop();\\n                else if (s[i]==\\')\\') s[i]=\\'#\\'; //We are making our close brackets as invalid\\n            }\\n        }\\n        while (!stk.empty()) {\\n            s[stk.top()]=\\'#\\';\\n            stk.pop();\\n        } //This loop marked open invalid brackets\\n        for (int i=0; i<s.size(); i++) {\\n            if (s[i]!=\\'#\\') res+=s[i];\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        string res;\\n        int count=0, i=0;\\n        for (i=0; i<s.size(); i++) {\\n            if (s[i]==\\'(\\' || s[i]==\\')\\') {\\n                if (s[i]==\\'(\\') count++;\\n                else if (count==0 && s[i]==\\')\\') s[i]=\\'#\\';\\n                else if (s[i]==\\')\\') count--;\\n            }\\n        }\\n\\t\\t\\t\\t//By now we ar done marking our close brackets as invalid\\n        i=s.size()-1; //We are now marking our invalid open brackets.\\n        cout<<s;\\n        while (count>0) {\\n            if (s[i]==\\'(\\') s[i]=\\'#\\', count--; \\n            i--;\\n        }\\n        for (int i=0; i<s.size(); i++) {\\n            if (s[i]!=\\'#\\') res+=s[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 830950,
                "title": "check-out-my-simple-c-solution-using-stack",
                "content": "```\\npublic class Solution {\\n           public  string MinRemoveToMakeValid(string s)\\n        {\\n            Stack<int> stack = new Stack<int>();\\n            StringBuilder validString = new StringBuilder(\"\");\\n            int lastIndex = 0;\\n            for (int i = 0; i < s.Length; i++)\\n            {\\n                if (s[i] == \\')\\' && stack.Count == 0)    //removing closing Parentheses (never opened ones)\\n                    continue;\\n                \\n                if (s[i] == \\')\\')\\n                    stack.Pop();\\n                \\n                if (s[i] == \\'(\\')\\n                    stack.Push(lastIndex);\\n\\n                validString.Append(s[i]);\\n                lastIndex++;\\n            }\\n               \\n            //removing unclosedBrackets\\n            if (stack.Count != 0)\\n            {\\n                while (stack.Count != 0)\\n                {\\n                    validString = validString.Remove(stack.Pop(), 1);\\n                }\\n            }\\n               \\n            return validString.ToString();\\n        }\\n}\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\npublic class Solution {\\n           public  string MinRemoveToMakeValid(string s)\\n        {\\n            Stack<int> stack = new Stack<int>();\\n            StringBuilder validString = new StringBuilder(\"\");\\n            int lastIndex = 0;\\n            for (int i = 0; i < s.Length; i++)\\n            {\\n                if (s[i] == \\')\\' && stack.Count == 0)    //removing closing Parentheses (never opened ones)\\n                    continue;\\n                \\n                if (s[i] == \\')\\')\\n                    stack.Pop();\\n                \\n                if (s[i] == \\'(\\')\\n                    stack.Push(lastIndex);\\n\\n                validString.Append(s[i]);\\n                lastIndex++;\\n            }\\n               \\n            //removing unclosedBrackets\\n            if (stack.Count != 0)\\n            {\\n                while (stack.Count != 0)\\n                {\\n                    validString = validString.Remove(stack.Pop(), 1);\\n                }\\n            }\\n               \\n            return validString.ToString();\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 668577,
                "title": "95-100-python-3-with-comments",
                "content": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        #convert s into a list just for convenience (we can directly mutate s now)\\n        s = list(s)\\n        #stores indices of leftover left parentheses\\n        left = []\\n        #stores indices of leftover right parentheses\\n        right = []\\n        #We only have to process the parentheses:\\n        #Case 1: \"(\"\\n            #We will simply add to the left stack to pop in case we find a right parentheses\\n        #Case 2: \")\"\\n            #If we have any left parentheses to pop, we will pop them, effectively \"removing\" this pair\\n            #of parentheses (If this was Tetris, we have successfully made a row to delete. All that\\n            #matters is that we don\\'t have to worry about this pair of parentheses anymore)\\n            \\n            #If we don\\'t have any more left parentheses to pop, then we will have to remove this right parentheses\\n            #We add it to the right stack in order to remember its index\\n        for i in range(len(s)):\\n            if s[i] == \"(\": \\n                left.append(i)\\n            elif s[i] == \")\":\\n                if left: \\n                    left.pop()\\n                else:\\n                    right.append(i)\\n    \\n        #We remove all stray left and right parentheses in O(1) time because s is now mutable\\n        for index in left: \\n            s[index] = \"\"\\n        for index in right: \\n            s[index] = \"\"\\n        #Remember to convert s back into a string\\n        return \"\".join(s)\\n                    \\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        #convert s into a list just for convenience (we can directly mutate s now)\\n        s = list(s)\\n        #stores indices of leftover left parentheses\\n        left = []\\n        #stores indices of leftover right parentheses\\n        right = []\\n        #We only have to process the parentheses:\\n        #Case 1: \"(\"\\n            #We will simply add to the left stack to pop in case we find a right parentheses\\n        #Case 2: \")\"\\n            #If we have any left parentheses to pop, we will pop them, effectively \"removing\" this pair\\n            #of parentheses (If this was Tetris, we have successfully made a row to delete. All that\\n            #matters is that we don\\'t have to worry about this pair of parentheses anymore)\\n            \\n            #If we don\\'t have any more left parentheses to pop, then we will have to remove this right parentheses\\n            #We add it to the right stack in order to remember its index\\n        for i in range(len(s)):\\n            if s[i] == \"(\": \\n                left.append(i)\\n            elif s[i] == \")\":\\n                if left: \\n                    left.pop()\\n                else:\\n                    right.append(i)\\n    \\n        #We remove all stray left and right parentheses in O(1) time because s is now mutable\\n        for index in left: \\n            s[index] = \"\"\\n        for index in right: \\n            s[index] = \"\"\\n        #Remember to convert s back into a string\\n        return \"\".join(s)\\n                    \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 649015,
                "title": "javascript-solution",
                "content": "> Runtime: 96 ms, faster than 59.60% of JavaScript online submissions for Minimum Remove to Make Valid Parentheses.\\nMemory Usage: 42.6 MB, less than 100.00% of JavaScript online submissions for Minimum Remove to Make Valid Parentheses.\\n\\n```js\\nvar minRemoveToMakeValid = function(s) {\\n    const sArr = s.split(\\'\\')\\n    let stack=0\\n    for(let i=0;i<sArr.length;i++) {\\n        if (sArr[i]==\\'(\\') {\\n            stack++\\n        }else if (sArr[i]==\\')\\') {\\n            if (stack<1) {\\n                sArr.splice(i, 1)\\n                i--\\n            }else{\\n                stack--\\n            }\\n        }\\n    }\\n    while(stack>0) {\\n        let i = sArr.lastIndexOf(\\'(\\')\\n        sArr.splice(i,1)\\n        stack--\\n    }\\n    return sArr.join(\\'\\')\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar minRemoveToMakeValid = function(s) {\\n    const sArr = s.split(\\'\\')\\n    let stack=0\\n    for(let i=0;i<sArr.length;i++) {\\n        if (sArr[i]==\\'(\\') {\\n            stack++\\n        }else if (sArr[i]==\\')\\') {\\n            if (stack<1) {\\n                sArr.splice(i, 1)\\n                i--\\n            }else{\\n                stack--\\n            }\\n        }\\n    }\\n    while(stack>0) {\\n        let i = sArr.lastIndexOf(\\'(\\')\\n        sArr.splice(i,1)\\n        stack--\\n    }\\n    return sArr.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 551239,
                "title": "c-solution-without-stack",
                "content": "class Solution {\\npublic:\\n\\n    string minRemoveToMakeValid(string s) {\\n      string str=\"\";int open=0;\\n    //Removing the not required \")\"\\n      for(int i=0;i<s.length();i++)\\n      {\\n          if(s[i]==\\')\\'&&open==0)\\n              s[i]=\\'#\\';\\n          else if(s[i]==\\')\\')\\n              open--;\\n          else if(s[i]==\\'(\\')\\n              open++;\\n       }\\n      //Removing the not required \"(\" from backward as we do not want to remove the valid pairs \\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n          if(open>0&&s[i]==\\'(\\')\\n          {\\n              s[i]=\\'#\\';\\n              open--;\\n          }\\n          if(open==0) break;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n          if(s[i]!=\\'#\\')\\n          str+=s[i];\\n        }\\n       return str;       \\n      }\\n      \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    string minRemoveToMakeValid(string s) {\\n      string str=\"\";int open=0;\\n    //Removing the not required \")\"\\n      for(int i=0;i<s.length();i++)\\n      {\\n          if(s[i]==\\')\\'&&open==0)\\n              s[i]=\\'#\\';\\n          else if(s[i]==\\')\\')\\n              open--;\\n          else if(s[i]==\\'(\\')\\n              open++;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 532418,
                "title": "java-my-easy-solution-without-stack-o-n",
                "content": "```\\npublic String minRemoveToMakeValid(String s) {\\n\\tStringBuilder sb = new StringBuilder();\\n\\tint open = 0;\\n\\tfor(char c : s.toCharArray()) {\\n\\t\\tif(c==\\')\\') {\\n\\t\\t\\tif(open == 0) continue;\\n\\t\\t\\topen--;\\n\\t\\t} else if(c == \\'(\\') {\\n\\t\\t\\topen++;\\n\\t\\t} \\n\\t\\tsb.append(c);\\n\\t}\\n\\t\\n\\tif(open == 0) return sb.toString();\\n\\t\\n\\tStringBuilder sol = new StringBuilder();\\n\\tfor(int i = sb.length()-1; i>=0; i--) {\\n\\t\\tif(sb.charAt(i) == \\'(\\' && open-- > 0) continue;\\n\\t\\telse sol.append(sb.charAt(i));\\n\\t} \\n\\treturn sol.reverse().toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String minRemoveToMakeValid(String s) {\\n\\tStringBuilder sb = new StringBuilder();\\n\\tint open = 0;\\n\\tfor(char c : s.toCharArray()) {\\n\\t\\tif(c==\\')\\') {\\n\\t\\t\\tif(open == 0) continue;\\n\\t\\t\\topen--;\\n\\t\\t} else if(c == \\'(\\') {\\n\\t\\t\\topen++;\\n\\t\\t} \\n\\t\\tsb.append(c);\\n\\t}\\n\\t\\n\\tif(open == 0) return sb.toString();\\n\\t\\n\\tStringBuilder sol = new StringBuilder();\\n\\tfor(int i = sb.length()-1; i>=0; i--) {\\n\\t\\tif(sb.charAt(i) == \\'(\\' && open-- > 0) continue;\\n\\t\\telse sol.append(sb.charAt(i));\\n\\t} \\n\\treturn sol.reverse().toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525960,
                "title": "very-simple-java-stack-solution-o-n-with-explanation",
                "content": "The idea is to use a stack to store indexes of invalid parentheses, because we need to remove those parentheses to make the string valid.\\nIdea is same as:\\nhttps://leetcode.com/problems/longest-valid-parentheses/discuss/525900/JAVA-simple-stack-solution-O(n)-with-explanation\\nhttps://leetcode.com/problems/minimum-add-to-make-parentheses-valid/discuss/525953/JAVA-one-pass-stack-solution-with-explanation\\n\\n```\\n    public String minRemoveToMakeValid(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') {\\n                stack.push(i);\\n            } else if (c == \\')\\') {\\n                if (!stack.isEmpty() && s.charAt(stack.peek()) == \\'(\\') {\\n                    stack.pop();\\n                } else {\\n                    stack.push(i);\\n                }\\n            }\\n        }\\n        Set<Integer> invalidIndexes = new HashSet<>(stack);\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (invalidIndexes.contains(i)) continue;\\n            sb.append(s.charAt(i));\\n        }\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String minRemoveToMakeValid(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') {\\n                stack.push(i);\\n            } else if (c == \\')\\') {\\n                if (!stack.isEmpty() && s.charAt(stack.peek()) == \\'(\\') {\\n                    stack.pop();\\n                } else {\\n                    stack.push(i);\\n                }\\n            }\\n        }\\n        Set<Integer> invalidIndexes = new HashSet<>(stack);\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (invalidIndexes.contains(i)) continue;\\n            sb.append(s.charAt(i));\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 524076,
                "title": "c-clean-readable-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int balance = 0;\\n        //scan from left to right\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] == \\'(\\')\\n                balance++;\\n            else if (s[i] == \\')\\') {\\n                balance--;\\n                if (balance < 0) {\\n                    s[i] = \\'#\\';\\n                    balance = 0;\\n                }\\n            }\\n        }\\n        \\n        balance = 0;\\n        //scan from right to left\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            if (s[i] == \\')\\')\\n                balance++;\\n            else if (s[i] == \\'(\\') {\\n                balance--;\\n                if (balance < 0) {\\n                    s[i] = \\'#\\';\\n                    balance = 0;                   \\n                }\\n            } \\n        }\\n        \\n        string result;\\n        for (auto &ch : s)\\n            if (ch != \\'#\\')\\n                result += ch;\\n        \\n        return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int balance = 0;\\n        //scan from left to right\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] == \\'(\\')\\n                balance++;\\n            else if (s[i] == \\')\\') {\\n                balance--;\\n                if (balance < 0) {\\n                    s[i] = \\'#\\';\\n                    balance = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 474578,
                "title": "c-first-practice-in-2020",
                "content": "January 8, 2020\\n1249. Minimum Remove to Make Valid Parentheses\\n\\nI took a more than three weeks break and it is the first algorithm I like to solve in 2020. I like to solve 240 algorithms in 2020. This is my first one. \\n\\n**Case study**\\nIn order for me to solve the algorithm, I learn that I have to put two test cases into consideration. \\nCase 1: lee(t(c)o)de)\\nThe idea is to use stack to store all indexes of open paretheses, and if there is \\')\\', then remove matched open parethese. Otherwise replace stringbuilder temporary variable **copy** - a copy of string - using placeholder char * at index of \\')\\'. We can name it \"replace unmatched close parenthese with wildchar *\". \\n\\nlee(t(c)o)de) -> lee(t(c)o)de* -> remove * in the string. \\nput \\'(\\' in stack, and if there is matched \\')\\', then pop \\'(\\' otherwise replace stringBuilder index position with \\'*\\'.\\n\\nCase 2: ))((\\nDo not forget to pop out all chars in the stack, remove open parenthese \\'(\\' at the index position in **copy** variable. \\n\\nHere are my C# practice highlights:\\n1. C# string is immutable, so declare a StringBuilder variable to make a copy of string. \\n2. Get familiar with C# StringBuilder.Replace and Remove API, empty char has issue to use Replace, so empty string \"\" works. \\n3. Always work on my weakness, come out test cases to fully test the code by myself first. This time I missed test case ))((. I quickly fixed the bug after online judge showed me the bug with the test case ))((.  \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1249_minimumToRemove\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var result = MinRemoveToMakeValid(\"lee(t(c)o)d)e\"); \\n        }\\n\\n        /// <summary>\\n        /// lee(t(c)o)de) -> lee(t(c)o)de* -> remove * in the string\\n        /// put ( in stack, and if there is matched ), then pop ( otherwise replace stringBuilder index position with *\\n        /// </summary>\\n        /// <param name=\"s\"></param>\\n        /// <returns></returns>\\n        public static String MinRemoveToMakeValid(String s)\\n        {\\n            var sb = new StringBuilder(s);\\n            var stack = new Stack<int>();\\n\\n            var length = s.Length;\\n            for (int i = 0; i < length; i++)\\n            {\\n                var current = s[i];\\n                var isOpen = current == \\'(\\';\\n                var isClose = current == \\')\\';\\n\\n                if (isOpen)\\n                {\\n                    stack.Push(i); \\n                }\\n\\n                if (isClose)\\n                {\\n                    if (stack.Count > 0)\\n                    {\\n                        stack.Pop();\\n                    }\\n                    else\\n                    {\\n                        sb.Replace(\\')\\',\\'*\\',i,1);\\n                    }\\n                }\\n            }\\n\\n            // remove extract ((, for example ))((\\n            while (stack.Count > 0)\\n            {                \\n                sb.Remove(stack.Pop(), 1); \\n            }\\n\\n            return sb.Replace(\"*\",\"\",0,sb.Length).ToString();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1249_minimumToRemove\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var result = MinRemoveToMakeValid(\"lee(t(c)o)d)e\"); \\n        }\\n\\n        /// <summary>\\n        /// lee(t(c)o)de) -> lee(t(c)o)de* -> remove * in the string\\n        /// put ( in stack, and if there is matched ), then pop ( otherwise replace stringBuilder index position with *\\n        /// </summary>\\n        /// <param name=\"s\"></param>\\n        /// <returns></returns>\\n        public static String MinRemoveToMakeValid(String s)\\n        {\\n            var sb = new StringBuilder(s);\\n            var stack = new Stack<int>();\\n\\n            var length = s.Length;\\n            for (int i = 0; i < length; i++)\\n            {\\n                var current = s[i];\\n                var isOpen = current == \\'(\\';\\n                var isClose = current == \\')\\';\\n\\n                if (isOpen)\\n                {\\n                    stack.Push(i); \\n                }\\n\\n                if (isClose)\\n                {\\n                    if (stack.Count > 0)\\n                    {\\n                        stack.Pop();\\n                    }\\n                    else\\n                    {\\n                        sb.Replace(\\')\\',\\'*\\',i,1);\\n                    }\\n                }\\n            }\\n\\n            // remove extract ((, for example ))((\\n            while (stack.Count > 0)\\n            {                \\n                sb.Remove(stack.Pop(), 1); \\n            }\\n\\n            return sb.Replace(\"*\",\"\",0,sb.Length).ToString();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441109,
                "title": "java-follow-up-we-asked-to-check-if-string-valid-with-many-different-types-of-parenthesis",
                "content": "store different parenthesis in map and set\\n```java\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        int n = s.length();\\n        Map<Character, Character> closesMap = new HashMap<>();\\n        closesMap.put(\\')\\', \\'(\\');\\n        \\n        Set<Character> opensSet = new HashSet<>();\\n        opensSet.add(\\'(\\');\\n        \\n        Stack<CharInString> stack = new Stack<>();\\n        Set<Integer> toRemove = new HashSet<>();\\n        \\n        for (int i = 0; i < n; ++i) {\\n            CharInString curr = new CharInString(s.charAt(i), i);\\n            if (closesMap.containsKey(curr.val)) {\\n                if (stack.isEmpty())\\n                    toRemove.add(i);\\n                else if (stack.peek().val != closesMap.get(curr.val))\\n                    toRemove.add(i);\\n                else\\n                    stack.pop();\\n            } else if (opensSet.contains(curr.val)) {\\n                stack.push(curr);\\n            }\\n        }\\n        \\n        if ( ! stack.isEmpty() ) {\\n            while ( ! stack.isEmpty() )\\n                toRemove.add(stack.pop().pos);\\n        }\\n        \\n        StringBuilder res = new StringBuilder();\\n        for (int i = 0; i < n; ++i)\\n            if ( ! toRemove.contains(i) )\\n                res.append(s.charAt(i));\\n                \\n        return res.toString();\\n    }\\n    \\n    private class CharInString {\\n        char val;\\n        int pos;\\n        \\n        public CharInString(char val, int pos) {\\n            this.val = val;\\n            this.pos = pos;\\n        }\\n    }\\n}\\n```\\n\\noriginal solution without follow up question\\n\\n```java\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        int n = s.length();\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        Set<Integer> toRemove = new HashSet<>();\\n        \\n        for (int i = 0; i < n; ++i) {\\n            char curr = s.charAt(i);\\n            if (curr == \\')\\') {\\n                if (stack.isEmpty())\\n                    toRemove.add(i);\\n                else\\n                    stack.pop();\\n            } else if (curr == \\'(\\') {\\n                stack.push(i);\\n            }\\n        }\\n        \\n        if ( ! stack.isEmpty() ) {\\n            while ( ! stack.isEmpty() )\\n                toRemove.add(stack.pop());\\n        }\\n        \\n        StringBuilder res = new StringBuilder();\\n        for (int i = 0; i < n; ++i)\\n            if ( ! toRemove.contains(i) )\\n                res.append(s.charAt(i));\\n                \\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        int n = s.length();\\n        Map<Character, Character> closesMap = new HashMap<>();\\n        closesMap.put(\\')\\', \\'(\\');\\n        \\n        Set<Character> opensSet = new HashSet<>();\\n        opensSet.add(\\'(\\');\\n        \\n        Stack<CharInString> stack = new Stack<>();\\n        Set<Integer> toRemove = new HashSet<>();\\n        \\n        for (int i = 0; i < n; ++i) {\\n            CharInString curr = new CharInString(s.charAt(i), i);\\n            if (closesMap.containsKey(curr.val)) {\\n                if (stack.isEmpty())\\n                    toRemove.add(i);\\n                else if (stack.peek().val != closesMap.get(curr.val))\\n                    toRemove.add(i);\\n                else\\n                    stack.pop();\\n            } else if (opensSet.contains(curr.val)) {\\n                stack.push(curr);\\n            }\\n        }\\n        \\n        if ( ! stack.isEmpty() ) {\\n            while ( ! stack.isEmpty() )\\n                toRemove.add(stack.pop().pos);\\n        }\\n        \\n        StringBuilder res = new StringBuilder();\\n        for (int i = 0; i < n; ++i)\\n            if ( ! toRemove.contains(i) )\\n                res.append(s.charAt(i));\\n                \\n        return res.toString();\\n    }\\n    \\n    private class CharInString {\\n        char val;\\n        int pos;\\n        \\n        public CharInString(char val, int pos) {\\n            this.val = val;\\n            this.pos = pos;\\n        }\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        int n = s.length();\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        Set<Integer> toRemove = new HashSet<>();\\n        \\n        for (int i = 0; i < n; ++i) {\\n            char curr = s.charAt(i);\\n            if (curr == \\')\\') {\\n                if (stack.isEmpty())\\n                    toRemove.add(i);\\n                else\\n                    stack.pop();\\n            } else if (curr == \\'(\\') {\\n                stack.push(i);\\n            }\\n        }\\n        \\n        if ( ! stack.isEmpty() ) {\\n            while ( ! stack.isEmpty() )\\n                toRemove.add(stack.pop());\\n        }\\n        \\n        StringBuilder res = new StringBuilder();\\n        for (int i = 0; i < n; ++i)\\n            if ( ! toRemove.contains(i) )\\n                res.append(s.charAt(i));\\n                \\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419622,
                "title": "python-stack-remember-invalid-indexes",
                "content": "Any unmatched right parenthese, add it into the invalid set to remove later\\nUse stack to record all left parenthese\\'s index, and remove one if a counterpart met. Add all unmacthed left parenthese in the stack into the invalid set to remove.\\n```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        removePos=set()\\n        unmatched=0\\n        lefts=[]\\n        for i,c in enumerate(s):\\n            if c==\\'(\\':\\n                unmatched+=1\\n                lefts.append(i)\\n            elif c==\\')\\':\\n                unmatched-=1\\n                if unmatched<0:\\n                    removePos.add(i)\\n                    unmatched=0\\n                else:\\n                    lefts.pop()\\n        for i in lefts:\\n            removePos.add(i)\\n        return \\'\\'.join(c for i,c in enumerate(s) if i not in removePos)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        removePos=set()\\n        unmatched=0\\n        lefts=[]\\n        for i,c in enumerate(s):\\n            if c==\\'(\\':\\n                unmatched+=1\\n                lefts.append(i)\\n            elif c==\\')\\':\\n                unmatched-=1\\n                if unmatched<0:\\n                    removePos.add(i)\\n                    unmatched=0\\n                else:\\n                    lefts.pop()\\n        for i in lefts:\\n            removePos.add(i)\\n        return \\'\\'.join(c for i,c in enumerate(s) if i not in removePos)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419517,
                "title": "simple-c-stack-solution-with-detailed-explanation",
                "content": "\\nFirst loop:\\n\\n1. if we encounter \\'(\\', then we push it to vector l\\n2. when we encounter \\')\\'\\n-> if l.size()>0, then we pop the element in l (because a pair is made)\\n-> if l.size()==0, then we add the index of \\')\\' to vector d for deletion (because no pair can be made for this \\')\\')\\n\\nAfter the loop:\\n\\u3000\\u30003. we push all the unpaired \\'(\\' into vector d for deletion after the loop\\n\\u3000\\u30004. remove the characters in the string whose index is in d\\n\\u3000\\u30005. removal should be from right to left so the current removal operation will be independent of previous ones \\n```\\nclass Solution \\n{\\n    public:\\n    string minRemoveToMakeValid(string s) \\n    {\\n        vector<int> l; //to record the left parentheses not paired\\n        vector<int> d; //to record the index for deletion in the string\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                l.push_back(i);\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                if(l.size()>0)\\n                {\\n                    l.pop_back();   \\n                }\\n                else\\n                {\\n                    d.push_back(i);   \\n                }\\n            }\\n        }\\n        for(int i=0;i<l.size();i++)\\n        {\\n            d.push_back(l[i]);\\n        }\\n        reverse(d.rbegin(),d.rend());\\n        for(int i=0;i<d.size();i++)\\n        {\\n            s=s.substr(0,d[i])+s.substr(d[i]+1);   \\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    string minRemoveToMakeValid(string s) \\n    {\\n        vector<int> l; //to record the left parentheses not paired\\n        vector<int> d; //to record the index for deletion in the string\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                l.push_back(i);\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                if(l.size()>0)\\n                {\\n                    l.pop_back();   \\n                }\\n                else\\n                {\\n                    d.push_back(i);   \\n                }\\n            }\\n        }\\n        for(int i=0;i<l.size();i++)\\n        {\\n            d.push_back(l[i]);\\n        }\\n        reverse(d.rbegin(),d.rend());\\n        for(int i=0;i<d.size();i++)\\n        {\\n            s=s.substr(0,d[i])+s.substr(d[i]+1);   \\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949699,
                "title": "must-revise-problem-easy-unique-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, you can use a two-pass approach:\\n\\n1)First Pass - Remove Invalid Closing Parentheses: Iterate through the string from left to right and remove any closing parentheses \\')\\' that don\\'t have a matching opening parentheses \\'(\\'. Keep track of the indices of these characters.\\n\\n2)Second Pass - Remove Invalid Opening Parentheses: Iterate through the string from right to left. Similar to the first pass, remove any opening parentheses \\'(\\' that don\\'t have a matching closing parentheses \\')\\'. Keep track of the indices of these characters.\\n\\n3)Building the Resultant String: After the two passes, you\\'ll have the indices of characters that need to be removed to make the string valid. Construct a new string by excluding these characters.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1)First Pass - Remove Invalid Closing Parentheses:\\nInitialize an empty stack and a set to store the indices of characters to be removed.\\nTraverse through the string from left to right using the index i.\\nIf s[i] is an opening parenthesis \\'(\\', push the index i onto the stack.\\nIf s[i] is a closing parenthesis \\')\\':\\nIf the stack is empty, add the index i to the set of characters to be removed.\\nOtherwise, pop an index from the stack, indicating a valid match.\\n2)Second Pass - Remove Invalid Opening Parentheses:\\n\\nInitialize an empty stack and a set to store the indices of characters to be removed.\\nTraverse through the string from right to left using the index i.\\nIf s[i] is a closing parenthesis \\')\\', push the index i onto the stack.\\nIf s[i] is an opening parenthesis \\'(\\':\\nIf the stack is empty, add the index i to the set of characters to be removed.\\nOtherwise, pop an index from the stack, indicating a valid match.\\nBuild Resultant String:\\n\\n3)Initialize an empty list to hold the characters of the resultant string.\\nTraverse through the string s using the index i.\\nIf i is not in the set of characters to be removed, append s[i] to the resultant list.\\nReturn Result:\\n\\nConvert the list of characters to a string and return it.\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack<int>st;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(i);\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                if(st.empty())\\n                {      \\n\\n                    //STACK ME JO LAST ELEMENT BACH GAYA USKO ! SE DENOTE KIYA HAI \\n\\n                    //\\'!\\'  IS THE CHARACTER JISKO HUM STRING SE DELETE KARENGE        \\n                    s[i]=\\'!\\';           \\n                    \\n                }\\n                else\\n                {    \\n                    st.pop();\\n                }\\n            }\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            // it means the top of the stack HAS PROBLEMATIC INDEX  AND  WE NEED TO POP IT OUT FROM THE DTACK AS WELL AS THE RESULTANT STRING\\n            s[st.top()]=\\'!\\';\\n            st.pop();\\n        }\\n        \\n        //remove all \\'!\\' from string\\n        \\n        s.erase(remove(s.begin(), s.end(), \\'!\\'), s.end());\\n        return s;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack<int>st;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(i);\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                if(st.empty())\\n                {      \\n\\n                    //STACK ME JO LAST ELEMENT BACH GAYA USKO ! SE DENOTE KIYA HAI \\n\\n                    //\\'!\\'  IS THE CHARACTER JISKO HUM STRING SE DELETE KARENGE        \\n                    s[i]=\\'!\\';           \\n                    \\n                }\\n                else\\n                {    \\n                    st.pop();\\n                }\\n            }\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            // it means the top of the stack HAS PROBLEMATIC INDEX  AND  WE NEED TO POP IT OUT FROM THE DTACK AS WELL AS THE RESULTANT STRING\\n            s[st.top()]=\\'!\\';\\n            st.pop();\\n        }\\n        \\n        //remove all \\'!\\' from string\\n        \\n        s.erase(remove(s.begin(), s.end(), \\'!\\'), s.end());\\n        return s;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881043,
                "title": "using-lee-s-approach-from-another-problem-beats-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n I saw Lee\\'s amazing approach to solve [Reverse Substrings Between Each Pair of Parentheses](https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/) in O(n) which made me think that we can solve this question with a similar approach. You can also use stack<pair<char, int>> but I have used them separately so everyone can understand.\\n\\n### Do upvote if you liked the solution !\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int n = s.length();\\n        vector<int> pair(n,0);\\n        stack<int> open;\\n\\n        for(int i=0; i<n; i++){\\n            if(s[i]==\\'(\\'){\\n                open.push(i);\\n            }\\n            else if(s[i]==\\')\\'){\\n                if(!open.empty() && s[open.top()] ==\\'(\\'){ \\n                    int j = open.top();\\n                    pair[i] = j;\\n                    pair[j] = i;\\n                    open.pop();\\n                }\\n                else \\n                    open.push(i);\\n            }\\n        }\\n        \\n        while(!open.empty()){\\n            pair[open.top()] = -1;\\n            open.pop();\\n        }\\n        \\n        string ans;\\n        for(int i=0; i<n; i++){\\n            if(pair[i] >= 0)\\n                ans += s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int n = s.length();\\n        vector<int> pair(n,0);\\n        stack<int> open;\\n\\n        for(int i=0; i<n; i++){\\n            if(s[i]==\\'(\\'){\\n                open.push(i);\\n            }\\n            else if(s[i]==\\')\\'){\\n                if(!open.empty() && s[open.top()] ==\\'(\\'){ \\n                    int j = open.top();\\n                    pair[i] = j;\\n                    pair[j] = i;\\n                    open.pop();\\n                }\\n                else \\n                    open.push(i);\\n            }\\n        }\\n        \\n        while(!open.empty()){\\n            pair[open.top()] = -1;\\n            open.pop();\\n        }\\n        \\n        string ans;\\n        for(int i=0; i<n; i++){\\n            if(pair[i] >= 0)\\n                ans += s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794307,
                "title": "easy-approach-stack-pair-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        \\n        stack<pair<char,int>>st;\\n        \\n        string ans=\"\";\\n        \\n        set<int>Intset;\\n        \\n        for(int i=0;i<s.size();i++){\\n            \\n              if(s[i]==\\')\\' || s[i]==\\'(\\'){\\n                  \\n                  if(st.empty()){\\n                      st.push({s[i],i});\\n                  }else if(st.top().first==\\'(\\' && s[i]==\\')\\'){ \\n                      st.pop();\\n                  }else{\\n                      st.push({s[i],i});\\n                  }\\n              }\\n        }\\n      \\n        \\n        while(!st.empty()){\\n            int val=st.top().second;\\n            Intset.insert(val);\\n            st.pop();\\n        }\\n        \\n        for(int i=0;i<s.size();i++){\\n            \\n             if(Intset.find(i)==Intset.end())ans+=s[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        \\n        stack<pair<char,int>>st;\\n        \\n        string ans=\"\";\\n        \\n        set<int>Intset;\\n        \\n        for(int i=0;i<s.size();i++){\\n            \\n              if(s[i]==\\')\\' || s[i]==\\'(\\'){\\n                  \\n                  if(st.empty()){\\n                      st.push({s[i],i});\\n                  }else if(st.top().first==\\'(\\' && s[i]==\\')\\'){ \\n                      st.pop();\\n                  }else{\\n                      st.push({s[i],i});\\n                  }\\n              }\\n        }\\n      \\n        \\n        while(!st.empty()){\\n            int val=st.top().second;\\n            Intset.insert(val);\\n            st.pop();\\n        }\\n        \\n        for(int i=0;i<s.size();i++){\\n            \\n             if(Intset.find(i)==Intset.end())ans+=s[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331353,
                "title": "simple-c-using-stack",
                "content": "\\n# Code\\n```\\n    class Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        string ans=\"\";\\n        stack<pair<char,int>>st;\\n\\n        set<int>set1;\\n\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(\\'a\\'<=s[i] && s[i]<=\\'z\\' )\\n            {\\n                continue;\\n            }\\n            else if(s[i]==\\'(\\')\\n            {\\n                st.push({\\'(\\',i});\\n            }\\n            else\\n            {\\n                if(st.empty())\\n                {\\n                    set1.insert(i);\\n                }\\n                else\\n                {\\n                    st.pop();\\n                }\\n            }\\n        }\\n\\n        while(!st.empty())\\n        {\\n            set1.insert(st.top().second);\\n            st.pop();\\n        }\\n\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(!set1.count(i))\\n            {\\n                ans+=s[i];\\n            }\\n        }\\n\\n\\n\\n      return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    class Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        string ans=\"\";\\n        stack<pair<char,int>>st;\\n\\n        set<int>set1;\\n\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(\\'a\\'<=s[i] && s[i]<=\\'z\\' )\\n            {\\n                continue;\\n            }\\n            else if(s[i]==\\'(\\')\\n            {\\n                st.push({\\'(\\',i});\\n            }\\n            else\\n            {\\n                if(st.empty())\\n                {\\n                    set1.insert(i);\\n                }\\n                else\\n                {\\n                    st.pop();\\n                }\\n            }\\n        }\\n\\n        while(!st.empty())\\n        {\\n            set1.insert(st.top().second);\\n            st.pop();\\n        }\\n\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(!set1.count(i))\\n            {\\n                ans+=s[i];\\n            }\\n        }\\n\\n\\n\\n      return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321694,
                "title": "easy-cpp-code-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# **Please upvote the solution if you like it.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe function uses a stack to keep track of the positions of opening and closing parentheses. It iterates through the input string and pushes a pair of the current character and its index onto the stack if the current character is \\'(\\'. If the current character is \\')\\', the function checks if the stack is not empty and the top of the stack contains \\'(\\'. If so, the function pops the top of the stack. Otherwise, it pushes a pair of \\')\\' and its index onto the stack.\\n\\nAfter iterating through the input string, the function constructs a new string by iterating through the input string again in reverse order. If the current index matches the index of a closing parenthesis on top of the stack, the function skips adding the character to the new string. Otherwise, the function adds the character to the new string. Finally, the new string is reversed to obtain the desired output.\\n\\nThe ios_base::sync_with_stdio(false); line is used to optimize input/output operations by disabling the synchronization between the standard input/output streams of C++ and the corresponding C streams. This can lead to a performance improvement in certain situations.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        ios_base::sync_with_stdio(false);\\n        stack<pair<char,int>> st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(make_pair(\\'(\\',i));\\n            }\\n            if(s[i]==\\')\\'){\\n                if(!st.empty() && st.top().first==\\'(\\'){\\n                    st.pop();\\n                }\\n                else{\\n                    st.push(make_pair(\\')\\',i));\\n                }\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i=s.length()-1;i>=0;i--){\\n            if(!st.empty() && i==st.top().second){\\n                st.pop();\\n                continue;\\n            }\\n            ans.push_back(s[i]);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        ios_base::sync_with_stdio(false);\\n        stack<pair<char,int>> st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(make_pair(\\'(\\',i));\\n            }\\n            if(s[i]==\\')\\'){\\n                if(!st.empty() && st.top().first==\\'(\\'){\\n                    st.pop();\\n                }\\n                else{\\n                    st.push(make_pair(\\')\\',i));\\n                }\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i=s.length()-1;i>=0;i--){\\n            if(!st.empty() && i==st.top().second){\\n                st.pop();\\n                continue;\\n            }\\n            ans.push_back(s[i]);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076544,
                "title": "most-easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        char ch[]=s.toCharArray();\\n        Stack<Integer>st=new Stack<>();\\n        for(int i=0;i<ch.length;i++){\\n            if(ch[i]==\\'(\\' || ch[i]==\\')\\'){\\n                if(ch[i]==\\'(\\')\\n                    st.push(i);\\n                else if(ch[i]==\\')\\' && !st.isEmpty()){\\n                    st.pop();\\n                }\\n                else{\\n                    ch[i]=\\'@\\';\\n                }\\n            }\\n\\n        }\\n        while(!st.isEmpty()){\\n            ch[st.pop()]=\\'@\\';\\n        }\\n        String ans=\"\";\\n        for(int i=0;i<ch.length;i++){\\n            if(ch[i]!=\\'@\\'){\\n                ans+=ch[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        char ch[]=s.toCharArray();\\n        Stack<Integer>st=new Stack<>();\\n        for(int i=0;i<ch.length;i++){\\n            if(ch[i]==\\'(\\' || ch[i]==\\')\\'){\\n                if(ch[i]==\\'(\\')\\n                    st.push(i);\\n                else if(ch[i]==\\')\\' && !st.isEmpty()){\\n                    st.pop();\\n                }\\n                else{\\n                    ch[i]=\\'@\\';\\n                }\\n            }\\n\\n        }\\n        while(!st.isEmpty()){\\n            ch[st.pop()]=\\'@\\';\\n        }\\n        String ans=\"\";\\n        for(int i=0;i<ch.length;i++){\\n            if(ch[i]!=\\'@\\'){\\n                ans+=ch[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071383,
                "title": "most-easy-to-understand-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n\\n        char ch[]=s.toCharArray();\\n\\n        Stack<Integer>st=new Stack<>();\\n        for(int i=0;i<ch.length;i++){\\n            if(ch[i]==\\'(\\' || ch[i]==\\')\\'){\\n                if(ch[i]==\\'(\\')\\n                    st.push(i);\\n                else if(ch[i]==\\')\\' && !st.isEmpty()){\\n                    st.pop();\\n                }\\n                else{\\n                    ch[i]=\\'@\\';\\n                }\\n            }\\n\\n        }\\n\\n        while(!st.isEmpty()){\\n            ch[st.pop()]=\\'@\\';\\n        }\\n\\n        String ans=\"\";\\n        for(int i=0;i<ch.length;i++){\\n            if(ch[i]!=\\'@\\'){\\n                ans+=ch[i];\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n\\n        char ch[]=s.toCharArray();\\n\\n        Stack<Integer>st=new Stack<>();\\n        for(int i=0;i<ch.length;i++){\\n            if(ch[i]==\\'(\\' || ch[i]==\\')\\'){\\n                if(ch[i]==\\'(\\')\\n                    st.push(i);\\n                else if(ch[i]==\\')\\' && !st.isEmpty()){\\n                    st.pop();\\n                }\\n                else{\\n                    ch[i]=\\'@\\';\\n                }\\n            }\\n\\n        }\\n\\n        while(!st.isEmpty()){\\n            ch[st.pop()]=\\'@\\';\\n        }\\n\\n        String ans=\"\";\\n        for(int i=0;i<ch.length;i++){\\n            if(ch[i]!=\\'@\\'){\\n                ans+=ch[i];\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057499,
                "title": "c-very-easy-to-understand",
                "content": "### Intution \\n- Just track all string and find out invalid parenthesis and erase it\\'s in reverse order, that\\'s it !!! \\uD83D\\uDE0A\\n\\n### Complexity\\n- Time complexity: $$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack<pair<char, int>> st;\\n        for(int i = 0; i < s.size(); i++) {\\n            char c = s[i];\\n            if(c == \\'(\\') {\\n                st.push({c, i});\\n            }else if(c == \\')\\') {\\n                if(!st.empty() && st.top().first == \\'(\\') st.pop();\\n                else st.push({c, i});\\n            }\\n        }\\n\\n        string answer = \"\";\\n        for(int i = s.size() - 1; i >= 0; i--) {\\n            if(!st.empty() && st.top().second == i) {\\n                s.erase(i, 1);\\n                st.pop();\\n            }\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack<pair<char, int>> st;\\n        for(int i = 0; i < s.size(); i++) {\\n            char c = s[i];\\n            if(c == \\'(\\') {\\n                st.push({c, i});\\n            }else if(c == \\')\\') {\\n                if(!st.empty() && st.top().first == \\'(\\') st.pop();\\n                else st.push({c, i});\\n            }\\n        }\\n\\n        string answer = \"\";\\n        for(int i = s.size() - 1; i >= 0; i--) {\\n            if(!st.empty() && st.top().second == i) {\\n                s.erase(i, 1);\\n                st.pop();\\n            }\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2863406,
                "title": "easy-understanding-c-please-upvote",
                "content": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n       stack<int>st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(i);\\n                    \\n            }\\n            else\\n                if(s[i]==\\')\\')\\n                {\\n                    if(st.empty())\\n                    {\\n                        s[i]=\\'%\\';\\n                    }\\n                    else\\n                    {\\n                        st.pop();\\n                    }\\n                }\\n        }\\n        while(!st.empty())\\n        {\\n            s[st.top()]=\\'%\\';\\n            st.pop();\\n        }\\n        s.erase(remove(s.begin(), s.end(), \\'%\\'), s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n       stack<int>st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(i);\\n                    \\n            }\\n            else\\n                if(s[i]==\\')\\')\\n                {\\n                    if(st.empty())\\n                    {\\n                        s[i]=\\'%\\';\\n                    }\\n                    else\\n                    {\\n                        st.pop();\\n                    }\\n                }\\n        }\\n        while(!st.empty())\\n        {\\n            s[st.top()]=\\'%\\';\\n            st.pop();\\n        }\\n        s.erase(remove(s.begin(), s.end(), \\'%\\'), s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804114,
                "title": "no-stack-easy-understanding-hint-solution-c",
                "content": "# Solution -->\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int count=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){\\n                count++;\\n            }\\n            else if(s[i]==\\')\\'){\\n                if(count>0) count--;\\n                else s[i]=\\'*\\';\\n            }\\n        }\\n        count=0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\')\\'){\\n                count++;\\n            }\\n            else if(s[i]==\\'(\\'){\\n                if(count>0) count--;\\n                else s[i]=\\'*\\';\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\'*\\') ans+=s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int count=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){\\n                count++;\\n            }\\n            else if(s[i]==\\')\\'){\\n                if(count>0) count--;\\n                else s[i]=\\'*\\';\\n            }\\n        }\\n        count=0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\')\\'){\\n                count++;\\n            }\\n            else if(s[i]==\\'(\\'){\\n                if(count>0) count--;\\n                else s[i]=\\'*\\';\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\'*\\') ans+=s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771621,
                "title": "simple-python-solution-o-n-time",
                "content": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n\\t\\t# store all the currently open brackets\\n        stack = []\\n\\t\\t\\n\\t\\t# Stores the resulting string as list\\n        res = []\\n\\t\\t\\n\\t\\t# Tracks the index position  of all the open brackets within the resulting list\\n        index = []\\n        for c in s:\\n\\n            if c == \\')\\' and len(stack) > 0 and stack[-1] == \"(\":\\n                res.append(c)\\n                stack.pop()\\n            elif c == \\'(\\':\\n                index.append(len(res))\\n                res.append(c)\\n                stack.append(c)\\n            elif c not in [\\'(\\', \\')\\']:\\n                res.append(c)\\n                \\n        while len(stack) > 0:\\n            res[index.pop()] = \"\"\\n            stack.pop()\\n            \\n        return \"\".join(res)\\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n\\t\\t# store all the currently open brackets\\n        stack = []\\n\\t\\t\\n\\t\\t# Stores the resulting string as list\\n        res = []\\n\\t\\t\\n\\t\\t# Tracks the index position  of all the open brackets within the resulting list\\n        index = []\\n        for c in s:\\n\\n            if c == \\')\\' and len(stack) > 0 and stack[-1] == \"(\":\\n                res.append(c)\\n                stack.pop()\\n            elif c == \\'(\\':\\n                index.append(len(res))\\n                res.append(c)\\n                stack.append(c)\\n            elif c not in [\\'(\\', \\')\\']:\\n                res.append(c)\\n                \\n        while len(stack) > 0:\\n            res[index.pop()] = \"\"\\n            stack.pop()\\n            \\n        return \"\".join(res)\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2635565,
                "title": "c-easy-solution-using-stack",
                "content": "```\\n    string minRemoveToMakeValid(string s) {\\n        stack<pair<char,int>> st;\\n        int i=0;\\n        while(i<s.size())\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push({s[i],i});  //storing the index of the parenthesis//\\n                i++;\\n            }\\n           else if(!st.empty()&&s[i]==\\')\\')\\n            {\\n                st.pop();\\n                i++;\\n            }\\n            else if(st.empty()&&s[i]==\\')\\') // empty stack means it has no opening parentheses and if closing parentheses comes that means there is no chance for it to be valid parentheses therefore we will delete it//\\n\\t\\t\\t\\n            {\\n                s.erase(i,1);\\n            }\\n            else \\n                i++;\\n        }\\n        if(!st.empty()) // we will check whether the stack is empty ,if not empty that means it contains one or more opening parentheses which does not have its corresponding closing parentheses //\\n        {\\n            while(!st.empty())\\n            {\\n                s.erase(st.top().second,1); // since we have taken the pair therefore we have the index of the       parentheses to be deleted//\\n                st.pop();\\n            }\\n        }\\n        return s;\\n    }",
                "solutionTags": [],
                "code": "```\\n    string minRemoveToMakeValid(string s) {\\n        stack<pair<char,int>> st;\\n        int i=0;\\n        while(i<s.size())\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push({s[i],i});  //storing the index of the parenthesis//\\n                i++;\\n            }\\n           else if(!st.empty()&&s[i]==\\')\\')\\n            {\\n                st.pop();\\n                i++;\\n            }\\n            else if(st.empty()&&s[i]==\\')\\') // empty stack means it has no opening parentheses and if closing parentheses comes that means there is no chance for it to be valid parentheses therefore we will delete it//\\n\\t\\t\\t\\n            {\\n                s.erase(i,1);\\n            }\\n            else \\n                i++;\\n        }\\n        if(!st.empty()) // we will check whether the stack is empty ,if not empty that means it contains one or more opening parentheses which does not have its corresponding closing parentheses //\\n        {\\n            while(!st.empty())\\n            {\\n                s.erase(st.top().second,1); // since we have taken the pair therefore we have the index of the       parentheses to be deleted//\\n                st.pop();\\n            }\\n        }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2598744,
                "title": "python-stack-o-n",
                "content": "\\tclass Solution:\\n\\t\\tdef minRemoveToMakeValid(self, s: str) -> str:\\n\\t\\t\\tstack = []\\n\\t\\t\\tcharacters = list(s)\\n        \\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif s[i] == \"(\":\\n\\t\\t\\t\\t\\tstack.append(i)\\n\\t\\t\\t\\telif s[i] == \")\":\\n\\t\\t\\t\\t\\tif stack:\\n\\t\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tcharacters[i] = \"\"\\n\\n\\t\\t\\tfor i in range(len(stack)):\\n\\t\\t\\t\\tcharacters[stack[i]] = \"\" \\n\\n\\t\\t\\treturn \"\".join(characters)",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef minRemoveToMakeValid(self, s: str) -> str:\\n\\t\\t\\tstack = []\\n\\t\\t\\tcharacters = list(s)\\n        \\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif s[i] == \"(\":\\n\\t\\t\\t\\t\\tstack.append(i)\\n\\t\\t\\t\\telif s[i] == \")\":\\n\\t\\t\\t\\t\\tif stack:\\n\\t\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tcharacters[i] = \"\"\\n\\n\\t\\t\\tfor i in range(len(stack)):\\n\\t\\t\\t\\tcharacters[stack[i]] = \"\" \\n\\n\\t\\t\\treturn \"\".join(characters)",
                "codeTag": "Java"
            },
            {
                "id": 2289799,
                "title": "very-simple-and-easy-to-understand-c-solution-with-o-n-complexity",
                "content": "<b> Up Vote if you like the solution.\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        vector<int> v;\\n        string ans = \"\";\\n        int n = s.length();\\n        //try to match a open bracket, if not matching then it will be in the list \\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'(\\') v.push_back(i);\\n            else if(s[i] == \\')\\'){\\n                if(v.size() > 0 && s[v.back()] == \\'(\\') v.pop_back();\\n                else v.push_back(i);\\n            }\\n        }\\n        //Now if any of the barces are not matched need to skip those from the string\\n        if(v.size() == 0) return s;\\n        for(int i = 0, j = 0; i < n; i++){\\n            if(j >= v.size() ) ans += s[i];\\n            else if(i != v[j]) ans += s[i];\\n            else j++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        vector<int> v;\\n        string ans = \"\";\\n        int n = s.length();\\n        //try to match a open bracket, if not matching then it will be in the list \\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'(\\') v.push_back(i);\\n            else if(s[i] == \\')\\'){\\n                if(v.size() > 0 && s[v.back()] == \\'(\\') v.pop_back();\\n                else v.push_back(i);\\n            }\\n        }\\n        //Now if any of the barces are not matched need to skip those from the string\\n        if(v.size() == 0) return s;\\n        for(int i = 0, j = 0; i < n; i++){\\n            if(j >= v.size() ) ans += s[i];\\n            else if(i != v[j]) ans += s[i];\\n            else j++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919800,
                "title": "python-o-n-solution-using-stack-clearly-explained-in-details",
                "content": "**Note that** the problem asks us to return **any valid string**, so that the only requirement is to remove the minimum number of parentheses.\\nThere could be multiple answers, and this solution gives one of them that is easy to construct.\\n\\n**The main idea is:**\\nIf we loop through the input string from left to right, **it will be invalid** if at some position, **the number of \")\" is larger than the number of \"(\"**. When it becomes invalid, we will remove that character.\\nBesides, after the looping, all **\"(\" not yet matched (left in stack)** should also be removed.\\n\\n**Initiate:**\\n**a stack** used to match \"(\" and \")\".\\n**a set** that keeps the indexes of string that should be removed.\\n\\n**Time:** O(n)\\n**Space:** O(n)\\n\\n```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        \\n        indexes_removed = set()\\n        stack = []\\n        \\n        for i, c in enumerate(s):\\n            if c not in \"()\":\\n                continue\\n            if c == \"(\":\\n                stack.append(i)\\n            else:\\n                if not stack:\\n                    indexes_removed.add(i)\\n                else:\\n                    stack.pop()\\n        \\n        stack_left = set(stack)\\n        indexes_removed = indexes_removed.union(stack_left)\\n        \\n        res = []\\n        for i, c in enumerate(s):\\n            if i in indexes_removed:\\n                continue\\n            res.append(c)\\n        \\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        \\n        indexes_removed = set()\\n        stack = []\\n        \\n        for i, c in enumerate(s):\\n            if c not in \"()\":\\n                continue\\n            if c == \"(\":\\n                stack.append(i)\\n            else:\\n                if not stack:\\n                    indexes_removed.add(i)\\n                else:\\n                    stack.pop()\\n        \\n        stack_left = set(stack)\\n        indexes_removed = indexes_removed.union(stack_left)\\n        \\n        res = []\\n        for i, c in enumerate(s):\\n            if i in indexes_removed:\\n                continue\\n            res.append(c)\\n        \\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852863,
                "title": "simple-c-stack-solution",
                "content": "- There are two approaches to paranthesis questions using stack. In this we have store the index of the paranthesis, instead of storing the the \\'(\\' in stack and checking if top===\\'(\\'. This is because we have only \\'(\\' and \\')\\', unlike the valid paranthesis question.\\n- So we store the index of the \\'(\\' paranthesis, when we encounter a \\')\\', we check if stack is empty, if stack is not empty, the \\'(\\' is valid and we pop the stack. If the stack is empty, then we mark the index of string s[i]=\\'#\\'.\\n- finally we would have marked all the invalid \\')\\' paranthesis.\\n- now we might have a invalid \\'(\\' in the end of the string, but that will be remaining in the stack.\\n* so we pop the stack until its empty and mark the corresponding index of remaining \\'(\\' as #.\\n* now we loop over the entire string and append(push_back) only the characters which are not \\'#\\' to our answer string.\\n    \\n```\\nstring minRemoveToMakeValid(string s) {\\n        string ans=\"\";\\n        stack<int> st;\\n        for(int i=0;i<s.length();++i){\\n            if(s[i]==\\'(\\') st.push(i);\\n            else if(s[i]==\\')\\'){\\n                if(st.empty()){\\n                    s[i]=\\'#\\';\\n                }\\n                else{\\n                    st.pop();\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            s[st.top()]=\\'#\\';\\n            st.pop();\\n        }\\n        for(int i=0;i<s.length();++i){\\n            if(s[i]!=\\'#\\'){\\n                ans.push_back(s[i]);\\n            }\\n        }\\n        return ans;\\n        }\\n```\\n        \\n    \\n    \\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nstring minRemoveToMakeValid(string s) {\\n        string ans=\"\";\\n        stack<int> st;\\n        for(int i=0;i<s.length();++i){\\n            if(s[i]==\\'(\\') st.push(i);\\n            else if(s[i]==\\')\\'){\\n                if(st.empty()){\\n                    s[i]=\\'#\\';\\n                }\\n                else{\\n                    st.pop();\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            s[st.top()]=\\'#\\';\\n            st.pop();\\n        }\\n        for(int i=0;i<s.length();++i){\\n            if(s[i]!=\\'#\\'){\\n                ans.push_back(s[i]);\\n            }\\n        }\\n        return ans;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1852833,
                "title": "c-counting-valid-pairs-of-parenthesis",
                "content": "```\\n string minRemoveToMakeValid(string s) {\\n        stack<char> st;\\n        int count=0;\\n        for(char ch:s){\\n            if(ch==\\'(\\'){\\n                st.push(ch);\\n            }\\n            else if(ch==\\')\\'){\\n                if(st.size()&&st.top()==\\'(\\'){\\n                    st.pop();\\n                    count++;   // it means u got a valid pair of parenthesis i. e \"()\";\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        if(count==0){\\n            for(char ch:s){\\n                if(ch!=\\'(\\'&&ch!=\\')\\')\\n                    ans+=ch;\\n                \\n            }\\n            return ans;\\n        }\\n        int count1=0;\\n        int count2=0;\\n        for(char ch:s){\\n            if(ch==\\'(\\'){\\n                if(count1<count){\\n                ans+=ch;\\n                count1++;\\n                }\\n            }\\n            else if(ch==\\')\\'){\\n                if(count2<count&&count1>count2){ // it\\'s certainly important to check if count1 is greater than count 2 coz we cannot have a closing parenthesis before opening parenthesis\\n                ans+=ch;\\n                count2++;\\n                }\\n            }\\n            else{\\n                ans+=ch;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\n string minRemoveToMakeValid(string s) {\\n        stack<char> st;\\n        int count=0;\\n        for(char ch:s){\\n            if(ch==\\'(\\'){\\n                st.push(ch);\\n            }\\n            else if(ch==\\')\\'){\\n                if(st.size()&&st.top()==\\'(\\'){\\n                    st.pop();\\n                    count++;   // it means u got a valid pair of parenthesis i. e \"()\";\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        if(count==0){\\n            for(char ch:s){\\n                if(ch!=\\'(\\'&&ch!=\\')\\')\\n                    ans+=ch;\\n                \\n            }\\n            return ans;\\n        }\\n        int count1=0;\\n        int count2=0;\\n        for(char ch:s){\\n            if(ch==\\'(\\'){\\n                if(count1<count){\\n                ans+=ch;\\n                count1++;\\n                }\\n            }\\n            else if(ch==\\')\\'){\\n                if(count2<count&&count1>count2){ // it\\'s certainly important to check if count1 is greater than count 2 coz we cannot have a closing parenthesis before opening parenthesis\\n                ans+=ch;\\n                count2++;\\n                }\\n            }\\n            else{\\n                ans+=ch;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1852423,
                "title": "java-easy-approach",
                "content": "Hey Everyone!\\nHere we will follow simple and easy approach....\\nBy looking at the Problem Statement , we came to know that we want to remove unwanted parentheses from the String and return the new String.\\nWe will use StringBuilder to Store what we want in String (i.e removing unwanted parentheses)\\nso for that \\nwe have to first Traverse the String and check\\n**if char c is equal to \\'(\\'**\\nthen we will increment open by 1.\\nhere open is the variable which will look on counting of parentheses \\'(\\' and \\')\\'\\nby doing simple check is my  number of opening parentheses is equal to my closing parentheses or not \\nif in case its more than required we will simply remove it.\\nBut we also have to check before getting closing one there must be one opening one too\\n```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int open = 0;\\n        for(char c : s.toCharArray()) {\\n            if(c ==\\'(\\') {\\n                open++;\\n            \\n            }\\n            else if(c == \\')\\') {\\n                if(open == 0) continue;\\n                open--;\\n            }\\n            sb.append(c);\\n        }\\n        \\n        StringBuilder result = new StringBuilder();\\n        for(int i=sb.length()-1 ; i>=0 ; i-- ){\\n            if(sb.charAt(i) == \\'(\\' && open-- > 0) continue;\\n            result.append(sb.charAt(i));\\n            \\n            \\n        }\\n        return result.reverse().toString(); \\n        \\n        }\\n        \\n    }\\n```\\nHope it might help!!!\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int open = 0;\\n        for(char c : s.toCharArray()) {\\n            if(c ==\\'(\\') {\\n                open++;\\n            \\n            }\\n            else if(c == \\')\\') {\\n                if(open == 0) continue;\\n                open--;\\n            }\\n            sb.append(c);\\n        }\\n        \\n        StringBuilder result = new StringBuilder();\\n        for(int i=sb.length()-1 ; i>=0 ; i-- ){\\n            if(sb.charAt(i) == \\'(\\' && open-- > 0) continue;\\n            result.append(sb.charAt(i));\\n            \\n            \\n        }\\n        return result.reverse().toString(); \\n        \\n        }\\n        \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852322,
                "title": "c-simple-code-explained-easy-to-understand",
                "content": "##### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\nstring minRemoveToMakeValid(string s) {\\n        int n= s.size();\\n        stack<int> st;\\n\\n        //just keep invalid brackets index and popping valid out of stack.\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==\\')\\') st.push(i);\\n            if(s[i]==\\'(\\')\\n                (st.size() && s[st.top()]==\\')\\')? st.pop(): st.push(i);        \\n        }\\n\\n        //reconstruct a new string by ignoring all brackets wrt their position present in stack, and keep popping them\\n        string res=\"\";\\n        for(int i=0;i<n;i++){ \\n            if(st.size() and st.top()==i) st.pop();   \\n            else res+= s[i];\\n        }\\n\\n        return res;\\n    }",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "##### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\nstring minRemoveToMakeValid(string s) {\\n        int n= s.size();\\n        stack<int> st;\\n\\n        //just keep invalid brackets index and popping valid out of stack.\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==\\')\\') st.push(i);\\n            if(s[i]==\\'(\\')\\n                (st.size() && s[st.top()]==\\')\\')? st.pop(): st.push(i);        \\n        }\\n\\n        //reconstruct a new string by ignoring all brackets wrt their position present in stack, and keep popping them\\n        string res=\"\";\\n        for(int i=0;i<n;i++){ \\n            if(st.size() and st.top()==i) st.pop();   \\n            else res+= s[i];\\n        }\\n\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1852113,
                "title": "2-java-solutions-minimum-remove-to-make-valid-parentheses-easy",
                "content": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        int count = 0;\\n        \\n        char ch[] = s.toCharArray();\\n        \\n        for(int i = 0; i < ch.length; i++){\\n            if(ch[i] == \\'(\\') count++;\\n            else if(ch[i] == \\')\\'){\\n                if(count == 0) ch[i] = \\'#\\';\\n                else count--;\\n            }\\n        }\\n        \\n        for(int i = ch.length - 1; i >= 0; i--){\\n            if(ch[i] == \\'(\\' && count > 0){\\n                ch[i] = \\'#\\';\\n                count--;\\n            }\\n            \\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = 0; i < ch.length; i++){\\n            if(ch[i] != \\'#\\') sb.append(ch[i]);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        char[] ch=s.toCharArray();\\n        Stack<Integer> st=new Stack<>();\\n        \\n        for(int i=0;i<ch.length;i++){\\n            if(ch[i]==\\'(\\') st.push(i);\\n            else if(ch[i]==\\')\\'){\\n                if(st.isEmpty()) ch[i]=\\'#\\';\\n                else st.pop();\\n            }\\n            \\n        }\\n        while(!st.isEmpty()) ch[st.pop()]=\\'#\\';\\n        \\n        StringBuffer res=new StringBuffer();\\n        \\n        for(int i=0;i<ch.length;i++){\\n            if(ch[i]!=\\'#\\'){\\n                res.append(ch[i]);\\n            }\\n        }\\n       return res.toString(); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        int count = 0;\\n        \\n        char ch[] = s.toCharArray();\\n        \\n        for(int i = 0; i < ch.length; i++){\\n            if(ch[i] == \\'(\\') count++;\\n            else if(ch[i] == \\')\\'){\\n                if(count == 0) ch[i] = \\'#\\';\\n                else count--;\\n            }\\n        }\\n        \\n        for(int i = ch.length - 1; i >= 0; i--){\\n            if(ch[i] == \\'(\\' && count > 0){\\n                ch[i] = \\'#\\';\\n                count--;\\n            }\\n            \\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = 0; i < ch.length; i++){\\n            if(ch[i] != \\'#\\') sb.append(ch[i]);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        char[] ch=s.toCharArray();\\n        Stack<Integer> st=new Stack<>();\\n        \\n        for(int i=0;i<ch.length;i++){\\n            if(ch[i]==\\'(\\') st.push(i);\\n            else if(ch[i]==\\')\\'){\\n                if(st.isEmpty()) ch[i]=\\'#\\';\\n                else st.pop();\\n            }\\n            \\n        }\\n        while(!st.isEmpty()) ch[st.pop()]=\\'#\\';\\n        \\n        StringBuffer res=new StringBuffer();\\n        \\n        for(int i=0;i<ch.length;i++){\\n            if(ch[i]!=\\'#\\'){\\n                res.append(ch[i]);\\n            }\\n        }\\n       return res.toString(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852004,
                "title": "python-easy-prefix-count",
                "content": "The approach is quite simple\\n1. To add the opening ```(```, we have to see the future, how many closing ```)``` are at right side in order to make it valid, so we count it. if we have some closing at right then only we can add the opening.\\n2. To add the closing ```)``` we have to count how many opening```(``` we had at left side waiting for closing ```)```. If no one is waiting why would we add it.\\n```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        closing, opening, ans = s.count(\\')\\'), 0, \\'\\'\\n        for i in s:\\n            if i == \\'(\\':\\n                opening += 1\\n                if opening <= closing: ans += \\'(\\'\\n            elif i == \\')\\':\\n                if opening > 0: ans += \\')\\'\\n                closing -= 1; opening -= 1\\n                if opening < 0: opening = 0\\n            else: ans += i\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```(```\n```)```\n```)```\n```(```\n```)```\n```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        closing, opening, ans = s.count(\\')\\'), 0, \\'\\'\\n        for i in s:\\n            if i == \\'(\\':\\n                opening += 1\\n                if opening <= closing: ans += \\'(\\'\\n            elif i == \\')\\':\\n                if opening > 0: ans += \\')\\'\\n                closing -= 1; opening -= 1\\n                if opening < 0: opening = 0\\n            else: ans += i\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851874,
                "title": "c-easy-faster-and-easier-guarranteed-cpp-stack-with-line-by-line-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string &s) {\\n        stack<pair<int,char>> st;\\n\\t\\t//created a pair of stack to store index and \\'(\\' (see valid parentheses question on stack for easy understanding)\\n        if(s.size()==0)return s; // if size of string is 0, just return it\\n        int i=0;//1st index for iterating\\n        while(i<s.size()){\\n            if(s[i]==\\'(\\'){\\n                st.push({i,\\'(\\'}); // pushing the index and \\'(\\' into stack\\n            }\\n            if(s[i]==\\')\\'){\\n                if(!st.empty()){  //if it is valid and stack is not empty,then removing the subsequent parenthesis(just like we have done in valid parentheses question)\\n                    st.pop();\\n                }\\n                else{\\n                    s.erase(i,1); //if stack is empty,no subsequent paren.., so we will remove it\\n                    i--; //on removing size of string decreases, so do i-- to consider the element which comes at the current position\\n                }\\n            }\\n            i++;\\n        }\\n        while(!st.empty()){  // if stack is not empty,so we have to remove the invalid parentheses by it\\'s index(thats why we have stored index see the test case--> \"))((\"\\n            s.erase(st.top().first,1);\\n            st.pop();\\n        }\\n        return s; // return the string finally\\n    }\\n};\\n```\\n\\nGuys please upvote, also you are welcome for any suggessions and feedback....:)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string &s) {\\n        stack<pair<int,char>> st;\\n\\t\\t//created a pair of stack to store index and \\'(\\' (see valid parentheses question on stack for easy understanding)\\n        if(s.size()==0)return s; // if size of string is 0, just return it\\n        int i=0;//1st index for iterating\\n        while(i<s.size()){\\n            if(s[i]==\\'(\\'){\\n                st.push({i,\\'(\\'}); // pushing the index and \\'(\\' into stack\\n            }\\n            if(s[i]==\\')\\'){\\n                if(!st.empty()){  //if it is valid and stack is not empty,then removing the subsequent parenthesis(just like we have done in valid parentheses question)\\n                    st.pop();\\n                }\\n                else{\\n                    s.erase(i,1); //if stack is empty,no subsequent paren.., so we will remove it\\n                    i--; //on removing size of string decreases, so do i-- to consider the element which comes at the current position\\n                }\\n            }\\n            i++;\\n        }\\n        while(!st.empty()){  // if stack is not empty,so we have to remove the invalid parentheses by it\\'s index(thats why we have stored index see the test case--> \"))((\"\\n            s.erase(st.top().first,1);\\n            st.pop();\\n        }\\n        return s; // return the string finally\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851652,
                "title": "python3-runtime-68-ms-faster-than-98-56-memory-15-1-mb-less-than-96-51",
                "content": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        s = list(s)\\n        stack = []\\n        \\n        for i, c in enumerate(s):\\n            if c == \"(\":\\n                stack.append(i)\\n            elif c == \")\":\\n                if not stack:\\n                    s[i] = \"\"\\n                else:\\n                    stack.pop()\\n                    \\n        for i in stack:\\n            s[i] = \\'\\'\\n        return \\'\\'.join(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        s = list(s)\\n        stack = []\\n        \\n        for i, c in enumerate(s):\\n            if c == \"(\":\\n                stack.append(i)\\n            elif c == \")\":\\n                if not stack:\\n                    s[i] = \"\"\\n                else:\\n                    stack.pop()\\n                    \\n        for i in stack:\\n            s[i] = \\'\\'\\n        return \\'\\'.join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851400,
                "title": "minimum-remove-to-make-valid-parentheses-without-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        string str=\"\";\\n        int l=0,n=s.size(),r=0;\\n        for(int i=0;i<n;i++)\\n            if(s[i]==\\')\\')\\n                r++;\\n        for(int i=0;i<n;i++){\\n            if(s[i]>=\\'a\\'&&s[i]<=\\'z\\')\\n                str+=s[i];\\n            else if(s[i]==\\'(\\'&&l<r){\\n                str+=s[i];\\n                l++;\\n            }\\n            else if(s[i]==\\')\\'){\\n                if(l){\\n                    str+=s[i];\\n                    l--;\\n                }\\n                r--;\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        string str=\"\";\\n        int l=0,n=s.size(),r=0;\\n        for(int i=0;i<n;i++)\\n            if(s[i]==\\')\\')\\n                r++;\\n        for(int i=0;i<n;i++){\\n            if(s[i]>=\\'a\\'&&s[i]<=\\'z\\')\\n                str+=s[i];\\n            else if(s[i]==\\'(\\'&&l<r){\\n                str+=s[i];\\n                l++;\\n            }\\n            else if(s[i]==\\')\\'){\\n                if(l){\\n                    str+=s[i];\\n                    l--;\\n                }\\n                r--;\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851210,
                "title": "easiest-approach-just-check",
                "content": "```\\n//please upvote, if you like my solution :)\\nstring minRemoveToMakeValid(string s) {\\n        stack<char> st;\\n        string ans = \"\";\\n        for(int i=0;i<s.size();i++){\\n            if(isalpha(s[i]) || s[i] == \\'(\\'){       \\n                ans += s[i];\\n                if(s[i] == \\'(\\'){\\n                    st.push(\\'(\\');\\n                }\\n            }else if(s[i] == \\')\\'){\\n                    if(!st.empty() && st.top() == \\'(\\'){\\n                        ans += s[i];\\n                        st.pop();\\n                    }else if(st.empty()){\\n                        continue;\\n                    }\\n                }\\n            }\\n        string ret = \"\";\\n        if(!st.size()) {return ans;}\\n        int i;\\n        if(st.size()){\\n            for(i=ans.size()-1;i>=0;i--){\\n                if(st.empty()) break;\\n                if(ans[i] != \\'(\\')\\n                    ret += ans[i];\\n                else st.pop(); \\n            }\\n        }\\n        while(i!=-1){\\n            ret += ans[i];\\n            i--;\\n        }\\n        reverse(ret.begin(),ret.end());\\n        return ret;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "String",
                    "Stack"
                ],
                "code": "```\\n//please upvote, if you like my solution :)\\nstring minRemoveToMakeValid(string s) {\\n        stack<char> st;\\n        string ans = \"\";\\n        for(int i=0;i<s.size();i++){\\n            if(isalpha(s[i]) || s[i] == \\'(\\'){       \\n                ans += s[i];\\n                if(s[i] == \\'(\\'){\\n                    st.push(\\'(\\');\\n                }\\n            }else if(s[i] == \\')\\'){\\n                    if(!st.empty() && st.top() == \\'(\\'){\\n                        ans += s[i];\\n                        st.pop();\\n                    }else if(st.empty()){\\n                        continue;\\n                    }\\n                }\\n            }\\n        string ret = \"\";\\n        if(!st.size()) {return ans;}\\n        int i;\\n        if(st.size()){\\n            for(i=ans.size()-1;i>=0;i--){\\n                if(st.empty()) break;\\n                if(ans[i] != \\'(\\')\\n                    ret += ans[i];\\n                else st.pop(); \\n            }\\n        }\\n        while(i!=-1){\\n            ret += ans[i];\\n            i--;\\n        }\\n        reverse(ret.begin(),ret.end());\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1851145,
                "title": "python-go-2-different-solutions-and-explanations",
                "content": "**\\uD83D\\uDC46Please UPVOTE it if you find my soulutions are useful \\uD83D\\uDC46 Feel free to ask any question**\\n# [Python/GO] \\uD83C\\uDF1F 2 Different Solutions and Explanations \\uD83D\\uDC95\\n## 1\\uFE0F\\u20E3 Stack Approach:\\nIn this approach, we use **index** for every char in string to store in stack and nonValidIdx. Below is my algorithm.\\n\\n**Algo**\\n1. Iterate through string\\n\\t* If char == \"(\", append its idx into stack\\n\\t* If char == \")\", check if stack is empty. If it\\'s empty add its idx in nonValidIdx\\n2. Pop out all remaining idx in stack and add it in nonValidIdx\\n3. Create a res list, and iterate through string, if char not in nonValidIdx append it in res\\n4. Return \"\".join(res)\\n## Complexity Analysis\\n* Time: O(N)\\n* Space: O(N): Stack may take O(N/2) at worst, and nonValidIdx is same.\\n\\n## Code\\n\\n**Python**\\n```python\\n# O(N) | O(N)\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        stack = []\\n        nonValidIdx = set()\\n        # Find invalid \")\" store in nonValidIdx\\n        for idx, char in enumerate(s):\\n            if char == \"(\":\\n                stack.append(idx)\\n            elif char == \")\":\\n                if stack:\\n                    stack.pop()\\n                else:\\n                    nonValidIdx.add(idx)\\n        # If stack != empty, remaining \"(\" is nonValidIdx\\n        for idx in stack:\\n            nonValidIdx.add(idx)\\n            \\n        # Create result list\\n        res = []\\n        for idx, char in enumerate(s):\\n            if idx not in nonValidIdx:\\n                res.append(char)\\n                \\n        return \"\".join(res)\\n```\\n**Go**\\n```go\\n// O(N) | O(N)\\nfunc minRemoveToMakeValid(s string) string {\\n    idxStack := make([]int, 0)\\n    nonValidIdx := make(map[int]bool)\\n    \\n    // Find invalid \")\" store in nonValidIdx\\n    for idx, char := range(s){\\n        if char == \\'(\\'{\\n            idxStack = append(idxStack, idx)\\n        } else if char == \\')\\'{\\n            if len(idxStack) != 0{\\n                idxStack = idxStack[:len(idxStack) - 1]\\n            } else {\\n                nonValidIdx[idx] = true\\n            }\\n        }\\n    }\\n    // If stack != empty, remaining \"(\" is nonValidIdx\\n    for len(idxStack) != 0{\\n        nonValidIdx[idxStack[len(idxStack) - 1]] = true\\n        idxStack = idxStack[:len(idxStack) - 1]\\n    }\\n    \\n    // Create result slice of rune\\n    res := make([]rune, 0)\\n    for idx, char := range(s){\\n        if _ , found := nonValidIdx[idx]; found{\\n            continue\\n        }\\n        res = append(res, char)\\n    }\\n    return string(res) \\n}\\n```\\n\\n## 2\\uFE0F\\u20E3 No Extra Space Solution Approach:\\nWe can easily count all opening \"(\" into a count var. And then we see \")\" decrease count by 1. If count == 0, we simply don\\'t add current char in res\\nAfter pop out all invalid \")\" we can apply same technique in reverse way.\\n**Algo**\\n1. Iterate through string\\n\\t* if char == \"(\", make count += 1, append it in res\\n\\t* if char == \")\", check if count >0, if so count -= 1 else continue, don\\'t add the invalid \")\" in result\\n\\t* Append all other char in res\\n2. If count > 0, means we have invalid (. So Iterate through reversed string\\n\\t* if char == \")\", make count += 1, append it in res\\n\\t* if char == \"(\", check if count >0, if so count -= 1 else continue, don\\'t add the invalid \")\" in result\\n\\t* Append all other char in res\\n3. Return \"\".join(res)\\n## Complexity Analysis\\n* Time: O(N): Iterate forward and backword both taks O(N)\\n* Space: O(N): Althrough we didn\\'t use stack, but output res still O(N)\\n\\n## Code\\n\\n**Python**\\n```python\\n# O(N) | O(N)\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        count = 0\\n        res = []\\n        # Poping \")\"\\n        for char in s:\\n            if char == \")\":\\n                if count > 0:\\n                    count -= 1\\n                else:\\n                    continue\\n            elif char == \"(\":\\n                count += 1\\n            res.append(char)\\n        # Popping \"(\" if count > 0\\n        if count > 0:\\n            count = 0\\n            for i in range(len(res))[::-1]:\\n                if res[i] == \"(\":\\n                    if count > 0:\\n                        count -= 1\\n                    else:\\n                        res[i] = \"\"\\n                elif res[i] == \")\":\\n                    count += 1\\n                    \\n        return \"\".join(res)       \\n```\\n**Go**\\n**NOTE** : In golang we can\\'t use a empty rune to replace \"(\", so we have to renew another slice of rune to store final result\\n```go\\n// O(N) | O(N)\\nfunc minRemoveToMakeValid(s string) string {\\n    count := 0\\n    popingLeft := make([]rune, 0)\\n    // Poping \")\"\\n    for _, char := range(s){\\n        if char == \\')\\'{\\n            if count == 0{\\n                continue\\n            } else {\\n                count -= 1\\n            }\\n        } else if char == \\'(\\'{\\n            count += 1\\n        }\\n        popingLeft = append(popingLeft, char)\\n    }\\n    \\n    \\n    // Poping \"(\" if count >0 else return string(popingLeft)\\n    if count > 0{\\n        count = 0\\n        res := make([]rune, 0)\\n        for i := len(popingLeft) - 1; i > -1; i--{\\n            if popingLeft[i] == \\'(\\'{\\n                if count == 0{\\n                    continue\\n                } else {\\n                    count -=1\\n                }\\n            } else if popingLeft[i] == \\')\\'{\\n                count += 1\\n            }\\n            res = append(res, popingLeft[i])\\n        }\\n        // Reverse res\\n        for i, j := 0, len(res)-1; i < j; i, j = i+1, j-1 {\\n            res[i], res[j] = res[j], res[i]\\n        }\\n        return string(res)\\n    }else{\\n        \\n        return string(popingLeft)\\n    }\\n}\\n```\\n\\n\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [],
                "code": "```python\\n# O(N) | O(N)\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        stack = []\\n        nonValidIdx = set()\\n        # Find invalid \")\" store in nonValidIdx\\n        for idx, char in enumerate(s):\\n            if char == \"(\":\\n                stack.append(idx)\\n            elif char == \")\":\\n                if stack:\\n                    stack.pop()\\n                else:\\n                    nonValidIdx.add(idx)\\n        # If stack != empty, remaining \"(\" is nonValidIdx\\n        for idx in stack:\\n            nonValidIdx.add(idx)\\n            \\n        # Create result list\\n        res = []\\n        for idx, char in enumerate(s):\\n            if idx not in nonValidIdx:\\n                res.append(char)\\n                \\n        return \"\".join(res)\\n```\n```go\\n// O(N) | O(N)\\nfunc minRemoveToMakeValid(s string) string {\\n    idxStack := make([]int, 0)\\n    nonValidIdx := make(map[int]bool)\\n    \\n    // Find invalid \")\" store in nonValidIdx\\n    for idx, char := range(s){\\n        if char == \\'(\\'{\\n            idxStack = append(idxStack, idx)\\n        } else if char == \\')\\'{\\n            if len(idxStack) != 0{\\n                idxStack = idxStack[:len(idxStack) - 1]\\n            } else {\\n                nonValidIdx[idx] = true\\n            }\\n        }\\n    }\\n    // If stack != empty, remaining \"(\" is nonValidIdx\\n    for len(idxStack) != 0{\\n        nonValidIdx[idxStack[len(idxStack) - 1]] = true\\n        idxStack = idxStack[:len(idxStack) - 1]\\n    }\\n    \\n    // Create result slice of rune\\n    res := make([]rune, 0)\\n    for idx, char := range(s){\\n        if _ , found := nonValidIdx[idx]; found{\\n            continue\\n        }\\n        res = append(res, char)\\n    }\\n    return string(res) \\n}\\n```\n```python\\n# O(N) | O(N)\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        count = 0\\n        res = []\\n        # Poping \")\"\\n        for char in s:\\n            if char == \")\":\\n                if count > 0:\\n                    count -= 1\\n                else:\\n                    continue\\n            elif char == \"(\":\\n                count += 1\\n            res.append(char)\\n        # Popping \"(\" if count > 0\\n        if count > 0:\\n            count = 0\\n            for i in range(len(res))[::-1]:\\n                if res[i] == \"(\":\\n                    if count > 0:\\n                        count -= 1\\n                    else:\\n                        res[i] = \"\"\\n                elif res[i] == \")\":\\n                    count += 1\\n                    \\n        return \"\".join(res)       \\n```\n```go\\n// O(N) | O(N)\\nfunc minRemoveToMakeValid(s string) string {\\n    count := 0\\n    popingLeft := make([]rune, 0)\\n    // Poping \")\"\\n    for _, char := range(s){\\n        if char == \\')\\'{\\n            if count == 0{\\n                continue\\n            } else {\\n                count -= 1\\n            }\\n        } else if char == \\'(\\'{\\n            count += 1\\n        }\\n        popingLeft = append(popingLeft, char)\\n    }\\n    \\n    \\n    // Poping \"(\" if count >0 else return string(popingLeft)\\n    if count > 0{\\n        count = 0\\n        res := make([]rune, 0)\\n        for i := len(popingLeft) - 1; i > -1; i--{\\n            if popingLeft[i] == \\'(\\'{\\n                if count == 0{\\n                    continue\\n                } else {\\n                    count -=1\\n                }\\n            } else if popingLeft[i] == \\')\\'{\\n                count += 1\\n            }\\n            res = append(res, popingLeft[i])\\n        }\\n        // Reverse res\\n        for i, j := 0, len(res)-1; i < j; i, j = i+1, j-1 {\\n            res[i], res[j] = res[j], res[i]\\n        }\\n        return string(res)\\n    }else{\\n        \\n        return string(popingLeft)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850951,
                "title": "simple-java-solution",
                "content": "public String minRemoveToMakeValid(String s) {\\n        \\n        StringBuilder builder = new StringBuilder(s);\\n\\n        int counter = 0;\\n        for(int i = 0; i < builder.length(); i++){\\n            if(builder.charAt(i) == \\'(\\'){\\n                counter++;\\n            }\\n            if(builder.charAt(i) == \\')\\'){\\n                counter--;\\n                if(counter<0){\\n                    counter = 0;\\n                   builder.deleteCharAt(i);// remove invalid close parenthese\\n                    i--;\\n                }\\n            }\\n        }\\n        counter = 0;\\n        for(int i = builder.length() - 1; i >= 0; i--){\\n              if(builder.charAt(i) == \\')\\'){\\n                counter++;\\n            }\\n            if(builder.charAt(i) == \\'(\\'){\\n                counter--;\\n                if(counter<0){\\n                    counter = 0;\\n                   builder.deleteCharAt(i);// remove invalid open parenthese\\n                }\\n            }\\n        }\\n        return builder.toString();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public String minRemoveToMakeValid(String s) {\\n        \\n        StringBuilder builder = new StringBuilder(s);\\n\\n        int counter = 0;\\n        for(int i = 0; i < builder.length(); i++){\\n            if(builder.charAt(i) == \\'(\\'){\\n                counter++;\\n            }\\n            if(builder.charAt(i) == \\')\\'){\\n                counter--;\\n                if(counter<0){\\n                    counter = 0;\\n                   builder.deleteCharAt(i);// remove invalid close parenthese\\n                    i--;\\n                }\\n            }\\n        }\\n        counter = 0;\\n        for(int i = builder.length() - 1; i >= 0; i--){\\n              if(builder.charAt(i) == \\')\\'){\\n                counter++;\\n            }\\n            if(builder.charAt(i) == \\'(\\'){\\n                counter--;\\n                if(counter<0){\\n                    counter = 0;\\n                   builder.deleteCharAt(i);// remove invalid open parenthese\\n                }\\n            }\\n        }\\n        return builder.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1850838,
                "title": "c-easy-stack-solution",
                "content": "We will use stack to store extra brackets index and then remove it from string\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack<int> st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(i);                \\n            }else if(s[i]==\\')\\'){\\n                if(!st.empty() && s[st.top()]==\\'(\\')\\n                    st.pop();\\n                else\\n                    st.push({i});\\n            }\\n        }\\n        while(!st.empty()){\\n            s.erase(s.begin()+st.top());\\n            st.pop();\\n        }\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack<int> st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(i);                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1850825,
                "title": "c-3-approaches-with-comments",
                "content": "```\\nThree approaches->\\n\\nApproach 1:\\tO(N), 2 pass\\n\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack<int> st;\\n        \\n        // O(N) 1-st pass,\\n        for(int i=0; i<s.size(); i++) {\\n\\t\\t\\n            // incase of \\'(\\' pushing index \\n            if(s[i]==\\'(\\') st.push(i);\\n            // incase of \\')\\' check few conditions \\n\\t\\t\\t\\n            else if(s[i]==\\')\\') {\\n                // if stack is not empty then index value = st.top() contains \\'(\\'  at s[st.top()], \\n                // so as we found a valid pair, so we will remove that index from top of the stack\\n                if(!st.empty()) st.pop();\\n                else s[i] = \\'#\\';\\n                // but, if stack is empty then \\')\\' at s[i] have no \\'(\\' before so, we will remove this and mark as \\'#\\'\\n            }\\n        }\\n        \\n        // incase of valid parentheses the stack will be empty, but if it is not empty then remaining indices at stack are not worthy,\\n        // so we will remove this and mark as \\'#\\'\\n        while(!st.empty()) {\\n            s[st.top()] = \\'#\\';\\n            st.pop();\\n        }\\n        \\n        string res = \"\";\\n        // O(N) 2-nd pass, building final string\\n        for(int i=0; i<s.size(); i++) { \\n            if(s[i]!=\\'#\\') res.push_back(s[i]);\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\nApproach 2:\\tO(N), 2 pass\\n\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        \\n        int count;\\n        \\n        count = 0;\\n        for(int i=0; i<s.size(); i++) {\\n            \\n            // incase of \\'(\\' count opening braces\\n            if(s[i]==\\'(\\') count++;\\n            \\n            // incase of \\')\\' check few conditions \\n            else if(s[i]==\\')\\') {\\n                // if count is not 0 then it is sure that previous indices contains \\'(\\' \\n                // so as we found a valid pair, so we will decrease count\\n                if(count>0) count--;\\n                else s[i] = \\'#\\';\\n                // but, if count is 0 then \\')\\' at s[i] have no \\'(\\' before so, we will remove this and mark as \\'#\\'\\n            }\\n        }\\n        \\n        \\n        count = 0;\\n        for(int i=s.size()-1; i>=0; i--) {\\n            \\n            // incase of \\')\\' count closing braces\\n            if(s[i]==\\')\\') count++;\\n            \\n            // incase of \\'(\\' check few conditions \\n            else if(s[i]==\\'(\\') {\\n                // if count is not 0 then it is sure that previous indices from end of string contains \\')\\' \\n                // so as we found a valid pair, so we will decrease count\\n                if(count>0) count--;\\n                else s[i] = \\'#\\';\\n                // but, if count is 0 then \\'(\\' at s[i] have no \\')\\' before so, we will remove this and mark as \\'#\\'\\n            }\\n        }\\n        \\n        \\n        string res = \"\";\\n        // O(N) 2-nd pass, building final string\\n        for(int i=0; i<s.size(); i++) { \\n            if(s[i]!=\\'#\\') res.push_back(s[i]);\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\nApproach 3:\\tO(N*N), 2 pass\\n\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        vector<int> toTake(s.size(), 0); // to store which indices we will take inside final string\\n        \\n        // O(N*N) 1-st pass\\n        for(int i=0, j=0; i<s.size(); i++) {\\n            // in case of a-z take it\\n            if( s[i]>=\\'a\\' && s[i]<=\\'z\\' ) toTake[i] = 1;  \\n            else {\\n                // in case of \\'(\\' find a valid \\')\\' and take them both\\n                if( s[i]==\\'(\\' ) {\\n                    if(j<=i) j = i+1;\\n                    \\n                    while(j<s.size() && s[j]!=\\')\\') j++;\\n                    // cout<<i<<\"-\"<<j<<endl;\\n                    if(j<s.size()) {\\n                        toTake[i] = 1;\\n                        toTake[j] = 1;\\n                    }\\n                    j++;\\n                }\\n            }\\n        }\\n        \\n        \\n        string res = \"\";\\n        // O(N) 2-nd pass, building final string\\n        for(int i=0; i<s.size(); i++) { \\n            if(toTake[i]) res.push_back(s[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nThree approaches->\\n\\nApproach 1:\\tO(N), 2 pass\\n\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack<int> st;\\n        \\n        // O(N) 1-st pass,\\n        for(int i=0; i<s.size(); i++) {\\n\\t\\t\\n            // incase of \\'(\\' pushing index \\n            if(s[i]==\\'(\\') st.push(i);\\n            // incase of \\')\\' check few conditions \\n\\t\\t\\t\\n            else if(s[i]==\\')\\') {\\n                // if stack is not empty then index value = st.top() contains \\'(\\'  at s[st.top()], \\n                // so as we found a valid pair, so we will remove that index from top of the stack\\n                if(!st.empty()) st.pop();\\n                else s[i] = \\'#\\';\\n                // but, if stack is empty then \\')\\' at s[i] have no \\'(\\' before so, we will remove this and mark as \\'#\\'\\n            }\\n        }\\n        \\n        // incase of valid parentheses the stack will be empty, but if it is not empty then remaining indices at stack are not worthy,\\n        // so we will remove this and mark as \\'#\\'\\n        while(!st.empty()) {\\n            s[st.top()] = \\'#\\';\\n            st.pop();\\n        }\\n        \\n        string res = \"\";\\n        // O(N) 2-nd pass, building final string\\n        for(int i=0; i<s.size(); i++) { \\n            if(s[i]!=\\'#\\') res.push_back(s[i]);\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\nApproach 2:\\tO(N), 2 pass\\n\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        \\n        int count;\\n        \\n        count = 0;\\n        for(int i=0; i<s.size(); i++) {\\n            \\n            // incase of \\'(\\' count opening braces\\n            if(s[i]==\\'(\\') count++;\\n            \\n            // incase of \\')\\' check few conditions \\n            else if(s[i]==\\')\\') {\\n                // if count is not 0 then it is sure that previous indices contains \\'(\\' \\n                // so as we found a valid pair, so we will decrease count\\n                if(count>0) count--;\\n                else s[i] = \\'#\\';\\n                // but, if count is 0 then \\')\\' at s[i] have no \\'(\\' before so, we will remove this and mark as \\'#\\'\\n            }\\n        }\\n        \\n        \\n        count = 0;\\n        for(int i=s.size()-1; i>=0; i--) {\\n            \\n            // incase of \\')\\' count closing braces\\n            if(s[i]==\\')\\') count++;\\n            \\n            // incase of \\'(\\' check few conditions \\n            else if(s[i]==\\'(\\') {\\n                // if count is not 0 then it is sure that previous indices from end of string contains \\')\\' \\n                // so as we found a valid pair, so we will decrease count\\n                if(count>0) count--;\\n                else s[i] = \\'#\\';\\n                // but, if count is 0 then \\'(\\' at s[i] have no \\')\\' before so, we will remove this and mark as \\'#\\'\\n            }\\n        }\\n        \\n        \\n        string res = \"\";\\n        // O(N) 2-nd pass, building final string\\n        for(int i=0; i<s.size(); i++) { \\n            if(s[i]!=\\'#\\') res.push_back(s[i]);\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\nApproach 3:\\tO(N*N), 2 pass\\n\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        vector<int> toTake(s.size(), 0); // to store which indices we will take inside final string\\n        \\n        // O(N*N) 1-st pass\\n        for(int i=0, j=0; i<s.size(); i++) {\\n            // in case of a-z take it\\n            if( s[i]>=\\'a\\' && s[i]<=\\'z\\' ) toTake[i] = 1;  \\n            else {\\n                // in case of \\'(\\' find a valid \\')\\' and take them both\\n                if( s[i]==\\'(\\' ) {\\n                    if(j<=i) j = i+1;\\n                    \\n                    while(j<s.size() && s[j]!=\\')\\') j++;\\n                    // cout<<i<<\"-\"<<j<<endl;\\n                    if(j<s.size()) {\\n                        toTake[i] = 1;\\n                        toTake[j] = 1;\\n                    }\\n                    j++;\\n                }\\n            }\\n        }\\n        \\n        \\n        string res = \"\";\\n        // O(N) 2-nd pass, building final string\\n        for(int i=0; i<s.size(); i++) { \\n            if(toTake[i]) res.push_back(s[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1850613,
                "title": "c-without-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int n = s.size();\\n        vector<char> st(n);\\n        int count = 0;\\n\\t\\t// we are storing each character of the given string in a vector\\n        for(int i=0;i<n;i++)\\n        {\\n            st[i] = s[i];\\n        }\\n\\t\\t// we are checking that every opening bracket have closing bracket or not from left to right, if it not having closing bracket we will make that particular character = 0   \\n        for(int i=0;i<st.size();i++)\\n        {\\n            if(st[i] == \\'(\\')\\n                count++;\\n             else if(st[i] == \\')\\')\\n             {\\n                 if(count>0) count--;\\n                 else\\n                 {\\n                     st[i] = 0;\\n                 }\\n             }\\n        }\\n        count = 0;\\n\\t\\t\\t// we are checking that every closing bracket have opening bracket or not from right to left, if it not having opening bracket we will make that particular character = 0   \\n        for(int i=st.size()-1;i>=0;i--)\\n        {\\n            if(st[i] == \\')\\')\\n                count++;\\n             else if(st[i] == \\'(\\')\\n             {\\n                 if(count>0) count--;\\n                 else\\n                 {\\n                     st[i] = 0;\\n                 }\\n             }\\n        }\\n        string res;\\n\\t\\t/// now we can append that result in the string \\n        for(int i=0;i<st.size();i++)\\n        {\\n            if(st[i]!=0)\\n                res+=st[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int n = s.size();\\n        vector<char> st(n);\\n        int count = 0;\\n\\t\\t// we are storing each character of the given string in a vector\\n        for(int i=0;i<n;i++)\\n        {\\n            st[i] = s[i];\\n        }\\n\\t\\t// we are checking that every opening bracket have closing bracket or not from left to right, if it not having closing bracket we will make that particular character = 0   \\n        for(int i=0;i<st.size();i++)\\n        {\\n            if(st[i] == \\'(\\')\\n                count++;\\n             else if(st[i] == \\')\\')\\n             {\\n                 if(count>0) count--;\\n                 else\\n                 {\\n                     st[i] = 0;\\n                 }\\n             }\\n        }\\n        count = 0;\\n\\t\\t\\t// we are checking that every closing bracket have opening bracket or not from right to left, if it not having opening bracket we will make that particular character = 0   \\n        for(int i=st.size()-1;i>=0;i--)\\n        {\\n            if(st[i] == \\')\\')\\n                count++;\\n             else if(st[i] == \\'(\\')\\n             {\\n                 if(count>0) count--;\\n                 else\\n                 {\\n                     st[i] = 0;\\n                 }\\n             }\\n        }\\n        string res;\\n\\t\\t/// now we can append that result in the string \\n        for(int i=0;i<st.size();i++)\\n        {\\n            if(st[i]!=0)\\n                res+=st[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850453,
                "title": "c-solution-using-stack-w-o-using-stack",
                "content": "**Approach 1 (Using Stack)**\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        \\n        stack<int>st;\\n        \\n        for(int i=0;i<s.length();++i){\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(i);\\n            }\\n            else if(s[i]==\\')\\'){\\n                if(st.empty()){ \\n                    s[i]=\\'@\\';\\n                }\\n                else\\n                {\\n                    st.pop();\\n                }\\n            }\\n        }\\n\\n        while(!st.empty()){\\n            s[st.top()]=\\'@\\';\\n            st.pop();\\n        }\\n        \\n        string ans=\"\";\\n        for(int i=0;i<s.length();++i)\\n        {\\n            if(s[i]!=\\'@\\')\\n            {\\n                ans.push_back(s[i]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity:- O(N)\\nSpace Complexity:- O(N)**\\n\\n**Approach 2 (w/o Stack)**\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int n=s.length();\\n        int count=0; \\n        \\n        // 1st Traversal for removing invalid \\')\\'\\n        for(int i=0;i<n;++i)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                ++count;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                if(count==0)\\n                {\\n                    s[i]=\\'#\\';\\n                }\\n                else\\n                {\\n                    --count;\\n                }\\n            }\\n        }\\n        \\n        count = 0;\\n        \\n        // 2nd Traversal for removing invalid \\'(\\'\\n        for(int i=n-1;i>=0;--i)\\n        {\\n            if(s[i]==\\')\\')\\n            {\\n                ++count;\\n            }\\n            else if(s[i]==\\'(\\')\\n            {\\n                if(count==0)\\n                {\\n                    s[i]=\\'#\\';\\n                }\\n                else\\n                {\\n                    --count;\\n                }\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        for(int i=0; i<n; ++i)\\n        {\\n            if(s[i]!=\\'#\\')\\n            { \\n                ans.push_back(s[i]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity:- O(N)\\nSpace Complexity:- O(1)**\\n\\n***Please, upvote the solution and comment down below if you have some queries, I\\'ll be happy to help***",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        \\n        stack<int>st;\\n        \\n        for(int i=0;i<s.length();++i){\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(i);\\n            }\\n            else if(s[i]==\\')\\'){\\n                if(st.empty()){ \\n                    s[i]=\\'@\\';\\n                }\\n                else\\n                {\\n                    st.pop();\\n                }\\n            }\\n        }\\n\\n        while(!st.empty()){\\n            s[st.top()]=\\'@\\';\\n            st.pop();\\n        }\\n        \\n        string ans=\"\";\\n        for(int i=0;i<s.length();++i)\\n        {\\n            if(s[i]!=\\'@\\')\\n            {\\n                ans.push_back(s[i]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int n=s.length();\\n        int count=0; \\n        \\n        // 1st Traversal for removing invalid \\')\\'\\n        for(int i=0;i<n;++i)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                ++count;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                if(count==0)\\n                {\\n                    s[i]=\\'#\\';\\n                }\\n                else\\n                {\\n                    --count;\\n                }\\n            }\\n        }\\n        \\n        count = 0;\\n        \\n        // 2nd Traversal for removing invalid \\'(\\'\\n        for(int i=n-1;i>=0;--i)\\n        {\\n            if(s[i]==\\')\\')\\n            {\\n                ++count;\\n            }\\n            else if(s[i]==\\'(\\')\\n            {\\n                if(count==0)\\n                {\\n                    s[i]=\\'#\\';\\n                }\\n                else\\n                {\\n                    --count;\\n                }\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        for(int i=0; i<n; ++i)\\n        {\\n            if(s[i]!=\\'#\\')\\n            { \\n                ans.push_back(s[i]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850393,
                "title": "java-4-solutions",
                "content": "\\u2318 Given statement :\\n\\nYour task is to remove the minimum number of parentheses.\\nreturn any valid string.\\n\\u2318 Observations :\\n\\nIt is quite obvious to get a hunch of using stack when we see a parenthesis problem but we can for sure optimise the space in such a case where the input is limited. [ eg: here s[i] is either\\'(\\' , \\')\\', or lowercase English letter ].\\n\\nSolution 1 : Stack\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i=0;i<s.length();i++) {\\n            char ch = s.charAt(i);\\n            if(Character.isAlphabetic(ch))\\n                continue;\\n            if(ch == \\'(\\')\\n                stack.push(i);\\n            else {\\n                if(!stack.isEmpty() && s.charAt(stack.peek()) == \\'(\\')\\n                    stack.pop();\\n                else stack.push(i);\\n            }\\n        }\\n        \\n        // if(stack.size() == 0) return \"\";\\n        \\n        StringBuilder result = new StringBuilder();\\n        HashSet<Integer> set = new HashSet<>(stack);\\n        for(int i=0;i<s.length();i++)\\n            if(!set.contains(i))\\n                result.append(s.charAt(i));\\n        \\n        return result.toString();\\n    }\\n}\\nSolution 2 : Using Deque\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n\\t\\tif (s == null || s.length() == 0) {\\n            return s;\\n        }\\n        \\n        char[] chars = s.toCharArray();\\n        Deque<Integer> deque = new ArrayDeque<>();\\n\\t\\t\\n\\t\\t// push invalid indices in deque\\n        for (int i = 0; i < chars.length; i++) {\\n            char c = chars[i];\\n            if (c == \\'(\\') {\\n                deque.push(i);\\n            } else if (c == \\')\\') {\\n                if (deque.isEmpty()) {\\n                    chars[i] = \\'#\\';\\n                } else {\\n                    deque.pop();\\n                }\\n            } \\n        }\\n        // mark invalid indices\\n        while (!deque.isEmpty()) {\\n            chars[deque.pop()] = \\'#\\';\\n        }\\n        \\n        StringBuilder ans = new StringBuilder();\\n        for (char c : chars) {\\n            if (c != \\'#\\') {\\n                ans.append(c);\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\nConstant Solutions :\\n\\u2318 Constant Solution 1 : [ Slow as we are using insert() function ]\\n\\n\\u2714\\uFE0F Logic : [ 2 steps ]\\n\\nremove invalid close parenthesis\\nremove invalid open parenthesis\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        StringBuilder R = new StringBuilder();\\n        int open = 0, close = 0;\\n        \\n        // remove invalid close parenthesis\\n        for(char ch : s.toCharArray()) {\\n            if(Character.isAlphabetic(ch)) {\\n                R.append(ch);\\n            }\\n            else if(ch==\\'(\\') {\\n                open++;\\n                R.append(ch);\\n            }\\n            else {\\n                if(open > close) { // if there is an \\'(\\' to be considered for a valid pair\\n                    R.append(ch);\\n                    close++;\\n                }\\n                else {\\n                    open = open < 0 ? 0 : open--;\\n                }\\n            }\\n        }\\n\\n        s = R.toString();\\n        R.setLength(0); // reset ans\\n        int n = s.length();\\n        open = close = 0;\\n\\t\\t\\n\\t\\t// remove invalid open parenthesis\\n\\t\\t\\n        for(int i=n-1;i>=0;i--) {\\n            char ch = s.charAt(i);\\n            if(Character.isAlphabetic(ch)) {\\n                R.insert(0, ch);\\n            }\\n            else if(ch == \\')\\') {\\n                R.insert(0, ch);\\n                close++;\\n            }\\n            else {\\n                if(close > open) {\\n                    R.insert(0, ch);\\n                    open++;\\n                }\\n                else {\\n                    close = close < 0 ? 0 : close--;\\n                }\\n            }\\n        }        \\n        return R.toString();\\n    }\\n}\\n\\u2318 A not so contant solution : [ used a char [] ]\\n\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        StringBuilder R = new StringBuilder();\\n        int open = 0, close = 0;\\n        \\n        // remove invalid close parenthesis\\n        for(char ch : s.toCharArray()) {\\n            if(Character.isAlphabetic(ch)) {\\n                R.append(ch);\\n            }\\n            else if(ch==\\'(\\') {\\n                open++;\\n                R.append(ch);\\n            }\\n            else {\\n                if(open > close) {\\n                    R.append(ch);\\n                    close++;\\n                }\\n                else {\\n                    open = open < 0 ? 0 : open--;\\n                }\\n            }\\n        }\\n\\n        // remove invalid open parenthesis\\n        s = R.toString();\\n        int n = s.length();\\n        R.setLength(0);\\n        open = close = 0;\\n        char[] A = s.toCharArray();\\n        \\n        for(int i=n-1;i>=0;i--) {\\n            char ch = s.charAt(i);\\n            if(Character.isAlphabetic(ch)) {\\n                continue;\\n            }\\n            else if(ch == \\')\\') {\\n                close++;\\n            }\\n            else {\\n                if(close > open) {\\n                    open++;\\n                }\\n                else {\\n                    A[i] = \\'*\\';\\n                    close = close < 0 ? 0 : close--;\\n                }\\n            }\\n        }\\n        \\n        for(char ch : A) \\n            if(ch!=\\'*\\')\\n                R.append(ch);\\n        \\n        return R.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "class Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i=0;i<s.length();i++) {\\n            char ch = s.charAt(i);\\n            if(Character.isAlphabetic(ch))\\n                continue;\\n            if(ch == \\'(\\')\\n                stack.push(i);\\n            else {\\n                if(!stack.isEmpty() && s.charAt(stack.peek()) == \\'(\\')\\n                    stack.pop();\\n                else stack.push(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1726784,
                "title": "neat-and-easy-using-stack-beats-99-8",
                "content": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        \"\"\"\\n        Approach:\\n        0. convert string to list\\n        1. Keep track of all \"(\" in a stack, by capturing its index\\n        2. If we encounter a \")\", pop element from stack if stack else make that char \"\"\\n        3. at the end if there is a stack, it will have all indices with extra open bracket, loop through and replace with \"\"\\n        \"\"\"\\n        \\n        S = list(s)\\n        stack = []\\n        \\n        for i in range(len(S)):\\n            if S[i] == \"(\":\\n                stack.append(i)\\n            elif S[i] == \")\":\\n                if stack:\\n                    stack.pop()\\n                else:\\n                    S[i] = \"\"\\n                    \\n        if stack:\\n            for i in stack:\\n                S[i] = \"\"\\n        \\n        return \"\".join(S)\\n\\t\\t\\n\\t\\t\\nDetails \\nRuntime: 72 ms, faster than 99.80% of Python3 online submissions for Minimum Remove to Make Valid Parentheses.\\nMemory Usage: 15.7 MB, less than 86.93% of Python3 online submissions for Minimum Remove to Make Valid Parentheses.",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        \"\"\"\\n        Approach:\\n        0. convert string to list\\n        1. Keep track of all \"(\" in a stack, by capturing its index\\n        2. If we encounter a \")\", pop element from stack if stack else make that char \"\"\\n        3. at the end if there is a stack, it will have all indices with extra open bracket, loop through and replace with \"\"\\n        \"\"\"\\n        \\n        S = list(s)\\n        stack = []\\n        \\n        for i in range(len(S)):\\n            if S[i] == \"(\":\\n                stack.append(i)\\n            elif S[i] == \")\":\\n                if stack:\\n                    stack.pop()\\n                else:\\n                    S[i] = \"\"\\n                    \\n        if stack:\\n            for i in stack:\\n                S[i] = \"\"\\n        \\n        return \"\".join(S)\\n\\t\\t\\n\\t\\t\\nDetails \\nRuntime: 72 ms, faster than 99.80% of Python3 online submissions for Minimum Remove to Make Valid Parentheses.\\nMemory Usage: 15.7 MB, less than 86.93% of Python3 online submissions for Minimum Remove to Make Valid Parentheses.",
                "codeTag": "Java"
            },
            {
                "id": 1719464,
                "title": "c-73-faster-easy-sol-using-stack",
                "content": "```\\n string minRemoveToMakeValid(string s) {\\n        string result=\"\";\\n        stack<int>st;\\n        string fina=\"\";\\n        int n=s.size();\\n        vector<int>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!isalpha(s[i]))\\n            {\\n                if(s[i]==\\'(\\')\\n                    st.push(i);\\n                else \\n                {\\n                    if(st.empty())\\n                       v.push_back(i);\\n                    else \\n                        st.pop();\\n                }\\n            }\\n        }\\n        while(!st.empty())\\n        {\\n            int t=st.top();\\n            v.push_back(t);\\n            st.pop();\\n        }\\n        if(v.size()==n)\\n            return result;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            s[v[i]]=\\'#\\';\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n           if(s[i]==\\'#\\')\\n               continue;\\n            fina+=s[i];\\n        }\\n        return fina;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n string minRemoveToMakeValid(string s) {\\n        string result=\"\";\\n        stack<int>st;\\n        string fina=\"\";\\n        int n=s.size();\\n        vector<int>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!isalpha(s[i]))\\n            {\\n                if(s[i]==\\'(\\')\\n                    st.push(i);\\n                else \\n                {\\n                    if(st.empty())\\n                       v.push_back(i);\\n                    else \\n                        st.pop();\\n                }\\n            }\\n        }\\n        while(!st.empty())\\n        {\\n            int t=st.top();\\n            v.push_back(t);\\n            st.pop();\\n        }\\n        if(v.size()==n)\\n            return result;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            s[v[i]]=\\'#\\';\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n           if(s[i]==\\'#\\')\\n               continue;\\n            fina+=s[i];\\n        }\\n        return fina;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1713691,
                "title": "simple-solution-cpp-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int n=s.length();\\n        stack<int>sta;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'(\\'){\\n                sta.push(i);\\n                s[i]=\\'#\\';\\n            }else if(s[i]==\\')\\'){\\n                if(!sta.empty()){\\n                    s[sta.top()]=\\'(\\';\\n                    sta.pop();\\n                }else{\\n                    s[i]=\\'#\\';\\n                }\\n            }\\n        }\\n        string output;\\n        for(int i=0;i<n;i++){\\n            if(s[i]!=\\'#\\'){\\n                output+=s[i];\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int n=s.length();\\n        stack<int>sta;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'(\\'){\\n                sta.push(i);\\n                s[i]=\\'#\\';\\n            }else if(s[i]==\\')\\'){\\n                if(!sta.empty()){\\n                    s[sta.top()]=\\'(\\';\\n                    sta.pop();\\n                }else{\\n                    s[i]=\\'#\\';\\n                }\\n            }\\n        }\\n        string output;\\n        for(int i=0;i<n;i++){\\n            if(s[i]!=\\'#\\'){\\n                output+=s[i];\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672799,
                "title": "easy-c-solution-stack-based-o-n-linear-time",
                "content": "**Please upvote to motivate me in quest of documenting leetcode solutions**\\n```\\nThe question is simply a use case of \"STACK\" Datastructure.\\nThe logic to this problem is storing all  \\'(\\' or \\')\\' characters in stack which are violating valid Parentheses and their index no. Now Traverse\\nthe string and check if current character is present in stack , pop it. Otherwise add the character to resultant string.\\n```\\n```\\n string remove_str(string str, int l)\\n{\\n   stack<pair<char,int>>s;\\n   for(int i=0; i<l; i++)\\n   {\\n      if(str[i]==\\'(\\' || str[i]==\\')\\')\\n      {\\n         if(s.empty())\\n           s.push({str[i],i});\\n         else\\n         {\\n              if(str[i]==\\')\\' && s.top().first==\\'(\\')\\n                 s.pop();\\n              else\\n                 s.push({str[i],i});       // store character and its index which violates valid parentheses\\n         }\\n      }\\n   }\\n   \\n  string ss;\\n  for(int i=l-1; i>=0; i--)\\n  {\\n      if(s.size()>0 && i==s.top().second)     // if current index is equal to stack top invalid parentheses index dont add to resultant string\\n       s.pop();\\n      else\\n       ss+=str[i];\\n  }\\n  reverse(ss.begin(),ss.end());\\n return ss;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nThe question is simply a use case of \"STACK\" Datastructure.\\nThe logic to this problem is storing all  \\'(\\' or \\')\\' characters in stack which are violating valid Parentheses and their index no. Now Traverse\\nthe string and check if current character is present in stack , pop it. Otherwise add the character to resultant string.\\n```\n```\\n string remove_str(string str, int l)\\n{\\n   stack<pair<char,int>>s;\\n   for(int i=0; i<l; i++)\\n   {\\n      if(str[i]==\\'(\\' || str[i]==\\')\\')\\n      {\\n         if(s.empty())\\n           s.push({str[i],i});\\n         else\\n         {\\n              if(str[i]==\\')\\' && s.top().first==\\'(\\')\\n                 s.pop();\\n              else\\n                 s.push({str[i],i});       // store character and its index which violates valid parentheses\\n         }\\n      }\\n   }\\n   \\n  string ss;\\n  for(int i=l-1; i>=0; i--)\\n  {\\n      if(s.size()>0 && i==s.top().second)     // if current index is equal to stack top invalid parentheses index dont add to resultant string\\n       s.pop();\\n      else\\n       ss+=str[i];\\n  }\\n  reverse(ss.begin(),ss.end());\\n return ss;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1621435,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int open = 0;\\n        string str = \"\";\\n        for(auto c: s){\\n            if(c!=\\'(\\' && c!=\\')\\'){\\n                str += c;\\n                continue;\\n            }\\n            else if(c==\\'(\\'){\\n                open++;\\n                str += c;\\n            }\\n            else{\\n                if(open>0){\\n                    open--;\\n                    str += c;\\n                }\\n            }\\n        }\\n        cout<<str;\\n        string ans = \"\";\\n        if(open){\\n            for(int i=str.size()-1;i>=0;i--){\\n                if(open && str[i]==\\'(\\'){\\n                    open--;\\n                    continue;\\n                }\\n                else{\\n                    ans += str[i];\\n                }\\n            }\\n            reverse(ans.begin(),ans.end());\\n        }\\n        else{\\n            ans = str;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        int open = 0;\\n        string str = \"\";\\n        for(auto c: s){\\n            if(c!=\\'(\\' && c!=\\')\\'){\\n                str += c;\\n                continue;\\n            }\\n            else if(c==\\'(\\'){\\n                open++;\\n                str += c;\\n            }\\n            else{\\n                if(open>0){\\n                    open--;\\n                    str += c;\\n                }\\n            }\\n        }\\n        cout<<str;\\n        string ans = \"\";\\n        if(open){\\n            for(int i=str.size()-1;i>=0;i--){\\n                if(open && str[i]==\\'(\\'){\\n                    open--;\\n                    continue;\\n                }\\n                else{\\n                    ans += str[i];\\n                }\\n            }\\n            reverse(ans.begin(),ans.end());\\n        }\\n        else{\\n            ans = str;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1609164,
                "title": "java-stack-95-t-o-n-s-o-n",
                "content": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        char[] sArray = s.toCharArray();\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = 0; i < sArray.length; i++) {\\n            if (sArray[i] == \\'(\\') stack.push(i);\\n            else if (sArray[i] == \\')\\') {\\n                if (stack.isEmpty()) sArray[i] = \\'0\\';\\n                else stack.pop();\\n            }\\n        }\\n        while (!stack.isEmpty()) sArray[stack.pop()] = \\'0\\';\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : sArray) {\\n            if (c != \\'0\\') sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        char[] sArray = s.toCharArray();\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = 0; i < sArray.length; i++) {\\n            if (sArray[i] == \\'(\\') stack.push(i);\\n            else if (sArray[i] == \\')\\') {\\n                if (stack.isEmpty()) sArray[i] = \\'0\\';\\n                else stack.pop();\\n            }\\n        }\\n        while (!stack.isEmpty()) sArray[stack.pop()] = \\'0\\';\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : sArray) {\\n            if (c != \\'0\\') sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586819,
                "title": "minimum-remove-to-make-valid-parentheses-easy-simple",
                "content": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        Stack<Integer> stack=new Stack<>();\\n        StringBuilder sb=new StringBuilder(\"\");\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(ch!=\\')\\' && ch!=\\'(\\'){\\n                sb.append(ch);\\n            }else if(ch==\\'(\\'){\\n                sb.append(ch);\\n                stack.push(sb.length()-1);\\n                \\n            }else if(ch==\\')\\'){\\n               boolean res=findPair(stack);\\n                if(res){\\n                    sb.append(ch);\\n            }\\n        }\\n        }\\n        while(!stack.isEmpty()){\\n            sb.deleteCharAt(stack.pop());\\n        }\\n        return sb.toString();\\n    }\\n    \\n    \\n    public boolean findPair(Stack<Integer> s){\\n        if(s.isEmpty()){\\n            return false;\\n        }else{\\n            s.pop();\\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        Stack<Integer> stack=new Stack<>();\\n        StringBuilder sb=new StringBuilder(\"\");\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(ch!=\\')\\' && ch!=\\'(\\'){\\n                sb.append(ch);\\n            }else if(ch==\\'(\\'){\\n                sb.append(ch);\\n                stack.push(sb.length()-1);\\n                \\n            }else if(ch==\\')\\'){\\n               boolean res=findPair(stack);\\n                if(res){\\n                    sb.append(ch);\\n            }\\n        }\\n        }\\n        while(!stack.isEmpty()){\\n            sb.deleteCharAt(stack.pop());\\n        }\\n        return sb.toString();\\n    }\\n    \\n    \\n    public boolean findPair(Stack<Integer> s){\\n        if(s.isEmpty()){\\n            return false;\\n        }else{\\n            s.pop();\\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1571716,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        int count = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(char c : s.toCharArray()){\\n            if(c == \\'(\\')    count ++;\\n            else if(c == \\')\\'){\\n                if(count == 0)  continue;\\n                count--;\\n            }\\n            sb.append(c);\\n        }\\n        for(int i=sb.length()-1; i>=0 && count>0; i--){\\n            if(sb.charAt(i) == \\'(\\'){\\n                sb.deleteCharAt(i);\\n                count--;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        int count = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(char c : s.toCharArray()){\\n            if(c == \\'(\\')    count ++;\\n            else if(c == \\')\\'){\\n                if(count == 0)  continue;\\n                count--;\\n            }\\n            sb.append(c);\\n        }\\n        for(int i=sb.length()-1; i>=0 && count>0; i--){\\n            if(sb.charAt(i) == \\'(\\'){\\n                sb.deleteCharAt(i);\\n                count--;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550438,
                "title": "c-stack-of-pairs-tc-o-n-sc-o-n-aux-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack<pair<char,int>> stk;\\n\\t\\t\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] == \\'(\\')\\n                stk.push({s[i],i});\\n            else if(!stk.empty() && stk.top().first == \\'(\\' && s[i] == \\')\\')\\n                stk.pop();\\n            else if(s[i] == \\')\\')\\n                stk.push({s[i],i});\\n        }\\n        \\n        while(!stk.empty()) {\\n            s.erase(s.begin()+stk.top().second);\\n            stk.pop();\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack<pair<char,int>> stk;\\n\\t\\t\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] == \\'(\\')\\n                stk.push({s[i],i});\\n            else if(!stk.empty() && stk.top().first == \\'(\\' && s[i] == \\')\\')\\n                stk.pop();\\n            else if(s[i] == \\')\\')\\n                stk.push({s[i],i});\\n        }\\n        \\n        while(!stk.empty()) {\\n            s.erase(s.begin()+stk.top().second);\\n            stk.pop();\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537727,
                "title": "python-3-99-faster-solution",
                "content": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        stack = []\\n        s = list(s)\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                stack.append(i)\\n            elif s[i] == \\')\\':\\n                if stack:\\n                    stack.pop()\\n                else:\\n                    s[i] = \"\"\\n        for j in stack:\\n            s[j] = \"\"\\n        return \"\".join(s)\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        stack = []\\n        s = list(s)\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                stack.append(i)\\n            elif s[i] == \\')\\':\\n                if stack:\\n                    stack.pop()\\n                else:\\n                    s[i] = \"\"\\n        for j in stack:\\n            s[j] = \"\"\\n        return \"\".join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536353,
                "title": "simple-and-intuitive-o-n-python-solution",
                "content": "```class Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        #similar to valid parenthesis problem\\n        #we keep storing the indices of open parantheses in stack (which are not matched to closed parentheses) so that we can remove these from resulting string\\n        #also convert unmatched closed parantheses into empty string\\n        \\n        stack=[]\\n        lis= list(s)\\n        n= len(s)\\n        \\n        for idx, i in enumerate(lis):\\n            if i==\\'(\\':\\n                stack.append(idx)\\n            elif i==\\')\\':\\n                if stack: #if stack contains open parentheses we can remove the pair ()\\n                    stack.pop()\\n                else: #if closed parantheses is encountered without any open parentheses in stack, then it has to be removed\\n                    lis[idx]=\"\"\\n            else: #if we encounter characters\\n                continue\\n        \\n        #now stack contains indices of open parentheses in string and we need to remove them from final string\\n        for i in stack:\\n            lis[i]=\"\"\\n        \\n        return \"\".join(lis)",
                "solutionTags": [],
                "code": "```class Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        #similar to valid parenthesis problem\\n        #we keep storing the indices of open parantheses in stack (which are not matched to closed parentheses) so that we can remove these from resulting string\\n        #also convert unmatched closed parantheses into empty string\\n        \\n        stack=[]\\n        lis= list(s)\\n        n= len(s)\\n        \\n        for idx, i in enumerate(lis):\\n            if i==\\'(\\':\\n                stack.append(idx)\\n            elif i==\\')\\':\\n                if stack: #if stack contains open parentheses we can remove the pair ()\\n                    stack.pop()\\n                else: #if closed parantheses is encountered without any open parentheses in stack, then it has to be removed\\n                    lis[idx]=\"\"\\n            else: #if we encounter characters\\n                continue\\n        \\n        #now stack contains indices of open parentheses in string and we need to remove them from final string\\n        for i in stack:\\n            lis[i]=\"\"\\n        \\n        return \"\".join(lis)",
                "codeTag": "Java"
            },
            {
                "id": 1508101,
                "title": "c-no-stack-using-counter",
                "content": "Task -> We have to remove minimum number of parathesis, so that our string becomes valid. \\n\\nSolution -> \\nThere can be some observations, that we should observe.\\n1) if at any point count of closing paranthesis \\')\\' is greater than opening paranthesis \\'(\\', then we have to remove closing paranthesis at that point only, because we can not validade a closing paranthesis by moving right,\\n2) but we can validate a opening paranthesis by moving right, because there can be same number of closing paranthesis in the right.\\n3) at last if we have count of opening paranthesis greater than closing, so we have to remove some opening paranthesis, \\n4) so which paranthesis should be removed -----> the answer is pretty simple, remove the paranthesis from the right side of string, because we know if there are any closing paranthesis to right of these opening paranthesis that we are going to remove, these closing paranthesis can be validated by opening ones at left,\\n5) But if we start removing from left or start of string, there can be some closing paranthesis , that can not be validated by opening paranthesis in right of string.\\n\\n\\nCoding Part -> \\n1) use cnt variable for counting of opening and closing paranthesis.\\n2) If we encounter opening paranthesis, then increment cnt.\\n3) If any closing paranthesis comes, decrement cnt.\\n4) If at any point cnt is negative, then remove that character. (that is closing paranthesis [see point 1 of observations]).\\n5) and at last after iterating , cnt is positive, then remove same amount of opening paranthesis from the end of string.\\n6) I removed paranthesis by updating that char with \\'#\\', you can pick any other character and after all operations, created a new string which will not contain \\'#\\' character.\\n\\nSee below code for more clearity.\\n\\n`IF YOU LIKE MY EXPLANATION & CODE PLEASE DO UPVOTE (<>)`\\n\\n```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        \\n        int cnt = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n\\n            if(s[i] == \\'(\\') cnt++;\\n            if(s[i] == \\')\\') cnt--;\\n            if(cnt < 0) {\\n                \\n                s[i] = \\'#\\';\\n                cnt = 0;\\n            }\\n        }\\n        int idx = s.length() - 1;\\n        while(cnt > 0 && idx >= 0) {\\n            \\n            if(s[idx] == \\'(\\') {\\n                \\n                s[idx] = \\'#\\';\\n                cnt--;\\n            }\\n            idx--;\\n        }\\n        string res = \"\";\\n        for(char c : s) {\\n            \\n            if(c != \\'#\\') res += c;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        \\n        int cnt = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n\\n            if(s[i] == \\'(\\') cnt++;\\n            if(s[i] == \\')\\') cnt--;\\n            if(cnt < 0) {\\n                \\n                s[i] = \\'#\\';\\n                cnt = 0;\\n            }\\n        }\\n        int idx = s.length() - 1;\\n        while(cnt > 0 && idx >= 0) {\\n            \\n            if(s[idx] == \\'(\\') {\\n                \\n                s[idx] = \\'#\\';\\n                cnt--;\\n            }\\n            idx--;\\n        }\\n        string res = \"\";\\n        for(char c : s) {\\n            \\n            if(c != \\'#\\') res += c;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446801,
                "title": "python-stack-solution",
                "content": "- For balanced parenthesis:\\n  * total number of ( == total number of )\\n  * at every instance, number of ( is always >= )\\n- In summary: iterate and keep track of indices to remove\\n- There are three cases:\\n  * imbalanced with ) and no ( in stack add to invalid set\\n  * if ) and there\\'s ( in stack pop stack **only need indices in stack\\n  * At the end, if the stack isn\\'t empty i.e. there are unclosed opening parentheses,\\n    also add them to set to be removed.\\n- Iterate over original string and ignore any indices marked as invalid\\n\\n```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        invalids = set()\\n        stack = []\\n        for idx, ch in enumerate(s):\\n            if ch == \\'(\\':\\n                stack.append(idx)\\n            elif ch == \\')\\':\\n                if not stack: # no prior opening parenthesis\\n                    invalids.add(idx)\\n                else:\\n                    stack.pop()\\n                    \\n        for idx in stack:  # if stack is non empty (unclosed parenthesis)\\n            invalids.add(idx)\\n            \\n        ans = []\\n        for i in range(len(s)):\\n            if i in invalids:\\n                continue\\n            ans.append(s[i])\\n            \\n        return \"\".join(ans)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        invalids = set()\\n        stack = []\\n        for idx, ch in enumerate(s):\\n            if ch == \\'(\\':\\n                stack.append(idx)\\n            elif ch == \\')\\':\\n                if not stack: # no prior opening parenthesis\\n                    invalids.add(idx)\\n                else:\\n                    stack.pop()\\n                    \\n        for idx in stack:  # if stack is non empty (unclosed parenthesis)\\n            invalids.add(idx)\\n            \\n        ans = []\\n        for i in range(len(s)):\\n            if i in invalids:\\n                continue\\n            ans.append(s[i])\\n            \\n        return \"\".join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428700,
                "title": "intuitive-approach-easy-solution-python3",
                "content": "The idea here is to have 2 stacks where one will be storing the paranthesis and another stack will be storing the corresponding index of that paranthesis.\\nIn the following loop we are checking if the string which is coming is lowercase alphabet or not if it is then we are just continuing the process else we are checking Valid paranthesis.\\nAfter the loop end, then we are just checking if aur Index Stack is empty or not if it is not empty then we are popping out the element whose index are there in the Index Stack.\\n```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        stackParan = []\\n        stackIdx = []\\n        n = len(s)\\n        for i in range(n):\\n            if s[i].islower() == True:\\n                continue\\n            else:\\n\\t\\t\\t#Checking Valid Paranthesis\\n                if len(stackParan) == 0 and len(stackIdx) == 0:\\n                    stackParan.append(s[i])\\n                    stackIdx.append(i)\\n                else:\\n                    if stackParan[-1] == \"(\" and s[i] == \")\":\\n                        stackParan.pop()\\n                        stackIdx.pop()\\n                    elif stackParan[-1] == \")\" or stackParan[-1] == \"(\":\\n                        stackParan.append(s[i])\\n                        stackIdx.append(i)\\n        \\n        s = list(s)\\n        while stackIdx != []:\\n            s.pop(stackIdx[-1])\\n            stackIdx.pop()\\n        \\n        return \"\".join(s)\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minRemoveToMakeValid(self, s: str) -> str:\\n        stackParan = []\\n        stackIdx = []\\n        n = len(s)\\n        for i in range(n):\\n            if s[i].islower() == True:\\n                continue\\n            else:\\n\\t\\t\\t#Checking Valid Paranthesis\\n                if len(stackParan) == 0 and len(stackIdx) == 0:\\n                    stackParan.append(s[i])\\n                    stackIdx.append(i)\\n                else:\\n                    if stackParan[-1] == \"(\" and s[i] == \")\":\\n                        stackParan.pop()\\n                        stackIdx.pop()\\n                    elif stackParan[-1] == \")\" or stackParan[-1] == \"(\":\\n                        stackParan.append(s[i])\\n                        stackIdx.append(i)\\n        \\n        s = list(s)\\n        while stackIdx != []:\\n            s.pop(stackIdx[-1])\\n            stackIdx.pop()\\n        \\n        return \"\".join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381180,
                "title": "stack-faster-than-98-02-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string str) {\\n        stack<int> stk;\\n        for(int i =0; i<str.size();i++){\\n            if( str[i] == \\'(\\'){\\n                stk.push(i);\\n            }else if(str[i] ==\\')\\'){\\n                if(!stk.empty()){\\n                    stk.pop();\\n                }else{\\n                    str[i] =\\'*\\';\\n                }\\n            }\\n        }\\n        while(!stk.empty()){\\n            str[stk.top()] = \\'*\\';\\n            stk.pop();\\n        }\\n        str.erase(remove(str.begin(), str.end(), \\'*\\'), str.end());\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string str) {\\n        stack<int> stk;\\n        for(int i =0; i<str.size();i++){\\n            if( str[i] == \\'(\\'){\\n                stk.push(i);\\n            }else if(str[i] ==\\')\\'){\\n                if(!stk.empty()){\\n                    stk.pop();\\n                }else{\\n                    str[i] =\\'*\\';\\n                }\\n            }\\n        }\\n        while(!stk.empty()){\\n            str[stk.top()] = \\'*\\';\\n            stk.pop();\\n        }\\n        str.erase(remove(str.begin(), str.end(), \\'*\\'), str.end());\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301491,
                "title": "o-1-space-o-n-time",
                "content": "```\\nvar minRemoveToMakeValid = function(str) {\\n    let counter = 0;\\n    str = str.split(\\'\\');\\n    \\n    let i = 0;\\n    \\n    while (str[i] != undefined) {\\n        if (str[i] == \"(\") counter++;\\n        if (str[i] == \")\") counter--;\\n        \\n        if (counter < 0) {\\n            counter++;\\n            str[i] = \"\";\\n        }\\n        \\n        i++;\\n    }\\n    \\n    counter = 0;\\n    i = str.length-1;\\n    \\n    while (str[i] != undefined) {\\n        if (str[i] == \"(\") counter++;\\n        if (str[i] == \")\") counter--;\\n        \\n        if (counter > 0) {\\n            counter--;\\n            str[i] = \"\";\\n        }\\n        \\n        i--;\\n    }\\n    \\n    return str.join(\\'\\');\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minRemoveToMakeValid = function(str) {\\n    let counter = 0;\\n    str = str.split(\\'\\');\\n    \\n    let i = 0;\\n    \\n    while (str[i] != undefined) {\\n        if (str[i] == \"(\") counter++;\\n        if (str[i] == \")\") counter--;\\n        \\n        if (counter < 0) {\\n            counter++;\\n            str[i] = \"\";\\n        }\\n        \\n        i++;\\n    }\\n    \\n    counter = 0;\\n    i = str.length-1;\\n    \\n    while (str[i] != undefined) {\\n        if (str[i] == \"(\") counter++;\\n        if (str[i] == \")\") counter--;\\n        \\n        if (counter > 0) {\\n            counter--;\\n            str[i] = \"\";\\n        }\\n        \\n        i--;\\n    }\\n    \\n    return str.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1170220,
                "title": "javascript-stack-solution",
                "content": "solution is based on the https://leetcode.com/problems/valid-parentheses/\\n```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isValid = function(s) {\\n    const map = {\\n        \\')\\':\\'(\\',\\n        \\'}\\':\\'{\\',\\n        \\']\\':\\'[\\'\\n    };\\n    \\n    let stack = [];\\n    \\n    for(let i = 0; i < s.length; i++){\\n        if(!map[s[i]]){\\n            stack.push(s[i]); // this is an open bracket;\\n        } else {\\n            // this is an closing bracket\\n            if(map[s[i]] !== stack.pop()) return false\\n        }\\n    }\\n    \\n    return stack.length === 0;\\n};\\n```\\nexept we store \\'(\\' index in the string not char itself, and we look into the stack once again and remove all  unclosed \\'(\\' , basically having valid string at the end\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar minRemoveToMakeValid = function(s) {\\n    let str = s.split(\\'\\');\\n\\tlet stack = [];\\n    \\n    for(let i = 0; i < str.length; i++){\\n        if(str[i] === \\'(\\') {\\n            stack.push(i);\\n        }\\n        else if(str[i] === \\')\\'){\\n            if(stack.length) stack.pop(); // case 1. there was a \"(\" before - nothing to remove, this is a valid case\\n            else str[i]= \\'\\'; // case 2. there was no \"(\" before, so we need to remove \")\" from the string, to make string valid\\n        }\\n    }\\n    \\n    for(let i of stack) str[i] = \\'\\'; // we remove all left unclosed \"(\" from the string, to make string valid\\n    \\n    return str.join(\\'\\');\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isValid = function(s) {\\n    const map = {\\n        \\')\\':\\'(\\',\\n        \\'}\\':\\'{\\',\\n        \\']\\':\\'[\\'\\n    };\\n    \\n    let stack = [];\\n    \\n    for(let i = 0; i < s.length; i++){\\n        if(!map[s[i]]){\\n            stack.push(s[i]); // this is an open bracket;\\n        } else {\\n            // this is an closing bracket\\n            if(map[s[i]] !== stack.pop()) return false\\n        }\\n    }\\n    \\n    return stack.length === 0;\\n};\\n```\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar minRemoveToMakeValid = function(s) {\\n    let str = s.split(\\'\\');\\n\\tlet stack = [];\\n    \\n    for(let i = 0; i < str.length; i++){\\n        if(str[i] === \\'(\\') {\\n            stack.push(i);\\n        }\\n        else if(str[i] === \\')\\'){\\n            if(stack.length) stack.pop(); // case 1. there was a \"(\" before - nothing to remove, this is a valid case\\n            else str[i]= \\'\\'; // case 2. there was no \"(\" before, so we need to remove \")\" from the string, to make string valid\\n        }\\n    }\\n    \\n    for(let i of stack) str[i] = \\'\\'; // we remove all left unclosed \"(\" from the string, to make string valid\\n    \\n    return str.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1105612,
                "title": "java-solution-faster-than-100-with-comments-expplanation",
                "content": "JAVA CODE IS:\\n#    \\n```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        //build resultant array\\n        StringBuilder str=new StringBuilder();\\n        //keep track of extra open braces\\n        Stack<Integer>stack=new Stack<>();\\n        for(char c : s.toCharArray())\\n            if(c==\\')\\'){\\n                if(stack.empty())  continue;\\n                else { stack.pop();\\n                      str.append(c);\\n                 }\\n            }\\n           else if(c==\\'(\\'){\\n              stack.push(str.length());\\n               str.append(c);\\n           }\\n        else\\n            str.append(c);\\n        while(!stack.empty())\\n            str.deleteCharAt(stack.pop());\\n        return str.toString();\\n               \\n    }\\n}\\n```\\nTime : O(n)\\nSpace : O(n) extra space used\\n***PLEASE,UPVOTE IF THIS IS HELPFUL***\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        //build resultant array\\n        StringBuilder str=new StringBuilder();\\n        //keep track of extra open braces\\n        Stack<Integer>stack=new Stack<>();\\n        for(char c : s.toCharArray())\\n            if(c==\\')\\'){\\n                if(stack.empty())  continue;\\n                else { stack.pop();\\n                      str.append(c);\\n                 }\\n            }\\n           else if(c==\\'(\\'){\\n              stack.push(str.length());\\n               str.append(c);\\n           }\\n        else\\n            str.append(c);\\n        while(!stack.empty())\\n            str.deleteCharAt(stack.pop());\\n        return str.toString();\\n               \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1095885,
                "title": "easy-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack<int> st;\\n        string res=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(i);\\n            }\\n            else if(s[i]==\\')\\' )\\n            {\\n                if(st.empty()==false){\\n                    st.pop();\\n                }\\n                else{\\n                s[i]=\\'*\\';\\n            }\\n            }\\n            \\n        }\\n        while(!st.empty())\\n        {\\n            s[st.top()]=\\'*\\';\\n            st.pop();\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]!=\\'*\\')\\n                res+=s[i];\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minRemoveToMakeValid(string s) {\\n        stack<int> st;\\n        string res=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(i);\\n            }\\n            else if(s[i]==\\')\\' )\\n            {\\n                if(st.empty()==false){\\n                    st.pop();\\n                }\\n                else{\\n                s[i]=\\'*\\';\\n            }\\n            }\\n            \\n        }\\n        while(!st.empty())\\n        {\\n            s[st.top()]=\\'*\\';\\n            st.pop();\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]!=\\'*\\')\\n                res+=s[i];\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565646,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using a Stack and String Builder\n\n  \n**Approach 2:** Two Pass String Builder\n\n  \n**Approach 3:** Shortened Two Pass String Builder\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calm27",
                        "content": "it seems to be \\'easy\\', not \\'medium\\' problem. \\nintuitive stack approach is pretty straight forward, however official approaches are kind confusing. "
                    },
                    {
                        "username": "Fedolodic",
                        "content": "Looking to see how the community would approach this follow-up. I can\\'t think of anything that beats the immutable string O(n) algorithm with 3 for-loops."
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Easy explanation | 4 min Hindi Video | Explained the crux of the problem \\nyoutube. com/watch?v=hLWkxDrdQPI"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Could you share math proof that stack approach gives optimal solution"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "***(...yet to go through LC solutions 2 and 3, but a wonderful LC solution 1)***\\n\\nThis is an interesting problem in a way that only if I know about the **Parentheses Properties**, **Stack Data Structure** and **relation between Parentheses and Stack**, I could come up with the solution (read LC solution 1) in an interview.\\n\\n**Parentheses Properties**: \\n* For parentheses to be balanced, count of Opens must be equal to count of Closes. eg: for ( ( ( ) ) ), count = 3 and 3\\n* Each Close must form a pair with previously encountered Open. eg: for ) ) ) ( ( (, though count = 3 and 3, each Close doesn\\'t have a previous Open to be paired with.\\n\\n**Stack Data Structure**\\n* First In First Out: Insertion and removeal happens at the same side. // recency based\\n\\n**Relation between Parentheses and Stack**\\n* For Parenetheses Property 2, Stack is the DS that facilitates this validation. On encountering Open, it is pushed into stack, and on encountering Close, the last Open (at the top of stack) is popped out. Now we have found a pair, we just need to compute similarly for the rest of the brackets. Depending on the problem, stack could either store the Open itslef or its index. Here we need to remove the corresponding bracket from input string, so we store index. \\n* For Parentheses Propert 1: At the end of the stack computation if stack is empty, we have equal counts of Open and Close.\\n* Extra Open: At the end of computation, if Opens are remaining, these are the extra brackets that make the parentheses unbalanced. These could be removed to make the parentheses balanced.\\n* Exra Close: If at any time during the computation, Close is encountered but stack is empty, it means this Close is extra (no Open to pair with) and is making already encountered parentheses unbalanced. This could be removed to continue the computation for the rest of the brackets.\\n* A thought that could hinder the proof: Instead of pairing currently computing Close with last Open, what if I pair a later Close with this Open, so the currently computing Close could be removed from making the parentheses unbalanced? \\nEg: `( ) )`. Parentheses 0 = last Open, Parentheses 1 = currently computing Close, Parentheses 2 = later Close\\nAnswer: It won\\'t make any difference to the overall number of \")\" we need to remove from the parantheses. \\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally solved a stack string medium question without help !!"
                    },
                    {
                        "username": "Agg_Riitk",
                        "content": "You have to use StringBuilder Method to store the result instead of storing it in a normal string. The reason for this is given below form a StackOverFlow Post.\\n\\n\\nEvery time you do stringA += stringB; a new string is created an assigned to stringA, so it will consume memory (a new string instance!) and time (copy the old string + new characters of the other string).\\n\\nStringBuilder will use an array of characters internally and when you use the .append() method it will do several things:\\n\\n\\t-check if there are any free space for the string to append\\n\\t\\n\\t-again some internal checks and run a System.arraycopy to copy the characters of the string in the array.\\n\\t\\n\\t\\nSource :- https://stackoverflow.com/questions/22439177/why-is-stringbuilder-much-faster-than-string"
                    },
                    {
                        "username": "baburaoapte",
                        "content": "The approach using Stack - or any approach for that matter - how do you ensure that it\\'s the minimum number of brackets are being removed? How to prove that? I didn\\'t understand that part about the solution and it is very critical to the understanding of this problem. Please can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no need to use a stack here. Just traverse the string from left to right removing any unmatched closing parentheses (closing parenthesis count is greater than the opening parenthesis count) as you go then traverse the string from right to left removing any unmatched opening parentheses as you go."
                    }
                ]
            },
            {
                "id": 1733314,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using a Stack and String Builder\n\n  \n**Approach 2:** Two Pass String Builder\n\n  \n**Approach 3:** Shortened Two Pass String Builder\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calm27",
                        "content": "it seems to be \\'easy\\', not \\'medium\\' problem. \\nintuitive stack approach is pretty straight forward, however official approaches are kind confusing. "
                    },
                    {
                        "username": "Fedolodic",
                        "content": "Looking to see how the community would approach this follow-up. I can\\'t think of anything that beats the immutable string O(n) algorithm with 3 for-loops."
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Easy explanation | 4 min Hindi Video | Explained the crux of the problem \\nyoutube. com/watch?v=hLWkxDrdQPI"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Could you share math proof that stack approach gives optimal solution"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "***(...yet to go through LC solutions 2 and 3, but a wonderful LC solution 1)***\\n\\nThis is an interesting problem in a way that only if I know about the **Parentheses Properties**, **Stack Data Structure** and **relation between Parentheses and Stack**, I could come up with the solution (read LC solution 1) in an interview.\\n\\n**Parentheses Properties**: \\n* For parentheses to be balanced, count of Opens must be equal to count of Closes. eg: for ( ( ( ) ) ), count = 3 and 3\\n* Each Close must form a pair with previously encountered Open. eg: for ) ) ) ( ( (, though count = 3 and 3, each Close doesn\\'t have a previous Open to be paired with.\\n\\n**Stack Data Structure**\\n* First In First Out: Insertion and removeal happens at the same side. // recency based\\n\\n**Relation between Parentheses and Stack**\\n* For Parenetheses Property 2, Stack is the DS that facilitates this validation. On encountering Open, it is pushed into stack, and on encountering Close, the last Open (at the top of stack) is popped out. Now we have found a pair, we just need to compute similarly for the rest of the brackets. Depending on the problem, stack could either store the Open itslef or its index. Here we need to remove the corresponding bracket from input string, so we store index. \\n* For Parentheses Propert 1: At the end of the stack computation if stack is empty, we have equal counts of Open and Close.\\n* Extra Open: At the end of computation, if Opens are remaining, these are the extra brackets that make the parentheses unbalanced. These could be removed to make the parentheses balanced.\\n* Exra Close: If at any time during the computation, Close is encountered but stack is empty, it means this Close is extra (no Open to pair with) and is making already encountered parentheses unbalanced. This could be removed to continue the computation for the rest of the brackets.\\n* A thought that could hinder the proof: Instead of pairing currently computing Close with last Open, what if I pair a later Close with this Open, so the currently computing Close could be removed from making the parentheses unbalanced? \\nEg: `( ) )`. Parentheses 0 = last Open, Parentheses 1 = currently computing Close, Parentheses 2 = later Close\\nAnswer: It won\\'t make any difference to the overall number of \")\" we need to remove from the parantheses. \\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally solved a stack string medium question without help !!"
                    },
                    {
                        "username": "Agg_Riitk",
                        "content": "You have to use StringBuilder Method to store the result instead of storing it in a normal string. The reason for this is given below form a StackOverFlow Post.\\n\\n\\nEvery time you do stringA += stringB; a new string is created an assigned to stringA, so it will consume memory (a new string instance!) and time (copy the old string + new characters of the other string).\\n\\nStringBuilder will use an array of characters internally and when you use the .append() method it will do several things:\\n\\n\\t-check if there are any free space for the string to append\\n\\t\\n\\t-again some internal checks and run a System.arraycopy to copy the characters of the string in the array.\\n\\t\\n\\t\\nSource :- https://stackoverflow.com/questions/22439177/why-is-stringbuilder-much-faster-than-string"
                    },
                    {
                        "username": "baburaoapte",
                        "content": "The approach using Stack - or any approach for that matter - how do you ensure that it\\'s the minimum number of brackets are being removed? How to prove that? I didn\\'t understand that part about the solution and it is very critical to the understanding of this problem. Please can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no need to use a stack here. Just traverse the string from left to right removing any unmatched closing parentheses (closing parenthesis count is greater than the opening parenthesis count) as you go then traverse the string from right to left removing any unmatched opening parentheses as you go."
                    }
                ]
            },
            {
                "id": 1568444,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using a Stack and String Builder\n\n  \n**Approach 2:** Two Pass String Builder\n\n  \n**Approach 3:** Shortened Two Pass String Builder\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calm27",
                        "content": "it seems to be \\'easy\\', not \\'medium\\' problem. \\nintuitive stack approach is pretty straight forward, however official approaches are kind confusing. "
                    },
                    {
                        "username": "Fedolodic",
                        "content": "Looking to see how the community would approach this follow-up. I can\\'t think of anything that beats the immutable string O(n) algorithm with 3 for-loops."
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Easy explanation | 4 min Hindi Video | Explained the crux of the problem \\nyoutube. com/watch?v=hLWkxDrdQPI"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Could you share math proof that stack approach gives optimal solution"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "***(...yet to go through LC solutions 2 and 3, but a wonderful LC solution 1)***\\n\\nThis is an interesting problem in a way that only if I know about the **Parentheses Properties**, **Stack Data Structure** and **relation between Parentheses and Stack**, I could come up with the solution (read LC solution 1) in an interview.\\n\\n**Parentheses Properties**: \\n* For parentheses to be balanced, count of Opens must be equal to count of Closes. eg: for ( ( ( ) ) ), count = 3 and 3\\n* Each Close must form a pair with previously encountered Open. eg: for ) ) ) ( ( (, though count = 3 and 3, each Close doesn\\'t have a previous Open to be paired with.\\n\\n**Stack Data Structure**\\n* First In First Out: Insertion and removeal happens at the same side. // recency based\\n\\n**Relation between Parentheses and Stack**\\n* For Parenetheses Property 2, Stack is the DS that facilitates this validation. On encountering Open, it is pushed into stack, and on encountering Close, the last Open (at the top of stack) is popped out. Now we have found a pair, we just need to compute similarly for the rest of the brackets. Depending on the problem, stack could either store the Open itslef or its index. Here we need to remove the corresponding bracket from input string, so we store index. \\n* For Parentheses Propert 1: At the end of the stack computation if stack is empty, we have equal counts of Open and Close.\\n* Extra Open: At the end of computation, if Opens are remaining, these are the extra brackets that make the parentheses unbalanced. These could be removed to make the parentheses balanced.\\n* Exra Close: If at any time during the computation, Close is encountered but stack is empty, it means this Close is extra (no Open to pair with) and is making already encountered parentheses unbalanced. This could be removed to continue the computation for the rest of the brackets.\\n* A thought that could hinder the proof: Instead of pairing currently computing Close with last Open, what if I pair a later Close with this Open, so the currently computing Close could be removed from making the parentheses unbalanced? \\nEg: `( ) )`. Parentheses 0 = last Open, Parentheses 1 = currently computing Close, Parentheses 2 = later Close\\nAnswer: It won\\'t make any difference to the overall number of \")\" we need to remove from the parantheses. \\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally solved a stack string medium question without help !!"
                    },
                    {
                        "username": "Agg_Riitk",
                        "content": "You have to use StringBuilder Method to store the result instead of storing it in a normal string. The reason for this is given below form a StackOverFlow Post.\\n\\n\\nEvery time you do stringA += stringB; a new string is created an assigned to stringA, so it will consume memory (a new string instance!) and time (copy the old string + new characters of the other string).\\n\\nStringBuilder will use an array of characters internally and when you use the .append() method it will do several things:\\n\\n\\t-check if there are any free space for the string to append\\n\\t\\n\\t-again some internal checks and run a System.arraycopy to copy the characters of the string in the array.\\n\\t\\n\\t\\nSource :- https://stackoverflow.com/questions/22439177/why-is-stringbuilder-much-faster-than-string"
                    },
                    {
                        "username": "baburaoapte",
                        "content": "The approach using Stack - or any approach for that matter - how do you ensure that it\\'s the minimum number of brackets are being removed? How to prove that? I didn\\'t understand that part about the solution and it is very critical to the understanding of this problem. Please can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no need to use a stack here. Just traverse the string from left to right removing any unmatched closing parentheses (closing parenthesis count is greater than the opening parenthesis count) as you go then traverse the string from right to left removing any unmatched opening parentheses as you go."
                    }
                ]
            },
            {
                "id": 1576507,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using a Stack and String Builder\n\n  \n**Approach 2:** Two Pass String Builder\n\n  \n**Approach 3:** Shortened Two Pass String Builder\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calm27",
                        "content": "it seems to be \\'easy\\', not \\'medium\\' problem. \\nintuitive stack approach is pretty straight forward, however official approaches are kind confusing. "
                    },
                    {
                        "username": "Fedolodic",
                        "content": "Looking to see how the community would approach this follow-up. I can\\'t think of anything that beats the immutable string O(n) algorithm with 3 for-loops."
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Easy explanation | 4 min Hindi Video | Explained the crux of the problem \\nyoutube. com/watch?v=hLWkxDrdQPI"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Could you share math proof that stack approach gives optimal solution"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "***(...yet to go through LC solutions 2 and 3, but a wonderful LC solution 1)***\\n\\nThis is an interesting problem in a way that only if I know about the **Parentheses Properties**, **Stack Data Structure** and **relation between Parentheses and Stack**, I could come up with the solution (read LC solution 1) in an interview.\\n\\n**Parentheses Properties**: \\n* For parentheses to be balanced, count of Opens must be equal to count of Closes. eg: for ( ( ( ) ) ), count = 3 and 3\\n* Each Close must form a pair with previously encountered Open. eg: for ) ) ) ( ( (, though count = 3 and 3, each Close doesn\\'t have a previous Open to be paired with.\\n\\n**Stack Data Structure**\\n* First In First Out: Insertion and removeal happens at the same side. // recency based\\n\\n**Relation between Parentheses and Stack**\\n* For Parenetheses Property 2, Stack is the DS that facilitates this validation. On encountering Open, it is pushed into stack, and on encountering Close, the last Open (at the top of stack) is popped out. Now we have found a pair, we just need to compute similarly for the rest of the brackets. Depending on the problem, stack could either store the Open itslef or its index. Here we need to remove the corresponding bracket from input string, so we store index. \\n* For Parentheses Propert 1: At the end of the stack computation if stack is empty, we have equal counts of Open and Close.\\n* Extra Open: At the end of computation, if Opens are remaining, these are the extra brackets that make the parentheses unbalanced. These could be removed to make the parentheses balanced.\\n* Exra Close: If at any time during the computation, Close is encountered but stack is empty, it means this Close is extra (no Open to pair with) and is making already encountered parentheses unbalanced. This could be removed to continue the computation for the rest of the brackets.\\n* A thought that could hinder the proof: Instead of pairing currently computing Close with last Open, what if I pair a later Close with this Open, so the currently computing Close could be removed from making the parentheses unbalanced? \\nEg: `( ) )`. Parentheses 0 = last Open, Parentheses 1 = currently computing Close, Parentheses 2 = later Close\\nAnswer: It won\\'t make any difference to the overall number of \")\" we need to remove from the parantheses. \\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally solved a stack string medium question without help !!"
                    },
                    {
                        "username": "Agg_Riitk",
                        "content": "You have to use StringBuilder Method to store the result instead of storing it in a normal string. The reason for this is given below form a StackOverFlow Post.\\n\\n\\nEvery time you do stringA += stringB; a new string is created an assigned to stringA, so it will consume memory (a new string instance!) and time (copy the old string + new characters of the other string).\\n\\nStringBuilder will use an array of characters internally and when you use the .append() method it will do several things:\\n\\n\\t-check if there are any free space for the string to append\\n\\t\\n\\t-again some internal checks and run a System.arraycopy to copy the characters of the string in the array.\\n\\t\\n\\t\\nSource :- https://stackoverflow.com/questions/22439177/why-is-stringbuilder-much-faster-than-string"
                    },
                    {
                        "username": "baburaoapte",
                        "content": "The approach using Stack - or any approach for that matter - how do you ensure that it\\'s the minimum number of brackets are being removed? How to prove that? I didn\\'t understand that part about the solution and it is very critical to the understanding of this problem. Please can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no need to use a stack here. Just traverse the string from left to right removing any unmatched closing parentheses (closing parenthesis count is greater than the opening parenthesis count) as you go then traverse the string from right to left removing any unmatched opening parentheses as you go."
                    }
                ]
            },
            {
                "id": 1574963,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using a Stack and String Builder\n\n  \n**Approach 2:** Two Pass String Builder\n\n  \n**Approach 3:** Shortened Two Pass String Builder\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calm27",
                        "content": "it seems to be \\'easy\\', not \\'medium\\' problem. \\nintuitive stack approach is pretty straight forward, however official approaches are kind confusing. "
                    },
                    {
                        "username": "Fedolodic",
                        "content": "Looking to see how the community would approach this follow-up. I can\\'t think of anything that beats the immutable string O(n) algorithm with 3 for-loops."
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Easy explanation | 4 min Hindi Video | Explained the crux of the problem \\nyoutube. com/watch?v=hLWkxDrdQPI"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Could you share math proof that stack approach gives optimal solution"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "***(...yet to go through LC solutions 2 and 3, but a wonderful LC solution 1)***\\n\\nThis is an interesting problem in a way that only if I know about the **Parentheses Properties**, **Stack Data Structure** and **relation between Parentheses and Stack**, I could come up with the solution (read LC solution 1) in an interview.\\n\\n**Parentheses Properties**: \\n* For parentheses to be balanced, count of Opens must be equal to count of Closes. eg: for ( ( ( ) ) ), count = 3 and 3\\n* Each Close must form a pair with previously encountered Open. eg: for ) ) ) ( ( (, though count = 3 and 3, each Close doesn\\'t have a previous Open to be paired with.\\n\\n**Stack Data Structure**\\n* First In First Out: Insertion and removeal happens at the same side. // recency based\\n\\n**Relation between Parentheses and Stack**\\n* For Parenetheses Property 2, Stack is the DS that facilitates this validation. On encountering Open, it is pushed into stack, and on encountering Close, the last Open (at the top of stack) is popped out. Now we have found a pair, we just need to compute similarly for the rest of the brackets. Depending on the problem, stack could either store the Open itslef or its index. Here we need to remove the corresponding bracket from input string, so we store index. \\n* For Parentheses Propert 1: At the end of the stack computation if stack is empty, we have equal counts of Open and Close.\\n* Extra Open: At the end of computation, if Opens are remaining, these are the extra brackets that make the parentheses unbalanced. These could be removed to make the parentheses balanced.\\n* Exra Close: If at any time during the computation, Close is encountered but stack is empty, it means this Close is extra (no Open to pair with) and is making already encountered parentheses unbalanced. This could be removed to continue the computation for the rest of the brackets.\\n* A thought that could hinder the proof: Instead of pairing currently computing Close with last Open, what if I pair a later Close with this Open, so the currently computing Close could be removed from making the parentheses unbalanced? \\nEg: `( ) )`. Parentheses 0 = last Open, Parentheses 1 = currently computing Close, Parentheses 2 = later Close\\nAnswer: It won\\'t make any difference to the overall number of \")\" we need to remove from the parantheses. \\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally solved a stack string medium question without help !!"
                    },
                    {
                        "username": "Agg_Riitk",
                        "content": "You have to use StringBuilder Method to store the result instead of storing it in a normal string. The reason for this is given below form a StackOverFlow Post.\\n\\n\\nEvery time you do stringA += stringB; a new string is created an assigned to stringA, so it will consume memory (a new string instance!) and time (copy the old string + new characters of the other string).\\n\\nStringBuilder will use an array of characters internally and when you use the .append() method it will do several things:\\n\\n\\t-check if there are any free space for the string to append\\n\\t\\n\\t-again some internal checks and run a System.arraycopy to copy the characters of the string in the array.\\n\\t\\n\\t\\nSource :- https://stackoverflow.com/questions/22439177/why-is-stringbuilder-much-faster-than-string"
                    },
                    {
                        "username": "baburaoapte",
                        "content": "The approach using Stack - or any approach for that matter - how do you ensure that it\\'s the minimum number of brackets are being removed? How to prove that? I didn\\'t understand that part about the solution and it is very critical to the understanding of this problem. Please can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no need to use a stack here. Just traverse the string from left to right removing any unmatched closing parentheses (closing parenthesis count is greater than the opening parenthesis count) as you go then traverse the string from right to left removing any unmatched opening parentheses as you go."
                    }
                ]
            },
            {
                "id": 1574957,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using a Stack and String Builder\n\n  \n**Approach 2:** Two Pass String Builder\n\n  \n**Approach 3:** Shortened Two Pass String Builder\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calm27",
                        "content": "it seems to be \\'easy\\', not \\'medium\\' problem. \\nintuitive stack approach is pretty straight forward, however official approaches are kind confusing. "
                    },
                    {
                        "username": "Fedolodic",
                        "content": "Looking to see how the community would approach this follow-up. I can\\'t think of anything that beats the immutable string O(n) algorithm with 3 for-loops."
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Easy explanation | 4 min Hindi Video | Explained the crux of the problem \\nyoutube. com/watch?v=hLWkxDrdQPI"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Could you share math proof that stack approach gives optimal solution"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "***(...yet to go through LC solutions 2 and 3, but a wonderful LC solution 1)***\\n\\nThis is an interesting problem in a way that only if I know about the **Parentheses Properties**, **Stack Data Structure** and **relation between Parentheses and Stack**, I could come up with the solution (read LC solution 1) in an interview.\\n\\n**Parentheses Properties**: \\n* For parentheses to be balanced, count of Opens must be equal to count of Closes. eg: for ( ( ( ) ) ), count = 3 and 3\\n* Each Close must form a pair with previously encountered Open. eg: for ) ) ) ( ( (, though count = 3 and 3, each Close doesn\\'t have a previous Open to be paired with.\\n\\n**Stack Data Structure**\\n* First In First Out: Insertion and removeal happens at the same side. // recency based\\n\\n**Relation between Parentheses and Stack**\\n* For Parenetheses Property 2, Stack is the DS that facilitates this validation. On encountering Open, it is pushed into stack, and on encountering Close, the last Open (at the top of stack) is popped out. Now we have found a pair, we just need to compute similarly for the rest of the brackets. Depending on the problem, stack could either store the Open itslef or its index. Here we need to remove the corresponding bracket from input string, so we store index. \\n* For Parentheses Propert 1: At the end of the stack computation if stack is empty, we have equal counts of Open and Close.\\n* Extra Open: At the end of computation, if Opens are remaining, these are the extra brackets that make the parentheses unbalanced. These could be removed to make the parentheses balanced.\\n* Exra Close: If at any time during the computation, Close is encountered but stack is empty, it means this Close is extra (no Open to pair with) and is making already encountered parentheses unbalanced. This could be removed to continue the computation for the rest of the brackets.\\n* A thought that could hinder the proof: Instead of pairing currently computing Close with last Open, what if I pair a later Close with this Open, so the currently computing Close could be removed from making the parentheses unbalanced? \\nEg: `( ) )`. Parentheses 0 = last Open, Parentheses 1 = currently computing Close, Parentheses 2 = later Close\\nAnswer: It won\\'t make any difference to the overall number of \")\" we need to remove from the parantheses. \\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally solved a stack string medium question without help !!"
                    },
                    {
                        "username": "Agg_Riitk",
                        "content": "You have to use StringBuilder Method to store the result instead of storing it in a normal string. The reason for this is given below form a StackOverFlow Post.\\n\\n\\nEvery time you do stringA += stringB; a new string is created an assigned to stringA, so it will consume memory (a new string instance!) and time (copy the old string + new characters of the other string).\\n\\nStringBuilder will use an array of characters internally and when you use the .append() method it will do several things:\\n\\n\\t-check if there are any free space for the string to append\\n\\t\\n\\t-again some internal checks and run a System.arraycopy to copy the characters of the string in the array.\\n\\t\\n\\t\\nSource :- https://stackoverflow.com/questions/22439177/why-is-stringbuilder-much-faster-than-string"
                    },
                    {
                        "username": "baburaoapte",
                        "content": "The approach using Stack - or any approach for that matter - how do you ensure that it\\'s the minimum number of brackets are being removed? How to prove that? I didn\\'t understand that part about the solution and it is very critical to the understanding of this problem. Please can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no need to use a stack here. Just traverse the string from left to right removing any unmatched closing parentheses (closing parenthesis count is greater than the opening parenthesis count) as you go then traverse the string from right to left removing any unmatched opening parentheses as you go."
                    }
                ]
            },
            {
                "id": 1917201,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using a Stack and String Builder\n\n  \n**Approach 2:** Two Pass String Builder\n\n  \n**Approach 3:** Shortened Two Pass String Builder\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calm27",
                        "content": "it seems to be \\'easy\\', not \\'medium\\' problem. \\nintuitive stack approach is pretty straight forward, however official approaches are kind confusing. "
                    },
                    {
                        "username": "Fedolodic",
                        "content": "Looking to see how the community would approach this follow-up. I can\\'t think of anything that beats the immutable string O(n) algorithm with 3 for-loops."
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Easy explanation | 4 min Hindi Video | Explained the crux of the problem \\nyoutube. com/watch?v=hLWkxDrdQPI"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Could you share math proof that stack approach gives optimal solution"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "***(...yet to go through LC solutions 2 and 3, but a wonderful LC solution 1)***\\n\\nThis is an interesting problem in a way that only if I know about the **Parentheses Properties**, **Stack Data Structure** and **relation between Parentheses and Stack**, I could come up with the solution (read LC solution 1) in an interview.\\n\\n**Parentheses Properties**: \\n* For parentheses to be balanced, count of Opens must be equal to count of Closes. eg: for ( ( ( ) ) ), count = 3 and 3\\n* Each Close must form a pair with previously encountered Open. eg: for ) ) ) ( ( (, though count = 3 and 3, each Close doesn\\'t have a previous Open to be paired with.\\n\\n**Stack Data Structure**\\n* First In First Out: Insertion and removeal happens at the same side. // recency based\\n\\n**Relation between Parentheses and Stack**\\n* For Parenetheses Property 2, Stack is the DS that facilitates this validation. On encountering Open, it is pushed into stack, and on encountering Close, the last Open (at the top of stack) is popped out. Now we have found a pair, we just need to compute similarly for the rest of the brackets. Depending on the problem, stack could either store the Open itslef or its index. Here we need to remove the corresponding bracket from input string, so we store index. \\n* For Parentheses Propert 1: At the end of the stack computation if stack is empty, we have equal counts of Open and Close.\\n* Extra Open: At the end of computation, if Opens are remaining, these are the extra brackets that make the parentheses unbalanced. These could be removed to make the parentheses balanced.\\n* Exra Close: If at any time during the computation, Close is encountered but stack is empty, it means this Close is extra (no Open to pair with) and is making already encountered parentheses unbalanced. This could be removed to continue the computation for the rest of the brackets.\\n* A thought that could hinder the proof: Instead of pairing currently computing Close with last Open, what if I pair a later Close with this Open, so the currently computing Close could be removed from making the parentheses unbalanced? \\nEg: `( ) )`. Parentheses 0 = last Open, Parentheses 1 = currently computing Close, Parentheses 2 = later Close\\nAnswer: It won\\'t make any difference to the overall number of \")\" we need to remove from the parantheses. \\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally solved a stack string medium question without help !!"
                    },
                    {
                        "username": "Agg_Riitk",
                        "content": "You have to use StringBuilder Method to store the result instead of storing it in a normal string. The reason for this is given below form a StackOverFlow Post.\\n\\n\\nEvery time you do stringA += stringB; a new string is created an assigned to stringA, so it will consume memory (a new string instance!) and time (copy the old string + new characters of the other string).\\n\\nStringBuilder will use an array of characters internally and when you use the .append() method it will do several things:\\n\\n\\t-check if there are any free space for the string to append\\n\\t\\n\\t-again some internal checks and run a System.arraycopy to copy the characters of the string in the array.\\n\\t\\n\\t\\nSource :- https://stackoverflow.com/questions/22439177/why-is-stringbuilder-much-faster-than-string"
                    },
                    {
                        "username": "baburaoapte",
                        "content": "The approach using Stack - or any approach for that matter - how do you ensure that it\\'s the minimum number of brackets are being removed? How to prove that? I didn\\'t understand that part about the solution and it is very critical to the understanding of this problem. Please can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no need to use a stack here. Just traverse the string from left to right removing any unmatched closing parentheses (closing parenthesis count is greater than the opening parenthesis count) as you go then traverse the string from right to left removing any unmatched opening parentheses as you go."
                    }
                ]
            },
            {
                "id": 1576508,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using a Stack and String Builder\n\n  \n**Approach 2:** Two Pass String Builder\n\n  \n**Approach 3:** Shortened Two Pass String Builder\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calm27",
                        "content": "it seems to be \\'easy\\', not \\'medium\\' problem. \\nintuitive stack approach is pretty straight forward, however official approaches are kind confusing. "
                    },
                    {
                        "username": "Fedolodic",
                        "content": "Looking to see how the community would approach this follow-up. I can\\'t think of anything that beats the immutable string O(n) algorithm with 3 for-loops."
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Easy explanation | 4 min Hindi Video | Explained the crux of the problem \\nyoutube. com/watch?v=hLWkxDrdQPI"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Could you share math proof that stack approach gives optimal solution"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "***(...yet to go through LC solutions 2 and 3, but a wonderful LC solution 1)***\\n\\nThis is an interesting problem in a way that only if I know about the **Parentheses Properties**, **Stack Data Structure** and **relation between Parentheses and Stack**, I could come up with the solution (read LC solution 1) in an interview.\\n\\n**Parentheses Properties**: \\n* For parentheses to be balanced, count of Opens must be equal to count of Closes. eg: for ( ( ( ) ) ), count = 3 and 3\\n* Each Close must form a pair with previously encountered Open. eg: for ) ) ) ( ( (, though count = 3 and 3, each Close doesn\\'t have a previous Open to be paired with.\\n\\n**Stack Data Structure**\\n* First In First Out: Insertion and removeal happens at the same side. // recency based\\n\\n**Relation between Parentheses and Stack**\\n* For Parenetheses Property 2, Stack is the DS that facilitates this validation. On encountering Open, it is pushed into stack, and on encountering Close, the last Open (at the top of stack) is popped out. Now we have found a pair, we just need to compute similarly for the rest of the brackets. Depending on the problem, stack could either store the Open itslef or its index. Here we need to remove the corresponding bracket from input string, so we store index. \\n* For Parentheses Propert 1: At the end of the stack computation if stack is empty, we have equal counts of Open and Close.\\n* Extra Open: At the end of computation, if Opens are remaining, these are the extra brackets that make the parentheses unbalanced. These could be removed to make the parentheses balanced.\\n* Exra Close: If at any time during the computation, Close is encountered but stack is empty, it means this Close is extra (no Open to pair with) and is making already encountered parentheses unbalanced. This could be removed to continue the computation for the rest of the brackets.\\n* A thought that could hinder the proof: Instead of pairing currently computing Close with last Open, what if I pair a later Close with this Open, so the currently computing Close could be removed from making the parentheses unbalanced? \\nEg: `( ) )`. Parentheses 0 = last Open, Parentheses 1 = currently computing Close, Parentheses 2 = later Close\\nAnswer: It won\\'t make any difference to the overall number of \")\" we need to remove from the parantheses. \\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally solved a stack string medium question without help !!"
                    },
                    {
                        "username": "Agg_Riitk",
                        "content": "You have to use StringBuilder Method to store the result instead of storing it in a normal string. The reason for this is given below form a StackOverFlow Post.\\n\\n\\nEvery time you do stringA += stringB; a new string is created an assigned to stringA, so it will consume memory (a new string instance!) and time (copy the old string + new characters of the other string).\\n\\nStringBuilder will use an array of characters internally and when you use the .append() method it will do several things:\\n\\n\\t-check if there are any free space for the string to append\\n\\t\\n\\t-again some internal checks and run a System.arraycopy to copy the characters of the string in the array.\\n\\t\\n\\t\\nSource :- https://stackoverflow.com/questions/22439177/why-is-stringbuilder-much-faster-than-string"
                    },
                    {
                        "username": "baburaoapte",
                        "content": "The approach using Stack - or any approach for that matter - how do you ensure that it\\'s the minimum number of brackets are being removed? How to prove that? I didn\\'t understand that part about the solution and it is very critical to the understanding of this problem. Please can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no need to use a stack here. Just traverse the string from left to right removing any unmatched closing parentheses (closing parenthesis count is greater than the opening parenthesis count) as you go then traverse the string from right to left removing any unmatched opening parentheses as you go."
                    }
                ]
            },
            {
                "id": 1575579,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using a Stack and String Builder\n\n  \n**Approach 2:** Two Pass String Builder\n\n  \n**Approach 3:** Shortened Two Pass String Builder\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calm27",
                        "content": "it seems to be \\'easy\\', not \\'medium\\' problem. \\nintuitive stack approach is pretty straight forward, however official approaches are kind confusing. "
                    },
                    {
                        "username": "Fedolodic",
                        "content": "Looking to see how the community would approach this follow-up. I can\\'t think of anything that beats the immutable string O(n) algorithm with 3 for-loops."
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Easy explanation | 4 min Hindi Video | Explained the crux of the problem \\nyoutube. com/watch?v=hLWkxDrdQPI"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Could you share math proof that stack approach gives optimal solution"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "***(...yet to go through LC solutions 2 and 3, but a wonderful LC solution 1)***\\n\\nThis is an interesting problem in a way that only if I know about the **Parentheses Properties**, **Stack Data Structure** and **relation between Parentheses and Stack**, I could come up with the solution (read LC solution 1) in an interview.\\n\\n**Parentheses Properties**: \\n* For parentheses to be balanced, count of Opens must be equal to count of Closes. eg: for ( ( ( ) ) ), count = 3 and 3\\n* Each Close must form a pair with previously encountered Open. eg: for ) ) ) ( ( (, though count = 3 and 3, each Close doesn\\'t have a previous Open to be paired with.\\n\\n**Stack Data Structure**\\n* First In First Out: Insertion and removeal happens at the same side. // recency based\\n\\n**Relation between Parentheses and Stack**\\n* For Parenetheses Property 2, Stack is the DS that facilitates this validation. On encountering Open, it is pushed into stack, and on encountering Close, the last Open (at the top of stack) is popped out. Now we have found a pair, we just need to compute similarly for the rest of the brackets. Depending on the problem, stack could either store the Open itslef or its index. Here we need to remove the corresponding bracket from input string, so we store index. \\n* For Parentheses Propert 1: At the end of the stack computation if stack is empty, we have equal counts of Open and Close.\\n* Extra Open: At the end of computation, if Opens are remaining, these are the extra brackets that make the parentheses unbalanced. These could be removed to make the parentheses balanced.\\n* Exra Close: If at any time during the computation, Close is encountered but stack is empty, it means this Close is extra (no Open to pair with) and is making already encountered parentheses unbalanced. This could be removed to continue the computation for the rest of the brackets.\\n* A thought that could hinder the proof: Instead of pairing currently computing Close with last Open, what if I pair a later Close with this Open, so the currently computing Close could be removed from making the parentheses unbalanced? \\nEg: `( ) )`. Parentheses 0 = last Open, Parentheses 1 = currently computing Close, Parentheses 2 = later Close\\nAnswer: It won\\'t make any difference to the overall number of \")\" we need to remove from the parantheses. \\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally solved a stack string medium question without help !!"
                    },
                    {
                        "username": "Agg_Riitk",
                        "content": "You have to use StringBuilder Method to store the result instead of storing it in a normal string. The reason for this is given below form a StackOverFlow Post.\\n\\n\\nEvery time you do stringA += stringB; a new string is created an assigned to stringA, so it will consume memory (a new string instance!) and time (copy the old string + new characters of the other string).\\n\\nStringBuilder will use an array of characters internally and when you use the .append() method it will do several things:\\n\\n\\t-check if there are any free space for the string to append\\n\\t\\n\\t-again some internal checks and run a System.arraycopy to copy the characters of the string in the array.\\n\\t\\n\\t\\nSource :- https://stackoverflow.com/questions/22439177/why-is-stringbuilder-much-faster-than-string"
                    },
                    {
                        "username": "baburaoapte",
                        "content": "The approach using Stack - or any approach for that matter - how do you ensure that it\\'s the minimum number of brackets are being removed? How to prove that? I didn\\'t understand that part about the solution and it is very critical to the understanding of this problem. Please can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no need to use a stack here. Just traverse the string from left to right removing any unmatched closing parentheses (closing parenthesis count is greater than the opening parenthesis count) as you go then traverse the string from right to left removing any unmatched opening parentheses as you go."
                    }
                ]
            },
            {
                "id": 1864076,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using a Stack and String Builder\n\n  \n**Approach 2:** Two Pass String Builder\n\n  \n**Approach 3:** Shortened Two Pass String Builder\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calm27",
                        "content": "it seems to be \\'easy\\', not \\'medium\\' problem. \\nintuitive stack approach is pretty straight forward, however official approaches are kind confusing. "
                    },
                    {
                        "username": "Fedolodic",
                        "content": "Looking to see how the community would approach this follow-up. I can\\'t think of anything that beats the immutable string O(n) algorithm with 3 for-loops."
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Easy explanation | 4 min Hindi Video | Explained the crux of the problem \\nyoutube. com/watch?v=hLWkxDrdQPI"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Could you share math proof that stack approach gives optimal solution"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "***(...yet to go through LC solutions 2 and 3, but a wonderful LC solution 1)***\\n\\nThis is an interesting problem in a way that only if I know about the **Parentheses Properties**, **Stack Data Structure** and **relation between Parentheses and Stack**, I could come up with the solution (read LC solution 1) in an interview.\\n\\n**Parentheses Properties**: \\n* For parentheses to be balanced, count of Opens must be equal to count of Closes. eg: for ( ( ( ) ) ), count = 3 and 3\\n* Each Close must form a pair with previously encountered Open. eg: for ) ) ) ( ( (, though count = 3 and 3, each Close doesn\\'t have a previous Open to be paired with.\\n\\n**Stack Data Structure**\\n* First In First Out: Insertion and removeal happens at the same side. // recency based\\n\\n**Relation between Parentheses and Stack**\\n* For Parenetheses Property 2, Stack is the DS that facilitates this validation. On encountering Open, it is pushed into stack, and on encountering Close, the last Open (at the top of stack) is popped out. Now we have found a pair, we just need to compute similarly for the rest of the brackets. Depending on the problem, stack could either store the Open itslef or its index. Here we need to remove the corresponding bracket from input string, so we store index. \\n* For Parentheses Propert 1: At the end of the stack computation if stack is empty, we have equal counts of Open and Close.\\n* Extra Open: At the end of computation, if Opens are remaining, these are the extra brackets that make the parentheses unbalanced. These could be removed to make the parentheses balanced.\\n* Exra Close: If at any time during the computation, Close is encountered but stack is empty, it means this Close is extra (no Open to pair with) and is making already encountered parentheses unbalanced. This could be removed to continue the computation for the rest of the brackets.\\n* A thought that could hinder the proof: Instead of pairing currently computing Close with last Open, what if I pair a later Close with this Open, so the currently computing Close could be removed from making the parentheses unbalanced? \\nEg: `( ) )`. Parentheses 0 = last Open, Parentheses 1 = currently computing Close, Parentheses 2 = later Close\\nAnswer: It won\\'t make any difference to the overall number of \")\" we need to remove from the parantheses. \\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally solved a stack string medium question without help !!"
                    },
                    {
                        "username": "Agg_Riitk",
                        "content": "You have to use StringBuilder Method to store the result instead of storing it in a normal string. The reason for this is given below form a StackOverFlow Post.\\n\\n\\nEvery time you do stringA += stringB; a new string is created an assigned to stringA, so it will consume memory (a new string instance!) and time (copy the old string + new characters of the other string).\\n\\nStringBuilder will use an array of characters internally and when you use the .append() method it will do several things:\\n\\n\\t-check if there are any free space for the string to append\\n\\t\\n\\t-again some internal checks and run a System.arraycopy to copy the characters of the string in the array.\\n\\t\\n\\t\\nSource :- https://stackoverflow.com/questions/22439177/why-is-stringbuilder-much-faster-than-string"
                    },
                    {
                        "username": "baburaoapte",
                        "content": "The approach using Stack - or any approach for that matter - how do you ensure that it\\'s the minimum number of brackets are being removed? How to prove that? I didn\\'t understand that part about the solution and it is very critical to the understanding of this problem. Please can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no need to use a stack here. Just traverse the string from left to right removing any unmatched closing parentheses (closing parenthesis count is greater than the opening parenthesis count) as you go then traverse the string from right to left removing any unmatched opening parentheses as you go."
                    }
                ]
            },
            {
                "id": 1565646,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using a Stack and String Builder\n\n  \n**Approach 2:** Two Pass String Builder\n\n  \n**Approach 3:** Shortened Two Pass String Builder\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calm27",
                        "content": "it seems to be \\'easy\\', not \\'medium\\' problem. \\nintuitive stack approach is pretty straight forward, however official approaches are kind confusing. "
                    },
                    {
                        "username": "Fedolodic",
                        "content": "Looking to see how the community would approach this follow-up. I can\\'t think of anything that beats the immutable string O(n) algorithm with 3 for-loops."
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Easy explanation | 4 min Hindi Video | Explained the crux of the problem \\nyoutube. com/watch?v=hLWkxDrdQPI"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Could you share math proof that stack approach gives optimal solution"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "***(...yet to go through LC solutions 2 and 3, but a wonderful LC solution 1)***\\n\\nThis is an interesting problem in a way that only if I know about the **Parentheses Properties**, **Stack Data Structure** and **relation between Parentheses and Stack**, I could come up with the solution (read LC solution 1) in an interview.\\n\\n**Parentheses Properties**: \\n* For parentheses to be balanced, count of Opens must be equal to count of Closes. eg: for ( ( ( ) ) ), count = 3 and 3\\n* Each Close must form a pair with previously encountered Open. eg: for ) ) ) ( ( (, though count = 3 and 3, each Close doesn\\'t have a previous Open to be paired with.\\n\\n**Stack Data Structure**\\n* First In First Out: Insertion and removeal happens at the same side. // recency based\\n\\n**Relation between Parentheses and Stack**\\n* For Parenetheses Property 2, Stack is the DS that facilitates this validation. On encountering Open, it is pushed into stack, and on encountering Close, the last Open (at the top of stack) is popped out. Now we have found a pair, we just need to compute similarly for the rest of the brackets. Depending on the problem, stack could either store the Open itslef or its index. Here we need to remove the corresponding bracket from input string, so we store index. \\n* For Parentheses Propert 1: At the end of the stack computation if stack is empty, we have equal counts of Open and Close.\\n* Extra Open: At the end of computation, if Opens are remaining, these are the extra brackets that make the parentheses unbalanced. These could be removed to make the parentheses balanced.\\n* Exra Close: If at any time during the computation, Close is encountered but stack is empty, it means this Close is extra (no Open to pair with) and is making already encountered parentheses unbalanced. This could be removed to continue the computation for the rest of the brackets.\\n* A thought that could hinder the proof: Instead of pairing currently computing Close with last Open, what if I pair a later Close with this Open, so the currently computing Close could be removed from making the parentheses unbalanced? \\nEg: `( ) )`. Parentheses 0 = last Open, Parentheses 1 = currently computing Close, Parentheses 2 = later Close\\nAnswer: It won\\'t make any difference to the overall number of \")\" we need to remove from the parantheses. \\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally solved a stack string medium question without help !!"
                    },
                    {
                        "username": "Agg_Riitk",
                        "content": "You have to use StringBuilder Method to store the result instead of storing it in a normal string. The reason for this is given below form a StackOverFlow Post.\\n\\n\\nEvery time you do stringA += stringB; a new string is created an assigned to stringA, so it will consume memory (a new string instance!) and time (copy the old string + new characters of the other string).\\n\\nStringBuilder will use an array of characters internally and when you use the .append() method it will do several things:\\n\\n\\t-check if there are any free space for the string to append\\n\\t\\n\\t-again some internal checks and run a System.arraycopy to copy the characters of the string in the array.\\n\\t\\n\\t\\nSource :- https://stackoverflow.com/questions/22439177/why-is-stringbuilder-much-faster-than-string"
                    },
                    {
                        "username": "baburaoapte",
                        "content": "The approach using Stack - or any approach for that matter - how do you ensure that it\\'s the minimum number of brackets are being removed? How to prove that? I didn\\'t understand that part about the solution and it is very critical to the understanding of this problem. Please can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no need to use a stack here. Just traverse the string from left to right removing any unmatched closing parentheses (closing parenthesis count is greater than the opening parenthesis count) as you go then traverse the string from right to left removing any unmatched opening parentheses as you go."
                    }
                ]
            },
            {
                "id": 1733314,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using a Stack and String Builder\n\n  \n**Approach 2:** Two Pass String Builder\n\n  \n**Approach 3:** Shortened Two Pass String Builder\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calm27",
                        "content": "it seems to be \\'easy\\', not \\'medium\\' problem. \\nintuitive stack approach is pretty straight forward, however official approaches are kind confusing. "
                    },
                    {
                        "username": "Fedolodic",
                        "content": "Looking to see how the community would approach this follow-up. I can\\'t think of anything that beats the immutable string O(n) algorithm with 3 for-loops."
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Easy explanation | 4 min Hindi Video | Explained the crux of the problem \\nyoutube. com/watch?v=hLWkxDrdQPI"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Could you share math proof that stack approach gives optimal solution"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "***(...yet to go through LC solutions 2 and 3, but a wonderful LC solution 1)***\\n\\nThis is an interesting problem in a way that only if I know about the **Parentheses Properties**, **Stack Data Structure** and **relation between Parentheses and Stack**, I could come up with the solution (read LC solution 1) in an interview.\\n\\n**Parentheses Properties**: \\n* For parentheses to be balanced, count of Opens must be equal to count of Closes. eg: for ( ( ( ) ) ), count = 3 and 3\\n* Each Close must form a pair with previously encountered Open. eg: for ) ) ) ( ( (, though count = 3 and 3, each Close doesn\\'t have a previous Open to be paired with.\\n\\n**Stack Data Structure**\\n* First In First Out: Insertion and removeal happens at the same side. // recency based\\n\\n**Relation between Parentheses and Stack**\\n* For Parenetheses Property 2, Stack is the DS that facilitates this validation. On encountering Open, it is pushed into stack, and on encountering Close, the last Open (at the top of stack) is popped out. Now we have found a pair, we just need to compute similarly for the rest of the brackets. Depending on the problem, stack could either store the Open itslef or its index. Here we need to remove the corresponding bracket from input string, so we store index. \\n* For Parentheses Propert 1: At the end of the stack computation if stack is empty, we have equal counts of Open and Close.\\n* Extra Open: At the end of computation, if Opens are remaining, these are the extra brackets that make the parentheses unbalanced. These could be removed to make the parentheses balanced.\\n* Exra Close: If at any time during the computation, Close is encountered but stack is empty, it means this Close is extra (no Open to pair with) and is making already encountered parentheses unbalanced. This could be removed to continue the computation for the rest of the brackets.\\n* A thought that could hinder the proof: Instead of pairing currently computing Close with last Open, what if I pair a later Close with this Open, so the currently computing Close could be removed from making the parentheses unbalanced? \\nEg: `( ) )`. Parentheses 0 = last Open, Parentheses 1 = currently computing Close, Parentheses 2 = later Close\\nAnswer: It won\\'t make any difference to the overall number of \")\" we need to remove from the parantheses. \\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally solved a stack string medium question without help !!"
                    },
                    {
                        "username": "Agg_Riitk",
                        "content": "You have to use StringBuilder Method to store the result instead of storing it in a normal string. The reason for this is given below form a StackOverFlow Post.\\n\\n\\nEvery time you do stringA += stringB; a new string is created an assigned to stringA, so it will consume memory (a new string instance!) and time (copy the old string + new characters of the other string).\\n\\nStringBuilder will use an array of characters internally and when you use the .append() method it will do several things:\\n\\n\\t-check if there are any free space for the string to append\\n\\t\\n\\t-again some internal checks and run a System.arraycopy to copy the characters of the string in the array.\\n\\t\\n\\t\\nSource :- https://stackoverflow.com/questions/22439177/why-is-stringbuilder-much-faster-than-string"
                    },
                    {
                        "username": "baburaoapte",
                        "content": "The approach using Stack - or any approach for that matter - how do you ensure that it\\'s the minimum number of brackets are being removed? How to prove that? I didn\\'t understand that part about the solution and it is very critical to the understanding of this problem. Please can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no need to use a stack here. Just traverse the string from left to right removing any unmatched closing parentheses (closing parenthesis count is greater than the opening parenthesis count) as you go then traverse the string from right to left removing any unmatched opening parentheses as you go."
                    }
                ]
            },
            {
                "id": 1568444,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using a Stack and String Builder\n\n  \n**Approach 2:** Two Pass String Builder\n\n  \n**Approach 3:** Shortened Two Pass String Builder\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calm27",
                        "content": "it seems to be \\'easy\\', not \\'medium\\' problem. \\nintuitive stack approach is pretty straight forward, however official approaches are kind confusing. "
                    },
                    {
                        "username": "Fedolodic",
                        "content": "Looking to see how the community would approach this follow-up. I can\\'t think of anything that beats the immutable string O(n) algorithm with 3 for-loops."
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Easy explanation | 4 min Hindi Video | Explained the crux of the problem \\nyoutube. com/watch?v=hLWkxDrdQPI"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Could you share math proof that stack approach gives optimal solution"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "***(...yet to go through LC solutions 2 and 3, but a wonderful LC solution 1)***\\n\\nThis is an interesting problem in a way that only if I know about the **Parentheses Properties**, **Stack Data Structure** and **relation between Parentheses and Stack**, I could come up with the solution (read LC solution 1) in an interview.\\n\\n**Parentheses Properties**: \\n* For parentheses to be balanced, count of Opens must be equal to count of Closes. eg: for ( ( ( ) ) ), count = 3 and 3\\n* Each Close must form a pair with previously encountered Open. eg: for ) ) ) ( ( (, though count = 3 and 3, each Close doesn\\'t have a previous Open to be paired with.\\n\\n**Stack Data Structure**\\n* First In First Out: Insertion and removeal happens at the same side. // recency based\\n\\n**Relation between Parentheses and Stack**\\n* For Parenetheses Property 2, Stack is the DS that facilitates this validation. On encountering Open, it is pushed into stack, and on encountering Close, the last Open (at the top of stack) is popped out. Now we have found a pair, we just need to compute similarly for the rest of the brackets. Depending on the problem, stack could either store the Open itslef or its index. Here we need to remove the corresponding bracket from input string, so we store index. \\n* For Parentheses Propert 1: At the end of the stack computation if stack is empty, we have equal counts of Open and Close.\\n* Extra Open: At the end of computation, if Opens are remaining, these are the extra brackets that make the parentheses unbalanced. These could be removed to make the parentheses balanced.\\n* Exra Close: If at any time during the computation, Close is encountered but stack is empty, it means this Close is extra (no Open to pair with) and is making already encountered parentheses unbalanced. This could be removed to continue the computation for the rest of the brackets.\\n* A thought that could hinder the proof: Instead of pairing currently computing Close with last Open, what if I pair a later Close with this Open, so the currently computing Close could be removed from making the parentheses unbalanced? \\nEg: `( ) )`. Parentheses 0 = last Open, Parentheses 1 = currently computing Close, Parentheses 2 = later Close\\nAnswer: It won\\'t make any difference to the overall number of \")\" we need to remove from the parantheses. \\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally solved a stack string medium question without help !!"
                    },
                    {
                        "username": "Agg_Riitk",
                        "content": "You have to use StringBuilder Method to store the result instead of storing it in a normal string. The reason for this is given below form a StackOverFlow Post.\\n\\n\\nEvery time you do stringA += stringB; a new string is created an assigned to stringA, so it will consume memory (a new string instance!) and time (copy the old string + new characters of the other string).\\n\\nStringBuilder will use an array of characters internally and when you use the .append() method it will do several things:\\n\\n\\t-check if there are any free space for the string to append\\n\\t\\n\\t-again some internal checks and run a System.arraycopy to copy the characters of the string in the array.\\n\\t\\n\\t\\nSource :- https://stackoverflow.com/questions/22439177/why-is-stringbuilder-much-faster-than-string"
                    },
                    {
                        "username": "baburaoapte",
                        "content": "The approach using Stack - or any approach for that matter - how do you ensure that it\\'s the minimum number of brackets are being removed? How to prove that? I didn\\'t understand that part about the solution and it is very critical to the understanding of this problem. Please can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no need to use a stack here. Just traverse the string from left to right removing any unmatched closing parentheses (closing parenthesis count is greater than the opening parenthesis count) as you go then traverse the string from right to left removing any unmatched opening parentheses as you go."
                    }
                ]
            },
            {
                "id": 1576507,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using a Stack and String Builder\n\n  \n**Approach 2:** Two Pass String Builder\n\n  \n**Approach 3:** Shortened Two Pass String Builder\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calm27",
                        "content": "it seems to be \\'easy\\', not \\'medium\\' problem. \\nintuitive stack approach is pretty straight forward, however official approaches are kind confusing. "
                    },
                    {
                        "username": "Fedolodic",
                        "content": "Looking to see how the community would approach this follow-up. I can\\'t think of anything that beats the immutable string O(n) algorithm with 3 for-loops."
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Easy explanation | 4 min Hindi Video | Explained the crux of the problem \\nyoutube. com/watch?v=hLWkxDrdQPI"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Could you share math proof that stack approach gives optimal solution"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "***(...yet to go through LC solutions 2 and 3, but a wonderful LC solution 1)***\\n\\nThis is an interesting problem in a way that only if I know about the **Parentheses Properties**, **Stack Data Structure** and **relation between Parentheses and Stack**, I could come up with the solution (read LC solution 1) in an interview.\\n\\n**Parentheses Properties**: \\n* For parentheses to be balanced, count of Opens must be equal to count of Closes. eg: for ( ( ( ) ) ), count = 3 and 3\\n* Each Close must form a pair with previously encountered Open. eg: for ) ) ) ( ( (, though count = 3 and 3, each Close doesn\\'t have a previous Open to be paired with.\\n\\n**Stack Data Structure**\\n* First In First Out: Insertion and removeal happens at the same side. // recency based\\n\\n**Relation between Parentheses and Stack**\\n* For Parenetheses Property 2, Stack is the DS that facilitates this validation. On encountering Open, it is pushed into stack, and on encountering Close, the last Open (at the top of stack) is popped out. Now we have found a pair, we just need to compute similarly for the rest of the brackets. Depending on the problem, stack could either store the Open itslef or its index. Here we need to remove the corresponding bracket from input string, so we store index. \\n* For Parentheses Propert 1: At the end of the stack computation if stack is empty, we have equal counts of Open and Close.\\n* Extra Open: At the end of computation, if Opens are remaining, these are the extra brackets that make the parentheses unbalanced. These could be removed to make the parentheses balanced.\\n* Exra Close: If at any time during the computation, Close is encountered but stack is empty, it means this Close is extra (no Open to pair with) and is making already encountered parentheses unbalanced. This could be removed to continue the computation for the rest of the brackets.\\n* A thought that could hinder the proof: Instead of pairing currently computing Close with last Open, what if I pair a later Close with this Open, so the currently computing Close could be removed from making the parentheses unbalanced? \\nEg: `( ) )`. Parentheses 0 = last Open, Parentheses 1 = currently computing Close, Parentheses 2 = later Close\\nAnswer: It won\\'t make any difference to the overall number of \")\" we need to remove from the parantheses. \\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally solved a stack string medium question without help !!"
                    },
                    {
                        "username": "Agg_Riitk",
                        "content": "You have to use StringBuilder Method to store the result instead of storing it in a normal string. The reason for this is given below form a StackOverFlow Post.\\n\\n\\nEvery time you do stringA += stringB; a new string is created an assigned to stringA, so it will consume memory (a new string instance!) and time (copy the old string + new characters of the other string).\\n\\nStringBuilder will use an array of characters internally and when you use the .append() method it will do several things:\\n\\n\\t-check if there are any free space for the string to append\\n\\t\\n\\t-again some internal checks and run a System.arraycopy to copy the characters of the string in the array.\\n\\t\\n\\t\\nSource :- https://stackoverflow.com/questions/22439177/why-is-stringbuilder-much-faster-than-string"
                    },
                    {
                        "username": "baburaoapte",
                        "content": "The approach using Stack - or any approach for that matter - how do you ensure that it\\'s the minimum number of brackets are being removed? How to prove that? I didn\\'t understand that part about the solution and it is very critical to the understanding of this problem. Please can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no need to use a stack here. Just traverse the string from left to right removing any unmatched closing parentheses (closing parenthesis count is greater than the opening parenthesis count) as you go then traverse the string from right to left removing any unmatched opening parentheses as you go."
                    }
                ]
            },
            {
                "id": 1574963,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using a Stack and String Builder\n\n  \n**Approach 2:** Two Pass String Builder\n\n  \n**Approach 3:** Shortened Two Pass String Builder\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calm27",
                        "content": "it seems to be \\'easy\\', not \\'medium\\' problem. \\nintuitive stack approach is pretty straight forward, however official approaches are kind confusing. "
                    },
                    {
                        "username": "Fedolodic",
                        "content": "Looking to see how the community would approach this follow-up. I can\\'t think of anything that beats the immutable string O(n) algorithm with 3 for-loops."
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Easy explanation | 4 min Hindi Video | Explained the crux of the problem \\nyoutube. com/watch?v=hLWkxDrdQPI"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Could you share math proof that stack approach gives optimal solution"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "***(...yet to go through LC solutions 2 and 3, but a wonderful LC solution 1)***\\n\\nThis is an interesting problem in a way that only if I know about the **Parentheses Properties**, **Stack Data Structure** and **relation between Parentheses and Stack**, I could come up with the solution (read LC solution 1) in an interview.\\n\\n**Parentheses Properties**: \\n* For parentheses to be balanced, count of Opens must be equal to count of Closes. eg: for ( ( ( ) ) ), count = 3 and 3\\n* Each Close must form a pair with previously encountered Open. eg: for ) ) ) ( ( (, though count = 3 and 3, each Close doesn\\'t have a previous Open to be paired with.\\n\\n**Stack Data Structure**\\n* First In First Out: Insertion and removeal happens at the same side. // recency based\\n\\n**Relation between Parentheses and Stack**\\n* For Parenetheses Property 2, Stack is the DS that facilitates this validation. On encountering Open, it is pushed into stack, and on encountering Close, the last Open (at the top of stack) is popped out. Now we have found a pair, we just need to compute similarly for the rest of the brackets. Depending on the problem, stack could either store the Open itslef or its index. Here we need to remove the corresponding bracket from input string, so we store index. \\n* For Parentheses Propert 1: At the end of the stack computation if stack is empty, we have equal counts of Open and Close.\\n* Extra Open: At the end of computation, if Opens are remaining, these are the extra brackets that make the parentheses unbalanced. These could be removed to make the parentheses balanced.\\n* Exra Close: If at any time during the computation, Close is encountered but stack is empty, it means this Close is extra (no Open to pair with) and is making already encountered parentheses unbalanced. This could be removed to continue the computation for the rest of the brackets.\\n* A thought that could hinder the proof: Instead of pairing currently computing Close with last Open, what if I pair a later Close with this Open, so the currently computing Close could be removed from making the parentheses unbalanced? \\nEg: `( ) )`. Parentheses 0 = last Open, Parentheses 1 = currently computing Close, Parentheses 2 = later Close\\nAnswer: It won\\'t make any difference to the overall number of \")\" we need to remove from the parantheses. \\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally solved a stack string medium question without help !!"
                    },
                    {
                        "username": "Agg_Riitk",
                        "content": "You have to use StringBuilder Method to store the result instead of storing it in a normal string. The reason for this is given below form a StackOverFlow Post.\\n\\n\\nEvery time you do stringA += stringB; a new string is created an assigned to stringA, so it will consume memory (a new string instance!) and time (copy the old string + new characters of the other string).\\n\\nStringBuilder will use an array of characters internally and when you use the .append() method it will do several things:\\n\\n\\t-check if there are any free space for the string to append\\n\\t\\n\\t-again some internal checks and run a System.arraycopy to copy the characters of the string in the array.\\n\\t\\n\\t\\nSource :- https://stackoverflow.com/questions/22439177/why-is-stringbuilder-much-faster-than-string"
                    },
                    {
                        "username": "baburaoapte",
                        "content": "The approach using Stack - or any approach for that matter - how do you ensure that it\\'s the minimum number of brackets are being removed? How to prove that? I didn\\'t understand that part about the solution and it is very critical to the understanding of this problem. Please can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no need to use a stack here. Just traverse the string from left to right removing any unmatched closing parentheses (closing parenthesis count is greater than the opening parenthesis count) as you go then traverse the string from right to left removing any unmatched opening parentheses as you go."
                    }
                ]
            },
            {
                "id": 1574957,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using a Stack and String Builder\n\n  \n**Approach 2:** Two Pass String Builder\n\n  \n**Approach 3:** Shortened Two Pass String Builder\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calm27",
                        "content": "it seems to be \\'easy\\', not \\'medium\\' problem. \\nintuitive stack approach is pretty straight forward, however official approaches are kind confusing. "
                    },
                    {
                        "username": "Fedolodic",
                        "content": "Looking to see how the community would approach this follow-up. I can\\'t think of anything that beats the immutable string O(n) algorithm with 3 for-loops."
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Easy explanation | 4 min Hindi Video | Explained the crux of the problem \\nyoutube. com/watch?v=hLWkxDrdQPI"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Could you share math proof that stack approach gives optimal solution"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "***(...yet to go through LC solutions 2 and 3, but a wonderful LC solution 1)***\\n\\nThis is an interesting problem in a way that only if I know about the **Parentheses Properties**, **Stack Data Structure** and **relation between Parentheses and Stack**, I could come up with the solution (read LC solution 1) in an interview.\\n\\n**Parentheses Properties**: \\n* For parentheses to be balanced, count of Opens must be equal to count of Closes. eg: for ( ( ( ) ) ), count = 3 and 3\\n* Each Close must form a pair with previously encountered Open. eg: for ) ) ) ( ( (, though count = 3 and 3, each Close doesn\\'t have a previous Open to be paired with.\\n\\n**Stack Data Structure**\\n* First In First Out: Insertion and removeal happens at the same side. // recency based\\n\\n**Relation between Parentheses and Stack**\\n* For Parenetheses Property 2, Stack is the DS that facilitates this validation. On encountering Open, it is pushed into stack, and on encountering Close, the last Open (at the top of stack) is popped out. Now we have found a pair, we just need to compute similarly for the rest of the brackets. Depending on the problem, stack could either store the Open itslef or its index. Here we need to remove the corresponding bracket from input string, so we store index. \\n* For Parentheses Propert 1: At the end of the stack computation if stack is empty, we have equal counts of Open and Close.\\n* Extra Open: At the end of computation, if Opens are remaining, these are the extra brackets that make the parentheses unbalanced. These could be removed to make the parentheses balanced.\\n* Exra Close: If at any time during the computation, Close is encountered but stack is empty, it means this Close is extra (no Open to pair with) and is making already encountered parentheses unbalanced. This could be removed to continue the computation for the rest of the brackets.\\n* A thought that could hinder the proof: Instead of pairing currently computing Close with last Open, what if I pair a later Close with this Open, so the currently computing Close could be removed from making the parentheses unbalanced? \\nEg: `( ) )`. Parentheses 0 = last Open, Parentheses 1 = currently computing Close, Parentheses 2 = later Close\\nAnswer: It won\\'t make any difference to the overall number of \")\" we need to remove from the parantheses. \\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally solved a stack string medium question without help !!"
                    },
                    {
                        "username": "Agg_Riitk",
                        "content": "You have to use StringBuilder Method to store the result instead of storing it in a normal string. The reason for this is given below form a StackOverFlow Post.\\n\\n\\nEvery time you do stringA += stringB; a new string is created an assigned to stringA, so it will consume memory (a new string instance!) and time (copy the old string + new characters of the other string).\\n\\nStringBuilder will use an array of characters internally and when you use the .append() method it will do several things:\\n\\n\\t-check if there are any free space for the string to append\\n\\t\\n\\t-again some internal checks and run a System.arraycopy to copy the characters of the string in the array.\\n\\t\\n\\t\\nSource :- https://stackoverflow.com/questions/22439177/why-is-stringbuilder-much-faster-than-string"
                    },
                    {
                        "username": "baburaoapte",
                        "content": "The approach using Stack - or any approach for that matter - how do you ensure that it\\'s the minimum number of brackets are being removed? How to prove that? I didn\\'t understand that part about the solution and it is very critical to the understanding of this problem. Please can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no need to use a stack here. Just traverse the string from left to right removing any unmatched closing parentheses (closing parenthesis count is greater than the opening parenthesis count) as you go then traverse the string from right to left removing any unmatched opening parentheses as you go."
                    }
                ]
            },
            {
                "id": 1917201,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using a Stack and String Builder\n\n  \n**Approach 2:** Two Pass String Builder\n\n  \n**Approach 3:** Shortened Two Pass String Builder\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calm27",
                        "content": "it seems to be \\'easy\\', not \\'medium\\' problem. \\nintuitive stack approach is pretty straight forward, however official approaches are kind confusing. "
                    },
                    {
                        "username": "Fedolodic",
                        "content": "Looking to see how the community would approach this follow-up. I can\\'t think of anything that beats the immutable string O(n) algorithm with 3 for-loops."
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Easy explanation | 4 min Hindi Video | Explained the crux of the problem \\nyoutube. com/watch?v=hLWkxDrdQPI"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Could you share math proof that stack approach gives optimal solution"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "***(...yet to go through LC solutions 2 and 3, but a wonderful LC solution 1)***\\n\\nThis is an interesting problem in a way that only if I know about the **Parentheses Properties**, **Stack Data Structure** and **relation between Parentheses and Stack**, I could come up with the solution (read LC solution 1) in an interview.\\n\\n**Parentheses Properties**: \\n* For parentheses to be balanced, count of Opens must be equal to count of Closes. eg: for ( ( ( ) ) ), count = 3 and 3\\n* Each Close must form a pair with previously encountered Open. eg: for ) ) ) ( ( (, though count = 3 and 3, each Close doesn\\'t have a previous Open to be paired with.\\n\\n**Stack Data Structure**\\n* First In First Out: Insertion and removeal happens at the same side. // recency based\\n\\n**Relation between Parentheses and Stack**\\n* For Parenetheses Property 2, Stack is the DS that facilitates this validation. On encountering Open, it is pushed into stack, and on encountering Close, the last Open (at the top of stack) is popped out. Now we have found a pair, we just need to compute similarly for the rest of the brackets. Depending on the problem, stack could either store the Open itslef or its index. Here we need to remove the corresponding bracket from input string, so we store index. \\n* For Parentheses Propert 1: At the end of the stack computation if stack is empty, we have equal counts of Open and Close.\\n* Extra Open: At the end of computation, if Opens are remaining, these are the extra brackets that make the parentheses unbalanced. These could be removed to make the parentheses balanced.\\n* Exra Close: If at any time during the computation, Close is encountered but stack is empty, it means this Close is extra (no Open to pair with) and is making already encountered parentheses unbalanced. This could be removed to continue the computation for the rest of the brackets.\\n* A thought that could hinder the proof: Instead of pairing currently computing Close with last Open, what if I pair a later Close with this Open, so the currently computing Close could be removed from making the parentheses unbalanced? \\nEg: `( ) )`. Parentheses 0 = last Open, Parentheses 1 = currently computing Close, Parentheses 2 = later Close\\nAnswer: It won\\'t make any difference to the overall number of \")\" we need to remove from the parantheses. \\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally solved a stack string medium question without help !!"
                    },
                    {
                        "username": "Agg_Riitk",
                        "content": "You have to use StringBuilder Method to store the result instead of storing it in a normal string. The reason for this is given below form a StackOverFlow Post.\\n\\n\\nEvery time you do stringA += stringB; a new string is created an assigned to stringA, so it will consume memory (a new string instance!) and time (copy the old string + new characters of the other string).\\n\\nStringBuilder will use an array of characters internally and when you use the .append() method it will do several things:\\n\\n\\t-check if there are any free space for the string to append\\n\\t\\n\\t-again some internal checks and run a System.arraycopy to copy the characters of the string in the array.\\n\\t\\n\\t\\nSource :- https://stackoverflow.com/questions/22439177/why-is-stringbuilder-much-faster-than-string"
                    },
                    {
                        "username": "baburaoapte",
                        "content": "The approach using Stack - or any approach for that matter - how do you ensure that it\\'s the minimum number of brackets are being removed? How to prove that? I didn\\'t understand that part about the solution and it is very critical to the understanding of this problem. Please can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no need to use a stack here. Just traverse the string from left to right removing any unmatched closing parentheses (closing parenthesis count is greater than the opening parenthesis count) as you go then traverse the string from right to left removing any unmatched opening parentheses as you go."
                    }
                ]
            },
            {
                "id": 1576508,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using a Stack and String Builder\n\n  \n**Approach 2:** Two Pass String Builder\n\n  \n**Approach 3:** Shortened Two Pass String Builder\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calm27",
                        "content": "it seems to be \\'easy\\', not \\'medium\\' problem. \\nintuitive stack approach is pretty straight forward, however official approaches are kind confusing. "
                    },
                    {
                        "username": "Fedolodic",
                        "content": "Looking to see how the community would approach this follow-up. I can\\'t think of anything that beats the immutable string O(n) algorithm with 3 for-loops."
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Easy explanation | 4 min Hindi Video | Explained the crux of the problem \\nyoutube. com/watch?v=hLWkxDrdQPI"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Could you share math proof that stack approach gives optimal solution"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "***(...yet to go through LC solutions 2 and 3, but a wonderful LC solution 1)***\\n\\nThis is an interesting problem in a way that only if I know about the **Parentheses Properties**, **Stack Data Structure** and **relation between Parentheses and Stack**, I could come up with the solution (read LC solution 1) in an interview.\\n\\n**Parentheses Properties**: \\n* For parentheses to be balanced, count of Opens must be equal to count of Closes. eg: for ( ( ( ) ) ), count = 3 and 3\\n* Each Close must form a pair with previously encountered Open. eg: for ) ) ) ( ( (, though count = 3 and 3, each Close doesn\\'t have a previous Open to be paired with.\\n\\n**Stack Data Structure**\\n* First In First Out: Insertion and removeal happens at the same side. // recency based\\n\\n**Relation between Parentheses and Stack**\\n* For Parenetheses Property 2, Stack is the DS that facilitates this validation. On encountering Open, it is pushed into stack, and on encountering Close, the last Open (at the top of stack) is popped out. Now we have found a pair, we just need to compute similarly for the rest of the brackets. Depending on the problem, stack could either store the Open itslef or its index. Here we need to remove the corresponding bracket from input string, so we store index. \\n* For Parentheses Propert 1: At the end of the stack computation if stack is empty, we have equal counts of Open and Close.\\n* Extra Open: At the end of computation, if Opens are remaining, these are the extra brackets that make the parentheses unbalanced. These could be removed to make the parentheses balanced.\\n* Exra Close: If at any time during the computation, Close is encountered but stack is empty, it means this Close is extra (no Open to pair with) and is making already encountered parentheses unbalanced. This could be removed to continue the computation for the rest of the brackets.\\n* A thought that could hinder the proof: Instead of pairing currently computing Close with last Open, what if I pair a later Close with this Open, so the currently computing Close could be removed from making the parentheses unbalanced? \\nEg: `( ) )`. Parentheses 0 = last Open, Parentheses 1 = currently computing Close, Parentheses 2 = later Close\\nAnswer: It won\\'t make any difference to the overall number of \")\" we need to remove from the parantheses. \\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally solved a stack string medium question without help !!"
                    },
                    {
                        "username": "Agg_Riitk",
                        "content": "You have to use StringBuilder Method to store the result instead of storing it in a normal string. The reason for this is given below form a StackOverFlow Post.\\n\\n\\nEvery time you do stringA += stringB; a new string is created an assigned to stringA, so it will consume memory (a new string instance!) and time (copy the old string + new characters of the other string).\\n\\nStringBuilder will use an array of characters internally and when you use the .append() method it will do several things:\\n\\n\\t-check if there are any free space for the string to append\\n\\t\\n\\t-again some internal checks and run a System.arraycopy to copy the characters of the string in the array.\\n\\t\\n\\t\\nSource :- https://stackoverflow.com/questions/22439177/why-is-stringbuilder-much-faster-than-string"
                    },
                    {
                        "username": "baburaoapte",
                        "content": "The approach using Stack - or any approach for that matter - how do you ensure that it\\'s the minimum number of brackets are being removed? How to prove that? I didn\\'t understand that part about the solution and it is very critical to the understanding of this problem. Please can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no need to use a stack here. Just traverse the string from left to right removing any unmatched closing parentheses (closing parenthesis count is greater than the opening parenthesis count) as you go then traverse the string from right to left removing any unmatched opening parentheses as you go."
                    }
                ]
            },
            {
                "id": 1575579,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using a Stack and String Builder\n\n  \n**Approach 2:** Two Pass String Builder\n\n  \n**Approach 3:** Shortened Two Pass String Builder\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calm27",
                        "content": "it seems to be \\'easy\\', not \\'medium\\' problem. \\nintuitive stack approach is pretty straight forward, however official approaches are kind confusing. "
                    },
                    {
                        "username": "Fedolodic",
                        "content": "Looking to see how the community would approach this follow-up. I can\\'t think of anything that beats the immutable string O(n) algorithm with 3 for-loops."
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Easy explanation | 4 min Hindi Video | Explained the crux of the problem \\nyoutube. com/watch?v=hLWkxDrdQPI"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Could you share math proof that stack approach gives optimal solution"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "***(...yet to go through LC solutions 2 and 3, but a wonderful LC solution 1)***\\n\\nThis is an interesting problem in a way that only if I know about the **Parentheses Properties**, **Stack Data Structure** and **relation between Parentheses and Stack**, I could come up with the solution (read LC solution 1) in an interview.\\n\\n**Parentheses Properties**: \\n* For parentheses to be balanced, count of Opens must be equal to count of Closes. eg: for ( ( ( ) ) ), count = 3 and 3\\n* Each Close must form a pair with previously encountered Open. eg: for ) ) ) ( ( (, though count = 3 and 3, each Close doesn\\'t have a previous Open to be paired with.\\n\\n**Stack Data Structure**\\n* First In First Out: Insertion and removeal happens at the same side. // recency based\\n\\n**Relation between Parentheses and Stack**\\n* For Parenetheses Property 2, Stack is the DS that facilitates this validation. On encountering Open, it is pushed into stack, and on encountering Close, the last Open (at the top of stack) is popped out. Now we have found a pair, we just need to compute similarly for the rest of the brackets. Depending on the problem, stack could either store the Open itslef or its index. Here we need to remove the corresponding bracket from input string, so we store index. \\n* For Parentheses Propert 1: At the end of the stack computation if stack is empty, we have equal counts of Open and Close.\\n* Extra Open: At the end of computation, if Opens are remaining, these are the extra brackets that make the parentheses unbalanced. These could be removed to make the parentheses balanced.\\n* Exra Close: If at any time during the computation, Close is encountered but stack is empty, it means this Close is extra (no Open to pair with) and is making already encountered parentheses unbalanced. This could be removed to continue the computation for the rest of the brackets.\\n* A thought that could hinder the proof: Instead of pairing currently computing Close with last Open, what if I pair a later Close with this Open, so the currently computing Close could be removed from making the parentheses unbalanced? \\nEg: `( ) )`. Parentheses 0 = last Open, Parentheses 1 = currently computing Close, Parentheses 2 = later Close\\nAnswer: It won\\'t make any difference to the overall number of \")\" we need to remove from the parantheses. \\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally solved a stack string medium question without help !!"
                    },
                    {
                        "username": "Agg_Riitk",
                        "content": "You have to use StringBuilder Method to store the result instead of storing it in a normal string. The reason for this is given below form a StackOverFlow Post.\\n\\n\\nEvery time you do stringA += stringB; a new string is created an assigned to stringA, so it will consume memory (a new string instance!) and time (copy the old string + new characters of the other string).\\n\\nStringBuilder will use an array of characters internally and when you use the .append() method it will do several things:\\n\\n\\t-check if there are any free space for the string to append\\n\\t\\n\\t-again some internal checks and run a System.arraycopy to copy the characters of the string in the array.\\n\\t\\n\\t\\nSource :- https://stackoverflow.com/questions/22439177/why-is-stringbuilder-much-faster-than-string"
                    },
                    {
                        "username": "baburaoapte",
                        "content": "The approach using Stack - or any approach for that matter - how do you ensure that it\\'s the minimum number of brackets are being removed? How to prove that? I didn\\'t understand that part about the solution and it is very critical to the understanding of this problem. Please can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no need to use a stack here. Just traverse the string from left to right removing any unmatched closing parentheses (closing parenthesis count is greater than the opening parenthesis count) as you go then traverse the string from right to left removing any unmatched opening parentheses as you go."
                    }
                ]
            },
            {
                "id": 1864076,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using a Stack and String Builder\n\n  \n**Approach 2:** Two Pass String Builder\n\n  \n**Approach 3:** Shortened Two Pass String Builder\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calm27",
                        "content": "it seems to be \\'easy\\', not \\'medium\\' problem. \\nintuitive stack approach is pretty straight forward, however official approaches are kind confusing. "
                    },
                    {
                        "username": "Fedolodic",
                        "content": "Looking to see how the community would approach this follow-up. I can\\'t think of anything that beats the immutable string O(n) algorithm with 3 for-loops."
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Easy explanation | 4 min Hindi Video | Explained the crux of the problem \\nyoutube. com/watch?v=hLWkxDrdQPI"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Could you share math proof that stack approach gives optimal solution"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "***(...yet to go through LC solutions 2 and 3, but a wonderful LC solution 1)***\\n\\nThis is an interesting problem in a way that only if I know about the **Parentheses Properties**, **Stack Data Structure** and **relation between Parentheses and Stack**, I could come up with the solution (read LC solution 1) in an interview.\\n\\n**Parentheses Properties**: \\n* For parentheses to be balanced, count of Opens must be equal to count of Closes. eg: for ( ( ( ) ) ), count = 3 and 3\\n* Each Close must form a pair with previously encountered Open. eg: for ) ) ) ( ( (, though count = 3 and 3, each Close doesn\\'t have a previous Open to be paired with.\\n\\n**Stack Data Structure**\\n* First In First Out: Insertion and removeal happens at the same side. // recency based\\n\\n**Relation between Parentheses and Stack**\\n* For Parenetheses Property 2, Stack is the DS that facilitates this validation. On encountering Open, it is pushed into stack, and on encountering Close, the last Open (at the top of stack) is popped out. Now we have found a pair, we just need to compute similarly for the rest of the brackets. Depending on the problem, stack could either store the Open itslef or its index. Here we need to remove the corresponding bracket from input string, so we store index. \\n* For Parentheses Propert 1: At the end of the stack computation if stack is empty, we have equal counts of Open and Close.\\n* Extra Open: At the end of computation, if Opens are remaining, these are the extra brackets that make the parentheses unbalanced. These could be removed to make the parentheses balanced.\\n* Exra Close: If at any time during the computation, Close is encountered but stack is empty, it means this Close is extra (no Open to pair with) and is making already encountered parentheses unbalanced. This could be removed to continue the computation for the rest of the brackets.\\n* A thought that could hinder the proof: Instead of pairing currently computing Close with last Open, what if I pair a later Close with this Open, so the currently computing Close could be removed from making the parentheses unbalanced? \\nEg: `( ) )`. Parentheses 0 = last Open, Parentheses 1 = currently computing Close, Parentheses 2 = later Close\\nAnswer: It won\\'t make any difference to the overall number of \")\" we need to remove from the parantheses. \\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally solved a stack string medium question without help !!"
                    },
                    {
                        "username": "Agg_Riitk",
                        "content": "You have to use StringBuilder Method to store the result instead of storing it in a normal string. The reason for this is given below form a StackOverFlow Post.\\n\\n\\nEvery time you do stringA += stringB; a new string is created an assigned to stringA, so it will consume memory (a new string instance!) and time (copy the old string + new characters of the other string).\\n\\nStringBuilder will use an array of characters internally and when you use the .append() method it will do several things:\\n\\n\\t-check if there are any free space for the string to append\\n\\t\\n\\t-again some internal checks and run a System.arraycopy to copy the characters of the string in the array.\\n\\t\\n\\t\\nSource :- https://stackoverflow.com/questions/22439177/why-is-stringbuilder-much-faster-than-string"
                    },
                    {
                        "username": "baburaoapte",
                        "content": "The approach using Stack - or any approach for that matter - how do you ensure that it\\'s the minimum number of brackets are being removed? How to prove that? I didn\\'t understand that part about the solution and it is very critical to the understanding of this problem. Please can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no need to use a stack here. Just traverse the string from left to right removing any unmatched closing parentheses (closing parenthesis count is greater than the opening parenthesis count) as you go then traverse the string from right to left removing any unmatched opening parentheses as you go."
                    }
                ]
            }
        ]
    },
    {
        "title": "Stone Game VI",
        "question_content": "<p>Alice and Bob take turns playing a game, with Alice starting first.</p>\n\n<p>There are <code>n</code> stones in a pile. On each player&#39;s turn, they can <strong>remove</strong> a stone from the pile and receive points based on the stone&#39;s value. Alice and Bob may <strong>value the stones differently</strong>.</p>\n\n<p>You are given two integer arrays of length <code>n</code>, <code>aliceValues</code> and <code>bobValues</code>. Each <code>aliceValues[i]</code> and <code>bobValues[i]</code> represents how Alice and Bob, respectively, value the <code>i<sup>th</sup></code> stone.</p>\n\n<p>The winner is the person with the most points after all the stones are chosen. If both players have the same amount of points, the game results in a draw. Both players will play <strong>optimally</strong>.&nbsp;Both players know the other&#39;s values.</p>\n\n<p>Determine the result of the game, and:</p>\n\n<ul>\n\t<li>If Alice wins, return <code>1</code>.</li>\n\t<li>If Bob wins, return <code>-1</code>.</li>\n\t<li>If the game results in a draw, return <code>0</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> aliceValues = [1,3], bobValues = [2,1]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong>\nIf Alice takes stone 1 (0-indexed) first, Alice will receive 3 points.\nBob can only choose stone 0, and will only receive 2 points.\nAlice wins.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> aliceValues = [1,2], bobValues = [3,1]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong>\nIf Alice takes stone 0, and Bob takes stone 1, they will both have 1 point.\nDraw.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> aliceValues = [2,4,3], bobValues = [1,6,7]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong>\nRegardless of how Alice plays, Bob will be able to have more points than Alice.\nFor example, if Alice takes stone 1, Bob can take stone 2, and Alice takes stone 0, Alice will have 6 points to Bob&#39;s 7.\nBob wins.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == aliceValues.length == bobValues.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= aliceValues[i], bobValues[i] &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 969574,
                "title": "java-c-python-sort-by-value-sum",
                "content": "# **Intuition**\\nSort stones by their sum value for Alice and Bob.\\nIf a stone is super valued for Alice, Alice wants to take it.\\nIf a stone is super valued for Bob, Alice also wants to take it.\\nBecause she doesn\\'t want Bob to take it.\\n<br>\\n\\n# **Explanation**\\nHere is more convinced explanation.\\nAssume a stone valued `[a,b]` for Alice and Bod.\\nAlice takes it, worth `a` for Alice,\\nBob takes it, worth `b` for Bob,\\nwe can also consider that it worth `-b` for Alice.\\nThe difference will be `a+b`.\\nThat\\'s the reason why we need to sort based on `a+b`.\\nAnd Alice and Bob will take one most valued stone each turn.\\n<br>\\n\\n# **Complexity**\\nTime `O(nlogn)`\\nSpace `O(n)`\\n<br>\\n\\n# **Solution 1**\\n**Java**\\nSuggested by @blackspinner, @leonfan\\n```java\\n    public int stoneGameVI(int[] A, int[] B) {\\n        int n = A.length;\\n        int[][] sums = new int[n][];\\n        for (int i = 0; i < n; i++) {\\n            sums[i] = new int[] {A[i] + B[i], A[i], B[i]};\\n        }\\n        Arrays.sort(sums, (a, b) -> Integer.compare(b[0], a[0]));\\n        int a = 0;\\n        int b = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (i % 2 == 0) {\\n                a += sums[i][1];\\n            } else {\\n                b += sums[i][2];\\n            }\\n        }\\n        return Integer.compare(a, b);\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int stoneGameVI(vector<int>& A, vector<int>& B) {\\n        vector<vector<int>> C;\\n        int res[2] = {0, 0}, n = A.size();\\n        for (int i = 0; i < n; ++i)\\n            C.push_back({ -A[i] - B[i], A[i], B[i]});\\n        sort(begin(C), end(C));\\n        for (int i = 0; i < n; ++i)\\n            res[i % 2] += C[i][1 + i % 2];\\n        return res[0] == res[1] ? 0 : res[0] > res[1] ? 1 : -1;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def stoneGameVI(self, A, B):\\n        A = sorted(zip(A, B), key=sum)\\n        return cmp(sum(a for a, b in A[::-2]), sum(b for a, b in A[-2::-2]))\\n```\\n<br>\\n\\n# **Solution 2**\\nAssume the Bob takes all stones and the difference is `sum(B)` now.\\nEach stone Alex picks can make the `difference += A[i] + B[i]`.\\nSo we need to sort on `A[i] + B[i]`.\\n\\n**Java**\\n```java\\n    public int stoneGameVI(int[] A, int[] B) {\\n        int n = A.length, diff = 0;\\n        for (int i = 0; i < n; i++) {\\n            A[i] += B[i];\\n            diff -= B[i];\\n        }\\n        Arrays.sort(A);\\n        for (int i =  n - 1; i >= 0; i -= 2)\\n            diff += A[i];\\n        return Integer.compare(diff, 0);\\n    }\\n```\\n**C++**\\n```cpp\\n    int stoneGameVI(vector<int> A, vector<int>& B) {\\n        int n = A.size(), diff = 0;\\n        for (int i = 0; i < n; i++) {\\n            A[i] += B[i];\\n            diff -= B[i];\\n        }\\n        sort(begin(A), end(A));\\n        for (int i = n - 1; i >= 0; i -= 2)\\n            diff += A[i];\\n        return diff == 0 ? 0 : diff > 0 ? 1 : -1;\\n    }\\n```\\n**Python**\\n```py\\n    def stoneGameVI(self, A, B):\\n        return cmp(-sum(B) + sum(sorted(a + b for a,b in zip(A,B))[::-2]), 0)\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int stoneGameVI(int[] A, int[] B) {\\n        int n = A.length;\\n        int[][] sums = new int[n][];\\n        for (int i = 0; i < n; i++) {\\n            sums[i] = new int[] {A[i] + B[i], A[i], B[i]};\\n        }\\n        Arrays.sort(sums, (a, b) -> Integer.compare(b[0], a[0]));\\n        int a = 0;\\n        int b = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (i % 2 == 0) {\\n                a += sums[i][1];\\n            } else {\\n                b += sums[i][2];\\n            }\\n        }\\n        return Integer.compare(a, b);\\n    }\\n```\n```cpp\\n    int stoneGameVI(vector<int>& A, vector<int>& B) {\\n        vector<vector<int>> C;\\n        int res[2] = {0, 0}, n = A.size();\\n        for (int i = 0; i < n; ++i)\\n            C.push_back({ -A[i] - B[i], A[i], B[i]});\\n        sort(begin(C), end(C));\\n        for (int i = 0; i < n; ++i)\\n            res[i % 2] += C[i][1 + i % 2];\\n        return res[0] == res[1] ? 0 : res[0] > res[1] ? 1 : -1;\\n    }\\n```\n```py\\n    def stoneGameVI(self, A, B):\\n        A = sorted(zip(A, B), key=sum)\\n        return cmp(sum(a for a, b in A[::-2]), sum(b for a, b in A[-2::-2]))\\n```\n```java\\n    public int stoneGameVI(int[] A, int[] B) {\\n        int n = A.length, diff = 0;\\n        for (int i = 0; i < n; i++) {\\n            A[i] += B[i];\\n            diff -= B[i];\\n        }\\n        Arrays.sort(A);\\n        for (int i =  n - 1; i >= 0; i -= 2)\\n            diff += A[i];\\n        return Integer.compare(diff, 0);\\n    }\\n```\n```cpp\\n    int stoneGameVI(vector<int> A, vector<int>& B) {\\n        int n = A.size(), diff = 0;\\n        for (int i = 0; i < n; i++) {\\n            A[i] += B[i];\\n            diff -= B[i];\\n        }\\n        sort(begin(A), end(A));\\n        for (int i = n - 1; i >= 0; i -= 2)\\n            diff += A[i];\\n        return diff == 0 ? 0 : diff > 0 ? 1 : -1;\\n    }\\n```\n```py\\n    def stoneGameVI(self, A, B):\\n        return cmp(-sum(B) + sum(sorted(a + b for a,b in zip(A,B))[::-2]), 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 969817,
                "title": "strategy-proof",
                "content": "# For two stones\\n\\nAssume there are only two stones.\\nFirst stone values `a1, b1 ` for Alice and Bob respectively.\\nSecond stone values `a2, b2 ` for Alice and Bob respectively.\\nLet `S1 = a1 + b1` and `S2 =  a2 + b2`\\n\\n| Stone # | Alice\\'s score | Bob\\'s score  |\\n| --------:|------------:| -----:|\\n| 1 | a1 = S1 - b1 | b1 |\\n| 2 | a2  = S2 - b2 | b2  |\\n\\nLet `F` be the points difference between the two players: the sum of Alice\\'s points minus the sum of Bob\\'s points\\n\\nIf Alice picks stone #1:\\n```\\nF = a1 - b2 = (S1 - b1) - b2 = S1 - (b1 + b2)\\n```\\nIf Alice picks stone #2:  \\n```\\nF = a2 - b1 = (S2 - b2) - b1 = S2 - (b1 + b2)\\n```\\n`b1 + b2` is fixed for given stone values. So Alice should pick a stone with maximum sum of values to maximize `F` and make it positive. \\n\\n# General case\\n\\nFor `N` stones: \\n\\n```\\nF = \\u2211Si - (b1 + b2 + ... + bN) , where i in the numbers of stones that are picked by Alice. \\n```\\n\\nSo the strategy for Alice whould be to pick each time a stone with maximum sum of values for Alice and Bob.\\n\\nSame strategy works for Bob who needs to minimize F and make it negative:\\n\\n```\\nF = (a1 + a2 + ... + aN) - \\u2211Sj , where j in the numbers of stones that are picked by Bob. \\n```\\n\\n\\n### Ruby code V1\\n\\n\\n```ruby\\ndef stone_game_vi(alice_values, bob_values)\\n  arr = alice_values.zip(bob_values).sort_by(&:sum).reverse\\n  s = [0, 0]\\n  for ab, i in arr.each_with_index\\n    s[i % 2] += ab[i % 2]\\n  end\\n  s[0] <=> s[1] # returns 0, -1, or 1\\nend\\n# Runtime: 368 ms\\n# Time compexity: O(N * log(N))\\n# Space compexity: O(N)\\n```\\n\\n### Ruby code V2\\n\\nAccording to the formula:\\n\\n```ruby\\ndef stone_game_vi(alice_values, bob_values)\\n  f = alice_values.sum\\n  alice_values.zip(bob_values).map(&:sum).sort.reverse.each_with_index do |s, i|\\n    f -= s if i.odd?\\n  end\\n  f <=> 0\\nend\\n# Runtime: 252 ms\\n# Time compexity: O(N * log(N))\\n# Space compexity: O(N)\\n```",
                "solutionTags": [],
                "code": "```\\nF = a1 - b2 = (S1 - b1) - b2 = S1 - (b1 + b2)\\n```\n```\\nF = a2 - b1 = (S2 - b2) - b1 = S2 - (b1 + b2)\\n```\n```\\nF = \\u2211Si - (b1 + b2 + ... + bN) , where i in the numbers of stones that are picked by Alice. \\n```\n```\\nF = (a1 + a2 + ... + aN) - \\u2211Sj , where j in the numbers of stones that are picked by Bob. \\n```\n```ruby\\ndef stone_game_vi(alice_values, bob_values)\\n  arr = alice_values.zip(bob_values).sort_by(&:sum).reverse\\n  s = [0, 0]\\n  for ab, i in arr.each_with_index\\n    s[i % 2] += ab[i % 2]\\n  end\\n  s[0] <=> s[1] # returns 0, -1, or 1\\nend\\n# Runtime: 368 ms\\n# Time compexity: O(N * log(N))\\n# Space compexity: O(N)\\n```\n```ruby\\ndef stone_game_vi(alice_values, bob_values)\\n  f = alice_values.sum\\n  alice_values.zip(bob_values).map(&:sum).sort.reverse.each_with_index do |s, i|\\n    f -= s if i.odd?\\n  end\\n  f <=> 0\\nend\\n# Runtime: 252 ms\\n# Time compexity: O(N * log(N))\\n# Space compexity: O(N)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 969507,
                "title": "c-o-n-log-n-optimal-strategy",
                "content": "The optimal strategy is to pick a stone with the maximum **combined** value.\\n\\nI thought about it this way: stone values do not matter, it is the **balance** that determines the outcome of the game.\\n\\nInitially, our balance is the sum of values for Alice minus sum of values for Bob. Picking a stone with the maximum combined value changes the balance in the most favorable way. This can be proven by a contradiction. \\n\\nFor example, if there we have stones [1, 100] and [50, 50], the first player should pick [1, 100], resulting in `-49` balance (picking the second stone would result in `-50` ballance).\\n\\n```cpp\\nint stoneGameVI(vector<int>& aV, vector<int>& bV) {\\n    vector<array<int, 3>> n;\\n    int a = 0, b = 0, sz = aV.size();\\n    for (int i = 0; i < sz; ++i)\\n        n.push_back({aV[i] + bV[i], aV[i], bV[i]});\\n    sort(begin(n), end(n));\\n    for (int i = 0; i < sz; ++i) {\\n        a += i % 2 ? 0 : n[sz - i - 1][1];\\n        b += i % 2 ? n[sz - i - 1][2] : 0;\\n    }\\n    return a == b ? 0 : a > b ? 1 : -1;\\n}\\n```\\nAnother version using the index array.\\n```cpp\\nint stoneGameVI(vector<int>& aV, vector<int>& bV) {\\n    int a = 0, b = 0, sz = aV.size();\\n    vector<int> idx(sz);\\n    iota(begin(idx), end(idx), 0);\\n    sort(begin(idx), end(idx), [&](int i, int j) {\\n        return aV[i] + bV[i] > aV[j] + bV[j];\\n    });\\n    for (int i = 0; i < sz; ++i) {\\n        a += i % 2 ? 0 : aV[idx[i]];\\n        b += i % 2 ? bV[idx[i]] : 0;\\n    }\\n    return a == b ? 0 : a > b ? 1 : -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint stoneGameVI(vector<int>& aV, vector<int>& bV) {\\n    vector<array<int, 3>> n;\\n    int a = 0, b = 0, sz = aV.size();\\n    for (int i = 0; i < sz; ++i)\\n        n.push_back({aV[i] + bV[i], aV[i], bV[i]});\\n    sort(begin(n), end(n));\\n    for (int i = 0; i < sz; ++i) {\\n        a += i % 2 ? 0 : n[sz - i - 1][1];\\n        b += i % 2 ? n[sz - i - 1][2] : 0;\\n    }\\n    return a == b ? 0 : a > b ? 1 : -1;\\n}\\n```\n```cpp\\nint stoneGameVI(vector<int>& aV, vector<int>& bV) {\\n    int a = 0, b = 0, sz = aV.size();\\n    vector<int> idx(sz);\\n    iota(begin(idx), end(idx), 0);\\n    sort(begin(idx), end(idx), [&](int i, int j) {\\n        return aV[i] + bV[i] > aV[j] + bV[j];\\n    });\\n    for (int i = 0; i < sz; ++i) {\\n        a += i % 2 ? 0 : aV[idx[i]];\\n        b += i % 2 ? bV[idx[i]] : 0;\\n    }\\n    return a == b ? 0 : a > b ? 1 : -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 969648,
                "title": "c-o-n",
                "content": "Somehow I got TLE using priority_queue, so reduced to O(N) with counting sort!\\n\\nBasically, for picking `i`, Alice will get `net value` of gaining `a[i]` point and having Bob lose `b[i]` point. Similarly for Bob. \\nSo the player wants to maximize the `net value` at each turn.\\n\\nTime: O(n)\\nSpace: O(n)\\n```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& a, vector<int>& b) {\\n        int m = a.size();\\n        vector<vector<int>> indices(201);\\n        for (int i = 0; i < m; ++i) {\\n            indices[a[i] + b[i]].push_back(i);\\n        }\\n        \\n        bool turn = true;\\n        int ta = 0, tb = 0;\\n        for (int i = 200; i >= 0; --i) {\\n            for (auto index: indices[i]) {\\n                if (turn) {\\n\\t\\t\\t\\t\\tta += a[index];\\n                } else {\\n                    tb += b[index];\\n                }\\n\\n                turn = !turn;    \\n            }\\n        }\\n        \\n        if (ta > tb) return 1;\\n        else if (ta < tb) return -1;\\n        return 0;\\n    }\\n};\\n```\\n\\n\\n\\n\\\\\\n\\\\\\n\\\\\\n\\\\\\nThis is my O(nlogn) solution similar to many others, but I weirdly got TLE with tuple.\\nReplcing tuple with pair works...\\n\\nEdit: Potential answer here, not sure if it will help, but some reference here\\nhttps://stackoverflow.com/questions/46901697/is-returning-a-2-tuple-less-efficient-than-stdpair\\n```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& a, vector<int>& b) {\\n        int m = a.size();\\n        priority_queue<pair<int, int>> pq;\\n        for (int i = 0; i < m; ++i) {\\n            pq.emplace(a[i] + b[i], i);\\n        }\\n\\n        bool turn = true;\\n        int ta = 0, tb = 0;\\n        while (!pq.empty()) {\\n            auto [value, index] = pq.top();\\n            pq.pop();\\n            \\n            if (turn) {\\n                ta += a[index];\\n            } else {\\n                tb += b[index];\\n            }\\n\\n            turn = !turn;    \\n        }\\n        \\n        if (ta > tb) return 1;\\n        else if (ta < tb) return -1;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& a, vector<int>& b) {\\n        int m = a.size();\\n        vector<vector<int>> indices(201);\\n        for (int i = 0; i < m; ++i) {\\n            indices[a[i] + b[i]].push_back(i);\\n        }\\n        \\n        bool turn = true;\\n        int ta = 0, tb = 0;\\n        for (int i = 200; i >= 0; --i) {\\n            for (auto index: indices[i]) {\\n                if (turn) {\\n\\t\\t\\t\\t\\tta += a[index];\\n                } else {\\n                    tb += b[index];\\n                }\\n\\n                turn = !turn;    \\n            }\\n        }\\n        \\n        if (ta > tb) return 1;\\n        else if (ta < tb) return -1;\\n        return 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& a, vector<int>& b) {\\n        int m = a.size();\\n        priority_queue<pair<int, int>> pq;\\n        for (int i = 0; i < m; ++i) {\\n            pq.emplace(a[i] + b[i], i);\\n        }\\n\\n        bool turn = true;\\n        int ta = 0, tb = 0;\\n        while (!pq.empty()) {\\n            auto [value, index] = pq.top();\\n            pq.pop();\\n            \\n            if (turn) {\\n                ta += a[index];\\n            } else {\\n                tb += b[index];\\n            }\\n\\n            turn = !turn;    \\n        }\\n        \\n        if (ta > tb) return 1;\\n        else if (ta < tb) return -1;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 969581,
                "title": "python-easy-understanding",
                "content": "Simple logic, greedy approach, sort based on maximum sum of pairs.\\n* The best approach is not only to pick the stone with maximum value, but the one where you could hurt your opponent\\'s chances by picking an optimal value.\\n* So by picking a stone, you get x points and you affect bob\\'s chances by -y points, so the impact inflicted by picking a given stone is a-(-b) = a+b. \\n* So sorting based on sum, you get the maximum impact you could inflict.\\n\\nFor example, \\nalice=[2,3] and bob=[5,3]\\nNormally it would be nice for alice to pick 3 to increase her chances, but when she picks 2, she could hurt bob\\'s chances by not allowing him to pick 5, so instead of selecting the maximum one, find the one where you could hurt your opponents chances(Greedy).\\n```\\nclass Solution:\\n    def stoneGameVI(self, alice: List[int], bob: List[int]) -> int:\\n        t=list(zip(alice,bob))\\n        t=sorted(t,key=lambda x: sum(x),reverse=True)\\n        al=sum([i[0] for i in t[::2]])\\n        bb=sum([i[1] for i in t[1::2]])\\n        if al>bb:\\n            return 1\\n        elif al<bb:\\n            return -1\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameVI(self, alice: List[int], bob: List[int]) -> int:\\n        t=list(zip(alice,bob))\\n        t=sorted(t,key=lambda x: sum(x),reverse=True)\\n        al=sum([i[0] for i in t[::2]])\\n        bb=sum([i[1] for i in t[1::2]])\\n        if al>bb:\\n            return 1\\n        elif al<bb:\\n            return -1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 969509,
                "title": "java-20-lines-o-nlogn-explained-greedy",
                "content": "```\\nclass Solution {\\n  public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n    //Define Gain Factor as =  Value to us + Loss we can force on opponent. Start picking with the best Gain Factor.\\n    //Realise Gain Factor is same for both player and is symmetric so we can pick from a single priority q.\\n    PriorityQueue<int[]> lot = new PriorityQueue<>((a, b) -> (b[0] + b[1]) - (a[0] + a[1]));\\n    for (int i = 0; i < aliceValues.length; i++) {\\n      lot.add(new int[]{aliceValues[i], bobValues[i]});\\n    }\\n    boolean aliceTurn = true;\\n    int a = 0;\\n    int b = 0;\\n    while (!lot.isEmpty()) {\\n      int[] n = lot.poll();\\n      if (aliceTurn) {\\n        a += n[0];\\n      } else {\\n        b += n[1];\\n      }\\n      aliceTurn=!aliceTurn;\\n    }\\n    return Integer.compare(a, b);\\n  }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n    //Define Gain Factor as =  Value to us + Loss we can force on opponent. Start picking with the best Gain Factor.\\n    //Realise Gain Factor is same for both player and is symmetric so we can pick from a single priority q.\\n    PriorityQueue<int[]> lot = new PriorityQueue<>((a, b) -> (b[0] + b[1]) - (a[0] + a[1]));\\n    for (int i = 0; i < aliceValues.length; i++) {\\n      lot.add(new int[]{aliceValues[i], bobValues[i]});\\n    }\\n    boolean aliceTurn = true;\\n    int a = 0;\\n    int b = 0;\\n    while (!lot.isEmpty()) {\\n      int[] n = lot.poll();\\n      if (aliceTurn) {\\n        a += n[0];\\n      } else {\\n        b += n[1];\\n      }\\n      aliceTurn=!aliceTurn;\\n    }\\n    return Integer.compare(a, b);\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 969583,
                "title": "python3-greedy-heap",
                "content": "Optimal strategy for either player: pick the stone[i] with max (aliceValues[i]+bobValues[i]). Use a max heap\\nRationale  for greedy strategy : Each player would want to select the stone which maximizes its current value. At the same time want to deselect the max value stone of other player. \\n\\n```\\nimport heapq\\nfrom typing import List\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        heap=[(-i-j,i,j) for i,j in zip(aliceValues,bobValues)] #max heap\\n        AScore=0\\n        BScore=0\\n        heapq.heapify(heap)\\n        turn=\"A\"\\n        while (heap):\\n            _,ascore,bscore=heapq.heappop(heap)\\n            if turn==\"A\":\\n                AScore+=ascore\\n                turn=\"B\"\\n            else:\\n                BScore+=bscore\\n                turn=\"A\"\\n        if AScore==BScore : return 0\\n        return 1 if AScore > BScore else  -1\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nfrom typing import List\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        heap=[(-i-j,i,j) for i,j in zip(aliceValues,bobValues)] #max heap\\n        AScore=0\\n        BScore=0\\n        heapq.heapify(heap)\\n        turn=\"A\"\\n        while (heap):\\n            _,ascore,bscore=heapq.heappop(heap)\\n            if turn==\"A\":\\n                AScore+=ascore\\n                turn=\"B\"\\n            else:\\n                BScore+=bscore\\n                turn=\"A\"\\n        if AScore==BScore : return 0\\n        return 1 if AScore > BScore else  -1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 969552,
                "title": "c-priority-queue-easy-to-understand-with-explanation",
                "content": "We utilize the fact that the best value to take for each player is the value with the ` best_profit = (stones_for_me + stones_for_him)`.\\nThis way we maximize our profit, while minimizing other player profit.\\n\\nE.g.:\\nFor each index i you sum: valuesAlice[i] + valuesBob[i].\\nIf Alice plays, she receives valuesAlice[i] coins, and potentially takes valuesBob[i] coins from Bob.\\n\\nWe calculate these best_profits, so that when the game starts, we can always play the move with the best profit.\\nFor that we can use a priority queue which will have the values sorted by their best_profit. Next to the best_profit, we save the index where such values occur.\\n\\n```\\n[1, 2] -> AliceValues\\n[1, 3] -> BobValues\\n```\\nTo calculate the bestProfit, we go by index:\\n```html\\n[(1 for us + 1 taken from our opponent ), (2 for us + 3 taken from our oppnonent)] \\n```\\ncomputes to:\\n```\\n[2, 5] -> BestProfit\\n```\\n\\nWe can push these values in a priority_queue where the pair is (best_profit, index).\\n\\nThen, until the queue is empty, play the game switching turns for each player.\\n\\n\\n### Game start\\n\\n\\npriority_queue = {5: 1, 2: 0}\\n\\n\\n#### Round 1:\\nAlice_sum += AliceValues[1] => 2;           // Alice_sum += AliceValues[priority_queue.top().second]\\npriority_queue = {2: 0}\\n\\n#### Round 2:\\nBob_sum += BobValues[0] => 1;\\npriority_queue = {}\\n\\n```C++\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        int N = aliceValues.size();\\n        priority_queue<pair<int, int>> q;\\n        for(int i = 0; i < N; i++) {\\n            q.push({(aliceValues[i] + bobValues[i]), i});\\n        }\\n        int alice_sum = 0;\\n        int bob_sum = 0;\\n        int turn = 0;\\n        while(q.size()) {\\n            auto p = q.top();\\n            q.pop();\\n            if (turn == 0) {\\n                alice_sum += aliceValues[p.second];\\n            } else {\\n                bob_sum += bobValues[p.second];\\n            }\\n            turn = turn ^ 1;\\n        }\\n        if (alice_sum == bob_sum) {\\n            return 0;\\n        } else if (alice_sum > bob_sum) {\\n            return 1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nSpace complexity: O(N) for the auxiliarry priority_queue where N is the number of values in Alice and Bob arrays.\\n\\nTime complexity: O(NlogN); each insertion in the priority_queue takes logN, and we do this for every N",
                "solutionTags": [],
                "code": "```\\n[1, 2] -> AliceValues\\n[1, 3] -> BobValues\\n```\n```html\\n[(1 for us + 1 taken from our opponent ), (2 for us + 3 taken from our oppnonent)] \\n```\n```\\n[2, 5] -> BestProfit\\n```\n```C++\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        int N = aliceValues.size();\\n        priority_queue<pair<int, int>> q;\\n        for(int i = 0; i < N; i++) {\\n            q.push({(aliceValues[i] + bobValues[i]), i});\\n        }\\n        int alice_sum = 0;\\n        int bob_sum = 0;\\n        int turn = 0;\\n        while(q.size()) {\\n            auto p = q.top();\\n            q.pop();\\n            if (turn == 0) {\\n                alice_sum += aliceValues[p.second];\\n            } else {\\n                bob_sum += bobValues[p.second];\\n            }\\n            turn = turn ^ 1;\\n        }\\n        if (alice_sum == bob_sum) {\\n            return 0;\\n        } else if (alice_sum > bob_sum) {\\n            return 1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874353,
                "title": "easy-to-understand",
                "content": "```\\nLike if you understand\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,int> p1,pair<int,int> p2)\\n    {\\n        if(p1.second==p2.second)\\n            return p1.first<p2.first;\\n        return p1.second>p2.second;\\n    }\\n    int stoneGameVI(vector<int>& a, vector<int>& b) {\\n       \\n        int n=a.size();\\n        int suma=0,sumb=0;\\n        \\n        vector<pair<int,int>> v;\\n        \\n        for(int i=0;i<n;++i)\\n        {\\n            v.push_back({i,a[i]+b[i]});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        \\n        for(int i=0;i<n;++i)\\n        {\\n            if(i%2==0)\\n                suma+=a[v[i].first];\\n            else\\n                sumb+=b[v[i].first];\\n        }\\n        \\n        if(suma>sumb)\\n            return 1;\\n        else if(suma==sumb)\\n            return 0;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nLike if you understand\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,int> p1,pair<int,int> p2)\\n    {\\n        if(p1.second==p2.second)\\n            return p1.first<p2.first;\\n        return p1.second>p2.second;\\n    }\\n    int stoneGameVI(vector<int>& a, vector<int>& b) {\\n       \\n        int n=a.size();\\n        int suma=0,sumb=0;\\n        \\n        vector<pair<int,int>> v;\\n        \\n        for(int i=0;i<n;++i)\\n        {\\n            v.push_back({i,a[i]+b[i]});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        \\n        for(int i=0;i<n;++i)\\n        {\\n            if(i%2==0)\\n                suma+=a[v[i].first];\\n            else\\n                sumb+=b[v[i].first];\\n        }\\n        \\n        if(suma>sumb)\\n            return 1;\\n        else if(suma==sumb)\\n            return 0;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1409540,
                "title": "c-using-priority-queue",
                "content": "```\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n       priority_queue<pair<int,pair<int,int>>>pq;\\n        for(int i=0;i<aliceValues.size();i++){\\n            pq.push({bobValues[i]+aliceValues[i],{aliceValues[i],bobValues[i]}});\\n        }\\n        bool alice=true;\\n        int as=0,bs=0;\\n        while(!pq.empty()){\\n            if(alice){\\n                as+=pq.top().second.first;\\n                pq.pop();\\n                alice=false;\\n            }\\n            else{\\n                bs+=pq.top().second.second;\\n                pq.pop();\\n                alice=true;\\n            }\\n        }\\n        if(as>bs)\\n            return 1;\\n        else if(as<bs)\\n            return -1;\\n        return 0;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n       priority_queue<pair<int,pair<int,int>>>pq;\\n        for(int i=0;i<aliceValues.size();i++){\\n            pq.push({bobValues[i]+aliceValues[i],{aliceValues[i],bobValues[i]}});\\n        }\\n        bool alice=true;\\n        int as=0,bs=0;\\n        while(!pq.empty()){\\n            if(alice){\\n                as+=pq.top().second.first;\\n                pq.pop();\\n                alice=false;\\n            }\\n            else{\\n                bs+=pq.top().second.second;\\n                pq.pop();\\n                alice=true;\\n            }\\n        }\\n        if(as>bs)\\n            return 1;\\n        else if(as<bs)\\n            return -1;\\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1687101,
                "title": "easy-understanding-with-clear-solution-java",
                "content": "**INTUTION**\\nSort in descending order the value according to the total value at the i position of the aliceValue and bobvalue\\n\\n**EXPLANATION**\\nPls dont take seriously and dont  downvote due to this\\n\\nIf u like a girl and ur friend also like the same girl u r greedy to get her and ur friend is also greedy to get her  nobody wants to lose her now if ur impressive power is x and his impressive power is y suppose and you have first chance to impress her\\nif x>y then u will impress her and win her heart\\nif x<y then u will not able to impress her but u r greedy and its on your ego what u will do surely u will try to aquire his impressive power by putting his character down so that he looses \\nsame happens here\\n\\nAssume a stone valued [a,b] for Alice and Bod.\\nAlice takes it, worth a for Alice,\\nBob takes it, worth b for Bob,\\nwe can also consider that it worth -b for Alice.\\nThe difference will be a+b.\\nThat\\'s the reason why we need to sort based on a+b.\\nAnd Alice and Bob will take one most valued stone each turn.\\n\\ni think i am clear enough pls upvote if u like the solution\\n\\nhere is my solution in java\\n\\n\\n\\n```\\nclass Solution \\n{\\nstatic class Pair\\n{\\n        int sum=0;\\n        int alice=0;\\n        int bob=0;\\n    public Pair(int sum,int alice, int bob)\\n{\\n    this.sum=sum;\\n\\tthis.alice = alice;\\n\\tthis.bob = bob;\\n}\\n}\\n\\n// class to define user defined conparator\\nstatic class Compare {\\n\\t\\n\\tstatic  void compare(Pair arr[], int n)\\n\\t{\\n\\t\\t// Comparator to sort the pair according to second element\\n\\t\\tArrays.sort(arr, new Comparator<Pair>() {\\n\\t\\t\\t@Override public int compare(Pair p1, Pair p2)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn p2.sum - p1.sum;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\t\\n\\t\\t\\n\\t}\\n}\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues)\\n    {\\n        int n=aliceValues.length;\\n        Pair[] a=new Pair[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=new Pair(aliceValues[i]+bobValues[i],aliceValues[i],bobValues[i]);\\n        }\\n        Compare.compare(a,n);\\n         int al=0;int bo=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%2==0)\\n            {\\n                al+=a[i].alice;\\n            }\\n            else\\n            {\\n                bo+=a[i].bob;\\n            }\\n        }\\n        return Integer.compare(al,bo);\\n    \\n    \\n    \\n    }\\n}\\n\\n```\\n\\n\\n**PLS UPVOTE IF U LIKE THE SOLUTION**\\n",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution \\n{\\nstatic class Pair\\n{\\n        int sum=0;\\n        int alice=0;\\n        int bob=0;\\n    public Pair(int sum,int alice, int bob)\\n{\\n    this.sum=sum;\\n\\tthis.alice = alice;\\n\\tthis.bob = bob;\\n}\\n}\\n\\n// class to define user defined conparator\\nstatic class Compare {\\n\\t\\n\\tstatic  void compare(Pair arr[], int n)\\n\\t{\\n\\t\\t// Comparator to sort the pair according to second element\\n\\t\\tArrays.sort(arr, new Comparator<Pair>() {\\n\\t\\t\\t@Override public int compare(Pair p1, Pair p2)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn p2.sum - p1.sum;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\t\\n\\t\\t\\n\\t}\\n}\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues)\\n    {\\n        int n=aliceValues.length;\\n        Pair[] a=new Pair[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=new Pair(aliceValues[i]+bobValues[i],aliceValues[i],bobValues[i]);\\n        }\\n        Compare.compare(a,n);\\n         int al=0;int bo=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%2==0)\\n            {\\n                al+=a[i].alice;\\n            }\\n            else\\n            {\\n                bo+=a[i].bob;\\n            }\\n        }\\n        return Integer.compare(al,bo);\\n    \\n    \\n    \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074514,
                "title": "easy-python-99-speed",
                "content": "**Easy Python | 99% Speed**\\n\\nEasy Python algorithm, which can be derived by rephrasing the problem statement:\\n\\nInstead of taking turns starting from a situation where both players have zero score, we first consider that Bob has a maximum score of ```sum(B)```. As a result, Alice starts with an inmense loss ```-sum(B)```, and every stone ```A[i]``` she takes gives her a net gain ```A[i]+B[i]```, because she gains the value of the stone (```A[i]```) plus what she takes away from Bob\\'s score ```B[i]```.\\n\\nThe algorithm then becomes very easy to program, because we can build an array with the gains for Alice ```G=A+B```, where we can sort the entries to find the upcoming optimal moves. Also, Bob in his turn will try to delete the biggest entries in this array, since they are the biggest gains for Alice.\\n\\nThe implementation of the program is thus very simple. It\\'s incredible how easy a problem can become once you rephrase the question.\\n\\nI hope the explanation was helpful.\\nCheers,\\n\\n\\n```\\nclass Solution:\\n    def stoneGameVI(self, A, B):\\n        G  = [a+b for a,b in zip(A,B)]\\n        G.sort()\\n        L  = len(A)\\n        d  = -sum(B) + sum( G[i] for i in range(L-1,-1,-2) )\\n        return 1 if d>0 else ( -1 if d<0 else 0 )\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```sum(B)```\n```-sum(B)```\n```A[i]```\n```A[i]+B[i]```\n```A[i]```\n```B[i]```\n```G=A+B```\n```\\nclass Solution:\\n    def stoneGameVI(self, A, B):\\n        G  = [a+b for a,b in zip(A,B)]\\n        G.sort()\\n        L  = len(A)\\n        d  = -sum(B) + sum( G[i] for i in range(L-1,-1,-2) )\\n        return 1 if d>0 else ( -1 if d<0 else 0 )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 972224,
                "title": "c-easiest-approach-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool compare(pair<int,int>a,pair<int,int>b){\\n        return a.first>b.first;\\n    }\\n    int stoneGameVI(vector<int>& av, vector<int>& bv) {\\n        vector<pair<int,int>> vec;\\n        int n=av.size();\\n        for(int i=0;i<n;i++){\\n            vec.push_back({av[i]+bv[i],i});\\n        }\\n        sort(vec.begin(),vec.end(),compare);\\n        int alice=0,bob=0;\\n        for(int i=0;i<n;i++){\\n            if(i%2==0){\\n                alice+=av[vec[i].second];\\n            }else{\\n                bob+=bv[vec[i].second];\\n            }\\n        }\\n        return alice==bob?0:alice>bob?1:-1;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool compare(pair<int,int>a,pair<int,int>b){\\n        return a.first>b.first;\\n    }\\n    int stoneGameVI(vector<int>& av, vector<int>& bv) {\\n        vector<pair<int,int>> vec;\\n        int n=av.size();\\n        for(int i=0;i<n;i++){\\n            vec.push_back({av[i]+bv[i],i});\\n        }\\n        sort(vec.begin(),vec.end(),compare);\\n        int alice=0,bob=0;\\n        for(int i=0;i<n;i++){\\n            if(i%2==0){\\n                alice+=av[vec[i].second];\\n            }else{\\n                bob+=bv[vec[i].second];\\n            }\\n        }\\n        return alice==bob?0:alice>bob?1:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 969551,
                "title": "python-greedy-max-heap-solution-explanation",
                "content": "The idea is that we want to take stones that will provide us with a large value, but also ones that provide the other player large value at the same time: so we can average out the values, such that the real value for the ith stone is actually 0.5 * p1_value + 0.5 * p2_value, where p1_value is how much the first player values the ith stone stone, and similarily p2_value is how much the second player values it.\\n\\nAll that\\'s left to do is at every turn, we will greedily pick the stone with the maximum value using the formula above, and we can do that efficiently by storing the values in a max heap.\\n\\nThe winner is the player who gathers the most value overall after choosing his stone in every turn using the above logic.\\n```\\nimport heapq\\n\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n\\n        n = len(bobValues)\\n        h = []\\n        \\n        for i, (a, b) in enumerate(zip(aliceValues, bobValues)):\\n            heapq.heappush(h, [(-1) * (0.5*a + 0.5*b), i])\\n        \\n        bob = 0\\n        alice = 0\\n        for i in range(n):\\n            _, pick = heapq.heappop(h)\\n                        \\n            if i % 2 == 0:\\n                alice += aliceValues[pick]\\n            else:\\n                bob += bobValues[pick]\\n        \\n        if alice > bob:\\n            return 1\\n        elif alice == bob:\\n            return 0\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n\\n        n = len(bobValues)\\n        h = []\\n        \\n        for i, (a, b) in enumerate(zip(aliceValues, bobValues)):\\n            heapq.heappush(h, [(-1) * (0.5*a + 0.5*b), i])\\n        \\n        bob = 0\\n        alice = 0\\n        for i in range(n):\\n            _, pick = heapq.heappop(h)\\n                        \\n            if i % 2 == 0:\\n                alice += aliceValues[pick]\\n            else:\\n                bob += bobValues[pick]\\n        \\n        if alice > bob:\\n            return 1\\n        elif alice == bob:\\n            return 0\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860874,
                "title": "python-3-4-lines-w-explanation-and-example-t-m-84-87",
                "content": "```\\nclass Solution:         # The optimum strategy for each is to select the rock for which the greatest\\n                        # sum of points is at risk. We sort the indices with that key, and then keep \\n                        # track of scores as Alice and Bob take their turns.                    \\n\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n\\n                                                    # Ex: aliceValues = [9,8,3,8], bobValues = [10,6,9,5]\\n        arr = sorted(zip(aliceValues, bobValues), \\n                     key = lambda x: -sum(x))       #     arr = [(9,10), (8,6), (8,5), (3,9)]\\n        \\n        a = sum([i[0] for i in arr[0::2]])          #     a = sum(9 + 8) = 17\\n        b = sum([i[1] for i in arr[1::2]])          #     b = sum(6 + 9) = 15\\n        \\n        return (a>=b) - (a<=b)                      #     return (a>=b) - (a<=b) = (17>=15) - (1<=17) \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t#                            = 1-0 = 1\\n\\n```\\n[https://leetcode.com/submissions/detail/851940272/ ](http://)\\n\\nI could be wrong, but I think it\\'s T:*O*(*N*log*N*) / M: *O*(*N*).",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:         # The optimum strategy for each is to select the rock for which the greatest\\n                        # sum of points is at risk. We sort the indices with that key, and then keep \\n                        # track of scores as Alice and Bob take their turns.                    \\n\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n\\n                                                    # Ex: aliceValues = [9,8,3,8], bobValues = [10,6,9,5]\\n        arr = sorted(zip(aliceValues, bobValues), \\n                     key = lambda x: -sum(x))       #     arr = [(9,10), (8,6), (8,5), (3,9)]\\n        \\n        a = sum([i[0] for i in arr[0::2]])          #     a = sum(9 + 8) = 17\\n        b = sum([i[1] for i in arr[1::2]])          #     b = sum(6 + 9) = 15\\n        \\n        return (a>=b) - (a<=b)                      #     return (a>=b) - (a<=b) = (17>=15) - (1<=17) \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t#                            = 1-0 = 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280939,
                "title": "java-simple-and-easy-greedy-solution-t-o-n-log-n-s-o-n-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        int n = aliceValues.length;\\n        \\n        int[][] stoneValues = new int[n][3];\\n        \\n        for(int i = 0; i < n; i++){\\n            stoneValues[i] = new int[]{aliceValues[i], bobValues[i],  (aliceValues[i] + bobValues[i])};\\n        }\\n        \\n        //Sort the stones, based on sum of Alice and Bob stones values\\n        Arrays.sort(stoneValues, (a, b) -> (b[2] - a[2]));\\n        \\n        int aliceScore = 0;\\n        \\n        //Alternatively pick stone value from Alice and Bob, start with Alice\\n        for(int i = 0; i < n; i++){\\n            \\n            if(i % 2 == 0){\\n                //Append the Alice stone values\\n                aliceScore += stoneValues[i][0];\\n            }else{\\n                //Substract the Bob stones values\\n                aliceScore -= stoneValues[i][1];\\n            }\\n        }\\n        \\n        if(aliceScore > 0) return 1;\\n        if(aliceScore < 0) return -1;\\n        \\n        return 0;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        int n = aliceValues.length;\\n        \\n        int[][] stoneValues = new int[n][3];\\n        \\n        for(int i = 0; i < n; i++){\\n            stoneValues[i] = new int[]{aliceValues[i], bobValues[i],  (aliceValues[i] + bobValues[i])};\\n        }\\n        \\n        //Sort the stones, based on sum of Alice and Bob stones values\\n        Arrays.sort(stoneValues, (a, b) -> (b[2] - a[2]));\\n        \\n        int aliceScore = 0;\\n        \\n        //Alternatively pick stone value from Alice and Bob, start with Alice\\n        for(int i = 0; i < n; i++){\\n            \\n            if(i % 2 == 0){\\n                //Append the Alice stone values\\n                aliceScore += stoneValues[i][0];\\n            }else{\\n                //Substract the Bob stones values\\n                aliceScore -= stoneValues[i][1];\\n            }\\n        }\\n        \\n        if(aliceScore > 0) return 1;\\n        if(aliceScore < 0) return -1;\\n        \\n        return 0;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440784,
                "title": "c-game-theory-greedy-optimal-play",
                "content": "This is a problem where both player will play optimally! Let assume that you are Alice.\\n**Now in order to win the game, you  you not only have to win the game, but also defeat your opponent**.  Now observe that when you takes the stone, you not only get the points, but take them away from bob too. So, we will gredily choose the maximum `aliceValue[i]+bobValue[i]`.\\n\\nHow this will work?\\n* Assume `aliceValue[i]>bobValue[i] ` --> so if you pick ith stone, you will be profitable\\n* Assume `aliceValue[i]<bobValue[i] `--> so, if you pick th stone, then you are basically restricting bob to pick ith stone, and as  aliceValue[i]<bobValue[i], and bob can\\'t pick bobValue[i], so again bob will go in loss and you will be profitable.\\n\\nThat is the whole strategy. Bob will also apply the same strategy (as both will play the game optimally) \\n\\n**CODE:**\\n```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        priority_queue<pair<int, int>, vector<pair<int,int>>> pq;\\n        \\n        for(int i=0; i<bobValues.size(); i++){\\n            pq.push({bobValues[i]+aliceValues[i], i});\\n        }\\n        \\n        int alice=0; int bob=0; int turn=0;\\n        while(!pq.empty()){\\n            if(turn==0){\\n                alice+=aliceValues[pq.top().second]; pq.pop();\\n            }\\n            else if(turn==1){\\n                bob+=bobValues[pq.top().second]; pq.pop();\\n            }\\n            if(turn==0){ turn=1; }\\n            else if(turn==1){ turn=0; }\\n        }\\n        \\n        if(alice>bob){ return 1; }\\n        else if(alice<bob){ return -1; }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        priority_queue<pair<int, int>, vector<pair<int,int>>> pq;\\n        \\n        for(int i=0; i<bobValues.size(); i++){\\n            pq.push({bobValues[i]+aliceValues[i], i});\\n        }\\n        \\n        int alice=0; int bob=0; int turn=0;\\n        while(!pq.empty()){\\n            if(turn==0){\\n                alice+=aliceValues[pq.top().second]; pq.pop();\\n            }\\n            else if(turn==1){\\n                bob+=bobValues[pq.top().second]; pq.pop();\\n            }\\n            if(turn==0){ turn=1; }\\n            else if(turn==1){ turn=0; }\\n        }\\n        \\n        if(alice>bob){ return 1; }\\n        else if(alice<bob){ return -1; }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 969508,
                "title": "c-o-nlogn-greedy-take-stone-sets-with-biggest-impact-first",
                "content": "Sort the IDs by the biggest sums and take those first. This means that each movement is going to add the most points or stop the other player from taking the most points.\\n```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& av, vector<int>& bv)\\n    {\\n        const size_t size = av.size();\\n        vector<size_t> ids( size, 0 );\\n        iota( ids.begin(), ids.end(), 0 );\\n        \\n        sort( ids.begin(), ids.end(), [&av, &bv](const size_t& l, const size_t& r)\\n             {\\n                 return (av[l]+bv[l]) > (av[r]+bv[r]);\\n             });\\n        \\n        int a = 0, b = 0;\\n        for( size_t i = 0; i < size; ++i )\\n        {\\n            if( (i&1) == 0 ) a += av[ids[i]];\\n            else b += bv[ids[i]];\\n        }\\n        \\n        if( a > b )\\n            return 1;\\n        else if( b > a )\\n            return -1;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& av, vector<int>& bv)\\n    {\\n        const size_t size = av.size();\\n        vector<size_t> ids( size, 0 );\\n        iota( ids.begin(), ids.end(), 0 );\\n        \\n        sort( ids.begin(), ids.end(), [&av, &bv](const size_t& l, const size_t& r)\\n             {\\n                 return (av[l]+bv[l]) > (av[r]+bv[r]);\\n             });\\n        \\n        int a = 0, b = 0;\\n        for( size_t i = 0; i < size; ++i )\\n        {\\n            if( (i&1) == 0 ) a += av[ids[i]];\\n            else b += bv[ids[i]];\\n        }\\n        \\n        if( a > b )\\n            return 1;\\n        else if( b > a )\\n            return -1;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830388,
                "title": "beats-99-38-python-3-explained",
                "content": "# Intuition\\nIn this problem instead of picking/not Picking largest making sum we need to pick those stones by alice which can hurt bob more.\\nSo we combine them and sort them in reverse order\\n`why we can do sorting? Because in question its stated we can pick any stone (and not only from left most or right most)`\\nNow alice will pick first highest combined effecting the bobPoints most (which is the total Sum of bob values) and then skip next point (which is to be picked by bob).\\nAccording to our alicePoints and bobPoints return the ans.\\n\\n# Code\\n```\\nclass Solution:\\n    def stoneGameVI(self, a: List[int], b: List[int]) -> int:\\n        # hurt other enemy rather than self collecting to max\\n        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))]\\n        combines.sort(reverse=True) # why we can sort? -> because we can pick any stone we want\\n        bobPoints = sum(b)\\n        alicePoints = 0\\n        for i in range(0, len(a), 2):\\n            alicePoints += combines[i][1]\\n            bobPoints -= combines[i][2]\\n        if alicePoints > bobPoints:\\n            return 1\\n        elif alicePoints < bobPoints:\\n            return -1\\n        return 0\\n        \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameVI(self, a: List[int], b: List[int]) -> int:\\n        # hurt other enemy rather than self collecting to max\\n        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))]\\n        combines.sort(reverse=True) # why we can sort? -> because we can pick any stone we want\\n        bobPoints = sum(b)\\n        alicePoints = 0\\n        for i in range(0, len(a), 2):\\n            alicePoints += combines[i][1]\\n            bobPoints -= combines[i][2]\\n        if alicePoints > bobPoints:\\n            return 1\\n        elif alicePoints < bobPoints:\\n            return -1\\n        return 0\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667246,
                "title": "best-c-using-max-heap-with-comments",
                "content": "\\n \\n      class Solution {\\n        public:\\n        int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        \\n        // MAKING AN ARRAY WITH SUM OF BOTH VALUES ; \\n        int i = 0 ; int j = 0 ; \\n        int n = aliceValues.size();\\n        vector<int> total ; \\n        while(j<n){\\n            total.push_back(aliceValues[i]+bobValues[j]);\\n            i++ ; j++ ; \\n        }\\n        \\n        // MAX HEAP WITH THAT ARRAY (pair of array[i],index)\\n        priority_queue<pair<int,int>> p ; \\n        int m = total.size() ; \\n        for(int i=0 ; i<m ; i++){\\n            p.push({total[i],i});\\n        }\\n        int sum1 = 0 ; \\n        int sum2 = 0 ;\\n        // ADDING SUMS TO SUM1 to SUM2 by getting index from top and then from that            index getting the value from that item\\n        while(!p.empty()){\\n           int index = p.top().second ; \\n            sum1 += aliceValues[index];\\n            p.pop();\\n            if(!p.empty()){\\n                 int index = p.top().second ; \\n                 sum2 += bobValues[index];\\n                p.pop();\\n            }\\n        }\\n        if(sum1>sum2) return 1 ; \\n        else if(sum2>sum1) return -1 ; \\n        else return 0 ; \\n            }\\n        };",
                "solutionTags": [
                    "C",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n        public:\\n        int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        \\n        // MAKING AN ARRAY WITH SUM OF BOTH VALUES ; \\n        int i = 0 ; int j = 0 ; \\n        int n = aliceValues.size();\\n        vector<int> total ; \\n        while(j<n){\\n            total.push_back(aliceValues[i]+bobValues[j]);\\n            i++ ; j++ ; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2645662,
                "title": "c-60-time-and-space-beats-time-o-lnogn-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a,vector<int> &b){\\n        return a[0]>b[0];\\n    }\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        int i,n = aliceValues.size(),sum = 0;\\n        vector<vector<int>> temp;\\n        for(i = 0; i < n; i++){\\n            sum = aliceValues[i]+bobValues[i];\\n            temp.push_back({sum,i});\\n        }\\n        int sum1 = 0,sum2 = 0;\\n        sort(temp.begin(),temp.end(),cmp);\\n        // for(auto &i: temp){\\n        //     cout<<i[0]<<\" \"<<i[1]<<endl;\\n        // }\\n        int x = 1;\\n        for(auto &i: temp){\\n            if(x){\\n                sum1+=aliceValues[i[1]];\\n            }else{\\n                sum2+=bobValues[i[1]];\\n            }\\n            x ^= 1;\\n        }\\n        // cout<<endl;\\n        // cout<<sum1<<\" \"<<sum2;\\n        if(sum1==sum2){\\n            return 0;\\n        }else if(sum1>sum2){\\n            return 1;\\n        }return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a,vector<int> &b){\\n        return a[0]>b[0];\\n    }\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        int i,n = aliceValues.size(),sum = 0;\\n        vector<vector<int>> temp;\\n        for(i = 0; i < n; i++){\\n            sum = aliceValues[i]+bobValues[i];\\n            temp.push_back({sum,i});\\n        }\\n        int sum1 = 0,sum2 = 0;\\n        sort(temp.begin(),temp.end(),cmp);\\n        // for(auto &i: temp){\\n        //     cout<<i[0]<<\" \"<<i[1]<<endl;\\n        // }\\n        int x = 1;\\n        for(auto &i: temp){\\n            if(x){\\n                sum1+=aliceValues[i[1]];\\n            }else{\\n                sum2+=bobValues[i[1]];\\n            }\\n            x ^= 1;\\n        }\\n        // cout<<endl;\\n        // cout<<sum1<<\" \"<<sum2;\\n        if(sum1==sum2){\\n            return 0;\\n        }else if(sum1>sum2){\\n            return 1;\\n        }return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1940718,
                "title": "c-easy-to-understand-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        int alice=0,bob=0;\\n        priority_queue<vector<int>> pq;\\n        int n=aliceValues.size();\\n        for(int i=0;i<n;i++)\\n        {\\n     pq.push({(aliceValues[i]+bobValues[i]),aliceValues[i],bobValues[i]});\\n        }\\n        bool ok=true;\\n        while(!pq.empty())\\n        {\\n            vector<int> v;\\n            v=pq.top();\\n            pq.pop();\\n            if(ok)\\n            {\\n            alice+=v[1];\\n            ok=false;\\n            }\\n            else\\n            {      \\n            bob+=v[2];\\n            ok=true;\\n            }\\n        }\\n        if(alice>bob)\\n        return 1;\\n        else if(bob>alice)\\n        return -1;\\n        \\n        return 0;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        int alice=0,bob=0;\\n        priority_queue<vector<int>> pq;\\n        int n=aliceValues.size();\\n        for(int i=0;i<n;i++)\\n        {\\n     pq.push({(aliceValues[i]+bobValues[i]),aliceValues[i],bobValues[i]});\\n        }\\n        bool ok=true;\\n        while(!pq.empty())\\n        {\\n            vector<int> v;\\n            v=pq.top();\\n            pq.pop();\\n            if(ok)\\n            {\\n            alice+=v[1];\\n            ok=false;\\n            }\\n            else\\n            {      \\n            bob+=v[2];\\n            ok=true;\\n            }\\n        }\\n        if(alice>bob)\\n        return 1;\\n        else if(bob>alice)\\n        return -1;\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936956,
                "title": "cpp-simple-solutions-two-logics",
                "content": "Code 1:-\\n```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& a, vector<int>& b) {\\n        priority_queue<pair<int, pair<int,int>>> pq;\\n        \\n        int alice=0, bob=0;\\n        \\n        for(int i=0; i<a.size(); i++){\\n            pq.push({a[i]+b[i], {a[i], b[i]}});\\n        }\\n        \\n        while(pq.size()){\\n            alice += pq.top().second.first; pq.pop();\\n            if(pq.size()) bob += pq.top().second.second, pq.pop();\\n        }\\n        \\n        if(bob == alice) return 0;\\n        if(bob > alice) return -1;\\n        return 1;\\n    }\\n};\\n```\\n Code:- 2\\n```\\nvector<int> alice, bob;\\n\\nstruct myComp {\\n  bool operator()(pair<int, int>& a, pair<int, int>& b){\\n      return alice[a.second] + bob[a.second] < alice[b.second] + bob[b.second];\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        alice = aliceValues;\\n        bob = bobValues;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, myComp> a,b;\\n        \\n        for(int i=0;i<aliceValues.size();i++){\\n            a.push({aliceValues[i], i});\\n            b.push({bobValues[i], i});\\n        }\\n        \\n        int ans1, ans2;\\n        ans1 = ans2 = 0;\\n        int vis[100001] = {};\\n        \\n        while(a.size()){\\n            while(a.size() && vis[a.top().second] == 1) a.pop();\\n            if(a.size()){ \\n                ans1 += a.top().first;\\n                vis[a.top().second] = 1;\\n                a.pop();\\n            }\\n            \\n            while(b.size() && vis[b.top().second] == 1) b.pop();\\n            if(b.size()){\\n                ans2 += b.top().first;\\n                vis[b.top().second] = 1;\\n                b.pop();\\n            }\\n        }\\n        \\n        if(ans1 == ans2) return 0;\\n        if(ans1 > ans2) return 1;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& a, vector<int>& b) {\\n        priority_queue<pair<int, pair<int,int>>> pq;\\n        \\n        int alice=0, bob=0;\\n        \\n        for(int i=0; i<a.size(); i++){\\n            pq.push({a[i]+b[i], {a[i], b[i]}});\\n        }\\n        \\n        while(pq.size()){\\n            alice += pq.top().second.first; pq.pop();\\n            if(pq.size()) bob += pq.top().second.second, pq.pop();\\n        }\\n        \\n        if(bob == alice) return 0;\\n        if(bob > alice) return -1;\\n        return 1;\\n    }\\n};\\n```\n```\\nvector<int> alice, bob;\\n\\nstruct myComp {\\n  bool operator()(pair<int, int>& a, pair<int, int>& b){\\n      return alice[a.second] + bob[a.second] < alice[b.second] + bob[b.second];\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        alice = aliceValues;\\n        bob = bobValues;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, myComp> a,b;\\n        \\n        for(int i=0;i<aliceValues.size();i++){\\n            a.push({aliceValues[i], i});\\n            b.push({bobValues[i], i});\\n        }\\n        \\n        int ans1, ans2;\\n        ans1 = ans2 = 0;\\n        int vis[100001] = {};\\n        \\n        while(a.size()){\\n            while(a.size() && vis[a.top().second] == 1) a.pop();\\n            if(a.size()){ \\n                ans1 += a.top().first;\\n                vis[a.top().second] = 1;\\n                a.pop();\\n            }\\n            \\n            while(b.size() && vis[b.top().second] == 1) b.pop();\\n            if(b.size()){\\n                ans2 += b.top().first;\\n                vis[b.top().second] = 1;\\n                b.pop();\\n            }\\n        }\\n        \\n        if(ans1 == ans2) return 0;\\n        if(ans1 > ans2) return 1;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262605,
                "title": "simple-sorting-solution-in-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        vector<pair<int,int> >alicesort;\\n        for(int i=0;i<aliceValues.size();i++)\\n        {\\n            alicesort.push_back({aliceValues[i]+bobValues[i],i});\\n        }\\n        sort(alicesort.begin(),alicesort.end(),greater<pair<int,int> >());\\n        int alicescore=0;\\n        int bobscore=0;\\n        \\n        for(int i=0;i<alicesort.size();i++)\\n        {\\n        if(i%2==0)\\n            alicescore+=aliceValues[alicesort[i].second];\\n        else\\n            bobscore+=bobValues[alicesort[i].second];\\n        }\\n        \\n        \\n        if(alicescore<bobscore)\\n            return -1;\\n        else if(alicescore>bobscore)\\n            return 1;\\n        else\\n            return 0;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        vector<pair<int,int> >alicesort;\\n        for(int i=0;i<aliceValues.size();i++)\\n        {\\n            alicesort.push_back({aliceValues[i]+bobValues[i],i});\\n        }\\n        sort(alicesort.begin(),alicesort.end(),greater<pair<int,int> >());\\n        int alicescore=0;\\n        int bobscore=0;\\n        \\n        for(int i=0;i<alicesort.size();i++)\\n        {\\n        if(i%2==0)\\n            alicescore+=aliceValues[alicesort[i].second];\\n        else\\n            bobscore+=bobValues[alicesort[i].second];\\n        }\\n        \\n        \\n        if(alicescore<bobscore)\\n            return -1;\\n        else if(alicescore>bobscore)\\n            return 1;\\n        else\\n            return 0;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1196604,
                "title": "python3-sort-and-greedy",
                "content": "Let\\'s play from Alice\\'s point of view. We want to maximize the difference between Alice\\'s and Bob\\'s scores. For any stone, suppose its value is a and b for Alice and Bob. \\n\\n1. If alice takes it, Alice\\'s value will +a.\\n2. If alice does not take it, Bob\\'s value will +b. From Alice\\'s point of view, Alice\\'s value will -b.\\n\\nSo for each stone, the difference by taking one of the above decisions can be as big as a + b. So we need to sort the stones so each time Alice/Bob just picks up the stone with the maximum a+b. This will make sure when Alice gets a, Bob will also lose b. The same strategy will apply to Bob as well.\\n\\n```python\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        diff = [(a+b, i) for i, (a,b) in enumerate(zip(aliceValues, bobValues))]\\n        diff.sort(reverse=True)\\n        alice = bob = 0\\n        for i in range(len(diff)):\\n            if i % 2 == 0:\\n                alice += aliceValues[diff[i][1]]\\n            else:\\n                bob += bobValues[diff[i][1]]\\n        if alice > bob:\\n            return 1\\n        elif alice < bob:\\n            return -1\\n        else:\\n            return 0\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        diff = [(a+b, i) for i, (a,b) in enumerate(zip(aliceValues, bobValues))]\\n        diff.sort(reverse=True)\\n        alice = bob = 0\\n        for i in range(len(diff)):\\n            if i % 2 == 0:\\n                alice += aliceValues[diff[i][1]]\\n            else:\\n                bob += bobValues[diff[i][1]]\\n        if alice > bob:\\n            return 1\\n        elif alice < bob:\\n            return -1\\n        else:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 994420,
                "title": "java-4-clean-codes-o-n-log-n-o-n-to-o-n-o-1",
                "content": "Optimal strategy for both players at any point of time is to pick the stone with maximum combined value i.e. aliceValues[i] + bobValues[i] among all the remaining stones. Refer [Post 1](https://leetcode.com/problems/stone-game-vi/discuss/969635/math-proof) and [Post 2](https://leetcode.com/problems/stone-game-vi/discuss/969817/Strategy-proof) for great explanations of why that is the case.\\n\\n**PriorityQueue**\\n```\\n// 139 ms. 26.61%\\npublic int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(b[0] + b[1], a[0] + a[1]));\\n    for(int i = 0; i < aliceValues.length; i++) {\\n    \\tpq.add(new int[] { aliceValues[i], bobValues[i] });\\n    }\\n    int[] score = new int[2];\\n    for(int i = 0; i < aliceValues.length; i++) {\\n    \\tscore[i & 1] += pq.poll()[i & 1];\\n    }\\n    return Integer.compare(score[0], score[1]);\\n}\\n```\\n\\nTime complexity: O(n log n)\\nSpace complexity: O(n)\\n\\n**Sorting**\\n\\n```\\n// 74 ms. 89.66%\\npublic int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n    int n = aliceValues.length;\\n    int[][] A = new int[n][];\\n    for(int i = 0; i < n; i++) {\\n        A[i] = new int[] { aliceValues[i] + bobValues[i], aliceValues[i], bobValues[i] };\\n    }\\n    Arrays.sort(A, (a, b) -> b[0] - a[0]);\\n    int a = 0, b = 0;\\n    for(int i = 0; i < n; i++) {\\n        if((i & 1) == 0) {\\n            a += A[i][1];\\n        } else {\\n            b += A[i][2];\\n        }\\n    }\\n    return Integer.compare(a, b);\\n}\\n```\\n\\nTime complexity: O(n log n)\\nSpace complexity: O(n)\\n\\n**Sorting - Space optimized**\\n\\n```\\n// 15 ms. 99.50%\\npublic int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n    int n = aliceValues.length, diff = 0;\\n    for(int i = 0; i < n; i++) {\\n        aliceValues[i] += bobValues[i];\\n        diff -= bobValues[i];\\n    }\\n    Arrays.sort(aliceValues);\\n    for(int i = n - 1; i >= 0; i -= 2) {\\n        diff += aliceValues[i];\\n    }\\n    return Integer.compare(diff, 0);\\n}\\n```\\n\\nTime complexity: O(n log n)\\nSpace complexity: O(1) assuming we\\'re allowed to modify the original array(s) otherwise we\\'ll need O(n).\\n\\n**Counting sort**\\n\\n```\\n// 3 ms. 100%\\npublic int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n    int n = aliceValues.length, diff = 0;\\n    int[] count = new int[201];\\n    for(int i = 0; i < n; i++) {\\n        count[aliceValues[i] + bobValues[i]]++;\\n        diff -= bobValues[i];\\n    }\\n    for(int i = 200, turn = 1; i >= 0; i--) {\\n        diff += ((count[i] + turn) >> 1) * i;\\n        if((count[i] & 1) != 0) turn ^= 1;\\n    }\\n    return Integer.compare(diff, 0);\\n}\\n```\\n\\nTime complexity: O(n)\\nSpace complexity: O(1)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// 139 ms. 26.61%\\npublic int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(b[0] + b[1], a[0] + a[1]));\\n    for(int i = 0; i < aliceValues.length; i++) {\\n    \\tpq.add(new int[] { aliceValues[i], bobValues[i] });\\n    }\\n    int[] score = new int[2];\\n    for(int i = 0; i < aliceValues.length; i++) {\\n    \\tscore[i & 1] += pq.poll()[i & 1];\\n    }\\n    return Integer.compare(score[0], score[1]);\\n}\\n```\n```\\n// 74 ms. 89.66%\\npublic int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n    int n = aliceValues.length;\\n    int[][] A = new int[n][];\\n    for(int i = 0; i < n; i++) {\\n        A[i] = new int[] { aliceValues[i] + bobValues[i], aliceValues[i], bobValues[i] };\\n    }\\n    Arrays.sort(A, (a, b) -> b[0] - a[0]);\\n    int a = 0, b = 0;\\n    for(int i = 0; i < n; i++) {\\n        if((i & 1) == 0) {\\n            a += A[i][1];\\n        } else {\\n            b += A[i][2];\\n        }\\n    }\\n    return Integer.compare(a, b);\\n}\\n```\n```\\n// 15 ms. 99.50%\\npublic int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n    int n = aliceValues.length, diff = 0;\\n    for(int i = 0; i < n; i++) {\\n        aliceValues[i] += bobValues[i];\\n        diff -= bobValues[i];\\n    }\\n    Arrays.sort(aliceValues);\\n    for(int i = n - 1; i >= 0; i -= 2) {\\n        diff += aliceValues[i];\\n    }\\n    return Integer.compare(diff, 0);\\n}\\n```\n```\\n// 3 ms. 100%\\npublic int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n    int n = aliceValues.length, diff = 0;\\n    int[] count = new int[201];\\n    for(int i = 0; i < n; i++) {\\n        count[aliceValues[i] + bobValues[i]]++;\\n        diff -= bobValues[i];\\n    }\\n    for(int i = 200, turn = 1; i >= 0; i--) {\\n        diff += ((count[i] + turn) >> 1) * i;\\n        if((count[i] & 1) != 0) turn ^= 1;\\n    }\\n    return Integer.compare(diff, 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 975294,
                "title": "c-0-nlogn-use-sort-clean-code",
                "content": "Strategy: every player select the stone which satisfy he/she most and hurt the opponent most.\\n```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        vector<pair<int, int>> stones;\\n        \\n        for (int i = 0; i < aliceValues.size(); ++i) {\\n            stones.push_back({aliceValues[i] + bobValues[i], i});\\n        }\\n        \\n        sort(stones.rbegin(), stones.rend());\\n        \\n        int a = 0;\\n        int b = 0;\\n        \\n        for (int i = 0; i < stones.size(); ++i) {\\n            if (i % 2 == 0) {\\n                a += aliceValues[stones[i].second];\\n            } else {\\n                b += bobValues[stones[i].second];\\n            }\\n        }\\n        \\n        return a == b ? 0 : a > b ? 1 : -1;\\n    }\\n};\\n```\\n\\nbecause the max stone value is 100. We can use vector\\'s index to indicate sum value.\\n```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        vector<vector<int>> stone(201);\\n        \\n        for (int i = 0; i < aliceValues.size(); ++i) {\\n            stone[aliceValues[i] + bobValues[i]].push_back(i);\\n        }\\n        \\n        int a = 0;\\n        int b = 0;\\n        \\n        for (int i = 200, t = 0; i >= 0; --i) {\\n            for (auto& idx : stone[i]) {\\n                if (t % 2 == 0) {\\n                    a += aliceValues[idx];\\n                } else {\\n                    b += bobValues[idx];\\n                }\\n                ++t;\\n            }\\n        }\\n        \\n        return a == b ? 0 : a > b ? 1 : -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        vector<pair<int, int>> stones;\\n        \\n        for (int i = 0; i < aliceValues.size(); ++i) {\\n            stones.push_back({aliceValues[i] + bobValues[i], i});\\n        }\\n        \\n        sort(stones.rbegin(), stones.rend());\\n        \\n        int a = 0;\\n        int b = 0;\\n        \\n        for (int i = 0; i < stones.size(); ++i) {\\n            if (i % 2 == 0) {\\n                a += aliceValues[stones[i].second];\\n            } else {\\n                b += bobValues[stones[i].second];\\n            }\\n        }\\n        \\n        return a == b ? 0 : a > b ? 1 : -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        vector<vector<int>> stone(201);\\n        \\n        for (int i = 0; i < aliceValues.size(); ++i) {\\n            stone[aliceValues[i] + bobValues[i]].push_back(i);\\n        }\\n        \\n        int a = 0;\\n        int b = 0;\\n        \\n        for (int i = 200, t = 0; i >= 0; --i) {\\n            for (auto& idx : stone[i]) {\\n                if (t % 2 == 0) {\\n                    a += aliceValues[idx];\\n                } else {\\n                    b += bobValues[idx];\\n                }\\n                ++t;\\n            }\\n        }\\n        \\n        return a == b ? 0 : a > b ? 1 : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 973148,
                "title": "c-multimap-solution-explained-75-time-15-space",
                "content": "Great problem and my first usage of a `multimap`, rushing to check its docs while trying to complete the problem itself on time - quite fun!\\n\\nMy basic assumption was that in order to figure out the most convenient move for each player, we have to sum their matching scores: it is not just how much it gives you directly, but it is also how much you manage to \"steal\" from your opponent!\\n\\nIn order to do this, a multimap comes in really handy, since it allow us to store even repeated keys if necessary (some stones might have the same overall value of others) and keeps them nicely sorted for us on top of it.\\n\\nTo go in that direction, we declare first of all a few support variables:\\n* `diffs` is our aforementioned `multimap` storing the summed score as a key and the matching index as a value; passing the second optional parameter will make our live easier, if we tell it to sort results using `greater<int>`, for example;\\n* `len`, `aScore` and `bScore` are all integers storing the length of the input and the scores for Alice and Bob, both set initially to `0`;\\n* `aTurn` is a simple boolean to tell us if it is Alice or Bob to do the next move - initially set to `true` since the rules are that Alice will always move first.\\n\\nWith that laid out, we then proceed to populate `diffs` as stated before, summing the values of each position as a key and passing the index of said position as a value.\\n\\nTime then to go for the actual development of the game, which is rather straightforward now: we will loop through all the best moves (kindly sorted for us by our `multimap`) and alternatively assign it to Alice or Bob, flipping our boolean at each iteration to know who moves next.\\n\\nOnce done, we can return a value according to their cumulated score and be done with it :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& ali, vector<int>& bob) {\\n        // support variables\\n        multimap<int, int, greater<int>> diffs;\\n        int len = ali.size(), aScore = 0, bScore = 0;\\n        bool aTurn = true;\\n        // populating diffs\\n        for (int i = 0; i < len; i++) {\\n            diffs.insert({(ali[i] + bob[i]), i});\\n        }\\n        for (auto e: diffs) {\\n            // playing the optimal move for each player\\n            if (aTurn) aScore += ali[e.second];\\n            else bScore += bob[e.second];\\n            aTurn = !aTurn;\\n        }\\n        return aScore == bScore ? 0 : aScore > bScore ? 1 : -1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& ali, vector<int>& bob) {\\n        // support variables\\n        multimap<int, int, greater<int>> diffs;\\n        int len = ali.size(), aScore = 0, bScore = 0;\\n        bool aTurn = true;\\n        // populating diffs\\n        for (int i = 0; i < len; i++) {\\n            diffs.insert({(ali[i] + bob[i]), i});\\n        }\\n        for (auto e: diffs) {\\n            // playing the optimal move for each player\\n            if (aTurn) aScore += ali[e.second];\\n            else bScore += bob[e.second];\\n            aTurn = !aTurn;\\n        }\\n        return aScore == bScore ? 0 : aScore > bScore ? 1 : -1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 969660,
                "title": "java-o-nlogn-solution",
                "content": "Optimal strategy is to pick a stone with the maximum **combined value.**\\n```\\nclass Solution {\\n    public int stoneGameVI(int[] a, int[] b) {\\n        int n = a.length;\\n\\t\\tpair p[] = new pair[n];\\n\\t\\tfor (int i = 0; i < n; i++) \\n\\t\\t\\tp[i] = new pair(a[i] + b[i], i); \\n\\t\\t\\n        Arrays.sort(p, (x,y) -> y.v - x.v); // sorting in decreasing order (a[i] + b[i])\\n        \\n        int av = 0, bv = 0;\\n\\t\\tfor(int i=0;i<n ;i++){\\n            if(i%2 == 0){\\n                av += a[p[i].i];\\n            }else{\\n                bv += b[p[i].i];\\n            }\\n        }\\n\\t\\treturn av == bv ? 0 : (av > bv ? 1 : -1);\\n\\t}\\n\\n\\tclass pair {\\n\\t\\tint v, i;\\n\\t\\tpair(int dd, int ii) {\\n\\t\\t\\tv = dd;\\n\\t\\t\\ti = ii;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int stoneGameVI(int[] a, int[] b) {\\n        int n = a.length;\\n\\t\\tpair p[] = new pair[n];\\n\\t\\tfor (int i = 0; i < n; i++) \\n\\t\\t\\tp[i] = new pair(a[i] + b[i], i); \\n\\t\\t\\n        Arrays.sort(p, (x,y) -> y.v - x.v); // sorting in decreasing order (a[i] + b[i])\\n        \\n        int av = 0, bv = 0;\\n\\t\\tfor(int i=0;i<n ;i++){\\n            if(i%2 == 0){\\n                av += a[p[i].i];\\n            }else{\\n                bv += b[p[i].i];\\n            }\\n        }\\n\\t\\treturn av == bv ? 0 : (av > bv ? 1 : -1);\\n\\t}\\n\\n\\tclass pair {\\n\\t\\tint v, i;\\n\\t\\tpair(int dd, int ii) {\\n\\t\\t\\tv = dd;\\n\\t\\t\\ti = ii;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 969573,
                "title": "python-sort-based-solution",
                "content": "To play optimally is to get the max points for yourself and min for the opponent. Therefore the value of each played stone is the sum of the values of that stone for both players. We use this value to sort the arrays of stones and then iterate over the resulting array calculating max sums for Alice and Bob:\\n```\\ndef stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        alice_profit = sorted([(av + bv, av, bv) for av, bv in zip(aliceValues, bobValues)], reverse=True)\\n        ap = bp = 0\\n        \\n        for i, (az, a, b) in enumerate(alice_profit):\\n            if i & 1: bp += b\\n            else: ap += a\\n        \\n        if ap == bp: return 0\\n        elif ap > bp: return 1\\n        else: return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\ndef stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        alice_profit = sorted([(av + bv, av, bv) for av, bv in zip(aliceValues, bobValues)], reverse=True)\\n        ap = bp = 0\\n        \\n        for i, (az, a, b) in enumerate(alice_profit):\\n            if i & 1: bp += b\\n            else: ap += a\\n        \\n        if ap == bp: return 0\\n        elif ap > bp: return 1\\n        else: return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3590614,
                "title": "greedy-heep",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(n))$$.\\n\\n- Space complexity: $$O(n)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        values = [(-a - b, a, b) for a, b in zip(aliceValues, bobValues)]\\n        heapq.heapify(values)\\n        aliceScore = bobScore = 0\\n        while True:\\n            if values:\\n                aliceScore += heapq.heappop(values)[1]\\n            else:\\n                break\\n\\n            if values:\\n                bobScore += heapq.heappop(values)[2]\\n            else:\\n                break\\n        \\n        if aliceScore > bobScore:\\n            return 1\\n        elif aliceScore < bobScore:\\n            return -1\\n        return 0\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        values = [(-a - b, a, b) for a, b in zip(aliceValues, bobValues)]\\n        heapq.heapify(values)\\n        aliceScore = bobScore = 0\\n        while True:\\n            if values:\\n                aliceScore += heapq.heappop(values)[1]\\n            else:\\n                break\\n\\n            if values:\\n                bobScore += heapq.heappop(values)[2]\\n            else:\\n                break\\n        \\n        if aliceScore > bobScore:\\n            return 1\\n        elif aliceScore < bobScore:\\n            return -1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567476,
                "title": "dp-sollution-optimsed-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhere dp solutions gives tle but one can tell that to the interviewer\\nthe most optimsed greedy approach is here which i coded by lookking on\\nthe first hint to be honest\\nwhen i used the greeedy approach that each player will only try to maximise his score it only passed 72/95 test case which means that some case this greedy approach fails\\ncause in a optimal game play we not only need to maximize our win chances but also decrease the wining chances of the opponent\\nthat why we are using greedy approach to choose that index stone which combinly valuable to both ie the one for which alice[i]+bob[i] is maximum and game play occurs chance by chance\\nso we use c++ priority_queue which is by default max heap\\n\\n\\n\\ndp tle solution\\n\\nclass Solution {\\npublic:\\n\\n    map<string,long long >dp;\\n    long long  help(int n,vector<int>&alice,vector<int>&bob,string st,int p,int s){\\n\\n\\n        if(s==n){\\n            return 0;\\n        }\\n\\n\\n        string th=st+to_string(p);\\n        if(dp.find(th)!=dp.end()){\\n            return dp[th];\\n        }\\n\\n\\n\\n        long long  curr=INT_MIN ;\\n        for(int i=0;i<n;i++){\\n\\n            if(st[i]==\\'0\\'){\\n                st[i]=1;\\n                s++;\\n\\n             int  c=(p==1?alice[i]:bob[i]);\\n                curr=max(curr,c-help(n,alice,bob,st,1-p,s));\\n                // st.erase(st.find(i));\\n                st[i]=\\'0\\';\\n                s--;\\n            \\n            }else{\\n                continue;\\n            }\\n        }\\n        return dp[th]=curr;\\n\\n\\n\\n        \\n    }\\n    int stoneGameVI(vector<int>& alice, vector<int>& bob) {\\n\\n\\n        //since greedy approach only  satify locally and fails for multiple test cases \\n        //we will use dp \\n\\n        int n=alice.size();\\n        \\n\\n\\n        // string st=\"\";\\n\\n        string st=\"\";\\n        for(int i=0;i<n;i++){\\n            st+=\"0\";\\n        }\\n        // for(int i=0)\\n        //this set will keep track of what all index stones have picked now \\n        //in any path of the gameplay\\n\\n        long long ans=help(n,alice,bob,st,1,0);\\n        \\n        if(ans>0){\\n            return 1;\\n        }else if(ans<0){\\n            return -1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nnow we have the optimsed solution greedy\\n# Code\\n``\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& alice, vector<int>& bob) {\\n\\n\\n\\n        //here the greedy approach to choose the most valuable is not the best game play\\n        //the best play is to make max point from our side as well as reduce the points of \\n        //opponents as much as possible\\n\\n        //we will choose the stone index where sum of values for both is maximum \\n        //this intuition is correct \\n        //take example\\n        //5   1\\n        //6    7\\n        //if the second player chooses 7 the opponenet only loses 1 points\\n        //but the second player choosed 6 then its a good score for him and alos \\n        //he reduced the point of opponent as much as possible\\n\\n        priority_queue<pair<int,int>>pq;\\n        int n=alice.size();\\n\\n        for(int i=0;i<n;i++){\\n            pq.push({alice[i]+bob[i],i});\\n\\n\\n        }\\n\\n        int p=1;\\n\\n        long long a=0;\\n        long long b=0;\\n\\n        while(pq.empty()==false){\\n            if(p){\\n                auto curr=pq.top();\\n\\n                a+=alice[pq.top().second];\\n                pq.pop();\\n\\n                \\n\\n            }else{\\n                auto curr=pq.top();\\n                b+=bob[pq.top().second];\\n                pq.pop();\\n\\n            }\\n            p=1-p;\\n\\n        }\\n        if(a>b){\\n            return 1;\\n        }else if(a<b){\\n            return -1;\\n        \\n        }\\n        return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n\\n    map<string,long long >dp;\\n    long long  help(int n,vector<int>&alice,vector<int>&bob,string st,int p,int s){\\n\\n\\n        if(s==n){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3219319,
                "title": "o-nlogn-array-of-array-solution-10-lines-of-code",
                "content": "**create an array of array as stones and it will have index, alicevalue , bobvalue.**\\n\\n**now sort it in descending order of the total values combined.**\\n\\n**traverse from 0 to n\\nand collect stones as their turn comes by.**\\n\\n**atlast return the winner.**\\n```\\nclass Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        int alice=0,bob=0,n=aliceValues.length;\\n        int stones[][]=new int [n][3];\\n        for(int i=0;i<n;i++){\\n            stones[i]=new int[]{i,aliceValues[i],bobValues[i]};\\n        }\\n        Arrays.sort(stones,(a,b)->(b[1]+b[2])-(a[1]+a[2]));\\n        for(int i=0;i<n;i++){\\n            int []stone=stones[i];\\n            if(i%2==0){\\n                alice+=stone[1];\\n            }\\n            else{\\n                bob+=stone[2];\\n            }\\n        }\\n        if(alice==bob)return 0;\\n        return alice>bob?1:-1;\\n    }\\n}\\n```\\n# Upvoting is much appreciated",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        int alice=0,bob=0,n=aliceValues.length;\\n        int stones[][]=new int [n][3];\\n        for(int i=0;i<n;i++){\\n            stones[i]=new int[]{i,aliceValues[i],bobValues[i]};\\n        }\\n        Arrays.sort(stones,(a,b)->(b[1]+b[2])-(a[1]+a[2]));\\n        for(int i=0;i<n;i++){\\n            int []stone=stones[i];\\n            if(i%2==0){\\n                alice+=stone[1];\\n            }\\n            else{\\n                bob+=stone[2];\\n            }\\n        }\\n        if(alice==bob)return 0;\\n        return alice>bob?1:-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072348,
                "title": "simple-solution-by-intuition-and-logic-priority-queue-max-heap-pairs-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& alice, vector<int>& bob) {\\n        int n=alice.size();\\n        priority_queue<pair<int,int>>pq;\\n        for(int i=0;i<n;i++)pq.push({alice[i]+bob[i],i});\\n        int aliceSum=0,bobSum=0,turn=0;\\n        while(!pq.empty()){\\n            pair<int,int> temp=pq.top();\\n            pq.pop();\\n            if(turn==0)aliceSum+=alice[temp.second];\\n            else bobSum+=bob[temp.second];\\n            turn=turn^1;\\n        }\\n        if(aliceSum==bobSum)return 0;\\n        else if(aliceSum<bobSum)return -1;\\n        else return 1;\\n    }\\n};\\n```\\nDo Upvote if Helpful",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& alice, vector<int>& bob) {\\n        int n=alice.size();\\n        priority_queue<pair<int,int>>pq;\\n        for(int i=0;i<n;i++)pq.push({alice[i]+bob[i],i});\\n        int aliceSum=0,bobSum=0,turn=0;\\n        while(!pq.empty()){\\n            pair<int,int> temp=pq.top();\\n            pq.pop();\\n            if(turn==0)aliceSum+=alice[temp.second];\\n            else bobSum+=bob[temp.second];\\n            turn=turn^1;\\n        }\\n        if(aliceSum==bobSum)return 0;\\n        else if(aliceSum<bobSum)return -1;\\n        else return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816827,
                "title": "easiest-solution-c-plus-plus-priority-queue-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass compare{\\n    public:\\n    bool operator()(pair<int,int> a,pair<int,int> b){\\n        return b.first>a.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        priority_queue<pair<int, int>, vector<pair<int,int>>,compare> pq;\\n        \\n        for(int i=0; i<bobValues.size(); i++){\\n            pq.push({bobValues[i]+aliceValues[i], i});\\n        }\\n        \\n        int alice=0; int bob=0; int turn=0;\\n        while(!pq.empty()){\\n            if(turn==0){\\n                alice+=aliceValues[pq.top().second]; pq.pop();\\n            }\\n            else if(turn==1){\\n                bob+=bobValues[pq.top().second]; pq.pop();\\n            }\\n            if(turn==0){ turn=1; }\\n            else if(turn==1){ turn=0; }\\n        }\\n        \\n        if(alice>bob){ return 1; }\\n        else if(alice<bob){ return -1; }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass compare{\\n    public:\\n    bool operator()(pair<int,int> a,pair<int,int> b){\\n        return b.first>a.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        priority_queue<pair<int, int>, vector<pair<int,int>>,compare> pq;\\n        \\n        for(int i=0; i<bobValues.size(); i++){\\n            pq.push({bobValues[i]+aliceValues[i], i});\\n        }\\n        \\n        int alice=0; int bob=0; int turn=0;\\n        while(!pq.empty()){\\n            if(turn==0){\\n                alice+=aliceValues[pq.top().second]; pq.pop();\\n            }\\n            else if(turn==1){\\n                bob+=bobValues[pq.top().second]; pq.pop();\\n            }\\n            if(turn==0){ turn=1; }\\n            else if(turn==1){ turn=0; }\\n        }\\n        \\n        if(alice>bob){ return 1; }\\n        else if(alice<bob){ return -1; }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2211757,
                "title": "java-easy-priority-queue",
                "content": "```\\nclass Pair {\\n    int a;\\n    int b;\\n    int sum;\\n    Pair(int a,int b , int sum){\\n        this.a=a;\\n        this.b=b;\\n        this.sum=sum;\\n    }\\n\\n}\\nclass Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n       \\n        PriorityQueue<Pair> max = new PriorityQueue<>((x,y)->y.sum-x.sum);\\n// we can use only one custom class with Pq injava, x,y represent every new entry that has 3 sub fields \\n        for (int i = 0; i < bobValues.length; i++) {\\n            max.add(new Pair(aliceValues[i], bobValues[i], aliceValues[i]+bobValues[i]));\\n\\n        }\\n        int alicePoints = 0, bobPoints = 0, ans = 0;\\n        while (max.size() > 0) {\\n            alicePoints+=max.poll().a;\\n            if(max.size()>0)\\n            bobPoints+=max.poll().b;            \\n        }\\n        ans = (alicePoints > bobPoints) ? 1 : (alicePoints == bobPoints) ? 0 : -1;\\n        return ans;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Pair {\\n    int a;\\n    int b;\\n    int sum;\\n    Pair(int a,int b , int sum){\\n        this.a=a;\\n        this.b=b;\\n        this.sum=sum;\\n    }\\n\\n}\\nclass Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n       \\n        PriorityQueue<Pair> max = new PriorityQueue<>((x,y)->y.sum-x.sum);\\n// we can use only one custom class with Pq injava, x,y represent every new entry that has 3 sub fields \\n        for (int i = 0; i < bobValues.length; i++) {\\n            max.add(new Pair(aliceValues[i], bobValues[i], aliceValues[i]+bobValues[i]));\\n\\n        }\\n        int alicePoints = 0, bobPoints = 0, ans = 0;\\n        while (max.size() > 0) {\\n            alicePoints+=max.poll().a;\\n            if(max.size()>0)\\n            bobPoints+=max.poll().b;            \\n        }\\n        ans = (alicePoints > bobPoints) ? 1 : (alicePoints == bobPoints) ? 0 : -1;\\n        return ans;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954562,
                "title": "similar-to-two-city-scheduling",
                "content": "The question is slightly similar to the question [Two City Scheduling](https://leetcode.com/problems/two-city-scheduling/). \\n\\nWhen I started solving this question, I could recall that I had done something similar in another question. A little bit of seraching led me to find out Two City Scheduling. There also, we are checking what is the gain of sending a person to city A over city B. Here also, we are checking what is gain of choosing a stone for Alice (which is Alice\\'s value + Bob\\'s value).",
                "solutionTags": [],
                "code": "The question is slightly similar to the question [Two City Scheduling](https://leetcode.com/problems/two-city-scheduling/). \\n\\nWhen I started solving this question, I could recall that I had done something similar in another question. A little bit of seraching led me to find out Two City Scheduling. There also, we are checking what is the gain of sending a person to city A over city B. Here also, we are checking what is gain of choosing a stone for Alice (which is Alice\\'s value + Bob\\'s value).",
                "codeTag": "Unknown"
            },
            {
                "id": 1946363,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        int n=aliceValues.size();\\n        \\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> temp(3);\\n            temp[0]=aliceValues[i]+bobValues[i];\\n            temp[1]=aliceValues[i];\\n            temp[2]=bobValues[i];\\n            \\n            v.push_back(temp);\\n        }\\n        sort(v.begin(),v.end());\\n        \\n        int alice=0,bob=0;\\n        \\n        for(int i=n-1;i>=0;i-=2)\\n        {\\n            alice+=v[i][1];\\n        }\\n        for(int i=n-2;i>=0;i-=2)\\n        {\\n            bob+=v[i][2];\\n        }\\n        \\n        if(alice>bob) return 1;\\n        if(alice<bob) return -1;\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        int n=aliceValues.size();\\n        \\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> temp(3);\\n            temp[0]=aliceValues[i]+bobValues[i];\\n            temp[1]=aliceValues[i];\\n            temp[2]=bobValues[i];\\n            \\n            v.push_back(temp);\\n        }\\n        sort(v.begin(),v.end());\\n        \\n        int alice=0,bob=0;\\n        \\n        for(int i=n-1;i>=0;i-=2)\\n        {\\n            alice+=v[i][1];\\n        }\\n        for(int i=n-2;i>=0;i-=2)\\n        {\\n            bob+=v[i][2];\\n        }\\n        \\n        if(alice>bob) return 1;\\n        if(alice<bob) return -1;\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708811,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<pair<int,int>> v(n);\\n        for(int i=0; i<n; i++)\\n        {\\n            v[i] = {-A[i]-B[i], i};\\n        }\\n        sort(v.begin(), v.end());\\n        int f = 1;\\n        int a = 0, b = 0;\\n        for(auto it : v)\\n        {\\n            if(f%2)\\n            a += A[it.second];\\n            else\\n            b += B[it.second];\\n            f = 1 - f;\\n        }\\n        if(a>b)\\n        return 1;\\n        if(a == b)\\n        return 0;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<pair<int,int>> v(n);\\n        for(int i=0; i<n; i++)\\n        {\\n            v[i] = {-A[i]-B[i], i};\\n        }\\n        sort(v.begin(), v.end());\\n        int f = 1;\\n        int a = 0, b = 0;\\n        for(auto it : v)\\n        {\\n            if(f%2)\\n            a += A[it.second];\\n            else\\n            b += B[it.second];\\n            f = 1 - f;\\n        }\\n        if(a>b)\\n        return 1;\\n        if(a == b)\\n        return 0;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682719,
                "title": "oops-java-solution-priorityqueue-easy-hint",
                "content": "```\\nclass Solution {\\n    public static class Node{\\n        int val;\\n        int index;\\n        public Node(int val,int index){\\n            this.val=val;\\n            this.index=index;\\n        }\\n    }\\n    public int stoneGameVI(int[] aValues, int[] bValues) {\\n        int a = 0;\\n        int b =0;\\n        PriorityQueue<Node> pq = new PriorityQueue<>((ac,bc)-> bc.val-ac.val);\\n        for(int i=0;i<aValues.length;i++){\\n            Node newNode = new Node(aValues[i]+bValues[i],i);\\n            pq.add(newNode);\\n        }\\n        boolean flag = true;\\n        while(!pq.isEmpty()){\\n            Node newNode = pq.poll();\\n            if(flag){\\n                a+=aValues[newNode.index];\\n                flag = false;\\n            }else{\\n                flag = true;\\n                b+=bValues[newNode.index];\\n            }\\n        }\\n        if(b==a)\\n            return 0;\\n        if(a>b){\\n            return 1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public static class Node{\\n        int val;\\n        int index;\\n        public Node(int val,int index){\\n            this.val=val;\\n            this.index=index;\\n        }\\n    }\\n    public int stoneGameVI(int[] aValues, int[] bValues) {\\n        int a = 0;\\n        int b =0;\\n        PriorityQueue<Node> pq = new PriorityQueue<>((ac,bc)-> bc.val-ac.val);\\n        for(int i=0;i<aValues.length;i++){\\n            Node newNode = new Node(aValues[i]+bValues[i],i);\\n            pq.add(newNode);\\n        }\\n        boolean flag = true;\\n        while(!pq.isEmpty()){\\n            Node newNode = pq.poll();\\n            if(flag){\\n                a+=aValues[newNode.index];\\n                flag = false;\\n            }else{\\n                flag = true;\\n                b+=bValues[newNode.index];\\n            }\\n        }\\n        if(b==a)\\n            return 0;\\n        if(a>b){\\n            return 1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662101,
                "title": "very-easy-c-solution",
                "content": "We have to just sort the arrays in decreasing order of aliceValues[i]+bobValues[i], so I have made a vector of pair<int,int> which contains first value as aliceValues[i] and second value as bobValues[i], and sorted this vector on basis of decreasing order of aliceValues[i]+bobValues[i]. Then just add v[i].first to alice\\'s score when i%2==0 and add v[i].second to bob\\'s score when i%2==1.\\n```\\nclass Solution {\\npublic:\\n    static bool comp(pair<int,int> a,pair<int,int> b){\\n        return a.first+a.second>b.first+b.second;\\n    }\\n    int stoneGameVI(vector<int>& a, vector<int>& b) {\\n        vector<pair<int,int>> v;\\n        int i,j,k,n=a.size();\\n        for(i=0;i<n;i++){\\n            v.push_back({a[i],b[i]});\\n        }\\n        sort(v.begin(),v.end(),comp);\\n        int al=0,bb=0;\\n        for(i=0;i<n;i++){\\n            if(i%2==0)\\n                al+=v[i].first;\\n            else\\n                bb+=v[i].second;\\n        }\\n        if(al>bb)\\n            return 1;\\n        else if(al==bb)\\n            return 0;\\n        else\\n            return -1;\\n     }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(pair<int,int> a,pair<int,int> b){\\n        return a.first+a.second>b.first+b.second;\\n    }\\n    int stoneGameVI(vector<int>& a, vector<int>& b) {\\n        vector<pair<int,int>> v;\\n        int i,j,k,n=a.size();\\n        for(i=0;i<n;i++){\\n            v.push_back({a[i],b[i]});\\n        }\\n        sort(v.begin(),v.end(),comp);\\n        int al=0,bb=0;\\n        for(i=0;i<n;i++){\\n            if(i%2==0)\\n                al+=v[i].first;\\n            else\\n                bb+=v[i].second;\\n        }\\n        if(al>bb)\\n            return 1;\\n        else if(al==bb)\\n            return 0;\\n        else\\n            return -1;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411630,
                "title": "c-greedy-solution-using-priority-queue-o-nlogn",
                "content": "```\\nint stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) \\n{\\n\\tpriority_queue<array<int, 3>> pq;\\n\\n\\tfor(int i = 0; i < aliceValues.size(); ++i)\\n\\t{\\n\\t\\tpq.push({aliceValues[i] + bobValues[i], aliceValues[i], bobValues[i]});\\n\\t}\\n\\n\\tbool isAliceTurn = true;\\n\\tint aliceSum = 0, bobSum = 0;\\n\\n\\twhile(!pq.empty())\\n\\t{\\n\\t\\tauto [_, a, b] = pq.top();\\n\\t\\tpq.pop();\\n\\n\\t\\tif(isAliceTurn)\\n\\t\\t{\\n\\t\\t\\taliceSum += a;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tbobSum += b;\\n\\t\\t}\\n\\n\\t\\tisAliceTurn = !isAliceTurn;\\n\\t}\\n\\n\\treturn aliceSum > bobSum ? 1 : aliceSum < bobSum ? -1 : 0;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) \\n{\\n\\tpriority_queue<array<int, 3>> pq;\\n\\n\\tfor(int i = 0; i < aliceValues.size(); ++i)\\n\\t{\\n\\t\\tpq.push({aliceValues[i] + bobValues[i], aliceValues[i], bobValues[i]});\\n\\t}\\n\\n\\tbool isAliceTurn = true;\\n\\tint aliceSum = 0, bobSum = 0;\\n\\n\\twhile(!pq.empty())\\n\\t{\\n\\t\\tauto [_, a, b] = pq.top();\\n\\t\\tpq.pop();\\n\\n\\t\\tif(isAliceTurn)\\n\\t\\t{\\n\\t\\t\\taliceSum += a;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tbobSum += b;\\n\\t\\t}\\n\\n\\t\\tisAliceTurn = !isAliceTurn;\\n\\t}\\n\\n\\treturn aliceSum > bobSum ? 1 : aliceSum < bobSum ? -1 : 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1385886,
                "title": "c-priority-queue",
                "content": "```\\n int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>>pq;\\n        for(int i=0;i<aliceValues.size();i++){\\n            pq.push({aliceValues[i]+bobValues[i],{aliceValues[i],bobValues[i]}});\\n        }\\n        bool flag=true;\\n        int A=0,B=0;\\n        while(!pq.empty()){\\n            if(flag){\\n                A+=pq.top().second.first;\\n                pq.pop();\\n                flag=false;\\n            }else{\\n                B+=pq.top().second.second;\\n                pq.pop();\\n                flag=true;\\n            }\\n        }\\n        if(A==B)return 0;\\n        if(A>B)return 1;\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>>pq;\\n        for(int i=0;i<aliceValues.size();i++){\\n            pq.push({aliceValues[i]+bobValues[i],{aliceValues[i],bobValues[i]}});\\n        }\\n        bool flag=true;\\n        int A=0,B=0;\\n        while(!pq.empty()){\\n            if(flag){\\n                A+=pq.top().second.first;\\n                pq.pop();\\n                flag=false;\\n            }else{\\n                B+=pq.top().second.second;\\n                pq.pop();\\n                flag=true;\\n            }\\n        }\\n        if(A==B)return 0;\\n        if(A>B)return 1;\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1342882,
                "title": "easy-python-solution-faster-than-80",
                "content": "```\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n\\t#sort the values based on aliceValues[i]+bobValues[i]. \\n\\t#Alice or bob will choose in a way that will give them an advantage over their opponent.\\n        d=sorted(zip(aliceValues,bobValues),key=sum,reverse=True)\\n        alice=0\\n        bob=0\\n\\t\\t#simulate taking each turn. Alice goes first\\n        for i in range(len(d)):\\n            if i%2==0:\\n                alice+=d[i][0]\\n            else:\\n                bob+=d[i][1]\\n        if alice==bob:\\n            return 0\\n        elif alice>bob:\\n            return 1\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n\\t#sort the values based on aliceValues[i]+bobValues[i]. \\n\\t#Alice or bob will choose in a way that will give them an advantage over their opponent.\\n        d=sorted(zip(aliceValues,bobValues),key=sum,reverse=True)\\n        alice=0\\n        bob=0\\n\\t\\t#simulate taking each turn. Alice goes first\\n        for i in range(len(d)):\\n            if i%2==0:\\n                alice+=d[i][0]\\n            else:\\n                bob+=d[i][1]\\n        if alice==bob:\\n            return 0\\n        elif alice>bob:\\n            return 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270442,
                "title": "java-o-nlog-n-solution-with-explanation",
                "content": "Approach:\\n\\n1. Optimal move for playing this game is to select that index that either **increse your score** or **prevent opponent from increasing it\\'s own score**.\\n2. So in other words the max of **aliceValues[i] + bobValues[i]** is the most optimal move so that either of above condition can be met.\\n3. Below is implementation of the same.\\n```\\nclass Solution {\\n    public class Pair {\\n        int a,b;\\n        Pair() {\\n            a = b = 0;\\n        }\\n        Pair(int a,int b) {\\n            this.a = a;\\n            this.b = b;\\n        }\\n    }\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        int n = aliceValues.length;\\n        Pair[] pairs = new Pair[n];\\n        for (int i = 0; i < n; i++) {\\n            pairs[i] = new Pair(aliceValues[i],bobValues[i]);\\n        }\\n        Arrays.sort(pairs,new Comparator<Pair>() {\\n            public int compare(Pair p1,Pair p2) {\\n                return Integer.compare(p1.a + p1.b,p2.a + p2.b);\\n            }\\n        });\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        int turn = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (turn == 0) {\\n                sum1 += pairs[i].a;\\n            } else {\\n                sum2 += pairs[i].b;\\n            }\\n            turn = 1 - turn;\\n        }\\n        return Integer.compare(sum1,sum2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public class Pair {\\n        int a,b;\\n        Pair() {\\n            a = b = 0;\\n        }\\n        Pair(int a,int b) {\\n            this.a = a;\\n            this.b = b;\\n        }\\n    }\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        int n = aliceValues.length;\\n        Pair[] pairs = new Pair[n];\\n        for (int i = 0; i < n; i++) {\\n            pairs[i] = new Pair(aliceValues[i],bobValues[i]);\\n        }\\n        Arrays.sort(pairs,new Comparator<Pair>() {\\n            public int compare(Pair p1,Pair p2) {\\n                return Integer.compare(p1.a + p1.b,p2.a + p2.b);\\n            }\\n        });\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        int turn = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (turn == 0) {\\n                sum1 += pairs[i].a;\\n            } else {\\n                sum2 += pairs[i].b;\\n            }\\n            turn = 1 - turn;\\n        }\\n        return Integer.compare(sum1,sum2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1264281,
                "title": "python-greedy-with-thought-process",
                "content": "O(nlogn) time and O(n) space due to timsort in Python takes O(n) worst case and O(1) best case.\\nThe key observation is that the next optimal move would be the index where aliceValues[i]+bobValues[i] is maximum, because you want to pick the item whose value can maximize the gap between your score and your partner\\'s score.  For each stone with value a for Alice and b for Bob, if Alice takes it, her score +a, if Bob takes it, the value Alice loses would be -b, so the gap for each stone is a-(-b)=a+b. Our goal is to maximize the difference/gap, thus we pick the next available item with biggest (a+b) value.\\n\\nMy first attempt was to use two different priority queues to determine the next item to take = max(next biggest value for the current player, next  biggest value for the other), this failed when two inputs are [8,8,1],[7,8,1] , priority queue just gives one 8 without caring about first 8 or second 8 from Alice\\'s queue, but Alice particularly needs the 2nd 8, because it minimize opponent\\'s gain. When fixing this bug, I realized that the essence of this problem is to get the item that has the max(aliceValue+bobValue), which priority queue will never be able to deliver.\\n```\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        #strategy: greedy. key observation is to take the optimal = max(aliceValue[i]+bobValue[i])\\n        def greedy_aux_array_v0():\\n            optValues=sorted(((aliceValues[i]+bobValues[i],i) for i in range(len(aliceValues))),reverse=True) # sorted takes an iter/generator eg sorted(range(3))\\n            scores=[0,0] \\n            for i in range(len(aliceValues)):\\n                idx=optValues[i][1]\\n                scores[i%2]+=aliceValues[idx] if i%2==0 else bobValues[idx]\\n            return max(-1,min(1,scores[0]-scores[1]))\\n        #return greedy_aux_array_v0()\\n        \\n        def greedy_mutate_inplace_v1(): # if we are allowed to mutate input arrays , and if we do not want to bundle index into the sorted combined values\\n            ascore=-0\\n            for i in range(len(aliceValues)):\\n                aliceValues[i]+=bobValues[i]\\n                ascore-=bobValues[i]\\n            aliceValues.sort()\\n            for i in range(len(aliceValues)-1,-1,-2):  # only count Alice\\'s score as Bob automatically get the next optimal after each move of Alice\\n                ascore+=aliceValues[i] \\n            return max(-1,min(1,ascore))\\n        return greedy_mutate_inplace_v1()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        #strategy: greedy. key observation is to take the optimal = max(aliceValue[i]+bobValue[i])\\n        def greedy_aux_array_v0():\\n            optValues=sorted(((aliceValues[i]+bobValues[i],i) for i in range(len(aliceValues))),reverse=True) # sorted takes an iter/generator eg sorted(range(3))\\n            scores=[0,0] \\n            for i in range(len(aliceValues)):\\n                idx=optValues[i][1]\\n                scores[i%2]+=aliceValues[idx] if i%2==0 else bobValues[idx]\\n            return max(-1,min(1,scores[0]-scores[1]))\\n        #return greedy_aux_array_v0()\\n        \\n        def greedy_mutate_inplace_v1(): # if we are allowed to mutate input arrays , and if we do not want to bundle index into the sorted combined values\\n            ascore=-0\\n            for i in range(len(aliceValues)):\\n                aliceValues[i]+=bobValues[i]\\n                ascore-=bobValues[i]\\n            aliceValues.sort()\\n            for i in range(len(aliceValues)-1,-1,-2):  # only count Alice\\'s score as Bob automatically get the next optimal after each move of Alice\\n                ascore+=aliceValues[i] \\n            return max(-1,min(1,ascore))\\n        return greedy_mutate_inplace_v1()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122801,
                "title": "c-greedy-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        // A player\\'s optimal strategy is to: \\n        // 1) maximize the value from available stones of him/her own, AND\\n        // 2) minimize the value from available stones of the opponent.\\n        // To achieve the goal, we need to check the sum of aliceValues[i] + bobValues[i]\\n        // in each turn. We go through each index i and find out the max value of aliceValues[i]\\n        // + bobValues[i], and pick that index. We can use priority queue to sort the indices\\n        // based on the sum of the values first, and then play the game until the end.\\n        int size = aliceValues.size(), alice = 0, bob = 0;\\n        vector<int> indices(aliceValues.size());\\n        for (int i = 0; i < size; ++i)\\n        {\\n            indices[i] = i; // store all indices\\n        }\\n        \\n        sort(indices.begin(), indices.end(), [&](int i, int j) // sort indices based on sum of alice and bob\\'s value\\n             {\\n                 return aliceValues[i] + bobValues[i] > aliceValues[j] + bobValues[j];\\n             });\\n        \\n        for (int i = 0; i < size; i += 2)\\n        {\\n            alice += aliceValues[indices[i]]; // alice\\'s turn\\n            bob += i + 1 < size ? bobValues[indices[i + 1]] : 0; // bob\\'s turn\\n        }\\n        \\n        return alice < bob ? -1 : alice == bob ? 0 : 1; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        // A player\\'s optimal strategy is to: \\n        // 1) maximize the value from available stones of him/her own, AND\\n        // 2) minimize the value from available stones of the opponent.\\n        // To achieve the goal, we need to check the sum of aliceValues[i] + bobValues[i]\\n        // in each turn. We go through each index i and find out the max value of aliceValues[i]\\n        // + bobValues[i], and pick that index. We can use priority queue to sort the indices\\n        // based on the sum of the values first, and then play the game until the end.\\n        int size = aliceValues.size(), alice = 0, bob = 0;\\n        vector<int> indices(aliceValues.size());\\n        for (int i = 0; i < size; ++i)\\n        {\\n            indices[i] = i; // store all indices\\n        }\\n        \\n        sort(indices.begin(), indices.end(), [&](int i, int j) // sort indices based on sum of alice and bob\\'s value\\n             {\\n                 return aliceValues[i] + bobValues[i] > aliceValues[j] + bobValues[j];\\n             });\\n        \\n        for (int i = 0; i < size; i += 2)\\n        {\\n            alice += aliceValues[indices[i]]; // alice\\'s turn\\n            bob += i + 1 < size ? bobValues[indices[i + 1]] : 0; // bob\\'s turn\\n        }\\n        \\n        return alice < bob ? -1 : alice == bob ? 0 : 1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060582,
                "title": "c-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& v,vector<int>& p){\\n        int n=v.size();\\n        int sb=0;\\n        for(int i=0;i<n;i++){\\n            sb+=p[i];\\n            v[i]+=p[i];\\n        }\\n        sort(v.begin(),v.end());\\n        int x=0;\\n        for(int i=n-1;i>=0;i=i-2)x+=v[i];\\n        if(sb>x)return -1;\\n        else if(sb==x)return 0;\\n        return 1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int stoneGameVI(vector<int>& v,vector<int>& p){\\n        int n=v.size();\\n        int sb=0;\\n        for(int i=0;i<n;i++){\\n            sb+=p[i];\\n            v[i]+=p[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1058081,
                "title": "c-95-fast-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& a, vector<int>& b) {\\n        priority_queue<pair<int,pair<int,int>>>pq;\\n        int as=0,bs=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            pq.push(make_pair(a[i]+b[i],make_pair(a[i],b[i])));\\n        }\\n        int i=0;\\n        while(!pq.empty())\\n        {\\n            if(i%2==0)\\n            {\\n                as+=pq.top().second.first;\\n            }\\n            else\\n                bs+=pq.top().second.second;\\n            pq.pop();\\n            i++;\\n        }\\n        if(as>bs)\\n            return 1;\\n        else if(as<bs)\\n            return -1;\\n        return 0;\\n        \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& a, vector<int>& b) {\\n        priority_queue<pair<int,pair<int,int>>>pq;\\n        int as=0,bs=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            pq.push(make_pair(a[i]+b[i],make_pair(a[i],b[i])));\\n        }\\n        int i=0;\\n        while(!pq.empty())\\n        {\\n            if(i%2==0)\\n            {\\n                as+=pq.top().second.first;\\n            }\\n            else\\n                bs+=pq.top().second.second;\\n            pq.pop();\\n            i++;\\n        }\\n        if(as>bs)\\n            return 1;\\n        else if(as<bs)\\n            return -1;\\n        return 0;\\n        \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1047774,
                "title": "python-greedy-solution",
                "content": "```\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        sum_alice_bob = [[aliceValues[i] + bobValues[i], i] for i in range(len(bobValues))]\\n        sum_alice_bob.sort(key = lambda x:x[0], reverse=True)\\n        sum_alice_bob_ind = [x[1] for x in sum_alice_bob]\\n        total_value_alice = sum(aliceValues[i] for i in sum_alice_bob_ind[0:len(bobValues):2])\\n        total_value_bob = sum(bobValues[i] for i in sum_alice_bob_ind[1:len(bobValues):2])\\n        if total_value_alice < total_value_bob:\\n            return -1\\n        if total_value_alice > total_value_bob:\\n            return 1\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        sum_alice_bob = [[aliceValues[i] + bobValues[i], i] for i in range(len(bobValues))]\\n        sum_alice_bob.sort(key = lambda x:x[0], reverse=True)\\n        sum_alice_bob_ind = [x[1] for x in sum_alice_bob]\\n        total_value_alice = sum(aliceValues[i] for i in sum_alice_bob_ind[0:len(bobValues):2])\\n        total_value_bob = sum(bobValues[i] for i in sum_alice_bob_ind[1:len(bobValues):2])\\n        if total_value_alice < total_value_bob:\\n            return -1\\n        if total_value_alice > total_value_bob:\\n            return 1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1007831,
                "title": "sorting-based-solution-with-c",
                "content": "Inspired by [lee\\'s solution](https://leetcode.com/problems/stone-game-vi/discuss/969574/JavaC%2B%2BPython-Sort-by-Value-Sum)\\n\\n## Algorithm\\nWe play the game a little backwards.\\n1. Assume that bob has taken all the tiles at once. So bobs points is `Sum(bobValues)`\\n2. Now, alice has `size/2` moves to play. Which stone she should pick? She should pick the one which\\n\\t* Maximizes her point\\n\\t* Minimizes bobs\\'s point\\n\\nIn other words, should should pick the i such that `aliceValues[i] + bobValues[i]` is maximum.\\nAs they will play optimally, alice can\\'t take all the max values, she will take even numbered index to accomodate bob\\'s optimum game.\\nIf, after taking `size/2` values, alice should win if her taken values sum are greater than bob.\\n\\nWe can track this sum by taking a difference variable. \\nFirst, `diff = -Sum(bobValues)`\\nThen, whenever index i is taken, diff is incremented `by aliceValues[i] + bobValues[i]`\\nif `diff > 0`, alice has won.\\n\\n__Exmple__\\n```\\naliceValues = [2,4,3]\\nbobValues = [1,6,7]\\n```\\n\\ninitially, bob gain points = `1 + 6 +7 = 14`\\ndiff `= -14`\\nnow, alice has available options `= 1+2, 4+6, 3+7 = 3, 10, 10`\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t`= 10, 10, 3` (after sorting)\\n\\nSo, alice can take 10 and 3, makeing the differnce `= -14 + 13 = -1`, so she losts.\\nTaking first 10 = taking index 2 (or 3, same)\\nTaking second 1 = taking index 0\\n\\n**Code**\\n```\\nint stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n\\tint diff = 0, n = aliceValues.size();\\n\\n\\tfor(int i=0; i<n; i++) {\\n\\t\\taliceValues[i] += bobValues[i];\\n\\t\\tdiff -= bobValues[i];\\n\\t}\\n\\n\\tsort(aliceValues.begin(), aliceValues.end());\\n\\n\\tfor(int i=n-1; i >= 0; i -= 2) {\\n\\t\\tdiff += aliceValues[i];\\n\\t}\\n\\n\\tif (diff == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\treturn diff < 0 ? -1 : 1;\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\naliceValues = [2,4,3]\\nbobValues = [1,6,7]\\n```\n```\\nint stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n\\tint diff = 0, n = aliceValues.size();\\n\\n\\tfor(int i=0; i<n; i++) {\\n\\t\\taliceValues[i] += bobValues[i];\\n\\t\\tdiff -= bobValues[i];\\n\\t}\\n\\n\\tsort(aliceValues.begin(), aliceValues.end());\\n\\n\\tfor(int i=n-1; i >= 0; i -= 2) {\\n\\t\\tdiff += aliceValues[i];\\n\\t}\\n\\n\\tif (diff == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\treturn diff < 0 ? -1 : 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1005346,
                "title": "alice-and-bob-need-another-hobby",
                "content": "```\\nclass Solution {\\n    public int stoneGameVI(int[] a, int[] b) {\\n        int[][] value = new int[a.length][2];\\n        for (int i = 0; i < a.length; i++)\\n        {\\n            value[i][0] = i;\\n            value[i][1] = a[i] + b[i];\\n        }\\n        Arrays.sort(value, (x, y) -> {return x[1] - y[1];});\\n        int sum = 0;\\n        boolean alice = true;\\n        for (int i = a.length-1; i >= 0; i--)\\n        {\\n            if (alice)\\n            {\\n                sum += a[value[i][0]];\\n                alice = false;\\n            }\\n            else\\n            {\\n                sum -= b[value[i][0]];\\n                alice = true;\\n            }\\n        }\\n        return (sum > 0) ? 1 : (sum < 0) ? -1 : 0;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int stoneGameVI(int[] a, int[] b) {\\n        int[][] value = new int[a.length][2];\\n        for (int i = 0; i < a.length; i++)\\n        {\\n            value[i][0] = i;\\n            value[i][1] = a[i] + b[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 987626,
                "title": "java-time-o-nlogn-space-o-1-15-ms-solution",
                "content": "I though I was wrong and there was test gap, but just realized it doesn\\'t matter what Bob\\'s value is.\\n\\nThe solution still uses  sort of sum. But the diff is simply sum of Alice\\'s picked sum minus all Bob\\'s values. It will reduce the space cost to O(1).\\n```\\nclass Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n\\t\\tint diff=0;\\n        for(int i=0;i<aliceValues.length;i++) {\\n            aliceValues[i]=-(aliceValues[i]+bobValues[i]);\\n\\t\\t\\tdiff-=bobValues[i];\\n        }\\n        Arrays.sort(aliceValues);\\n        for(int i=0;i<aliceValues.length;i+=2) {\\n            diff-=aliceValues[i];\\n        }\\n        if(diff>0) return 1;\\n        if(diff<0) return -1;\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n\\t\\tint diff=0;\\n        for(int i=0;i<aliceValues.length;i++) {\\n            aliceValues[i]=-(aliceValues[i]+bobValues[i]);\\n\\t\\t\\tdiff-=bobValues[i];\\n        }\\n        Arrays.sort(aliceValues);\\n        for(int i=0;i<aliceValues.length;i+=2) {\\n            diff-=aliceValues[i];\\n        }\\n        if(diff>0) return 1;\\n        if(diff<0) return -1;\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 970006,
                "title": "normal-implementation-using-pq-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        \\n        \\n       // vector<int> num(aliceValues.size(),0);\\n        int n = aliceValues.size();\\n        priority_queue<pair<int,int>> pq;\\n        for(int i =0; i<n; i++){\\n            \\n            //num[i] = min(aliceValues[i],bobValues[i]);\\n            pq.push(make_pair(aliceValues[i]+bobValues[i],i));\\n            \\n        }\\n        int alice_sum =0;\\n        int bob_sum =0;\\n        int cnt =0;\\n        while(!pq.empty()){\\n            auto i = pq.top();\\n            pq.pop();\\n            if(cnt%2==0){\\n                alice_sum+=aliceValues[i.second];\\n            }\\n            \\n            else {\\n                \\n                bob_sum+=bobValues[i.second];\\n            }\\n            \\n            cnt++;\\n            \\n            \\n        }\\n        \\n        if(alice_sum>bob_sum){\\n            return 1;\\n        }\\n        else if(alice_sum==bob_sum){\\n            return 0;\\n        }\\n        else return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        \\n        \\n       // vector<int> num(aliceValues.size(),0);\\n        int n = aliceValues.size();\\n        priority_queue<pair<int,int>> pq;\\n        for(int i =0; i<n; i++){\\n            \\n            //num[i] = min(aliceValues[i],bobValues[i]);\\n            pq.push(make_pair(aliceValues[i]+bobValues[i],i));\\n            \\n        }\\n        int alice_sum =0;\\n        int bob_sum =0;\\n        int cnt =0;\\n        while(!pq.empty()){\\n            auto i = pq.top();\\n            pq.pop();\\n            if(cnt%2==0){\\n                alice_sum+=aliceValues[i.second];\\n            }\\n            \\n            else {\\n                \\n                bob_sum+=bobValues[i.second];\\n            }\\n            \\n            cnt++;\\n            \\n            \\n        }\\n        \\n        if(alice_sum>bob_sum){\\n            return 1;\\n        }\\n        else if(alice_sum==bob_sum){\\n            return 0;\\n        }\\n        else return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 969751,
                "title": "javascript-sort-by-significance-of-stones",
                "content": "inspired by [@dettier](https://leetcode.com/dettier/)\\'s solution\\n```\\n/**\\n * @param {number[]} aliceValues\\n * @param {number[]} bobValues\\n * @return {number}\\n */\\nvar stoneGameVI = function(aliceValues, bobValues) {\\n  const scores = [0, 0];\\n  let turn = 0;\\n  const N = bobValues.length;\\n  \\n  // Building a game, i.e sequence of turns based on optimal tactics\\n  // Optimal tactics is to take a stone which makes the most impact \\n  // if we have pairs [2, 4] and [5, 4], we have to take 4, just because it\\'s not only add 4 points to us, \\n  // it also takes away the opportunity to gain 4 points from our opponent\\n  // And since Alice and Bob make moves after each other one by one and always pull a \\n  // most significant stone, our tactics sequence would be presented as an array of\\n  // elemets with alice\\'s score, bob\\'s score and total impact of stone, sorted in decreasing order of total impact\\n  const tactics = aliceValues.reduce((acc, v, i) => {\\n    acc.push({\\n      0: v,\\n      1: bobValues[i],\\n      s: v + bobValues[i],\\n    })\\n    return acc;\\n  }, []).sort((a, b) => b.s - a.s);\\n  \\n  for (let i = 0; i < N; i++) {\\n    scores[turn] += tactics[i][turn];\\n    turn ^= 1;\\n  }\\n  \\n  return scores[0] > scores[1] ? 1 : (scores[0] < scores[1] ? -1 : 0);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} aliceValues\\n * @param {number[]} bobValues\\n * @return {number}\\n */\\nvar stoneGameVI = function(aliceValues, bobValues) {\\n  const scores = [0, 0];\\n  let turn = 0;\\n  const N = bobValues.length;\\n  \\n  // Building a game, i.e sequence of turns based on optimal tactics\\n  // Optimal tactics is to take a stone which makes the most impact \\n  // if we have pairs [2, 4] and [5, 4], we have to take 4, just because it\\'s not only add 4 points to us, \\n  // it also takes away the opportunity to gain 4 points from our opponent\\n  // And since Alice and Bob make moves after each other one by one and always pull a \\n  // most significant stone, our tactics sequence would be presented as an array of\\n  // elemets with alice\\'s score, bob\\'s score and total impact of stone, sorted in decreasing order of total impact\\n  const tactics = aliceValues.reduce((acc, v, i) => {\\n    acc.push({\\n      0: v,\\n      1: bobValues[i],\\n      s: v + bobValues[i],\\n    })\\n    return acc;\\n  }, []).sort((a, b) => b.s - a.s);\\n  \\n  for (let i = 0; i < N; i++) {\\n    scores[turn] += tactics[i][turn];\\n    turn ^= 1;\\n  }\\n  \\n  return scores[0] > scores[1] ? 1 : (scores[0] < scores[1] ? -1 : 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 969738,
                "title": "solution-using-sorting-with-detailed-comments",
                "content": "```\\n  // Complexity: Linearithmic in the length of aliceValues\\n  int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n    vector<int> stones;\\n    int score = 0, n = aliceValues.size();\\n    for (int i = 0; i < n; i++) stones.push_back(i);\\n    \\n    // Sort stones in descending order of the sum of evaluations of Alice and \\n    // Bob. We are doing this because the real value of a stone is the sum\\n    // of its value for Alice and its value for Bob. If Alice takes stone S,\\n    // she does not only gain her valuation of it, but she also hinders Bob from\\n    // gaining his valuation of S.\\n    sort(begin(stones), end(stones), [&aliceValues, &bobValues](int i, int j){\\n      return aliceValues[i] + bobValues[i] > aliceValues[j] + bobValues[j];\\n    });\\n    \\n    // Alice makes the first move thus she is the even positions.\\n    for (int i = 0; i < n; i++) {\\n      if (i & 1) score -= bobValues[stones[i]];\\n      else score += aliceValues[stones[i]];\\n    }\\n    return score != 0? score > 0? 1 : -1 : 0;\\n  }\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n  // Complexity: Linearithmic in the length of aliceValues\\n  int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n    vector<int> stones;\\n    int score = 0, n = aliceValues.size();\\n    for (int i = 0; i < n; i++) stones.push_back(i);\\n    \\n    // Sort stones in descending order of the sum of evaluations of Alice and \\n    // Bob. We are doing this because the real value of a stone is the sum\\n    // of its value for Alice and its value for Bob. If Alice takes stone S,\\n    // she does not only gain her valuation of it, but she also hinders Bob from\\n    // gaining his valuation of S.\\n    sort(begin(stones), end(stones), [&aliceValues, &bobValues](int i, int j){\\n      return aliceValues[i] + bobValues[i] > aliceValues[j] + bobValues[j];\\n    });\\n    \\n    // Alice makes the first move thus she is the even positions.\\n    for (int i = 0; i < n; i++) {\\n      if (i & 1) score -= bobValues[stones[i]];\\n      else score += aliceValues[stones[i]];\\n    }\\n    return score != 0? score > 0? 1 : -1 : 0;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 969716,
                "title": "java-beats-100-o-nlogn-with-explanation",
                "content": "**Using Array**:\\n```\\nclass Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        int[][] stones = new int[aliceValues.length][];\\n        for(int i = 0; i < aliceValues.length; i++) {\\n            stones[i] = new int[]{aliceValues[i], bobValues[i]};\\n        }\\n        Arrays.sort(stones, (s1, s2) -> s2[0] + s2[1] - s1[0] - s1[1]);\\n        // sort each stone in decreasing on the basis of it\\'s worth\\n        // each player will remove a stone which helps them score more for themselves\\n        // as well as prevents the other player from scoring more\\n        // so a stone with a larger total value (i.e. value for alice + value for bob) is more worthy\\n        // and thus will be removed first\\n        \\n        int ac = 0, bc = 0, i = 0;\\n        boolean aliceTurn = true;\\n        while(i < stones.length) {\\n            if(aliceTurn) ac += stones[i++][0];\\n            else bc += stones[i++][1];\\n            aliceTurn = !aliceTurn;\\n        }\\n        \\n        return Integer.compare(ac, bc);\\n    }\\n}\\n```\\n\\n**Using Priority Queue**:\\n```\\nclass Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        PriorityQueue<Stone> q = new PriorityQueue<Stone>((a, b) -> b.alice + b.bob - a.alice - a.bob);\\n        // sort each stone in decreasing on the basis of it\\'s worth\\n        // each player will remove a stone which helps them score more for themselves\\n        // as well as prevents the other player from scoring more\\n        // so a stone with a larger total value (i.e. value for alice + value for bob) is more worthy\\n        // and thus will be removed first\\n        \\n        for(int i = 0; i < aliceValues.length; i++) {\\n            q.add(new Stone(aliceValues[i], bobValues[i]));\\n        }\\n        \\n        int ac = 0, bc = 0;\\n        boolean aliceTurn = true;\\n        while(!q.isEmpty()) {\\n            if(aliceTurn) ac += q.poll().alice;\\n            else bc += q.poll().bob;\\n            aliceTurn = !aliceTurn;\\n        }\\n        \\n        return Integer.compare(ac, bc);\\n    }\\n    \\n    private static class Stone {\\n        int alice, bob;\\n        \\n        Stone(int a, int b) {\\n            alice = a;\\n            bob = b;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        int[][] stones = new int[aliceValues.length][];\\n        for(int i = 0; i < aliceValues.length; i++) {\\n            stones[i] = new int[]{aliceValues[i], bobValues[i]};\\n        }\\n        Arrays.sort(stones, (s1, s2) -> s2[0] + s2[1] - s1[0] - s1[1]);\\n        // sort each stone in decreasing on the basis of it\\'s worth\\n        // each player will remove a stone which helps them score more for themselves\\n        // as well as prevents the other player from scoring more\\n        // so a stone with a larger total value (i.e. value for alice + value for bob) is more worthy\\n        // and thus will be removed first\\n        \\n        int ac = 0, bc = 0, i = 0;\\n        boolean aliceTurn = true;\\n        while(i < stones.length) {\\n            if(aliceTurn) ac += stones[i++][0];\\n            else bc += stones[i++][1];\\n            aliceTurn = !aliceTurn;\\n        }\\n        \\n        return Integer.compare(ac, bc);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        PriorityQueue<Stone> q = new PriorityQueue<Stone>((a, b) -> b.alice + b.bob - a.alice - a.bob);\\n        // sort each stone in decreasing on the basis of it\\'s worth\\n        // each player will remove a stone which helps them score more for themselves\\n        // as well as prevents the other player from scoring more\\n        // so a stone with a larger total value (i.e. value for alice + value for bob) is more worthy\\n        // and thus will be removed first\\n        \\n        for(int i = 0; i < aliceValues.length; i++) {\\n            q.add(new Stone(aliceValues[i], bobValues[i]));\\n        }\\n        \\n        int ac = 0, bc = 0;\\n        boolean aliceTurn = true;\\n        while(!q.isEmpty()) {\\n            if(aliceTurn) ac += q.poll().alice;\\n            else bc += q.poll().bob;\\n            aliceTurn = !aliceTurn;\\n        }\\n        \\n        return Integer.compare(ac, bc);\\n    }\\n    \\n    private static class Stone {\\n        int alice, bob;\\n        \\n        Stone(int a, int b) {\\n            alice = a;\\n            bob = b;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 969694,
                "title": "c-faster-than-100-00-o-n-log-n-vector-based-implementation",
                "content": "The optimal strategy is to pick up the next element at index i, where the aliceValues[i]+bobValues[i] is the maximum.\\n\\nGreedy solution follows.\\n\\n```\\nclass Solution {\\npublic:\\n  \\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n       \\n        const auto N = aliceValues.size();\\n        \\n        struct st { int score; int index; };\\n        vector<st> v(N, {0,0});\\n       \\n        for(int i = 0; i < N; ++i)\\n        {\\n            v[i] = {aliceValues[i] + bobValues[i], i};\\n        }\\n        \\n        sort(v.begin(), v.end(), [](auto &left, auto &right){\\n            return left.score > right.score;\\n        });\\n        \\n        int ar = 0;\\n        int br = 0;\\n        for(int i = 0; i < N; ++i)\\n        {\\n            if(i % 2)\\n                br += bobValues[v[i].index];\\n            else\\n                ar += aliceValues[v[i].index];\\n        }\\n        \\n        if(ar > br)\\n            return 1;\\n        \\n        if(ar < br)\\n            return -1;\\n        \\n        return 0;\\n    }\\n};\\n```\\n\\nUpvote if you find my post helpful, please.\\n\\nCheers",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n       \\n        const auto N = aliceValues.size();\\n        \\n        struct st { int score; int index; };\\n        vector<st> v(N, {0,0});\\n       \\n        for(int i = 0; i < N; ++i)\\n        {\\n            v[i] = {aliceValues[i] + bobValues[i], i};\\n        }\\n        \\n        sort(v.begin(), v.end(), [](auto &left, auto &right){\\n            return left.score > right.score;\\n        });\\n        \\n        int ar = 0;\\n        int br = 0;\\n        for(int i = 0; i < N; ++i)\\n        {\\n            if(i % 2)\\n                br += bobValues[v[i].index];\\n            else\\n                ar += aliceValues[v[i].index];\\n        }\\n        \\n        if(ar > br)\\n            return 1;\\n        \\n        if(ar < br)\\n            return -1;\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 969688,
                "title": "python-easy-solution-code-commented",
                "content": "The explanation is in the code as comments:\\n```\\nimport numpy\\n\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        \"\"\" \\n        Idea: for each stone, its actual value is given by the sum of Alice\\'s and Bob\\'s value \\n        for that stone. In fact, each stone eventually goes to either Alice and Bob. When you pick\\n        a stone, not only you get its value, but also you prevent the enemy from taking it, hence\\n        it\\'s like if you penalize the enemy (still a positive variation for you!).\\n        \"\"\"\\n        \\n        # The optimal order of choice is invariant for Alice and Bob. Hence, once you have\\n        # sorted the items by (aliceValue + bobValue), Alice will always pick the 0th, Bob the 1st,\\n        # Alice the 2nd, Bob the 3rd, ...\\n        # In other words, Alice will pick the even-indexed stones, Bob the odd-indexed ones.\\n        choice_idx = numpy.argsort([-(a+b) for (a,b) in zip(aliceValues, bobValues)])\\n        \\n        # Compute the cumulative values for Bob and Alice, respectively\\n        al_sum = sum(aliceValues[choice_idx[i]] for i in range(0,len(choice_idx),2))\\n        bob_sum = sum(bobValues[choice_idx[i]] for i in range(1,len(choice_idx),2))\\n\\n        return numpy.sign(al_sum - bob_sum)\\n```",
                "solutionTags": [],
                "code": "```\\nimport numpy\\n\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        \"\"\" \\n        Idea: for each stone, its actual value is given by the sum of Alice\\'s and Bob\\'s value \\n        for that stone. In fact, each stone eventually goes to either Alice and Bob. When you pick\\n        a stone, not only you get its value, but also you prevent the enemy from taking it, hence\\n        it\\'s like if you penalize the enemy (still a positive variation for you!).\\n        \"\"\"\\n        \\n        # The optimal order of choice is invariant for Alice and Bob. Hence, once you have\\n        # sorted the items by (aliceValue + bobValue), Alice will always pick the 0th, Bob the 1st,\\n        # Alice the 2nd, Bob the 3rd, ...\\n        # In other words, Alice will pick the even-indexed stones, Bob the odd-indexed ones.\\n        choice_idx = numpy.argsort([-(a+b) for (a,b) in zip(aliceValues, bobValues)])\\n        \\n        # Compute the cumulative values for Bob and Alice, respectively\\n        al_sum = sum(aliceValues[choice_idx[i]] for i in range(0,len(choice_idx),2))\\n        bob_sum = sum(bobValues[choice_idx[i]] for i in range(1,len(choice_idx),2))\\n\\n        return numpy.sign(al_sum - bob_sum)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 969622,
                "title": "python-just-sort",
                "content": "The key of the greedy is to pick max(aliceValues[i]+bobValues[i])\\nto prove this:\\na[i] b[i] a[j] b[j]\\nso two ways:\\na[i] vs b[j] or a[j] vs b[i]\\ndifference is (a[i]-b[j]) - (a[j] - b[i]) = (a[i]+b[i])-(a[j]+b[j])\\ntherefore Alice neeed to pick max(aliceValues[i]+bobValues[i])\\ncode is very easy \\n\\t\\ta=b=0\\n        for i in range(len(aliceValues)):\\n            v.append((aliceValues[i]+bobValues[i],i))\\n        v.sort(reverse=True)\\n        for i in range(len(aliceValues)):\\n            ii=v[i][1]\\n            if i%2==0:\\n                a+=aliceValues[ii]\\n            else:\\n                b+=bobValues[ii]\\n        if a>b:\\n            return 1\\n        elif a==b:\\n            return 0\\n        else:\\n            return -1",
                "solutionTags": [],
                "code": "The key of the greedy is to pick max(aliceValues[i]+bobValues[i])\\nto prove this:\\na[i] b[i] a[j] b[j]\\nso two ways:\\na[i] vs b[j] or a[j] vs b[i]\\ndifference is (a[i]-b[j]) - (a[j] - b[i]) = (a[i]+b[i])-(a[j]+b[j])\\ntherefore Alice neeed to pick max(aliceValues[i]+bobValues[i])\\ncode is very easy \\n\\t\\ta=b=0\\n        for i in range(len(aliceValues)):\\n            v.append((aliceValues[i]+bobValues[i],i))\\n        v.sort(reverse=True)\\n        for i in range(len(aliceValues)):\\n            ii=v[i][1]\\n            if i%2==0:\\n                a+=aliceValues[ii]\\n            else:\\n                b+=bobValues[ii]\\n        if a>b:\\n            return 1\\n        elif a==b:\\n            return 0\\n        else:\\n            return -1",
                "codeTag": "Unknown"
            },
            {
                "id": 4070298,
                "title": "greedy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        #Alice wants the most, she get and the least bob gets\\n\\n        Values = [(aliceValues[i] + bobValues[i], i) for i in range(len(aliceValues))]\\n        Values.sort(key = lambda x: x[0])\\n        AliceScore = 0\\n        BobScore = 0\\n        AliceTurn = True\\n        while Values:\\n            curr = Values.pop()\\n            if AliceTurn:\\n                AliceScore += aliceValues[curr[1]]\\n                AliceTurn = False\\n            else:\\n                BobScore += bobValues[curr[1]]\\n                AliceTurn = True\\n            \\n        if AliceScore == BobScore:\\n            return 0\\n        elif AliceScore > BobScore:\\n            return 1\\n        else:\\n            return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        #Alice wants the most, she get and the least bob gets\\n\\n        Values = [(aliceValues[i] + bobValues[i], i) for i in range(len(aliceValues))]\\n        Values.sort(key = lambda x: x[0])\\n        AliceScore = 0\\n        BobScore = 0\\n        AliceTurn = True\\n        while Values:\\n            curr = Values.pop()\\n            if AliceTurn:\\n                AliceScore += aliceValues[curr[1]]\\n                AliceTurn = False\\n            else:\\n                BobScore += bobValues[curr[1]]\\n                AliceTurn = True\\n            \\n        if AliceScore == BobScore:\\n            return 0\\n        elif AliceScore > BobScore:\\n            return 1\\n        else:\\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047070,
                "title": "c-optimal-way-to-play-this-game-is-to-sum-both-points-and-take-maximum-greedily",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& a, vector<int>& b) {\\n        int n = a.size();\\n        vector<pair<int, int>> v;\\n\\n        for (int i = 0; i < n; i++) {\\n            v.push_back({a[i] + b[i], i});\\n        }\\n        sort(v.rbegin(), v.rend());\\n        int bob = 0, alice = 0;\\n        for (int i = 0; i < n; i++) {\\n            int idx = v[i].second;\\n            if (i % 2) {\\n                bob += b[idx];\\n            } else {\\n                alice += a[idx];\\n            }\\n        }\\n\\n        if (bob == alice) return 0;\\n        return alice > bob ? 1 : -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& a, vector<int>& b) {\\n        int n = a.size();\\n        vector<pair<int, int>> v;\\n\\n        for (int i = 0; i < n; i++) {\\n            v.push_back({a[i] + b[i], i});\\n        }\\n        sort(v.rbegin(), v.rend());\\n        int bob = 0, alice = 0;\\n        for (int i = 0; i < n; i++) {\\n            int idx = v[i].second;\\n            if (i % 2) {\\n                bob += b[idx];\\n            } else {\\n                alice += a[idx];\\n            }\\n        }\\n\\n        if (bob == alice) return 0;\\n        return alice > bob ? 1 : -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045896,
                "title": "5-line-python-solution-beat-88-runtime",
                "content": "# Code\\n```\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        combinedArr = sorted(zip(aliceValues, bobValues), key = lambda x: -(x[0]+x[1]))\\n        alice = sum(aliceValues for aliceValues, bobValues in combinedArr[::2])\\n        bob = sum(bobValues for aliceValues, bobValues in combinedArr[1::2])\\n        if alice < bob: return -1\\n        return 0 if alice == bob else 1\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        combinedArr = sorted(zip(aliceValues, bobValues), key = lambda x: -(x[0]+x[1]))\\n        alice = sum(aliceValues for aliceValues, bobValues in combinedArr[::2])\\n        bob = sum(bobValues for aliceValues, bobValues in combinedArr[1::2])\\n        if alice < bob: return -1\\n        return 0 if alice == bob else 1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000124,
                "title": "python-sort-by-alicevalues-i-bobvalues-i",
                "content": "As the problem statement says, Alice and Bob both will play optimally and they both know what is the value of stone for other person.\\n\\nNow, think about it. \\n\\nInitially, we may think that the best option is for each to choose the stone that gives them the maximum points, right?\\n\\nBut, will this strategy work for all the cases?\\n\\n\\tLet\\'s take an example => aliceValues = [1,5] and bobValues = [7,1]\\n\\t\\n\\tLet\\'s go by the strategy of removing maximum valued stone.\\n\\t\\n\\tSince Alice plays first, she will choose the stone at index 1 with value \"5\"\\n\\tSo, alice\\'s points = 5\\n\\t\\n\\tIn next move, Bob will remove the stone at index 0 with value \"7\"\\n\\tSo, bob\\'s points = 7\\n\\t\\n\\tSo going by this strategy, Alice lost!\\n\\t\\nNow, think about some other strategy by which Alice may win or at least the game ends in a draw. \\n\\nThere is a reason why this problem says \"**Both players know the other\\'s values.**\"\\n\\nI mean, if I am playing this game then my thinking would be to remove a stone such that not only I get some points, but it also removes the stone that my opposition might remove in next round.\\n\\nAnd well, that\\'s the most optimal strategy.\\n\\n\\tThis means, when choosing a stone to remove\\n\\tWe should not just consider our profit\\n\\tBut also consider the loss of the opposition\\n\\t\\n\\tWe want to maximize these two values together\\n\\tWe want to increase our profit and also increase the loss of opposition\\n\\tAnd this sum of (profit + loss) should be maximum\\n\\t\\n\\tComing back to the example -> [1,5] and [7,1]\\n\\t\\n\\tAlice should remove stone at index 0 initially because doing that mean - \\n\\t\\n\\t\\tAlice gets profit of 1 point\\n\\t\\tBob loses 7 points\\n\\t\\t\\n\\t\\tSo, total 1 + 7 => 8\\n\\t\\t\\n\\tAnd this is the maximum sum value in this list and so stone at index 0 must be removed first\\n\\t\\n\\tSo, Alice removes the stone at index 0 and gets 1 point\\n\\tNow, bob removes stone at index 1 and gets 1 point as wel\\n\\t\\n\\t\\n\\tAnd so, the game ends in a draw, instead of Alice losing.\\n\\nHence, what we understood is that we need to order the stones by the sum of aliceValues[i] + bobValues[i] for each stone i.\\n\\nAnd so, we will sort the stones accordingly.\\n\\n# **SORTING APPROACH**\\n\\n```\\ndef stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        # How many stones\\n        n = len(aliceValues)\\n        \\n        # Let\\'s combine the values in a single list with each index having a pair\\n        # Each pair will be like this => (value of stone as per alice, value of stone as per bob)\\n        values = [(aliceValues[i], bobValues[i]) for i in range(n)]\\n        \\n        # We will sort by the sum of aliceValues and bobvalues for each stone\\n        values.sort(key = lambda x: x[0] + x[1])\\n        \\n        # Now, we can start playing the same\\n        aliceScore, bobScore = 0,0\\n        \\n        # To keep track of whose turn it is\\n        i = 0\\n        \\n        # While the values list is not empty\\n        while values:\\n            \\n            # Most optimal pair in the values list is the last pair\\n            pair = values.pop()\\n            \\n            # Since alice starts first, each even index \"i\" represents Alice\\'s turn\\n            if i % 2 == 0: aliceScore += pair[0]\\n            else: bobScore += pair[1]\\n                \\n            # Increment i\\n            i += 1\\n        \\n        # Now, return the output based on the scores\\n        # If both have same score, return 0\\n        if aliceScore == bobScore: return 0\\n        \\n        # If alice has a higher score than bob, return 1\\n        elif aliceScore > bobScore: return 1\\n        \\n        # Otherwise, return -1\\n        return -1\\n```\\n\\n# **USING A MAXHEAP**\\n\\n```\\ndef stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        # How many stones\\n        n = len(aliceValues)\\n        \\n        # Instead of creating a list and then sorting it, we can use a maxHeap here\\n        maxHeap = []\\n        for i in range(n):heappush(maxHeap, (-(aliceValues[i] + bobValues[i]), i ))\\n        \\n        # Now, we can start playing the same\\n        aliceScore, bobScore = 0,0\\n        \\n        # To keep track of whose turn it is\\n        i = 0\\n        \\n        # While the maxHeap is not empty\\n        while maxHeap:\\n            \\n            # Most optimal stone index is on top of the maxHeap\\n            stoneIdx = heappop(maxHeap)[1]\\n            \\n            # Since alice starts first, each even value \"i\" represents Alice\\'s turn\\n            if i % 2 == 0: aliceScore += aliceValues[stoneIdx]\\n            else: bobScore += bobValues[stoneIdx]\\n                \\n            # Increment i\\n            i += 1\\n        \\n        # Now, return the output based on the scores\\n        # If both have same score, return 0\\n        if aliceScore == bobScore: return 0\\n        \\n        # If alice has a higher score than bob, return 1\\n        elif aliceScore > bobScore: return 1\\n        \\n        # Otherwise, return -1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        # How many stones\\n        n = len(aliceValues)\\n        \\n        # Let\\'s combine the values in a single list with each index having a pair\\n        # Each pair will be like this => (value of stone as per alice, value of stone as per bob)\\n        values = [(aliceValues[i], bobValues[i]) for i in range(n)]\\n        \\n        # We will sort by the sum of aliceValues and bobvalues for each stone\\n        values.sort(key = lambda x: x[0] + x[1])\\n        \\n        # Now, we can start playing the same\\n        aliceScore, bobScore = 0,0\\n        \\n        # To keep track of whose turn it is\\n        i = 0\\n        \\n        # While the values list is not empty\\n        while values:\\n            \\n            # Most optimal pair in the values list is the last pair\\n            pair = values.pop()\\n            \\n            # Since alice starts first, each even index \"i\" represents Alice\\'s turn\\n            if i % 2 == 0: aliceScore += pair[0]\\n            else: bobScore += pair[1]\\n                \\n            # Increment i\\n            i += 1\\n        \\n        # Now, return the output based on the scores\\n        # If both have same score, return 0\\n        if aliceScore == bobScore: return 0\\n        \\n        # If alice has a higher score than bob, return 1\\n        elif aliceScore > bobScore: return 1\\n        \\n        # Otherwise, return -1\\n        return -1\\n```\n```\\ndef stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        # How many stones\\n        n = len(aliceValues)\\n        \\n        # Instead of creating a list and then sorting it, we can use a maxHeap here\\n        maxHeap = []\\n        for i in range(n):heappush(maxHeap, (-(aliceValues[i] + bobValues[i]), i ))\\n        \\n        # Now, we can start playing the same\\n        aliceScore, bobScore = 0,0\\n        \\n        # To keep track of whose turn it is\\n        i = 0\\n        \\n        # While the maxHeap is not empty\\n        while maxHeap:\\n            \\n            # Most optimal stone index is on top of the maxHeap\\n            stoneIdx = heappop(maxHeap)[1]\\n            \\n            # Since alice starts first, each even value \"i\" represents Alice\\'s turn\\n            if i % 2 == 0: aliceScore += aliceValues[stoneIdx]\\n            else: bobScore += bobValues[stoneIdx]\\n                \\n            # Increment i\\n            i += 1\\n        \\n        # Now, return the output based on the scores\\n        # If both have same score, return 0\\n        if aliceScore == bobScore: return 0\\n        \\n        # If alice has a higher score than bob, return 1\\n        elif aliceScore > bobScore: return 1\\n        \\n        # Otherwise, return -1\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3991527,
                "title": "rust-solution-with-proper-proof-explanation-on-why-it-works",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nFrom the example where Alice get `[1, 2]` and Bob gets `[3, 1]`, we immediately knows that greedy approach based solely on their own perspective won\\'t work.\\n\\nHmm, why is that the case?\\nIt\\'s since when Alice gets the 0-th stone, she eliminates the possibility that Bob gets the 0-th.\\nUnder such a competing game setup, we can say that the 0-th stone actually worths `1 + 3` to Alice.\\nSimilar argument holds for Bob.\\n\\nBoth players, at first glance, values differently on different stones, but in such a competition, they actually have exactly the same consensus on what stones should be picked!\\n\\nCan we proof such intuition in a more rigorous way? Yes, we could.\\nLet sum of Alice\\'s values be `A` and `B` be that of Bob\\'s.\\nSuppose for certain strategies, Alice picked certain stones, of which value sum is `VA` and consensus sum (i.e. sum of values of those picked of both Alice and Bob) is `CA`, similarly `VB` and `CB` for Bob.\\n\\nPseudo-code in rust would be like:\\n``` rust\\nuse std::collections::HashSet;\\n\\nlet A = alice_values.iter().sum();\\nlet mut alice_indices = HashSet::new();\\n// some Alice strategy to fill in the hash set\\nlet VA = alice_indices.iter().fold(0, |sum, idx| sum + alice_values[idx]);\\nlet CA = alice_indices.iter().fold(0, |sum, idx| sum + alice_values[idx] + bob_values[idx]);\\n\\nlet B = bob_values.iter().sum();\\nlet mut bob_indices = HashSet::new();\\n// some Bob strategy to fill in the hash set\\nlet VB = bob_indices.iter().fold(0, |sum, idx| sum + bob_values[idx]);\\nlet CB = bob_indices.iter().fold(0, |sum, idx| sum + alice_values[idx] + bob_values[idx]);\\n\\nlet Alice_prevent_Bob_from_these = CA - VA;\\nlet ApBft = &Alice_prevent_Bob_from_these;\\nlet Bob_prevent_Alice_from_these = CB - VB;\\nlet BpAft = &Bob_prevent_Alice_from_these;\\n```\\n\\nHere\\'s the most important observation: `BpAft + VA == A` and `ApBft + VB == B`, which is straightforward: sum of Alice\\'s values is exactly those Alice got plus those Bob prevents Alice from obtaining.\\n\\nClaim: `CA + A >= CB + B` iff Alice wins.\\nProof:\\n`CA + A >= CB + B`\\n`VA + ApBft + A >= VB + BpAft + B` by definition of `ApBft` and `BpAft`\\n`VA + ApBft + BpAft + VA >= VB + BpAft + ApBft + VB` by our observation.\\nCancel same terms, we have:\\n`VA + VA >= VB + VB`. Alice wins. Converse part is the same.\\n\\nFinally, we note that `A`, `B`, and `CA + CB == A + B` are all constant.\\nAlice\\'s optimal strategy is just maximizing `CA`, similarly Bob maximizing `CB`.\\nAgain since `CA + CB == A + B` is constant, this becomes an obvious greedy game, where Alice and Bob pickes stone by its consensus value.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nTo prevent overflow, based on the intuition that Alice and Bob won\\'t have too much disagreement on value of any stone, we keep track of differences instead.\\nRecall that Alice win iff `CA + A >= CB + B`, which in term equivalent to `CA - CB >= B - A`, we record these two terms on the two sides of inequality.\\nSince both players\\' optimal way is choosing based on consensus sum, we make the consensus sum by summing the two array and sort it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`O(n*lg(n))` since sort and linear scan.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nDepends solely on sorting algorithm. Probably linear or constant.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn stone_game_vi(alice_values: Vec<i32>, bob_values: Vec<i32>) -> i32 {\\n        let aliss_debt = alice_values\\n            .iter()\\n            .zip(bob_values.iter())\\n            .fold(0, |sum, (a, b)| sum + b - a);\\n        let mut consensus_worths = alice_values;\\n        consensus_worths\\n            .iter_mut()\\n            .zip(bob_values.iter())\\n            .for_each(|(n, b)| *n = *n + b);\\n        consensus_worths.sort_unstable();\\n        match consensus_worths\\n            .iter()\\n            .rev()\\n            .enumerate()\\n            .fold(0, |alice_margin_in_terms_of_consensus_worth, (idx, consensus)| {\\n                if idx % 2 == 0 {\\n                    alice_margin_in_terms_of_consensus_worth + consensus\\n                } else {\\n                    alice_margin_in_terms_of_consensus_worth - consensus\\n                }\\n            })\\n            .cmp(&aliss_debt)\\n        {\\n            std::cmp::Ordering::Less => -1,\\n            std::cmp::Ordering::Equal => 0,\\n            std::cmp::Ordering::Greater => 1,\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "``` rust\\nuse std::collections::HashSet;\\n\\nlet A = alice_values.iter().sum();\\nlet mut alice_indices = HashSet::new();\\n// some Alice strategy to fill in the hash set\\nlet VA = alice_indices.iter().fold(0, |sum, idx| sum + alice_values[idx]);\\nlet CA = alice_indices.iter().fold(0, |sum, idx| sum + alice_values[idx] + bob_values[idx]);\\n\\nlet B = bob_values.iter().sum();\\nlet mut bob_indices = HashSet::new();\\n// some Bob strategy to fill in the hash set\\nlet VB = bob_indices.iter().fold(0, |sum, idx| sum + bob_values[idx]);\\nlet CB = bob_indices.iter().fold(0, |sum, idx| sum + alice_values[idx] + bob_values[idx]);\\n\\nlet Alice_prevent_Bob_from_these = CA - VA;\\nlet ApBft = &Alice_prevent_Bob_from_these;\\nlet Bob_prevent_Alice_from_these = CB - VB;\\nlet BpAft = &Bob_prevent_Alice_from_these;\\n```\n```\\nimpl Solution {\\n    pub fn stone_game_vi(alice_values: Vec<i32>, bob_values: Vec<i32>) -> i32 {\\n        let aliss_debt = alice_values\\n            .iter()\\n            .zip(bob_values.iter())\\n            .fold(0, |sum, (a, b)| sum + b - a);\\n        let mut consensus_worths = alice_values;\\n        consensus_worths\\n            .iter_mut()\\n            .zip(bob_values.iter())\\n            .for_each(|(n, b)| *n = *n + b);\\n        consensus_worths.sort_unstable();\\n        match consensus_worths\\n            .iter()\\n            .rev()\\n            .enumerate()\\n            .fold(0, |alice_margin_in_terms_of_consensus_worth, (idx, consensus)| {\\n                if idx % 2 == 0 {\\n                    alice_margin_in_terms_of_consensus_worth + consensus\\n                } else {\\n                    alice_margin_in_terms_of_consensus_worth - consensus\\n                }\\n            })\\n            .cmp(&aliss_debt)\\n        {\\n            std::cmp::Ordering::Less => -1,\\n            std::cmp::Ordering::Equal => 0,\\n            std::cmp::Ordering::Greater => 1,\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3923696,
                "title": "c-code-fast-solution-greedy-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& A, vector<int>& B) {\\n        vector<vector<int>> v;\\n        for(int i=0;i<A.size();i++){\\n            v.push_back({A[i]+B[i], A[i],B[i]});\\n        }\\n        sort(v.begin(), v.end(), greater<vector<int>>() );\\n        \\n        int a=0,b=0;\\n        for(int i=0;i<A.size();i++){\\n            if(i&1){\\n                b+=v[i][2];\\n            }else{\\n                a+=v[i][1];\\n            }\\n        }\\n        if(a==b)return 0;\\n        else if(a>b)return 1;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& A, vector<int>& B) {\\n        vector<vector<int>> v;\\n        for(int i=0;i<A.size();i++){\\n            v.push_back({A[i]+B[i], A[i],B[i]});\\n        }\\n        sort(v.begin(), v.end(), greater<vector<int>>() );\\n        \\n        int a=0,b=0;\\n        for(int i=0;i<A.size();i++){\\n            if(i&1){\\n                b+=v[i][2];\\n            }else{\\n                a+=v[i][1];\\n            }\\n        }\\n        if(a==b)return 0;\\n        else if(a>b)return 1;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923445,
                "title": "approach-greedy",
                "content": "# Intuition\\nHere the trick is to store the sum(aliceValues[i]+bobValues[i]) and sort it and then pick the even values of alice and off for bob\\nLink to video [link](https://youtu.be/iEf6bWgqHZo)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(3n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        vector<vector<int>>v;\\n        int n=aliceValues.size();\\n        int alice=0,bob=0;\\n        for(int i=0;i<n;i++){\\n            v.push_back({aliceValues[i]+bobValues[i],aliceValues[i],bobValues[i]});\\n        }\\n        sort(v.begin(),v.end(),greater<vector<int>>());\\n        for(int i=0;i<n;i++){\\n            if(i%2==0) alice+=v[i][1];\\n            else bob+=v[i][2];\\n        }\\n        if(alice==bob) return 0;\\n        else if(alice>bob) return 1;\\n        else return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        vector<vector<int>>v;\\n        int n=aliceValues.size();\\n        int alice=0,bob=0;\\n        for(int i=0;i<n;i++){\\n            v.push_back({aliceValues[i]+bobValues[i],aliceValues[i],bobValues[i]});\\n        }\\n        sort(v.begin(),v.end(),greater<vector<int>>());\\n        for(int i=0;i<n;i++){\\n            if(i%2==0) alice+=v[i][1];\\n            else bob+=v[i][2];\\n        }\\n        if(alice==bob) return 0;\\n        else if(alice>bob) return 1;\\n        else return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888232,
                "title": "easy-to-understand-and-faster-than-97-of-c-submissions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe goal of each player is to maximize their own score while also minimizing the score of their opponent. To achieve this, we sort the array based on the sum of a[i] + b[i]. This is because when one player takes a stone, they not only gain points for themselves, but they also prevent the other player from gaining those points. So, by choosing the stone with the maximum sum of values, the player is maximizing their own gain while minimizing the gain of their opponent.\\n# Approach\\n1. Create a new array sum of length n, where sum[i] = a[i] + b[i].\\n2. Sort the sum array in descending order.\\n3. Initialize two variables aliceScore and bobScore to 0.\\n4. Iterate through the sorted values array. On each iteration:\\n    - If it\\u2019s Alice\\u2019s turn, add aliceValues[i] to aliceScore.\\n    - If it\\u2019s Bob\\u2019s turn, add bobValues[i] to bobScore.\\n5. Compare aliceScore and bobScore. If aliceScore > bobScore, return 1. If aliceScore < bobScore, return -1. Otherwise, return 0.\\n# Complexity\\n- Time complexity: \\nO(n log n) \\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& a, vector<int>& b) {\\n        int n = a.size();\\n        vector<pair<int, int> > sum(n);\\n        for (int i = 0; i < n; i++) {\\n            sum[i] = {a[i] + b[i], i};\\n        }\\n        sort(sum.rbegin(), sum.rend());\\n        int aliceScore = 0, bobScore = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (i % 2 == 0) {\\n                aliceScore += a[sum[i].second];\\n            }\\n            else {\\n                bobScore += b[sum[i].second];\\n            }\\n        }\\n        return aliceScore > bobScore ? 1 : aliceScore < bobScore ? -1 : 0;\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& a, vector<int>& b) {\\n        int n = a.size();\\n        vector<pair<int, int> > sum(n);\\n        for (int i = 0; i < n; i++) {\\n            sum[i] = {a[i] + b[i], i};\\n        }\\n        sort(sum.rbegin(), sum.rend());\\n        int aliceScore = 0, bobScore = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (i % 2 == 0) {\\n                aliceScore += a[sum[i].second];\\n            }\\n            else {\\n                bobScore += b[sum[i].second];\\n            }\\n        }\\n        return aliceScore > bobScore ? 1 : aliceScore < bobScore ? -1 : 0;\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887552,
                "title": "best-c-solution-using-heaps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are given that they will play optimally, now think how would they play optimally? If you were at that place then you would definitely want max advantage to yourself and maximum loss to the other one so just sum the value of alice and bob which are at same index and select the one with the maximum sum in this way we can play optimally but now we want maximum sum in minimum time...we can think of max heap as it give us maximmum element in O(1) TC \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a max heap to store the sum of aliceValues and bobValues and the index i , in my case I have used class mine to store them\\n2. I have created variables alice and bob to store their store and an additional boolean variable to track the turn of players\\n3. Now we will process items till the max heap does not become empty (Using While loop)\\n4. In loop,Take out the top element of heap and pop it\\n5. Take out the Index from it\\n6. see whose turn it is \\n7. if alice turn , take value from aliceValues and add it to alice score...do same for bob\\n8. Return as per given in question\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass mine{\\n    public:\\n    int sum;\\n    int index;\\n    mine(int s,int i){\\n        sum=s;\\n        index=i;\\n    }\\n};\\nclass compare{\\n    public:\\n    bool operator()(mine*a,mine*b){\\n        return a->sum < b->sum;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        int n=bobValues.size();\\n        priority_queue<mine*,vector<mine*>,compare>pq;\\n        for(int i=0;i<n;i++){\\n            mine*t=new mine(aliceValues[i]+bobValues[i],i);\\n            pq.push(t);\\n        }\\n        int alice=0,bob=0;\\n        bool turn_alice=true;\\n        while(!pq.empty()){\\n            auto fr=pq.top();\\n            pq.pop();\\n            if(turn_alice){\\n                alice+=aliceValues[fr->index];\\n            }\\n            else{\\n                bob+=bobValues[fr->index];\\n            }\\n            turn_alice=!turn_alice;\\n        }\\n        if(alice>bob){\\n            return 1;\\n        }\\n        else if(alice<bob){\\n            return -1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass mine{\\n    public:\\n    int sum;\\n    int index;\\n    mine(int s,int i){\\n        sum=s;\\n        index=i;\\n    }\\n};\\nclass compare{\\n    public:\\n    bool operator()(mine*a,mine*b){\\n        return a->sum < b->sum;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        int n=bobValues.size();\\n        priority_queue<mine*,vector<mine*>,compare>pq;\\n        for(int i=0;i<n;i++){\\n            mine*t=new mine(aliceValues[i]+bobValues[i],i);\\n            pq.push(t);\\n        }\\n        int alice=0,bob=0;\\n        bool turn_alice=true;\\n        while(!pq.empty()){\\n            auto fr=pq.top();\\n            pq.pop();\\n            if(turn_alice){\\n                alice+=aliceValues[fr->index];\\n            }\\n            else{\\n                bob+=bobValues[fr->index];\\n            }\\n            turn_alice=!turn_alice;\\n        }\\n        if(alice>bob){\\n            return 1;\\n        }\\n        else if(alice<bob){\\n            return -1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748599,
                "title": "stone-game-vi-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        priority_queue<pair<int,int>> pq;\\n        int i, j=0, sum1=0, sum2=0;\\n        for(i=0 ; i<aliceValues.size() ; i++)\\n        {\\n            pq.push(make_pair((aliceValues[i]+bobValues[i]), i));\\n        }\\n        while(!pq.empty())\\n        {\\n            if(j%2==0)\\n            {\\n                sum1 += pq.top().first-bobValues[pq.top().second];\\n                pq.pop();\\n            }\\n            else\\n            {\\n                sum2 += pq.top().first-aliceValues[pq.top().second];\\n                pq.pop();\\n            }\\n            j++;\\n        }\\n        if(sum1>sum2)\\n            return 1;\\n        else if(sum1<sum2)\\n            return -1;\\n        else\\n            return 0;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/95f430db-37b5-4506-ac4a-9ce0499b9c5f_1689055779.1948133.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        priority_queue<pair<int,int>> pq;\\n        int i, j=0, sum1=0, sum2=0;\\n        for(i=0 ; i<aliceValues.size() ; i++)\\n        {\\n            pq.push(make_pair((aliceValues[i]+bobValues[i]), i));\\n        }\\n        while(!pq.empty())\\n        {\\n            if(j%2==0)\\n            {\\n                sum1 += pq.top().first-bobValues[pq.top().second];\\n                pq.pop();\\n            }\\n            else\\n            {\\n                sum2 += pq.top().first-aliceValues[pq.top().second];\\n                pq.pop();\\n            }\\n            j++;\\n        }\\n        if(sum1>sum2)\\n            return 1;\\n        else if(sum1<sum2)\\n            return -1;\\n        else\\n            return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705520,
                "title": "full-explanation-priority-queue-greedy",
                "content": "# Intuition\\nInitially when looking at this question it seems like some choosing type problem. Hence first thought goes to DP, but it fails due to the constraints. \\n\\nNow thinking greedily, let assume that we have a pile of stones, where both alice and bob\\'s value are present instead of only one. In other words, in this question we have a pile of stones where both only think different values for themselves. But what I am saying is assume that you have a new pile of stones, where Alice\\'s array and Bob\\'s array piles of stones are present. \\nEx - Given, A = [1, 2 ,3] & B = [2, 6, 7];\\nSo, assume new pile of stones is [1, 2, 2, 3, 6, 7]. And assume that in alice and bob are playing this game where they have to choose an element from this array. Only difference is that, when they will choose an element from this array, one more element will be out from this array. This is our question? \\nWhenever you are choosing an element you are taking one element of the other also. So, the total value by which you are making his loss is a[i] + b[i], and yourself gaining as b[i]/a[i] based on what you choose. So, using a priority queue for storing the values of {a[i]+b[i], i} in the pq, and optimally take the element corresponding to max loss of others.\\n# Approach\\nUsing pq to store {loss of other, index} and each time taking the index corresponding to max loss of other. Finally checking who got maximum point.\\n# Complexity\\n- Time complexity:\\nO(N*LOG N)\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& av, vector<int>& bv) \\n    {\\n        int al = 0, b = 0, n = av.size();\\n        priority_queue<pair<int, int>> pq;\\n        for(int i = 0; i < n; i++)\\n        {\\n            pq.push({av[i] + bv[i], i});\\n        }\\n\\n        int turn = 0;\\n        while(!pq.empty())\\n        {\\n            int ind = pq.top().second;\\n            pq.pop();\\n            if(turn == 0)\\n            {\\n                al += av[ind];\\n            }\\n            else \\n            {\\n                b += bv[ind];\\n            }\\n            turn = (turn^1);\\n        }\\n\\n        if(al > b)\\n        {\\n            return 1;\\n        }\\n        else if(al < b)\\n        {\\n            return -1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& av, vector<int>& bv) \\n    {\\n        int al = 0, b = 0, n = av.size();\\n        priority_queue<pair<int, int>> pq;\\n        for(int i = 0; i < n; i++)\\n        {\\n            pq.push({av[i] + bv[i], i});\\n        }\\n\\n        int turn = 0;\\n        while(!pq.empty())\\n        {\\n            int ind = pq.top().second;\\n            pq.pop();\\n            if(turn == 0)\\n            {\\n                al += av[ind];\\n            }\\n            else \\n            {\\n                b += bv[ind];\\n            }\\n            turn = (turn^1);\\n        }\\n\\n        if(al > b)\\n        {\\n            return 1;\\n        }\\n        else if(al < b)\\n        {\\n            return -1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641741,
                "title": "ruby-sorting-solution-with-explanation-100-100",
                "content": "# Intuition\\nStones that are worth a lot to either player are valuable to both players, either by giving them lots of points or preventing their opponent from getting lots of points.  The best strategy is to pick the stones with the greatest total value.\\n\\n# Approach\\n1. Create an array of stones, with the value assigned by both players.\\n2. Sort these stones by total value.\\n3. Initialize score as 0\\n4. Pop off pairs of stones, adding the alice value for one and subtracting the bob value for the next.\\n5. If there\\'s a stone left over (because there were an odd number), give those points to Alice.\\n6. Convert the score to 1, -1, or 0.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\ndef stone_game_vi(alice, bob)\\n    stones = []\\n    (0...alice.length).each { |i| stones << [alice[i],bob[i]] }\\n\\n    stones.sort_by! { |arr| arr[0] + arr[1] }\\n\\n    score = 0\\n    while stones.length > 1\\n        score += stones.pop[0]\\n        score -= stones.pop[1]\\n    end\\n    \\n    score += stones[0][0] if stones[0]\\n\\n    if score > 0\\n        1\\n    elsif score < 0\\n        -1\\n    else\\n        0\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef stone_game_vi(alice, bob)\\n    stones = []\\n    (0...alice.length).each { |i| stones << [alice[i],bob[i]] }\\n\\n    stones.sort_by! { |arr| arr[0] + arr[1] }\\n\\n    score = 0\\n    while stones.length > 1\\n        score += stones.pop[0]\\n        score -= stones.pop[1]\\n    end\\n    \\n    score += stones[0][0] if stones[0]\\n\\n    if score > 0\\n        1\\n    elsif score < 0\\n        -1\\n    else\\n        0\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3594494,
                "title": "easy-solution-with-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef vector< vector<pair<int, int>> >vv;\\ntypedef vector<pair<int, int>>vi;\\nclass Solution {\\npublic:\\n\\n    int stoneGameVI(vector<int>& Alice, vector<int>& Bob) {\\n    int n=Bob.size();\\n    priority_queue<pair<int, int>>Pq;\\n    for (int x = 0; x < n; x++)Pq.push({Alice[x]+Bob[x],x});\\n    int A = 0, B = 0,Ch=1;\\n    while (!Pq.empty())\\n     {\\n    pair<int, int>cur = Pq.top();\\n    if (Ch)A += (cur.first - Bob[cur.second]);\\n    else B += (cur.first - Alice[cur.second]);\\n    Ch = !Ch;\\n    Pq.pop();\\n    }\\n    return (A > B ? 1 : (A == B ? 0 : -1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntypedef vector< vector<pair<int, int>> >vv;\\ntypedef vector<pair<int, int>>vi;\\nclass Solution {\\npublic:\\n\\n    int stoneGameVI(vector<int>& Alice, vector<int>& Bob) {\\n    int n=Bob.size();\\n    priority_queue<pair<int, int>>Pq;\\n    for (int x = 0; x < n; x++)Pq.push({Alice[x]+Bob[x],x});\\n    int A = 0, B = 0,Ch=1;\\n    while (!Pq.empty())\\n     {\\n    pair<int, int>cur = Pq.top();\\n    if (Ch)A += (cur.first - Bob[cur.second]);\\n    else B += (cur.first - Alice[cur.second]);\\n    Ch = !Ch;\\n    Pq.pop();\\n    }\\n    return (A > B ? 1 : (A == B ? 0 : -1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578474,
                "title": "kotlin-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun stoneGameVI(aliceValues: IntArray, bobValues: IntArray): Int {\\n        val n = aliceValues.size\\n        val diff = mutableListOf<Pair<Int, Int>>()\\n\\n        for (i in 0 until n) {\\n            diff.add(Pair(aliceValues[i] + bobValues[i], i))\\n        }\\n\\n        diff.sortWith(compareBy({ -it.first }))\\n\\n        var result = 0\\n\\n        for(i in 0 until n) {\\n            if (i % 2 == 0) {\\n                result += aliceValues[diff[i].second]\\n            } else {\\n                result -= bobValues[diff[i].second]\\n            }\\n        }\\n\\n        return if(result > 0) 1 else if(result < 0) -1 else 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun stoneGameVI(aliceValues: IntArray, bobValues: IntArray): Int {\\n        val n = aliceValues.size\\n        val diff = mutableListOf<Pair<Int, Int>>()\\n\\n        for (i in 0 until n) {\\n            diff.add(Pair(aliceValues[i] + bobValues[i], i))\\n        }\\n\\n        diff.sortWith(compareBy({ -it.first }))\\n\\n        var result = 0\\n\\n        for(i in 0 until n) {\\n            if (i % 2 == 0) {\\n                result += aliceValues[diff[i].second]\\n            } else {\\n                result -= bobValues[diff[i].second]\\n            }\\n        }\\n\\n        return if(result > 0) 1 else if(result < 0) -1 else 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578076,
                "title": "an-almost-one-line-solution",
                "content": "# Intuition\\n\\nSuppose Alice selects a subset of stones $S$ and Bob the complement $S^c$. Then the difference of the value obtained by Alice and Bob is:\\n$$\\nv = \\\\sum_{i\\\\in S} a_i-\\\\sum_{j\\\\in S^c} b_j\\n=\\\\sum_{i\\\\in S} (a_i+b_i) - B, \\\\quad \\\\text{where $B=\\\\sum_j b_j$ the total value of stones for Bob}.\\n$$\\nHere $a_i$ is the value of the $i$th stone for Alice and $b_i$ is the same for Bob.\\n\\nSo Alice goal is to select the most valuable stones, where the value measured by ($a_i+b_i$). Since Bob has the same goal, if they play rationally they will select the first available stone with the largest value. \\n\\nSo all we have to do is the sort the array with elements $(a_i+b_i)$ and sum every second term. Subtracting $B$ the total value of stones for Bob, gives the final standing.\\n \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        c = sorted((ai+bi for ai, bi in zip(aliceValues, bobValues)), reverse=True)\\n        val = sum(c[::2])-sum(bobValues)\\n        if val > 0:\\n            return 1\\n        if val < 0:\\n            return -1\\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        c = sorted((ai+bi for ai, bi in zip(aliceValues, bobValues)), reverse=True)\\n        val = sum(c[::2])-sum(bobValues)\\n        if val > 0:\\n            return 1\\n        if val < 0:\\n            return -1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566558,
                "title": "c-easy-using-sort",
                "content": "First calculate the sum at each index. The logic is that we can only maximise the players turn by\\nnot only maximising the score from our own array but also taking away the maximum possible from other players array. So sort according to sum and then maximise the move based on turns.\\n\\n\\nclass Solution {\\npublic:\\n    static bool comp(pair<int,int>&a,pair<int,int>&b){\\n        return a.first>b.first;\\n    }\\n    pair<int,int>helper(vector<int>&a,vector<int>&b,int sum1,int sum2){\\n        int n= a.size();\\n        vector<pair<int,int>>temp;\\n        for(int i=0; i<n; i++){\\n            int sum= a[i]+b[i];\\n            temp.push_back({sum,i});\\n            \\n        }\\n        sort(temp.begin(),temp.end(),comp);\\n        bool flag=true;\\n        for(int i=0; i<n; i++){\\n            if(flag){\\n                sum1+= a[temp[i].second];\\n            }\\n            else if(!flag){\\n                sum2+= b[temp[i].second];\\n            }\\n            flag= !flag;\\n            \\n        }\\n        return {sum1,sum2};\\n        \\n    }\\n    int stoneGameVI(vector<int>& a, vector<int>& b) {\\n      pair<int,int>temp=  helper(a,b,0,0);\\n        if(temp.first>temp.second) return 1;\\n        else if(temp.second==temp.first) return 0;\\n        else{\\n            return -1;\\n        }\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    static bool comp(pair<int,int>&a,pair<int,int>&b){\\n        return a.first>b.first;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3566191,
                "title": "c-clean-code-sorting",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& a, vector<int>& b) {\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<a.size();i++)\\n        v.push_back({a[i]+b[i],i});\\n        sort(v.begin(),v.end(),greater<pair<int,int>> ());\\n        long long int s=0,s2=0;\\n\\n        for(int i=0;i<v.size();i++)\\n        if(i%2==0)\\n        s+=a[v[i].second];\\n        else\\n        s2+=b[v[i].second];\\n\\n        if(s>s2)\\n        return 1;\\n        else if(s2>s)\\n        return -1;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& a, vector<int>& b) {\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<a.size();i++)\\n        v.push_back({a[i]+b[i],i});\\n        sort(v.begin(),v.end(),greater<pair<int,int>> ());\\n        long long int s=0,s2=0;\\n\\n        for(int i=0;i<v.size();i++)\\n        if(i%2==0)\\n        s+=a[v[i].second];\\n        else\\n        s2+=b[v[i].second];\\n\\n        if(s>s2)\\n        return 1;\\n        else if(s2>s)\\n        return -1;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548680,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int stoneGameVI(List<int> aliceValues, List<int> bobValues) {\\n      int bob=0,alice=0;\\n      List<int> stoneIndices=List.generate(aliceValues.length,(index)=>index);\\n      stoneIndices.sort((a,b)=>(aliceValues[b]+bobValues[b]).compareTo(aliceValues[a]+bobValues[a]));\\n      for(int i=0;i<stoneIndices.length;i++){\\n          var index=stoneIndices[i];\\n          if(i%2==0){\\n              alice+=aliceValues[index];\\n          }\\n          else{\\n              bob+=bobValues[index];\\n          }\\n      }\\n\\n      return bob>alice?-1:bob<alice?1:0;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int stoneGameVI(List<int> aliceValues, List<int> bobValues) {\\n      int bob=0,alice=0;\\n      List<int> stoneIndices=List.generate(aliceValues.length,(index)=>index);\\n      stoneIndices.sort((a,b)=>(aliceValues[b]+bobValues[b]).compareTo(aliceValues[a]+bobValues[a]));\\n      for(int i=0;i<stoneIndices.length;i++){\\n          var index=stoneIndices[i];\\n          if(i%2==0){\\n              alice+=aliceValues[index];\\n          }\\n          else{\\n              bob+=bobValues[index];\\n          }\\n      }\\n\\n      return bob>alice?-1:bob<alice?1:0;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545190,
                "title": "c-greedy-sorting",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        int n = aliceValues.size();\\n        vector<int> index(n);\\n        iota(index.begin(), index.end(), 0);\\n        sort(index.begin(), index.end(), [&](int i, int j) {\\n            return aliceValues[i] + bobValues[i] > aliceValues[j] + bobValues[j];\\n        });\\n        int scoreDiff = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(i % 2 == 0) {\\n                scoreDiff += aliceValues[index[i]];\\n            } else {\\n                scoreDiff -= bobValues[index[i]];\\n            }\\n        }\\n        return scoreDiff == 0? 0: scoreDiff / abs(scoreDiff);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        int n = aliceValues.size();\\n        vector<int> index(n);\\n        iota(index.begin(), index.end(), 0);\\n        sort(index.begin(), index.end(), [&](int i, int j) {\\n            return aliceValues[i] + bobValues[i] > aliceValues[j] + bobValues[j];\\n        });\\n        int scoreDiff = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(i % 2 == 0) {\\n                scoreDiff += aliceValues[index[i]];\\n            } else {\\n                scoreDiff -= bobValues[index[i]];\\n            }\\n        }\\n        return scoreDiff == 0? 0: scoreDiff / abs(scoreDiff);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502772,
                "title": "elixir-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec stone_game_vi(alice_values :: [integer], bob_values :: [integer]) :: integer\\n  def stone_game_vi(alice_values, bob_values) do\\n    [_ | rest] = values = \\n        alice_values\\n        |> Enum.zip(bob_values)\\n        |> Enum.sort_by(fn {a, b} -> a + b end, :desc)\\n\\n    alice = Enum.take_every(values, 2) |> Enum.map(fn {a, _} -> a end) |> Enum.sum()\\n    bob = Enum.take_every(rest, 2) |> Enum.map(fn {_, b} -> b end) |> Enum.sum()\\n\\n    cond do\\n      alice > bob -> 1\\n      bob > alice -> -1\\n      true -> 0 \\n    end\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec stone_game_vi(alice_values :: [integer], bob_values :: [integer]) :: integer\\n  def stone_game_vi(alice_values, bob_values) do\\n    [_ | rest] = values = \\n        alice_values\\n        |> Enum.zip(bob_values)\\n        |> Enum.sort_by(fn {a, b} -> a + b end, :desc)\\n\\n    alice = Enum.take_every(values, 2) |> Enum.map(fn {a, _} -> a end) |> Enum.sum()\\n    bob = Enum.take_every(rest, 2) |> Enum.map(fn {_, b} -> b end) |> Enum.sum()\\n\\n    cond do\\n      alice > bob -> 1\\n      bob > alice -> -1\\n      true -> 0 \\n    end\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3446547,
                "title": "very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n\\n        priority_queue<pair<int,pair<int,int>>>pq;\\n        int alice = 0;\\n        int bob = 0;\\n\\n        for(int i = 0;i<aliceValues.size();i++){\\n\\n            int s = aliceValues[i] + bobValues[i];\\n            pq.push({s,{aliceValues[i],bobValues[i]}});\\n        }\\n\\n        int c = 0;\\n        while(!pq.empty()){\\n\\n            if(c%2==0){\\n                alice = alice + pq.top().second.first;\\n            }\\n            else{\\n                bob = bob + pq.top().second.second;\\n            }\\n            c++;\\n            pq.pop();\\n        }\\n        if(alice>bob)return 1;\\n        if(bob>alice)return -1;\\n        return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n\\n        priority_queue<pair<int,pair<int,int>>>pq;\\n        int alice = 0;\\n        int bob = 0;\\n\\n        for(int i = 0;i<aliceValues.size();i++){\\n\\n            int s = aliceValues[i] + bobValues[i];\\n            pq.push({s,{aliceValues[i],bobValues[i]}});\\n        }\\n\\n        int c = 0;\\n        while(!pq.empty()){\\n\\n            if(c%2==0){\\n                alice = alice + pq.top().second.first;\\n            }\\n            else{\\n                bob = bob + pq.top().second.second;\\n            }\\n            c++;\\n            pq.pop();\\n        }\\n        if(alice>bob)return 1;\\n        if(bob>alice)return -1;\\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419651,
                "title": "c-greedy",
                "content": "# Intuition\\nWhen one player chooses a stone, he dosen\\'t allow the next player to take points of that stone, hence alice and bob can take stones in order of maximum sum of each stone\\'s value(i.e. at ith index, sum will be alice[i]+bob[i]). So if players take stones in order of maximum sum, they will gain maximum points as they will play optimally.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& av, vector<int>& bv) {\\n        int n = av.size();\\n        vector<pair<int,int>> vec(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            vec[i] = {av[i]+bv[i],i};\\n        }\\n        sort(vec.rbegin(),vec.rend());\\n        int cnta = 0,cntb = 0;\\n        int flg=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!flg)\\n            {\\n                flg = 1;\\n                cnta+=av[vec[i].second];\\n            }\\n            else\\n            {\\n                flg = 0;\\n                cntb+=bv[vec[i].second];\\n            }\\n        }\\n        if(cnta>cntb)\\n        return 1;\\n        if(cntb>cnta)\\n        return -1;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& av, vector<int>& bv) {\\n        int n = av.size();\\n        vector<pair<int,int>> vec(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            vec[i] = {av[i]+bv[i],i};\\n        }\\n        sort(vec.rbegin(),vec.rend());\\n        int cnta = 0,cntb = 0;\\n        int flg=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!flg)\\n            {\\n                flg = 1;\\n                cnta+=av[vec[i].second];\\n            }\\n            else\\n            {\\n                flg = 0;\\n                cntb+=bv[vec[i].second];\\n            }\\n        }\\n        if(cnta>cntb)\\n        return 1;\\n        if(cntb>cnta)\\n        return -1;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380378,
                "title": "stone-game-vi-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        int n=aliceValues.length;\\n        int ans[][]=new int[n][3];\\n        for(int i=0;i<n;i++){\\n        ans[i]=  new int[]{aliceValues[i]+bobValues[i],aliceValues[i],bobValues[i]};\\n        }\\n        Arrays.sort(ans,(a,b)->Integer.compare(b[0],a[0]));\\n        int a=0;\\n        int b=0;\\n        for(int i=0;i<n;i++){\\n            if(i%2==0){\\n                a+=ans[i][1];\\n            }\\n            else{\\n                b+=ans[i][2];\\n            }\\n        }\\n       return Integer.compare(a, b); \\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        int n=aliceValues.length;\\n        int ans[][]=new int[n][3];\\n        for(int i=0;i<n;i++){\\n        ans[i]=  new int[]{aliceValues[i]+bobValues[i],aliceValues[i],bobValues[i]};\\n        }\\n        Arrays.sort(ans,(a,b)->Integer.compare(b[0],a[0]));\\n        int a=0;\\n        int b=0;\\n        for(int i=0;i<n;i++){\\n            if(i%2==0){\\n                a+=ans[i][1];\\n            }\\n            else{\\n                b+=ans[i][2];\\n            }\\n        }\\n       return Integer.compare(a, b); \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362760,
                "title": "java-solution-observation-based",
                "content": "### T.C. - O(nlogn)\\n### S.C. - O(3n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        int n=aliceValues.length;\\n        int a[][]=new int[n][3];\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i][0]=aliceValues[i];\\n            a[i][1]=bobValues[i];\\n            a[i][2]=aliceValues[i]+bobValues[i];\\n        }\\n        Arrays.sort(a,(x,y)->\\n        {\\n            if(x[2]>y[2])return -1;\\n            else if(x[2]<y[2])return 1;\\n            else return 0;\\n        });\\n        int s=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%2==0)s+=a[i][0];\\n            else s-=a[i][1];\\n        }\\n        if(s>0)return 1;\\n        else if(s<0)return -1;\\n        else return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        int n=aliceValues.length;\\n        int a[][]=new int[n][3];\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i][0]=aliceValues[i];\\n            a[i][1]=bobValues[i];\\n            a[i][2]=aliceValues[i]+bobValues[i];\\n        }\\n        Arrays.sort(a,(x,y)->\\n        {\\n            if(x[2]>y[2])return -1;\\n            else if(x[2]<y[2])return 1;\\n            else return 0;\\n        });\\n        int s=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%2==0)s+=a[i][0];\\n            else s-=a[i][1];\\n        }\\n        if(s>0)return 1;\\n        else if(s<0)return -1;\\n        else return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277575,
                "title": "python-3-solution-time-99-space-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConvert the problem to another equivalent maximization problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet $I$ be a subset in the index set $\\\\{1,2,\\\\cdots,n\\\\}$ consisting of the indices of stones that Alice takes at the end of the game. Of course then $I^c$ is the index subset the stones indexed by which Bob takes by the end of the game.\\n\\nAlice wants to maximize $a_I - b_{I^c} := \\\\sum_{i\\\\in I} a_i - \\\\sum_{j\\\\in I^c} b_i$, and Bob wants to minimize ti.\\n\\nNow note that\\n$$\\na_I - b_{I^c} = a_{I} + b_{I} - b_{I} - b_{I^c} = a_{I} + b_I - \\\\sum_{i=1}^n b_i\\n$$\\nso Alice equivalently needs to maximize the sum $a_I+b_I$, and the final score is given by the formula above. \\n\\nTherefore, in the first round, she should take the stone $i_1$ that has the highest joint score $a_{i_1} + b_{i_1}$; Bob then should take the second highest one, and so on. \\n\\nSimply sort the joint score list and calculate the sum of every other element from the largest element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$\\\\mathcal O\\\\big(n\\\\log n \\\\big)$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$\\\\mathcal O(n) $.\\n\\n# Code\\n```\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        a, b, n = aliceValues, bobValues, len(aliceValues)\\n        B = sum(b)\\n        tot = [a[i]+b[i] for i in range(n)]\\n        tot.sort(reverse = True)\\n        K = sum(tot[2*i] for i in range( (n+1)//2 ) )\\n        if K>B:\\n            return 1\\n        elif K==B:\\n            return 0\\n        else:\\n            return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        a, b, n = aliceValues, bobValues, len(aliceValues)\\n        B = sum(b)\\n        tot = [a[i]+b[i] for i in range(n)]\\n        tot.sort(reverse = True)\\n        K = sum(tot[2*i] for i in range( (n+1)//2 ) )\\n        if K>B:\\n            return 1\\n        elif K==B:\\n            return 0\\n        else:\\n            return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236228,
                "title": "easy-solution-c-priority-queue",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        priority_queue<pair<int,pair<int,int>>> pq ;\\n        int n = aliceValues.size() , i ;\\n        for(i=0;i<n;i++){\\n            pq.push({aliceValues[i]+bobValues[i],{aliceValues[i],bobValues[i]}}) ;\\n        }\\n        int bob = 0 , alice = 0   ;\\n        i=  0 ;\\n        while(pq.size()>0){\\n            if(i%2==0){\\n                alice += pq.top().second.first ;\\n            }\\n            else{\\n                bob   += pq.top().second.second ;\\n            }\\n            pq.pop() ;\\n            i++ ;\\n        }\\n        if(alice>bob){\\n            return 1 ;\\n        }\\n        else if(alice==bob){\\n            return 0 ;\\n        }\\n        else{\\n            return -1; \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        priority_queue<pair<int,pair<int,int>>> pq ;\\n        int n = aliceValues.size() , i ;\\n        for(i=0;i<n;i++){\\n            pq.push({aliceValues[i]+bobValues[i],{aliceValues[i],bobValues[i]}}) ;\\n        }\\n        int bob = 0 , alice = 0   ;\\n        i=  0 ;\\n        while(pq.size()>0){\\n            if(i%2==0){\\n                alice += pq.top().second.first ;\\n            }\\n            else{\\n                bob   += pq.top().second.second ;\\n            }\\n            pq.pop() ;\\n            i++ ;\\n        }\\n        if(alice>bob){\\n            return 1 ;\\n        }\\n        else if(alice==bob){\\n            return 0 ;\\n        }\\n        else{\\n            return -1; \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135597,
                "title": "using-comparator-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution{\\npublic:\\n    static bool cmp(pair<int,int> a,pair<int,int> b){\\n        if(a.first+a.second>b.first+b.second) return true;\\n        return false;\\n    }\\n    int stoneGameVI(vector<int>& aliceValues,vector<int>& bobValues){\\n        int n=aliceValues.size();\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<n;i++){\\n            v.push_back({aliceValues[i],bobValues[i]});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        int a=0,b=0;\\n        for(int i=0;i<n;i++){\\n            if(i%2==0) a+=v[i].first;\\n            else b+=v[i].second;\\n        }\\n        if(a>b) return 1;\\n        else if(a<b) return -1;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    static bool cmp(pair<int,int> a,pair<int,int> b){\\n        if(a.first+a.second>b.first+b.second) return true;\\n        return false;\\n    }\\n    int stoneGameVI(vector<int>& aliceValues,vector<int>& bobValues){\\n        int n=aliceValues.size();\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<n;i++){\\n            v.push_back({aliceValues[i],bobValues[i]});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        int a=0,b=0;\\n        for(int i=0;i<n;i++){\\n            if(i%2==0) a+=v[i].first;\\n            else b+=v[i].second;\\n        }\\n        if(a>b) return 1;\\n        else if(a<b) return -1;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100623,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n          vector<pair<int, int>> values;\\n          for(int i=0;i<aliceValues.size();i++) {\\n              values.push_back({aliceValues[i] + bobValues[i], i});\\n          }\\n\\n          sort(begin(values), end(values), [](auto& ele1, auto& ele2) {\\n              return ele1.first > ele2.first;\\n          });\\n\\n\\n          long long alice = 0;\\n          long long bob = 0;\\n          for(int i=0;i<values.size();i++) {\\n              if(i%2==0) {\\n                  alice += aliceValues[values[i].second];\\n              }else {\\n                  bob += bobValues[values[i].second];\\n              }\\n          }\\n\\n\\n          if(alice == bob) {\\n              return 0; \\n           }\\n\\n           return alice > bob ? 1: -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n          vector<pair<int, int>> values;\\n          for(int i=0;i<aliceValues.size();i++) {\\n              values.push_back({aliceValues[i] + bobValues[i], i});\\n          }\\n\\n          sort(begin(values), end(values), [](auto& ele1, auto& ele2) {\\n              return ele1.first > ele2.first;\\n          });\\n\\n\\n          long long alice = 0;\\n          long long bob = 0;\\n          for(int i=0;i<values.size();i++) {\\n              if(i%2==0) {\\n                  alice += aliceValues[values[i].second];\\n              }else {\\n                  bob += bobValues[values[i].second];\\n              }\\n          }\\n\\n\\n          if(alice == bob) {\\n              return 0; \\n           }\\n\\n           return alice > bob ? 1: -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041567,
                "title": "python-super-easy-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        s = []\\n        for i in range(len(aliceValues)):\\n            s.append((aliceValues[i]+bobValues[i], i))\\n\\n        s.sort(key = lambda x:x[0], reverse= True)\\n\\n        t = 0\\n        a = 0\\n        b = 0\\n        for i in range(len(s)):\\n            if not t:\\n                a +=aliceValues[s[i][1]]\\n            else:\\n                 b +=bobValues[s[i][1]]\\n            t ^=1\\n        if a > b:\\n            return 1\\n        elif a < b:\\n            return -1\\n        return 0\\n\\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        s = []\\n        for i in range(len(aliceValues)):\\n            s.append((aliceValues[i]+bobValues[i], i))\\n\\n        s.sort(key = lambda x:x[0], reverse= True)\\n\\n        t = 0\\n        a = 0\\n        b = 0\\n        for i in range(len(s)):\\n            if not t:\\n                a +=aliceValues[s[i][1]]\\n            else:\\n                 b +=bobValues[s[i][1]]\\n            t ^=1\\n        if a > b:\\n            return 1\\n        elif a < b:\\n            return -1\\n        return 0\\n\\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972087,
                "title": "use-heap-with-alicevalue-bobvalue-beats-65",
                "content": "```\\nimport heapq\\n\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        \"\"\"\\n        When one takes the stone, \\n        they not only get the points, \\n        but they take them away from the other player too.\\n        Greedily choose the stone with the \\n        maximum aliceValues[i] + bobValues[i]\\n        \"\"\"\\n        heap, ALICE, BOB = [], 0, 1\\n        for i, a_v, b_v in zip(range(len(aliceValues)), aliceValues, bobValues):\\n            heapq.heappush(heap, (-(a_v+b_v), i))\\n        alice, bob, turn = 0, 0, 0\\n        while len(heap):\\n            _, idx = heapq.heappop(heap)\\n            if turn == ALICE:\\n                alice+=aliceValues[idx]\\n                turn = BOB\\n            else:\\n                bob+=bobValues[idx]\\n                turn = ALICE\\n        if alice > bob:\\n            return 1\\n        elif bob > alice:\\n            return -1\\n        else:\\n            return 0\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        \"\"\"\\n        When one takes the stone, \\n        they not only get the points, \\n        but they take them away from the other player too.\\n        Greedily choose the stone with the \\n        maximum aliceValues[i] + bobValues[i]\\n        \"\"\"\\n        heap, ALICE, BOB = [], 0, 1\\n        for i, a_v, b_v in zip(range(len(aliceValues)), aliceValues, bobValues):\\n            heapq.heappush(heap, (-(a_v+b_v), i))\\n        alice, bob, turn = 0, 0, 0\\n        while len(heap):\\n            _, idx = heapq.heappop(heap)\\n            if turn == ALICE:\\n                alice+=aliceValues[idx]\\n                turn = BOB\\n            else:\\n                bob+=bobValues[idx]\\n                turn = ALICE\\n        if alice > bob:\\n            return 1\\n        elif bob > alice:\\n            return -1\\n        else:\\n            return 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923351,
                "title": "c",
                "content": "```\\nint cmp(const void* a, const void* b){\\n    int* A = *(int**)a;\\n    int* B = *(int**)b;\\n    return B[1] - A[1];\\n}\\nint stoneGameVI(int* aliceValues, int aliceValuesSize, int* bobValues, int bobValuesSize){\\n    int n = aliceValuesSize;\\n    int** merge = malloc(n * sizeof(int*));\\n    for(int i = 0; i < n; i++){\\n        merge[i] = malloc(2 * sizeof(int));\\n        merge[i][0] = i;\\n        merge[i][1] = aliceValues[i] + bobValues[i];\\n    }\\n    qsort(merge, n , sizeof(int*), cmp);\\n    int score = 0;\\n    for(int i = 0; i < n; i++){\\n        if(i%2 == 0)\\n            score += aliceValues[merge[i][0]];\\n        else\\n            score -= bobValues[merge[i][0]];\\n    }\\n    //free memory\\n    for(int i = 0; i < n; i++){\\n        free(merge[i]);\\n    }\\n    free(merge);\\n    \\n    if(score > 0)\\n        return 1;\\n    else if(score < 0)\\n        return -1;\\n    else\\n        return 0;\\n}\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nint cmp(const void* a, const void* b){\\n    int* A = *(int**)a;\\n    int* B = *(int**)b;\\n    return B[1] - A[1];\\n}\\nint stoneGameVI(int* aliceValues, int aliceValuesSize, int* bobValues, int bobValuesSize){\\n    int n = aliceValuesSize;\\n    int** merge = malloc(n * sizeof(int*));\\n    for(int i = 0; i < n; i++){\\n        merge[i] = malloc(2 * sizeof(int));\\n        merge[i][0] = i;\\n        merge[i][1] = aliceValues[i] + bobValues[i];\\n    }\\n    qsort(merge, n , sizeof(int*), cmp);\\n    int score = 0;\\n    for(int i = 0; i < n; i++){\\n        if(i%2 == 0)\\n            score += aliceValues[merge[i][0]];\\n        else\\n            score -= bobValues[merge[i][0]];\\n    }\\n    //free memory\\n    for(int i = 0; i < n; i++){\\n        free(merge[i]);\\n    }\\n    free(merge);\\n    \\n    if(score > 0)\\n        return 1;\\n    else if(score < 0)\\n        return -1;\\n    else\\n        return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2833561,
                "title": "c-o-1-memory-mutating-inputs-o-nlog-n-runtime-sorting",
                "content": "This solution sort of abuses the fact that the inputs are passed as mutable references.  With const reference inputs, the solution would use O(n) memory.\\n\\n```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n      for (int i = 0; i != aliceValues.size(); ++i) {\\n        aliceValues[i] += bobValues[i];\\n      }\\n      sort(begin(aliceValues), end(aliceValues), std::greater<int>());\\n      int aliceScore = 0;\\n      int bobScore = 0;\\n      for (int i = 0; i != aliceValues.size(); ++i) {\\n        if (i % 2) bobScore += bobValues[i];\\n        else aliceScore += aliceValues[i] - bobValues[i];\\n      }\\n      return aliceScore == bobScore ? 0 : aliceScore < bobScore ? -1 : 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n      for (int i = 0; i != aliceValues.size(); ++i) {\\n        aliceValues[i] += bobValues[i];\\n      }\\n      sort(begin(aliceValues), end(aliceValues), std::greater<int>());\\n      int aliceScore = 0;\\n      int bobScore = 0;\\n      for (int i = 0; i != aliceValues.size(); ++i) {\\n        if (i % 2) bobScore += bobValues[i];\\n        else aliceScore += aliceValues[i] - bobValues[i];\\n      }\\n      return aliceScore == bobScore ? 0 : aliceScore < bobScore ? -1 : 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816773,
                "title": "c-priority-queue-easy-to-understand",
                "content": "1.If there we have stones [1, 100] and [50, 50], the first player should pick [1, 100], resulting in -49 balance (picking the second stone would result in -50 ballance).\\n=\\n ```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& a, vector<int>& b)\\n    {\\n       priority_queue<vector<int>> maxh;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            maxh.push({a[i]+b[i],a[i],b[i]});\\n        }\\n        int av=0,bv=0;\\n        int k=0;\\n        while(maxh.size()>0)\\n        {\\n            vector<int> v=maxh.top();\\n            if(k%2==0)\\n            {\\n                av+=v[1];\\n            }\\n            else\\n            {\\n                bv+=v[2];\\n            }\\n            k++;\\n            maxh.pop();\\n            \\n            \\n        }\\n        if(av==bv)\\n            return 0;\\n        else if(av>bv)\\n            return 1;\\n        else\\n            return -1;\\n    }\\n};\\n```\\nIf you like the solution plz upvote.\\n=",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& a, vector<int>& b)\\n    {\\n       priority_queue<vector<int>> maxh;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            maxh.push({a[i]+b[i],a[i],b[i]});\\n        }\\n        int av=0,bv=0;\\n        int k=0;\\n        while(maxh.size()>0)\\n        {\\n            vector<int> v=maxh.top();\\n            if(k%2==0)\\n            {\\n                av+=v[1];\\n            }\\n            else\\n            {\\n                bv+=v[2];\\n            }\\n            k++;\\n            maxh.pop();\\n            \\n            \\n        }\\n        if(av==bv)\\n            return 0;\\n        else if(av>bv)\\n            return 1;\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814840,
                "title": "easy-and-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        int n = aliceValues.length;\\n        int[][] sums = new int[n][];\\n        for (int i = 0; i < n; i++) {\\n            sums[i] = new int[]{aliceValues[i] + bobValues[i], aliceValues[i], bobValues[i]};\\n        }\\n        Arrays.sort(sums, (a, b) -> Integer.compare(b[0], a[0]));\\n        int a = 0;\\n        int b = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (i % 2 == 0) {\\n                a += sums[i][1];\\n            }\\n            else {\\n                b += sums[i][2];\\n            }\\n        }\\n        if (a > b) {\\n            return 1;\\n        }\\n        else if (a < b) {\\n            return -1;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        int n = aliceValues.length;\\n        int[][] sums = new int[n][];\\n        for (int i = 0; i < n; i++) {\\n            sums[i] = new int[]{aliceValues[i] + bobValues[i], aliceValues[i], bobValues[i]};\\n        }\\n        Arrays.sort(sums, (a, b) -> Integer.compare(b[0], a[0]));\\n        int a = 0;\\n        int b = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (i % 2 == 0) {\\n                a += sums[i][1];\\n            }\\n            else {\\n                b += sums[i][2];\\n            }\\n        }\\n        if (a > b) {\\n            return 1;\\n        }\\n        else if (a < b) {\\n            return -1;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786887,
                "title": "python3-using-sorting",
                "content": "class Solution:\\n\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        li = [[a+b,a,b] for a,b in zip(aliceValues,bobValues)]\\n        li.sort(key = lambda x: (-x[0],-x[1]))\\n        n = len(aliceValues)\\n        alice_score = bob_score = 0\\n        \\n        for i in range(n):\\n            if i%2 == 0:\\n                alice_score+=li[i][1] \\n            else:\\n                bob_score+=li[i][2]\\n                \\n        if alice_score>bob_score:\\n            return 1\\n        elif alice_score<bob_score:\\n            return -1\\n        else:\\n            return 0",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        li = [[a+b,a,b] for a,b in zip(aliceValues,bobValues)]\\n        li.sort(key = lambda x: (-x[0],-x[1]))\\n        n = len(aliceValues)\\n        alice_score = bob_score = 0\\n        \\n        for i in range(n):\\n            if i%2 == 0:\\n                alice_score+=li[i][1] \\n            else:\\n                bob_score+=li[i][2]\\n                \\n        if alice_score>bob_score:\\n            return 1\\n        elif alice_score<bob_score:\\n            return -1\\n        else:\\n            return 0",
                "codeTag": "Java"
            },
            {
                "id": 2756348,
                "title": "simple-and-concise-solution-stone-game",
                "content": "class Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        \\n        int n=aliceValues.length;\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->b[2]-a[2]);\\n        \\n        for(int i=0;i<n;i++){\\n            pq.offer(new int[]{aliceValues[i],bobValues[i],aliceValues[i]+bobValues[i]});\\n        }\\n        int turn=0;\\n        int alice=0;\\n        int bob=0;\\n        while(!pq.isEmpty()){\\n            int nt[]=pq.poll();\\n            if(turn==0){\\n                alice+=nt[0];\\n            }\\n            else{\\n                bob+=nt[1];\\n            }\\n            turn=1-turn;\\n        }\\n        if(alice==bob){\\n            return 0;\\n        }\\n        else if(alice>bob){\\n            return 1;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        \\n        int n=aliceValues.length;\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->b[2]-a[2]);\\n        \\n        for(int i=0;i<n;i++){\\n            pq.offer(new int[]{aliceValues[i],bobValues[i],aliceValues[i]+bobValues[i]}",
                "codeTag": "Java"
            },
            {
                "id": 2714463,
                "title": "alternative-approach-using-maxheap-if-anyone-is-interested",
                "content": "```\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        stones = [(-valA - valB, valA, valB) for valA, valB in zip(aliceValues, bobValues)]\\n        heapify(stones)\\n        aliceScore, bobScore, turn = 0, 0, 0\\n        while stones:\\n            score = heappop(stones)\\n            if not turn % 2:\\n                aliceScore += (score[1])\\n            else:\\n                bobScore += (score[2])\\n            turn += 1\\n        if aliceScore == bobScore:\\n            return 0\\n        elif aliceScore > bobScore:\\n            return 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        stones = [(-valA - valB, valA, valB) for valA, valB in zip(aliceValues, bobValues)]\\n        heapify(stones)\\n        aliceScore, bobScore, turn = 0, 0, 0\\n        while stones:\\n            score = heappop(stones)\\n            if not turn % 2:\\n                aliceScore += (score[1])\\n            else:\\n                bobScore += (score[2])\\n            turn += 1\\n        if aliceScore == bobScore:\\n            return 0\\n        elif aliceScore > bobScore:\\n            return 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706997,
                "title": "easy-c-solution-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& alice, vector<int>& bob) {\\n        priority_queue<pair<int,int>> p;\\n        for(int i = 0;i<alice.size();i++){\\n            p.push({alice[i]+bob[i],alice[i]});\\n        }\\n        int flag = 0;\\n        int a=0,b=0;\\n        while(!p.empty()){\\n            if(!flag){\\n                a+=p.top().second;\\n                flag = 1;\\n                p.pop();\\n            }\\n            else{\\n                b+=p.top().first-p.top().second;\\n                flag = 0;\\n                p.pop();\\n            }\\n        }\\n        return ((a==b)?0:((a>b)?1:-1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& alice, vector<int>& bob) {\\n        priority_queue<pair<int,int>> p;\\n        for(int i = 0;i<alice.size();i++){\\n            p.push({alice[i]+bob[i],alice[i]});\\n        }\\n        int flag = 0;\\n        int a=0,b=0;\\n        while(!p.empty()){\\n            if(!flag){\\n                a+=p.top().second;\\n                flag = 1;\\n                p.pop();\\n            }\\n            else{\\n                b+=p.top().first-p.top().second;\\n                flag = 0;\\n                p.pop();\\n            }\\n        }\\n        return ((a==b)?0:((a>b)?1:-1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2639551,
                "title": "i-got-this-from-some-blog-dp-is-tle",
                "content": "```class Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        lst = []\\n\\t\\t# \\n        for i in range(len(aliceValues)):\\n            lst.append([aliceValues[i] + bobValues[i],i])\\n        lst.sort(reverse = True)\\n        bob = 0\\n        alice = 0\\n        p = True\\n        for i in lst:\\n            idx = i[1]\\n            if p:\\n                alice += aliceValues[idx]\\n                p = False\\n                continue\\n            else:\\n                bob +=  bobValues[idx]\\n                p = True\\n                continue\\n        if alice == bob:\\n            return 0\\n        elif alice > bob:\\n            return 1\\n        else:\\n            return -1```",
                "solutionTags": [],
                "code": "```class Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        lst = []\\n\\t\\t# \\n        for i in range(len(aliceValues)):\\n            lst.append([aliceValues[i] + bobValues[i],i])\\n        lst.sort(reverse = True)\\n        bob = 0\\n        alice = 0\\n        p = True\\n        for i in lst:\\n            idx = i[1]\\n            if p:\\n                alice += aliceValues[idx]\\n                p = False\\n                continue\\n            else:\\n                bob +=  bobValues[idx]\\n                p = True\\n                continue\\n        if alice == bob:\\n            return 0\\n        elif alice > bob:\\n            return 1\\n        else:\\n            return -1```",
                "codeTag": "Java"
            },
            {
                "id": 2619662,
                "title": "golang-s-best-solution-435ms-beats-100-double-heap",
                "content": "```\\n\\nfunc stoneGameVI(aliceValues []int, bobValues []int) int {\\n\\tn := len(aliceValues)\\n\\n\\taliceHeap := HeapStone{}\\n\\tbobHeap := HeapStone{}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\theap.Push(&aliceHeap, Stone{index: i, value: aliceValues[i], other: bobValues[i]})\\n\\t\\theap.Push(&bobHeap, Stone{index: i, value: bobValues[i], other: aliceValues[i]})\\n\\t}\\n\\n\\ttakenStone := make([]bool, n)\\n\\taliceScore := 0\\n\\tbobScore := 0\\n    \\n    for i := 0; i < n; i++ {\\n        if i % 2 == 0 {\\n            if takenStone[aliceHeap[0].index] == true {\\n                heap.Pop(&aliceHeap)\\n            }\\n\\n            aliceStone := heap.Pop(&aliceHeap).(Stone)\\n\\n            // fmt.Printf(\"alice choose stone %+v\\\\n\", aliceStone)\\n\\n            takenStone[aliceStone.index] = true\\n            aliceScore += aliceStone.value\\n        } else {\\n            for takenStone[bobHeap[0].index] == true {\\n                heap.Pop(&bobHeap)\\n            }\\n\\n            bobStone := heap.Pop(&bobHeap).(Stone)\\n\\n            // fmt.Printf(\"bob choose stone %+v\\\\n\", bobStone)\\n\\n            takenStone[bobStone.index] = true\\n            bobScore += bobStone.value\\n        }\\n    }\\n\\n\\t// fmt.Printf(\"aliceScore = %d, bobScore = %d\\\\n\", aliceScore, bobScore)\\n\\n\\tif aliceScore > bobScore {\\n\\t\\treturn 1\\n\\t}\\n\\n\\tif aliceScore < bobScore {\\n\\t\\treturn -1\\n\\t}\\n\\n\\treturn 0\\n}\\n\\ntype Stone struct {\\n\\tindex int\\n\\tvalue int\\n\\tother int\\n}\\n\\ntype HeapStone []Stone\\n\\nfunc (h HeapStone) Len() int           { return len(h) }\\nfunc (h HeapStone) Less(i, j int) bool { return h[i].value+h[i].other > h[j].value+h[j].other }\\nfunc (h HeapStone) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *HeapStone) Push(x interface{}) {\\n\\t*h = append(*h, x.(Stone))\\n}\\n\\nfunc (h *HeapStone) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n```\\n",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nfunc stoneGameVI(aliceValues []int, bobValues []int) int {\\n\\tn := len(aliceValues)\\n\\n\\taliceHeap := HeapStone{}\\n\\tbobHeap := HeapStone{}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\theap.Push(&aliceHeap, Stone{index: i, value: aliceValues[i], other: bobValues[i]})\\n\\t\\theap.Push(&bobHeap, Stone{index: i, value: bobValues[i], other: aliceValues[i]})\\n\\t}\\n\\n\\ttakenStone := make([]bool, n)\\n\\taliceScore := 0\\n\\tbobScore := 0\\n    \\n    for i := 0; i < n; i++ {\\n        if i % 2 == 0 {\\n            if takenStone[aliceHeap[0].index] == true {\\n                heap.Pop(&aliceHeap)\\n            }\\n\\n            aliceStone := heap.Pop(&aliceHeap).(Stone)\\n\\n            // fmt.Printf(\"alice choose stone %+v\\\\n\", aliceStone)\\n\\n            takenStone[aliceStone.index] = true\\n            aliceScore += aliceStone.value\\n        } else {\\n            for takenStone[bobHeap[0].index] == true {\\n                heap.Pop(&bobHeap)\\n            }\\n\\n            bobStone := heap.Pop(&bobHeap).(Stone)\\n\\n            // fmt.Printf(\"bob choose stone %+v\\\\n\", bobStone)\\n\\n            takenStone[bobStone.index] = true\\n            bobScore += bobStone.value\\n        }\\n    }\\n\\n\\t// fmt.Printf(\"aliceScore = %d, bobScore = %d\\\\n\", aliceScore, bobScore)\\n\\n\\tif aliceScore > bobScore {\\n\\t\\treturn 1\\n\\t}\\n\\n\\tif aliceScore < bobScore {\\n\\t\\treturn -1\\n\\t}\\n\\n\\treturn 0\\n}\\n\\ntype Stone struct {\\n\\tindex int\\n\\tvalue int\\n\\tother int\\n}\\n\\ntype HeapStone []Stone\\n\\nfunc (h HeapStone) Len() int           { return len(h) }\\nfunc (h HeapStone) Less(i, j int) bool { return h[i].value+h[i].other > h[j].value+h[j].other }\\nfunc (h HeapStone) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *HeapStone) Push(x interface{}) {\\n\\t*h = append(*h, x.(Stone))\\n}\\n\\nfunc (h *HeapStone) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2589440,
                "title": "java-sorting",
                "content": "\\tpublic int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        int n = aliceValues.length;\\n        \\n        int[][] vals = new int[n][3];\\n        for(int i=0; i<n; i++) {\\n            vals[i][0] = aliceValues[i]+bobValues[i];\\n            vals[i][1] = aliceValues[i];\\n            vals[i][2] = bobValues[i];\\n        }\\n        \\n        Arrays.sort(vals, (a, b) -> b[0]-a[0]);\\n        int asum = 0, bsum = 0;\\n        for(int i=0; i<n; i++) {\\n            if(i%2==0) {\\n                asum += vals[i][1];\\n            } else {\\n                bsum += vals[i][2];\\n            }\\n        }\\n        \\n        int diff = asum - bsum;\\n        return diff != 0 ? diff/Math.abs(diff) : 0;\\n    }",
                "solutionTags": [],
                "code": "\\tpublic int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        int n = aliceValues.length;\\n        \\n        int[][] vals = new int[n][3];\\n        for(int i=0; i<n; i++) {\\n            vals[i][0] = aliceValues[i]+bobValues[i];\\n            vals[i][1] = aliceValues[i];\\n            vals[i][2] = bobValues[i];\\n        }\\n        \\n        Arrays.sort(vals, (a, b) -> b[0]-a[0]);\\n        int asum = 0, bsum = 0;\\n        for(int i=0; i<n; i++) {\\n            if(i%2==0) {\\n                asum += vals[i][1];\\n            } else {\\n                bsum += vals[i][2];\\n            }\\n        }\\n        \\n        int diff = asum - bsum;\\n        return diff != 0 ? diff/Math.abs(diff) : 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2575391,
                "title": "c-game-theory-greedy",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int stoneGameVI(vector<int> &aliceValues, vector<int> &bobValues)\\n    {\\n\\n        int n = aliceValues.size();\\n\\n        vector<vector<int>> v;\\n\\n        for (int i = 0; i < n; i++)\\n            v.push_back({aliceValues[i] + bobValues[i], aliceValues[i], bobValues[i]});\\n\\n        sort(v.begin(), v.end());\\n        reverse(v.begin(), v.end());\\n\\n        int a_score = 0, b_score = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i % 2)\\n                b_score += v[i][2];\\n            else\\n                a_score += v[i][1];\\n        }\\n        \\n        if (a_score > b_score)\\n            return 1;\\n        else if (a_score < b_score)\\n            return -1;\\n        return 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution\\n{\\npublic:\\n    int stoneGameVI(vector<int> &aliceValues, vector<int> &bobValues)\\n    {\\n\\n        int n = aliceValues.size();\\n\\n        vector<vector<int>> v;\\n\\n        for (int i = 0; i < n; i++)\\n            v.push_back({aliceValues[i] + bobValues[i], aliceValues[i], bobValues[i]}",
                "codeTag": "Java"
            },
            {
                "id": 2562361,
                "title": "c-greedy-game-theory-easy-to-understand",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int stoneGameVI(vector<int> &aliceValues, vector<int> &bobValues)\\n    {\\n\\n        int n = aliceValues.size();\\n\\n        vector<vector<int>> v;\\n\\n        for (int i = 0; i < n; i++)\\n            v.push_back({aliceValues[i] + bobValues[i], aliceValues[i], bobValues[i]});\\n\\n        sort(v.begin(), v.end());\\n        reverse(v.begin(), v.end());\\n\\n        int a_score = 0, b_score = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i % 2)\\n                b_score += v[i][2];\\n            else\\n                a_score += v[i][1];\\n        }\\n        \\n        if (a_score > b_score)\\n            return 1;\\n        else if (a_score < b_score)\\n            return -1;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int stoneGameVI(vector<int> &aliceValues, vector<int> &bobValues)\\n    {\\n\\n        int n = aliceValues.size();\\n\\n        vector<vector<int>> v;\\n\\n        for (int i = 0; i < n; i++)\\n            v.push_back({aliceValues[i] + bobValues[i], aliceValues[i], bobValues[i]});\\n\\n        sort(v.begin(), v.end());\\n        reverse(v.begin(), v.end());\\n\\n        int a_score = 0, b_score = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i % 2)\\n                b_score += v[i][2];\\n            else\\n                a_score += v[i][1];\\n        }\\n        \\n        if (a_score > b_score)\\n            return 1;\\n        else if (a_score < b_score)\\n            return -1;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551800,
                "title": "kotlin-very-fast-solution-with-map",
                "content": "Runtime: 1968 ms, faster than 100.00% of Kotlin online submissions for Stone Game VI.\\nMemory Usage: 120 MB, less than 100.00% of Kotlin online submissions for Stone Game VI.\\n\\n```\\n    fun stoneGameVI(aliceValues: IntArray, bobValues: IntArray): Int {\\n        val maximumsList = aliceValues.mapIndexed { index, i -> i + bobValues[index] }\\n        val map = mutableMapOf<Int, Int>()\\n        maximumsList.forEachIndexed { index, i -> map[index] = i }\\n        var sumAlice = 0\\n        var sumBob = 0\\n        map.entries.sortedByDescending { it.value }.forEachIndexed { index, mutableEntry ->\\n            if (index % 2 == 0) {\\n                sumAlice += aliceValues[mutableEntry.key]\\n            } else {\\n                sumBob += bobValues[mutableEntry.key]\\n            }\\n        }\\n        return when {\\n            sumAlice > sumBob -> 1\\n            sumAlice < sumBob -> -1\\n            else -> 0\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    fun stoneGameVI(aliceValues: IntArray, bobValues: IntArray): Int {\\n        val maximumsList = aliceValues.mapIndexed { index, i -> i + bobValues[index] }\\n        val map = mutableMapOf<Int, Int>()\\n        maximumsList.forEachIndexed { index, i -> map[index] = i }\\n        var sumAlice = 0\\n        var sumBob = 0\\n        map.entries.sortedByDescending { it.value }.forEachIndexed { index, mutableEntry ->\\n            if (index % 2 == 0) {\\n                sumAlice += aliceValues[mutableEntry.key]\\n            } else {\\n                sumBob += bobValues[mutableEntry.key]\\n            }\\n        }\\n        return when {\\n            sumAlice > sumBob -> 1\\n            sumAlice < sumBob -> -1\\n            else -> 0\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2547679,
                "title": "explained-solution-with-tests-to-experiment-and-debug-python-3",
                "content": "```\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        \"\"\"\\n        https://leetcode.com/problems/stone-game-vi/\\n\\n        There are n stones.\\n        Players take any stone in each turn and gain the points according to the stones index in their values.\\n        Alice starts.\\n        Both play optimally.\\n\\n        The stones are not ordered, which is a very important pont.\\n        The value to each player is how much they gain plus how much they prevent the other player to gain by taking the stone.\\n        That is because the value taken by the other player is a stone that the first player has to gain elsewhere to win.\\n        So the game value of the stone i for Alice is F = aliceValues[i] + bobValue[i]\\n\\n        Since the players play against each other. They always try to take the biggest game value.\\n        \"\"\"\\n\\n        # Alice and Bob results\\n        results = [0, 0]\\n        # Sort by the sum - the game value of the stone to each player.\\n        for i, value in enumerate(sorted(zip(aliceValues, bobValues), key=lambda x: x[0] + x[1], reverse=True)):\\n            # Assign to the player, who is on the turn.\\n            player_index = i % 2\\n            results[player_index] += value[player_index]\\n\\n        return sign(results[0] - results[1])\\n\\n\\ndef sign(a):\\n    return bool(a > 0) - bool(a < 0)\\n\\n\\nassert Solution().stoneGameVI(\\n    [69, 36, 42, 96, 61, 80, 74, 75, 75, 26, 34, 73, 22, 53, 13, 88, 73, 26, 78, 1, 12, 39, 51, 10, 21, 97, 85, 98, 41,],\\n    [73, 37, 39, 75, 98, 88, 53, 13, 96, 73, 51, 26, 92, 74, 75, 80, 69, 97, 1, 78, 85, 42, 34, 41, 48, 26, 12, 61, 10,]\\n) == 1\\n\\nassert Solution().stoneGameVI(\\n    [69, 36, 42, 96, 61, 80, 74, 75, 75, 26, 34, 73, 22, 53, 13, 88, 73, 26, 78, 1, 12, 39, 51, 10, 21, 97, 85, 98, 41,\\n     92, 48, 37],\\n    [73, 37, 39, 75, 98, 88, 53, 13, 96, 73, 51, 26, 92, 74, 75, 80, 69, 97, 1, 78, 85, 42, 34, 41, 48, 26, 12, 61, 10,\\n     22, 21, 36]\\n) == 0\\nassert Solution().stoneGameVI([8], [8]) == 1\\nassert Solution().stoneGameVI([1,2], [3,1]) == 0\\nassert Solution().stoneGameVI([1, 3], [2, 1]) == 1\\nassert Solution().stoneGameVI([2,4,3], [1,6,7]) == -1\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        \"\"\"\\n        https://leetcode.com/problems/stone-game-vi/\\n\\n        There are n stones.\\n        Players take any stone in each turn and gain the points according to the stones index in their values.\\n        Alice starts.\\n        Both play optimally.\\n\\n        The stones are not ordered, which is a very important pont.\\n        The value to each player is how much they gain plus how much they prevent the other player to gain by taking the stone.\\n        That is because the value taken by the other player is a stone that the first player has to gain elsewhere to win.\\n        So the game value of the stone i for Alice is F = aliceValues[i] + bobValue[i]\\n\\n        Since the players play against each other. They always try to take the biggest game value.\\n        \"\"\"\\n\\n        # Alice and Bob results\\n        results = [0, 0]\\n        # Sort by the sum - the game value of the stone to each player.\\n        for i, value in enumerate(sorted(zip(aliceValues, bobValues), key=lambda x: x[0] + x[1], reverse=True)):\\n            # Assign to the player, who is on the turn.\\n            player_index = i % 2\\n            results[player_index] += value[player_index]\\n\\n        return sign(results[0] - results[1])\\n\\n\\ndef sign(a):\\n    return bool(a > 0) - bool(a < 0)\\n\\n\\nassert Solution().stoneGameVI(\\n    [69, 36, 42, 96, 61, 80, 74, 75, 75, 26, 34, 73, 22, 53, 13, 88, 73, 26, 78, 1, 12, 39, 51, 10, 21, 97, 85, 98, 41,],\\n    [73, 37, 39, 75, 98, 88, 53, 13, 96, 73, 51, 26, 92, 74, 75, 80, 69, 97, 1, 78, 85, 42, 34, 41, 48, 26, 12, 61, 10,]\\n) == 1\\n\\nassert Solution().stoneGameVI(\\n    [69, 36, 42, 96, 61, 80, 74, 75, 75, 26, 34, 73, 22, 53, 13, 88, 73, 26, 78, 1, 12, 39, 51, 10, 21, 97, 85, 98, 41,\\n     92, 48, 37],\\n    [73, 37, 39, 75, 98, 88, 53, 13, 96, 73, 51, 26, 92, 74, 75, 80, 69, 97, 1, 78, 85, 42, 34, 41, 48, 26, 12, 61, 10,\\n     22, 21, 36]\\n) == 0\\nassert Solution().stoneGameVI([8], [8]) == 1\\nassert Solution().stoneGameVI([1,2], [3,1]) == 0\\nassert Solution().stoneGameVI([1, 3], [2, 1]) == 1\\nassert Solution().stoneGameVI([2,4,3], [1,6,7]) == -1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507993,
                "title": "sortedmap-stack-approach-faster-than-81-02",
                "content": "```\\nimport java.util.SortedMap;\\nclass Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        SortedMap<Integer,List<List<Integer>>> hashMap = new TreeMap();\\n        for(int i = 0; i < aliceValues.length; i++){\\n            List<Integer> temp = new ArrayList();\\n            temp.add(aliceValues[i]);\\n            temp.add(bobValues[i]);\\n            if(hashMap.get(aliceValues[i] + bobValues[i]) != null){\\n                hashMap.get(aliceValues[i] + bobValues[i]).add(temp);\\n                continue;\\n            } else{\\n                hashMap.put(aliceValues[i] + bobValues[i], new ArrayList());\\n            }\\n            hashMap.get(aliceValues[i] + bobValues[i]).add(temp);\\n        }\\n        int index = 0;\\n        int a = 0;\\n        int b =0;\\n        Stack<Integer> stack = new Stack();\\n        for(Map.Entry<Integer,List<List<Integer>>> entry: hashMap.entrySet()){\\n            stack.push(entry.getKey());\\n        }\\n        while(!stack.isEmpty()){\\n            int key = stack.peek();\\n            List<List<Integer>> tList = hashMap.get(key);\\n            if( index % 2 == 0){\\n            a = a + tList.get(0).get(0);\\n\\n            tList.remove(0);\\n            } else{\\n                            \\n            b = b + tList.get(tList.size()-1).get(1);\\n\\n            tList.remove(tList.size()-1);\\n            \\n            }\\n            if(tList == null || tList.isEmpty()){\\n                stack.pop();\\n            }\\n            index++;\\n        }\\n        if(a>b){\\n            return 1;\\n        } else if(b>a){\\n            return -1;\\n        } else{\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.SortedMap;\\nclass Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        SortedMap<Integer,List<List<Integer>>> hashMap = new TreeMap();\\n        for(int i = 0; i < aliceValues.length; i++){\\n            List<Integer> temp = new ArrayList();\\n            temp.add(aliceValues[i]);\\n            temp.add(bobValues[i]);\\n            if(hashMap.get(aliceValues[i] + bobValues[i]) != null){\\n                hashMap.get(aliceValues[i] + bobValues[i]).add(temp);\\n                continue;\\n            } else{\\n                hashMap.put(aliceValues[i] + bobValues[i], new ArrayList());\\n            }\\n            hashMap.get(aliceValues[i] + bobValues[i]).add(temp);\\n        }\\n        int index = 0;\\n        int a = 0;\\n        int b =0;\\n        Stack<Integer> stack = new Stack();\\n        for(Map.Entry<Integer,List<List<Integer>>> entry: hashMap.entrySet()){\\n            stack.push(entry.getKey());\\n        }\\n        while(!stack.isEmpty()){\\n            int key = stack.peek();\\n            List<List<Integer>> tList = hashMap.get(key);\\n            if( index % 2 == 0){\\n            a = a + tList.get(0).get(0);\\n\\n            tList.remove(0);\\n            } else{\\n                            \\n            b = b + tList.get(tList.size()-1).get(1);\\n\\n            tList.remove(tList.size()-1);\\n            \\n            }\\n            if(tList == null || tList.isEmpty()){\\n                stack.pop();\\n            }\\n            index++;\\n        }\\n        if(a>b){\\n            return 1;\\n        } else if(b>a){\\n            return -1;\\n        } else{\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2505871,
                "title": "java-2-solutions-1-max-heap-faster-than-30-2-sorting-faster-than-90",
                "content": "1.Max-Heap\\n\\n```\\nclass Solution {\\n    class Pair implements Comparable<Pair>\\n    {\\n        int index;\\n        int sum;\\n        public Pair(int n,int v)\\n        {\\n            index=n;\\n            sum=v;\\n        }\\n        public int compareTo(Pair p)\\n        {\\n            if(p.sum>sum)\\n                return 1;\\n            else\\n                return -1;\\n        }\\n    }\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        PriorityQueue<Pair> pq=new PriorityQueue<>();\\n        for(int i=0;i<aliceValues.length;i++)\\n        {\\n            pq.add(new Pair(i,aliceValues[i]+bobValues[i]));\\n        }\\n        int flag=0,sum=0;\\n        while(!pq.isEmpty())\\n        {\\n            Pair p=pq.poll();\\n            if(flag%2==0)\\n            {\\n                sum+=p.sum-bobValues[p.index];\\n                flag++;\\n            }\\n            else\\n            {\\n                sum-=(p.sum-aliceValues[p.index]);\\n                flag++;\\n            }\\n        }\\n        if(sum==0)\\n            return 0;\\n        else if(sum>0)\\n            return 1;\\n        else\\n            return -1;\\n    }\\n}\\n```\\nsolution 2:\\n\\n```\\nclass Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        int[][] arr=new int[aliceValues.length][3];\\n        int n=aliceValues.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            arr[i][0]=aliceValues[i]+bobValues[i];\\n            arr[i][1]=aliceValues[i];\\n            arr[i][2]=bobValues[i];\\n        }\\n        Arrays.sort(arr, (a,b) -> b[0]-a[0]);\\n        int a=0,b=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%2==0)\\n            {\\n                a+=arr[i][1];\\n            }\\n            else\\n            {\\n                b+=arr[i][2];\\n            }\\n        }\\n        return Integer.compare(a,b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    class Pair implements Comparable<Pair>\\n    {\\n        int index;\\n        int sum;\\n        public Pair(int n,int v)\\n        {\\n            index=n;\\n            sum=v;\\n        }\\n        public int compareTo(Pair p)\\n        {\\n            if(p.sum>sum)\\n                return 1;\\n            else\\n                return -1;\\n        }\\n    }\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        PriorityQueue<Pair> pq=new PriorityQueue<>();\\n        for(int i=0;i<aliceValues.length;i++)\\n        {\\n            pq.add(new Pair(i,aliceValues[i]+bobValues[i]));\\n        }\\n        int flag=0,sum=0;\\n        while(!pq.isEmpty())\\n        {\\n            Pair p=pq.poll();\\n            if(flag%2==0)\\n            {\\n                sum+=p.sum-bobValues[p.index];\\n                flag++;\\n            }\\n            else\\n            {\\n                sum-=(p.sum-aliceValues[p.index]);\\n                flag++;\\n            }\\n        }\\n        if(sum==0)\\n            return 0;\\n        else if(sum>0)\\n            return 1;\\n        else\\n            return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        int[][] arr=new int[aliceValues.length][3];\\n        int n=aliceValues.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            arr[i][0]=aliceValues[i]+bobValues[i];\\n            arr[i][1]=aliceValues[i];\\n            arr[i][2]=bobValues[i];\\n        }\\n        Arrays.sort(arr, (a,b) -> b[0]-a[0]);\\n        int a=0,b=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%2==0)\\n            {\\n                a+=arr[i][1];\\n            }\\n            else\\n            {\\n                b+=arr[i][2];\\n            }\\n        }\\n        return Integer.compare(a,b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500021,
                "title": "c-greedy",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstatic bool cmp(array<int , 3> a , array<int , 3> b){\\n\\t\\t\\treturn (a[0] == b[0]) ? a[1] > b[1] : a[0] > b[0];\\n\\t\\t}\\n\\n\\t\\tint stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n\\t\\t\\tvector<array<int, 3>> v(aliceValues.size());\\n\\t\\t\\tfor(int i = 0 ; i < aliceValues.size() ; i++){\\n\\t\\t\\t\\tv[i][0] = aliceValues[i] + bobValues[i];\\n\\t\\t\\t\\tv[i][1] = aliceValues[i];\\n\\t\\t\\t\\tv[i][2] = bobValues[i];\\n\\t\\t\\t}\\n\\n\\t\\t\\tsort(v.begin() , v.end() , cmp);\\n\\t\\t\\tint a = 0 , b = 0;\\n\\t\\t\\tfor(int i = 0 ; i < aliceValues.size() ; i++){\\n\\t\\t\\t\\t(i&1) ? b += v[i][2] : a += v[i][1];\\n\\t\\t\\t}\\n\\t\\t\\treturn (a == b) ? 0 : ((a - b > 0) ? 1 : -1);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstatic bool cmp(array<int , 3> a , array<int , 3> b){\\n\\t\\t\\treturn (a[0] == b[0]) ? a[1] > b[1] : a[0] > b[0];\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2493760,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def stoneGameVI(self, a, b):\\n        \"\"\"\\n        :type aliceValues: List[int]\\n        :type bobValues: List[int]\\n        :rtype: int\\n        \"\"\"\\n        l=len(a)\\n        v=[0]*l\\n        d={}\\n        for i in range(l):\\n            val=a[i]+b[i]\\n            v[i]=val\\n            if(val in d):\\n                d[val].append(i)\\n            else:\\n                d[val]=[i]\\n        s1=0\\n        s2=0\\n        v.sort(reverse=True)\\n        for i in range(l):\\n            m=d[v[i]].pop(0)\\n            if(i%2==0):\\n                s1+=a[m]\\n            else:\\n                s2+=b[m]\\n        if(s1>s2):\\n            return 1\\n        elif(s1<s2):\\n            return -1\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def stoneGameVI(self, a, b):\\n        \"\"\"\\n        :type aliceValues: List[int]\\n        :type bobValues: List[int]\\n        :rtype: int\\n        \"\"\"\\n        l=len(a)\\n        v=[0]*l\\n        d={}\\n        for i in range(l):\\n            val=a[i]+b[i]\\n            v[i]=val\\n            if(val in d):\\n                d[val].append(i)\\n            else:\\n                d[val]=[i]\\n        s1=0\\n        s2=0\\n        v.sort(reverse=True)\\n        for i in range(l):\\n            m=d[v[i]].pop(0)\\n            if(i%2==0):\\n                s1+=a[m]\\n            else:\\n                s2+=b[m]\\n        if(s1>s2):\\n            return 1\\n        elif(s1<s2):\\n            return -1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491775,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    int stoneGameVI(vector<int>& a, vector<int>& b)\\n    {\\n        \\n        priority_queue <pair<int,int>,vector<pair<int,int>>> pq;\\n        \\n        for(int i=0; i<b.size(); i++)\\n        {\\n            pq.push({a[i] + b[i], i});\\n        }\\n        \\n        bool turn = true;\\n        \\n        int n1 = 0, n2 = 0;\\n        \\n        while(!pq.empty())\\n        {\\n            if(turn)\\n            {\\n                n1 += a[pq.top().second];\\n                pq.pop();\\n            }\\n            else if(!turn)\\n            {\\n                n2 += b[pq.top().second];\\n                pq.pop();\\n                \\n            }\\n            \\n            turn = !turn;\\n        }\\n        \\n        if(n1 > n2)\\n        {\\n            return 1;\\n        }\\n        else if(n2 > n1)\\n        {\\n            return -1;\\n        }\\n        \\n        return 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int stoneGameVI(vector<int>& a, vector<int>& b)\\n    {\\n        \\n        priority_queue <pair<int,int>,vector<pair<int,int>>> pq;\\n        \\n        for(int i=0; i<b.size(); i++)\\n        {\\n            pq.push({a[i] + b[i], i}",
                "codeTag": "Java"
            },
            {
                "id": 2474263,
                "title": "greedy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    static bool cmp(vector<int> &a,vector<int> &b)\\n    {\\n        if(a[0]==b[0])return a[1]>b[1];\\n        return a[0]>b[0];\\n    }\\n    \\n    int stoneGameVI(vector<int>& av, vector<int>& bv) {\\n        int n = av.size();\\n        \\n        vector<vector<int>> v;\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            v.push_back({av[i]+bv[i],av[i],bv[i]});\\n        }\\n        \\n        sort(v.begin(),v.end(),cmp);\\n        \\n        \\n        int a = 0,b = 0;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(i%2==0)\\n                a+= v[i][1];\\n            else \\n                b += v[i][2];\\n        }\\n        \\n        if(a==b)return 0;\\n        if(a>b)return 1;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool cmp(vector<int> &a,vector<int> &b)\\n    {\\n        if(a[0]==b[0])return a[1]>b[1];\\n        return a[0]>b[0];\\n    }\\n    \\n    int stoneGameVI(vector<int>& av, vector<int>& bv) {\\n        int n = av.size();\\n        \\n        vector<vector<int>> v;\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            v.push_back({av[i]+bv[i],av[i],bv[i]});\\n        }\\n        \\n        sort(v.begin(),v.end(),cmp);\\n        \\n        \\n        int a = 0,b = 0;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(i%2==0)\\n                a+= v[i][1];\\n            else \\n                b += v[i][2];\\n        }\\n        \\n        if(a==b)return 0;\\n        if(a>b)return 1;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386356,
                "title": "c-greedy",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>&a, vector<int>&b) {\\n        int n=a.size();\\n        vector<pair<int,int>>hold(n);\\n        for(int i=0;i<n;i++) hold[i]={a[i]+b[i],i};\\n        sort(hold.rbegin(),hold.rend());\\n        int alice=0,bob=0;\\n        for(int i=0;i<n;i++){\\n            if(i%2==0) alice+=a[hold[i].second];\\n            else bob+=b[hold[i].second];\\n        }\\n        if(alice>bob) return 1;\\n        else if(alice==bob) return 0;\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int stoneGameVI(vector<int>&a, vector<int>&b) {\\n        int n=a.size();\\n        vector<pair<int,int>>hold(n);\\n        for(int i=0;i<n;i++) hold[i]={a[i]+b[i],i}",
                "codeTag": "Java"
            },
            {
                "id": 2343085,
                "title": "priorityqueue-maxheap-java-solution-220ms",
                "content": "```\\nclass Solution {\\n    \\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n     int result=0;\\n     int aliceScore=0;\\n     int bobScore=0;\\n     Queue<Stone> queueAlice=new PriorityQueue<>((a,b)->b.sum-a.sum); \\n     queueAlice.addAll(IntStream\\n                       .range(0,aliceValues.length)\\n                       .parallel()\\n                       .mapToObj(e->new Stone(aliceValues[e],bobValues[e]))\\n                       .collect(Collectors.toList())); \\n     boolean aliceTurn=true;\\n     while(!queueAlice.isEmpty())\\n     { \\n        Stone stone=queueAlice.poll();\\n        if(aliceTurn)\\n        {\\n           aliceScore+=stone.aliceStone; \\n        }   \\n        else\\n        {\\n           bobScore+=stone.bobStone;  \\n        } \\n        aliceTurn=!aliceTurn;\\n     }\\n        \\n     if(aliceScore==bobScore)\\n        return 0; \\n        \\n     return (aliceScore>bobScore)?1:-1;\\n    }\\n    class Stone{\\n        public int aliceStone;\\n        public int bobStone;\\n        public int sum;\\n        public Stone(int aliceStone,int bobStone)\\n        {\\n            this.aliceStone=aliceStone;\\n            this.bobStone=bobStone;\\n            this.sum=aliceStone+bobStone;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n     int result=0;\\n     int aliceScore=0;\\n     int bobScore=0;\\n     Queue<Stone> queueAlice=new PriorityQueue<>((a,b)->b.sum-a.sum); \\n     queueAlice.addAll(IntStream\\n                       .range(0,aliceValues.length)\\n                       .parallel()\\n                       .mapToObj(e->new Stone(aliceValues[e],bobValues[e]))\\n                       .collect(Collectors.toList())); \\n     boolean aliceTurn=true;\\n     while(!queueAlice.isEmpty())\\n     { \\n        Stone stone=queueAlice.poll();\\n        if(aliceTurn)\\n        {\\n           aliceScore+=stone.aliceStone; \\n        }   \\n        else\\n        {\\n           bobScore+=stone.bobStone;  \\n        } \\n        aliceTurn=!aliceTurn;\\n     }\\n        \\n     if(aliceScore==bobScore)\\n        return 0; \\n        \\n     return (aliceScore>bobScore)?1:-1;\\n    }\\n    class Stone{\\n        public int aliceStone;\\n        public int bobStone;\\n        public int sum;\\n        public Stone(int aliceStone,int bobStone)\\n        {\\n            this.aliceStone=aliceStone;\\n            this.bobStone=bobStone;\\n            this.sum=aliceStone+bobStone;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336511,
                "title": "python3-simple-combined-sum",
                "content": "```\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        combined_values = sorted([aliceValues[i] + bobValues[i] for i in range(len(aliceValues))], reverse=True)\\n        i = 0\\n        j = 1\\n        alice = 0\\n        bob = 0\\n        while i < len(combined_values):\\n            alice += combined_values[i]\\n            i += 2\\n        while j < len(combined_values):\\n            bob += combined_values[j]\\n            j += 2\\n        \\n        score = alice - bob\\n        imbalance = sum(bobValues) - sum(aliceValues)\\n        \\n        if score > imbalance: \\n            return 1 \\n        elif score < imbalance: \\n            return -1 \\n        else: \\n            return 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        combined_values = sorted([aliceValues[i] + bobValues[i] for i in range(len(aliceValues))], reverse=True)\\n        i = 0\\n        j = 1\\n        alice = 0\\n        bob = 0\\n        while i < len(combined_values):\\n            alice += combined_values[i]\\n            i += 2\\n        while j < len(combined_values):\\n            bob += combined_values[j]\\n            j += 2\\n        \\n        score = alice - bob\\n        imbalance = sum(bobValues) - sum(aliceValues)\\n        \\n        if score > imbalance: \\n            return 1 \\n        elif score < imbalance: \\n            return -1 \\n        else: \\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333177,
                "title": "simple-easy-approach-greedy-priority-queue",
                "content": "pls upvote :)\\n```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        priority_queue<pair<int,int>>pq;\\n        for(int i=0;i<aliceValues.size();i++)\\n        {\\n            pq.push({aliceValues[i]+bobValues[i],i});\\n        }\\n        int flag=0;\\n        int sum1=0,sum2=0;\\n        while(!pq.empty())\\n        {\\n            pair<int,int>it=pq.top();\\n            pq.pop();\\n            if(flag==0)\\n            {\\n                sum1=sum1+(it.first-bobValues[it.second]);\\n                flag=1;\\n            }\\n            else if(flag==1)\\n            {\\n                sum2=sum2+(it.first-aliceValues[it.second]);\\n                flag=0;\\n            }\\n        }\\n        if(sum1>sum2)\\n        {\\n            return 1;\\n        }\\n        else if(sum1<sum2)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        priority_queue<pair<int,int>>pq;\\n        for(int i=0;i<aliceValues.size();i++)\\n        {\\n            pq.push({aliceValues[i]+bobValues[i],i});\\n        }\\n        int flag=0;\\n        int sum1=0,sum2=0;\\n        while(!pq.empty())\\n        {\\n            pair<int,int>it=pq.top();\\n            pq.pop();\\n            if(flag==0)\\n            {\\n                sum1=sum1+(it.first-bobValues[it.second]);\\n                flag=1;\\n            }\\n            else if(flag==1)\\n            {\\n                sum2=sum2+(it.first-aliceValues[it.second]);\\n                flag=0;\\n            }\\n        }\\n        if(sum1>sum2)\\n        {\\n            return 1;\\n        }\\n        else if(sum1<sum2)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2314168,
                "title": "greedy-problems-can-be-elusive-they-are-not-simple",
                "content": "## My comments on Greedy\\nI sometimes find other difficult topics like DP and backtracking easier compared to the Greedy class of problems. I managed to solve other Stone Game problems (before I solved this one) which were much more harder than this one. But Greedy problems can be elusive and this problem is evidence of that. I tried this problem for a long time. The problem with greedy problems is - you have to find the right strategy. Unlike DP and backtracking which are brute force methods. Greedy is purely about finding the shortcut. And it is hard to find shortcuts.\\n\\nBest way to work around greedy problems is take the test cases and come  up with various strategies, \\nin this particular problem I thought about various complicated ways that involved priority_queues to simulate best pick for both Alice and bob, but they just didn\\'t work. \\n\\n## All about observation\\nTurns out it was a simple observation, which is you just evaluate how precious each stone is. i.e.  **how both Alice and Bob value each stone and sort them in descending order.** Then you just start picking in that order Alice first then Bob till you are done.\\n\\nAnd that\\'s it.\\n\\n\\n```\\nbool comp(const pair<int, int>& p1, const pair<int, int>& p2) {\\n    return p1.first > p2.first;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        \\n        int n = aliceValues.size();\\n        vector<pair<int, int>> precious;\\n        \\n        for(int i = 0; i < n; i++) {\\n            precious.push_back(make_pair(aliceValues[i] + bobValues[i], i));\\n        }\\n        \\n        sort(precious.begin(), precious.end(), comp); \\n        int alice = 0, bob = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(i & 1)\\n                bob += bobValues[precious[i].second];\\n            else\\n                alice += aliceValues[precious[i].second];\\n        }\\n        \\n        if(alice > bob)\\n            return 1;\\n        if(alice < bob)\\n            return -1;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nbool comp(const pair<int, int>& p1, const pair<int, int>& p2) {\\n    return p1.first > p2.first;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        \\n        int n = aliceValues.size();\\n        vector<pair<int, int>> precious;\\n        \\n        for(int i = 0; i < n; i++) {\\n            precious.push_back(make_pair(aliceValues[i] + bobValues[i], i));\\n        }\\n        \\n        sort(precious.begin(), precious.end(), comp); \\n        int alice = 0, bob = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(i & 1)\\n                bob += bobValues[precious[i].second];\\n            else\\n                alice += aliceValues[precious[i].second];\\n        }\\n        \\n        if(alice > bob)\\n            return 1;\\n        if(alice < bob)\\n            return -1;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308062,
                "title": "rust-solution-using-greeedy",
                "content": "```\\nimpl Solution {\\n    pub fn stone_game_vi(alice_values: Vec<i32>, bob_values: Vec<i32>) -> i32 {\\n        let n = alice_values.len();\\n        let mut memo = vec![(0,0);n];\\n        for i in 0..n {\\n            memo[i] = (alice_values[i] + bob_values[i], i);\\n        }\\n        memo.sort();\\n        memo.reverse();\\n\\n        let mut a = 0;\\n        let mut b = 0;\\n        for i in 0..n {\\n            if i % 2 == 0 {\\n                a += alice_values[memo[i].1];\\n            } else {\\n                b += bob_values[memo[i].1];\\n            }\\n        }\\n\\n        if a > b {\\n            1\\n        } else if a == b {\\n            0\\n        } else {\\n            -1\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Greedy"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn stone_game_vi(alice_values: Vec<i32>, bob_values: Vec<i32>) -> i32 {\\n        let n = alice_values.len();\\n        let mut memo = vec![(0,0);n];\\n        for i in 0..n {\\n            memo[i] = (alice_values[i] + bob_values[i], i);\\n        }\\n        memo.sort();\\n        memo.reverse();\\n\\n        let mut a = 0;\\n        let mut b = 0;\\n        for i in 0..n {\\n            if i % 2 == 0 {\\n                a += alice_values[memo[i].1];\\n            } else {\\n                b += bob_values[memo[i].1];\\n            }\\n        }\\n\\n        if a > b {\\n            1\\n        } else if a == b {\\n            0\\n        } else {\\n            -1\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2243593,
                "title": "javascript-3-liner-w-reduce",
                "content": "```javascript\\n/**\\n * @param {number[]} aliceValues\\n * @param {number[]} bobValues\\n * @return {number}\\n */\\nvar stoneGameVI = function (aliceValues, bobValues) {\\n  let pick_me_first = new Array(aliceValues.length).fill([]).map((_, idx, arr) => (arr[idx] = [aliceValues[idx], bobValues[idx]])).sort((a, b) => b[0] + b[1] - (a[0] + a[1]));\\n  let diff = pick_me_first.reduce((acc, val, idx) => (acc += idx % 2 === 0 ? val[0] : 0), 0) - pick_me_first.reduce((acc, val, idx) => (acc += idx % 2 === 1 ? val[1] : 0), 0);\\n  return diff > 0 ? 1 : diff < 0 ? -1 : diff;\\n};\\n```\\n\\nVersion w/ higher readability score:\\n\\n```javascript\\n/**\\n * @param {number[]} aliceValues\\n * @param {number[]} bobValues\\n * @return {number}\\n */\\nvar stoneGameVI = function (aliceValues, bobValues) {\\n  let pick_me_first = new Array(aliceValues.length)\\n    .fill([])\\n    .map((_, idx, arr) => (arr[idx] = [aliceValues[idx], bobValues[idx]]))\\n    .sort((a, b) => b[0] + b[1] - (a[0] + a[1]));\\n  let diff =\\n    pick_me_first.reduce(\\n      (acc, val, idx) => (acc += idx % 2 === 0 ? val[0] : 0),\\n      0\\n    ) -\\n    pick_me_first.reduce(\\n      (acc, val, idx) => (acc += idx % 2 === 1 ? val[1] : 0),\\n      0\\n    );\\n  return diff > 0 ? 1 : diff < 0 ? -1 : diff;\\n};\\n```\\n\\n- Idea: optimal strategy for both players is picking the stone w/ highest combined value\\n- ref: https://leetcode.com/problems/stone-game-vi/discuss/969574/JavaC%2B%2BPython-Sort-by-Value-Sum\\n\\nTESTED\\n\\n```txt\\nAccepted\\n95/95 cases passed (405 ms)\\nYour runtime beats 66.67 % of javascript submissions\\nYour memory usage beats 50 % of javascript submissions (75.9 MB)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} aliceValues\\n * @param {number[]} bobValues\\n * @return {number}\\n */\\nvar stoneGameVI = function (aliceValues, bobValues) {\\n  let pick_me_first = new Array(aliceValues.length).fill([]).map((_, idx, arr) => (arr[idx] = [aliceValues[idx], bobValues[idx]])).sort((a, b) => b[0] + b[1] - (a[0] + a[1]));\\n  let diff = pick_me_first.reduce((acc, val, idx) => (acc += idx % 2 === 0 ? val[0] : 0), 0) - pick_me_first.reduce((acc, val, idx) => (acc += idx % 2 === 1 ? val[1] : 0), 0);\\n  return diff > 0 ? 1 : diff < 0 ? -1 : diff;\\n};\\n```\n```javascript\\n/**\\n * @param {number[]} aliceValues\\n * @param {number[]} bobValues\\n * @return {number}\\n */\\nvar stoneGameVI = function (aliceValues, bobValues) {\\n  let pick_me_first = new Array(aliceValues.length)\\n    .fill([])\\n    .map((_, idx, arr) => (arr[idx] = [aliceValues[idx], bobValues[idx]]))\\n    .sort((a, b) => b[0] + b[1] - (a[0] + a[1]));\\n  let diff =\\n    pick_me_first.reduce(\\n      (acc, val, idx) => (acc += idx % 2 === 0 ? val[0] : 0),\\n      0\\n    ) -\\n    pick_me_first.reduce(\\n      (acc, val, idx) => (acc += idx % 2 === 1 ? val[1] : 0),\\n      0\\n    );\\n  return diff > 0 ? 1 : diff < 0 ? -1 : diff;\\n};\\n```\n```txt\\nAccepted\\n95/95 cases passed (405 ms)\\nYour runtime beats 66.67 % of javascript submissions\\nYour memory usage beats 50 % of javascript submissions (75.9 MB)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2241742,
                "title": "c-code-logical",
                "content": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& a, vector<int>& b) {\\n        vector<pair<int,int>> v;\\n        int i;\\n        \\n        int n=a.size();\\n        \\n        for (i=0; i<n; i++){\\n            v.push_back({a[i]+b[i],i});\\n        }\\n        \\n        sort(v.rbegin(),v.rend());\\n        \\n        int j=n-1;\\n        i=0;\\n        \\n        int bob=0,alice=0;\\n        bool flag=true;\\n        \\n    \\n        \\n        for (i=0; i<v.size(); i++){\\n        \\n                if (flag){\\n                    alice+=a[v[i].second];\\n                    flag=false;\\n                }\\n                else{\\n                    bob+=b[v[i].second];\\n                    flag=true;\\n                }\\n            \\n        }\\n        \\n        if (bob>alice){\\n            return -1;\\n        }\\n        else if (alice>bob){\\n            return 1;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& a, vector<int>& b) {\\n        vector<pair<int,int>> v;\\n        int i;\\n        \\n        int n=a.size();\\n        \\n        for (i=0; i<n; i++){\\n            v.push_back({a[i]+b[i],i});\\n        }\\n        \\n        sort(v.rbegin(),v.rend());\\n        \\n        int j=n-1;\\n        i=0;\\n        \\n        int bob=0,alice=0;\\n        bool flag=true;\\n        \\n    \\n        \\n        for (i=0; i<v.size(); i++){\\n        \\n                if (flag){\\n                    alice+=a[v[i].second];\\n                    flag=false;\\n                }\\n                else{\\n                    bob+=b[v[i].second];\\n                    flag=true;\\n                }\\n            \\n        }\\n        \\n        if (bob>alice){\\n            return -1;\\n        }\\n        else if (alice>bob){\\n            return 1;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235429,
                "title": "easy-to-understand-proof",
                "content": "- Let\\'s say the indexes of stones taken by Alice are:  `i,j...k`\\n- The points Alice can get is `aliceValue[i] + aliceValue[j] ... + aliceValue[k]`\\n- The points Bob can get is `sum(bobValue) - bobValue[i] - bobValue[j] ... - bobValue[k]`\\n- From the above formulas, we can deduce the difference of points between Alice and Bob:`\\n```\\nsum(bobValue) + aliceValue[i] + bobValue[i] + aliceValue[j] + bobValue[j] ...  + aliceValue[k] + bobValue[k]\\n```\\n- Clearly, the best strategy for Alice to get most points is to choose the stones whose sum of value is the highest\\n",
                "solutionTags": [],
                "code": "```\\nsum(bobValue) + aliceValue[i] + bobValue[i] + aliceValue[j] + bobValue[j] ...  + aliceValue[k] + bobValue[k]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2209056,
                "title": "simple-greedy-c",
                "content": "```\\n//Time:O(nlogn),Space:O(n)\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        priority_queue<tuple<int,int,int>> pq;\\n        for(int i=0;i<n;i++){\\n            pq.push({A[i]+B[i],A[i],B[i]});\\n        }\\n        int res=0;\\n        bool ok=true;\\n        while(!pq.empty()){\\n            auto curr=pq.top();pq.pop();\\n            if(ok){\\n                res+=get<1>(curr);\\n                ok=!ok;\\n            }\\n            else{\\n                res-=get<2>(curr);\\n                ok=!ok;\\n            }\\n        }\\n        if(res>0) return 1;\\n        else if(res<0) return -1;\\n        return 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int stoneGameVI(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        priority_queue<tuple<int,int,int>> pq;\\n        for(int i=0;i<n;i++){\\n            pq.push({A[i]+B[i],A[i],B[i]}",
                "codeTag": "Java"
            },
            {
                "id": 2197012,
                "title": "fast-hashmap-solution-python",
                "content": "```\\n def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        valuesDict = {}\\n        for i in range(len(aliceValues)):\\n            valuesDict[i] = (aliceValues[i], bobValues[i], aliceValues[i]+bobValues[i])\\n        \\n        valuesDict = {k:v for k, v in sorted(valuesDict.items(), key = lambda x: -x[1][2])}\\n        \\n        alice = 0\\n        bob = 0\\n        count = 0\\n        for k, v in valuesDict.items():\\n            if count %2 == 0:\\n                alice+= v[0]\\n            else:\\n                bob+=v[1]\\n            count+=1\\n        \\n        if alice > bob:\\n            return 1\\n        elif bob > alice:\\n            return -1\\n        else:\\n            return 0\\n",
                "solutionTags": [],
                "code": "```\\n def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\\n        valuesDict = {}\\n        for i in range(len(aliceValues)):\\n            valuesDict[i] = (aliceValues[i], bobValues[i], aliceValues[i]+bobValues[i])\\n        \\n        valuesDict = {k:v for k, v in sorted(valuesDict.items(), key = lambda x: -x[1][2])}\\n        \\n        alice = 0\\n        bob = 0\\n        count = 0\\n        for k, v in valuesDict.items():\\n            if count %2 == 0:\\n                alice+= v[0]\\n            else:\\n                bob+=v[1]\\n            count+=1\\n        \\n        if alice > bob:\\n            return 1\\n        elif bob > alice:\\n            return -1\\n        else:\\n            return 0\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2190710,
                "title": "scala-solution-o-n-log-n",
                "content": "The most valuable stone to take is the one that maximise each player\\'s personal value *and* the opponent\\'s missed value. That is a sum.\\nGiven that, the algorithm consists in generating the sums of alice and bob values, sort them in decreasing order and playing the game: at each move, if it is even, Alice will pick the next best choice, otherwise Bob will. The score will be kept as a difference of Alice and Bob scores: the difference sign is the required solution.\\n\\n```\\nobject Solution {\\n  def stoneGameVI(aliceValues: Array[Int], bobValues: Array[Int]): Int = {\\n    val sumToIndex = aliceValues\\n      .zipWithIndex\\n      .zip(bobValues)\\n      .map {\\n        case ((aliceValue, index), bobValue) =>\\n          (aliceValue + bobValue) -> index\\n      }\\n      .sortBy(-_._1)\\n    val result: Int = sumToIndex\\n      .zipWithIndex\\n      .foldLeft(0) {\\n        case (acc, ((_, valueIndex), moveIndex)) if moveIndex % 2 == 0 =>\\n          acc + aliceValues(valueIndex)\\n        case (acc, ((_, index), _))=>\\n          acc - bobValues(index)\\n      }\\n    Math.signum(result).toInt\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def stoneGameVI(aliceValues: Array[Int], bobValues: Array[Int]): Int = {\\n    val sumToIndex = aliceValues\\n      .zipWithIndex\\n      .zip(bobValues)\\n      .map {\\n        case ((aliceValue, index), bobValue) =>\\n          (aliceValue + bobValue) -> index\\n      }\\n      .sortBy(-_._1)\\n    val result: Int = sumToIndex\\n      .zipWithIndex\\n      .foldLeft(0) {\\n        case (acc, ((_, valueIndex), moveIndex)) if moveIndex % 2 == 0 =>\\n          acc + aliceValues(valueIndex)\\n        case (acc, ((_, index), _))=>\\n          acc - bobValues(index)\\n      }\\n    Math.signum(result).toInt\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2034399,
                "title": "c-set-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& a, vector<int>& b) {\\n       int n=a.size();\\n      set<pair<int,int>,greater<pair<int,int>>>s1;\\n        for(int i=0;i<n;i++)\\n        {\\n            s1.insert({a[i]+b[i],i});\\n        }\\n        int sum1=0,sum2=0;\\n        bool flag=true;\\n        while(s1.size())\\n        {   \\n            pair<int,int>p=*s1.begin();\\n            int ind=p.second;\\n            if(flag)\\n            {\\n                sum1+=a[ind];    \\n                \\n            }\\n            else\\n            {\\n                sum2+=b[ind];\\n            }\\n            \\n            s1.erase(p);\\n            flag=!flag;\\n            \\n        }\\n            \\n        if(sum1==sum2)\\n            return 0;\\n        else if(sum1>sum2)\\n            return 1;\\n        else\\n            return -1;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& a, vector<int>& b) {\\n       int n=a.size();\\n      set<pair<int,int>,greater<pair<int,int>>>s1;\\n        for(int i=0;i<n;i++)\\n        {\\n            s1.insert({a[i]+b[i],i});\\n        }\\n        int sum1=0,sum2=0;\\n        bool flag=true;\\n        while(s1.size())\\n        {   \\n            pair<int,int>p=*s1.begin();\\n            int ind=p.second;\\n            if(flag)\\n            {\\n                sum1+=a[ind];    \\n                \\n            }\\n            else\\n            {\\n                sum2+=b[ind];\\n            }\\n            \\n            s1.erase(p);\\n            flag=!flag;\\n            \\n        }\\n            \\n        if(sum1==sum2)\\n            return 0;\\n        else if(sum1>sum2)\\n            return 1;\\n        else\\n            return -1;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026942,
                "title": "c-simplest-intuitive-game-theory-greedy",
                "content": "```\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        priority_queue<pair<int,int>> pq;\\n        int n = aliceValues.size();\\n        for(int i = 0; i<n; ++i){\\n            int val = aliceValues[i] + bobValues[i];\\n            pq.push({val, i});\\n        }\\n        int alicePoints = 0, bobPoints = 0, aliceChance = 1;\\n        while(!pq.empty()){\\n            int i = pq.top().second;\\n            if(aliceChance){\\n                alicePoints+=aliceValues[i];\\n                aliceChance = 0;\\n            }else{\\n                bobPoints+=bobValues[i];\\n                aliceChance = 1;\\n            }\\n            pq.pop();\\n        }\\n        if(alicePoints>bobPoints) return 1;\\n        if(alicePoints<bobPoints) return -1;\\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "Greedy",
                    "Heap (Priority Queue)",
                    "Game Theory"
                ],
                "code": "```\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        priority_queue<pair<int,int>> pq;\\n        int n = aliceValues.size();\\n        for(int i = 0; i<n; ++i){\\n            int val = aliceValues[i] + bobValues[i];\\n            pq.push({val, i});\\n        }\\n        int alicePoints = 0, bobPoints = 0, aliceChance = 1;\\n        while(!pq.empty()){\\n            int i = pq.top().second;\\n            if(aliceChance){\\n                alicePoints+=aliceValues[i];\\n                aliceChance = 0;\\n            }else{\\n                bobPoints+=bobValues[i];\\n                aliceChance = 1;\\n            }\\n            pq.pop();\\n        }\\n        if(alicePoints>bobPoints) return 1;\\n        if(alicePoints<bobPoints) return -1;\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1967327,
                "title": "simple-c-faster-than-100",
                "content": "```\\npublic class Solution {\\n    public int StoneGameVI(int[] aliceValues, int[] bobValues) {\\n        var moves = new int[aliceValues.Length][];\\n        \\n        for(var i = 0; i < aliceValues.Length; i++)\\n        {\\n            moves[i] = new []{ aliceValues[i] + bobValues[i], i};\\n        }\\n        \\n        Array.Sort(moves, (x,y) => y[0].CompareTo(x[0]));\\n        \\n        var alice = 0;\\n        var bob = 0;\\n        \\n        for(var i = 0 ; i < moves.Length; i++)\\n        {\\n            if(i % 2 == 0)\\n            {\\n                alice += aliceValues[moves[i][1]];\\n            }\\n            else\\n            {\\n                bob += bobValues[moves[i][1]];\\n            }\\n        }\\n        \\n        return alice == bob ? 0 : alice > bob ? 1 : -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int StoneGameVI(int[] aliceValues, int[] bobValues) {\\n        var moves = new int[aliceValues.Length][];\\n        \\n        for(var i = 0; i < aliceValues.Length; i++)\\n        {\\n            moves[i] = new []{ aliceValues[i] + bobValues[i], i};\\n        }\\n        \\n        Array.Sort(moves, (x,y) => y[0].CompareTo(x[0]));\\n        \\n        var alice = 0;\\n        var bob = 0;\\n        \\n        for(var i = 0 ; i < moves.Length; i++)\\n        {\\n            if(i % 2 == 0)\\n            {\\n                alice += aliceValues[moves[i][1]];\\n            }\\n            else\\n            {\\n                bob += bobValues[moves[i][1]];\\n            }\\n        }\\n        \\n        return alice == bob ? 0 : alice > bob ? 1 : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931432,
                "title": "java-priorityqueue-maxheap",
                "content": "```\\nclass Pair {\\n    int sum, a, b;\\n    Pair(int a, int b) {\\n        sum = a + b;\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\n\\nclass PairComparator implements Comparator<Pair> {\\n    @Override\\n    public int compare(Pair p1, Pair p2) {\\n        return p2.sum - p1.sum;\\n    }\\n}\\n\\nclass Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        PriorityQueue<Pair> maxHeap = new PriorityQueue<>(new PairComparator());\\n        for(int i=0;i<aliceValues.length;i++) {\\n            maxHeap.offer(new Pair(aliceValues[i], bobValues[i]));\\n        }\\n        boolean turn = true;\\n        int aliceScore = 0, bobScore = 0;\\n        while(!maxHeap.isEmpty()) {\\n            if(turn) {\\n                aliceScore += maxHeap.poll().a;\\n            } else {\\n                bobScore += maxHeap.poll().b;\\n            }\\n            turn = !turn;\\n        }\\n        return Integer.compare(aliceScore, bobScore);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Pair {\\n    int sum, a, b;\\n    Pair(int a, int b) {\\n        sum = a + b;\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\n\\nclass PairComparator implements Comparator<Pair> {\\n    @Override\\n    public int compare(Pair p1, Pair p2) {\\n        return p2.sum - p1.sum;\\n    }\\n}\\n\\nclass Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        PriorityQueue<Pair> maxHeap = new PriorityQueue<>(new PairComparator());\\n        for(int i=0;i<aliceValues.length;i++) {\\n            maxHeap.offer(new Pair(aliceValues[i], bobValues[i]));\\n        }\\n        boolean turn = true;\\n        int aliceScore = 0, bobScore = 0;\\n        while(!maxHeap.isEmpty()) {\\n            if(turn) {\\n                aliceScore += maxHeap.poll().a;\\n            } else {\\n                bobScore += maxHeap.poll().b;\\n            }\\n            turn = !turn;\\n        }\\n        return Integer.compare(aliceScore, bobScore);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929800,
                "title": "java-simple-solution-priorityqueue",
                "content": "class pair{\\n    int i,j,diff;\\n    pair(int i,int j,int diff)\\n    {\\n        this.i=i;\\n        this.j=j;\\n        this.diff=this.j+this.i;\\n    \\n    }\\n}\\nclass Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        \\n        \\n        \\n        PriorityQueue<pair> pq=new PriorityQueue<>((a,b)->(b.diff-a.diff));\\n        for(int i=0;i<aliceValues.length;i++)\\n        {\\n            pq.add(new pair(aliceValues[i],bobValues[i],-aliceValues[i]+bobValues[i]));\\n        }\\n        \\n        int k=0,l1=0,l2=0;    \\n        while(pq.size()>0)\\n        {\\n            pair p=pq.poll();\\n          //  System.out.println(p.i+\" \"+p.j+\" \"+p.diff);\\n            if(k%2==0)\\n            {\\n                l1+=p.i;\\n            }\\n            else\\n            {\\n               l2+=p.j; \\n            }\\n            k++;\\n        }\\n        if(l1>l2)\\n            return 1;\\n        if(l1<l2)\\n            return -1;\\n        return 0;\\n        \\n \\n }\\n }",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        \\n        \\n        \\n        PriorityQueue<pair> pq=new PriorityQueue<>((a,b)->(b.diff-a.diff));\\n        for(int i=0;i<aliceValues.length;i++)\\n        {\\n            pq.add(new pair(aliceValues[i],bobValues[i],-aliceValues[i]+bobValues[i]));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1924234,
                "title": "typescript",
                "content": "```\\nfunction stoneGameVI(aliceValues: number[], bobValues: number[]): number {\\n    let values = [];\\n    let n = aliceValues.length;\\n    for(let i = 0; i < n; i++) {\\n        values.push([aliceValues[i],bobValues[i]]);\\n    }\\n    values.sort((a,b) => (b[0] + b[1])-(a[0] + a[1]));\\n    let i = 0;\\n    let [aliceScore,bobScore] = [0,0];\\n    let t = true;\\n    while( i < n) {\\n        if(t) {\\n            aliceScore += values[i][0];\\n        } else {\\n            bobScore += values[i][1];\\n        }\\n        i++;\\n        t = !t;\\n    }\\n    if(aliceScore > bobScore) return 1;\\n    if(aliceScore < bobScore) return -1;\\n    return 0;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction stoneGameVI(aliceValues: number[], bobValues: number[]): number {\\n    let values = [];\\n    let n = aliceValues.length;\\n    for(let i = 0; i < n; i++) {\\n        values.push([aliceValues[i],bobValues[i]]);\\n    }\\n    values.sort((a,b) => (b[0] + b[1])-(a[0] + a[1]));\\n    let i = 0;\\n    let [aliceScore,bobScore] = [0,0];\\n    let t = true;\\n    while( i < n) {\\n        if(t) {\\n            aliceScore += values[i][0];\\n        } else {\\n            bobScore += values[i][1];\\n        }\\n        i++;\\n        t = !t;\\n    }\\n    if(aliceScore > bobScore) return 1;\\n    if(aliceScore < bobScore) return -1;\\n    return 0;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1909492,
                "title": "scala",
                "content": "```\\nimport scala.collection.immutable.SortedSet\\nimport scala.util.chaining.scalaUtilChainingOps\\n\\nobject Solution {\\n  private object Player extends Enumeration {\\n    type Player = Value\\n    val Alice, Bob = Value\\n  }\\n  import Player._\\n\\n  def stoneGameVI(aliceValues: Array[Int], bobValues: Array[Int]): Int = aliceValues\\n    .view\\n    .zip(bobValues)\\n    .zipWithIndex\\n    .map { case ((aliceValue, bobValue), index) => Stone(index, aliceValue, bobValue) }\\n    .to(SortedSet)\\n    .foldLeft(Alice, 0, 0) {\\n      case ((Alice, aliceScore, bobScore), Stone(_, aliceValue, _)) => (Bob, aliceScore + aliceValue, bobScore)\\n      case ((_, aliceScore, bobScore), Stone(_, _, bobValue)) => (Alice, aliceScore, bobScore + bobValue)\\n    }\\n    .pipe { case (_, aliceScore, bobScore) => math.signum(aliceScore.compareTo(bobScore)) }\\n\\n  private final case class Stone(index: Int, aliceValue: Int, bobValue: Int)\\n\\n  private implicit val StoneOrdering: Ordering[Stone] = Ordering.by {\\n    case Stone(index, aliceValue, bobValue) => (-aliceValue - bobValue, index)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nimport scala.collection.immutable.SortedSet\\nimport scala.util.chaining.scalaUtilChainingOps\\n\\nobject Solution {\\n  private object Player extends Enumeration {\\n    type Player = Value\\n    val Alice, Bob = Value\\n  }\\n  import Player._\\n\\n  def stoneGameVI(aliceValues: Array[Int], bobValues: Array[Int]): Int = aliceValues\\n    .view\\n    .zip(bobValues)\\n    .zipWithIndex\\n    .map { case ((aliceValue, bobValue), index) => Stone(index, aliceValue, bobValue) }\\n    .to(SortedSet)\\n    .foldLeft(Alice, 0, 0) {\\n      case ((Alice, aliceScore, bobScore), Stone(_, aliceValue, _)) => (Bob, aliceScore + aliceValue, bobScore)\\n      case ((_, aliceScore, bobScore), Stone(_, _, bobValue)) => (Alice, aliceScore, bobScore + bobValue)\\n    }\\n    .pipe { case (_, aliceScore, bobScore) => math.signum(aliceScore.compareTo(bobScore)) }\\n\\n  private final case class Stone(index: Int, aliceValue: Int, bobValue: Int)\\n\\n  private implicit val StoneOrdering: Ordering[Stone] = Ordering.by {\\n    case Stone(index, aliceValue, bobValue) => (-aliceValue - bobValue, index)\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860830,
                "title": "python-easy-solution-using-sort",
                "content": "```\\nclass Solution:\\n    def stoneGameVI(self, alice: List[int], bob: List[int]) -> int:\\n        n = len(alice)\\n        arr = [alice[i] + bob[i] for i in range(n)]\\n        s = sum(bob)\\n        res = 0\\n        k = (n+1)//2\\n        arr.sort(reverse=True)\\n        for i in range(0, n, 2):\\n            res += arr[i]\\n        \\n        \\n        if res > s:\\n            return 1\\n        elif res == s:\\n            return 0 \\n        else:\\n            return -1 \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameVI(self, alice: List[int], bob: List[int]) -> int:\\n        n = len(alice)\\n        arr = [alice[i] + bob[i] for i in range(n)]\\n        s = sum(bob)\\n        res = 0\\n        k = (n+1)//2\\n        arr.sort(reverse=True)\\n        for i in range(0, n, 2):\\n            res += arr[i]\\n        \\n        \\n        if res > s:\\n            return 1\\n        elif res == s:\\n            return 0 \\n        else:\\n            return -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834907,
                "title": "ruby-one-liner-beats-100-100",
                "content": "```\\n# @param {Integer[]} alice_values\\n# @param {Integer[]} bob_values\\n# @return {Integer}\\ndef stone_game_vi(alice_values, bob_values)\\n  alice_values.zip(bob_values).sort_by { -_1.sum }.each_with_index.sum { |(a, b), i| i.odd? ? -b : a } <=> 0\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} alice_values\\n# @param {Integer[]} bob_values\\n# @return {Integer}\\ndef stone_game_vi(alice_values, bob_values)\\n  alice_values.zip(bob_values).sort_by { -_1.sum }.each_with_index.sum { |(a, b), i| i.odd? ? -b : a } <=> 0\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1831582,
                "title": "sorting-cpp",
                "content": "```\\nint stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        \\n        vector<array<int,3>> v;\\n        int n=aliceValues.size();\\n        for(int i=0;i<n;i++){\\n            v.push_back({aliceValues[i]+bobValues[i],aliceValues[i],bobValues[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int a =0,b=0;\\n        for(int i=0;i<n;i++){\\n            a+=i%2==0?v[n-1-i][1]:0;\\n            b+=i%2!=0?v[n-1-i][2]:0;\\n        }\\n        if(b==a) return 0;\\n        else if(b>a) return -1;\\n        return 1;\\n    }",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Iterator"
                ],
                "code": "```\\nint stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        \\n        vector<array<int,3>> v;\\n        int n=aliceValues.size();\\n        for(int i=0;i<n;i++){\\n            v.push_back({aliceValues[i]+bobValues[i],aliceValues[i],bobValues[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int a =0,b=0;\\n        for(int i=0;i<n;i++){\\n            a+=i%2==0?v[n-1-i][1]:0;\\n            b+=i%2!=0?v[n-1-i][2]:0;\\n        }\\n        if(b==a) return 0;\\n        else if(b>a) return -1;\\n        return 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1817550,
                "title": "java-o-n-97",
                "content": "Uses boxes based on the constraint that max value = 100\\n\\ndifference = \"weight\" (at the beginning I thought that the key was the difference)\\n\\n\\n```class Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        LinkedList[] pointsDifference = (LinkedList[]) new LinkedList[201];\\n        \\n        int maxVal = 0;\\n        for (int i=0; i<aliceValues.length;i++) {\\n            int weight = aliceValues[i]+bobValues[i];\\n            if (weight > maxVal) {\\n                maxVal=weight;\\n            }\\n            LinkedList<Integer> existingDiff=pointsDifference[weight];\\n            if (existingDiff == null) {\\n                existingDiff = new LinkedList<Integer>();\\n                pointsDifference[weight]=existingDiff;\\n            }\\n            existingDiff.add(i);\\n        }\\n        \\n        int bestPlay = maxVal;\\n        int currentPlay = 0;\\n        int bobPoints = 0;\\n        int alicePoints = 0;\\n        boolean alicePlays=true;\\n        while (currentPlay<aliceValues.length) {\\n            if (alicePlays == true) {\\n                LinkedList<Integer> plays = pointsDifference[bestPlay];\\n                if (plays != null && plays.size()>0) {\\n                    currentPlay += 1;\\n                    alicePoints += aliceValues[plays.poll()];\\n                    alicePlays = false;\\n                } else {\\n                    bestPlay = bestPlay-1;\\n                }\\n            } else {\\n                LinkedList<Integer> plays = pointsDifference[bestPlay];\\n                if (plays != null && plays.size()>0) {\\n                    currentPlay += 1;\\n                    bobPoints += bobValues[plays.poll()];\\n                    alicePlays = true;\\n                } else {\\n                    bestPlay = bestPlay-1;\\n                }\\n            }\\n        }\\n        \\n        \\n        if (alicePoints > bobPoints ) {\\n            return 1;\\n        } else if ( alicePoints < bobPoints) {\\n            return -1;\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        LinkedList[] pointsDifference = (LinkedList[]) new LinkedList[201];\\n        \\n        int maxVal = 0;\\n        for (int i=0; i<aliceValues.length;i++) {\\n            int weight = aliceValues[i]+bobValues[i];\\n            if (weight > maxVal) {\\n                maxVal=weight;\\n            }\\n            LinkedList<Integer> existingDiff=pointsDifference[weight];\\n            if (existingDiff == null) {\\n                existingDiff = new LinkedList<Integer>();\\n                pointsDifference[weight]=existingDiff;\\n            }\\n            existingDiff.add(i);\\n        }\\n        \\n        int bestPlay = maxVal;\\n        int currentPlay = 0;\\n        int bobPoints = 0;\\n        int alicePoints = 0;\\n        boolean alicePlays=true;\\n        while (currentPlay<aliceValues.length) {\\n            if (alicePlays == true) {\\n                LinkedList<Integer> plays = pointsDifference[bestPlay];\\n                if (plays != null && plays.size()>0) {\\n                    currentPlay += 1;\\n                    alicePoints += aliceValues[plays.poll()];\\n                    alicePlays = false;\\n                } else {\\n                    bestPlay = bestPlay-1;\\n                }\\n            } else {\\n                LinkedList<Integer> plays = pointsDifference[bestPlay];\\n                if (plays != null && plays.size()>0) {\\n                    currentPlay += 1;\\n                    bobPoints += bobValues[plays.poll()];\\n                    alicePlays = true;\\n                } else {\\n                    bestPlay = bestPlay-1;\\n                }\\n            }\\n        }\\n        \\n        \\n        if (alicePoints > bobPoints ) {\\n            return 1;\\n        } else if ( alicePoints < bobPoints) {\\n            return -1;\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772255,
                "title": "c-priority-queue",
                "content": "class Solution {\\npublic:\\n    \\n\\tint stoneGameVI(vector<int>& a, vector<int>& b) {\\n        int n = a.size();\\n        priority_queue<vector<int>>pq;\\n        for(int i=0;i<n;i++){\\n            pq.push({a[i]+b[i],a[i],b[i]});\\n        }\\n        int c1 = 0,c2 = 0;\\n        bool f = true;\\n        while(!pq.empty()){\\n            if(f){\\n                c1+=pq.top()[1];\\n                pq.pop();\\n                f = false;\\n            }else{\\n                c2+=pq.top()[2];\\n                pq.pop();\\n                f = true;\\n            }\\n        }\\n        //cout<<c1<<\" \"<<c2;\\n        if(c1>c2) return 1;\\n        else if(c2==c1) return 0;\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    \\n\\tint stoneGameVI(vector<int>& a, vector<int>& b) {\\n        int n = a.size();\\n        priority_queue<vector<int>>pq;\\n        for(int i=0;i<n;i++){\\n            pq.push({a[i]+b[i],a[i],b[i]}",
                "codeTag": "Java"
            },
            {
                "id": 1750078,
                "title": "javascript-112ms-beats-100-o-n",
                "content": "the core idea is, every player\\'s best strategy is to take stone that values\\' sum is biggest\\nso if you have situation: [1,2,3] vs [7,8,9], first player have to take 3rd stone that value is 3+9=12, to take maximum value to player and minus the opponents\\' value\\n\\nand you have Object.values in javascript and they are sorted for you already, so it\\'s actually O(n) to build an object and O(n) to parse through it\\n```\\nvar stoneGameVI = function(aliceValues, bobValues) {\\n    let aliceVal = 0\\n    let bobVal = 0\\n    let turn = true\\n    const combined = {}\\n    let n = aliceValues.length\\n    for (let i = 0; i < n; i++) {\\n        if (combined[aliceValues[i] + bobValues[i]]) {\\n            combined[aliceValues[i] + bobValues[i]].push({value: aliceValues[i] + bobValues[i], id: i})\\n        } else {\\n            combined[aliceValues[i] + bobValues[i]] = [{value: aliceValues[i] + bobValues[i], id: i}]\\n        }\\n    }\\n    Object.values(combined).reverse().forEach((value) => {\\n        value.forEach(val => {\\n            if (turn) {\\n                aliceVal += aliceValues[val.id]\\n            } else {\\n                bobVal += bobValues[val.id]\\n            }\\n            turn = !turn\\n        })\\n    })\\n    if (aliceVal === bobVal) return 0\\n    return aliceVal > bobVal ? 1 : -1\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "the core idea is, every player\\'s best strategy is to take stone that values\\' sum is biggest\\nso if you have situation: [1,2,3] vs [7,8,9], first player have to take 3rd stone that value is 3+9=12, to take maximum value to player and minus the opponents\\' value\\n\\nand you have Object.values in javascript and they are sorted for you already, so it\\'s actually O(n) to build an object and O(n) to parse through it\\n```\\nvar stoneGameVI = function(aliceValues, bobValues) {\\n    let aliceVal = 0\\n    let bobVal = 0\\n    let turn = true\\n    const combined = {}\\n    let n = aliceValues.length\\n    for (let i = 0; i < n; i++) {\\n        if (combined[aliceValues[i] + bobValues[i]]) {\\n            combined[aliceValues[i] + bobValues[i]].push({value: aliceValues[i] + bobValues[i], id: i})\\n        } else {\\n            combined[aliceValues[i] + bobValues[i]] = [{value: aliceValues[i] + bobValues[i], id: i}]\\n        }\\n    }\\n    Object.values(combined).reverse().forEach((value) => {\\n        value.forEach(val => {\\n            if (turn) {\\n                aliceVal += aliceValues[val.id]\\n            } else {\\n                bobVal += bobValues[val.id]\\n            }\\n            turn = !turn\\n        })\\n    })\\n    if (aliceVal === bobVal) return 0\\n    return aliceVal > bobVal ? 1 : -1\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1732853,
                "title": "python-o-nlogn-with-explanation-above-99-score",
                "content": "We can simplify the problem by looking at it this way. Bob has sum(stonesBob) score at the beginning. Everytime Alice takes a stone, Bob loses `aliceStone[i] + bobStone[i]` of score. At the end\\n```\\nscoreBob == 0 -> tie\\nscoreBob > 0 -> Bob wins\\nscoreBob < 0 -> Alice wins\\n```\\nThis results in the same exact result in the end given the same choice of stones for both 2 games. You can further change the problem now as Alice has 0 score at the beginning and at each time she plays, she gets `aliceStone[i] + bobStone[i]` score for what she picks. She wins if her score at the end is bigger that the sum of the value of stones in Bob\\'s eyes.\\n\\nThe equivalent game is easy to look at. Alice simply just wants to maximize sum of `aliceStone[i] + bobStone[i]` for stones she picks. And Bob wants to minimize the score of Alice. So the optimum play is for each player to pick the stone with biggest `aliceStone[i] + bobStone[i]` everytime.\\n\\nWe can now compute Alice\\'s score for this modified game and optimum play and compare it to sum of the value of Stones in Bob\\'s eyes to see the result.\\n\\n```python\\nclass Solution:\\n    def stoneGameVI(self, pilesA: List[int], pilesB: List[int]) -> bool:\\n        base = sum(pilesB)\\n        piles = [a + b for (a,b) in zip(pilesA, pilesB)]\\n        piles = list(reversed(sorted(piles)))\\n        score = sum(piles[::2])\\n\\n        if score > base:\\n            return 1\\n        if score < base:\\n            return -1\\n        if score == base:\\n            return 0\\n```\\n\\n![image](https://assets.leetcode.com/users/images/5bf471ae-4476-4e90-b0c7-eb63febee17e_1643594288.7818723.png)\\n",
                "solutionTags": [],
                "code": "```\\nscoreBob == 0 -> tie\\nscoreBob > 0 -> Bob wins\\nscoreBob < 0 -> Alice wins\\n```\n```python\\nclass Solution:\\n    def stoneGameVI(self, pilesA: List[int], pilesB: List[int]) -> bool:\\n        base = sum(pilesB)\\n        piles = [a + b for (a,b) in zip(pilesA, pilesB)]\\n        piles = list(reversed(sorted(piles)))\\n        score = sum(piles[::2])\\n\\n        if score > base:\\n            return 1\\n        if score < base:\\n            return -1\\n        if score == base:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1720702,
                "title": "priorityq-java",
                "content": "\\tclass Solution {\\n\\t\\tpublic class pair implements Comparable<pair>{\\n\\t\\t\\tint sum;int a;int b;\\n\\t\\t\\tpair(int sum,int a,int b){\\n\\t\\t\\t\\tthis.sum=a+b;\\n\\t\\t\\t\\tthis.a=a;\\n\\t\\t\\t\\tthis.b=b;\\n\\t\\t\\t}\\n\\t\\t\\tpublic int compareTo(pair p){\\n\\t\\t\\t\\treturn p.sum-this.sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tpublic int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n\\t\\t\\tPriorityQueue<pair>pq=new PriorityQueue<>();\\n\\t\\t\\tfor(int i=0;i<aliceValues.length;i++) pq.add(new pair(aliceValues[i]+bobValues[i],aliceValues[i],bobValues[i]));\\n\\t\\t\\tboolean turn=true;\\n\\t\\t\\tint a=0,b=0;\\n\\t\\t\\twhile(!pq.isEmpty()){\\n\\t\\t\\t\\tif(turn) a+=pq.poll().a;\\n\\t\\t\\t\\telse b+=pq.poll().b;\\n\\t\\t\\t\\tturn=!turn;\\n\\n\\t\\t\\t}\\n\\t\\t\\t return Integer.compare(a, b);\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic class pair implements Comparable<pair>{\\n\\t\\t\\tint sum;int a;int b;\\n\\t\\t\\tpair(int sum,int a,int b){\\n\\t\\t\\t\\tthis.sum=a+b;\\n\\t\\t\\t\\tthis.a=a;\\n\\t\\t\\t\\tthis.b=b;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1715904,
                "title": "c-greedy-priority-queue",
                "content": "class Solution {\\npublic:\\n\\n    int stoneGameVI(vector<int>& av, vector<int>& bv) {\\n        priority_queue<vector<int>>pq;\\n        \\n        for(int i = 0;i< av.size();i++) pq.push({av[i] + bv[i],av[i],bv[i]});\\n        \\n        bool turn = false;\\n        int ali = 0,bob = 0;\\n        while(!pq.empty()){\\n            if(!turn){\\n                ali += pq.top()[1];\\n                pq.pop();\\n                turn = true;\\n            }else{\\n                bob += pq.top()[2];\\n                pq.pop();\\n                turn = false;\\n            }\\n        }\\n        \\n        if(ali > bob) return 1;\\n        if(bob > ali) return -1;\\n        \\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int stoneGameVI(vector<int>& av, vector<int>& bv) {\\n        priority_queue<vector<int>>pq;\\n        \\n        for(int i = 0;i< av.size();i++) pq.push({av[i] + bv[i],av[i],bv[i]}",
                "codeTag": "Java"
            },
            {
                "id": 1701838,
                "title": "greedy-cpp",
                "content": "```\\nstatic bool comparator(pair<int,int>f,pair<int,int>s){\\n        return f.first>s.first;\\n    }\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n          vector<pair<int,int>>pairSum;\\n          for(int i=0;i<aliceValues.size();i++)\\n              pairSum.push_back({aliceValues[i]+bobValues[i],i});\\n        \\n        \\n          sort(pairSum.begin(),pairSum.end(),comparator);\\n        \\n          int a{0},b{0};\\n          for(int i=0;i<aliceValues.size();i++){\\n              if(i%2==0)a+=aliceValues[pairSum[i].second];\\n              else b+=bobValues[pairSum[i].second];\\n          }\\n         \\n          return a > b ? 1 : a < b ? -1 : 0;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstatic bool comparator(pair<int,int>f,pair<int,int>s){\\n        return f.first>s.first;\\n    }\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n          vector<pair<int,int>>pairSum;\\n          for(int i=0;i<aliceValues.size();i++)\\n              pairSum.push_back({aliceValues[i]+bobValues[i],i});\\n        \\n        \\n          sort(pairSum.begin(),pairSum.end(),comparator);\\n        \\n          int a{0},b{0};\\n          for(int i=0;i<aliceValues.size();i++){\\n              if(i%2==0)a+=aliceValues[pairSum[i].second];\\n              else b+=bobValues[pairSum[i].second];\\n          }\\n         \\n          return a > b ? 1 : a < b ? -1 : 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1695997,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        int n = aliceValues.length;\\n        int[][] ga = new int[n][3];\\n        for (int i=0;i<n;i++) {\\n            ga[i][0] = aliceValues[i] + bobValues[i];\\n            ga[i][1] = aliceValues[i];\\n            ga[i][2] = bobValues[i];\\n        }\\n        Arrays.sort(ga, (a,b)-> b[0]-a[0]);\\n        int as = 0;\\n        int bs = 0;\\n        for (int i=0;i<n;i++) {\\n            if (i%2==0) {\\n                as = as + ga[i][1];\\n            } else {\\n                bs = bs + ga[i][2];\\n            }\\n        }\\n        if (as>bs) {\\n            return 1;\\n        } else {\\n            if (bs>as) {\\n                return -1;\\n            } else {\\n                return 0;\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        int n = aliceValues.length;\\n        int[][] ga = new int[n][3];\\n        for (int i=0;i<n;i++) {\\n            ga[i][0] = aliceValues[i] + bobValues[i];\\n            ga[i][1] = aliceValues[i];\\n            ga[i][2] = bobValues[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1640595,
                "title": "python-simple-sorting-o-nlogn",
                "content": "```\\nclass Solution:\\n    def stoneGameVI(self, av: List[int], bv: List[int]) -> int:\\n        ax=0;bx=0;f=0\\n        for v in sorted([i for i in range(len(av))],key=lambda z:-(av[z]+bv[z])):\\n            if f==0:ax+=av[v];f=1\\n            else:bx+=bv[v];f=0\\n        if ax>bx:return 1\\n        elif bx>ax:return -1\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def stoneGameVI(self, av: List[int], bv: List[int]) -> int:\\n        ax=0;bx=0;f=0\\n        for v in sorted([i for i in range(len(av))],key=lambda z:-(av[z]+bv[z])):\\n            if f==0:ax+=av[v];f=1\\n            else:bx+=bv[v];f=0\\n        if ax>bx:return 1\\n        elif bx>ax:return -1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628710,
                "title": "golang-o-n-log-n-with-explanation",
                "content": "```\\nfunc stoneGameVI(av []int, bv []int) int {\\n    n := len(av)\\n    \\n    // Suppose that after all optimal pick:\\n    // Alice: x1, x2 ... xn = sum(all stones that Alice value) - sum(all stones \\n    // that Alice value but picked by Bob)\\n    //\\n    // So: Difference = Alice - Bob = sum(all stones that Alice value) - sum(a[i] + b[i]) where i are \\n    // stones that Bob picks\\n    //\\n    // Bob will try to make Difference as small as possible, Alice vice versa\\n    //\\n    // In order to do that, Alice must pick max(a[i] + b[i]), Bob also try to pick max(a[i] + b[i])\\n    s, totalAliceCouldPick := make([]int, n), 0\\n    for i := range s {\\n        s[i] = av[i] + bv[i] // Bob and Alice will try to pick from this\\n        totalAliceCouldPick += av[i]\\n    }\\n    \\n    // order to get max(a[i] + b[i])\\n    sort.Ints(s)\\n \\n    // Alice play first and want pick max -> pick stone n - 1\\n    // Bob also pick max -> pick stone n-2\\n    // Alice has no choice -> pick stone n-3\\n    // Bob has no choice -> pick ston n-4\\n    // ... and so on\\n    bobPick := 0\\n    for i := n - 2; i >= 0; i -= 2 {\\n        bobPick += s[i]\\n    }\\n   \\n    // Differrence = TotalAliceCouldPick - bobPick\\n    if totalAliceCouldPick > bobPick {\\n        return 1\\n    }\\n    \\n    if totalAliceCouldPick == bobPick {\\n        return 0\\n    }\\n    \\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc stoneGameVI(av []int, bv []int) int {\\n    n := len(av)\\n    \\n    // Suppose that after all optimal pick:\\n    // Alice: x1, x2 ... xn = sum(all stones that Alice value) - sum(all stones \\n    // that Alice value but picked by Bob)\\n    //\\n    // So: Difference = Alice - Bob = sum(all stones that Alice value) - sum(a[i] + b[i]) where i are \\n    // stones that Bob picks\\n    //\\n    // Bob will try to make Difference as small as possible, Alice vice versa\\n    //\\n    // In order to do that, Alice must pick max(a[i] + b[i]), Bob also try to pick max(a[i] + b[i])\\n    s, totalAliceCouldPick := make([]int, n), 0\\n    for i := range s {\\n        s[i] = av[i] + bv[i] // Bob and Alice will try to pick from this\\n        totalAliceCouldPick += av[i]\\n    }\\n    \\n    // order to get max(a[i] + b[i])\\n    sort.Ints(s)\\n \\n    // Alice play first and want pick max -> pick stone n - 1\\n    // Bob also pick max -> pick stone n-2\\n    // Alice has no choice -> pick stone n-3\\n    // Bob has no choice -> pick ston n-4\\n    // ... and so on\\n    bobPick := 0\\n    for i := n - 2; i >= 0; i -= 2 {\\n        bobPick += s[i]\\n    }\\n   \\n    // Differrence = TotalAliceCouldPick - bobPick\\n    if totalAliceCouldPick > bobPick {\\n        return 1\\n    }\\n    \\n    if totalAliceCouldPick == bobPick {\\n        return 0\\n    }\\n    \\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1605817,
                "title": "go",
                "content": "```\\nfunc stoneGameVI(aliceValues []int, bobValues []int) int {\\n    n := len(aliceValues)\\n    sum := make([]int, n)\\n    for i := 0; i < n; i++ {\\n        sum[i] = aliceValues[i] + bobValues[i]\\n    }\\n    list := make([]int, n)\\n    for i := 0; i < n; i++ {\\n        list[i] = i\\n    }\\n    sort.Slice(list, func(i int, j int) bool {\\n        return sum[list[i]] > sum[list[j]]\\n    })\\n    \\n    var alice, bob int\\n    for i := 0; i < n; i++ {\\n        if i % 2 == 0 {\\n            alice += aliceValues[list[i]]\\n        } else {\\n            bob += bobValues[list[i]]\\n        }\\n    }\\n    if alice > bob {\\n        return 1\\n    } else if alice < bob {\\n        return -1\\n    } else {\\n        return 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc stoneGameVI(aliceValues []int, bobValues []int) int {\\n    n := len(aliceValues)\\n    sum := make([]int, n)\\n    for i := 0; i < n; i++ {\\n        sum[i] = aliceValues[i] + bobValues[i]\\n    }\\n    list := make([]int, n)\\n    for i := 0; i < n; i++ {\\n        list[i] = i\\n    }\\n    sort.Slice(list, func(i int, j int) bool {\\n        return sum[list[i]] > sum[list[j]]\\n    })\\n    \\n    var alice, bob int\\n    for i := 0; i < n; i++ {\\n        if i % 2 == 0 {\\n            alice += aliceValues[list[i]]\\n        } else {\\n            bob += bobValues[list[i]]\\n        }\\n    }\\n    if alice > bob {\\n        return 1\\n    } else if alice < bob {\\n        return -1\\n    } else {\\n        return 0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1598493,
                "title": "c-easy-solution",
                "content": "The problem specifies that a given index in both arrays can only be used by either alice or bob.\\nThe optimal way to play the game is to choose the maximum from whatever is options are available. \\nWhat happens whaen we choose the maximum available option is, we are either taking the maximum from our array or eliminating the chance of our opponent to gather the point of a high scoring element.\\n\\nThus whoever has completed the game with maximum points after n/2 choices each wins.\\n\\nWe use a priority queue of pairs to store the sum at any given index and the index.\\nBeginning with alice we take the value at index from the priority queue and alternate turns.\\n\\n```\\nint stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n\\tpriority_queue<pair<int, int>> pq;\\n\\tfor(int i = 0; i < bobValues.size(); i++){\\n\\t\\tpq.push({aliceValues[i] + bobValues[i], i});\\n\\t}\\n\\n\\tint bPoints = 0;\\n\\tint aPoints = 0;\\n\\n\\tint turn = 1;\\n\\twhile(!pq.empty()){\\n\\t\\tif(turn){\\n\\t\\t\\taPoints += aliceValues[pq.top().second];\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tbPoints += bobValues[pq.top().second];\\n\\t\\t}\\n\\n\\t\\tturn = turn == 1 ? 0 : 1;\\n\\t\\tpq.pop();\\n\\t}\\n\\n\\tif(aPoints != bPoints)\\n\\t\\treturn aPoints > bPoints ? 1 : -1;\\n\\n\\treturn 0;\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)",
                    "Counting"
                ],
                "code": "```\\nint stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n\\tpriority_queue<pair<int, int>> pq;\\n\\tfor(int i = 0; i < bobValues.size(); i++){\\n\\t\\tpq.push({aliceValues[i] + bobValues[i], i});\\n\\t}\\n\\n\\tint bPoints = 0;\\n\\tint aPoints = 0;\\n\\n\\tint turn = 1;\\n\\twhile(!pq.empty()){\\n\\t\\tif(turn){\\n\\t\\t\\taPoints += aliceValues[pq.top().second];\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tbPoints += bobValues[pq.top().second];\\n\\t\\t}\\n\\n\\t\\tturn = turn == 1 ? 0 : 1;\\n\\t\\tpq.pop();\\n\\t}\\n\\n\\tif(aPoints != bPoints)\\n\\t\\treturn aPoints > bPoints ? 1 : -1;\\n\\n\\treturn 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1588539,
                "title": "scala-greedy",
                "content": "```scala\\nobject Solution {\\n  def stoneGameVI(aliceValues: Array[Int], bobValues: Array[Int]): Int = {\\n    lazy val x = (aliceValues zip bobValues)\\n    .sortBy (ab => - ab._1 - ab._2)          // descending sort by sum a+b\\n    .map(ab => Seq(ab._1, - ab._2))          // positive moves for A, negative for B\\n    .zip(Stream.continually(0 to 1).flatten) // zip with 0,1,0,1,0,1\\n    .map(ab=>ab._1(ab._2)).sum               // sum a(0),b(1),a(2),b(3)...\\n    if(x==0) 0 else if(x>0) 1 else -1        // get sign\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```scala\\nobject Solution {\\n  def stoneGameVI(aliceValues: Array[Int], bobValues: Array[Int]): Int = {\\n    lazy val x = (aliceValues zip bobValues)\\n    .sortBy (ab => - ab._1 - ab._2)          // descending sort by sum a+b\\n    .map(ab => Seq(ab._1, - ab._2))          // positive moves for A, negative for B\\n    .zip(Stream.continually(0 to 1).flatten) // zip with 0,1,0,1,0,1\\n    .map(ab=>ab._1(ab._2)).sum               // sum a(0),b(1),a(2),b(3)...\\n    if(x==0) 0 else if(x>0) 1 else -1        // get sign\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1586598,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        vector<array<int, 2>> val(aliceValues.size());\\n        for (int i = 0; i < aliceValues.size(); i++)\\n            val[i] = {aliceValues[i] + bobValues[i], i};\\n        sort(val.rbegin(), val.rend());\\n        int score = 0;\\n        for (int i = 0; i < val.size(); i++)\\n            score += i & 1 ? -bobValues[val[i][1]] : aliceValues[val[i][1]];\\n        return score > 0 ? 1 : score == 0 ? 0 : -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        vector<array<int, 2>> val(aliceValues.size());\\n        for (int i = 0; i < aliceValues.size(); i++)\\n            val[i] = {aliceValues[i] + bobValues[i], i};\\n        sort(val.rbegin(), val.rend());\\n        int score = 0;\\n        for (int i = 0; i < val.size(); i++)\\n            score += i & 1 ? -bobValues[val[i][1]] : aliceValues[val[i][1]];\\n        return score > 0 ? 1 : score == 0 ? 0 : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1565070,
                "title": "c-greedy-sorting",
                "content": "class Solution {\\npublic:\\n    int stoneGameVI(vector<int>& alice, vector<int>& bob) {\\n        \\n        int n=alice.size();\\n        \\n        int a=0,b=0;\\n        \\n        vector<vector<int>>v(n);\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            v[i]={-alice[i]-bob[i],i};\\n            \\n        }\\n        \\n        sort(v.begin(),v.end());\\n        \\n        int f=1;\\n        \\n        for(auto x:v){\\n            \\n            if(f==1){\\n                a+=alice[x[1]];\\n            }\\n            \\n            else{\\n                b+=bob[x[1]];\\n            }\\n            \\n            f=1-f;\\n            \\n        }\\n        \\n        if(a>b){\\n            return 1;\\n        }\\n        \\n        else if(a<b){\\n            return -1;\\n        }\\n        \\n        else{\\n            return 0;\\n        }\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int stoneGameVI(vector<int>& alice, vector<int>& bob) {\\n        \\n        int n=alice.size();\\n        \\n        int a=0,b=0;\\n        \\n        vector<vector<int>>v(n);\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            v[i]={-alice[i]-bob[i],i}",
                "codeTag": "Java"
            },
            {
                "id": 1525529,
                "title": "c-easy-sort-them-on-the-basis-of-sum",
                "content": "The winning mentality would be \\n\\t1) pick up a high stone value\\n\\t2) Block a high stone value by picking up a stone corresponding to it my array\\n\\t\\t\\nNow what would one chose from the above two ? Depends on whose value is higer\\nSo just sort the stones array on the basis of sum and then keep picking to get the answer\\n\\n```\\nclass Solution {\\npublic:\\n#define pii pair<int,int>\\n    static bool sumComp(pii &p1, pii &p2) {\\n        return p1.first + p1.second > p2.first + p2.second;\\n    }\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        vector<pair<int, int>> stones;\\n\\n        for (int i = 0; i < aliceValues.size(); i++) {\\n            stones.push_back({aliceValues[i], bobValues[i]});\\n\\n        }\\n\\n        sort(stones.begin(), stones.end(), sumComp);\\n\\n        // for (auto x : stones) {\\n        //     cout << x.first << \" , \" << x.second << \\'\\\\n\\';\\n\\n        // }\\n\\n        int aliceScore = 0; int bobScore = 0;\\n        // return 0;\\n        int turn = 0;\\n        for (int i = 0; i < stones.size(); i++) {\\n\\n            if (turn == 0) {\\n\\n                aliceScore += stones[i].first;\\n\\n            } else if (turn == 1) {\\n                bobScore += stones[i].second;\\n            }\\n\\n            turn = (turn + 1) % 2;\\n        }\\n\\n        if (aliceScore > bobScore) return 1;\\n        else if (aliceScore == bobScore) return 0;\\n        else return -1;\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n#define pii pair<int,int>\\n    static bool sumComp(pii &p1, pii &p2) {\\n        return p1.first + p1.second > p2.first + p2.second;\\n    }\\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\\n        vector<pair<int, int>> stones;\\n\\n        for (int i = 0; i < aliceValues.size(); i++) {\\n            stones.push_back({aliceValues[i], bobValues[i]});\\n\\n        }\\n\\n        sort(stones.begin(), stones.end(), sumComp);\\n\\n        // for (auto x : stones) {\\n        //     cout << x.first << \" , \" << x.second << \\'\\\\n\\';\\n\\n        // }\\n\\n        int aliceScore = 0; int bobScore = 0;\\n        // return 0;\\n        int turn = 0;\\n        for (int i = 0; i < stones.size(); i++) {\\n\\n            if (turn == 0) {\\n\\n                aliceScore += stones[i].first;\\n\\n            } else if (turn == 1) {\\n                bobScore += stones[i].second;\\n            }\\n\\n            turn = (turn + 1) % 2;\\n        }\\n\\n        if (aliceScore > bobScore) return 1;\\n        else if (aliceScore == bobScore) return 0;\\n        else return -1;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1480262,
                "title": "o-n-log-n-python-solution-beats-100",
                "content": "```\\nclass Solution(object):\\n    def stoneGameVI(self, aliceValues, bobValues):\\n        \"\"\"\\n        :type aliceValues: List[int]\\n        :type bobValues: List[int]\\n        :rtype: int\\n        \"\"\"\\n        arr = sorted([i+j for i,j in zip(aliceValues, bobValues)], reverse=True)\\n        n=len(arr)\\n        bobs=sum(bobValues)\\n        alices=sum(aliceValues)\\n        sum1 = sum([arr[v] for v in range(0,n,2)]) - bobs\\n        sum2 = sum([arr[v] for v in range(1,n,2)]) - alices\\n        if sum1>sum2:\\n            return 1\\n        elif sum1<sum2:\\n            return -1\\n        else:\\n            return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def stoneGameVI(self, aliceValues, bobValues):\\n        \"\"\"\\n        :type aliceValues: List[int]\\n        :type bobValues: List[int]\\n        :rtype: int\\n        \"\"\"\\n        arr = sorted([i+j for i,j in zip(aliceValues, bobValues)], reverse=True)\\n        n=len(arr)\\n        bobs=sum(bobValues)\\n        alices=sum(aliceValues)\\n        sum1 = sum([arr[v] for v in range(0,n,2)]) - bobs\\n        sum2 = sum([arr[v] for v in range(1,n,2)]) - alices\\n        if sum1>sum2:\\n            return 1\\n        elif sum1<sum2:\\n            return -1\\n        else:\\n            return 0\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564713,
                "content": [
                    {
                        "username": "acme",
                        "content": "For n=2, we have [a1,a2], [b1,b2]\\nFor Alice, she can choose a1, so the diff is a1-b2, or choose a2, gets a2-b1\\nif a1+b1==a2+b2, then a1-b2=a2-b1, pick anyone \\nif a1+b1>a2+b2, then a1-b2>a2-b1, pick a1\\n\\nso sort by ai+bi"
                    },
                    {
                        "username": "filipaya",
                        "content": "[@ishika_03](/ishika_03) they play optimally, means Alice will not pick 2 to lose the game."
                    },
                    {
                        "username": "ishika_03",
                        "content": "In test case 2, if Alice picks 2 and Bob picks 3, then Bob will win, how is it a draw? Any explanation."
                    },
                    {
                        "username": "Ceay",
                        "content": "Many people post just the algorithm (basically, see any solution) that sorts the stones by their joint (Alice\\'s and Bob\\'s) value. Here I document two proofs for this solutions.\\n\\n**Solution 1. Maximization of the objective function (added on 12/13/2020)**\\n\\n![image](https://assets.leetcode.com/users/images/1da9294d-5259-40b0-b813-1cd815e585fe_1607871952.8709736.png)\\n\\n\\n\\n\\n**Solution 2. Math induction**\\n\\nMath induction works great for this particular problem, with the induction by the number of stones.\\n\\n**n=1.** If there is one stone, then sorting is not important. Thus, the sorting produces correct algorithm for n=1.\\n\\n**Induction step for n>1.** Suppose the sum-sorting algorithm is correct for n-1 stones. Suppose that for n stones, the best algorithm is not sorted by the sum. As we assume that the algorithm works for n-1 stones, then the very first stone is not sorted. We need to show that if we place the non-maximized first stone on the correct spot, then the outcome for the person who makes the first pick is not worse.  One simplification we can make, as swapping does not change the stones after the swapped place, then we can ignore the tail of the stones. In other words, we can consider only when the first stone has the lowest sum.\\n\\nDenote the stones in the decrease of the sums: stone 1 has the highest sum and stone n has the lowest sum. In other words, a_i+b_i >= a_{i+1}+b_{i+1} \\n\\nNow, we separately need to consider even and odd n.\\n\\n**For even n**, Alice\\'s score when the lowest-sum stone is picked first and the rest are sorted is a_n + a_2 + a_4 + .. + a_{n-2}, and Bob\\'s score is b_1 + b_3 + .. + .b_{n-1}. If the stones are sorted based on their sum, then Alice\\'s score is a_1 + a_3 + ... + a_{n-1}, and Bob\\'s score is b_2 + b_4 + .. + b_n.\\n\\nAlice wins if her score is higher than Bob\\'s. Thus, we are interested in the difference of the Alice\\'s and Bob\\'s scores.\\n\\nFor the lowest stone picked first, the difference is S_{min-first} = a_n + a_2 + a_4 + ... + a_{n-2}  - (b_1 + b_3 + ... + b_{n-1}), and for sum-sorted stones the difference in scores is S_{sorted} = a_1 + a_3 + ... + a_{n-1} - (b_2 + b_4 + .. + b_n).\\n\\nOne can see that  \\n\\nS_{sorted} - S_{min-first} = \\na_1 + a_3 + ... + a_{n-1} - (b_2 + b_4 + ... + b_n) - [a_n + a_2 + a_4 + ... + a_{n-2} - (b_1 + b_3 + ... + b_{n-1})] =\\n(a_1 + a_3 + ... + a_{n-1} + b_1 + b_3 + ... + b_{n-1} ) - (a_n + a_2 + a_4 + ... + a_{n-2} + b_2 + b_4 + ... + b_n) = \\n(a_1 + b_1 + a_3 + b_3 + ... + a_{n-1} + b_{n-1}) - (a_2 + b_2 + a_4 + b_4 + ... + a_n + b_n) =\\n(a_1 + b_1) - (a_2 + b_2) + (a_3 + b_3) - (a_4 + b_4) + (a_{n-1} +b_{n-1}) - ( a_n + b_n) >= 0, \\n\\nbecause (a_1 + b_1) - (a_2 + b_2) >=0, (a_3 + b_3) - (a_4 + b_4) >=0, ..., (a_{n-1} + b_{n-1})  - ( a_n + b_n) >= 0.\\n\\n**For odd n** the reasoning is similar.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Feresini",
                        "content": "**Medium article with code, analysis, and step-by-step solution explanation**:https://federico-feresini.medium.com/stone-game-vi-alghoritms-visualizations-cc260c72402d"
                    },
                    {
                        "username": "zzzzj",
                        "content": "Here I want to share my understanding of the solution.\\n\\nConsider maximum value possible for A, if A took all: \\nTotalA = A1 + A2 + A3...\\nMaximum value for B, if B took all:\\nTotalB = B1 + B2 + B3...\\n\\nDuring the game, when A play, for each selection [i], A will add value Ai to itself, and reduce possible value for B by Bi.\\nIn the end, the total actual value for A is:\\nActualA = A_i1 + A_i2 + A_i3 ...\\nThe actual value of B is:\\nActualB = TotalB - B_i1 - B_i2 - B_i3 ...\\n\\nThe difference of value for A and B is:\\n\\nDiffAB = ActualA - ActualB = (A_i1 + A_i2 + A_i3 ... ) - (TotalB - B_i1 - B_i2 - B_i3 ...) \\n= (A_i1 + B_i1) + (A_i2 + B_i2) + (A_i3 +  B_i3) + ... - TotalB\\n\\nIn this equation, the TotalB is fixed and to maximize the difference, A should choose the maximum A_i + B_i at each round.\\n"
                    },
                    {
                        "username": "CodingMonkey2018",
                        "content": "After reading all the solutions, one question that I had was what happens when there is a tie? Meaning that if there are multiple indices i1, i2, i3, such that a[i1] + b[i1] == a[i2] + b[i2] == a[i3] + b[i3], which index should a player choose? The answer is actually it doesn\\'t matter!\\n\\nIf the sum of two pairs is the same, it doesn\\'t matter which pair a player pick and it will always end up with the same result.\\n\\nTo be more specific, let\\'s say there are two indices i and j such that a[i] + b[i] == a[j] + b[j]. Player A can either choose i or j so the end result would be a[i] vs. b[j] or a[j] vs. b[i], and it\\'s obvious that a[i] - b[j] == a[j] - b[i]. That means no matter which index player A chooses, the end result (point difference) is always the same."
                    },
                    {
                        "username": "p23_5",
                        "content": "Think in terms of gain to you + loss to other\\nThen use one pq, store(A[h],B[h])\\nand sort by decreasing value additon of gain to youand loss to other"
                    },
                    {
                        "username": "saud_anwar",
                        "content": "May be the approach in the solution is not intutive"
                    }
                ]
            },
            {
                "id": 1565130,
                "content": [
                    {
                        "username": "acme",
                        "content": "For n=2, we have [a1,a2], [b1,b2]\\nFor Alice, she can choose a1, so the diff is a1-b2, or choose a2, gets a2-b1\\nif a1+b1==a2+b2, then a1-b2=a2-b1, pick anyone \\nif a1+b1>a2+b2, then a1-b2>a2-b1, pick a1\\n\\nso sort by ai+bi"
                    },
                    {
                        "username": "filipaya",
                        "content": "[@ishika_03](/ishika_03) they play optimally, means Alice will not pick 2 to lose the game."
                    },
                    {
                        "username": "ishika_03",
                        "content": "In test case 2, if Alice picks 2 and Bob picks 3, then Bob will win, how is it a draw? Any explanation."
                    },
                    {
                        "username": "Ceay",
                        "content": "Many people post just the algorithm (basically, see any solution) that sorts the stones by their joint (Alice\\'s and Bob\\'s) value. Here I document two proofs for this solutions.\\n\\n**Solution 1. Maximization of the objective function (added on 12/13/2020)**\\n\\n![image](https://assets.leetcode.com/users/images/1da9294d-5259-40b0-b813-1cd815e585fe_1607871952.8709736.png)\\n\\n\\n\\n\\n**Solution 2. Math induction**\\n\\nMath induction works great for this particular problem, with the induction by the number of stones.\\n\\n**n=1.** If there is one stone, then sorting is not important. Thus, the sorting produces correct algorithm for n=1.\\n\\n**Induction step for n>1.** Suppose the sum-sorting algorithm is correct for n-1 stones. Suppose that for n stones, the best algorithm is not sorted by the sum. As we assume that the algorithm works for n-1 stones, then the very first stone is not sorted. We need to show that if we place the non-maximized first stone on the correct spot, then the outcome for the person who makes the first pick is not worse.  One simplification we can make, as swapping does not change the stones after the swapped place, then we can ignore the tail of the stones. In other words, we can consider only when the first stone has the lowest sum.\\n\\nDenote the stones in the decrease of the sums: stone 1 has the highest sum and stone n has the lowest sum. In other words, a_i+b_i >= a_{i+1}+b_{i+1} \\n\\nNow, we separately need to consider even and odd n.\\n\\n**For even n**, Alice\\'s score when the lowest-sum stone is picked first and the rest are sorted is a_n + a_2 + a_4 + .. + a_{n-2}, and Bob\\'s score is b_1 + b_3 + .. + .b_{n-1}. If the stones are sorted based on their sum, then Alice\\'s score is a_1 + a_3 + ... + a_{n-1}, and Bob\\'s score is b_2 + b_4 + .. + b_n.\\n\\nAlice wins if her score is higher than Bob\\'s. Thus, we are interested in the difference of the Alice\\'s and Bob\\'s scores.\\n\\nFor the lowest stone picked first, the difference is S_{min-first} = a_n + a_2 + a_4 + ... + a_{n-2}  - (b_1 + b_3 + ... + b_{n-1}), and for sum-sorted stones the difference in scores is S_{sorted} = a_1 + a_3 + ... + a_{n-1} - (b_2 + b_4 + .. + b_n).\\n\\nOne can see that  \\n\\nS_{sorted} - S_{min-first} = \\na_1 + a_3 + ... + a_{n-1} - (b_2 + b_4 + ... + b_n) - [a_n + a_2 + a_4 + ... + a_{n-2} - (b_1 + b_3 + ... + b_{n-1})] =\\n(a_1 + a_3 + ... + a_{n-1} + b_1 + b_3 + ... + b_{n-1} ) - (a_n + a_2 + a_4 + ... + a_{n-2} + b_2 + b_4 + ... + b_n) = \\n(a_1 + b_1 + a_3 + b_3 + ... + a_{n-1} + b_{n-1}) - (a_2 + b_2 + a_4 + b_4 + ... + a_n + b_n) =\\n(a_1 + b_1) - (a_2 + b_2) + (a_3 + b_3) - (a_4 + b_4) + (a_{n-1} +b_{n-1}) - ( a_n + b_n) >= 0, \\n\\nbecause (a_1 + b_1) - (a_2 + b_2) >=0, (a_3 + b_3) - (a_4 + b_4) >=0, ..., (a_{n-1} + b_{n-1})  - ( a_n + b_n) >= 0.\\n\\n**For odd n** the reasoning is similar.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Feresini",
                        "content": "**Medium article with code, analysis, and step-by-step solution explanation**:https://federico-feresini.medium.com/stone-game-vi-alghoritms-visualizations-cc260c72402d"
                    },
                    {
                        "username": "zzzzj",
                        "content": "Here I want to share my understanding of the solution.\\n\\nConsider maximum value possible for A, if A took all: \\nTotalA = A1 + A2 + A3...\\nMaximum value for B, if B took all:\\nTotalB = B1 + B2 + B3...\\n\\nDuring the game, when A play, for each selection [i], A will add value Ai to itself, and reduce possible value for B by Bi.\\nIn the end, the total actual value for A is:\\nActualA = A_i1 + A_i2 + A_i3 ...\\nThe actual value of B is:\\nActualB = TotalB - B_i1 - B_i2 - B_i3 ...\\n\\nThe difference of value for A and B is:\\n\\nDiffAB = ActualA - ActualB = (A_i1 + A_i2 + A_i3 ... ) - (TotalB - B_i1 - B_i2 - B_i3 ...) \\n= (A_i1 + B_i1) + (A_i2 + B_i2) + (A_i3 +  B_i3) + ... - TotalB\\n\\nIn this equation, the TotalB is fixed and to maximize the difference, A should choose the maximum A_i + B_i at each round.\\n"
                    },
                    {
                        "username": "CodingMonkey2018",
                        "content": "After reading all the solutions, one question that I had was what happens when there is a tie? Meaning that if there are multiple indices i1, i2, i3, such that a[i1] + b[i1] == a[i2] + b[i2] == a[i3] + b[i3], which index should a player choose? The answer is actually it doesn\\'t matter!\\n\\nIf the sum of two pairs is the same, it doesn\\'t matter which pair a player pick and it will always end up with the same result.\\n\\nTo be more specific, let\\'s say there are two indices i and j such that a[i] + b[i] == a[j] + b[j]. Player A can either choose i or j so the end result would be a[i] vs. b[j] or a[j] vs. b[i], and it\\'s obvious that a[i] - b[j] == a[j] - b[i]. That means no matter which index player A chooses, the end result (point difference) is always the same."
                    },
                    {
                        "username": "p23_5",
                        "content": "Think in terms of gain to you + loss to other\\nThen use one pq, store(A[h],B[h])\\nand sort by decreasing value additon of gain to youand loss to other"
                    },
                    {
                        "username": "saud_anwar",
                        "content": "May be the approach in the solution is not intutive"
                    }
                ]
            },
            {
                "id": 1566650,
                "content": [
                    {
                        "username": "acme",
                        "content": "For n=2, we have [a1,a2], [b1,b2]\\nFor Alice, she can choose a1, so the diff is a1-b2, or choose a2, gets a2-b1\\nif a1+b1==a2+b2, then a1-b2=a2-b1, pick anyone \\nif a1+b1>a2+b2, then a1-b2>a2-b1, pick a1\\n\\nso sort by ai+bi"
                    },
                    {
                        "username": "filipaya",
                        "content": "[@ishika_03](/ishika_03) they play optimally, means Alice will not pick 2 to lose the game."
                    },
                    {
                        "username": "ishika_03",
                        "content": "In test case 2, if Alice picks 2 and Bob picks 3, then Bob will win, how is it a draw? Any explanation."
                    },
                    {
                        "username": "Ceay",
                        "content": "Many people post just the algorithm (basically, see any solution) that sorts the stones by their joint (Alice\\'s and Bob\\'s) value. Here I document two proofs for this solutions.\\n\\n**Solution 1. Maximization of the objective function (added on 12/13/2020)**\\n\\n![image](https://assets.leetcode.com/users/images/1da9294d-5259-40b0-b813-1cd815e585fe_1607871952.8709736.png)\\n\\n\\n\\n\\n**Solution 2. Math induction**\\n\\nMath induction works great for this particular problem, with the induction by the number of stones.\\n\\n**n=1.** If there is one stone, then sorting is not important. Thus, the sorting produces correct algorithm for n=1.\\n\\n**Induction step for n>1.** Suppose the sum-sorting algorithm is correct for n-1 stones. Suppose that for n stones, the best algorithm is not sorted by the sum. As we assume that the algorithm works for n-1 stones, then the very first stone is not sorted. We need to show that if we place the non-maximized first stone on the correct spot, then the outcome for the person who makes the first pick is not worse.  One simplification we can make, as swapping does not change the stones after the swapped place, then we can ignore the tail of the stones. In other words, we can consider only when the first stone has the lowest sum.\\n\\nDenote the stones in the decrease of the sums: stone 1 has the highest sum and stone n has the lowest sum. In other words, a_i+b_i >= a_{i+1}+b_{i+1} \\n\\nNow, we separately need to consider even and odd n.\\n\\n**For even n**, Alice\\'s score when the lowest-sum stone is picked first and the rest are sorted is a_n + a_2 + a_4 + .. + a_{n-2}, and Bob\\'s score is b_1 + b_3 + .. + .b_{n-1}. If the stones are sorted based on their sum, then Alice\\'s score is a_1 + a_3 + ... + a_{n-1}, and Bob\\'s score is b_2 + b_4 + .. + b_n.\\n\\nAlice wins if her score is higher than Bob\\'s. Thus, we are interested in the difference of the Alice\\'s and Bob\\'s scores.\\n\\nFor the lowest stone picked first, the difference is S_{min-first} = a_n + a_2 + a_4 + ... + a_{n-2}  - (b_1 + b_3 + ... + b_{n-1}), and for sum-sorted stones the difference in scores is S_{sorted} = a_1 + a_3 + ... + a_{n-1} - (b_2 + b_4 + .. + b_n).\\n\\nOne can see that  \\n\\nS_{sorted} - S_{min-first} = \\na_1 + a_3 + ... + a_{n-1} - (b_2 + b_4 + ... + b_n) - [a_n + a_2 + a_4 + ... + a_{n-2} - (b_1 + b_3 + ... + b_{n-1})] =\\n(a_1 + a_3 + ... + a_{n-1} + b_1 + b_3 + ... + b_{n-1} ) - (a_n + a_2 + a_4 + ... + a_{n-2} + b_2 + b_4 + ... + b_n) = \\n(a_1 + b_1 + a_3 + b_3 + ... + a_{n-1} + b_{n-1}) - (a_2 + b_2 + a_4 + b_4 + ... + a_n + b_n) =\\n(a_1 + b_1) - (a_2 + b_2) + (a_3 + b_3) - (a_4 + b_4) + (a_{n-1} +b_{n-1}) - ( a_n + b_n) >= 0, \\n\\nbecause (a_1 + b_1) - (a_2 + b_2) >=0, (a_3 + b_3) - (a_4 + b_4) >=0, ..., (a_{n-1} + b_{n-1})  - ( a_n + b_n) >= 0.\\n\\n**For odd n** the reasoning is similar.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Feresini",
                        "content": "**Medium article with code, analysis, and step-by-step solution explanation**:https://federico-feresini.medium.com/stone-game-vi-alghoritms-visualizations-cc260c72402d"
                    },
                    {
                        "username": "zzzzj",
                        "content": "Here I want to share my understanding of the solution.\\n\\nConsider maximum value possible for A, if A took all: \\nTotalA = A1 + A2 + A3...\\nMaximum value for B, if B took all:\\nTotalB = B1 + B2 + B3...\\n\\nDuring the game, when A play, for each selection [i], A will add value Ai to itself, and reduce possible value for B by Bi.\\nIn the end, the total actual value for A is:\\nActualA = A_i1 + A_i2 + A_i3 ...\\nThe actual value of B is:\\nActualB = TotalB - B_i1 - B_i2 - B_i3 ...\\n\\nThe difference of value for A and B is:\\n\\nDiffAB = ActualA - ActualB = (A_i1 + A_i2 + A_i3 ... ) - (TotalB - B_i1 - B_i2 - B_i3 ...) \\n= (A_i1 + B_i1) + (A_i2 + B_i2) + (A_i3 +  B_i3) + ... - TotalB\\n\\nIn this equation, the TotalB is fixed and to maximize the difference, A should choose the maximum A_i + B_i at each round.\\n"
                    },
                    {
                        "username": "CodingMonkey2018",
                        "content": "After reading all the solutions, one question that I had was what happens when there is a tie? Meaning that if there are multiple indices i1, i2, i3, such that a[i1] + b[i1] == a[i2] + b[i2] == a[i3] + b[i3], which index should a player choose? The answer is actually it doesn\\'t matter!\\n\\nIf the sum of two pairs is the same, it doesn\\'t matter which pair a player pick and it will always end up with the same result.\\n\\nTo be more specific, let\\'s say there are two indices i and j such that a[i] + b[i] == a[j] + b[j]. Player A can either choose i or j so the end result would be a[i] vs. b[j] or a[j] vs. b[i], and it\\'s obvious that a[i] - b[j] == a[j] - b[i]. That means no matter which index player A chooses, the end result (point difference) is always the same."
                    },
                    {
                        "username": "p23_5",
                        "content": "Think in terms of gain to you + loss to other\\nThen use one pq, store(A[h],B[h])\\nand sort by decreasing value additon of gain to youand loss to other"
                    },
                    {
                        "username": "saud_anwar",
                        "content": "May be the approach in the solution is not intutive"
                    }
                ]
            },
            {
                "id": 1567656,
                "content": [
                    {
                        "username": "acme",
                        "content": "For n=2, we have [a1,a2], [b1,b2]\\nFor Alice, she can choose a1, so the diff is a1-b2, or choose a2, gets a2-b1\\nif a1+b1==a2+b2, then a1-b2=a2-b1, pick anyone \\nif a1+b1>a2+b2, then a1-b2>a2-b1, pick a1\\n\\nso sort by ai+bi"
                    },
                    {
                        "username": "filipaya",
                        "content": "[@ishika_03](/ishika_03) they play optimally, means Alice will not pick 2 to lose the game."
                    },
                    {
                        "username": "ishika_03",
                        "content": "In test case 2, if Alice picks 2 and Bob picks 3, then Bob will win, how is it a draw? Any explanation."
                    },
                    {
                        "username": "Ceay",
                        "content": "Many people post just the algorithm (basically, see any solution) that sorts the stones by their joint (Alice\\'s and Bob\\'s) value. Here I document two proofs for this solutions.\\n\\n**Solution 1. Maximization of the objective function (added on 12/13/2020)**\\n\\n![image](https://assets.leetcode.com/users/images/1da9294d-5259-40b0-b813-1cd815e585fe_1607871952.8709736.png)\\n\\n\\n\\n\\n**Solution 2. Math induction**\\n\\nMath induction works great for this particular problem, with the induction by the number of stones.\\n\\n**n=1.** If there is one stone, then sorting is not important. Thus, the sorting produces correct algorithm for n=1.\\n\\n**Induction step for n>1.** Suppose the sum-sorting algorithm is correct for n-1 stones. Suppose that for n stones, the best algorithm is not sorted by the sum. As we assume that the algorithm works for n-1 stones, then the very first stone is not sorted. We need to show that if we place the non-maximized first stone on the correct spot, then the outcome for the person who makes the first pick is not worse.  One simplification we can make, as swapping does not change the stones after the swapped place, then we can ignore the tail of the stones. In other words, we can consider only when the first stone has the lowest sum.\\n\\nDenote the stones in the decrease of the sums: stone 1 has the highest sum and stone n has the lowest sum. In other words, a_i+b_i >= a_{i+1}+b_{i+1} \\n\\nNow, we separately need to consider even and odd n.\\n\\n**For even n**, Alice\\'s score when the lowest-sum stone is picked first and the rest are sorted is a_n + a_2 + a_4 + .. + a_{n-2}, and Bob\\'s score is b_1 + b_3 + .. + .b_{n-1}. If the stones are sorted based on their sum, then Alice\\'s score is a_1 + a_3 + ... + a_{n-1}, and Bob\\'s score is b_2 + b_4 + .. + b_n.\\n\\nAlice wins if her score is higher than Bob\\'s. Thus, we are interested in the difference of the Alice\\'s and Bob\\'s scores.\\n\\nFor the lowest stone picked first, the difference is S_{min-first} = a_n + a_2 + a_4 + ... + a_{n-2}  - (b_1 + b_3 + ... + b_{n-1}), and for sum-sorted stones the difference in scores is S_{sorted} = a_1 + a_3 + ... + a_{n-1} - (b_2 + b_4 + .. + b_n).\\n\\nOne can see that  \\n\\nS_{sorted} - S_{min-first} = \\na_1 + a_3 + ... + a_{n-1} - (b_2 + b_4 + ... + b_n) - [a_n + a_2 + a_4 + ... + a_{n-2} - (b_1 + b_3 + ... + b_{n-1})] =\\n(a_1 + a_3 + ... + a_{n-1} + b_1 + b_3 + ... + b_{n-1} ) - (a_n + a_2 + a_4 + ... + a_{n-2} + b_2 + b_4 + ... + b_n) = \\n(a_1 + b_1 + a_3 + b_3 + ... + a_{n-1} + b_{n-1}) - (a_2 + b_2 + a_4 + b_4 + ... + a_n + b_n) =\\n(a_1 + b_1) - (a_2 + b_2) + (a_3 + b_3) - (a_4 + b_4) + (a_{n-1} +b_{n-1}) - ( a_n + b_n) >= 0, \\n\\nbecause (a_1 + b_1) - (a_2 + b_2) >=0, (a_3 + b_3) - (a_4 + b_4) >=0, ..., (a_{n-1} + b_{n-1})  - ( a_n + b_n) >= 0.\\n\\n**For odd n** the reasoning is similar.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Feresini",
                        "content": "**Medium article with code, analysis, and step-by-step solution explanation**:https://federico-feresini.medium.com/stone-game-vi-alghoritms-visualizations-cc260c72402d"
                    },
                    {
                        "username": "zzzzj",
                        "content": "Here I want to share my understanding of the solution.\\n\\nConsider maximum value possible for A, if A took all: \\nTotalA = A1 + A2 + A3...\\nMaximum value for B, if B took all:\\nTotalB = B1 + B2 + B3...\\n\\nDuring the game, when A play, for each selection [i], A will add value Ai to itself, and reduce possible value for B by Bi.\\nIn the end, the total actual value for A is:\\nActualA = A_i1 + A_i2 + A_i3 ...\\nThe actual value of B is:\\nActualB = TotalB - B_i1 - B_i2 - B_i3 ...\\n\\nThe difference of value for A and B is:\\n\\nDiffAB = ActualA - ActualB = (A_i1 + A_i2 + A_i3 ... ) - (TotalB - B_i1 - B_i2 - B_i3 ...) \\n= (A_i1 + B_i1) + (A_i2 + B_i2) + (A_i3 +  B_i3) + ... - TotalB\\n\\nIn this equation, the TotalB is fixed and to maximize the difference, A should choose the maximum A_i + B_i at each round.\\n"
                    },
                    {
                        "username": "CodingMonkey2018",
                        "content": "After reading all the solutions, one question that I had was what happens when there is a tie? Meaning that if there are multiple indices i1, i2, i3, such that a[i1] + b[i1] == a[i2] + b[i2] == a[i3] + b[i3], which index should a player choose? The answer is actually it doesn\\'t matter!\\n\\nIf the sum of two pairs is the same, it doesn\\'t matter which pair a player pick and it will always end up with the same result.\\n\\nTo be more specific, let\\'s say there are two indices i and j such that a[i] + b[i] == a[j] + b[j]. Player A can either choose i or j so the end result would be a[i] vs. b[j] or a[j] vs. b[i], and it\\'s obvious that a[i] - b[j] == a[j] - b[i]. That means no matter which index player A chooses, the end result (point difference) is always the same."
                    },
                    {
                        "username": "p23_5",
                        "content": "Think in terms of gain to you + loss to other\\nThen use one pq, store(A[h],B[h])\\nand sort by decreasing value additon of gain to youand loss to other"
                    },
                    {
                        "username": "saud_anwar",
                        "content": "May be the approach in the solution is not intutive"
                    }
                ]
            },
            {
                "id": 1574741,
                "content": [
                    {
                        "username": "acme",
                        "content": "For n=2, we have [a1,a2], [b1,b2]\\nFor Alice, she can choose a1, so the diff is a1-b2, or choose a2, gets a2-b1\\nif a1+b1==a2+b2, then a1-b2=a2-b1, pick anyone \\nif a1+b1>a2+b2, then a1-b2>a2-b1, pick a1\\n\\nso sort by ai+bi"
                    },
                    {
                        "username": "filipaya",
                        "content": "[@ishika_03](/ishika_03) they play optimally, means Alice will not pick 2 to lose the game."
                    },
                    {
                        "username": "ishika_03",
                        "content": "In test case 2, if Alice picks 2 and Bob picks 3, then Bob will win, how is it a draw? Any explanation."
                    },
                    {
                        "username": "Ceay",
                        "content": "Many people post just the algorithm (basically, see any solution) that sorts the stones by their joint (Alice\\'s and Bob\\'s) value. Here I document two proofs for this solutions.\\n\\n**Solution 1. Maximization of the objective function (added on 12/13/2020)**\\n\\n![image](https://assets.leetcode.com/users/images/1da9294d-5259-40b0-b813-1cd815e585fe_1607871952.8709736.png)\\n\\n\\n\\n\\n**Solution 2. Math induction**\\n\\nMath induction works great for this particular problem, with the induction by the number of stones.\\n\\n**n=1.** If there is one stone, then sorting is not important. Thus, the sorting produces correct algorithm for n=1.\\n\\n**Induction step for n>1.** Suppose the sum-sorting algorithm is correct for n-1 stones. Suppose that for n stones, the best algorithm is not sorted by the sum. As we assume that the algorithm works for n-1 stones, then the very first stone is not sorted. We need to show that if we place the non-maximized first stone on the correct spot, then the outcome for the person who makes the first pick is not worse.  One simplification we can make, as swapping does not change the stones after the swapped place, then we can ignore the tail of the stones. In other words, we can consider only when the first stone has the lowest sum.\\n\\nDenote the stones in the decrease of the sums: stone 1 has the highest sum and stone n has the lowest sum. In other words, a_i+b_i >= a_{i+1}+b_{i+1} \\n\\nNow, we separately need to consider even and odd n.\\n\\n**For even n**, Alice\\'s score when the lowest-sum stone is picked first and the rest are sorted is a_n + a_2 + a_4 + .. + a_{n-2}, and Bob\\'s score is b_1 + b_3 + .. + .b_{n-1}. If the stones are sorted based on their sum, then Alice\\'s score is a_1 + a_3 + ... + a_{n-1}, and Bob\\'s score is b_2 + b_4 + .. + b_n.\\n\\nAlice wins if her score is higher than Bob\\'s. Thus, we are interested in the difference of the Alice\\'s and Bob\\'s scores.\\n\\nFor the lowest stone picked first, the difference is S_{min-first} = a_n + a_2 + a_4 + ... + a_{n-2}  - (b_1 + b_3 + ... + b_{n-1}), and for sum-sorted stones the difference in scores is S_{sorted} = a_1 + a_3 + ... + a_{n-1} - (b_2 + b_4 + .. + b_n).\\n\\nOne can see that  \\n\\nS_{sorted} - S_{min-first} = \\na_1 + a_3 + ... + a_{n-1} - (b_2 + b_4 + ... + b_n) - [a_n + a_2 + a_4 + ... + a_{n-2} - (b_1 + b_3 + ... + b_{n-1})] =\\n(a_1 + a_3 + ... + a_{n-1} + b_1 + b_3 + ... + b_{n-1} ) - (a_n + a_2 + a_4 + ... + a_{n-2} + b_2 + b_4 + ... + b_n) = \\n(a_1 + b_1 + a_3 + b_3 + ... + a_{n-1} + b_{n-1}) - (a_2 + b_2 + a_4 + b_4 + ... + a_n + b_n) =\\n(a_1 + b_1) - (a_2 + b_2) + (a_3 + b_3) - (a_4 + b_4) + (a_{n-1} +b_{n-1}) - ( a_n + b_n) >= 0, \\n\\nbecause (a_1 + b_1) - (a_2 + b_2) >=0, (a_3 + b_3) - (a_4 + b_4) >=0, ..., (a_{n-1} + b_{n-1})  - ( a_n + b_n) >= 0.\\n\\n**For odd n** the reasoning is similar.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Feresini",
                        "content": "**Medium article with code, analysis, and step-by-step solution explanation**:https://federico-feresini.medium.com/stone-game-vi-alghoritms-visualizations-cc260c72402d"
                    },
                    {
                        "username": "zzzzj",
                        "content": "Here I want to share my understanding of the solution.\\n\\nConsider maximum value possible for A, if A took all: \\nTotalA = A1 + A2 + A3...\\nMaximum value for B, if B took all:\\nTotalB = B1 + B2 + B3...\\n\\nDuring the game, when A play, for each selection [i], A will add value Ai to itself, and reduce possible value for B by Bi.\\nIn the end, the total actual value for A is:\\nActualA = A_i1 + A_i2 + A_i3 ...\\nThe actual value of B is:\\nActualB = TotalB - B_i1 - B_i2 - B_i3 ...\\n\\nThe difference of value for A and B is:\\n\\nDiffAB = ActualA - ActualB = (A_i1 + A_i2 + A_i3 ... ) - (TotalB - B_i1 - B_i2 - B_i3 ...) \\n= (A_i1 + B_i1) + (A_i2 + B_i2) + (A_i3 +  B_i3) + ... - TotalB\\n\\nIn this equation, the TotalB is fixed and to maximize the difference, A should choose the maximum A_i + B_i at each round.\\n"
                    },
                    {
                        "username": "CodingMonkey2018",
                        "content": "After reading all the solutions, one question that I had was what happens when there is a tie? Meaning that if there are multiple indices i1, i2, i3, such that a[i1] + b[i1] == a[i2] + b[i2] == a[i3] + b[i3], which index should a player choose? The answer is actually it doesn\\'t matter!\\n\\nIf the sum of two pairs is the same, it doesn\\'t matter which pair a player pick and it will always end up with the same result.\\n\\nTo be more specific, let\\'s say there are two indices i and j such that a[i] + b[i] == a[j] + b[j]. Player A can either choose i or j so the end result would be a[i] vs. b[j] or a[j] vs. b[i], and it\\'s obvious that a[i] - b[j] == a[j] - b[i]. That means no matter which index player A chooses, the end result (point difference) is always the same."
                    },
                    {
                        "username": "p23_5",
                        "content": "Think in terms of gain to you + loss to other\\nThen use one pq, store(A[h],B[h])\\nand sort by decreasing value additon of gain to youand loss to other"
                    },
                    {
                        "username": "saud_anwar",
                        "content": "May be the approach in the solution is not intutive"
                    }
                ]
            },
            {
                "id": 1574684,
                "content": [
                    {
                        "username": "acme",
                        "content": "For n=2, we have [a1,a2], [b1,b2]\\nFor Alice, she can choose a1, so the diff is a1-b2, or choose a2, gets a2-b1\\nif a1+b1==a2+b2, then a1-b2=a2-b1, pick anyone \\nif a1+b1>a2+b2, then a1-b2>a2-b1, pick a1\\n\\nso sort by ai+bi"
                    },
                    {
                        "username": "filipaya",
                        "content": "[@ishika_03](/ishika_03) they play optimally, means Alice will not pick 2 to lose the game."
                    },
                    {
                        "username": "ishika_03",
                        "content": "In test case 2, if Alice picks 2 and Bob picks 3, then Bob will win, how is it a draw? Any explanation."
                    },
                    {
                        "username": "Ceay",
                        "content": "Many people post just the algorithm (basically, see any solution) that sorts the stones by their joint (Alice\\'s and Bob\\'s) value. Here I document two proofs for this solutions.\\n\\n**Solution 1. Maximization of the objective function (added on 12/13/2020)**\\n\\n![image](https://assets.leetcode.com/users/images/1da9294d-5259-40b0-b813-1cd815e585fe_1607871952.8709736.png)\\n\\n\\n\\n\\n**Solution 2. Math induction**\\n\\nMath induction works great for this particular problem, with the induction by the number of stones.\\n\\n**n=1.** If there is one stone, then sorting is not important. Thus, the sorting produces correct algorithm for n=1.\\n\\n**Induction step for n>1.** Suppose the sum-sorting algorithm is correct for n-1 stones. Suppose that for n stones, the best algorithm is not sorted by the sum. As we assume that the algorithm works for n-1 stones, then the very first stone is not sorted. We need to show that if we place the non-maximized first stone on the correct spot, then the outcome for the person who makes the first pick is not worse.  One simplification we can make, as swapping does not change the stones after the swapped place, then we can ignore the tail of the stones. In other words, we can consider only when the first stone has the lowest sum.\\n\\nDenote the stones in the decrease of the sums: stone 1 has the highest sum and stone n has the lowest sum. In other words, a_i+b_i >= a_{i+1}+b_{i+1} \\n\\nNow, we separately need to consider even and odd n.\\n\\n**For even n**, Alice\\'s score when the lowest-sum stone is picked first and the rest are sorted is a_n + a_2 + a_4 + .. + a_{n-2}, and Bob\\'s score is b_1 + b_3 + .. + .b_{n-1}. If the stones are sorted based on their sum, then Alice\\'s score is a_1 + a_3 + ... + a_{n-1}, and Bob\\'s score is b_2 + b_4 + .. + b_n.\\n\\nAlice wins if her score is higher than Bob\\'s. Thus, we are interested in the difference of the Alice\\'s and Bob\\'s scores.\\n\\nFor the lowest stone picked first, the difference is S_{min-first} = a_n + a_2 + a_4 + ... + a_{n-2}  - (b_1 + b_3 + ... + b_{n-1}), and for sum-sorted stones the difference in scores is S_{sorted} = a_1 + a_3 + ... + a_{n-1} - (b_2 + b_4 + .. + b_n).\\n\\nOne can see that  \\n\\nS_{sorted} - S_{min-first} = \\na_1 + a_3 + ... + a_{n-1} - (b_2 + b_4 + ... + b_n) - [a_n + a_2 + a_4 + ... + a_{n-2} - (b_1 + b_3 + ... + b_{n-1})] =\\n(a_1 + a_3 + ... + a_{n-1} + b_1 + b_3 + ... + b_{n-1} ) - (a_n + a_2 + a_4 + ... + a_{n-2} + b_2 + b_4 + ... + b_n) = \\n(a_1 + b_1 + a_3 + b_3 + ... + a_{n-1} + b_{n-1}) - (a_2 + b_2 + a_4 + b_4 + ... + a_n + b_n) =\\n(a_1 + b_1) - (a_2 + b_2) + (a_3 + b_3) - (a_4 + b_4) + (a_{n-1} +b_{n-1}) - ( a_n + b_n) >= 0, \\n\\nbecause (a_1 + b_1) - (a_2 + b_2) >=0, (a_3 + b_3) - (a_4 + b_4) >=0, ..., (a_{n-1} + b_{n-1})  - ( a_n + b_n) >= 0.\\n\\n**For odd n** the reasoning is similar.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Feresini",
                        "content": "**Medium article with code, analysis, and step-by-step solution explanation**:https://federico-feresini.medium.com/stone-game-vi-alghoritms-visualizations-cc260c72402d"
                    },
                    {
                        "username": "zzzzj",
                        "content": "Here I want to share my understanding of the solution.\\n\\nConsider maximum value possible for A, if A took all: \\nTotalA = A1 + A2 + A3...\\nMaximum value for B, if B took all:\\nTotalB = B1 + B2 + B3...\\n\\nDuring the game, when A play, for each selection [i], A will add value Ai to itself, and reduce possible value for B by Bi.\\nIn the end, the total actual value for A is:\\nActualA = A_i1 + A_i2 + A_i3 ...\\nThe actual value of B is:\\nActualB = TotalB - B_i1 - B_i2 - B_i3 ...\\n\\nThe difference of value for A and B is:\\n\\nDiffAB = ActualA - ActualB = (A_i1 + A_i2 + A_i3 ... ) - (TotalB - B_i1 - B_i2 - B_i3 ...) \\n= (A_i1 + B_i1) + (A_i2 + B_i2) + (A_i3 +  B_i3) + ... - TotalB\\n\\nIn this equation, the TotalB is fixed and to maximize the difference, A should choose the maximum A_i + B_i at each round.\\n"
                    },
                    {
                        "username": "CodingMonkey2018",
                        "content": "After reading all the solutions, one question that I had was what happens when there is a tie? Meaning that if there are multiple indices i1, i2, i3, such that a[i1] + b[i1] == a[i2] + b[i2] == a[i3] + b[i3], which index should a player choose? The answer is actually it doesn\\'t matter!\\n\\nIf the sum of two pairs is the same, it doesn\\'t matter which pair a player pick and it will always end up with the same result.\\n\\nTo be more specific, let\\'s say there are two indices i and j such that a[i] + b[i] == a[j] + b[j]. Player A can either choose i or j so the end result would be a[i] vs. b[j] or a[j] vs. b[i], and it\\'s obvious that a[i] - b[j] == a[j] - b[i]. That means no matter which index player A chooses, the end result (point difference) is always the same."
                    },
                    {
                        "username": "p23_5",
                        "content": "Think in terms of gain to you + loss to other\\nThen use one pq, store(A[h],B[h])\\nand sort by decreasing value additon of gain to youand loss to other"
                    },
                    {
                        "username": "saud_anwar",
                        "content": "May be the approach in the solution is not intutive"
                    }
                ]
            },
            {
                "id": 2028418,
                "content": [
                    {
                        "username": "acme",
                        "content": "For n=2, we have [a1,a2], [b1,b2]\\nFor Alice, she can choose a1, so the diff is a1-b2, or choose a2, gets a2-b1\\nif a1+b1==a2+b2, then a1-b2=a2-b1, pick anyone \\nif a1+b1>a2+b2, then a1-b2>a2-b1, pick a1\\n\\nso sort by ai+bi"
                    },
                    {
                        "username": "filipaya",
                        "content": "[@ishika_03](/ishika_03) they play optimally, means Alice will not pick 2 to lose the game."
                    },
                    {
                        "username": "ishika_03",
                        "content": "In test case 2, if Alice picks 2 and Bob picks 3, then Bob will win, how is it a draw? Any explanation."
                    },
                    {
                        "username": "Ceay",
                        "content": "Many people post just the algorithm (basically, see any solution) that sorts the stones by their joint (Alice\\'s and Bob\\'s) value. Here I document two proofs for this solutions.\\n\\n**Solution 1. Maximization of the objective function (added on 12/13/2020)**\\n\\n![image](https://assets.leetcode.com/users/images/1da9294d-5259-40b0-b813-1cd815e585fe_1607871952.8709736.png)\\n\\n\\n\\n\\n**Solution 2. Math induction**\\n\\nMath induction works great for this particular problem, with the induction by the number of stones.\\n\\n**n=1.** If there is one stone, then sorting is not important. Thus, the sorting produces correct algorithm for n=1.\\n\\n**Induction step for n>1.** Suppose the sum-sorting algorithm is correct for n-1 stones. Suppose that for n stones, the best algorithm is not sorted by the sum. As we assume that the algorithm works for n-1 stones, then the very first stone is not sorted. We need to show that if we place the non-maximized first stone on the correct spot, then the outcome for the person who makes the first pick is not worse.  One simplification we can make, as swapping does not change the stones after the swapped place, then we can ignore the tail of the stones. In other words, we can consider only when the first stone has the lowest sum.\\n\\nDenote the stones in the decrease of the sums: stone 1 has the highest sum and stone n has the lowest sum. In other words, a_i+b_i >= a_{i+1}+b_{i+1} \\n\\nNow, we separately need to consider even and odd n.\\n\\n**For even n**, Alice\\'s score when the lowest-sum stone is picked first and the rest are sorted is a_n + a_2 + a_4 + .. + a_{n-2}, and Bob\\'s score is b_1 + b_3 + .. + .b_{n-1}. If the stones are sorted based on their sum, then Alice\\'s score is a_1 + a_3 + ... + a_{n-1}, and Bob\\'s score is b_2 + b_4 + .. + b_n.\\n\\nAlice wins if her score is higher than Bob\\'s. Thus, we are interested in the difference of the Alice\\'s and Bob\\'s scores.\\n\\nFor the lowest stone picked first, the difference is S_{min-first} = a_n + a_2 + a_4 + ... + a_{n-2}  - (b_1 + b_3 + ... + b_{n-1}), and for sum-sorted stones the difference in scores is S_{sorted} = a_1 + a_3 + ... + a_{n-1} - (b_2 + b_4 + .. + b_n).\\n\\nOne can see that  \\n\\nS_{sorted} - S_{min-first} = \\na_1 + a_3 + ... + a_{n-1} - (b_2 + b_4 + ... + b_n) - [a_n + a_2 + a_4 + ... + a_{n-2} - (b_1 + b_3 + ... + b_{n-1})] =\\n(a_1 + a_3 + ... + a_{n-1} + b_1 + b_3 + ... + b_{n-1} ) - (a_n + a_2 + a_4 + ... + a_{n-2} + b_2 + b_4 + ... + b_n) = \\n(a_1 + b_1 + a_3 + b_3 + ... + a_{n-1} + b_{n-1}) - (a_2 + b_2 + a_4 + b_4 + ... + a_n + b_n) =\\n(a_1 + b_1) - (a_2 + b_2) + (a_3 + b_3) - (a_4 + b_4) + (a_{n-1} +b_{n-1}) - ( a_n + b_n) >= 0, \\n\\nbecause (a_1 + b_1) - (a_2 + b_2) >=0, (a_3 + b_3) - (a_4 + b_4) >=0, ..., (a_{n-1} + b_{n-1})  - ( a_n + b_n) >= 0.\\n\\n**For odd n** the reasoning is similar.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Feresini",
                        "content": "**Medium article with code, analysis, and step-by-step solution explanation**:https://federico-feresini.medium.com/stone-game-vi-alghoritms-visualizations-cc260c72402d"
                    },
                    {
                        "username": "zzzzj",
                        "content": "Here I want to share my understanding of the solution.\\n\\nConsider maximum value possible for A, if A took all: \\nTotalA = A1 + A2 + A3...\\nMaximum value for B, if B took all:\\nTotalB = B1 + B2 + B3...\\n\\nDuring the game, when A play, for each selection [i], A will add value Ai to itself, and reduce possible value for B by Bi.\\nIn the end, the total actual value for A is:\\nActualA = A_i1 + A_i2 + A_i3 ...\\nThe actual value of B is:\\nActualB = TotalB - B_i1 - B_i2 - B_i3 ...\\n\\nThe difference of value for A and B is:\\n\\nDiffAB = ActualA - ActualB = (A_i1 + A_i2 + A_i3 ... ) - (TotalB - B_i1 - B_i2 - B_i3 ...) \\n= (A_i1 + B_i1) + (A_i2 + B_i2) + (A_i3 +  B_i3) + ... - TotalB\\n\\nIn this equation, the TotalB is fixed and to maximize the difference, A should choose the maximum A_i + B_i at each round.\\n"
                    },
                    {
                        "username": "CodingMonkey2018",
                        "content": "After reading all the solutions, one question that I had was what happens when there is a tie? Meaning that if there are multiple indices i1, i2, i3, such that a[i1] + b[i1] == a[i2] + b[i2] == a[i3] + b[i3], which index should a player choose? The answer is actually it doesn\\'t matter!\\n\\nIf the sum of two pairs is the same, it doesn\\'t matter which pair a player pick and it will always end up with the same result.\\n\\nTo be more specific, let\\'s say there are two indices i and j such that a[i] + b[i] == a[j] + b[j]. Player A can either choose i or j so the end result would be a[i] vs. b[j] or a[j] vs. b[i], and it\\'s obvious that a[i] - b[j] == a[j] - b[i]. That means no matter which index player A chooses, the end result (point difference) is always the same."
                    },
                    {
                        "username": "p23_5",
                        "content": "Think in terms of gain to you + loss to other\\nThen use one pq, store(A[h],B[h])\\nand sort by decreasing value additon of gain to youand loss to other"
                    },
                    {
                        "username": "saud_anwar",
                        "content": "May be the approach in the solution is not intutive"
                    }
                ]
            }
        ]
    }
]