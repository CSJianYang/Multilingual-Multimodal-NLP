[
    {
        "title": "Maximum Number of Accepted Invitations",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565900,
                "content": [
                    {
                        "username": "guytryingtocode",
                        "content": "Looks like this question requires knowledge of specific algorithms and none of the existing solutions have clear explanations for a simpler way to solve."
                    },
                    {
                        "username": "f1re",
                        "content": "Looking at medium, couldn\\'t have guessed it\\'s a flow problem."
                    },
                    {
                        "username": "rogerwln",
                        "content": "This is not a good interview questions cuz it requires unique knowledge of bipartite graph. Its impossible to solve if you dont know that the algo and there is no alternative solution"
                    },
                    {
                        "username": "hodcse",
                        "content": "I think related topics is not matched with the hint and also Backtracking gives me TLE"
                    }
                ]
            },
            {
                "id": 1567034,
                "content": [
                    {
                        "username": "guytryingtocode",
                        "content": "Looks like this question requires knowledge of specific algorithms and none of the existing solutions have clear explanations for a simpler way to solve."
                    },
                    {
                        "username": "f1re",
                        "content": "Looking at medium, couldn\\'t have guessed it\\'s a flow problem."
                    },
                    {
                        "username": "rogerwln",
                        "content": "This is not a good interview questions cuz it requires unique knowledge of bipartite graph. Its impossible to solve if you dont know that the algo and there is no alternative solution"
                    },
                    {
                        "username": "hodcse",
                        "content": "I think related topics is not matched with the hint and also Backtracking gives me TLE"
                    }
                ]
            },
            {
                "id": 2060758,
                "content": [
                    {
                        "username": "guytryingtocode",
                        "content": "Looks like this question requires knowledge of specific algorithms and none of the existing solutions have clear explanations for a simpler way to solve."
                    },
                    {
                        "username": "f1re",
                        "content": "Looking at medium, couldn\\'t have guessed it\\'s a flow problem."
                    },
                    {
                        "username": "rogerwln",
                        "content": "This is not a good interview questions cuz it requires unique knowledge of bipartite graph. Its impossible to solve if you dont know that the algo and there is no alternative solution"
                    },
                    {
                        "username": "hodcse",
                        "content": "I think related topics is not matched with the hint and also Backtracking gives me TLE"
                    }
                ]
            },
            {
                "id": 1810428,
                "content": [
                    {
                        "username": "guytryingtocode",
                        "content": "Looks like this question requires knowledge of specific algorithms and none of the existing solutions have clear explanations for a simpler way to solve."
                    },
                    {
                        "username": "f1re",
                        "content": "Looking at medium, couldn\\'t have guessed it\\'s a flow problem."
                    },
                    {
                        "username": "rogerwln",
                        "content": "This is not a good interview questions cuz it requires unique knowledge of bipartite graph. Its impossible to solve if you dont know that the algo and there is no alternative solution"
                    },
                    {
                        "username": "hodcse",
                        "content": "I think related topics is not matched with the hint and also Backtracking gives me TLE"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Customers With Positive Revenue this Year",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1942842,
                "content": [
                    {
                        "username": "danek1313",
                        "content": "I find it very hard to believe that Google asked this to a candidate during an interview."
                    },
                    {
                        "username": "dolong2110",
                        "content": "```\\n# Write your MySQL query statement below\\nselect distinct customer_id\\nfrom Customers\\nwhere year = 2021\\ngroup by customer_id, year\\nhaving sum(revenue) > 0;\\n```"
                    },
                    {
                        "username": "medhacodes28",
                        "content": "Is this meant for interns or non SE jobs? "
                    }
                ]
            },
            {
                "id": 1712159,
                "content": [
                    {
                        "username": "danek1313",
                        "content": "I find it very hard to believe that Google asked this to a candidate during an interview."
                    },
                    {
                        "username": "dolong2110",
                        "content": "```\\n# Write your MySQL query statement below\\nselect distinct customer_id\\nfrom Customers\\nwhere year = 2021\\ngroup by customer_id, year\\nhaving sum(revenue) > 0;\\n```"
                    },
                    {
                        "username": "medhacodes28",
                        "content": "Is this meant for interns or non SE jobs? "
                    }
                ]
            },
            {
                "id": 1990853,
                "content": [
                    {
                        "username": "danek1313",
                        "content": "I find it very hard to believe that Google asked this to a candidate during an interview."
                    },
                    {
                        "username": "dolong2110",
                        "content": "```\\n# Write your MySQL query statement below\\nselect distinct customer_id\\nfrom Customers\\nwhere year = 2021\\ngroup by customer_id, year\\nhaving sum(revenue) > 0;\\n```"
                    },
                    {
                        "username": "medhacodes28",
                        "content": "Is this meant for interns or non SE jobs? "
                    }
                ]
            }
        ]
    },
    {
        "title": "Sign of the Product of an Array",
        "question_content": "<p>There is a function <code>signFunc(x)</code> that returns:</p>\n\n<ul>\n\t<li><code>1</code> if <code>x</code> is positive.</li>\n\t<li><code>-1</code> if <code>x</code> is negative.</li>\n\t<li><code>0</code> if <code>x</code> is equal to <code>0</code>.</li>\n</ul>\n\n<p>You are given an integer array <code>nums</code>. Let <code>product</code> be the product of all values in the array <code>nums</code>.</p>\n\n<p>Return <code>signFunc(product)</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,-2,-3,-4,3,2,1]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The product of all values in the array is 144, and signFunc(144) = 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,5,0,2,-3]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The product of all values in the array is 0, and signFunc(0) = 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,1,-1,1,-1]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> The product of all values in the array is -1, and signFunc(-1) = -1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1152555,
                "title": "java-solution-0-ms-seriously-why-we-need-2",
                "content": "We should just need to flip the count whenever encounter a negative number \\n```\\n   public int arraySign(int[] nums) {\\n        int sign = 1; \\n        for (int n : nums) {\\n            if (n == 0) {\\n                return 0; \\n            } \\n\\t\\t\\tif (n < 0) {\\n                sign = -sign; \\n            }\\n        }\\n        return sign; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   public int arraySign(int[] nums) {\\n        int sign = 1; \\n        for (int n : nums) {\\n            if (n == 0) {\\n                return 0; \\n            } \\n\\t\\t\\tif (n < 0) {\\n                sign = -sign; \\n            }\\n        }\\n        return sign; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3476080,
                "title": "c-easy-approach-explained",
                "content": "# **PLEASE UPVOTE \\uD83D\\uDC4D**\\n# Approach\\n- ##### The problem asks us to determine the sign of the product of all the numbers in the given array. To solve this problem, we need to consider the following cases:\\n    1. ##### If the product of all the numbers is positive, the sign is 1.\\n    1. ##### If the product of all the numbers is negative, the sign is -1.\\n    1. ##### If the product of all the numbers is zero, the sign is 0.\\n- ##### To compute the product of all the numbers in the array, we can iterate over the array and count the total negative numbers. We can initialize the cnt as 0 and then update it at each step of the iteration.\\n- ##### At any index, if number is 0, simply return 0.\\n- ##### Once we have computed the product, we can determine the sign of the product using an if-else statement. If the cnt is odd, the sign is -1. If the cnt is even, the sign is 1.\\n\\n- ##### Therefore, we can write a function that takes an array as input, computes the count of negative numbers in the array, and returns the sign of the product.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# **PLEASE UPVOTE \\uD83D\\uDC4D**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& a) {\\n        int cnt = 0;\\n        for(int i = 0; i < a.size(); i++) \\n        {\\n            if(a[i] == 0) return 0;\\n            if(a[i] < 0) cnt++;\\n        }\\n        return cnt%2 ? -1 : 1;\\n    }\\n};\\n```\\n\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/e5cc6438-63d7-47fb-84d1-e4e36cf43c6e_1683003574.1370602.png)\\n",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& a) {\\n        int cnt = 0;\\n        for(int i = 0; i < a.size(); i++) \\n        {\\n            if(a[i] == 0) return 0;\\n            if(a[i] < 0) cnt++;\\n        }\\n        return cnt%2 ? -1 : 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152412,
                "title": "python3-line-sweep",
                "content": "\\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        ans = 1\\n        for x in nums: \\n            if x == 0: return 0 \\n            if x < 0: ans *= -1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        ans = 1\\n        for x in nums: \\n            if x == 0: return 0 \\n            if x < 0: ans *= -1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168505,
                "title": "c-simple-easy-code",
                "content": "***Do upvote if you found it helpful to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int i , count_neg = 0;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count_neg++;\\n        }\\n        if(count_neg %2 == 0)\\n            return 1;\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int i , count_neg = 0;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count_neg++;\\n        }\\n        if(count_neg %2 == 0)\\n            return 1;\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152450,
                "title": "java-2-straightforward-solutions",
                "content": "We only care about 0 and the occurence of negative numbers in the array. No need to calculate the final product.\\n```\\n    public int arraySign(int[] nums) {\\n        int counter = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) {\\n                return 0;\\n            }\\n            if (nums[i] < 0) {\\n                counter++;\\n            }\\n        }\\n        return counter % 2 == 0 ? 1 : -1;\\n    }\\n```\\n\\n```\\n    public int arraySign(int[] nums) {\\n        int sign = 1;\\n        for (int i : nums) {\\n            if (i == 0) return 0;\\n            if (i < 0) sign *= -1;\\n        }\\n        return sign;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int arraySign(int[] nums) {\\n        int counter = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) {\\n                return 0;\\n            }\\n            if (nums[i] < 0) {\\n                counter++;\\n            }\\n        }\\n        return counter % 2 == 0 ? 1 : -1;\\n    }\\n```\n```\\n    public int arraySign(int[] nums) {\\n        int sign = 1;\\n        for (int i : nums) {\\n            if (i == 0) return 0;\\n            if (i < 0) sign *= -1;\\n        }\\n        return sign;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3475407,
                "title": "java-simple-math-beats-100-5-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int arraySign(int[] nums) {\\n    var sign = 1;\\n\\n    for (var n : nums) {\\n      if (n == 0) return 0;\\n      sign *= n > 0 ? 1 : -1;\\n    }\\n    return sign;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n  public int arraySign(int[] nums) {\\n    var sign = 1;\\n\\n    for (var n : nums) {\\n      if (n == 0) return 0;\\n      sign *= n > 0 ? 1 : -1;\\n    }\\n    return sign;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1837393,
                "title": "why-to-multiply-neat-and-simple-solution-o-n-72-ms",
                "content": "```\\nvar arraySign = function(nums) {\\n    var ans = 1\\n    for(i of nums){\\n        if(i == 0){\\n            return 0\\n        }\\n        if(i < 0){\\n            ans = -ans\\n        }\\n    }\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arraySign = function(nums) {\\n    var ans = 1\\n    for(i of nums){\\n        if(i == 0){\\n            return 0\\n        }\\n        if(i < 0){\\n            ans = -ans\\n        }\\n    }\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1162480,
                "title": "easy-to-understand-and-implement-c-solution",
                "content": "**Intuition: why idea of finding product does not work:**\\nConsider this code:\\n```\\nint arraySign(vector<int>& nums) {\\n        int p = 1;\\n        for(auto x: nums)\\n            p *= x;\\n        if(p > 0)\\n            return 1;\\n        else if(p < 0)\\n            return -1;\\n        return 0;\\n    }\\n```\\nThis code passes successfully for small test cases where the input is small. Larger size of array can lead to Runtime Error:\\n```\\nRuntime Error Message:\\nLine 6: Char 15: runtime error: signed integer overflow: 688764384 * -77 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:15:15\\nLast executed input:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n```\\n\\nSo a better solution would be to check if any of the element in the array is a zero. If yes, then return 0, If no, then count how many negative numbers are there. If their count is even, then return 1, else return 0.\\n\\n**Code for the same:**\\n```\\nint arraySign(vector<int>& nums) {\\n        int countNeg = 0;\\n        for(auto x: nums){\\n            if(x < 0)\\n                countNeg++;\\n            else if(x == 0)\\n                return 0;\\n        }\\n        if(countNeg%2 ==0)\\n            return 1;\\n        return -1;\\n    }\\n```\\n**Time complexity: O(N)\\nSpace Complexity: O(1)**\\n\\nDo upvote this solution if it helped you. \\nPeace :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint arraySign(vector<int>& nums) {\\n        int p = 1;\\n        for(auto x: nums)\\n            p *= x;\\n        if(p > 0)\\n            return 1;\\n        else if(p < 0)\\n            return -1;\\n        return 0;\\n    }\\n```\n```\\nRuntime Error Message:\\nLine 6: Char 15: runtime error: signed integer overflow: 688764384 * -77 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:15:15\\nLast executed input:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n```\n```\\nint arraySign(vector<int>& nums) {\\n        int countNeg = 0;\\n        for(auto x: nums){\\n            if(x < 0)\\n                countNeg++;\\n            else if(x == 0)\\n                return 0;\\n        }\\n        if(countNeg%2 ==0)\\n            return 1;\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1891235,
                "title": "simple-javascript-solution",
                "content": "```\\nvar arraySign = function(nums) {\\n\\t// use filter to find total negative numbers in the array\\n    let negativeCount = nums.filter(n => n<0).length;\\n\\t\\n\\t// check if the nums array has zero. If it does, then return 0\\n    if(nums.includes(0)) return 0;\\n\\t\\n\\t// If negativeCount variable is even answer is 1 else -1\\n    return negativeCount % 2 === 0 ? 1 : -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arraySign = function(nums) {\\n\\t// use filter to find total negative numbers in the array\\n    let negativeCount = nums.filter(n => n<0).length;\\n\\t\\n\\t// check if the nums array has zero. If it does, then return 0\\n    if(nums.includes(0)) return 0;\\n\\t\\n\\t// If negativeCount variable is even answer is 1 else -1\\n    return negativeCount % 2 === 0 ? 1 : -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1155733,
                "title": "python-multiple-solutions-tracking-sign-lazy-evaluation-branchless-and-one-liners",
                "content": "Using a loop, terminate early if a zero is encountered. Otherwise, invert the sign each time a negative value is encountered. This is the optimal solution in terms of complexity with O(N) ***in the worst case***.\\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        sign = 1\\n        for num in nums:\\n            if num == 0:\\n\\t\\t\\t\\treturn  0\\n            elif num < 0:\\n\\t\\t\\t\\tsign *= -1\\n        return sign\\n```\\nHowever, since we are using python, it is sometimes just as fast or faster to compute a list product if done correctly, even though computing the list product has complexity O(N) even if `nums` contains zeros. The best way to do this is to trade lazy evaluation in pure python for the blazing speed of functions pre-compiled in `Standard C`.\\n\\nWe can use `math.prod` to do this\\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n\\t\\tproduct = prod(nums)\\n        return 1 if product > 0 else -1 if product < 0 else 0\\n```\\n\\nThe walrus assignment operator (`:=`) in `Python 3.8+` allows us to do this in one-line\\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        return 1 if (product := prod(nums)) > 0 else -1 if product < 0 else 0\\n```\\n\\nAnother built-in way to compute list products is to use `functools.reduce` with the `mul` operator\\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        return 1 if (product := reduce(mul, nums)) > 0 else -1 if product < 0 else 0\\n```\\n\\nUse can also define your own multiplication operator to use with `reduce` using lambdas\\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        return 1 if (product := reduce(lambda x, y: x * y, nums)) > 0 else -1 if product < 0 else 0\\n```\\n\\nAnd finally, we can use a `generator comprehension` inside whichever list product method you like.\\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        return prod(1 if num > 0 else -1 if num < 0 else 0 for num in nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def arraySign(self, nums: List[int]) -> int:\\n        sign = 1\\n        for num in nums:\\n            if num == 0:\\n\\t\\t\\t\\treturn  0\\n            elif num < 0:\\n\\t\\t\\t\\tsign *= -1\\n        return sign\\n```\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n\\t\\tproduct = prod(nums)\\n        return 1 if product > 0 else -1 if product < 0 else 0\\n```\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        return 1 if (product := prod(nums)) > 0 else -1 if product < 0 else 0\\n```\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        return 1 if (product := reduce(mul, nums)) > 0 else -1 if product < 0 else 0\\n```\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        return 1 if (product := reduce(lambda x, y: x * y, nums)) > 0 else -1 if product < 0 else 0\\n```\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        return prod(1 if num > 0 else -1 if num < 0 else 0 for num in nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1153639,
                "title": "java-2-methods",
                "content": "**METHOD1:**\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int prod=1;\\n        for(int i=0;i<nums.length;i++){\\n            int val=signFunc(nums[i]);\\n            prod*=val;\\n        }\\n        return prod;\\n    }\\n    \\n    private int signFunc(int x){\\n        if(x<0) return -1;\\n        else if(x>0) return 1;\\n        return 0;\\n    }\\n}\\n```\\n\\n**Method2:**\\nwe can see that answer is going to be 1,-1 or 0 .\\nwe just need to flip values when we encountered a negative value.\\n```\\n  public int arraySign(int[] nums) {\\n        int prod=1;\\n        for(int num:nums){\\n            if(num<0) prod=-prod;\\n            else if(num==0) return 0; \\n        }\\n        return prod;\\n    }\\n```\\n\\nComplexity:\\n`Time:O(n) and Space:O(1)` in both methods\\n\\nPlease **UPVOTE** if found it helpful and feel free to reach out to me or comment down if you have any doubt.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int prod=1;\\n        for(int i=0;i<nums.length;i++){\\n            int val=signFunc(nums[i]);\\n            prod*=val;\\n        }\\n        return prod;\\n    }\\n    \\n    private int signFunc(int x){\\n        if(x<0) return -1;\\n        else if(x>0) return 1;\\n        return 0;\\n    }\\n}\\n```\n```\\n  public int arraySign(int[] nums) {\\n        int prod=1;\\n        for(int num:nums){\\n            if(num<0) prod=-prod;\\n            else if(num==0) return 0; \\n        }\\n        return prod;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476195,
                "title": "java-100-faster-full-explaination-comments-lbeginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to only predict the sign of the product of all the element in the array.\\n1. If we found 0 return 0 because anything one multipled to 0 will be 0 only.\\n2. Initalize a counter and count the total negative element present in the array.\\n3. If negative count is mutliple of 2 then the product output will be positive number so retrun 1.\\n4. If negative count is not a mutliple of 2 then the product output will be negative number so retrun 0.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int countMinus = 0;\\n        for(int i = 0 ; i < nums.length ; i ++){\\n            if(nums[i] == 0){\\n                return 0; // return 0 if we found a 0 in the array\\n            }\\n            if(nums[i] < 0){\\n                countMinus++; //increment the count wehn we found a negative number\\n            }\\n        }\\n        //check if countMinus is multiple of 2 then return 1 else return -1\\n        return countMinus % 2 == 0 ? 1 : -1;\\n    }\\n}\\n```\\n**Please UpVote If you like it Happy Coding :)\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int countMinus = 0;\\n        for(int i = 0 ; i < nums.length ; i ++){\\n            if(nums[i] == 0){\\n                return 0; // return 0 if we found a 0 in the array\\n            }\\n            if(nums[i] < 0){\\n                countMinus++; //increment the count wehn we found a negative number\\n            }\\n        }\\n        //check if countMinus is multiple of 2 then return 1 else return -1\\n        return countMinus % 2 == 0 ? 1 : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475758,
                "title": "c-easy-2-methods-100-beat",
                "content": "# Intuition\\nWe neet to determine the number of postive number , Negative Number , or is there any Zero or not.\\n\\nMutiply as given in quetion\\n-> 1 if x is positive.\\n-> -1 if x is negative.\\n-> 0 if x is equal to 0.\\n\\nIf we have Zero in a array, then product will be zero no matter other Number , because 0*(any number) = 0\\n\\n# Approach 1\\nLet\\'s Count the Number of postive Number or Negativer number\\n\\nif there is any zero in array answer will be 0\\nif negative number is odd answer will be -1\\nif negative numbers are even answer be 1\\nEX \\n`-1*-1 = 1`\\n`-1*-1*-1 = 1`\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```\\n\\n# code 1\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int pos=0,neg=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0) pos++;\\n            else if(nums[i]<0) neg++;\\n            else return 0;\\n        }\\n        if(neg%2==0) return 1;\\n        return -1;\\n    }\\n};\\n```\\n\\n# Approach 2\\nLet\\'s go dynamically \\n\\nif we found postive number multiply answer with 1 or leave as it is\\n\\nif we found 0 directly return 0\\n\\nif we found negetive multiply with -1\\n\\nfinally return our answer\\n\\n```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code 2\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int a = 1;\\n        for(auto i : nums){\\n            if(i==0) return 0;\\n            else if(i>0) a *=1;\\n            else a *= -1;\\n        }\\n        return a;\\n    }\\n};\\n```\\n```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int pos=0,neg=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0) pos++;\\n            else if(nums[i]<0) neg++;\\n            else return 0;\\n        }\\n        if(neg%2==0) return 1;\\n        return -1;\\n    }\\n};\\n```\n```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int a = 1;\\n        for(auto i : nums){\\n            if(i==0) return 0;\\n            else if(i>0) a *=1;\\n            else a *= -1;\\n        }\\n        return a;\\n    }\\n};\\n```\n```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475335,
                "title": "check-the-sign-explained",
                "content": "The first thought probably is just to simulate it by calculating the product of `nums` and check the sign like what problem statement says. However, We don\\'t need to do that since we are not interested in the value but the sign. Therefore, we can just check the sign only. If we meet a zero, we can exit early since the final sign must be 0 anyway.\\n\\n<iframe src=\"https://leetcode.com/playground/fZuQh2vv/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe>\\n\\nYou may notice that when the number is positive, basically it won\\'t change the sign. Hence, we can just focus on negative numbers and flip the sign when we meet one. Zero case remain unchanged.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int ans = 1;\\n        for (auto x : nums) {\\n            if (x == 0) return 0;\\n            if (x < 0) ans = -ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Rust"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int ans = 1;\\n        for (auto x : nums) {\\n            if (x == 0) return 0;\\n            if (x < 0) ans = -ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630408,
                "title": "simple-approach-0ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int res = 1;\\n        for(auto x : nums)\\n        {\\n            if(x < 0) res *= -1;\\n            else if(x == 0) return 0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int res = 1;\\n        for(auto x : nums)\\n        {\\n            if(x < 0) res *= -1;\\n            else if(x == 0) return 0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152626,
                "title": "python-two-solutions-functional-programming-and-tracking-negatives",
                "content": "Calculate the product using reduce and return the sign.\\n```python\\n\\tdef arraySign(self, nums: List[int]) -> int:\\n        product = reduce(lambda x,y: x*y, nums)\\n        return 0 if not product else 1 if product > 0 else -1\\n```\\n\\nIf we encounter a 0, we can return immediately. Otherwise keep track of the negatives. If the count of negatives is odd, the product is negative. If the count of negatives is even, the product is positive.\\n```python\\n\\tdef arraySign(self, nums: List[int]) -> int:\\n        result = 1\\n        for n in nums:\\n            if not n:\\n                return n\\n\\t\\t\\tif n < 0:\\n\\t\\t\\t\\tresult = -result\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\n\\tdef arraySign(self, nums: List[int]) -> int:\\n        product = reduce(lambda x,y: x*y, nums)\\n        return 0 if not product else 1 if product > 0 else -1\\n```\n```python\\n\\tdef arraySign(self, nums: List[int]) -> int:\\n        result = 1\\n        for n in nums:\\n            if not n:\\n                return n\\n\\t\\t\\tif n < 0:\\n\\t\\t\\t\\tresult = -result\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3502314,
                "title": "best-solution-by-java-in-runtime-8ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n         BigInteger res = BigInteger.ONE;\\n\\n\\n        for (int i = 0; i < nums.length ; i++) {\\n            res = res.multiply(BigInteger.valueOf(nums[i]));\\n        }\\n\\n        return res.signum() ;\\n    }\\n}\\n```\\n\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/7f2e544c-bd28-4f74-9a69-02531ffef3a6_1683577246.8802.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n         BigInteger res = BigInteger.ONE;\\n\\n\\n        for (int i = 0; i < nums.length ; i++) {\\n            res = res.multiply(BigInteger.valueOf(nums[i]));\\n        }\\n\\n        return res.signum() ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476201,
                "title": "beat-98-in-javascript",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou have initial state which is positive. Iterate through the array. \\n- Ignore all positive numbers\\n- When you see 0, immediately return 0\\n- If it is negative, swap the sign of the state  \\n\\n# Complexity\\n- Time complexity: O(N) in the worst case\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    // initial state\\n    let isNeg = false;\\n    // iterate through the array\\n    for(let num of nums) {\\n        if(num === 0) return 0;\\n        // swap the sign\\n        if(num < 0) isNeg = !isNeg;\\n    }\\n    return isNeg?-1:1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Math"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    // initial state\\n    let isNeg = false;\\n    // iterate through the array\\n    for(let num of nums) {\\n        if(num === 0) return 0;\\n        // swap the sign\\n        if(num < 0) isNeg = !isNeg;\\n    }\\n    return isNeg?-1:1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2750264,
                "title": "0ms-solution-with-explanation-c",
                "content": "This question was a bit tricky. At first I tried multiplying all the numbers in array to get product and then decide whether it\\'s positive or negative or it\\'s 0. But I got integer overflow error which probably could have been mitigated by $$long$$ or $$long$$ $$long$$ data types, but we have a better idea\\uD83D\\uDCA1\\n\\nLet\\'s multiply product by 1 if the element is positve instead of the whole number & -1 in case it\\'s negative. If it\\'s zero, we return 0.\\n\\nAnd then finally we will return product after this repetitive process. This saved us from the tedioud operation of multiplying the whole number and then storing it.. and as a result we get a much shorter runtime and better space complexity!\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int product=1;\\n        for (int x:nums) {\\n            if (x<0) product*=-1;\\n            else if (x>0) product*=1;\\n            else return 0;\\n        }\\n        return product;\\n    }\\n};\\n```\\n\\n## if this explanation helped you please leave a upvote on this solution\\n\\n## Visit my GitHub: https://github.com/crimsonKn1ght\\n\\n## Happy coding \\uD83D\\uDE00",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int product=1;\\n        for (int x:nums) {\\n            if (x<0) product*=-1;\\n            else if (x>0) product*=1;\\n            else return 0;\\n        }\\n        return product;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194388,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n\\t\\treturn 0 if 0 in nums else -1 if sum(x < 0 for x in nums) % 2 else 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n\\t\\treturn 0 if 0 in nums else -1 if sum(x < 0 for x in nums) % 2 else 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152482,
                "title": "python-one-pass",
                "content": "```\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        r = 1\\n        for i in nums:\\n            r *= i\\n        if r>0:\\n            return 1\\n        if r<0:\\n            return -1\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        r = 1\\n        for i in nums:\\n            r *= i\\n        if r>0:\\n            return 1\\n        if r<0:\\n            return -1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086766,
                "title": "2023-fastest-solution-java-easy-to-understand",
                "content": "\\t* class Solution {\\n\\t\\tpublic int arraySign(int[] nums) {\\n\\t\\t\\tint product=1;\\n\\t\\t\\tfor(int num:nums){\\n\\t\\t\\t   if(num<0){\\n\\t\\t\\t\\tproduct=-(product);\\n\\t\\t\\t   }else if(num==0){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t   }\\n\\t\\t\\t}\\n\\t\\t\\treturn product;\\n\\t\\t}\\n}",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n\\t\\tpublic int arraySign(int[] nums) {\\n\\t\\t\\tint product=1;\\n\\t\\t\\tfor(int num:nums){\\n\\t\\t\\t   if(num<0){\\n\\t\\t\\t\\tproduct=-(product);\\n\\t\\t\\t   }",
                "codeTag": "Java"
            },
            {
                "id": 2752360,
                "title": "simple-python3-solution-0-n-time-0-1-space",
                "content": "```\\n1. If nums has 0 it means the result of multiplication is guranteed to be 0\\n2. Otherwise count the number of negative signs\\n3. If the number of negative signs is even it means they are all cancelled during multiplication and we can return 1 else -1\\n\\n\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        if 0 in nums:\\n            return 0\\n        \\n        count = 0\\n        \\n        for n in nums:\\n            if n < 0:\\n                count += 1\\n        \\n        return 1 if count % 2 == 0 else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n1. If nums has 0 it means the result of multiplication is guranteed to be 0\\n2. Otherwise count the number of negative signs\\n3. If the number of negative signs is even it means they are all cancelled during multiplication and we can return 1 else -1\\n\\n\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        if 0 in nums:\\n            return 0\\n        \\n        count = 0\\n        \\n        for n in nums:\\n            if n < 0:\\n                count += 1\\n        \\n        return 1 if count % 2 == 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402614,
                "title": "python-easy-solution",
                "content": "```\\ndef arraySign(self, nums: List[int]) -> int:\\n        if nums.count(0) >=1:\\n            return 0\\n        # no of negative numbers in list\\n        count_neg = sum([1 for i in nums if i <0])\\n        \\n        if count_neg %2 == 0:\\n            return 1\\n        else:\\n            return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef arraySign(self, nums: List[int]) -> int:\\n        if nums.count(0) >=1:\\n            return 0\\n        # no of negative numbers in list\\n        count_neg = sum([1 for i in nums if i <0])\\n        \\n        if count_neg %2 == 0:\\n            return 1\\n        else:\\n            return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3476495,
                "title": "easily-understandable-o-n-c-solution-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int i,j,c=0;\\n        for(auto v:nums){\\n            if(v<0)\\n            c++;\\n            if(v==0)\\n            return 0;\\n        }\\n        if(c%2==0)\\n        return 1;\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int i,j,c=0;\\n        for(auto v:nums){\\n            if(v<0)\\n            c++;\\n            if(v==0)\\n            return 0;\\n        }\\n        if(c%2==0)\\n        return 1;\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499851,
                "title": "solution-using-xor-and-only-a-bool-for-memory",
                "content": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        signs = False\\n        for x in nums:\\n            if x == 0 : return 0\\n            signs = signs ^ (x < 0)\\n        if signs : return -1\\n        else: return 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        signs = False\\n        for x in nums:\\n            if x == 0 : return 0\\n            signs = signs ^ (x < 0)\\n        if signs : return -1\\n        else: return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155462,
                "title": "c",
                "content": "```\\npublic int ArraySign(int[] nums) {\\n\\tvar result = 1;\\n\\tforeach (var num in nums) {\\n\\t\\tif (num == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tresult *= num > 0 ? 1 : -1;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int ArraySign(int[] nums) {\\n\\tvar result = 1;\\n\\tforeach (var num in nums) {\\n\\t\\tif (num == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tresult *= num > 0 ? 1 : -1;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152978,
                "title": "rust-fp-solution",
                "content": "Thanks to **rudy_** for help with shortest solution!\\n\\n```\\nimpl Solution {\\n    pub fn array_sign(nums: Vec<i32>) -> i32 {\\n        nums.iter().fold(1, |prod, &x| prod * x.signum())\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn array_sign(nums: Vec<i32>) -> i32 {\\n        nums.iter().fold(1, |prod, &x| prod * x.signum())\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3477379,
                "title": "easy-solution-java",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The input to the method arraySign is an array of integers called nums. The goal of the method is to return the sign of the product of all the elements in the array.\\n\\n- The method **signFunc** is called with **nums** as an argument. This method computes the sign of the product of all the elements in the array.\\n\\n- The variable **count** is initialized to 0. This variable will be used to count the number of negative elements in the array.\\n\\n- The loop **for(int i:nums)** iterates over all the elements in the array. For each element, if it is equal to 0, the method immediately returns 0 because the product of any number and 0 is 0.\\n\\n- If the element is negative (i.e., less than 0), the variable count is incremented by 1.\\n\\n- After the loop, the method checks whether the count of negative elements is even or odd. If it is even, the method returns 1 because the product of an even number of negative numbers is positive. If it is odd, the method returns -1 because the product of an odd number of negative numbers is negative.\\n\\n- Finally, the arraySign method returns the value returned by **signFunc**.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the provided arraySign method is O(n), where n is the length of the input array nums. This is because the method iterates over each element in the array exactly once.\\n- Space complexity:\\nThe space complexity of the method is O(1), because it only uses a constant amount of extra space to store the count variable. No additional data structures are used that depend on the size of the input array\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        return signFunc(nums);\\n    }\\n    static int signFunc(int[] nums){\\n        int count=0;\\n        for(int i:nums)\\n        {\\n            if(i==0)\\n                return 0;\\n            if(i<0)\\n            count++;\\n        }\\n        if(count%2==0)\\n            return 1;\\n        else \\n            return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        return signFunc(nums);\\n    }\\n    static int signFunc(int[] nums){\\n        int count=0;\\n        for(int i:nums)\\n        {\\n            if(i==0)\\n                return 0;\\n            if(i<0)\\n            count++;\\n        }\\n        if(count%2==0)\\n            return 1;\\n        else \\n            return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475342,
                "title": "simplest-python-code",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        p=nums[0]\\n        for i in range(1,len(nums)):\\n            p*=nums[i]\\n        if p==0: return 0\\n        elif p>0: return 1\\n        else: return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        p=nums[0]\\n        for i in range(1,len(nums)):\\n            p*=nums[i]\\n        if p==0: return 0\\n        elif p>0: return 1\\n        else: return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475334,
                "title": "daily-leetcoding-challenge-may-day-2",
                "content": "This problem is the Daily LeetCoding Challenge for May, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sign-of-the-product-of-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Counting Negative Numbers\n\n  \n**Approach 2:** Tracking the Sign of the Product\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sign-of-the-product-of-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2789676,
                "title": "sign-of-the-product-of-an-array-easy-solve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint arraySign(int* nums, int numsSize){\\n    int k=1;\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        if(nums[i]==0)\\n        {\\n            return 0;\\n        }\\n        if(nums[i]<0)\\n        {\\n            k++;\\n        }\\n        \\n    }\\n    if(k%2!=0)\\n    {\\n        return 1;\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint arraySign(int* nums, int numsSize){\\n    int k=1;\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        if(nums[i]==0)\\n        {\\n            return 0;\\n        }\\n        if(nums[i]<0)\\n        {\\n            k++;\\n        }\\n        \\n    }\\n    if(k%2!=0)\\n    {\\n        return 1;\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2078722,
                "title": "sign-of-the-product-of-an-array-python-solution",
                "content": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product=1\\n        for i in nums:\\n            if i==0:\\n                return 0\\n            product*=i\\n        if product<0:\\n            return -1\\n        elif product>0:\\n            return 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product=1\\n        for i in nums:\\n            if i==0:\\n                return 0\\n            product*=i\\n        if product<0:\\n            return -1\\n        elif product>0:\\n            return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159862,
                "title": "sign-of-the-product-of-an-array-c-solution-explained-easy-to-understand",
                "content": "As  said that if the product of all the array element will negative than return -1, if the product will positive return 1 otherwise product is zero return 0. \\nthis is very easy we did not need to calculate the product of all array element just calculate how may negative value is there if total number of -ve value is even then product will surelly positive otherwise negative. if a single zero is present then only the product will zero.\\n\\nso  we calculate number of negative values and any zero if present.\\nby doing this we can reduse the time comlexity.\\nif we go to calculate product than there may be large value which generate some error.\\nso this method is very good use.\\n\\nif you understand upvote.\\n```\\nclass Solution {  \\npublic:\\n    int arraySign(vector<int>& nums) \\n    {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n                return 0;\\n            if(nums[i]<0)\\n                 c++;\\n        }\\n        if(c%2==0)\\n            return 1;\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {  \\npublic:\\n    int arraySign(vector<int>& nums) \\n    {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n                return 0;\\n            if(nums[i]<0)\\n                 c++;\\n        }\\n        if(c%2==0)\\n            return 1;\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159844,
                "title": "golang-solution-faster-than-100-with-quick-explanation",
                "content": "[1822. Sign of the Product of an Array](https://leetcode.com/problems/sign-of-the-product-of-an-array/)\\n\\n\\nThe idea of this solution is elementary:\\n\\n* If the current number in `nums` is negative, then we can flip the sign\\n* If the current number in `nums` is equal to `0`, we can return `0` because any number multiplied by `0` is `0`. You might think that we can check for `if num == 0` after we have iterated, but that won\\'t work because we only switch the sign and don\\'t multiply by `0`, so we will never know whether there is a `0` in the array.\\n\\n``` go\\nfunc arraySign(nums []int) int {\\n    sign := 1\\n\\n    for _, num := range nums {\\n        if num <= -1 {\\n            sign = - sign\\n        } else if num == 0 {\\n            return 0\\n        }\\n    }\\n\\n    return sign\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc arraySign(nums []int) int {\\n    sign := 1\\n\\n    for _, num := range nums {\\n        if num <= -1 {\\n            sign = - sign\\n        } else if num == 0 {\\n            return 0\\n        }\\n    }\\n\\n    return sign\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152447,
                "title": "javascript-one-line-solution",
                "content": "```javascript\\nvar arraySign = (nums) => Math.min(1, Math.max(-1, nums.reduce((a,c) => a * c)))\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar arraySign = (nums) => Math.min(1, Math.max(-1, nums.reduce((a,c) => a * c)))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3476912,
                "title": "c-java-python-runtime-0-ms-beats-100-daily-leetcode-solution",
                "content": "# Please UpVote..\\uD83D\\uDE0A\\uD83D\\uDC95\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n```C++ []\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int neg=0;\\n        for(auto x:nums)\\n        {\\n            if(x==0)\\n            {\\n                return 0;\\n            }\\n            else if(x<0)\\n            {\\n                neg++;\\n            }\\n        }\\n        if(neg%2==0)\\n        {\\n            return 1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n```python []\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        neg = 0\\n        for x in nums:\\n            if x == 0:\\n                return 0\\n            elif x < 0:\\n                neg += 1\\n        if neg % 2 == 0:\\n            return 1\\n        return -1\\n```\\n```JAVA []\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int neg = 0;\\n        for (int x : nums) {\\n            if (x == 0) {\\n                return 0;\\n            } else if (x < 0) {\\n                neg++;\\n            }\\n        }\\n        if (neg % 2 == 0) {\\n            return 1;\\n        }\\n        return -1;\\n    }\\n}\\n\\n```\\n# Please UpVote..\\uD83D\\uDE0A\\uD83D\\uDC95\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int neg=0;\\n        for(auto x:nums)\\n        {\\n            if(x==0)\\n            {\\n                return 0;\\n            }\\n            else if(x<0)\\n            {\\n                neg++;\\n            }\\n        }\\n        if(neg%2==0)\\n        {\\n            return 1;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```python []\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        neg = 0\\n        for x in nums:\\n            if x == 0:\\n                return 0\\n            elif x < 0:\\n                neg += 1\\n        if neg % 2 == 0:\\n            return 1\\n        return -1\\n```\n```JAVA []\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int neg = 0;\\n        for (int x : nums) {\\n            if (x == 0) {\\n                return 0;\\n            } else if (x < 0) {\\n                neg++;\\n            }\\n        }\\n        if (neg % 2 == 0) {\\n            return 1;\\n        }\\n        return -1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476400,
                "title": "without-multiplication-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int count = 0;\\n        for(auto i: nums){\\n            if(i == 0)\\n                return 0; // if 0 is part of array then product is 0\\n            else if(i < 0)\\n                count++;\\n        }  \\n        if(count%2 == 0) // even no. of negative integers then product is postive\\n            return 1;\\n        return -1; // odd no. of negative integers then product is negative\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int count = 0;\\n        for(auto i: nums){\\n            if(i == 0)\\n                return 0; // if 0 is part of array then product is 0\\n            else if(i < 0)\\n                count++;\\n        }  \\n        if(count%2 == 0) // even no. of negative integers then product is postive\\n            return 1;\\n        return -1; // odd no. of negative integers then product is negative\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349017,
                "title": "beats-100-0-ms-very-easy-beginner-friendly-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n## please Upvote..........................\\n```**\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        double prod=1;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            prod*=nums[i];\\n        }\\n        if(prod<0)return -1;\\n        if(prod>0)return 1;\\n        else return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```**\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        double prod=1;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            prod*=nums[i];\\n        }\\n        if(prod<0)return -1;\\n        if(prod>0)return 1;\\n        else return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159651,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int count = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] < 0){\\n                count *= -1;\\n            }else if (nums[i] == 0)\\n                return 0;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int count = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] < 0){\\n                count *= -1;\\n            }else if (nums[i] == 0)\\n                return 0;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054546,
                "title": "best-o-n-solution",
                "content": "# Approach\\nOptimal Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int negCnt = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == 0)\\n                return 0;\\n            if (nums[i] < 0)\\n                negCnt++;    \\n        }\\n        return (negCnt % 2 == 0) ? 1 : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int negCnt = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == 0)\\n                return 0;\\n            if (nums[i] < 0)\\n                negCnt++;    \\n        }\\n        return (negCnt % 2 == 0) ? 1 : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513150,
                "title": "c-most-optimized-easy-to-understand",
                "content": "If element 0 found than return 0;\\nkeep a track for negative element \\nif negative elements are odd return -1\\nelse return 1;\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int x = 0;\\n        for(auto &i: nums){\\n            if(i<0)x ^= 1;\\n            else if(i==0)return 0;\\n        }\\n        if(x)return -1;\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int x = 0;\\n        for(auto &i: nums){\\n            if(i<0)x ^= 1;\\n            else if(i==0)return 0;\\n        }\\n        if(x)return -1;\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477536,
                "title": "problem-of-the-day-very-easy-solution-best-approach",
                "content": "class Solution {\\npublic:\\n\\n    int arraySign(vector<int>& nums) {\\n       int neg = 0; \\n\\t   \\n     //neg will store number of negative numbers \\n\\t \\n        for(int i = 0 ; i<nums.size(); i++){\\n\\t\\t//if any number is 0 then product will be 0 \\n\\t\\t\\n            if(nums[i] == 0 )\\n                return 0;\\n            if(nums[i] < 0)\\n                neg++;\\n        }\\n        \\n\\t\\t// if negative numbers are not even the result will be negative hence -1\\n\\t\\t\\n        if(neg % 2 != 0)\\n            return -1;\\n        \\n        return 1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int arraySign(vector<int>& nums) {\\n       int neg = 0; \\n\\t   \\n     //neg will store number of negative numbers \\n\\t \\n        for(int i = 0 ; i<nums.size(); i++){\\n\\t\\t//if any number is 0 then product will be 0 \\n\\t\\t\\n            if(nums[i] == 0 )\\n                return 0;\\n            if(nums[i] < 0)\\n                neg++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3477458,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int sign = 1;\\n         for(auto num : nums){\\n             if(num==0){\\n                 return 0;\\n             }\\n             if(num<0){\\n                sign = -sign;\\n            }     \\n         }\\n        return sign;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int sign = 1;\\n         for(auto num : nums){\\n             if(num==0){\\n                 return 0;\\n             }\\n             if(num<0){\\n                sign = -sign;\\n            }     \\n         }\\n        return sign;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477170,
                "title": "c-solution-easy-faster",
                "content": "# Intuition\\nIf you go on to multiply each value and check the answer at last then checking the constraints you will get a overflow error for sure.\\n\\nWe have to find a solution without computing the entire values.\\n\\n# Approach\\nFirst sort the entire vector and the ittitare till you find a positive or 0. Keep counting the number of occurances of negative values, if you encounter a zero then directly return 0 otherwise if count of negative is even then return 1 or else return -1.\\n\\n# Complexity\\n- Time complexity:\\n- O(nlogn)\\n\\n- Space complexity:\\n- O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int neg=0;\\n        int pos=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                return 0;\\n            }\\n            else if(nums[0]>0)\\n            {\\n                return 1;\\n            }\\n            else{\\n                if(nums[i]>0)\\n                {\\n                    break;\\n                }\\n                neg++;\\n            }\\n        }\\n        if(neg%2==0)\\n        {\\n            return 1;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int neg=0;\\n        int pos=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                return 0;\\n            }\\n            else if(nums[0]>0)\\n            {\\n                return 1;\\n            }\\n            else{\\n                if(nums[i]>0)\\n                {\\n                    break;\\n                }\\n                neg++;\\n            }\\n        }\\n        if(neg%2==0)\\n        {\\n            return 1;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475980,
                "title": "1-liner-using-reduce-method",
                "content": "# Code\\n```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef array_sign(nums)\\n    nums.reduce(:*) <=> 0\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef array_sign(nums)\\n    nums.reduce(:*) <=> 0\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3475396,
                "title": "2-liner-cool-clean-code-fast-efficient-c",
                "content": "```\\n\\n/*  \\nWe don\\'t need to multiple all elements and then check the product, it will give RTE\\n\\nTo avoid this, we just need to check for each element is it +ve, -ve or 0.\\nAnd depending on this we just need to update our sign variable,\\n\\nif the element is < 0 : multiple sign by -1,\\nif element == 0 :  multiply sign by 0\\nelse the only condition that left is, if element is > 0 : multiply sign by 1( can skip this condition)\\n\\nAt the end just return the sign\\n*/\\n\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int sign = 1;\\n        for(int x : nums) sign *= (x == 0) ? 0 : ((x < 1) ? -1 : 1);\\n        return (sign < 0) ? -1 : ((sign > 0) ? 1 : 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n/*  \\nWe don\\'t need to multiple all elements and then check the product, it will give RTE\\n\\nTo avoid this, we just need to check for each element is it +ve, -ve or 0.\\nAnd depending on this we just need to update our sign variable,\\n\\nif the element is < 0 : multiple sign by -1,\\nif element == 0 :  multiply sign by 0\\nelse the only condition that left is, if element is > 0 : multiply sign by 1( can skip this condition)\\n\\nAt the end just return the sign\\n*/\\n\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int sign = 1;\\n        for(int x : nums) sign *= (x == 0) ? 0 : ((x < 1) ? -1 : 1);\\n        return (sign < 0) ? -1 : ((sign > 0) ? 1 : 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475377,
                "title": "swift-good-interview-answer",
                "content": "**Good Interview Answer (accepted answer)**\\n\\nThis is good interview answer because:\\n1) It is simple, clear and concise. (One pass through the array, not a fancy sort + binary search, etc..)\\n2) Doesn\\'t use Multiplication (in theory faster)\\n3) Doesn\\'t use `.reduce()`, so can short-circuit at the first zero (faster).\\n\\nNote: Problem doesn\\'t state what to return for an empty array. Given constraints state that the array always has more than one element, but this would be a good followup with your interviewer to ask to remove the constraint and handle accordingly (return zero, throw, etc).\\n\\n```\\nclass Solution {\\n    func arraySign(_ nums: [Int]) -> Int {\\n        var result = 1\\n        for num in nums where num < 1 {\\n            guard num != 0 else { return 0 }\\n            result = -result\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func arraySign(_ nums: [Int]) -> Int {\\n        var result = 1\\n        for num in nums where num < 1 {\\n            guard num != 0 else { return 0 }\\n            result = -result\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475346,
                "title": "solutions-in-c-python-and-java-look-at-once",
                "content": "<!-- Describe your first thoughts on how to solve this problem. -->\\n![b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png](https://assets.leetcode.com/users/images/9bb9f5b1-fd11-4bb0-8644-4173cdf95d76_1682986023.367854.png)\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code \\n<iframe src=\"https://leetcode.com/playground/7XSmkm9m/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "<!-- Describe your first thoughts on how to solve this problem. -->\\n![b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png](https://assets.leetcode.com/users/images/9bb9f5b1-fd11-4bb0-8644-4173cdf95d76_1682986023.367854.png)\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code \\n<iframe src=\"https://leetcode.com/playground/7XSmkm9m/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2996375,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust find the count of negative numbers. If the count is even , that means all the minus signs will cancel out each other and product will be postive otherwise negative.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirstly, if any number is 0 then product will be 0 so check for that first and no need to proceed further as we already encountered 0 final answer will also be 0 only.\\nthen, \\nIf count(negativeNumbers) is even, then return 1 otherwise return -1.\\n# Complexity\\n- Time complexity : O(N)\\n- Space complexity : O(1) \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n = nums.size(), negativecount = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n          if(nums[i]==0)\\n          return 0;\\n          else if(nums[i]<0)\\n          negativecount++;\\n        }\\n        return negativecount%2 ? -1 : 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n = nums.size(), negativecount = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n          if(nums[i]==0)\\n          return 0;\\n          else if(nums[i]<0)\\n          negativecount++;\\n        }\\n        return negativecount%2 ? -1 : 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835158,
                "title": "java-easiest-solution-using-only-if-and-else",
                "content": "# Approach\\nCount the number of **negative integer**, if number of count is **divisible by 2 **that means it will be a ****positive value**** so the answer is going to be 1, if the number of count is** not divisibleby 2 **that means it will be a **negative number**. and if the array contains any 0 so the product is ultimately going to 0,so the answer is 0. \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int count = 0,product = 1,result = 0;\\n        for (int num : nums) {\\n            if (num < 0) count++;\\n            if (num == 0) {\\n                product = 0;\\n                break;\\n            }\\n        }\\n        if (product == 0) return 0;\\n        else {\\n            if ((count % 2 != 0)) result = -1;\\n            if ((count % 2 == 0)) result = 1;\\n            if (result == -1) return -1;\\n            else return 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int count = 0,product = 1,result = 0;\\n        for (int num : nums) {\\n            if (num < 0) count++;\\n            if (num == 0) {\\n                product = 0;\\n                break;\\n            }\\n        }\\n        if (product == 0) return 0;\\n        else {\\n            if ((count % 2 != 0)) result = -1;\\n            if ((count % 2 == 0)) result = 1;\\n            if (result == -1) return -1;\\n            else return 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456697,
                "title": "python-solution-faster-than-95-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = math.prod(nums)\\n        return 1 if product > 0 else -1 if product < 0 else 0  \\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = math.prod(nums)\\n        return 1 if product > 0 else -1 if product < 0 else 0  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058671,
                "title": "naive-solution",
                "content": "private static int cuts(int A, int B){\\n        int sum = A + B;\\n        int length = sum/4;\\n        while(length>0){\\n            if((A/length + B/length)==4)\\n                return length;\\n            else\\n                length--;\\n        }\\n        return 0;\\n    }",
                "solutionTags": [],
                "code": "private static int cuts(int A, int B){\\n        int sum = A + B;\\n        int length = sum/4;\\n        while(length>0){\\n            if((A/length + B/length)==4)\\n                return length;\\n            else\\n                length--;\\n        }\\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1940922,
                "title": "python-3-lines-of-code-faster-than-96",
                "content": "Upvote if it was usefull for you \\uD83D\\uDE42\\n\\n```\\nclass Solution:\\n    class Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product=1\\n        for n in nums: product*=n\\n        return 1 if product > 1 else (-1 if product < 0 else 0)",
                "solutionTags": [
                    "Python"
                ],
                "code": "Upvote if it was usefull for you \\uD83D\\uDE42\\n\\n```\\nclass Solution:\\n    class Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product=1\\n        for n in nums: product*=n\\n        return 1 if product > 1 else (-1 if product < 0 else 0)",
                "codeTag": "Java"
            },
            {
                "id": 1484036,
                "title": "simple-javascript-solution",
                "content": "```\\nvar arraySign = function(nums) {\\n    if(nums.includes(0)) return 0;\\n    return (nums.filter(item => item < 0).length % 2 === 0 ? 1 : -1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arraySign = function(nums) {\\n    if(nums.includes(0)) return 0;\\n    return (nums.filter(item => item < 0).length % 2 === 0 ? 1 : -1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1463239,
                "title": "ruby-oneliner",
                "content": "```\\ndef array_sign(nums)\\n   nums.inject(:*) <=> 0\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef array_sign(nums)\\n   nums.inject(:*) <=> 0\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3478304,
                "title": "java-solution-for-sign-of-the-product-of-an-array-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n The intuition behind this approach is that the sign of the product of an array of numbers is determined by the number of negative elements in the array. If the number of negative elements is even, the product is positive, otherwise, it is negative. If there is a zero in the array, then the product is zero.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis implementation counts the number of negative integers in the input array. If the count is even, the product of all numbers is positive, and signFunc() returns 1. If the count is odd, the product of all numbers is negative, and signFunc() returns -1. If the input array contains a zero, the product is zero, and signFunc() returns 0. This approach works well even for large length of nums.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), where n is the length of the input array.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe solution uses a constant amount of space to store the count of negative elements, so the space complexity is O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n       int countNegatives = 0;\\n        for (int num : nums) \\n        {\\n            if (num == 0) \\n            {\\n                return 0;\\n            } \\n            else if (num < 0) \\n            {\\n                countNegatives++;\\n            }\\n        }\\n        return (countNegatives % 2 == 0) ? 1 : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n       int countNegatives = 0;\\n        for (int num : nums) \\n        {\\n            if (num == 0) \\n            {\\n                return 0;\\n            } \\n            else if (num < 0) \\n            {\\n                countNegatives++;\\n            }\\n        }\\n        return (countNegatives % 2 == 0) ? 1 : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477311,
                "title": "fastest-way-to-solve-this-question-beats-100",
                "content": "# What question says\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere is a function signFunc(x) that returns:\\n\\n1 if x is positive.\\n-1 if x is negative.\\n0 if x is equal to 0.\\n\\nYou are given an integer array nums. Let product be the product of all values in the array nums.\\n\\n# Approach\\n\\n1. The arraySign method takes an integer array nums as input.\\n\\n2. The method initializes the product variable to 1, which represents a positive product.\\n\\n3. The loop iterates over each element num of the input array nums.\\n\\n4. If the current element num is equal to 0, then the method immediately returns 0, since the product of the array will also be 0.\\n\\n5. If the current element num is negative (num < 0), then the product variable is multiplied by -1, which effectively flips the sign of the product to negative.\\n\\n6. After the loop has finished iterating over all the elements, the method returns the value of product.\\n\\n7. If product is positive, the method returns 1, which represents a positive product.\\n\\n8. If product is negative, the method returns -1, which represents a negative product.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int sign = 1;\\n        for (int num : nums) {\\n            if (num == 0) {\\n                return 0;\\n            } else if (num < 0) {\\n                sign *= -1;\\n            }\\n        }\\n        return sign;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int sign = 1;\\n        for (int num : nums) {\\n            if (num == 0) {\\n                return 0;\\n            } else if (num < 0) {\\n                sign *= -1;\\n            }\\n        }\\n        return sign;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477050,
                "title": "easy-js-one-liner",
                "content": "# Code\\n```\\nconst arraySign = nums => nums.includes(0) ? 0 : Math.sign(nums.reduce((p, n) => p * n, 1));\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst arraySign = nums => nums.includes(0) ? 0 : Math.sign(nums.reduce((p, n) => p * n, 1));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3476507,
                "title": "detailed-analysis-and-explanation-for-3-approach-in-python-with-time-comparison",
                "content": "## Simple approach but contains explanation to why I wrote what I wrote!\\nClearly, you cannot multiply each element and then return the sign of the product. This is not feasible as we will be storing large size of data.\\n\\n`Check the execution time for each approach in Python at the end of 3 python approaches`\\n# Code in Python: Approach 1\\n\\n1. Given that we have to `return 0` when we find a \\'0\\', simply put in a condition in the loop for this.\\n2. Initialize `sign` to 1 and if you find a **neg**ative **num**ber, **flip the sign**\\n3. Return the `sign` at the end.\\n``` Python_Approach_1 []\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        sign = 1\\n\\n        for i in nums:\\n\\n            if i == 0:\\n                return 0\\n\\n            if i < 0:\\n                sign = -sign\\n        \\n        return sign\\n```\\n# Code in Python: Approach 2\\n1. Return 0, if you find 0 in the list.\\n2. Initiliaze `sign=1`.\\n3. For each element, set `sign *= element//abs(element)`\\n\\n``` Python_Approach_2 []\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        sign = 1\\n\\n        for i in nums:\\n\\n            if i == 0:\\n                return 0\\n\\n            sign *= i // abs(i)\\n        \\n        return sign\\n```\\n# Code in Python: Approach 3\\n1. Return 0, if you find 0 in the list.\\n2. Initiliaze `countOfNegatives=0`.\\n3. For each **neg**ative **ele**ment, set `countOfNegatives += 1`.\\n4. After the loop, **return 1** if `countOfNegatives % 2 == 0`. This means that there are even number of negatives.\\n**(-1)<sup>2*n</sup> = 1**\\n5. Else, return -1\\n**(-1)<sup>2*n+1</sup> = -1**\\n\\n``` Python_Approach_3 []\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        countOfNegatives = 0\\n\\n        for i in nums:\\n\\n            if i == 0:\\n                return 0\\n\\n            if i < 0:\\n                countOfNegatives += 1\\n        \\n        return 1 if countOfNegatives % 2 == 0 else -1\\n```\\n<br>\\n\\n# Comparing Python execution time using timeit (in ms)\\n```ExecutionTime_Approach1 []\\n>>>timeit.timeit(\\'-19<0\\', number = 10**8) \\n    + timeit.timeit(\\'-(-19)\\', number = 10**8)\\n2.5612723330050358\\n```\\n\\n```ExecutionTime_Approach2 []\\n>>>timeit.timeit(\\'1 * (-19)//abs(-19)\\', number = 10**8)\\n3.7137523339988547\\n>>>timeit.timeit(\\'-1 * (-19)//abs(-19)\\', number = 10**8)\\n3.7235794579974026\\n```\\n\\n```ExecutionTime_Approach3 []\\n>>>timeit.timeit(\\'-19<0\\', number = 10**8) \\n    + timeit.timeit(\\'1+1\\', number = 10**8)\\n    + timeit.timeit(\\'2 % 2 == 0\\', number = 10**8)\\n4.421872499995516\\n```\\n---\\n\\n# Code in C\\n1. Use an **int** **var**iable for `sign` and initialize to 1.\\n2. When you find a negative number, **flip the sign**.\\n3. At the end, return the `sign`.\\n``` C []\\nint arraySign(int* nums, int numsSize){\\n\\n# Initialize sign to 1\\nint sign = 1;\\n\\nfor(int i =0; i<numsSize; i++){\\n\\n    if(nums[i] == 0)\\n        # If you encounter zero, the entire product will be zero\\n        return 0;\\n\\n    if (nums[i] < 0)\\n        # If number is negative, flip the sign\\n        sign = -sign;\\n}\\n\\nreturn sign;\\n}\\n```\\n\\n### Please consider upvoting if you liked it or comment if you have a better alternative! Thank you!",
                "solutionTags": [
                    "Python3",
                    "C",
                    "Array",
                    "Math",
                    "Number Theory"
                ],
                "code": "``` Python_Approach_1 []\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        sign = 1\\n\\n        for i in nums:\\n\\n            if i == 0:\\n                return 0\\n\\n            if i < 0:\\n                sign = -sign\\n        \\n        return sign\\n```\n``` Python_Approach_2 []\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        sign = 1\\n\\n        for i in nums:\\n\\n            if i == 0:\\n                return 0\\n\\n            sign *= i // abs(i)\\n        \\n        return sign\\n```\n``` Python_Approach_3 []\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        countOfNegatives = 0\\n\\n        for i in nums:\\n\\n            if i == 0:\\n                return 0\\n\\n            if i < 0:\\n                countOfNegatives += 1\\n        \\n        return 1 if countOfNegatives % 2 == 0 else -1\\n```\n```ExecutionTime_Approach1 []\\n>>>timeit.timeit(\\'-19<0\\', number = 10**8) \\n    + timeit.timeit(\\'-(-19)\\', number = 10**8)\\n2.5612723330050358\\n```\n```ExecutionTime_Approach2 []\\n>>>timeit.timeit(\\'1 * (-19)//abs(-19)\\', number = 10**8)\\n3.7137523339988547\\n>>>timeit.timeit(\\'-1 * (-19)//abs(-19)\\', number = 10**8)\\n3.7235794579974026\\n```\n```ExecutionTime_Approach3 []\\n>>>timeit.timeit(\\'-19<0\\', number = 10**8) \\n    + timeit.timeit(\\'1+1\\', number = 10**8)\\n    + timeit.timeit(\\'2 % 2 == 0\\', number = 10**8)\\n4.421872499995516\\n```\n``` C []\\nint arraySign(int* nums, int numsSize){\\n\\n# Initialize sign to 1\\nint sign = 1;\\n\\nfor(int i =0; i<numsSize; i++){\\n\\n    if(nums[i] == 0)\\n        # If you encounter zero, the entire product will be zero\\n        return 0;\\n\\n    if (nums[i] < 0)\\n        # If number is negative, flip the sign\\n        sign = -sign;\\n}\\n\\nreturn sign;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476425,
                "title": "two-approach-without-product-and-with-product-c-beats-100",
                "content": "# Intuition\\nFirst Approach-01:\\nIn this we create a `signFunc` as stated in the question \\nThen We simply do the product of all elements in vector and then pass it to the `signFunc` \\nMain trick to this Question is **Modulo operator**\\nAs the product will exceed the int or long long Range so to overcome that we have to use a number to limit the product and to limit a number so that it dont cross a specific range we use Modulo operator \\n\\nThe task is to determine which number we can take as the upper limit\\nSo for that we will go for 1e9+7 (i.e. 1000000007) as it is the highest prime number close to the range of int data type.\\n*P.S. you can google it to know more about it *\\n\\nSecond Approach-02:(**Easy and Brainer way**)\\nIn this method we are counting the no. of negative elements and if we found a zero we will return the 0\\n\\nif we dont then we simply check the count of negative number,\\nif count is multiple of two then the resultant product will always be a positive number \\nelse it will be a negative number\\n\\n\\n\\n# Approach-01-Code\\n```\\nclass Solution {\\npublic:\\n    int signFunc(long long product){\\n        if(product < 0){\\n            return -1;\\n        }\\n        else if(product > 0){\\n            return 1;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n    int arraySign(vector<int>& n) {\\n        long long int product=1;\\n\\n        for(auto val:n){\\n            product *= val*1ll;\\n            product = product%1000000007 ;\\n        }\\n\\n        return signFunc(product);\\n    }\\n};\\n```\\n# Approach-02-Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& n) {\\n        int count=0;\\n        \\n        for(auto val:n){\\n            if(val<0){\\n                count++;\\n            }\\n            else if(val==0){\\n                return 0;\\n            }\\n        }\\n\\n        if(count&1){//condition to check a number is odd\\n            return -1;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int signFunc(long long product){\\n        if(product < 0){\\n            return -1;\\n        }\\n        else if(product > 0){\\n            return 1;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n    int arraySign(vector<int>& n) {\\n        long long int product=1;\\n\\n        for(auto val:n){\\n            product *= val*1ll;\\n            product = product%1000000007 ;\\n        }\\n\\n        return signFunc(product);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& n) {\\n        int count=0;\\n        \\n        for(auto val:n){\\n            if(val<0){\\n                count++;\\n            }\\n            else if(val==0){\\n                return 0;\\n            }\\n        }\\n\\n        if(count&1){//condition to check a number is odd\\n            return -1;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476268,
                "title": "o-n-solution-java-python-easy-explained",
                "content": "# Intuition\\n- if any one is 0 all will get 0 \\n- if count of neg is even they will cancel each of them we will get positive \\n- if count of neg is odd it will be negative \\n\\n# Code\\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        neg_cnt = 0\\n\\n        for i in nums:\\n            if(i==0):\\n                return 0\\n            elif(i<0):\\n                neg_cnt+=1\\n        \\n        if(neg_cnt%2==0):\\n            return 1\\n        return -1\\n```\\n# Java \\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int cntneg = 0;\\n        for(int i: nums){\\n            if(i==0){\\n                return 0;\\n            }else if(i<0){\\n                cntneg++;\\n            }\\n        }\\n        return cntneg%2==0?1:-1;\\n    }\\n}\\n```\\n# Complexity \\n- TC: O(n)\\n- SC: O(1)",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        neg_cnt = 0\\n\\n        for i in nums:\\n            if(i==0):\\n                return 0\\n            elif(i<0):\\n                neg_cnt+=1\\n        \\n        if(neg_cnt%2==0):\\n            return 1\\n        return -1\\n```\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int cntneg = 0;\\n        for(int i: nums){\\n            if(i==0){\\n                return 0;\\n            }else if(i<0){\\n                cntneg++;\\n            }\\n        }\\n        return cntneg%2==0?1:-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475884,
                "title": "python-shortest-1-liner-functional-programming",
                "content": "# Approach\\n1. Let `sign` be a function that returns `1` for positive numbers, `-1` for negative, and `0` for zero. We can define this as:\\n`sign = lambda x: (x > 0) - (x < 0)`\\n\\n2. Apply `sign` to each number in `nums`.\\n\\n3. Return the product of the signs.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere, `n is length of nums`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def arraySign(self, nums: list[int]) -> int:\\n        return reduce(mul, map(lambda x: (x > 0) - (x < 0), nums))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n    def arraySign(self, nums: list[int]) -> int:\\n        return reduce(mul, map(lambda x: (x > 0) - (x < 0), nums))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475742,
                "title": "easy-java-solution-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int c=0;\\n        for(int i=0;i<nums.length;i++){\\n          if(nums[i]==0)\\n          return 0;\\n          if(nums[i]<0)\\n          c++;\\n        }\\n        return c%2==0 ? 1:-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int c=0;\\n        for(int i=0;i<nums.length;i++){\\n          if(nums[i]==0)\\n          return 0;\\n          if(nums[i]<0)\\n          c++;\\n        }\\n        return c%2==0 ? 1:-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475616,
                "title": "java-solutions-easy-to-understand-100",
                "content": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int prod = 1;\\n        for(int i: nums){\\n            if(i < 0){\\n                prod *= -1;\\n            }else if(i > 0){\\n                prod *= 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        return prod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int prod = 1;\\n        for(int i: nums){\\n            if(i < 0){\\n                prod *= -1;\\n            }else if(i > 0){\\n                prod *= 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        return prod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475415,
                "title": "easy-java-solution-using-iteration-beginner-friendly",
                "content": "# Intuition\\nIn Multiplciation\\n1. If any element is 0, multiplication is 0\\n2. if number if negative element are odd, multiplication is negative\\n3. multiplication is positive in other case\\n\\n# Approach\\n1. Count number of negative elements\\n2. If you see 0 while traversing, return 0 immediately\\n3. At the end if number of negative numbers is odd, return -1 else return 1 \\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int negativeCount = 0;\\n        for(int num : nums) {\\n            if(num == 0) {\\n                return 0;\\n            } else if( num < 0) {\\n                negativeCount++;\\n            }\\n        }\\n\\n        if(negativeCount % 2 == 1) {\\n            return -1;\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int negativeCount = 0;\\n        for(int num : nums) {\\n            if(num == 0) {\\n                return 0;\\n            } else if( num < 0) {\\n                negativeCount++;\\n            }\\n        }\\n\\n        if(negativeCount % 2 == 1) {\\n            return -1;\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475402,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        if 0 in nums:\\n            return 0\\n\\n        res=1\\n        for x in nums:\\n            res*=int(x/abs(x))\\n\\n        return res        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        if 0 in nums:\\n            return 0\\n\\n        res=1\\n        for x in nums:\\n            res*=int(x/abs(x))\\n\\n        return res        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274865,
                "title": "c-2-solutions-easy-understanding",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int product = 1 ; \\n        for (int i = 0 ; i < nums.size() ; i ++)\\n        {\\n            if (nums[i] == 0)\\n            {\\n                return 0 ; \\n            }\\n\\n            else if (nums[i] < 0)\\n            {\\n                product *= -1 ; \\n            }\\n\\n            else \\n            {\\n                product *= 1 ;\\n            }\\n        }\\n        return product ; \\n    }\\n};\\n```\\n---\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code \\n```C++ []\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int product = 1 ; \\n        for (int i = 0 ; i < nums.size() ; i ++)\\n        {\\n            if (nums[i] == 0)\\n            {\\n                return 0 ; \\n            }\\n\\n            else if (nums[i] < 0)\\n            {\\n                product *= -1 ; \\n            }\\n\\n            else \\n            {\\n                product *= 1 ;\\n            }\\n        }\\n        return product ; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/7990c4ba-a757-4a76-9eed-0d4cba0b8b5c_1678339994.0675652.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int product = 1 ; \\n        for (int i = 0 ; i < nums.size() ; i ++)\\n        {\\n            if (nums[i] == 0)\\n            {\\n                return 0 ; \\n            }\\n\\n            else if (nums[i] < 0)\\n            {\\n                product *= -1 ; \\n            }\\n\\n            else \\n            {\\n                product *= 1 ;\\n            }\\n        }\\n        return product ; \\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int product = 1 ; \\n        for (int i = 0 ; i < nums.size() ; i ++)\\n        {\\n            if (nums[i] == 0)\\n            {\\n                return 0 ; \\n            }\\n\\n            else if (nums[i] < 0)\\n            {\\n                product *= -1 ; \\n            }\\n\\n            else \\n            {\\n                product *= 1 ;\\n            }\\n        }\\n        return product ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266151,
                "title": "java-easy-and-explained-solution-speed-beats-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution involves a simple **iteration of the array**, we can track the **sign** of the product without actually make the operation.  \\n\\n*At each iteration* we have to do three operations:\\n1) If the **number is zero**, `return 0` this because the product of every number with zero is zero;\\n2) If the **number is negative**, change the sign of the result;\\n3) If the **number is positive** go to the next iteration, this case does not change the sign of the result.\\n\\n**Note:** Is important *to not make the operation* because the product of lots of high numbers can generate an **overflow** (this happen when the operation attempts to create a numeric value that is outside of the range that can be represented with a given number of digits).\\n\\n# Complexity\\n- **Time complexity:** $O(n)$\\n- **Speed Beats:** 100%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity:** $O(1)$\\n- **Memory Beats:** 74.72%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        \\n        int sign = 1;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            \\n            if (nums[i] == 0)\\n                return 0;\\n            if (nums[i] < 0)\\n                sign *= -1;\\n        }\\n\\n        return sign;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        \\n        int sign = 1;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            \\n            if (nums[i] == 0)\\n                return 0;\\n            if (nums[i] < 0)\\n                sign *= -1;\\n        }\\n\\n        return sign;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3226033,
                "title": "brute-force-but-beginner-friendly-code-c-62-69-beats",
                "content": "# Intuition\\n![upvote 1.jpeg](https://assets.leetcode.com/users/images/ff5c7348-6a3c-4428-886c-5682f8b40092_1678369404.0709472.jpeg)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      \\n        int size = nums.size () ;\\n        double pro = 1 ;\\n       \\n        for ( int i = 0 ; i < size ; i ++ ){\\n            pro = pro * nums[ i ] ;\\n         }\\n         if ( pro > 0 ) {\\n             return 1 ;\\n        }\\n        else if ( pro < 0 ){\\n            return -1; \\n        }\\n        else \\n        return 0 ;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      \\n        int size = nums.size () ;\\n        double pro = 1 ;\\n       \\n        for ( int i = 0 ; i < size ; i ++ ){\\n            pro = pro * nums[ i ] ;\\n         }\\n         if ( pro > 0 ) {\\n             return 1 ;\\n        }\\n        else if ( pro < 0 ){\\n            return -1; \\n        }\\n        else \\n        return 0 ;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128152,
                "title": "simple-javascript-solution-using-reduce-method-of-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    const pdt = nums.reduce((a,b)=>a*b,1);\\n    if(pdt<0){\\n        return -1;\\n    }\\n    else if (pdt >0){\\n        return 1;\\n    }\\n    return 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    const pdt = nums.reduce((a,b)=>a*b,1);\\n    if(pdt<0){\\n        return -1;\\n    }\\n    else if (pdt >0){\\n        return 1;\\n    }\\n    return 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3068013,
                "title": "simple-solution-with-explanation-on-swift",
                "content": "# Explanation\\n1. Check if nums array contains zero. __0 * n = 0__\\n2. Find how many negative numbers in array\\n3. if its even: __-2 * -2 = 4__. So result will be 1.\\n4. if its odd: __-2 * -2 * -1 = -4__. In this way result will be -1.\\n# Code\\n```\\nclass Solution {\\n    func arraySign(_ nums: [Int]) -> Int {\\n        guard !nums.contains(0) else { return 0 }\\n        return nums.filter { $0 < 0 }.count % 2 == 0 ? 1 : -1\\n    }\\n}\\n```\\n### Please upvote if my solution was helpful to you!",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func arraySign(_ nums: [Int]) -> Int {\\n        guard !nums.contains(0) else { return 0 }\\n        return nums.filter { $0 < 0 }.count % 2 == 0 ? 1 : -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926532,
                "title": "superb-logic-in-python3-java-golang",
                "content": "# 1. Python3 Solution\\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        answer=0\\n        for i in nums:\\n            if i==0:\\n                return 0\\n            if i<0:\\n                answer+=1\\n        return 1 if answer%2==0 else -1\\n\\t\\t\\n```\\n# 2. Golang Solution \\n```\\nfunc arraySign(nums []int) int {\\n    answer:=0\\n    for _,v:=range nums{\\n        if v==0{\\n            return 0\\n        }\\n        if v<0{\\n            answer++\\n        }\\n    }\\n    if answer%2==0{\\n        return 1\\n    }\\n    return -1\\n}\\n```\\n# 3. Java Solution\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int answer=0;\\n        for(int n :nums){\\n            if (n==0){\\n                return 0;\\n            }\\n            if (n<0){\\n                answer++;\\n            }\\n        }\\n        return answer%2==0?1:-1;\\n    }\\n}\\n```\\n# 4. Python3 Solution\\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        #import math\\n        list1=[]\\n        for i in nums:\\n            if i<0:\\n                list1.append(-1)\\n            elif i>0:\\n                list1.append(1)\\n            else:\\n                list1.append(0)\\n        list2=math.prod(list1)\\n        return list2\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Go"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        answer=0\\n        for i in nums:\\n            if i==0:\\n                return 0\\n            if i<0:\\n                answer+=1\\n        return 1 if answer%2==0 else -1\\n\\t\\t\\n```\n```\\nfunc arraySign(nums []int) int {\\n    answer:=0\\n    for _,v:=range nums{\\n        if v==0{\\n            return 0\\n        }\\n        if v<0{\\n            answer++\\n        }\\n    }\\n    if answer%2==0{\\n        return 1\\n    }\\n    return -1\\n}\\n```\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int answer=0;\\n        for(int n :nums){\\n            if (n==0){\\n                return 0;\\n            }\\n            if (n<0){\\n                answer++;\\n            }\\n        }\\n        return answer%2==0?1:-1;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        #import math\\n        list1=[]\\n        for i in nums:\\n            if i<0:\\n                list1.append(-1)\\n            elif i>0:\\n                list1.append(1)\\n            else:\\n                list1.append(0)\\n        list2=math.prod(list1)\\n        return list2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761996,
                "title": "fully-explained-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will maintain a counter to calculate the negative values in the array.\\nIf the counter got the even value after traversing the whole array, it means the product of all array elements will be positive.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraverse the array, \\nIf any element in the array appears to be 0, simply return 0;\\nIf we encounter any negative value then we will increase our negativeCount by 1;\\n\\nWe dont have to deal with positive values as positive*positive is always positive.\\n\\nIn the last we will check if negativeCount is even or not, if its even, then product will be positive, else it will be negative.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        //counter to keep track of negative values\\n        int negativeCount = 0;\\n        //Traversing the loop\\n        for(int i=0; i<nums.length; i++) {\\n            //If any array element is 0, product will be zero\\n            if(nums[i] == 0) {\\n                return 0;\\n            }\\n            //If negative number, then increase the negativeCount by 1\\n            if(nums[i] < 0) {\\n                negativeCount++;\\n            }\\n        }\\n        //If negativeCount is even, product will be positive, hence return 1\\n        if(negativeCount%2 == 0) {\\n            return 1;\\n        } else {    //negativeCount is odd, product will be negative\\n            return -1; \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        //counter to keep track of negative values\\n        int negativeCount = 0;\\n        //Traversing the loop\\n        for(int i=0; i<nums.length; i++) {\\n            //If any array element is 0, product will be zero\\n            if(nums[i] == 0) {\\n                return 0;\\n            }\\n            //If negative number, then increase the negativeCount by 1\\n            if(nums[i] < 0) {\\n                negativeCount++;\\n            }\\n        }\\n        //If negativeCount is even, product will be positive, hence return 1\\n        if(negativeCount%2 == 0) {\\n            return 1;\\n        } else {    //negativeCount is odd, product will be negative\\n            return -1; \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723756,
                "title": "one-line-python-code",
                "content": "Don\\'t use this for interview, just for fun :)\\n\\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        \\n        return reduce(lambda x, y: x*y, [0 if x==0 else (1 if x>0 else -1) for x in nums])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        \\n        return reduce(lambda x, y: x*y, [0 if x==0 else (1 if x>0 else -1) for x in nums])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2627194,
                "title": "java-solution-no-need",
                "content": "```\\n public int arraySign(int[] a) {\\n     int n=a.length;\\n        int sign=1;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==0){\\n                return 0;\\n            }\\n            else if(a[i]<0){\\n                sign=-sign;\\n            } \\n        }          \\n      return sign;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int arraySign(int[] a) {\\n     int n=a.length;\\n        int sign=1;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==0){\\n                return 0;\\n            }\\n            else if(a[i]<0){\\n                sign=-sign;\\n            } \\n        }          \\n      return sign;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2577104,
                "title": "easy-solution-fast-cpp",
                "content": "solution in CPP:\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n       long long prod=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          if(nums[i]<0)\\n                prod*=-1;\\n            if(nums[i]==0)\\n                return 0;\\n            \\n        }\\n        if(prod<0)\\n            return -1;\\n        else\\n            return 1;\\n       \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n       long long prod=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          if(nums[i]<0)\\n                prod*=-1;\\n            if(nums[i]==0)\\n                return 0;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2298279,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n = nums.size();\\n        int neg = 0; // number of negative numbers in given array\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == 0) return 0; // there is no doubt, that if one of the multipliers is zero, the product is also zero\\n            if(nums[i] < 0) neg++; // count negative numbers in our array\\n        }\\n        return neg % 2 == 0 ? 1 : -1; // obviously, if the number of negative numbers is odd, the product is also odd\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n = nums.size();\\n        int neg = 0; // number of negative numbers in given array\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == 0) return 0; // there is no doubt, that if one of the multipliers is zero, the product is also zero\\n            if(nums[i] < 0) neg++; // count negative numbers in our array\\n        }\\n        return neg % 2 == 0 ? 1 : -1; // obviously, if the number of negative numbers is odd, the product is also odd\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2224875,
                "title": "python3-simple-one-liner",
                "content": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        \\n        def signFun(x):\\n            return 1 if x > 0 else -1 if x < 0 else 0\\n        \\n        return signFun(math.prod(nums))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        \\n        def signFun(x):\\n            return 1 if x > 0 else -1 if x < 0 else 0\\n        \\n        return signFun(math.prod(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990967,
                "title": "java-easy-solution-faster-than-100",
                "content": "class Solution {\\n\\n    public int arraySign(int[] nums) {\\n\\t\\n        if(nums[0]==0)\\n            return 0;\\n        int sign= (int)nums[0]/Math.abs(nums[0]);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            \\n            if(nums[i]==0)\\n                return 0;\\n            \\n            if(nums[i]<0)\\n                sign*=-1;\\n        }\\n        return sign;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int arraySign(int[] nums) {\\n\\t\\n        if(nums[0]==0)\\n            return 0;\\n        int sign= (int)nums[0]/Math.abs(nums[0]);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            \\n            if(nums[i]==0)\\n                return 0;\\n            \\n            if(nums[i]<0)\\n                sign*=-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1913659,
                "title": "c-simple-solution-96-beats",
                "content": "Here I looped through the vector and with every element, I determined the sign of the product into a variable .\\nThis way we dont have to store huge valued data into a variable.\\n\\nTime Complexity : O(n)\\n\\n```\\n short int prod=1; /*this stores the sign of intermediate result*/\\n        \\n        for(int i:nums){\\n            prod*=i;\\n            \\n            if(prod>0)\\n\\t\\t\\t\\t\\tprod=1;\\n            else if(prod<0)\\n\\t\\t\\t\\t\\tprod=-1;\\n        }\\n        \\n        return prod;\\n```\\n\\n**Upvote** if you find this helpful. Thanks.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n short int prod=1; /*this stores the sign of intermediate result*/\\n        \\n        for(int i:nums){\\n            prod*=i;\\n            \\n            if(prod>0)\\n\\t\\t\\t\\t\\tprod=1;\\n            else if(prod<0)\\n\\t\\t\\t\\t\\tprod=-1;\\n        }\\n        \\n        return prod;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1897009,
                "title": "java-solution-100-beats-tc-o-n-sc-o-1",
                "content": "class Solution {\\n    public int arraySign(int[] nums) {\\n        int sign=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n                return 0;\\n            }\\n            else if(nums[i]<0){\\n                sign=-sign;\\n            }\\n        }\\n        return sign;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int arraySign(int[] nums) {\\n        int sign=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1819961,
                "title": "c-simple-code-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<0){\\n                ans*=-1;\\n            }\\n            if(nums[i]==0){\\n                ans=0;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nDo upvote if you understood :-)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<0){\\n                ans*=-1;\\n            }\\n            if(nums[i]==0){\\n                ans=0;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818106,
                "title": "rust-one-liner-with-bit-op",
                "content": "```\\nimpl Solution {\\n    pub fn array_sign(nums: Vec<i32>) -> i32 {\\n        nums.iter()\\n            .try_fold(0, |sign, &x| if x == 0 {Err(0)} else {Ok(sign^x)})\\n            .map(|sign| if sign < 0 {-1} else {1})\\n            .unwrap_or(0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Bit Manipulation"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn array_sign(nums: Vec<i32>) -> i32 {\\n        nums.iter()\\n            .try_fold(0, |sign, &x| if x == 0 {Err(0)} else {Ok(sign^x)})\\n            .map(|sign| if sign < 0 {-1} else {1})\\n            .unwrap_or(0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1200880,
                "title": "weeb-does-python-beats-99-32",
                "content": "![image](https://assets.leetcode.com/users/images/3e437a72-274e-4ada-890e-1cba6b175b2f_1620638449.5641868.png)\\n\\n\\tclass Solution:\\n\\t\\tdef arraySign(self, nums: List[int]) -> int:\\n\\t\\t\\tnums, count = sorted(nums), 0\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tif nums[i] == 0:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tif nums[i] > 0:\\n\\t\\t\\t\\t\\tif count % 2 == 0: return 1 \\n\\t\\t\\t\\t\\telse: return -1\\n\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\n\\t\\t\\tif count % 2 == 0: # if all are negative\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telse: return -1\\n\\t\\t\\nAIght coders, its time for some anime recommendations \\nTry watching **Y\\u014Dkoso Jitsuryoku Shij\\u014D Shugi no Ky\\u014Dshitsu e(Classroom of the Elite)**\\n\\n# Episodes: 12\\n# Genres: Comedy(not sure about that but its what kicassanime says), School, Romance\\n\\nThe protagonist in this anime is a savage and everyone in this highschool has a contorted mentality\\nWatch it yourself, its quite interesting",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/3e437a72-274e-4ada-890e-1cba6b175b2f_1620638449.5641868.png)\\n\\n\\tclass Solution:\\n\\t\\tdef arraySign(self, nums: List[int]) -> int:\\n\\t\\t\\tnums, count = sorted(nums), 0\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tif nums[i] == 0:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tif nums[i] > 0:\\n\\t\\t\\t\\t\\tif count % 2 == 0: return 1 \\n\\t\\t\\t\\t\\telse: return -1\\n\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\n\\t\\t\\tif count % 2 == 0: # if all are negative\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telse: return -1\\n\\t\\t\\nAIght coders, its time for some anime recommendations \\nTry watching **Y\\u014Dkoso Jitsuryoku Shij\\u014D Shugi no Ky\\u014Dshitsu e(Classroom of the Elite)**\\n\\n# Episodes: 12\\n# Genres: Comedy(not sure about that but its what kicassanime says), School, Romance\\n\\nThe protagonist in this anime is a savage and everyone in this highschool has a contorted mentality\\nWatch it yourself, its quite interesting",
                "codeTag": "Java"
            },
            {
                "id": 1155585,
                "title": "c-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int arraySign(const vector<int>& nums) {\\n        int neg=0;\\n        for(auto i:nums) {\\n            if(i<0) ++neg;\\n            else if(!i) return 0;\\n        }\\n        return neg%2?-1:1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int arraySign(const vector<int>& nums) {\\n        int res=1;\\n        for(auto i:nums) {\\n            if(i<0) res=-res;\\n            else if(!i) return 0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(const vector<int>& nums) {\\n        int neg=0;\\n        for(auto i:nums) {\\n            if(i<0) ++neg;\\n            else if(!i) return 0;\\n        }\\n        return neg%2?-1:1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int arraySign(const vector<int>& nums) {\\n        int res=1;\\n        for(auto i:nums) {\\n            if(i<0) res=-res;\\n            else if(!i) return 0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152844,
                "title": "c-easy-and-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) \\n    {\\n        int ans = 1;\\n        for(int i : nums)\\n        {\\n            if(i < 0)\\n                ans *= -1;\\n            if(i == 0)\\n                return 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) \\n    {\\n        int ans = 1;\\n        for(int i : nums)\\n        {\\n            if(i < 0)\\n                ans *= -1;\\n            if(i == 0)\\n                return 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892204,
                "title": "simply-code-beat-100-of-users-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] ==0) return 0;\\n            else if(nums[i]<0)\\n           count++;\\n        }\\n        if(count%2==0) return 1;\\n        else return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] ==0) return 0;\\n            else if(nums[i]<0)\\n           count++;\\n        }\\n        if(count%2==0) return 1;\\n        else return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672974,
                "title": "c-code-0ms-runtime-faster-than-100",
                "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n    int d=0;\\n    for(int i=0;i<nums.size();i++){\\n     if(nums[i]<0){\\n          d=d+1;\\n        \\n      }\\n      else if(nums[i]==0){\\n         return 0;\\n      }\\n     \\n  }\\n   \\n    if(d%2==0){\\n        return 1;\\n    }\\n   return -1;\\n\\n}\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n    int d=0;\\n    for(int i=0;i<nums.size();i++){\\n     if(nums[i]<0){\\n          d=d+1;\\n        \\n      }",
                "codeTag": "Java"
            },
            {
                "id": 3522902,
                "title": "easy-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe only need to check the sign of each integer in the given array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n>make a variable ans = 1;\\n>iterate through the array\\n> if the number is positive, multiply 1 to the ans\\n>if the number is negative, numtiply -1 to ans\\n>if the number is zero, make ans = 0;\\n\\n# Complexity\\n- Time complexity:  O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:  O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        \\n        int ans = 1;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n\\n            if(nums[i] > 0){\\n                ans *= 1;\\n            }\\n            else if(nums[i] == 0){\\n                ans = 0;\\n            }\\n            else{\\n                ans *= -1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        \\n        int ans = 1;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n\\n            if(nums[i] > 0){\\n                ans *= 1;\\n            }\\n            else if(nums[i] == 0){\\n                ans = 0;\\n            }\\n            else{\\n                ans *= -1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478995,
                "title": "o-1-space-c-easy-solution-traverse-the-array",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Maintain a variable neg =0;\\n2. increase neg every time the value of array is less than 0.\\n\\n\\n $$if$$ 0 is present in array, then return 0;\\n$$else if$$ neg is present **\\'even\\'** times, then return 1;\\n$$else$$ return -1;\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n\\n        // maintain count of negative number.\\n        int neg=0;\\n\\n        for(auto i:nums)\\n        {\\n             // if zero is present, then return 0;\\n             if(i==0) return 0;\\n\\n            // if number is negative, then increase the count\\n            if(i<0) neg++;\\n        }\\n\\n        // if count appears odd number of times.\\n        if(neg&1) return -1;\\n\\n        return 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n\\n        // maintain count of negative number.\\n        int neg=0;\\n\\n        for(auto i:nums)\\n        {\\n             // if zero is present, then return 0;\\n             if(i==0) return 0;\\n\\n            // if number is negative, then increase the count\\n            if(i<0) neg++;\\n        }\\n\\n        // if count appears odd number of times.\\n        if(neg&1) return -1;\\n\\n        return 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478965,
                "title": "easy-understable-code-javascript",
                "content": "ja# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate the array find the value \\nif value is greater than zero return 1\\nif value is lesser than zero return -1\\nif value is equal to zero return 1\\n\\n\\n# Complexity\\n- Time complexity: linear time complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    let value=1;\\n    for(let i=0;i<nums.length;i++){\\n        value=value*nums[i];\\n    }\\n    if(value>0){\\n        return 1\\n    }else if(value<0){\\n        return -1\\n    }else{\\n        return 0\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    let value=1;\\n    for(let i=0;i<nums.length;i++){\\n        value=value*nums[i];\\n    }\\n    if(value>0){\\n        return 1\\n    }else if(value<0){\\n        return -1\\n    }else{\\n        return 0\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3478763,
                "title": "1-line-math-sign",
                "content": "# Code\\n```\\nfunction arraySign(nums: number[]): number {\\n    return nums.reduce((sign, cur) => sign * Math.sign(cur), 1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction arraySign(nums: number[]): number {\\n    return nums.reduce((sign, cur) => sign * Math.sign(cur), 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3478296,
                "title": "2-liner-smart-code-faster-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int sign = 1;\\n        for(int x : nums) sign *= (x == 0) ? 0 : ((x < 1) ? -1 : 1);\\n        return (sign < 0) ? -1 : ((sign > 0) ? 1 : 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int sign = 1;\\n        for(int x : nums) sign *= (x == 0) ? 0 : ((x < 1) ? -1 : 1);\\n        return (sign < 0) ? -1 : ((sign > 0) ? 1 : 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477862,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the array contains odd numbers of negative numbers, than answer is -1.\\nIf not than answer is 1.If zero exist\\xA0in the array, then the answer is 0.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCount how many times negative exist in the array by traversing whole array.If zero exist\\xA0in the array, then return 0. if odd numbers of negative numbers than return -1.otherwise return 1.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int posnum = 0;\\n        int negnum = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                negnum++;\\n            }\\n            else if(nums[i]==0)\\n            {\\n                return 0;\\n            }\\n        }\\n        if(negnum%2!=0)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int posnum = 0;\\n        int negnum = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                negnum++;\\n            }\\n            else if(nums[i]==0)\\n            {\\n                return 0;\\n            }\\n        }\\n        if(negnum%2!=0)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477534,
                "title": "golang-solution-with-good-description",
                "content": "# Intuition\\nThe task is to find the sign of the product of the elements in the array `nums`. The initial idea is to iterate through each element of the array and determine the sign of the final product based on the properties of the signs of the numbers.\\n\\n# Approach\\nWe can use a single loop to solve this problem. In the loop, we go through each element of the array. If the current element is equal to zero, we immediately return 0, as the product will be zero. If the current element is less than zero, we increment the counter of negative numbers (`result`). After going through the loop, if the number of negative numbers is odd, we return -1; otherwise, we return 1.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where `n` is the number of elements in the array `nums`. The time complexity is linear since we iterate through each element of the array.\\n\\n- Space complexity: $$O(1)$$, as we only use a constant amount of additional space for storing the result and loop variables.\\n\\n\\n# Code\\n```\\nfunc arraySign(nums []int) int {\\n    var result int\\n    for i:=0;i<len(nums);i++{\\n        if  nums[i]==0{\\n            return 0\\n        }\\n        if nums[i]<0{\\n            result++\\n        }\\n    }\\n    if result%2!=0{\\n        return -1\\n    }    \\n    return 1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc arraySign(nums []int) int {\\n    var result int\\n    for i:=0;i<len(nums);i++{\\n        if  nums[i]==0{\\n            return 0\\n        }\\n        if nums[i]<0{\\n            result++\\n        }\\n    }\\n    if result%2!=0{\\n        return -1\\n    }    \\n    return 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3476913,
                "title": "javascript-simple-and-neat-solution-in-one-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    return nums.reduce((res, value)=>{ return value <= 0 ? value == 0 ? 0 : -res : res;}, 1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    return nums.reduce((res, value)=>{ return value <= 0 ? value == 0 ? 0 : -res : res;}, 1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3476587,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int ans = 1;\\n        for(auto x: nums) {\\n            if(x < 0) ans *= -1;\\n            else if(x > 0) ans *= 1;\\n            else ans *= 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int ans = 1;\\n        for(auto x: nums) {\\n            if(x < 0) ans *= -1;\\n            else if(x > 0) ans *= 1;\\n            else ans *= 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476428,
                "title": "simple-solution-in-java-cpp-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach will be to multiply all numbers and then see whether product is 0, positive or negative.\\n\\n__BUT__ on a closer inspection it can be seen that the numbers that affect the naswer are the ones that are less than equal to 0, Positive number don\\'t change the sign of the product\\n> -4 * 2 = -8.\\n0 * 2 = 0\\n4 * 2 = 8\\n__Whatever sign of the first term was, is continued when multiplied with a positive number, hence we dont really need to know how many positives do we have in the array.__\\n\\n__Two observations are needed to solve this question__\\n\\n>__1)__ If an element in the array is 0, product will be 0, no need   to multiply anything anymore, that how powerful 0 is here!!\\n__2)__ If the number of negative integers in the array, the answer be negative, else positive\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n>1) Traverse the array/vector\\n>2) Check if the element is 0 or not\\n>> If the element is 0, the answer or product will stay 0, no matter what is multiplied to it now, therefore return 0\\n\\n>3) Check if the number is negative\\n>>If the number is negative track the frequency of the negative numbers\\nElse Continue\\n\\n>4) If in Nothing has been return so far, check if the frequency of the negatives is odd \\n>> If, yes : return -1\\nElse Return 1\\n\\n# Complexity\\n- Time complexity $$O(n) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: $$O(1) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```java []\\nclass Solution {\\n    public int arraySign(int[] nums) \\n    {\\n        int negatives = 0;\\n        for (int number : nums)\\n            if (number < 0)\\n                negatives++;\\n            else if (number == 0)\\n                return 0;\\n        if ((negatives & 1) == 1)\\n            return -1;\\n        return 1;\\n    }\\n}\\n```\\n```cpp []\\nclass Solution\\n{\\npublic:\\n    int arraySign(vector<int> &nums)\\n    {\\n        int negatives = 0;\\n        for (int number : nums)\\n            if (number < 0)\\n                negatives++;\\n            else if (number == 0)\\n                return 0;\\n        if (negatives & 1)\\n            return -1;\\n        return 1;\\n    }\\n};\\n```\\n__Do Upvote, If it Helped :)__\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int arraySign(int[] nums) \\n    {\\n        int negatives = 0;\\n        for (int number : nums)\\n            if (number < 0)\\n                negatives++;\\n            else if (number == 0)\\n                return 0;\\n        if ((negatives & 1) == 1)\\n            return -1;\\n        return 1;\\n    }\\n}\\n```\n```cpp []\\nclass Solution\\n{\\npublic:\\n    int arraySign(vector<int> &nums)\\n    {\\n        int negatives = 0;\\n        for (int number : nums)\\n            if (number < 0)\\n                negatives++;\\n            else if (number == 0)\\n                return 0;\\n        if (negatives & 1)\\n            return -1;\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476342,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n=0;\\n        for(int i=0;i<nums.size();i++)\\n          if(nums[i]==0)\\n              return 0;\\n           else if(nums[i]<0)\\n               n++;\\n       if(n%2==1)\\n          return -1;\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n=0;\\n        for(int i=0;i<nums.size();i++)\\n          if(nums[i]==0)\\n              return 0;\\n           else if(nums[i]<0)\\n               n++;\\n       if(n%2==1)\\n          return -1;\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476194,
                "title": "easy-c-solution",
                "content": "# Intuition\\n\\n- If there are even negative numbers in the array then the result always be a positive number.\\n\\n- If there are odd negative numbers in the array then the result always be a negative number.\\n\\n# Approach\\n\\nIterate over an array and count the number of negative integers in the entire array. Check a base condition If there is any zero return answer as zero.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int ArraySign(int[] nums) {\\n        int neg = 0;\\n        \\n        foreach(var num in nums)\\n        {\\n            if(num == 0) return 0;\\n\\n            if(num < 0) neg++;\\n        }        \\n\\n        return (neg%2 == 0) ? 1 : -1;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Math"
                ],
                "code": "```\\npublic class Solution {\\n    public int ArraySign(int[] nums) {\\n        int neg = 0;\\n        \\n        foreach(var num in nums)\\n        {\\n            if(num == 0) return 0;\\n\\n            if(num < 0) neg++;\\n        }        \\n\\n        return (neg%2 == 0) ? 1 : -1;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476142,
                "title": "java-code",
                "content": "# Intuition\\nBy seeing question we can  easily understand that we have to just multiply all elsement of index.\\n\\n# Approach\\njust brute force and efficient approch\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int m=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>0){\\n                m=m*1;\\n            }else if(nums[i]<0){\\n                m*=-1;\\n            }else{\\n                m*=0;\\n            }\\n        }\\n        if(m>0){\\n            return 1;\\n        }else if(m==0){\\n             return 0;\\n        }else{\\n            return -1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int m=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>0){\\n                m=m*1;\\n            }else if(nums[i]<0){\\n                m*=-1;\\n            }else{\\n                m*=0;\\n            }\\n        }\\n        if(m>0){\\n            return 1;\\n        }else if(m==0){\\n             return 0;\\n        }else{\\n            return -1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475997,
                "title": "c-easy-solution-for-easy-problem",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        if(count(nums.begin(),nums.end(),0)){\\n            return 0;\\n        }\\n        int neg=0;\\n        sort(nums.begin(),nums.end());\\n        for(auto x:nums){\\n            if(x<0){\\n                neg++;\\n            }\\n            if(x>=0){\\n                break;\\n            }\\n        }\\n        if(neg%2==1){\\n            return -1;\\n        }\\n        else{\\n            return 1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        if(count(nums.begin(),nums.end(),0)){\\n            return 0;\\n        }\\n        int neg=0;\\n        sort(nums.begin(),nums.end());\\n        for(auto x:nums){\\n            if(x<0){\\n                neg++;\\n            }\\n            if(x>=0){\\n                break;\\n            }\\n        }\\n        if(neg%2==1){\\n            return -1;\\n        }\\n        else{\\n            return 1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475743,
                "title": "typescript-one-liner",
                "content": "# Intuition\\nInitial thoughts were to approach as described: find the product and validate. \\n\\n# Approach\\nRealised after writing a solution with initial thoughts that could actually be simplified by checking/validating based on context resulting in expected products. E.g. if `0` exists then product will always be `0` or if there\\'s an odd number of negative integers then it\\'ll alaways end up at 0.\\n\\nAfter running a basic comparison of the two approaches it appeared that checking the underlying contexts was faster on larger arrays than using a reducer to find the product. After this I simplified the function down to a one liner.\\n\\n# Code\\n```\\nfunction arraySign(nums: number[]): number {\\n    return nums.includes(0) ? 0 : !!(nums.filter((n) => n < 0).length % 2) ? -1 : 1;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction arraySign(nums: number[]): number {\\n    return nums.includes(0) ? 0 : !!(nums.filter((n) => n < 0).length % 2) ? -1 : 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3475646,
                "title": "solution-with-simple-foreach-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    var result = 1;\\n    nums.forEach(element => {\\n        result *= element;\\n    });\\n    return (result > 0)?1:(result < 0)?-1:0;\\n    \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    var result = 1;\\n    nums.forEach(element => {\\n        result *= element;\\n    });\\n    return (result > 0)?1:(result < 0)?-1:0;\\n    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3475494,
                "title": "super-easy-code-for-this-super-easy-problem",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int p = 1;\\n        for(int i = 0; i<nums.size(); i++){\\n\\n            if(nums[i]>0) p = p*1;\\n\\n            else if(nums[i]<0) p = p*-1;\\n\\n            else p = p*0;\\n        }\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int p = 1;\\n        for(int i = 0; i<nums.size(); i++){\\n\\n            if(nums[i]>0) p = p*1;\\n\\n            else if(nums[i]<0) p = p*-1;\\n\\n            else p = p*0;\\n        }\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475435,
                "title": "numpy-one-liner",
                "content": "# Approach\\nDid you know you could use numpy on LeetCode? I didn\\'t.\\n# Code\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        return np.prod(np.sign(nums))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport numpy as np\\n\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        return np.prod(np.sign(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475429,
                "title": "java-xor-shift-100-fast",
                "content": "# Intuition\\nOnly the sign bit matter.\\n\\n# Approach\\n- 2 negative sign bit cancel each other using xor.\\n- Early exit on `0`.\\n- Drag the sign bit over the whole int and set last bit.\\n\\n# Complexity\\n- Time complexity: *`O(n)`*\\n- Space complexity: *`O(1)`*\\n\\n# Code\\n```\\nclass Solution { // Vezzz\\n  public int arraySign(int[] nums) {\\n    int z = 0;\\n    for (int v : nums)\\n      if (v == 0)\\n        return 0;\\n      else\\n        z ^= v;\\n    return z >> 31 | 1;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution { // Vezzz\\n  public int arraySign(int[] nums) {\\n    int z = 0;\\n    for (int v : nums)\\n      if (v == 0)\\n        return 0;\\n      else\\n        z ^= v;\\n    return z >> 31 | 1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327954,
                "title": "java-0ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int negative_counter = 0;\\n        for (int i = 0; i < nums.length; i++){\\n            if (nums[i] < 0){\\n                negative_counter++;\\n            }\\n            if (nums[i] == 0){\\n                return 0;\\n            }\\n        }\\n        if (negative_counter % 2 != 0){\\n            return -1;\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int negative_counter = 0;\\n        for (int i = 0; i < nums.length; i++){\\n            if (nums[i] < 0){\\n                negative_counter++;\\n            }\\n            if (nums[i] == 0){\\n                return 0;\\n            }\\n        }\\n        if (negative_counter % 2 != 0){\\n            return -1;\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210258,
                "title": "scala-oneliner",
                "content": "# Code\\n```\\nobject Solution {\\n  def arraySign(nums: Array[Int]): Int = nums.map(_.sign).reduce(_ * _)\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def arraySign(nums: Array[Int]): Int = nums.map(_.sign).reduce(_ * _)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3193644,
                "title": "simple-c-solution-count-number-of-minus-numbers-explained",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor this problem you simply need to count the number of minus numbers in the array. If the number of minuses is odd, the result will be negative (-1 * 1 = -1), otherwise it will be positive (-1 * -1 = 1). Also if you ever see a zero, return 0 as anything multiplied by zero is zero..\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int ArraySign(int[] nums) {\\n        int minuses = 0;\\n\\n        foreach(int i in nums)\\n        {\\n            if(i == 0) return 0;\\n            if(i < 0) minuses++;\\n        }     \\n\\n        return minuses % 2 == 0 ? 1 :-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int ArraySign(int[] nums) {\\n        int minuses = 0;\\n\\n        foreach(int i in nums)\\n        {\\n            if(i == 0) return 0;\\n            if(i < 0) minuses++;\\n        }     \\n\\n        return minuses % 2 == 0 ? 1 :-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183410,
                "title": "simple-and-easy-to-understand-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int p=1;\\n        for(auto i: nums){\\n            if(i>0){\\n                p=p* 1;\\n            }else if(i<0){\\n                p=p*-1;\\n            }else{\\n                p=p*0;\\n            } \\n        }\\n        if(p>0){\\n            return 1;\\n        }else if(p<0){\\n            return -1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n```\\n\\nIf you like the code implementation, make sure to upvote :) \\u270C\\nKeep Coding.....\\nKeep chilling...",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int p=1;\\n        for(auto i: nums){\\n            if(i>0){\\n                p=p* 1;\\n            }else if(i<0){\\n                p=p*-1;\\n            }else{\\n                p=p*0;\\n            } \\n        }\\n        if(p>0){\\n            return 1;\\n        }else if(p<0){\\n            return -1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149267,
                "title": "c-easiest-soln",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)    , N= array size\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int c=1,d=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                c=0;\\n                break;\\n            }\\n            else if(nums[i]<0)\\n                d++;\\n        }\\n        if(c==0)\\n            return 0;\\n        if(d%2==1 && c==1)\\n            return -1;\\n    return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int c=1,d=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                c=0;\\n                break;\\n            }\\n            else if(nums[i]<0)\\n                d++;\\n        }\\n        if(c==0)\\n            return 0;\\n        if(d%2==1 && c==1)\\n            return -1;\\n    return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086440,
                "title": "easy-basic-solution-brute-force-using-loops-only",
                "content": "# Intuition\\nJust count number of negative numbers in the array, if count is even then return 1 else -1.\\nand also if one of the number in the array is zero then product will also be zero.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:  O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) \\n    {\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<0) cnt++;\\n            else if(nums[i]==0) return 0;\\n        }\\n\\n        if(cnt%2==0) return 1;\\n        return -1;\\n    }\\n};\\n\\n\\n**// please like and upvote . If you like the approach.**\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) \\n    {\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<0) cnt++;\\n            else if(nums[i]==0) return 0;\\n        }\\n\\n        if(cnt%2==0) return 1;\\n        return -1;\\n    }\\n};\\n\\n\\n**// please like and upvote . If you like the approach.**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026709,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def arraySign(nums: Array[Int]): Int = {\\n        nums.collect {\\n            case i if i<0 => -1\\n            case i if i>0 => 1\\n            case _ => 0\\n        }.product\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def arraySign(nums: Array[Int]): Int = {\\n        nums.collect {\\n            case i if i<0 => -1\\n            case i if i>0 => 1\\n            case _ => 0\\n        }.product\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2924655,
                "title": "compact-and-fast-beats-100",
                "content": "# Approach\\nChanging bool value while encountering any negetive value and just returning 0 when encountering any 0 in the array.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        boolean p=false;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0)\\n            return 0;\\n            p = (nums[i]<0)?((p)?false:true):p;\\n        }\\n        return (p)?-1:1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        boolean p=false;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0)\\n            return 0;\\n            p = (nums[i]<0)?((p)?false:true):p;\\n        }\\n        return (p)?-1:1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842760,
                "title": "easy-simple-short-c-solution",
                "content": "```\\nint n = 0;\\n        for(int i = 0; i<nums.size();i++){\\n           \\n             if(nums[i]<0){\\n                n++;\\n            }\\n            else if(nums[i] == 0){\\n                return 0;\\n            }\\n        }\\n        if(n%2 == 0){\\n            return 1;\\n        }\\n       \\n      return -1;",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nint n = 0;\\n        for(int i = 0; i<nums.size();i++){\\n           \\n             if(nums[i]<0){\\n                n++;\\n            }\\n            else if(nums[i] == 0){\\n                return 0;\\n            }\\n        }\\n        if(n%2 == 0){\\n            return 1;\\n        }\\n       \\n      return -1;",
                "codeTag": "Unknown"
            },
            {
                "id": 2823195,
                "title": "java-o-n-simple-sign-of-the-product-of-an-array",
                "content": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        Arrays.sort(nums);\\n        int neg=0;\\n        for(int i:nums)\\n        {\\n            if(i==0)return 0;\\n            else if(i<0)neg++;\\n            else break;\\n        }\\n        return neg%2==0?1:-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        Arrays.sort(nums);\\n        int neg=0;\\n        for(int i:nums)\\n        {\\n            if(i==0)return 0;\\n            else if(i<0)neg++;\\n            else break;\\n        }\\n        return neg%2==0?1:-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772511,
                "title": "java-o-n-in-just-0-ms",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        boolean isPositive = true;\\n        for (int n : nums) {\\n            if (n == 0) return 0;\\n            if (n < 0) isPositive = !isPositive;\\n        }\\n        return isPositive ? 1 : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        boolean isPositive = true;\\n        for (int n : nums) {\\n            if (n == 0) return 0;\\n            if (n < 0) isPositive = !isPositive;\\n        }\\n        return isPositive ? 1 : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767166,
                "title": "very-easy-solution-to-understand-in-python3-faster-than-99",
                "content": "```\\n        x=1\\n        for i in nums:\\n            x*=i\\n        if x==0:return 0\\n        elif x>0:return 1\\n        else:return -1\\n        \\n```\\n![image](https://assets.leetcode.com/users/images/eb8c431b-a56d-46dc-91a1-53b8ee387f77_1667314069.145179.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        x=1\\n        for i in nums:\\n            x*=i\\n        if x==0:return 0\\n        elif x>0:return 1\\n        else:return -1\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2749204,
                "title": "golang-solution-easy-understand",
                "content": "```\\n// 1822. Sign of the Product of an Array\\n// 1822. \\u6570\\u7EC4\\u5143\\u7D20\\u79EF\\u7684\\u7B26\\u53F7\\n// \\u601D\\u8DEF\\uFF1A\\u8D1F\\u8D1F\\u5F97\\u6B63\\n// time O(n) space O(1)\\nfunc arraySign(nums []int) int {\\n\\tans := 1\\n\\tfor _, num := range nums {\\n\\t\\tif num == 0 {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tif num < 0 {\\n\\t\\t\\tans = -ans\\n\\t\\t}\\n\\t}\\n\\treturn ans\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n// 1822. Sign of the Product of an Array\\n// 1822. \\u6570\\u7EC4\\u5143\\u7D20\\u79EF\\u7684\\u7B26\\u53F7\\n// \\u601D\\u8DEF\\uFF1A\\u8D1F\\u8D1F\\u5F97\\u6B63\\n// time O(n) space O(1)\\nfunc arraySign(nums []int) int {\\n\\tans := 1\\n\\tfor _, num := range nums {\\n\\t\\tif num == 0 {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tif num < 0 {\\n\\t\\t\\tans = -ans\\n\\t\\t}\\n\\t}\\n\\treturn ans\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2656027,
                "title": "c-easy-solution-beginner-friendly",
                "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) \\n    {\\n        int len = nums.size();\\n        int count = 1;\\n        \\n        for(int i = 0; i < len; i++)\\n        {\\n            if(nums[i] == 0)\\n            {\\n                return 0;\\n            }\\n            if(nums[i] < 0)\\n            {\\n                count = -count;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) \\n    {\\n        int len = nums.size();\\n        int count = 1;\\n        \\n        for(int i = 0; i < len; i++)\\n        {\\n            if(nums[i] == 0)\\n            {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2613866,
                "title": "python-simple-solution",
                "content": "```\\n# It is not neccesary to find the product of array. We only need the number of negatives in nums\\n# If number of negatives is odd result will be -1 else 1\\n# If there is one 0 result will be 0\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        neg = 0\\n        for x in nums:\\n            if x < 0:\\n                neg += 1\\n            elif x == 0:\\n                return 0\\n        if neg % 2 == 1:\\n            return -1\\n        return 1\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\n# It is not neccesary to find the product of array. We only need the number of negatives in nums\\n# If number of negatives is odd result will be -1 else 1\\n# If there is one 0 result will be 0\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        neg = 0\\n        for x in nums:\\n            if x < 0:\\n                neg += 1\\n            elif x == 0:\\n                return 0\\n        if neg % 2 == 1:\\n            return -1\\n        return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593029,
                "title": "with-explanation-comments-time-5-ms-83-42-space-10-3-mb-43-03",
                "content": "**Like it? ->Upvote please!** \\u30C4\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        \\n        //to avoid overflow, we\\'ll not use the method where product all array values & then check coditions\\n        \\n        //initialize a sign variable \\n        int sign=1;\\n        \\n        //loop over the whole array elements\\n        for(int num:nums){\\n            //check if there\\'s any 0-> product=0 & return 0\\n            if(num==0)\\n                return 0;\\n            //check if there\\'s negative value-> product will be negative-> return -1\\n            if(num<0)\\n                sign*=-1;\\n        }\\n        \\n        //if all are positive | there\\'re even number of negative values-> positive & return 1\\n        return sign;\\n    }\\n\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!** \\u30C4\\n**If still not understood, feel free to comment. I will help you out**\\n**Happy Coding :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        \\n        //to avoid overflow, we\\'ll not use the method where product all array values & then check coditions\\n        \\n        //initialize a sign variable \\n        int sign=1;\\n        \\n        //loop over the whole array elements\\n        for(int num:nums){\\n            //check if there\\'s any 0-> product=0 & return 0\\n            if(num==0)\\n                return 0;\\n            //check if there\\'s negative value-> product will be negative-> return -1\\n            if(num<0)\\n                sign*=-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2578810,
                "title": "python3-optimized-solution",
                "content": "![image](https://assets.leetcode.com/users/images/a6785442-0746-4fdb-9d2b-762ad6c565d5_1663232354.791573.png)\\n\\n\\n\\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        count_negative = 0\\n        for ele in nums:\\n            if ele<0:\\n                count_negative+=1\\n            elif ele==0:\\n                return 0\\n        if count_negative&1:\\n            return -1\\n        return 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        count_negative = 0\\n        for ele in nums:\\n            if ele<0:\\n                count_negative+=1\\n            elif ele==0:\\n                return 0\\n        if count_negative&1:\\n            return -1\\n        return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567281,
                "title": "easiest-solution-o-n-time-faster-than-100",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int arraySign(vector<int> &nums) {\\n        int neg = 0;\\n        for (int &num : nums) {\\n            if (num == 0) return 0;\\n            else if (num < 0) neg++;\\n        }\\n        return (neg % 2) ? -1 : 1;\\n    }\\n};\\n```\\n\\nPlease do upvote and share : )",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int arraySign(vector<int> &nums) {\\n        int neg = 0;\\n        for (int &num : nums) {\\n            if (num == 0) return 0;\\n            else if (num < 0) neg++;\\n        }\\n        return (neg % 2) ? -1 : 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397096,
                "title": "javascript-easy-solution",
                "content": "```\\nvar arraySign = function(nums) {\\n    let sign = true;\\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] == 0) return 0;\\n        if(nums[i] < 0) sign = !sign;\\n    }    \\n    return sign ? 1 : -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar arraySign = function(nums) {\\n    let sign = true;\\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] == 0) return 0;\\n        if(nums[i] < 0) sign = !sign;\\n    }    \\n    return sign ? 1 : -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2351669,
                "title": "java-0ms-solution",
                "content": "```class Solution {\\n    public int arraySign(int[] nums) {\\n        int neg = 0;\\n        int pos = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                neg++;\\n            }else if(nums[i]>0){\\n                pos++;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        if(neg%2==1){\\n            return -1;\\n        }\\n        return 1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int arraySign(int[] nums) {\\n        int neg = 0;\\n        int pos = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                neg++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2276614,
                "title": "javascript-fast-without-calculating-the-actual-product",
                "content": "Check elements of array.  Product sign is influenced by 0 and number of negative numbers.\\nIf the arr contains 0, return 0.\\n\\nAdvantages: When array is very large product will reach Infinite value. Infinite*0 = NaN\\n\\nWe could just return sign directly, but in problem description was mentioned the use of ```signFunc```\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    let sign = 1;\\n    \\n    for (let i = 0; i < nums.length; i ++) {\\n        if (nums[i] === 0) {\\n            sign = 0;\\n            break;\\n        }\\n        \\n        if (nums[i] < 0) \\n            sign = -sign;\\n    }\\n    \\n    return signFunc(sign);\\n};\\n\\nfunction signFunc(x) {\\n    if (x === 0)\\n        return 0;\\n    \\n    return x > 0 ? 1: -1;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```signFunc```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    let sign = 1;\\n    \\n    for (let i = 0; i < nums.length; i ++) {\\n        if (nums[i] === 0) {\\n            sign = 0;\\n            break;\\n        }\\n        \\n        if (nums[i] < 0) \\n            sign = -sign;\\n    }\\n    \\n    return signFunc(sign);\\n};\\n\\nfunction signFunc(x) {\\n    if (x === 0)\\n        return 0;\\n    \\n    return x > 0 ? 1: -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2228229,
                "title": "javascript-solution",
                "content": "```\\nvar arraySign = function(nums) {\\n    var product = 1;\\n    for (var i=0;i<nums.length;i++) {\\n        product = product * nums[i];\\n    }\\n\\n    console.log(product);\\n\\n    if (isNaN(product)) {\\n        return 0;\\n    }\\n    \\n    if (product == 0) {\\n        return 0;\\n    } else if (product < 0) {\\n        return -1;\\n    } else {\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arraySign = function(nums) {\\n    var product = 1;\\n    for (var i=0;i<nums.length;i++) {\\n        product = product * nums[i];\\n    }\\n\\n    console.log(product);\\n\\n    if (isNaN(product)) {\\n        return 0;\\n    }\\n    \\n    if (product == 0) {\\n        return 0;\\n    } else if (product < 0) {\\n        return -1;\\n    } else {\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2224321,
                "title": "simple-fast-javascript-solution",
                "content": "```\\nfunction arraySign(nums) {\\n    let numbers = [];\\n    for (i of nums) {\\n        if (i < 0) numbers.push(-1)\\n        else if (i > 0) numbers.push(1)\\n        else numbers.push(0)\\n    }\\n    var product = 1\\n    for (i of numbers) product *= i\\n    if (product > 0) return 1\\n    else if (product < 0) return -1\\n    else return 0\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction arraySign(nums) {\\n    let numbers = [];\\n    for (i of nums) {\\n        if (i < 0) numbers.push(-1)\\n        else if (i > 0) numbers.push(1)\\n        else numbers.push(0)\\n    }\\n    var product = 1\\n    for (i of numbers) product *= i\\n    if (product > 0) return 1\\n    else if (product < 0) return -1\\n    else return 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2157800,
                "title": "accepted-100-faster-with-0ms-run-time",
                "content": "When we read the question the first intuitive approach comes to our mind is that we calculate product of each number in array and then if product is less then 0 then print -1 and if product is greater than 0 then 1 and 0 otherwise.\\n**Problem with intuitive Approach:** The biggest problem that comes is the length of integer. Due to cyclic property of datatypes if the value goes out of bound it tries to bring it in the range of integer and if we use long int then its ;\\nTime Complexity: O(n)\\nSpace Complexity: long will take more space than int.\\n\\n**Optimal Approach: **\\n\\nWe know that in multiplication if a single zero is present then ans will be zero and if number of negative is even then by the rule ***negative  negative = positive*** we will get positive answer.\\nSo simply calculate number of negative numbers in nums array, if they are even ans is positive else negative and simultaneously check if a single zero is present return 0.**\\n\\nJava Code:-\\n\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int count_negative=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<0)\\n                count_negative++;\\n            if(nums[i]==0)\\n                return 0;\\n        }\\n       if(count_negative%2==0)\\n           return 1;\\n        else return -1;\\n    }\\n}\\n```\\n**Do upvote if you liked the approach and comment if you have any query.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int count_negative=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<0)\\n                count_negative++;\\n            if(nums[i]==0)\\n                return 0;\\n        }\\n       if(count_negative%2==0)\\n           return 1;\\n        else return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053925,
                "title": "python-fast-and-easy-solution-with-comments-faster-than-98-92",
                "content": "Fast abd Easy solution for Python .\\n\\n```\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        product = 1\\n\\t\\t# Return zero if 0 exist in the array\\n        if 0 in nums:\\n            return 0\\n\\t\\t# We do not need to actually calculate the product but simply the end goal is to find the sign of the resultant product\\n\\t\\t# Using 1 and -1 as our flag has less computational effort on the system.\\n\\t\\t# Odd negatives result in Negative result . Even negatives result in Positive result.\\n        \\n\\t\\tfor num in nums:\\n            if num < 0:\\n                product = product * -1\\n        \\n        return product\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        product = 1\\n\\t\\t# Return zero if 0 exist in the array\\n        if 0 in nums:\\n            return 0\\n\\t\\t# We do not need to actually calculate the product but simply the end goal is to find the sign of the resultant product\\n\\t\\t# Using 1 and -1 as our flag has less computational effort on the system.\\n\\t\\t# Odd negatives result in Negative result . Even negatives result in Positive result.\\n        \\n\\t\\tfor num in nums:\\n            if num < 0:\\n                product = product * -1\\n        \\n        return product\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937467,
                "title": "c-solution-easy-to-understand",
                "content": "We don\\'t need to calculate the whole product of the elements of the given vector..\\nWe\\'ll simply initialise a int variable \"prod\" with a value = 1;\\nThen we will simply form a for loop to iterate over all the elements of the vector;\\nNow, we have 3 cases:\\n1) We\\'ll simply return 0 if any of the elements is found to be 0..\\n2) We\\'ll multiply -1 to the prod if the element is < 0..\\n3) We\\'ll keep the value of the prod intact if the element is > 0..\\n \\nPlease upvote the solution if you find this helpful....\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n = nums.size();\\n        int prod = 1;\\n        for(int i = 0;i < n;i++)\\n        {\\n            if(nums[i] == 0) return 0;\\n            else if(nums[i] < 0) prod *= -1;\\n            else continue;\\n        }\\n        return prod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n = nums.size();\\n        int prod = 1;\\n        for(int i = 0;i < n;i++)\\n        {\\n            if(nums[i] == 0) return 0;\\n            else if(nums[i] < 0) prod *= -1;\\n            else continue;\\n        }\\n        return prod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926125,
                "title": "beginner-friendly-python-solution",
                "content": "```\\nTime Complexity : O(n)\\n```\\n```\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        mul = 1\\n        for num in nums:\\n            if num == 0:\\n                return 0\\n            mul *= num\\n        return 1 if mul > 0 else -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nTime Complexity : O(n)\\n```\n```\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        mul = 1\\n        for num in nums:\\n            if num == 0:\\n                return 0\\n            mul *= num\\n        return 1 if mul > 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902604,
                "title": "c-short-code-with-simple-logic",
                "content": "Simply change the sign of the variable sign when encountered with a negative number. **Return 0** if get 0 as an element because the product will be going to be zero.\\n\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int sign=1;\\n        for(int i:nums) {\\n            if(i==0)\\n                return 0;\\n            if(i<0)\\n                sign*=-1;\\n        }\\n        return sign;\\n    }\\n};\\n```\\n\\nTime Complexity: **O(N)** where N is the size of array.",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int sign=1;\\n        for(int i:nums) {\\n            if(i==0)\\n                return 0;\\n            if(i<0)\\n                sign*=-1;\\n        }\\n        return sign;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846503,
                "title": "c-4-solutions-advanced-techniques-linq-expression-matching-switch-clamping",
                "content": "**Solution 1:**\\nLINQ 2 lines\\n```\\npublic int ArraySign(int[] nums) {\\n\\tint result = nums.Aggregate((a,b) => (a*b) == 0 ? 0 : (a*b)/Math.Abs(a*b));\\n\\treturn result == 0 ? 0 : result / Math.Abs(result);\\n}\\n```\\n\\n----------\\n\\n**Solution 2:**\\nLINQ 1 Line\\n```\\npublic int ArraySign(int[] nums)\\n{\\n\\treturn Math.Clamp(nums.Aggregate((a, b) => (Math.Clamp(a, -1, 1) * Math.Clamp(b, -1, 1))), -1, 1);\\n}\\n```\\n\\n\\n---- \\n\\n**Solution 3:**\\nSwitch Expression Matching With Relational Operators\\n```\\npublic int ArraySign(int[] nums)\\n{\\n\\tint result = 1;\\n\\tforeach (int n in nums)\\n\\t{\\n\\t\\tresult *= n switch\\n\\t\\t{\\n\\t\\t\\t> 0         => 1,\\n\\t\\t\\t0           => 0,\\n\\t\\t\\t< 0         => -1,\\n\\t\\t};\\n\\t\\tif (result == 0)\\n\\t\\t\\treturn 0;\\n\\t}\\n\\treturn result;\\n}\\n```\\n\\n--------\\n\\n**Solution 4:**\\nOnly count negatives\\n```\\npublic int ArraySign(int[] nums)\\n{\\n\\tint negCt = 0;\\n\\tforeach (int n in nums)\\n\\t{\\n\\t\\tif (n == 0) return 0;\\n\\t\\tif (n < 0) negCt++;\\n\\t}\\n\\treturn negCt % 2 == 0 ? 1 : -1;\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic int ArraySign(int[] nums) {\\n\\tint result = nums.Aggregate((a,b) => (a*b) == 0 ? 0 : (a*b)/Math.Abs(a*b));\\n\\treturn result == 0 ? 0 : result / Math.Abs(result);\\n}\\n```\n```\\npublic int ArraySign(int[] nums)\\n{\\n\\treturn Math.Clamp(nums.Aggregate((a, b) => (Math.Clamp(a, -1, 1) * Math.Clamp(b, -1, 1))), -1, 1);\\n}\\n```\n```\\npublic int ArraySign(int[] nums)\\n{\\n\\tint result = 1;\\n\\tforeach (int n in nums)\\n\\t{\\n\\t\\tresult *= n switch\\n\\t\\t{\\n\\t\\t\\t> 0         => 1,\\n\\t\\t\\t0           => 0,\\n\\t\\t\\t< 0         => -1,\\n\\t\\t};\\n\\t\\tif (result == 0)\\n\\t\\t\\treturn 0;\\n\\t}\\n\\treturn result;\\n}\\n```\n```\\npublic int ArraySign(int[] nums)\\n{\\n\\tint negCt = 0;\\n\\tforeach (int n in nums)\\n\\t{\\n\\t\\tif (n == 0) return 0;\\n\\t\\tif (n < 0) negCt++;\\n\\t}\\n\\treturn negCt % 2 == 0 ? 1 : -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1815568,
                "title": "c-linq-one-liner",
                "content": "```csharp\\npublic int ArraySign(int[] nums) => nums.Aggregate(1, (a, c) => a * c.CompareTo(0));\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int ArraySign(int[] nums) => nums.Aggregate(1, (a, c) => a * c.CompareTo(0));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1809773,
                "title": "easytounderstand-fast-0ms-without-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int t=1;\\n        for(auto i:nums)\\n            if(i==0)\\n                return 0;\\n            else if(i<0)\\n                t=(t<0?1:-1);\\n          \\n        \\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int t=1;\\n        for(auto i:nums)\\n            if(i==0)\\n                return 0;\\n            else if(i<0)\\n                t=(t<0?1:-1);\\n          \\n        \\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808101,
                "title": "easy-simple-java-solution",
                "content": "1. negative * negative = positive\\n2. negative * positive = negative\\n\\n* We count the total number of negative numbers. If the count is even then product will turn positive else negative.\\n\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n\\n        int count = 0;\\n        for(int num: nums){\\n            if(num == 0) return 0;\\n            count += (num < 0)? 1: 0;\\n        }\\n        \\n        return (count%2 == 0)? 1: -1;\\n    }\\n}\\n```\\n\\nplease upvote if you think this is simple and easy to understand. Thanks :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n\\n        int count = 0;\\n        for(int num: nums){\\n            if(num == 0) return 0;\\n            count += (num < 0)? 1: 0;\\n        }\\n        \\n        return (count%2 == 0)? 1: -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806477,
                "title": "c-simple-approach-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int n = nums.size() ;\\n      int ans = 1 ;\\n       \\n      for(int i : nums){\\n          if(i == 0) return 0 ;\\n          else if(i < 0) ans = ans * -1 ;\\n      }\\n      return ans > 0 ? 1 : -1 ;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int n = nums.size() ;\\n      int ans = 1 ;\\n       \\n      for(int i : nums){\\n          if(i == 0) return 0 ;\\n          else if(i < 0) ans = ans * -1 ;\\n      }\\n      return ans > 0 ? 1 : -1 ;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676196,
                "title": "java-most-concise-o-n-time-o-1-space-solution",
                "content": "I am seeing a lot of solutions using `int` to store the product, or `int` to keep track of the sign by performing multiplication. \\n\\nThere is a much more concise way -- use a `bool`. Start with a boolean `sign` set to `false`. When we come across a number that is negative, negate `sign`. Once we\\'ve passed through every element of the array, just check if `sign` is `true`. If it is, return `-1`, else return `1`. \\n\\nOh, also, we know that any number multiplied by `0` is just going to be `0`, so if at any point we encounter a `0` in our traversal, we can just return `0` right away and be done. \\n\\n```\\nclass Solution {\\n    \\n    // Time complexity: O(N)\\n    // Space complexity: O(1)\\n    public int arraySign(int[] nums) {\\n        \\n        boolean sign = false; \\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] == 0) // If any number is 0, return 0, right away. \\n                return 0; \\n            if(nums[i] < 0)\\n                sign = !sign; \\n        }\\n        \\n        return (sign) ? -1 : 1; \\n            \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    // Time complexity: O(N)\\n    // Space complexity: O(1)\\n    public int arraySign(int[] nums) {\\n        \\n        boolean sign = false; \\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] == 0) // If any number is 0, return 0, right away. \\n                return 0; \\n            if(nums[i] < 0)\\n                sign = !sign; \\n        }\\n        \\n        return (sign) ? -1 : 1; \\n            \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649505,
                "title": "javascript-typescript-easy-100",
                "content": "```\\nconst arraySign = (nums: number[]): number => {\\n  // edgeCase\\n  if(nums.includes(0)) {\\n    return 0;\\n  };\\n  \\n  // count of negative\\n  let count: number = 0;\\n  nums.forEach(num => num < 0 && count++);\\n  \\n  // if count is odd, return 1, else return -1\\n  return count % 2 ? -1 : 1;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/0a5ecfa9-a724-4b12-9a03-8fcab9a3ed5e_1640571384.0467677.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst arraySign = (nums: number[]): number => {\\n  // edgeCase\\n  if(nums.includes(0)) {\\n    return 0;\\n  };\\n  \\n  // count of negative\\n  let count: number = 0;\\n  nums.forEach(num => num < 0 && count++);\\n  \\n  // if count is odd, return 1, else return -1\\n  return count % 2 ? -1 : 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1585927,
                "title": "c-90-faster",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    bool check(vector<int> &nums)\\n    {\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] == 0)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    int arraySign(vector<int> &nums)\\n    {\\n        int multi = 1;\\n        if (check(nums))\\n            return 0;\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] >= 1)\\n            {\\n                nums[i] = 1;\\n            }\\n            else\\n            {\\n                nums[i] = -1;\\n            }\\n            multi *= nums[i];\\n        }\\n        return (multi >= 1) ? 1 : -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool check(vector<int> &nums)\\n    {\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] == 0)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    int arraySign(vector<int> &nums)\\n    {\\n        int multi = 1;\\n        if (check(nums))\\n            return 0;\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] >= 1)\\n            {\\n                nums[i] = 1;\\n            }\\n            else\\n            {\\n                nums[i] = -1;\\n            }\\n            multi *= nums[i];\\n        }\\n        return (multi >= 1) ? 1 : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541342,
                "title": "easy-java-solution",
                "content": "```\\n  int p=1;\\n        for(int i: nums){\\n            if(i==0) return 0;\\n            \\n            p *= i>0 ? 1 : -1;\\n           \\n        }\\n        \\n        return p;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  int p=1;\\n        for(int i: nums){\\n            if(i==0) return 0;\\n            \\n            p *= i>0 ? 1 : -1;\\n           \\n        }\\n        \\n        return p;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1424377,
                "title": "python-87-using-reduce-with-lambda-argument",
                "content": "I took this approach since I have a bit of a Javascript background. The reduce function returns 1 value after it completes the lambda operations.\\n\\nMake sure to import functools. \\n\\n```python\\nimport functools\\n\\nclass Solution:\\n    def signProduct(self, num) -> int:\\n        if num > 0:\\n            return 1\\n        elif num < 0:\\n            return -1\\n        elif num == 0:\\n            return 0\\n        \\n    def arraySign(self, nums: List[int]) -> int:\\n        product = functools.reduce(lambda a, b: a * b, nums)\\n        return self.signProduct(product)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nimport functools\\n\\nclass Solution:\\n    def signProduct(self, num) -> int:\\n        if num > 0:\\n            return 1\\n        elif num < 0:\\n            return -1\\n        elif num == 0:\\n            return 0\\n        \\n    def arraySign(self, nums: List[int]) -> int:\\n        product = functools.reduce(lambda a, b: a * b, nums)\\n        return self.signProduct(product)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363191,
                "title": "kotlin-solution",
                "content": "```\\nclass Solution {\\n    fun arraySign(nums: IntArray): Int {\\n        var sign = 1\\n        for (number in nums) {\\n            if (number == 0) return 0\\n            if (number<0) sign *= -1\\n        }\\n        return sign\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun arraySign(nums: IntArray): Int {\\n        var sign = 1\\n        for (number in nums) {\\n            if (number == 0) return 0\\n            if (number<0) sign *= -1\\n        }\\n        return sign\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250512,
                "title": "java-math-0ms-beats-100-t-c-o-n-s-c-o-1",
                "content": "\\n    public int arraySign(int[] nums) {\\n        \\n        int len = nums.length, negative = 0;\\n        for(int i = 0; i < len; i++){\\n            \\n            if(nums[i] == 0)\\n                return 0;\\n            \\n            negative += (nums[i] < 0) ? 1 : 0;\\n        }\\n        \\n        return (negative % 2 == 0) ? 1 : -1;\\n        \\n    }\\n\\t\\n\\t\\n    public int arraySign(int[] nums) {\\n        \\n        int len = nums.length, sign = 1;\\n        for(int i = 0; i < len; i++){\\n            \\n            if(nums[i] == 0)\\n                return 0;\\n            \\n            if(nums[i] < 0)\\n                sign = -sign;\\n        }\\n        \\n        return sign;\\n    }\\n\\n",
                "solutionTags": [],
                "code": "\\n    public int arraySign(int[] nums) {\\n        \\n        int len = nums.length, negative = 0;\\n        for(int i = 0; i < len; i++){\\n            \\n            if(nums[i] == 0)\\n                return 0;\\n            \\n            negative += (nums[i] < 0) ? 1 : 0;\\n        }\\n        \\n        return (negative % 2 == 0) ? 1 : -1;\\n        \\n    }\\n\\t\\n\\t\\n    public int arraySign(int[] nums) {\\n        \\n        int len = nums.length, sign = 1;\\n        for(int i = 0; i < len; i++){\\n            \\n            if(nums[i] == 0)\\n                return 0;\\n            \\n            if(nums[i] < 0)\\n                sign = -sign;\\n        }\\n        \\n        return sign;\\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1197853,
                "title": "c-easy-concise-o-n-o-1",
                "content": "The sign depends upon weather the -ve\\'s are even (return 1) or odd(return -1).\\nIf you caught a zero it will give a product zero .Hence no need to traverse further , just return 0;\\n\\n```\\n int arraySign(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {if(nums[i]==0)return 0;\\n         if(nums[i]<0)count++;}\\n        if(count%2==0)return 1;\\n        return -1;\\n```",
                "solutionTags": [],
                "code": "```\\n int arraySign(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {if(nums[i]==0)return 0;\\n         if(nums[i]<0)count++;}\\n        if(count%2==0)return 1;\\n        return -1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1166799,
                "title": "python3-one-pass",
                "content": "Initialize a variable \"sign\" to be 1, and update it when passing every number if the list.\\n```\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        sign = 1\\n        for n in nums:\\n            if n > 0:\\n                continue\\n            elif n == 0:\\n                return 0\\n            else:\\n                sign = sign * (-1)\\n        return sign\\n```\\nPlease upvote if you find it helpful. Thanks.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        sign = 1\\n        for n in nums:\\n            if n > 0:\\n                continue\\n            elif n == 0:\\n                return 0\\n            else:\\n                sign = sign * (-1)\\n        return sign\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1845402,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1879678,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1806781,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1720834,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1699694,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1879888,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1845409,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1787236,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1730316,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1957906,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1845402,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1879678,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1806781,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1720834,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1699694,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1879888,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1845409,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1787236,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1730316,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1957906,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 2049095,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 1671670,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 1880393,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 1746054,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 2072011,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 2045904,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 1987192,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 1977976,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 1965940,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 1917526,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 1912323,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1899081,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1884875,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1884366,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1880420,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1880271,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1880234,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1880200,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1880174,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1880129,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1880125,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1880124,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1880122,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1880110,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1880098,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1880046,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1880028,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1880001,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1879991,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1879969,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1879940,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879922,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879878,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879873,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879864,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879861,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879853,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879851,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879820,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879806,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879802,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879801,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879777,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879766,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879764,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879753,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879741,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879737,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879695,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1784254,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            }
        ]
    }
]