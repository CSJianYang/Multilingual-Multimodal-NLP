[
    {
        "title": "Count the Number of Square-Free Subsets",
        "question_content": "You are given a positive integer 0-indexed&nbsp;array nums.\nA subset of the array nums is square-free if the product of its elements is a square-free integer.\nA square-free integer is an integer that is divisible by no square number other than 1.\nReturn the number of square-free non-empty subsets of the array nums. Since the answer may be too large, return it modulo 109 + 7.\nA non-empty&nbsp;subset of nums is an array that can be obtained by deleting some (possibly none but not all) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.\n&nbsp;\nExample 1:\n\nInput: nums = [3,4,4,5]\nOutput: 3\nExplanation: There are 3 square-free subsets in this example:\n- The subset consisting of the 0th element [3]. The product of its elements is 3, which is a square-free integer.\n- The subset consisting of the 3rd element [5]. The product of its elements is 5, which is a square-free integer.\n- The subset consisting of 0th and 3rd elements [3,5]. The product of its elements is 15, which is a square-free integer.\nIt can be proven that there are no more than 3 square-free subsets in the given array.\nExample 2:\n\nInput: nums = [1]\nOutput: 1\nExplanation: There is 1 square-free subset in this example:\n- The subset consisting of the 0th element [1]. The product of its elements is 1, which is a square-free integer.\nIt can be proven that there is no more than 1 square-free subset in the given array.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length&nbsp;<= 1000\n\t1 <= nums[i] <= 30",
        "solutions": [
            {
                "id": 3203707,
                "title": "dp-bitmask-c-prime-factorization",
                "content": "We can prime factorize the product of the subset, now we know that there are only 10 prime numbers under 30 for each prime we represent them as a bit, now we only have two choices to not take a number, or take a number if its prime mask and the products prime mask has no common bits.\\n\\n````\\n#define ll long long\\nll dp[1111][1 << 11];\\nll mod;\\nclass Solution {\\npublic:\\n    vector<int> primes;\\n    ll getMask(ll num) {\\n        ll mask = 0;\\n        for(int i = 0; i < 10; i++) {\\n            int tim = 0;\\n            while(num % primes[i] == 0) {\\n                tim += 1;\\n                num /= primes[i];\\n            }\\n            if(tim > 1) \\n\\t\\t\\t\\treturn -1;// if a number is getting divided with a prime more than 1 time meaning it can be divided by that primes square\\n            if(tim == 1) \\n\\t\\t\\t\\tmask |= (1 << (i + 1)); // i + 1 because the for i == 0 product 1 has already been taken\\n        }\\n        return mask;\\n    }\\n    ll dfs(int ind, ll prodmask, vector<int> &nums) {\\n        if(ind >= nums.size()) return 1;\\n        if(dp[ind][prodmask] != -1) return dp[ind][prodmask];\\n        \\n        ll mask = getMask(nums[ind]);\\n        ll ans = dfs(ind + 1, prodmask, nums);\\n        \\n        if((prodmask & mask) == 0) {\\n            ans = (ans + dfs(ind + 1, prodmask | mask, nums)) % mod;\\n        }\\n        return dp[ind][prodmask] = ans;\\n    }\\n    int squareFreeSubsets(vector<int>& nums) {\\n        mod = 1e9 + 7;\\n        memset(dp, -1, sizeof dp);\\n        primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n        return (dfs(0, 1, nums) - 1 + mod) % mod; // -1 because of the case when we have not taken any number\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> primes;\\n    ll getMask(ll num) {\\n        ll mask = 0;\\n        for(int i = 0; i < 10; i++) {\\n            int tim = 0;\\n            while(num % primes[i] == 0) {\\n                tim += 1;\\n                num /= primes[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3203755,
                "title": "o-n-1024-memoization-bitmask",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* We want no prime factor should occur more than once in our product of numbers.\\n*Use only prime numbers for bitmask state of dp.\\n*This reduces the number of states for bitmask from $${2^{30}}$$ to $${2^{10}}$$\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* We have 10 prime numbers from 0 to 30:   $$ 2,3,5,7,11,13,17,19,23,29;$$\\n* If any of them comes twice in our product we wont be having sqaure free integer.\\n* We define the state of dp as `i(current element)` and `mask (in which set bits represent the prime number already present in our product)`\\n* For each I we can either include it in our product or not include it.\\n* We can include it only if multiplying the number with the mask does not results in a prime number occuring twice as factor;\\n* For example, if i have mask as $$0000001010$$ then nums[i] should not have 3 and 7 as factors and also it should not have any of these factors occuring twice.\\n\\nkey notes:\\n* `count` variable is used to calculate how many time a prime factor divides nums[i]\\n* `((count==1)&&((mask>>j)&1))` checks whether a prime factor is already there in the mask or not\\n\\n# Complexity\\n- Time complexity:$$O(n* {2^{10}}))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n* {2^{10}}))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int memo[1001][1024];\\n    vector<int>vec={2,3,5,7,11,13,17,19,23,29};\\n    ll mod=1e9+7;\\n    ll dp(vector<int>&nums,int i,int mask)\\n    {\\n        if(i==nums.size()) return 1;\\n        if(memo[i][mask]!=-1) return memo[i][mask];\\n        int temp=mask,flag=1;\\n        for(int j=0;j<10;j++)\\n        {\\n            int num=nums[i],count=0;\\n            while(num%vec[j]==0)  num/=vec[j], count++;\\n            if(count>=2 or ((count==1) and ((mask>>j)&1)))\\n            {\\n                flag=0;\\n                break;\\n            }\\n            if(count) temp=temp|(1<<j);\\n        }\\n        if(flag)\\n               return memo[i][mask]=(dp(nums,i+1,mask)+dp(nums,i+1,temp))%mod;\\n        else\\n              return memo[i][mask]=dp(nums,i+1,mask);\\n        \\n    }\\n    \\n    int squareFreeSubsets(vector<int>& nums) \\n    {\\n        memset(memo,-1,sizeof(memo));\\n        return 1LL*(dp(nums,0,0)-1+mod)%mod;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int memo[1001][1024];\\n    vector<int>vec={2,3,5,7,11,13,17,19,23,29};\\n    ll mod=1e9+7;\\n    ll dp(vector<int>&nums,int i,int mask)\\n    {\\n        if(i==nums.size()) return 1;\\n        if(memo[i][mask]!=-1) return memo[i][mask];\\n        int temp=mask,flag=1;\\n        for(int j=0;j<10;j++)\\n        {\\n            int num=nums[i],count=0;\\n            while(num%vec[j]==0)  num/=vec[j], count++;\\n            if(count>=2 or ((count==1) and ((mask>>j)&1)))\\n            {\\n                flag=0;\\n                break;\\n            }\\n            if(count) temp=temp|(1<<j);\\n        }\\n        if(flag)\\n               return memo[i][mask]=(dp(nums,i+1,mask)+dp(nums,i+1,temp))%mod;\\n        else\\n              return memo[i][mask]=dp(nums,i+1,mask);\\n        \\n    }\\n    \\n    int squareFreeSubsets(vector<int>& nums) \\n    {\\n        memset(memo,-1,sizeof(memo));\\n        return 1LL*(dp(nums,0,0)-1+mod)%mod;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204715,
                "title": "video-explanation-building-solution-from-scratch-with-intuitions",
                "content": "# Explanation\\n\\nhttps://youtu.be/JNMBAUmL0Yc\\n\\n# Code\\n```\\nconst vector<int> PRIMES = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\nconst int MOD = 1e9+7;\\n\\ntypedef long long int ll;\\n\\nclass Solution {\\n    vector<vector<int>> dp;\\n    \\n    ll ConvertFromMask (int mask) {\\n        ll result = 1;\\n        \\n        for (int j = 0; j < PRIMES.size(); j ++) {\\n            if (mask & (1 << j)) result *= PRIMES[j];\\n        }\\n        return result;\\n    }\\n    \\n    int ConvertToMask (ll X) {\\n        int mask = 0;\\n        \\n        for (int j = 0; j < PRIMES.size(); j ++) {\\n            if (X % PRIMES[j] == 0) {\\n                X /= PRIMES[j];\\n                mask |= (1 << j);\\n            }\\n        }\\n        return mask;\\n    }\\n    \\n    int CountSubsets (int ind, int mask, const vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        if (mask == 0) return 1;  \\n        if (ind == n) return 0;\\n        \\n        int &ans = dp[ind][mask];\\n        if (ans != -1) return ans;\\n        \\n        ll X = ConvertFromMask (mask);\\n        \\n        ans = CountSubsets (ind+1, mask, arr);\\n        if (X % arr[ind] == 0)\\n            ans = (ans + CountSubsets (ind+1, ConvertToMask (X / arr[ind]), arr)) % MOD;\\n        \\n        return ans;\\n    }\\n    \\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        vector<int> nums_but_1;\\n        int ones = 0;\\n        \\n        for (auto i : nums) {\\n            if (i == 1) ones ++;\\n            else nums_but_1.push_back(i);\\n        }\\n        \\n        dp.clear();\\n        int n = nums_but_1.size();\\n        dp.resize(n, vector<int>(1025, -1));\\n                    \\n        long long non_empty_one_subsets = 1;\\n        while (ones --) non_empty_one_subsets = (non_empty_one_subsets * 2) % MOD;\\n        non_empty_one_subsets = (non_empty_one_subsets - 1 + MOD) % MOD;\\n        \\n        long long non_empty_other_subsets = 0;\\n        for (int mask = 1; mask < 1024; mask ++) {\\n            non_empty_other_subsets = (non_empty_other_subsets + CountSubsets(0, mask, nums_but_1)) % MOD;\\n        }\\n        \\n        long long result = (non_empty_one_subsets + non_empty_other_subsets) % MOD;\\n        result = (result + (non_empty_other_subsets * non_empty_one_subsets) % MOD) % MOD;\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst vector<int> PRIMES = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\nconst int MOD = 1e9+7;\\n\\ntypedef long long int ll;\\n\\nclass Solution {\\n    vector<vector<int>> dp;\\n    \\n    ll ConvertFromMask (int mask) {\\n        ll result = 1;\\n        \\n        for (int j = 0; j < PRIMES.size(); j ++) {\\n            if (mask & (1 << j)) result *= PRIMES[j];\\n        }\\n        return result;\\n    }\\n    \\n    int ConvertToMask (ll X) {\\n        int mask = 0;\\n        \\n        for (int j = 0; j < PRIMES.size(); j ++) {\\n            if (X % PRIMES[j] == 0) {\\n                X /= PRIMES[j];\\n                mask |= (1 << j);\\n            }\\n        }\\n        return mask;\\n    }\\n    \\n    int CountSubsets (int ind, int mask, const vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        if (mask == 0) return 1;  \\n        if (ind == n) return 0;\\n        \\n        int &ans = dp[ind][mask];\\n        if (ans != -1) return ans;\\n        \\n        ll X = ConvertFromMask (mask);\\n        \\n        ans = CountSubsets (ind+1, mask, arr);\\n        if (X % arr[ind] == 0)\\n            ans = (ans + CountSubsets (ind+1, ConvertToMask (X / arr[ind]), arr)) % MOD;\\n        \\n        return ans;\\n    }\\n    \\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        vector<int> nums_but_1;\\n        int ones = 0;\\n        \\n        for (auto i : nums) {\\n            if (i == 1) ones ++;\\n            else nums_but_1.push_back(i);\\n        }\\n        \\n        dp.clear();\\n        int n = nums_but_1.size();\\n        dp.resize(n, vector<int>(1025, -1));\\n                    \\n        long long non_empty_one_subsets = 1;\\n        while (ones --) non_empty_one_subsets = (non_empty_one_subsets * 2) % MOD;\\n        non_empty_one_subsets = (non_empty_one_subsets - 1 + MOD) % MOD;\\n        \\n        long long non_empty_other_subsets = 0;\\n        for (int mask = 1; mask < 1024; mask ++) {\\n            non_empty_other_subsets = (non_empty_other_subsets + CountSubsets(0, mask, nums_but_1)) % MOD;\\n        }\\n        \\n        long long result = (non_empty_one_subsets + non_empty_other_subsets) % MOD;\\n        result = (result + (non_empty_other_subsets * non_empty_one_subsets) % MOD) % MOD;\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203905,
                "title": "python3-dfs-gcd-solution-70ms-beats-100",
                "content": "# Approach\\n**Step 1:** Select all possible `num` between 2 to 30 that does not have a square as its factor. Record all such `num` in a set `candidates`;\\n**Step 2:** Use a Counter `cnt` to record the number of appearances in `nums` for all `num` in `candidates`;\\n**Step 3:** Define a helper function `count()` that return all possible Square-Free Subsets of a given array `arr` with unique elements;\\n**Step 4:** Apply `count()` function on the unique elements of `nums` in `candidates` and multiply by the cardinality of the power set of `1`\\'s in `nums`, then subtract 1 (the null subset) to get the final answer.\\n\\n# Code\\n```\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        MOD = 10 ** 9 + 7\\n        candidates = set([2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30])\\n        cnt = defaultdict(int)\\n        for num in nums:\\n            if num in candidates:\\n                cnt[num] += 1\\n        \\n        def count(arr):\\n            if not arr:\\n                return 1\\n            arr1 = []\\n            for num in arr[1:]:\\n                if math.gcd(num, arr[0]) == 1:\\n                    arr1.append(num)\\n            return (count(arr[1:]) + cnt[arr[0]] * count(arr1)) % MOD\\n            \\n        ones = nums.count(1)\\n        tmp = 1\\n        for _ in range(ones):\\n            tmp = (tmp * 2) % MOD\\n        return (count(list(cnt)) * tmp - 1) % MOD\\n```\\n\\n# Polished code to make it less lengthy\\nCredit to [@bortengineer](https://leetcode.com/bortengineer/).\\n```\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        MOD = 10 ** 9 + 7\\n        cnt = Counter(nums)\\n        \\n        def count(arr):\\n            if not arr:\\n                return 1\\n            arr1 = [x for x in arr if math.gcd(x, arr[0]) == 1]\\n            return (count(arr[1:]) + cnt[arr[0]] * count(arr1)) % MOD\\n\\n        candidates = [2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30]\\n        return (count(candidates) * pow(2, cnt[1], MOD) - 1) % MOD\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        MOD = 10 ** 9 + 7\\n        candidates = set([2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30])\\n        cnt = defaultdict(int)\\n        for num in nums:\\n            if num in candidates:\\n                cnt[num] += 1\\n        \\n        def count(arr):\\n            if not arr:\\n                return 1\\n            arr1 = []\\n            for num in arr[1:]:\\n                if math.gcd(num, arr[0]) == 1:\\n                    arr1.append(num)\\n            return (count(arr[1:]) + cnt[arr[0]] * count(arr1)) % MOD\\n            \\n        ones = nums.count(1)\\n        tmp = 1\\n        for _ in range(ones):\\n            tmp = (tmp * 2) % MOD\\n        return (count(list(cnt)) * tmp - 1) % MOD\\n```\n```\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        MOD = 10 ** 9 + 7\\n        cnt = Counter(nums)\\n        \\n        def count(arr):\\n            if not arr:\\n                return 1\\n            arr1 = [x for x in arr if math.gcd(x, arr[0]) == 1]\\n            return (count(arr[1:]) + cnt[arr[0]] * count(arr1)) % MOD\\n\\n        candidates = [2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30]\\n        return (count(candidates) * pow(2, cnt[1], MOD) - 1) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203758,
                "title": "mask-of-factors",
                "content": "In a square-free subset, each prime can appear only once (otherwise the multiple will include the square of that prime).\\n\\nThus, 11 numbers out of 30 can be excluded as they already include a repeated prime (e.g. 4, 8, 9, 12, etc.)\\n\\nFor the remaining numbers, we track their primes using a bit mask. There are 10 primes, so we only need 10 bits for memoisation.\\n\\nThe `f` array contains compressed prime factor masks for each number. \\n\\nWe do Knapsack 0/1 DP, memoising by the current position `i` and `mask`.\\n\\n**C++**\\n```cpp\\nint dp[1001][1024] = {}, mod = 1000000007;\\nint f[31] = {-1, 0, 1, 2, -1, 4, 3, 8, -1, -1, 5, 16, -1, 32, 9, 6,\\n             -1, 64, -1, 128, -1, 10, 17, 256, -1, -1, 33, -1, -1, 512, 7};\\nint dfs(int i, int mask, vector<int>& nums) {\\n    if (i >= nums.size())\\n        return 0;\\n    if (dp[i][mask] == 0) {\\n        dp[i][mask] = (1 + dfs(i + 1, mask, nums)) % mod;\\n        if (f[nums[i]] != -1 && (mask & f[nums[i]]) == 0)\\n            dp[i][mask] = (dp[i][mask] + 1 + dfs(i + 1, mask + f[nums[i]], nums)) % mod;\\n    }\\n    return dp[i][mask] - 1;\\n}\\nint squareFreeSubsets(vector<int>& nums) {\\n    return dfs(0, 0, nums);   \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint dp[1001][1024] = {}, mod = 1000000007;\\nint f[31] = {-1, 0, 1, 2, -1, 4, 3, 8, -1, -1, 5, 16, -1, 32, 9, 6,\\n             -1, 64, -1, 128, -1, 10, 17, 256, -1, -1, 33, -1, -1, 512, 7};\\nint dfs(int i, int mask, vector<int>& nums) {\\n    if (i >= nums.size())\\n        return 0;\\n    if (dp[i][mask] == 0) {\\n        dp[i][mask] = (1 + dfs(i + 1, mask, nums)) % mod;\\n        if (f[nums[i]] != -1 && (mask & f[nums[i]]) == 0)\\n            dp[i][mask] = (dp[i][mask] + 1 + dfs(i + 1, mask + f[nums[i]], nums)) % mod;\\n    }\\n    return dp[i][mask] - 1;\\n}\\nint squareFreeSubsets(vector<int>& nums) {\\n    return dfs(0, 0, nums);   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3206717,
                "title": "bitmask-very-detailed-explaination-titans-plz-skip-code-java",
                "content": "# Naive Way Not Okay\\n(1) Generate combinations   $$O(2^n)$$\\n(2) Check if valid $$O(\\\\sqrt{x})$$ where $$x$$ is possible product\\n\\nStep(1) directly leads to TLE.\\n\\n# Why Bitmask\\n\\n**Every integer greater than 1 can be written as the product of prime numbers.**\\n\\n\\n$$x=p_{1}^{a} \\\\times p_{2}^{b} \\\\times p_{3}^{c}\\\\times ...$$\\n\\nSo, square-free requires the power of each prime factor less than 2.\\n\\nIt is equivalent to for each prime, **choose once or not**, which leads to bit idea.\\n\\n    0: not selected\\n    1: selected\\n    \\nIf interested, [Explanation of BitMask](https://leetcode.com/discuss/interview-question/3206851/Bitmask-Learning-Note).\\n\\n**Usage in Code**\\n\\nInstead of actual value, use mask to show current primes selection.\\n\\n```\\nIf only 4 primes: {2, 3, 5, 7}\\n\\n2 = 0001\\n3 = 0010\\n5 = 0100\\n7 = 1000\\n\\n6  = 2 * 3     = 0011      (select 2 and 3)\\n10 = 2 * 5     = 0101      (select 2 and 5)\\n30 = 2 * 3 * 5 = 0111   (select 2, 3 and 5)\\n\\n```\\n\\nAt a certain step, product is `product`, decide to choose `nums[i]`, we can use mask to check if okay: \\n\\n```\\nIf only 4 primes: {2, 3, 5, 7}\\n\\nproduct = 6 = 0011\\nnum = 5 = 0100\\n\\n0011 & 0100 ===> 0 okay, no duplicate\\nnewProduct = 30 = 6 * 5 = 0011 | 0100 = 01111\\n\\n\\nproduct = 30 = 0111\\nnum = 3 = 0010\\n\\n0111 & 0010 != 0, not okay, duplicate\\n\\n```\\n\\nThis reduces Step(2) to $$O(1)$$\\n\\n---\\n\\n**Supportive Reason of BitMask**\\n\\n$$1 <= nums[i] <= 30$$\\n\\nOnly 10 prime numbers in this range, the total combination is $$2^{10} = 1024$$. Not Big.\\n\\n\\n# Additional Explanations\\n\\nQ: Why dfs base case return 1?\\nA: **Each combination counts 1** to final answer.\\n\\n---\\n\\nQ: Why final answer - 1?\\nA: Select **nothing** would count in dfs, which not okay.\\n\\n---\\n\\nQ: In computeMask, why illegal number return -1?\\nA: -1 in binary -> \"1111...11\", which would be excluded in AND operation check.\\n\\n\\n```Java []\\nSystem.out.println(Integer.toBinaryString(-1))\\n/// \"11111111111111111111111111111111\"\\n```\\n\\n\\n---\\nQ: Why `int[][] dp = new int[1010][1 << 11]`?\\n\\nA(1): `1 <= nums.length <= 1000`, so first dimension larger than 1000 okay.\\nSo you can see competitive guys using 1111, 1010, 1050, 1100. \\n\\nA(2): `1 << 11` is due to 10 primes and a possible valid product `1`\\n\\n```\\nInput: nums = [1]\\nOutput: 1\\nExplanation: There is 1 square-free subset in this example\\n```\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int MOD = (int)1e9 + 7;\\n    public int squareFreeSubsets(int[] nums) {\\n        int[][] dp = new int[1010][1 << 11];\\n        for (int[] d : dp) Arrays.fill(d, -1);\\n\\n        int[] primes = new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n        \\n        int[] numsPrimeMask = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            numsPrimeMask[i] = computeMask(nums[i], primes);\\n        }\\n\\n        // error one : return dfs(0, 1, numsPrimeMask, dp) - 1;\\n        return (dfs(0, 1, numsPrimeMask, dp) - 1 + MOD) % MOD;\\n    }\\n\\n    private int dfs(int pos, int productMask, int[] numsPrimeMask, int[][] dp) {\\n        if (pos >= numsPrimeMask.length) return 1;\\n\\n        if (dp[pos][productMask] != -1) return dp[pos][productMask];\\n\\n\\n        // case 1: skip current pos\\n        int ans = dfs(pos + 1, productMask, numsPrimeMask, dp);\\n\\n        // case 2: select current if not conflict\\n        if ((productMask & numsPrimeMask[pos]) == 0) {\\n            ans = (ans + dfs(pos + 1, productMask | numsPrimeMask[pos], numsPrimeMask, dp)) % MOD;\\n        }\\n\\n        return dp[pos][productMask] = ans;\\n    }\\n\\n    private int computeMask(int x, int[] primes) {\\n        int mask = 0;\\n        for (int i = 0; i < primes.length; i++) {\\n            int p = primes[i];\\n            int cnt = 0;\\n            while (x % p == 0) {\\n                x /= p;\\n                cnt++;\\n            }\\n\\n            if (cnt == 0) continue;\\n            if (cnt == 1) mask |= (1 << (i + 1));\\n            if (cnt >= 2) return -1;\\n        }\\n        return mask;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nIf only 4 primes: {2, 3, 5, 7}\\n\\n2 = 0001\\n3 = 0010\\n5 = 0100\\n7 = 1000\\n\\n6  = 2 * 3     = 0011      (select 2 and 3)\\n10 = 2 * 5     = 0101      (select 2 and 5)\\n30 = 2 * 3 * 5 = 0111   (select 2, 3 and 5)\\n\\n```\n```\\nIf only 4 primes: {2, 3, 5, 7}\\n\\nproduct = 6 = 0011\\nnum = 5 = 0100\\n\\n0011 & 0100 ===> 0 okay, no duplicate\\nnewProduct = 30 = 6 * 5 = 0011 | 0100 = 01111\\n\\n\\nproduct = 30 = 0111\\nnum = 3 = 0010\\n\\n0111 & 0010 != 0, not okay, duplicate\\n\\n```\n```Java []\\nSystem.out.println(Integer.toBinaryString(-1))\\n/// \"11111111111111111111111111111111\"\\n```\n```\\nInput: nums = [1]\\nOutput: 1\\nExplanation: There is 1 square-free subset in this example\\n```\n```\\nclass Solution {\\n    int MOD = (int)1e9 + 7;\\n    public int squareFreeSubsets(int[] nums) {\\n        int[][] dp = new int[1010][1 << 11];\\n        for (int[] d : dp) Arrays.fill(d, -1);\\n\\n        int[] primes = new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n        \\n        int[] numsPrimeMask = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            numsPrimeMask[i] = computeMask(nums[i], primes);\\n        }\\n\\n        // error one : return dfs(0, 1, numsPrimeMask, dp) - 1;\\n        return (dfs(0, 1, numsPrimeMask, dp) - 1 + MOD) % MOD;\\n    }\\n\\n    private int dfs(int pos, int productMask, int[] numsPrimeMask, int[][] dp) {\\n        if (pos >= numsPrimeMask.length) return 1;\\n\\n        if (dp[pos][productMask] != -1) return dp[pos][productMask];\\n\\n\\n        // case 1: skip current pos\\n        int ans = dfs(pos + 1, productMask, numsPrimeMask, dp);\\n\\n        // case 2: select current if not conflict\\n        if ((productMask & numsPrimeMask[pos]) == 0) {\\n            ans = (ans + dfs(pos + 1, productMask | numsPrimeMask[pos], numsPrimeMask, dp)) % MOD;\\n        }\\n\\n        return dp[pos][productMask] = ans;\\n    }\\n\\n    private int computeMask(int x, int[] primes) {\\n        int mask = 0;\\n        for (int i = 0; i < primes.length; i++) {\\n            int p = primes[i];\\n            int cnt = 0;\\n            while (x % p == 0) {\\n                x /= p;\\n                cnt++;\\n            }\\n\\n            if (cnt == 0) continue;\\n            if (cnt == 1) mask |= (1 << (i + 1));\\n            if (cnt >= 2) return -1;\\n        }\\n        return mask;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204393,
                "title": "recursive-beats-100-video-solution-no-dp",
                "content": "# Intuition\\nThere are multiple ways of doing this question since the constraints weren\\'t stringent. Had the constraints been a bit more stringent then probably the only way of doing it would be the one discussed below. \\nSo let\\'s discuss the hardest way (still easy to understand)\\n[DON\\'T GET SCARED BY THE LINES OF CODE IT\\'S A BIT LENGTHY BUT EASY]\\n\\nvideo solution: https://youtu.be/U4KL7IP8YOM\\n\\n[PREREQ] Some basic knowledge (can skip if you\\'re comfortable with basic maths). \\n1. any number can be represented as a multiplication of prime numbers \\n2. in order for a number to be divisible by a square it should have 2 same prime numbers in it\\'s multiplication (let\\'s say this prime number is p), if p appears twice in it\\'s representation then it\\'s divisible by p*p which makes it divisible by a square $(p*p)$\\n3. I can multiply 1 to any number without changing it, the ways of selecting non empty subsets of 1s from n 1s is $2^n-1$\\n\\nIn the question $a[i]<=30$ but $n<=10^3$, hence it\\'s obvious to store the frequencies (you can do it without that as well and it would still pass but we are understanding the best way of doing it :) ). \\n\\n# Approach\\nLet\\'s start with the solution now!\\nConstruction of all possible subsets is trivial (at each recursive call we can either try to keep the current element in the set or ignore it).\\n\\nfrom PREREQ(2) it\\'s obvious that the set we are trying to construct shouldn\\'t have 2 same prime numbers as their multipliers. Since there are only 10 prime numbers <=30, hence we can use any data structure (vector,map,set etc) to store them however in order to speed it up let\\'s store them in a mask and use bitmasking to know which all prime numbers are already present in the multiplication of all numbers in the current set. \\n\\nWe do this check via a function named getMul (sounds idiomatic? idk, it just returns the mask of the number which would be formed when we multiply the current number num to the existing set). it checks for all the prime factors of the current number if it has more than 2 occurences of the same prime number then it returns 0 (0 is set as the return for invalid operation). if the current number contains p as a factor which is also set in the mask then also it returns 0, else it returns the mask of the formed number after multiplication. \\nHowever the same number can be present more than 1 times in the original array provided, let\\'s say $a[i]$ is present $f[i]$ times then I could multiply $f[i]$ to the result I get when I cosider adding $a[i]$ to my subset (since I can choose any 1 of those $f[i]$ occurences).\\n\\nRest is plain and simple.\\n.\\n.\\n wait what about 1s? we ignored them initially. now it\\'s time to use them. Recall PreReq(3). let\\'s say the number of valid subsets without using 1s was $x$ and number of non empty subsets of 1s are $y$ then total number of valid sets = $x+x*y+y$ . I have used binary exponentiation to calculate the number of sets of 1 as the number could be huge and the inbuilt pow() function would overflow. \\n\\nI had used DP in the contest but the testcases are week enough thereby the dp solution does worse than the recusrive solution without memoisation. \\nBut still if you\\'re interested in dp then you just need to store the index of the array being traversed and the mask as in the 2D array.  \\n\\nI hope you understood and liked the ellaborate solution :)\\n\\n# Complexity\\n- Time complexity:\\n- $$O(30*(2^{10}))$$ : I had used dp for this\\n- for  recursive I am unable to come up with the exact time complexity, would update this soon. \\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n-$$O(30)$$  in case of recursion \\n-$$O(30*(2^{10}))$$  in dp \\n\\n\\n# Code\\n```\\nint primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};        // 10 primes in total-> need to check lesser than 30 only!\\nunordered_map<int,int> primeMap,freq;       // primeMap is used for setting the relevant bit in the mask. \\nint MOD=1e9+7;\\nint power(long long x, long long y, int p =  MOD)\\n{\\n    unsigned long long res = 1;\\n    x = x % p;\\n    while (y > 0)\\n    {\\n        if (y & 1)  res = (res * x) % p;\\n        y = y >> 1;\\n        x = (x * x) % p;\\n    }\\n    return res;\\n}\\nclass Solution {\\nprivate:\\n    int getMul(int mask,int num){               // returns 0 for invalid mask\\n        for(auto& p:primes){\\n            if(num%p==0){\\n                if(mask&(1<<primeMap[p]))   return 0;  \\n                num/=p;\\n                if(num%p==0)    return 0;    // can be divided by the same num twice hence is divisible by the square -> p*p\\n                mask|=(1<<primeMap[p]);\\n            }\\n        }\\n        return mask;\\n    }\\n    int construct(int prod_mask,vector<int>& nums,int idx){\\n        if(idx==nums.size())    return prod_mask!=0;\\n        \\n        int res=construct(prod_mask,nums,idx+1);\\n        \\n        int mask_when_multiplied=getMul(prod_mask,nums[idx]);   // can I add this number to the set?\\n        if(mask_when_multiplied!=0) res=(res+1ll*freq[nums[idx]]*construct(mask_when_multiplied,nums,idx+1))%MOD;\\n        \\n        return res;\\n    }\\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        freq.clear();   // clear the maps\\n        \\n        for(int i=0;i<10;i++)    primeMap[primes[i]]=i+1;       // set the locs of the prime Numbers (10 in total)\\n        for(auto& i:nums)   freq[i]++;\\n        \\n        set<int> st(nums.begin(),nums.end());\\n        nums.clear();       // num would only contain numbers greater than 1 and unique-> reqd for the recursion\\n        for(auto& x:st) if(x>1)    nums.push_back(x);\\n        \\n        int numberOfSets=construct(0,nums,0)%MOD;       // number of ways of creating non empty valid subsets without 1 \\n        \\n        int nonEmpty1sets=(power(2,freq[1])-1+MOD)%MOD;\\n        \\n        numberOfSets=(numberOfSets+1ll*numberOfSets*nonEmpty1sets%MOD+nonEmpty1sets)%MOD;    \\n        \\n        // if 1s are present then they can be used individually -> (2^n)-1 ways or each of these comb i.e.(2^n)-1 can be multiplied with the currently formed set\\n        return numberOfSets;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};        // 10 primes in total-> need to check lesser than 30 only!\\nunordered_map<int,int> primeMap,freq;       // primeMap is used for setting the relevant bit in the mask. \\nint MOD=1e9+7;\\nint power(long long x, long long y, int p =  MOD)\\n{\\n    unsigned long long res = 1;\\n    x = x % p;\\n    while (y > 0)\\n    {\\n        if (y & 1)  res = (res * x) % p;\\n        y = y >> 1;\\n        x = (x * x) % p;\\n    }\\n    return res;\\n}\\nclass Solution {\\nprivate:\\n    int getMul(int mask,int num){               // returns 0 for invalid mask\\n        for(auto& p:primes){\\n            if(num%p==0){\\n                if(mask&(1<<primeMap[p]))   return 0;  \\n                num/=p;\\n                if(num%p==0)    return 0;    // can be divided by the same num twice hence is divisible by the square -> p*p\\n                mask|=(1<<primeMap[p]);\\n            }\\n        }\\n        return mask;\\n    }\\n    int construct(int prod_mask,vector<int>& nums,int idx){\\n        if(idx==nums.size())    return prod_mask!=0;\\n        \\n        int res=construct(prod_mask,nums,idx+1);\\n        \\n        int mask_when_multiplied=getMul(prod_mask,nums[idx]);   // can I add this number to the set?\\n        if(mask_when_multiplied!=0) res=(res+1ll*freq[nums[idx]]*construct(mask_when_multiplied,nums,idx+1))%MOD;\\n        \\n        return res;\\n    }\\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        freq.clear();   // clear the maps\\n        \\n        for(int i=0;i<10;i++)    primeMap[primes[i]]=i+1;       // set the locs of the prime Numbers (10 in total)\\n        for(auto& i:nums)   freq[i]++;\\n        \\n        set<int> st(nums.begin(),nums.end());\\n        nums.clear();       // num would only contain numbers greater than 1 and unique-> reqd for the recursion\\n        for(auto& x:st) if(x>1)    nums.push_back(x);\\n        \\n        int numberOfSets=construct(0,nums,0)%MOD;       // number of ways of creating non empty valid subsets without 1 \\n        \\n        int nonEmpty1sets=(power(2,freq[1])-1+MOD)%MOD;\\n        \\n        numberOfSets=(numberOfSets+1ll*numberOfSets*nonEmpty1sets%MOD+nonEmpty1sets)%MOD;    \\n        \\n        // if 1s are present then they can be used individually -> (2^n)-1 ways or each of these comb i.e.(2^n)-1 can be multiplied with the currently formed set\\n        return numberOfSets;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205209,
                "title": "concise-9-lines-python-with-prime-factor-bitmap-and-a-map-to-record-of-subsets-of-valid-products",
                "content": "# Intuition\\n1. A square-free integer requires the prime factorization of an integer doesn\\'t have duplicate primes. (That is, each prime have a count of either **1 or 0**)\\n2. Follow 1., as the range of possible numbers is very small, we can use bitmask to represent valid integers or subsets.\\n3. Since we only care about subsets count, different subsets with the same composition of primes can be represented as a key-value pair with bitmask as key and subsets count as value. \\ni.e.\\n    arr = [3, 5, 5]\\n    valid subsets are: {**3**(index=0), **5**(index=1)}, {**3**(index=0), **5**(index=2)}, {**3**(index=0)}, {**5**(index=0)}, {**5**(index=1)} \\nand can be represent by \\n    map[**bitmask representation of 3*5**] = 2\\n    map[**bitmask representation of 3**] = 1\\n    map[**bitmask representation of 5**] = 2\\n\\n# Approach\\n1. Map all valid numbers to its bit mask representation, each bit represent the existence of a prime factor\\n    * $2 \\\\to b\\'1 = 1,\\\\; 3 \\\\to b\\'10 = 2,\\\\; 5 \\\\to b\\'100 = 4,\\\\; 7 \\\\to b\\'1000 = 8 ...$\\n    * 1 is special because its existance does not affect anything, we use 0 so that every number that AND with it would result 0\\n    * For other valid numbers, do OR operation with the bit mask of its prime factor, $30 = 2 * 3 * 5 \\\\to 1 | 2 | 4 = 7$\\n\\n2. Now, we can check if a subset is still valid after adding a number by checking if the AND of their bitmasks is 0.\\n   i.e. \\n    * {6,7} and 11 ? $6 \\\\to b\\'1\\' | b\\'10\\',\\\\; 7 \\\\to b\\'1000\\',\\\\; 11 \\\\to b\\'10000\\'$, since $b\\'1\\' |  b\\'10\\' | b\\'1000\\' & b\\'10000\\' = 0$, {6, 7, 11} is still a valid set\\n3. Then, we loop over every valid number and do AND operation with bit representations of all valid subset bitmask representations we currently have, a result of 0 means that there\\'s no duplicate prime factor between product of the subset and this number \\n4. Since a subset that only contains the valid number itself: $count[valid[n]] += 1$\\n\\n# Complexity\\nTime complexity: $O(n \\\\times 2^{10})$\\nSpace complexity: $O(2^{10})$\\n\\nSince there are only 10 prime factors in [1, 30], the max size of count map is $2^{10}$ (Either pick or not pick a prime factor)\\n# Code\\n```python\\nclass Solution:\\n    def squareFreeSubsets(self, nums):\\n        # Pre-prepared bitmask\\n        valid = {1:0, 2:1, 3:2, 5:4, 6:3, 7:8, 10:5, 11:16, 13:32, 14:9, 15:6, 17:64, 19:128, 21:10, 22:17, 23:256, 26:33, 29:512, 30:7}\\n        count = defaultdict(int)\\n        for n in nums:\\n            if n in valid:\\n                for k in count.copy():\\n                    # If n & subset with bitmask k have common prime factor\\n                    if valid[n] & k == 0:\\n                        # Since the subset is still valid taking n in, we now have count[k] more subsets\\n                        # count[k] subsets without n and count[k] subsets with n\\n                        count[valid[n]|k] += count[k]\\n                # subset {n}\\n                count[valid[n]] += 1\\n        return sum(count.values()) % (10 ** 9 + 7)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def squareFreeSubsets(self, nums):\\n        # Pre-prepared bitmask\\n        valid = {1:0, 2:1, 3:2, 5:4, 6:3, 7:8, 10:5, 11:16, 13:32, 14:9, 15:6, 17:64, 19:128, 21:10, 22:17, 23:256, 26:33, 29:512, 30:7}\\n        count = defaultdict(int)\\n        for n in nums:\\n            if n in valid:\\n                for k in count.copy():\\n                    # If n & subset with bitmask k have common prime factor\\n                    if valid[n] & k == 0:\\n                        # Since the subset is still valid taking n in, we now have count[k] more subsets\\n                        # count[k] subsets without n and count[k] subsets with n\\n                        count[valid[n]|k] += count[k]\\n                # subset {n}\\n                count[valid[n]] += 1\\n        return sum(count.values()) % (10 ** 9 + 7)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206821,
                "title": "easy-memoization-bit-masking-c-solution",
                "content": "# Complexity\\n- Time complexity: O(n * (2^10)) = O(1024*n) \\u2248 O($$n^2$$)\\n- Space complexity: O(n * (2^10)) = O(1024*n) \\u2248 O($$n^2$$)\\n    $$n^2$$ because in worst case, n = 1000 $$ie. \\u2248 1024$$\\n\\n# Code\\n```\\n#define mod int(1e9+7)\\nint prime_number[] = {2,3,5,7,11,13,17,19,23,29};\\nint dp[1001][1025];\\nclass Solution {\\npublic:\\n    int h(vector<int> &a, int in, int mask) {\\n        if(in == a.size()) {\\n            return 0;\\n        }\\n        if(dp[in][mask] != -1) {\\n            return dp[in][mask];\\n        }\\n        // no take - use the mask without updation\\n        int do_not_take = h(a, in+1, mask) % mod;\\n        \\n        // take\\n        int take = 1, new_mask = mask;\\n        for(int i=0 ; i<10 ; ++i) {\\n            // if a[in] is divisible by prime_number[i], then\\n            // prime_number[i] will also be a factor of the \\n            // current product, so update the mask accordingly\\n            if(a[in] % prime_number[i] == 0) {\\n                \\n                // if we previously have the i\\'th bit set (1), \\n                // then there will exit a square of higher power \\n                // of prime_number[i], so we can\\'t take this \\n                // product. therefore, don\\'t check further\\n                if(mask & (1<<i)) {\\n                    take = 0;\\n                    break;\\n                }\\n\\n                // if i\\'th bit of mask is unset (0), then \\n                // update mask by enabling (setting) the i\\'th bit\\n                new_mask |= (1<<i);\\n            }\\n        }\\n        if(take == 1) {\\n            // use the modified mask here\\n            take = (1ll + h(a, in+1, new_mask)) % mod;\\n        }\\n        \\n        return dp[in][mask] = (do_not_take + take) % mod;\\n    }\\n    int squareFreeSubsets(vector<int>& a) {\\n        memset(dp, -1, sizeof(dp));\\n\\n        // removing all those numbers form input array \\n        // which are a factor of (prime_number[j])^2\\n        vector<int> t;\\n        for(auto i: a) {\\n            bool use_this_number = 1;\\n            for(int j=0 ; j<10 ; ++j) {\\n                if(i % (prime_number[j] * prime_number[j]) == 0) {\\n                    use_this_number = 0;\\n                    break;\\n                }\\n            }\\n            if(use_this_number) {\\n                t.push_back(i);\\n            }\\n        }\\n\\n        // get the answer\\n        return h(t, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\n#define mod int(1e9+7)\\nint prime_number[] = {2,3,5,7,11,13,17,19,23,29};\\nint dp[1001][1025];\\nclass Solution {\\npublic:\\n    int h(vector<int> &a, int in, int mask) {\\n        if(in == a.size()) {\\n            return 0;\\n        }\\n        if(dp[in][mask] != -1) {\\n            return dp[in][mask];\\n        }\\n        // no take - use the mask without updation\\n        int do_not_take = h(a, in+1, mask) % mod;\\n        \\n        // take\\n        int take = 1, new_mask = mask;\\n        for(int i=0 ; i<10 ; ++i) {\\n            // if a[in] is divisible by prime_number[i], then\\n            // prime_number[i] will also be a factor of the \\n            // current product, so update the mask accordingly\\n            if(a[in] % prime_number[i] == 0) {\\n                \\n                // if we previously have the i\\'th bit set (1), \\n                // then there will exit a square of higher power \\n                // of prime_number[i], so we can\\'t take this \\n                // product. therefore, don\\'t check further\\n                if(mask & (1<<i)) {\\n                    take = 0;\\n                    break;\\n                }\\n\\n                // if i\\'th bit of mask is unset (0), then \\n                // update mask by enabling (setting) the i\\'th bit\\n                new_mask |= (1<<i);\\n            }\\n        }\\n        if(take == 1) {\\n            // use the modified mask here\\n            take = (1ll + h(a, in+1, new_mask)) % mod;\\n        }\\n        \\n        return dp[in][mask] = (do_not_take + take) % mod;\\n    }\\n    int squareFreeSubsets(vector<int>& a) {\\n        memset(dp, -1, sizeof(dp));\\n\\n        // removing all those numbers form input array \\n        // which are a factor of (prime_number[j])^2\\n        vector<int> t;\\n        for(auto i: a) {\\n            bool use_this_number = 1;\\n            for(int j=0 ; j<10 ; ++j) {\\n                if(i % (prime_number[j] * prime_number[j]) == 0) {\\n                    use_this_number = 0;\\n                    break;\\n                }\\n            }\\n            if(use_this_number) {\\n                t.push_back(i);\\n            }\\n        }\\n\\n        // get the answer\\n        return h(t, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204813,
                "title": "video-explanation-hindi-o-2-19-worst-case-bitmask-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCan I exploit so small value of nums[i] ?\\nWhat are invalid values that I cannot use?\\nAll values that are multiple of \\'4\\' or \\'9\\' or \\'25\\' <=30 are invalid as\\nthey will have square in them . {4,8,12,16,20,24,28,9,18,27,25}.\\n\\nSo I have 19 values only which are valid . oh now I can have O(2^n) solution .\\n\\n[https://youtu.be/kRJrgGWwpaU]()\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind **valid unique** array of intial array which contains valid values and also frequency array of intial nums array .\\n\\nWe choose only those subsequence whose **GCD(product_of_subsequence , A[i]) = 1** for all element A[i] in subseqence is  = 1 and length >1 .  \\n\\nNow for any subsequence of {a,b,c} of **vaid unique array** , total number of valid subset is  **(fre[a] * fre[b] * fre[c])**\\n\\nEdge case is subsequency containing **1** as here we take 2^fre[1] in place of fre[1] , this is just for \\'1\\' as we can have multiple \\'1\\'s in our subset. So option for \\'1\\' is 2^fre[1].\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^m) -- where m = size of valid unique array <= 19 \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(30) - as we take care of values upto 30\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long mod = 1e9+7;\\n    int not_allowed[31];\\n   \\n    long long power(long long a,long long b){\\n        long long res = 1ll;\\n        \\n        while(b){\\n            if(b%2){\\n                res*=a;\\n                res%=mod;\\n            }\\n            b>>=1ll;\\n            a*=a;\\n            a%=mod;\\n        }\\n        return res;\\n    }\\n    \\n    int squareFreeSubsets(vector<int>& nums) {\\n         \\n         \\n        memset(not_allowed,0,sizeof(not_allowed));\\n        for(int i=2;i<=5;++i){\\n            int cur = i*i;\\n            for(int j=cur;j<=30;j+=cur){\\n                not_allowed[j]++;\\n            }\\n        }\\n        vector<long long>z;\\n        vector<long long>fre(31);\\n        \\n        for(auto&x:nums){\\n            fre[x]++;\\n          //we are taking only valid values \\n            if(not_allowed[x] == 0){\\n                z.push_back(x);\\n                //after adding to our valid array we mark this also so we don\\'t add them again in array                 \\n                not_allowed[x]++;\\n            }\\n        }\\n        \\n        long long ex = 1;\\n        if(not_allowed[1]){\\n// only for \\'1\\' we have 2^fre[1] options\\n            ex = power(2ll,fre[1]);\\n            ex--;\\n        }\\n       \\n         int n = z.size();\\n         \\n        \\n        long long ans = 0;\\n        int lim = (1<<n);\\n        \\n//finding all subsequency usignn bitmask\\n        for(int i=1;i<=lim;++i){\\n            long long pro = 1;\\n            long long gc = 1;\\n            int f = 0,g = 0;\\n            long long val = 1,e = 1;\\n            \\n \\n            for(int j=0;j<n;++j){\\n                if(i & (1<<j)){\\n                    gc = __gcd(pro,z[j]);\\n                    g = 1;\\n\\n                   //if GCD >1 it means we have square factor\\n                    if(gc>1){\\n                        f=1;\\n                        break;\\n                    }\\n                    pro*=z[j];\\n                    if(z[j] != 1){\\n                        val*=fre[z[j]];\\n                        val%=mod;\\n                    }\\n                    else e = ex;\\n                     \\n                }\\n            }\\n            \\n            if(f);\\n            else if(g){\\n                val*=e;\\n                val%=mod;\\n                ans += val;\\n                ans%=mod;\\n            }\\n        }\\n        \\n        int fin = ans;\\n        return fin;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mod = 1e9+7;\\n    int not_allowed[31];\\n   \\n    long long power(long long a,long long b){\\n        long long res = 1ll;\\n        \\n        while(b){\\n            if(b%2){\\n                res*=a;\\n                res%=mod;\\n            }\\n            b>>=1ll;\\n            a*=a;\\n            a%=mod;\\n        }\\n        return res;\\n    }\\n    \\n    int squareFreeSubsets(vector<int>& nums) {\\n         \\n         \\n        memset(not_allowed,0,sizeof(not_allowed));\\n        for(int i=2;i<=5;++i){\\n            int cur = i*i;\\n            for(int j=cur;j<=30;j+=cur){\\n                not_allowed[j]++;\\n            }\\n        }\\n        vector<long long>z;\\n        vector<long long>fre(31);\\n        \\n        for(auto&x:nums){\\n            fre[x]++;\\n          //we are taking only valid values \\n            if(not_allowed[x] == 0){\\n                z.push_back(x);\\n                //after adding to our valid array we mark this also so we don\\'t add them again in array                 \\n                not_allowed[x]++;\\n            }\\n        }\\n        \\n        long long ex = 1;\\n        if(not_allowed[1]){\\n// only for \\'1\\' we have 2^fre[1] options\\n            ex = power(2ll,fre[1]);\\n            ex--;\\n        }\\n       \\n         int n = z.size();\\n         \\n        \\n        long long ans = 0;\\n        int lim = (1<<n);\\n        \\n//finding all subsequency usignn bitmask\\n        for(int i=1;i<=lim;++i){\\n            long long pro = 1;\\n            long long gc = 1;\\n            int f = 0,g = 0;\\n            long long val = 1,e = 1;\\n            \\n \\n            for(int j=0;j<n;++j){\\n                if(i & (1<<j)){\\n                    gc = __gcd(pro,z[j]);\\n                    g = 1;\\n\\n                   //if GCD >1 it means we have square factor\\n                    if(gc>1){\\n                        f=1;\\n                        break;\\n                    }\\n                    pro*=z[j];\\n                    if(z[j] != 1){\\n                        val*=fre[z[j]];\\n                        val%=mod;\\n                    }\\n                    else e = ex;\\n                     \\n                }\\n            }\\n            \\n            if(f);\\n            else if(g){\\n                val*=e;\\n                val%=mod;\\n                ans += val;\\n                ans%=mod;\\n            }\\n        }\\n        \\n        int fin = ans;\\n        return fin;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204685,
                "title": "python-bitmask-dp-bottom-up-solution",
                "content": "We iterate through all the element and  keep track of the primes that have been used by taking this element in a bitmask. Since the product should be free of squares, it contributes to all the subsets that don\\'t have the prime factors present in the current element. Also if the element has already more than one of the same prime, we discard the element.\\n\\nAfter calculating the contribution from each element, we can finally add the result of each bitmask from 0 to (2^10 - 1). Since the contribution of each element is added only towards the valid bitmasks, we are guaranteed to have the ways to have square free products only for each bitmask.\\n\\nAlso we need to subtract 1 at the end to subtract the case of taking an empty subset (which is said to be avoided in the problem statement).\\n\\n```\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        MOD = 10**9 + 7\\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\\n        dp = [0] * (1 << 10)\\n        dp[0] = 1\\n        for a in nums:\\n            mask = 0\\n            for i, x in enumerate(primes):\\n                if a % (x * x) == 0:\\n                    mask = -1\\n                    break\\n                if a % x == 0:\\n                    mask |= 1 << i\\n            if mask >= 0:\\n                for i in range(1 << 10):\\n                    if (i & mask) == 0:\\n                        dp[i | mask] += dp[i]\\n        return (sum(dp) - 1) % MOD\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        MOD = 10**9 + 7\\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\\n        dp = [0] * (1 << 10)\\n        dp[0] = 1\\n        for a in nums:\\n            mask = 0\\n            for i, x in enumerate(primes):\\n                if a % (x * x) == 0:\\n                    mask = -1\\n                    break\\n                if a % x == 0:\\n                    mask |= 1 << i\\n            if mask >= 0:\\n                for i in range(1 << 10):\\n                    if (i & mask) == 0:\\n                        dp[i | mask] += dp[i]\\n        return (sum(dp) - 1) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203788,
                "title": "python-factorization-and-bit-mask-dp",
                "content": "\\n# Code\\n```python []\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        \\n        def getfac(n):\\n            fac = [2,3,5,7,11,13,17,19,23,29]\\n            c = 0\\n            ind = 0\\n            while n != 1:\\n                while n % fac[ind] == 0:\\n                    if c & (1<<ind):\\n                        # n can be divided by fac[ind] * fac[ind], so -1\\n                        return -1\\n                    c |= (1<<ind)\\n                    n //= fac[ind]\\n                ind += 1\\n            return c\\n        d = defaultdict(int)\\n        d[0] = 1\\n        mod = 1000000007\\n        for num in nums:\\n            fac = getfac(num)\\n            # if -1, then continue\\n            if fac < 0:\\n                continue\\n            k = list(d)\\n            for dd in k:\\n                if dd & fac == 0:\\n                    d[dd|fac] += d[dd]\\n                    d[dd|fac] %= mod\\n        ans = 0\\n        for n in d.values():\\n            ans += n\\n            ans %= mod\\n        # ans -= 1 for excluding empty set\\n        ans -= 1\\n        ans %= mod\\n        return ans \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        \\n        def getfac(n):\\n            fac = [2,3,5,7,11,13,17,19,23,29]\\n            c = 0\\n            ind = 0\\n            while n != 1:\\n                while n % fac[ind] == 0:\\n                    if c & (1<<ind):\\n                        # n can be divided by fac[ind] * fac[ind], so -1\\n                        return -1\\n                    c |= (1<<ind)\\n                    n //= fac[ind]\\n                ind += 1\\n            return c\\n        d = defaultdict(int)\\n        d[0] = 1\\n        mod = 1000000007\\n        for num in nums:\\n            fac = getfac(num)\\n            # if -1, then continue\\n            if fac < 0:\\n                continue\\n            k = list(d)\\n            for dd in k:\\n                if dd & fac == 0:\\n                    d[dd|fac] += d[dd]\\n                    d[dd|fac] %= mod\\n        ans = 0\\n        for n in d.values():\\n            ans += n\\n            ans %= mod\\n        # ans -= 1 for excluding empty set\\n        ans -= 1\\n        ans %= mod\\n        return ans \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211870,
                "title": "python-3-10-lines-w-explanation-and-example-t-m-100-98",
                "content": "This approach is pretty much the same as many already posted, but we try to optimize in two ways:\\n1. Using `Counter` to reduce the amount of repetative work, and\\n2. Divide the integers `1,2,3, ..., 29,30` into those elements that could contribute to a square factor(`prefix`), and those that cannot(`suffix`). Those that already have a square factor are ignored in the`Counter`.\\n```\\nclass Solution:\\n    def squareFreeSubsets(self, nums):\\n\\n        prefix = (( 2, 1), ( 3, 2), ( 6, 3), ( 5, 4), (10, 5),  # <-- These are \\'prefix elements,\\' the fourteen \\n                  (15, 6), (30, 7), ( 7, 8), (14, 9), (21,10),  #     elements of nums, tupled along with their masks,  \\n                  (11,16), (13,32), (22,17), (26,33))           #     that could potentially contribute to a square\\n                                                                #     factor. We use a tuple of tuples instead of a dict  \\n                                                                #     for the iteration below.\\n\\n        suffix = {1,17,19,23,29}                                # <-- The \\'suffix\\' elements\\n\\n        nums, cnt = Counter(nums), defaultdict(int)\\n\\n        for n, p in prefix:\\n                                                                # <-- This is the standard stuff, except we use\\n            for k in list(cnt):                                 #     Counter to do each like value together instead\\n                if not p & k: cnt[p|k] += cnt[k]*nums[n]        #     of iterating thru nums element by element.\\n                                                                #\\n            cnt[p]+= nums[n]                                    #\\n\\n        ans = (sum(cnt.values())+1)*pow(2,nums[1])-1            # <-- We mutiply the prefix count by the number of \\n                                                                #     potential 1s that may be appended to any prefix.\\n        \\n        for n in (17,19,23,29): ans = (ans+1)*(nums[n]+1) - 1   # <-- The other suffix elements. These factors differ\\n                                                                #      from the 1s because including more than one \\n                                                                #      will produce a square factor\\n        return ans % (10 ** 9 + 7)\\n```\\n[https://leetcode.com/problems/count-the-number-of-square-free-subsets/submissions/901832329/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*)  and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def squareFreeSubsets(self, nums):\\n\\n        prefix = (( 2, 1), ( 3, 2), ( 6, 3), ( 5, 4), (10, 5),  # <-- These are \\'prefix elements,\\' the fourteen \\n                  (15, 6), (30, 7), ( 7, 8), (14, 9), (21,10),  #     elements of nums, tupled along with their masks,  \\n                  (11,16), (13,32), (22,17), (26,33))           #     that could potentially contribute to a square\\n                                                                #     factor. We use a tuple of tuples instead of a dict  \\n                                                                #     for the iteration below.\\n\\n        suffix = {1,17,19,23,29}                                # <-- The \\'suffix\\' elements\\n\\n        nums, cnt = Counter(nums), defaultdict(int)\\n\\n        for n, p in prefix:\\n                                                                # <-- This is the standard stuff, except we use\\n            for k in list(cnt):                                 #     Counter to do each like value together instead\\n                if not p & k: cnt[p|k] += cnt[k]*nums[n]        #     of iterating thru nums element by element.\\n                                                                #\\n            cnt[p]+= nums[n]                                    #\\n\\n        ans = (sum(cnt.values())+1)*pow(2,nums[1])-1            # <-- We mutiply the prefix count by the number of \\n                                                                #     potential 1s that may be appended to any prefix.\\n        \\n        for n in (17,19,23,29): ans = (ans+1)*(nums[n]+1) - 1   # <-- The other suffix elements. These factors differ\\n                                                                #      from the 1s because including more than one \\n                                                                #      will produce a square factor\\n        return ans % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204750,
                "title": "recursion-generate-all-possible-subsets",
                "content": "# Intuition\\nLets make some observations\\n1. The square free subset cannot contain duplicates \\n2. square free subset cannot contain a number divisible by a square\\n3. the count of each prime in the product of square free subset should be 1 , else the product is divisible by that prime\\'s square\\n\\n# Approach\\n1. for our current discussion lets ignore 1 because many 1\\'s can be present inside a square free set so we will handle that seperately\\n\\nthe numbers that are not divisble by any square between 2 to 30 are  {2,3,5,6,7,10,11,13,14,15,17,19,21,22,23,26,29,30}\\n\\nso we can generate all possible subsets using these numbers 2^18 , which fits the constraints\\n\\n\\nNow while we generate a subset in the end we simply check if there is some prime in the given set of numbers that occurs twice , if not we can use these numbers to create the set\\n\\nnow for each number we can include  it number of times it occurs in the array and form the total ways to create that particular set\\n\\n\\nNow for ones , we can simply generate 2^(cntof1) subsets and then add them to the ans , we can also pair those subsets with the subsets we generated earlier\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    map<int,int> cnt;\\n    int mod=1e9+7;\\n    \\n    long long ans = 0;\\n    vector<int> primes;\\n    \\n    map<int,vector<int>> factors;\\n    void generate(vector<int> &nums , int i , vector<int> &curr){\\n        \\n        if(i>=nums.size()){\\n            if(curr.size()==0) return;\\n            int prime_cnt[30]={0};\\n            for(auto x:curr){  \\n                for(auto &prime:primes){\\n                    if(x%prime==0){\\n                        prime_cnt[prime]++;\\n                        if(prime_cnt[prime]>=2) return;\\n                    }\\n                }     \\n            }\\n            long long curr_ans=1;\\n            for(auto &x:curr) curr_ans = (curr_ans * cnt[x])%mod;\\n            ans = (ans + curr_ans)%mod;\\n            return ;\\n        }\\n        \\n        generate(nums,i+1,curr);\\n        curr.push_back(nums[i]);\\n        generate(nums,i+1,curr);\\n        curr.pop_back();\\n    }\\n    \\n\\n    \\n    int squareFreeSubsets(vector<int>& nums) {\\n        for(auto &x:nums){\\n            cnt[x]++;\\n        }\\n        vector<int> valid = {2,3,5,6,7,10,11,13,14,15,17,19,21,22,23,26,29,30};\\n        primes={2,3,5,7,11,13,17,19,23,29};\\n        vector<int> curr;\\n        generate(valid,0 , curr);\\n\\n        long long onesubsets = powr(2LL,(long long)cnt[1])-1;\\n        if(onesubsets){\\n            ans = (ans + ans *  onesubsets )%mod;\\n            ans = (ans + onesubsets)%mod;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n\\n    long long powr(long long a, long long b) {\\n\\t long long res = 1;\\n     \\twhile (b) {\\n\\t\\tif (b & 1) res *= a % mod;\\n\\t\\ta = a * a;\\n\\t\\ta %= mod;\\n    \\t\\tb >>= 1;\\n    \\t}\\n\\t    return res;\\n     }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    map<int,int> cnt;\\n    int mod=1e9+7;\\n    \\n    long long ans = 0;\\n    vector<int> primes;\\n    \\n    map<int,vector<int>> factors;\\n    void generate(vector<int> &nums , int i , vector<int> &curr){\\n        \\n        if(i>=nums.size()){\\n            if(curr.size()==0) return;\\n            int prime_cnt[30]={0};\\n            for(auto x:curr){  \\n                for(auto &prime:primes){\\n                    if(x%prime==0){\\n                        prime_cnt[prime]++;\\n                        if(prime_cnt[prime]>=2) return;\\n                    }\\n                }     \\n            }\\n            long long curr_ans=1;\\n            for(auto &x:curr) curr_ans = (curr_ans * cnt[x])%mod;\\n            ans = (ans + curr_ans)%mod;\\n            return ;\\n        }\\n        \\n        generate(nums,i+1,curr);\\n        curr.push_back(nums[i]);\\n        generate(nums,i+1,curr);\\n        curr.pop_back();\\n    }\\n    \\n\\n    \\n    int squareFreeSubsets(vector<int>& nums) {\\n        for(auto &x:nums){\\n            cnt[x]++;\\n        }\\n        vector<int> valid = {2,3,5,6,7,10,11,13,14,15,17,19,21,22,23,26,29,30};\\n        primes={2,3,5,7,11,13,17,19,23,29};\\n        vector<int> curr;\\n        generate(valid,0 , curr);\\n\\n        long long onesubsets = powr(2LL,(long long)cnt[1])-1;\\n        if(onesubsets){\\n            ans = (ans + ans *  onesubsets )%mod;\\n            ans = (ans + onesubsets)%mod;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n\\n    long long powr(long long a, long long b) {\\n\\t long long res = 1;\\n     \\twhile (b) {\\n\\t\\tif (b & 1) res *= a % mod;\\n\\t\\ta = a * a;\\n\\t\\ta %= mod;\\n    \\t\\tb >>= 1;\\n    \\t}\\n\\t    return res;\\n     }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204122,
                "title": "100-fastest-simple-solution-c-recursive",
                "content": "\\n![image](https://assets.leetcode.com/users/images/4f75ca31-b3f8-47f1-834b-d7c3adbfcf6e_1676782359.0025332.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long long ans = 0;\\n    int mod = 1e9+7;\\n    long long one;\\n    \\n    int modI(long a,int p){\\n        long ans=1;\\n        while(p>0)\\n        {\\n            if(p%2)\\n                ans = (ans * a)%mod,p--;\\n            a = (a*a)%mod,p/=2;\\n        }\\n        return ans%mod;\\n    }\\n    \\n    void func(vector<int>& count,int i,vector<int>& nums,vector<int>& freq){\\n        \\n        if(i==31){\\n            int n = count.size();\\n            long long l = one;\\n            if(n==0) l--;\\n            \\n            long long tt = 1;\\n            for(auto i:count){\\n                tt = (tt * nums[i])%mod;\\n            }\\n            \\n            ans = (ans + l*tt)%mod;\\n            return ;\\n        }\\n        \\n        if(nums[i]==0){\\n            func(count,i+1,nums,freq);\\n        }else{\\n            func(count,i+1,nums,freq);\\n            \\n            int f = 1;\\n            \\n            int tt = i;\\n            for(int j=2;j*j<=tt;j++){\\n                while(tt%j==0){\\n                    if(freq[j]){\\n                        f = 0;\\n                        break;\\n                    }\\n                    tt = tt/j;\\n                }\\n            }\\n            if(tt>1 and freq[tt]) f = 0; \\n            \\n            if(f){\\n                count.push_back(i);\\n                tt = i;\\n                for(int j=2;j*j<=tt;j++){\\n                    while(tt%j==0){\\n                        freq[j]++;\\n                        tt = tt/j;\\n                    }\\n                }\\n                if(tt>1) freq[tt]++; \\n                \\n                func(count,i+1,nums,freq);\\n                count.pop_back();\\n                \\n                tt = i;\\n                for(int j=2;j*j<=tt;j++){\\n                    while(tt%j==0){\\n                        freq[j]--;\\n                        tt = tt/j;\\n                    }\\n                }\\n                if(tt>1) freq[tt]--;\\n                \\n            }\\n        }\\n        \\n        \\n    }\\n    \\n    int squareFreeSubsets(vector<int>& nums) {\\n        vector<int> count(31,0);\\n        \\n        for(auto i:nums){\\n            count[i]++;\\n        }\\n        \\n        count[4] = 0;\\n        count[8] = 0;\\n        count[9] = 0;\\n        count[12] = 0;\\n        count[16] = 0;\\n        count[18] = 0;\\n        count[20] = 0;\\n        count[24] = 0;\\n        count[25] = 0;\\n        count[27] = 0;\\n        count[28] = 0;\\n        \\n        vector<int> t,freq(31,0);\\n        \\n        one = modI(2,count[1]);\\n        \\n        func(t,2,count,freq);\\n        \\n        return ans;\\n    }\\n}\\n\\n\\n```\\n\\n",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long ans = 0;\\n    int mod = 1e9+7;\\n    long long one;\\n    \\n    int modI(long a,int p){\\n        long ans=1;\\n        while(p>0)\\n        {\\n            if(p%2)\\n                ans = (ans * a)%mod,p--;\\n            a = (a*a)%mod,p/=2;\\n        }\\n        return ans%mod;\\n    }\\n    \\n    void func(vector<int>& count,int i,vector<int>& nums,vector<int>& freq){\\n        \\n        if(i==31){\\n            int n = count.size();\\n            long long l = one;\\n            if(n==0) l--;\\n            \\n            long long tt = 1;\\n            for(auto i:count){\\n                tt = (tt * nums[i])%mod;\\n            }\\n            \\n            ans = (ans + l*tt)%mod;\\n            return ;\\n        }\\n        \\n        if(nums[i]==0){\\n            func(count,i+1,nums,freq);\\n        }else{\\n            func(count,i+1,nums,freq);\\n            \\n            int f = 1;\\n            \\n            int tt = i;\\n            for(int j=2;j*j<=tt;j++){\\n                while(tt%j==0){\\n                    if(freq[j]){\\n                        f = 0;\\n                        break;\\n                    }\\n                    tt = tt/j;\\n                }\\n            }\\n            if(tt>1 and freq[tt]) f = 0; \\n            \\n            if(f){\\n                count.push_back(i);\\n                tt = i;\\n                for(int j=2;j*j<=tt;j++){\\n                    while(tt%j==0){\\n                        freq[j]++;\\n                        tt = tt/j;\\n                    }\\n                }\\n                if(tt>1) freq[tt]++; \\n                \\n                func(count,i+1,nums,freq);\\n                count.pop_back();\\n                \\n                tt = i;\\n                for(int j=2;j*j<=tt;j++){\\n                    while(tt%j==0){\\n                        freq[j]--;\\n                        tt = tt/j;\\n                    }\\n                }\\n                if(tt>1) freq[tt]--;\\n                \\n            }\\n        }\\n        \\n        \\n    }\\n    \\n    int squareFreeSubsets(vector<int>& nums) {\\n        vector<int> count(31,0);\\n        \\n        for(auto i:nums){\\n            count[i]++;\\n        }\\n        \\n        count[4] = 0;\\n        count[8] = 0;\\n        count[9] = 0;\\n        count[12] = 0;\\n        count[16] = 0;\\n        count[18] = 0;\\n        count[20] = 0;\\n        count[24] = 0;\\n        count[25] = 0;\\n        count[27] = 0;\\n        count[28] = 0;\\n        \\n        vector<int> t,freq(31,0);\\n        \\n        one = modI(2,count[1]);\\n        \\n        func(t,2,count,freq);\\n        \\n        return ans;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203752,
                "title": "map-and-gcd-similar-to-using-a-bitmask",
                "content": "# Approach\\nThis approach is actually doing the same thing as using a bitmask for the prime numbers. I\\'m storing the product of the prime numbers in the map instead of a bitmask. Here I find the GCD of the subset and the number, if the GCD is 1, then it means that there are no common factors and hence there can\\'t be a square number that divides their product.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        using ll = long long;\\n        map<ll,ll> mp;\\n        int MOD = 1e9 + 7;\\n        \\n        for(int num : nums) {\\n            bool flag = false;\\n            \\n            for(int i=2; i<=5; i++) {\\n                if(num % (i*i) == 0) {\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag) continue;\\n            \\n            vector<pair<ll,ll>> temp;\\n            \\n            for(auto [k, v] : mp) {\\n                if(__gcd(k, (ll)num) == 1) {\\n                    temp.push_back({k*num, v});\\n                }\\n            }\\n            \\n            for(auto [k, v] : temp) {\\n                mp[k] = (mp[k] + v)%MOD;\\n            }\\n            \\n            mp[num] = (mp[num] + 1)%MOD;\\n        }\\n        \\n        int result = 0;\\n        \\n        for(auto [k, v] : mp) {\\n            result = (result + v)%MOD;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n> Sidenote: **Looks like `Hard` problems are slowing becoming `Medium` rated....**",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        using ll = long long;\\n        map<ll,ll> mp;\\n        int MOD = 1e9 + 7;\\n        \\n        for(int num : nums) {\\n            bool flag = false;\\n            \\n            for(int i=2; i<=5; i++) {\\n                if(num % (i*i) == 0) {\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag) continue;\\n            \\n            vector<pair<ll,ll>> temp;\\n            \\n            for(auto [k, v] : mp) {\\n                if(__gcd(k, (ll)num) == 1) {\\n                    temp.push_back({k*num, v});\\n                }\\n            }\\n            \\n            for(auto [k, v] : temp) {\\n                mp[k] = (mp[k] + v)%MOD;\\n            }\\n            \\n            mp[num] = (mp[num] + 1)%MOD;\\n        }\\n        \\n        int result = 0;\\n        \\n        for(auto [k, v] : mp) {\\n            result = (result + v)%MOD;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211495,
                "title": "improvements-made-based-on-yowaimo-s-great-idea",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nGang make some improvements:\\n1. Rename some variables for better meaning.\\n\\n2. Make the logic of count ans variable more understandable\\n   Inside dfs function, make change\\n     Before: if (ind === LEN) return 1;\\n     After:  if (ind === LEN) return 0;\\n   Then add ans++ line to increase the ans value when product of runningMask and mask creates a square free number\\n   Finally, remove the -1 operation from line return dfs(0, 0, nums);\\n\\n3. Change runningMask initial value from 1 to 0, and inside getMask function, shift mask by i instead of i + 1,\\n   this will save the memory space and more meaningful.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Based on the idea/code from Yowaimo\\'s great idea:\\n * https://leetcode.com/problems/count-the-number-of-square-free-subsets/solutions/3203707/dp-bitmask-c-prime-factorization/?orderBy=most_votes\\n * \\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar squareFreeSubsets = function (nums) {\\n  const LEN = nums.length;\\n  const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];\\n\\n  function getMask(num) {\\n    let mask = 0;\\n    for (let i = 0; i < 10; i++) {\\n      let samePrimeCount = 0;\\n      while (num % primes[i] === 0) {\\n        samePrimeCount += 1;\\n        num /= primes[i];\\n      }\\n      if (samePrimeCount > 1) return -1; // if a number is getting divided with a prime more than 1 time meaning it can be divided by that primes square\\n      if (samePrimeCount === 1) mask |= 1 << i; // i + 1 because the for i === 0 product 1 has already been taken\\n    }\\n    return mask;\\n  }\\n\\n  function dfs(ind, runningMask, nums) {\\n    if (ind === LEN) return 0;\\n    if (dp[ind][runningMask] !== undefined) return dp[ind][runningMask];\\n\\n    let mask = getMask(nums[ind]);\\n    let ans = dfs(ind + 1, runningMask, nums);\\n\\n    if (mask !== -1 && (runningMask & mask) === 0) {\\n      ans++;\\n      ans = (ans + dfs(ind + 1, runningMask | mask, nums)) % mod;\\n    }\\n    dp[ind][runningMask] = ans;\\n    return ans;\\n  }\\n\\n  let mod = 1e9 + 7;\\n  let dp = [];\\n  for (let i = 0; i < LEN; i++) dp[i] = [];\\n\\n  return dfs(0, 0, nums); //\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Based on the idea/code from Yowaimo\\'s great idea:\\n * https://leetcode.com/problems/count-the-number-of-square-free-subsets/solutions/3203707/dp-bitmask-c-prime-factorization/?orderBy=most_votes\\n * \\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar squareFreeSubsets = function (nums) {\\n  const LEN = nums.length;\\n  const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];\\n\\n  function getMask(num) {\\n    let mask = 0;\\n    for (let i = 0; i < 10; i++) {\\n      let samePrimeCount = 0;\\n      while (num % primes[i] === 0) {\\n        samePrimeCount += 1;\\n        num /= primes[i];\\n      }\\n      if (samePrimeCount > 1) return -1; // if a number is getting divided with a prime more than 1 time meaning it can be divided by that primes square\\n      if (samePrimeCount === 1) mask |= 1 << i; // i + 1 because the for i === 0 product 1 has already been taken\\n    }\\n    return mask;\\n  }\\n\\n  function dfs(ind, runningMask, nums) {\\n    if (ind === LEN) return 0;\\n    if (dp[ind][runningMask] !== undefined) return dp[ind][runningMask];\\n\\n    let mask = getMask(nums[ind]);\\n    let ans = dfs(ind + 1, runningMask, nums);\\n\\n    if (mask !== -1 && (runningMask & mask) === 0) {\\n      ans++;\\n      ans = (ans + dfs(ind + 1, runningMask | mask, nums)) % mod;\\n    }\\n    dp[ind][runningMask] = ans;\\n    return ans;\\n  }\\n\\n  let mod = 1e9 + 7;\\n  let dp = [];\\n  for (let i = 0; i < LEN; i++) dp[i] = [];\\n\\n  return dfs(0, 0, nums); //\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3207839,
                "title": "java-bit-mask-and-subset-and-counting-number-of-subsets-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem counts of number of subsets.\\n\\nWhen solving subsets problem, there are two choices for each element, to choose or not to choose. So that this problem uses typical patterns of subset problems, and uses depth-first search method.\\n\\nIt is a counting problem, so that consider using dynamic programming.\\n\\nThe number of non-overlapping subprolems are individual numbers times number of masks, which is 30 times 2^10 (because there are 10 primes in range of [1, 30]).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNotice that the range of number is from 1 to 30, which is less than 32, so that we can consider using **bit-mask**.\\n\\nNotice that only prime factors matters for each subproblem, and between 1 and 30, there are only 10 primes {2, 3, 5, 7, 11, 13, 17, 19, 23, 29}. This problem cannot have two identical primes, so that **bit-mask can be used to handle whether a prime is presented or not**.\\n\\nNotice that there are up to 1,000 numbers, but only different numbers matter. Thus we can use one **frequency array** to count frequency of these numbers and make the solution more efficient.\\n\\n# Edge Cases of Counting Duplicates\\nWhen freq[num] is larger than 1, there are duplicates.\\n\\nFor example, consider [3, 5] and [3, 3, 5].\\n\\n[3, 5] has square-free subsets of {[], [3], [5], [3, 5]}.\\n\\n[3, 3, 5] has square-free subsets of {[], [3], [5], [3, 5], [3], [3, 3], [3, 5], [3, 3, 5]}. Nubmer of these subsets are square-free subsets of [3, 5] doubled, each adding one 3.\\n\\n[3, 3, 3, 5] has square-free subsets of {[], [3], [5], [3, 5], [3], [3, 3], [3, 5], [3, 3, 5], [3, 3], [3, 3, 3], [3, 3, 5], [3, 3, 3, 5]}. Number of these subsets are square-free subsets of [3, 5] trippled, each adding one 3 or adding two 3s.\\n\\n# Edge Cases of 1\\nEdge case is when 1 is present.\\n\\nFor example, [3, 5]. The square-free subsets are {[], [3], [5], [3, 5]}. We need to remove the empty subset [], but we keep it here for now.\\n\\nWhen we add one 1. The nubmer of square-free sbusets are original solutions doubles, because we must add add one 1 to each of original subsets, such as {[], [3], [5], [3, 5], [1], [1, 3], [1, 5], [1, 3, 5]}, therefore, the count doubled when including empty subset [].\\n\\nWhen we add two 1s. The number of square-free subsets doubles again. The solution becomes: {[], [3], [5], [3, 5], [1], [1, 3], [1, 5], [1, 3, 5], [1], [1, 3], [1, 5], [1, 3, 5], [1,1], [1, 1, 3], [1, 1, 5], [1, 1, 3, 5]}. Notice that what the solution require are subsets, but not **unique subsets**, so that there are some **duplicated subsets**.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe non-overlapping subproblems are number of states, which is 30 * 1024.\\nO(30 * 1024) ~ O(1).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe matrix used to store states of non-overlapping subproblems.\\nO(30 * 1024) ~ O(1).\\n\\n# Code\\n```\\nclass Solution {\\n    int[] primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n    private static final int MOD = 1000000007;\\n    public int squareFreeSubsets(int[] nums) {\\n        Long[][] memo = new Long[31][1 << 11];\\n        int[] freq = new int[31];\\n        for (int num : nums) {\\n            freq[num]++;\\n        }\\n        // because factors 4, 9 and 25 are not square-free, so that\\n        // numbers that contain these factors does not contribute\\n        // to square-free product subsets. Set their frequencies to\\n        // zeroes here.\\n        for (int i = 4; i <= 30; i += 4) {\\n            freq[i] = 0;\\n        }\\n        for (int i = 9; i <= 30; i += 9) {\\n            freq[i] = 0;\\n        }\\n        freq[25] = 0;\\n        long result = dfs(2, 0, freq, memo);\\n        for (int i = 0; i < freq[1]; i++) {\\n            result = (result * 2) % MOD;\\n        }\\n        return (int) ((result - 1 + MOD) % MOD);\\n    }\\n    private long dfs(int num, int mask, int[] freq, Long[][] memo) {\\n        // termination condition\\n        if (num >= 31) {\\n            return 1;\\n        }\\n        if (memo[num][mask] != null) {\\n            return memo[num][mask];            \\n        }\\n        // normal condition\\n        // do not add num\\n        long result = dfs(num + 1, mask, freq, memo);\\n        // do add num\\n        boolean addNum = true;\\n        int maskNext = mask;\\n        for (int i = 0; i < primes.length; i++) {\\n            if (num % primes[i] == 0) {\\n                if ((maskNext & (1 << i)) > 0) {\\n                    addNum = false;\\n                    break;\\n                } else {\\n                    maskNext |= (1 << i);\\n                }\\n            }            \\n        }\\n        if (addNum && freq[num] > 0) {\\n            result = (result + freq[num] * dfs(num + 1, maskNext, freq, memo) % MOD) % MOD;\\n        }\\n        memo[num][mask] = result;\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    int[] primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n    private static final int MOD = 1000000007;\\n    public int squareFreeSubsets(int[] nums) {\\n        Long[][] memo = new Long[31][1 << 11];\\n        int[] freq = new int[31];\\n        for (int num : nums) {\\n            freq[num]++;\\n        }\\n        // because factors 4, 9 and 25 are not square-free, so that\\n        // numbers that contain these factors does not contribute\\n        // to square-free product subsets. Set their frequencies to\\n        // zeroes here.\\n        for (int i = 4; i <= 30; i += 4) {\\n            freq[i] = 0;\\n        }\\n        for (int i = 9; i <= 30; i += 9) {\\n            freq[i] = 0;\\n        }\\n        freq[25] = 0;\\n        long result = dfs(2, 0, freq, memo);\\n        for (int i = 0; i < freq[1]; i++) {\\n            result = (result * 2) % MOD;\\n        }\\n        return (int) ((result - 1 + MOD) % MOD);\\n    }\\n    private long dfs(int num, int mask, int[] freq, Long[][] memo) {\\n        // termination condition\\n        if (num >= 31) {\\n            return 1;\\n        }\\n        if (memo[num][mask] != null) {\\n            return memo[num][mask];            \\n        }\\n        // normal condition\\n        // do not add num\\n        long result = dfs(num + 1, mask, freq, memo);\\n        // do add num\\n        boolean addNum = true;\\n        int maskNext = mask;\\n        for (int i = 0; i < primes.length; i++) {\\n            if (num % primes[i] == 0) {\\n                if ((maskNext & (1 << i)) > 0) {\\n                    addNum = false;\\n                    break;\\n                } else {\\n                    maskNext |= (1 << i);\\n                }\\n            }            \\n        }\\n        if (addNum && freq[num] > 0) {\\n            result = (result + freq[num] * dfs(num + 1, maskNext, freq, memo) % MOD) % MOD;\\n        }\\n        memo[num][mask] = result;\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206041,
                "title": "python-fast-dfs",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        squares = {4, 8, 9, 12, 16, 18, 20, 24, 25, 27, 28}\\n        nums = [x for x in nums if x not in squares]\\n        c, nums = collections.Counter(nums), sorted(set(nums))\\n        \\n        @cache\\n        def getBit(x):\\n            primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\\n            return sum([1 << i for i, p in enumerate(primes) if x % p == 0])\\n        \\n        def dfs(u, cnt, mask):\\n            subRes = cnt\\n            for v in range(u + 1, len(nums)):\\n                if mask & getBit(nums[v]) == 0:\\n                    choice = (2 ** c[nums[v]] - 1) if nums[v] == 1 else c[nums[v]]\\n                    subRes += dfs(v, cnt * choice, mask | getBit(nums[v]))\\n            return subRes    \\n        return (dfs(-1, 1, 0) - 1) % (10 ** 9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        squares = {4, 8, 9, 12, 16, 18, 20, 24, 25, 27, 28}\\n        nums = [x for x in nums if x not in squares]\\n        c, nums = collections.Counter(nums), sorted(set(nums))\\n        \\n        @cache\\n        def getBit(x):\\n            primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\\n            return sum([1 << i for i, p in enumerate(primes) if x % p == 0])\\n        \\n        def dfs(u, cnt, mask):\\n            subRes = cnt\\n            for v in range(u + 1, len(nums)):\\n                if mask & getBit(nums[v]) == 0:\\n                    choice = (2 ** c[nums[v]] - 1) if nums[v] == 1 else c[nums[v]]\\n                    subRes += dfs(v, cnt * choice, mask | getBit(nums[v]))\\n            return subRes    \\n        return (dfs(-1, 1, 0) - 1) % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204398,
                "title": "beat-100-time-and-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nbitmap\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int primelist[10] = {2,3,5,7,11,13,17,19,23,29};\\n    int checkprime(int n){\\n        int ret = 0;\\n        for(int i = 0 ;  i < 10 ; i++){\\n            if(n%primelist[i] == 0){\\n                n/=primelist[i];\\n                ret |= 1<<i;\\n            }\\n            if(n%primelist[i] == 0) return -1;\\n        }\\n        return ret;\\n    }\\n    int squareFreeSubsets(vector<int>& nums) {\\n        int MOD = 1e9+7, cnt = 0;\\n        vector<int> bitmap(nums.size());\\n        for(auto &v:nums){\\n            auto ret = checkprime(v);\\n            if(ret != -1)   bitmap[cnt++] = ret;\\n        }\\n        int m[1024] = {0};\\n        int ans = 0;\\n        while(cnt > 0){\\n            cnt--;\\n            for(int k = 0 ; k < 1024 ; k++){     // add new digits after combination\\n                if(m[k] != 0 && (k&bitmap[cnt]) == 0){\\n                    m[(k|bitmap[cnt])] = (m[(k|bitmap[cnt])] + m[k])%MOD;\\n                }\\n            }\\n            m[bitmap[cnt]]++;\\n        }\\n        for(int i = 0 ; i < 1024 ; i++){\\n            ans = (ans + m[i])%MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int primelist[10] = {2,3,5,7,11,13,17,19,23,29};\\n    int checkprime(int n){\\n        int ret = 0;\\n        for(int i = 0 ;  i < 10 ; i++){\\n            if(n%primelist[i] == 0){\\n                n/=primelist[i];\\n                ret |= 1<<i;\\n            }\\n            if(n%primelist[i] == 0) return -1;\\n        }\\n        return ret;\\n    }\\n    int squareFreeSubsets(vector<int>& nums) {\\n        int MOD = 1e9+7, cnt = 0;\\n        vector<int> bitmap(nums.size());\\n        for(auto &v:nums){\\n            auto ret = checkprime(v);\\n            if(ret != -1)   bitmap[cnt++] = ret;\\n        }\\n        int m[1024] = {0};\\n        int ans = 0;\\n        while(cnt > 0){\\n            cnt--;\\n            for(int k = 0 ; k < 1024 ; k++){     // add new digits after combination\\n                if(m[k] != 0 && (k&bitmap[cnt]) == 0){\\n                    m[(k|bitmap[cnt])] = (m[(k|bitmap[cnt])] + m[k])%MOD;\\n                }\\n            }\\n            m[bitmap[cnt]]++;\\n        }\\n        for(int i = 0 ; i < 1024 ; i++){\\n            ans = (ans + m[i])%MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204351,
                "title": "java-bitmasking-recursion-easy-to-understand",
                "content": "# Intuition\\nI convert the problem into a dfs/recursion since the valid value range is less than 30, which also means that we can use bitmasking in int range. After tinkering with numbers I realized once you pick any number, then itself along with any number with same facotr cannot be picked, other than `1`. `1` is different since you can pick as many as you want and won\\'t change the subset property hence need to handle differently. So the high level becomes:\\n1. we want to go from 2 to 30 using dfs\\n2. a) if the number n is in nums, which we already know by counting the number of occurences, and number n is addable into the current subset we\\'re looking into, then we can add n and the total # subset is the current # of subset multiply # of n (since you can pick any **ONE** of n, not two, not less); b) you can also opt not to pick n which means the current # of subset remains the same. this is also true even when it\\'s unpickable.\\n3. we want to handle number 1 differently since we can pick as many as we want and it won\\'t change the property of subset. So say if 1 occurs 3 times, then the results are consists of 3 components, 1. only 1s, which is `[[1,_,_],[_,1,_],[_,_,1],[1,1,_],[1,_,1],[_,_,1],[1,1,1]]` = 7, 2. result from step 2 (all the combinations without 1) byitself, plus 3. result from step 2 multiply by number of combination of 1s (1 has to occur at least once). Now the number of combination of 1s, is 2 power of number of occurence of 1s, which also include 1 subset where there\\'s no 1s. \\n\\n# Explaination\\nLet me explain the definition of variables.\\n`count[]` is number of occurrences per each number in `nums`. e.g. if `nums = [3,4,4,5]` then `count = [0,0,0,1 (because 3 occurs 1 time), 2 (because 4 occurs 2 times), 1]`.\\n`totalUnpickable` is the bitmask of all the unpickable number at the current stage of dfs, denoted as `0 if pickable, 1 if not`. At the beginning numbers with square factor(s) within are be removed, hence the `| 4, | 8, etc`.\\n`secondOrderUnpickable[i]` is the bitmask of all the unpickable number once you pick `i` into the subset. So it contains the multiplication of all i and its factors. As you can see later since the traversal is strictly in the number ascending order there\\'s no need to consider any number less than `i`.\\n\\n\\n# Complexity\\n- Time complexity:\\nWorst case scenario is O(2^30), but I can prove this solution is optimal, since I prune all the immposible searches.\\n\\n- Space complexity:\\nO(constant)\\n\\n# Code\\n```\\nclass Solution {\\n    public int squareFreeSubsets(int[] nums) {\\n        int[] count = new int[31];\\n        int[] secondOrderUnpickable = new int[31];\\n        // init totalUnpickable by adding all numbers can\\'t be picked.\\n        int totalUnpickable = 0;\\n        totalUnpickable = totalUnpickable | 1 << 4;\\n        totalUnpickable = totalUnpickable | 1 << 8;\\n        totalUnpickable = totalUnpickable | 1 << 9;\\n        totalUnpickable = totalUnpickable | 1 << 12;\\n        totalUnpickable = totalUnpickable | 1 << 16;\\n        totalUnpickable = totalUnpickable | 1 << 18;\\n        totalUnpickable = totalUnpickable | 1 << 20;\\n        totalUnpickable = totalUnpickable | 1 << 24;\\n        totalUnpickable = totalUnpickable | 1 << 25;\\n        totalUnpickable = totalUnpickable | 1 << 27;\\n        totalUnpickable = totalUnpickable | 1 << 28;\\n\\n        // init secondOrderUnpickable\\n        for (int i = 2; i <= 30; i++) {\\n            int n = i;\\n\\n            // multiply by itself\\n            while (n <= 30) {\\n                secondOrderUnpickable[i] = secondOrderUnpickable[i] | 1 << n;\\n                n += i;\\n            }\\n            // if it\\'s unpickable by its factor then it\\'s unpickable by itself.\\n            for (int j = 2; j < i; j++) {\\n                if (i % j == 0) {\\n                    secondOrderUnpickable[i] = secondOrderUnpickable[i] | secondOrderUnpickable[j];\\n                }\\n            }\\n        }\\n        // retain a global result and use in dfs\\n        int[] finalRes = new int[1];\\n        finalRes[0] = 0;\\n        for (int num: nums) {\\n            count[num]++;\\n        }\\n        //\\n        dfs(finalRes, 2, secondOrderUnpickable, totalUnpickable, count, 0, false);\\n        int oneCombinationsCount = 1;\\n        int i = 0;\\n        // reason doing that is power of 2 can overflow and we\\n        // want to do mod 10^9+7 before overflow.\\n        while (i < count[1]) {\\n            oneCombinationsCount =  oneCombinationsCount << 1;\\n            oneCombinationsCount %= 1000000007;\\n            i++;\\n        }\\n        // minus 1 to exclude case where there\\'s no 1 picked. you can also handle this case differently.\\n        oneCombinationsCount--;\\n        // note every multiplication need to convert to long before \\n        // modulos to avoid overflow, and need to modulo after each operation.\\n        return ((int)((long)finalRes[0] * oneCombinationsCount % 1000000007) + finalRes[0] % 1000000007 + oneCombinationsCount % 1000000007) % 1000000007;\\n        \\n    }\\n    \\n    private void dfs(int[] finalRes, int step, int[] secondOrderUnpickable, int totalUnpickable, int[] combinationsCount, int res, boolean picked) {\\n        // update final res.\\n        if (step == 31 ) {\\n            finalRes[0] += res;\\n            finalRes[0] %= 1000000007;\\n            return;\\n        }\\n        // if not pickable (determined by bitmasking) or not occurred anyway, move on\\n        if (combinationsCount[step] == 0 || (((totalUnpickable >> step) & 1) == 1)) {\\n            dfs(finalRes, step + 1, secondOrderUnpickable, totalUnpickable, combinationsCount, res, picked);\\n            return;\\n        }\\n        // if pickable, and we still opt not to pick.\\n        dfs(finalRes, step + 1, secondOrderUnpickable, totalUnpickable, combinationsCount, res, picked);\\n\\n        // if pickable and there\\'s already number picked, we do a multiply of previous res.\\n        if (picked) {\\n            dfs(finalRes, step + 1, secondOrderUnpickable, totalUnpickable | secondOrderUnpickable[step], combinationsCount, (int)(((long)res * combinationsCount[step]) % 1000000007), true);\\n        // if pickable and there\\'s no number picked, we simply add occurences of that number into dfs\\n        } else {\\n            dfs(finalRes, step + 1, secondOrderUnpickable, totalUnpickable | secondOrderUnpickable[step], combinationsCount, combinationsCount[step] % 1000000007, true);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int squareFreeSubsets(int[] nums) {\\n        int[] count = new int[31];\\n        int[] secondOrderUnpickable = new int[31];\\n        // init totalUnpickable by adding all numbers can\\'t be picked.\\n        int totalUnpickable = 0;\\n        totalUnpickable = totalUnpickable | 1 << 4;\\n        totalUnpickable = totalUnpickable | 1 << 8;\\n        totalUnpickable = totalUnpickable | 1 << 9;\\n        totalUnpickable = totalUnpickable | 1 << 12;\\n        totalUnpickable = totalUnpickable | 1 << 16;\\n        totalUnpickable = totalUnpickable | 1 << 18;\\n        totalUnpickable = totalUnpickable | 1 << 20;\\n        totalUnpickable = totalUnpickable | 1 << 24;\\n        totalUnpickable = totalUnpickable | 1 << 25;\\n        totalUnpickable = totalUnpickable | 1 << 27;\\n        totalUnpickable = totalUnpickable | 1 << 28;\\n\\n        // init secondOrderUnpickable\\n        for (int i = 2; i <= 30; i++) {\\n            int n = i;\\n\\n            // multiply by itself\\n            while (n <= 30) {\\n                secondOrderUnpickable[i] = secondOrderUnpickable[i] | 1 << n;\\n                n += i;\\n            }\\n            // if it\\'s unpickable by its factor then it\\'s unpickable by itself.\\n            for (int j = 2; j < i; j++) {\\n                if (i % j == 0) {\\n                    secondOrderUnpickable[i] = secondOrderUnpickable[i] | secondOrderUnpickable[j];\\n                }\\n            }\\n        }\\n        // retain a global result and use in dfs\\n        int[] finalRes = new int[1];\\n        finalRes[0] = 0;\\n        for (int num: nums) {\\n            count[num]++;\\n        }\\n        //\\n        dfs(finalRes, 2, secondOrderUnpickable, totalUnpickable, count, 0, false);\\n        int oneCombinationsCount = 1;\\n        int i = 0;\\n        // reason doing that is power of 2 can overflow and we\\n        // want to do mod 10^9+7 before overflow.\\n        while (i < count[1]) {\\n            oneCombinationsCount =  oneCombinationsCount << 1;\\n            oneCombinationsCount %= 1000000007;\\n            i++;\\n        }\\n        // minus 1 to exclude case where there\\'s no 1 picked. you can also handle this case differently.\\n        oneCombinationsCount--;\\n        // note every multiplication need to convert to long before \\n        // modulos to avoid overflow, and need to modulo after each operation.\\n        return ((int)((long)finalRes[0] * oneCombinationsCount % 1000000007) + finalRes[0] % 1000000007 + oneCombinationsCount % 1000000007) % 1000000007;\\n        \\n    }\\n    \\n    private void dfs(int[] finalRes, int step, int[] secondOrderUnpickable, int totalUnpickable, int[] combinationsCount, int res, boolean picked) {\\n        // update final res.\\n        if (step == 31 ) {\\n            finalRes[0] += res;\\n            finalRes[0] %= 1000000007;\\n            return;\\n        }\\n        // if not pickable (determined by bitmasking) or not occurred anyway, move on\\n        if (combinationsCount[step] == 0 || (((totalUnpickable >> step) & 1) == 1)) {\\n            dfs(finalRes, step + 1, secondOrderUnpickable, totalUnpickable, combinationsCount, res, picked);\\n            return;\\n        }\\n        // if pickable, and we still opt not to pick.\\n        dfs(finalRes, step + 1, secondOrderUnpickable, totalUnpickable, combinationsCount, res, picked);\\n\\n        // if pickable and there\\'s already number picked, we do a multiply of previous res.\\n        if (picked) {\\n            dfs(finalRes, step + 1, secondOrderUnpickable, totalUnpickable | secondOrderUnpickable[step], combinationsCount, (int)(((long)res * combinationsCount[step]) % 1000000007), true);\\n        // if pickable and there\\'s no number picked, we simply add occurences of that number into dfs\\n        } else {\\n            dfs(finalRes, step + 1, secondOrderUnpickable, totalUnpickable | secondOrderUnpickable[step], combinationsCount, combinationsCount[step] % 1000000007, true);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204125,
                "title": "java-4ms-backtracking-solution",
                "content": "# Intuition\\nCheck the prime factors of each number. Because the number range is `[1,30]`, this is trivial. And then perform a backtracking to calculate the number of sebsets (pretty standard). \\n\\nThe tricky part is number `1`. `1` can co-exist with other `1`s in the subset, which doesn\\'t apply to other numbers (like there can\\'t be multiple `2`s in the subset).\\n\\n\\n# Complexity\\n- Time complexity: `O(n)` \\n\\n# Code\\n```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n\\n    /*\\n    Runtime 3 ms Beats 100%\\n    Memory 41.5 MB Beats 100%\\n     */\\n    private final int MOD = (int) (1e9 + 7);\\n    private final List<Integer> PRIMES = List.of(2, 3, 5, 7, 11, 13);\\n\\n    public int squareFreeSubsets(int[] nums) {\\n        int[] primeFactors = new int[31];\\n\\n        for (int i = 2; i <= 30; i++) {\\n            if (i % 4 == 0 || i % 9 == 0 || i % 25 == 0) {\\n                continue;\\n            }\\n\\n            for (int j = 0; j < PRIMES.size(); j++) {\\n                if (i % PRIMES.get(j) == 0) {\\n                    primeFactors[i] += 1 << j;\\n                }\\n            }\\n        }\\n\\n        int[] freqs = new int[31];\\n        for (int num : nums) {\\n            if (num % 4 == 0 || num % 9 == 0 || num % 25 == 0) {\\n                continue;\\n            }\\n            freqs[num]++;\\n        }\\n\\n        int mask = 0;\\n        int[][] cache = new int[31][1<<6];\\n        for (int[] row : cache) {\\n            Arrays.fill(row, -1);\\n        }\\n\\n        long oneSubsets = BigInteger.TWO.modPow(BigInteger.valueOf(freqs[1]), BigInteger.valueOf(MOD)).longValue();\\n        int otherSubsets = (int) (squareFreeSubsets(freqs, primeFactors, 2, mask, cache) % MOD);\\n\\n        return (int) (otherSubsets * oneSubsets % MOD + oneSubsets - 1) % MOD;\\n    }\\n\\n    private long squareFreeSubsets(int[] freqs, int[] primeFactors, int num, int mask, int[][] cache) {\\n        if (num == 30) {\\n            if ((primeFactors[num] & mask) != 0) {\\n                return 0;\\n            }\\n            return freqs[num];\\n        }\\n\\n        if (cache[num][mask] != -1) {\\n            return cache[num][mask];\\n        }\\n\\n        long countWithout = squareFreeSubsets(freqs, primeFactors, num + 1, mask, cache) % MOD;\\n\\n        if (freqs[num] == 0 || (primeFactors[num] & mask) != 0) {\\n            cache[num][mask] = (int) countWithout;\\n            return countWithout;\\n        }\\n\\n        long countWith = freqs[num] + freqs[num] * squareFreeSubsets(freqs, primeFactors, num + 1, primeFactors[num] | mask, cache) % MOD;\\n        countWith %= MOD;\\n\\n        cache[num][mask] = (int) ((countWithout + countWith) % MOD);\\n        return (countWithout + countWith) % MOD;\\n    }\\n}\\n```\\n\\n\\n1D DP implementation (idea is the same):\\n\\n```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n\\n    private static final int MOD = (int) (1e9 + 7);\\n    private static final List<Integer> PRIMES = List.of(2, 3, 5, 7, 11, 13);\\n\\n    public int squareFreeSubsets(int[] nums) {\\n        int[] primeFactors = new int[31];\\n        for (int i = 2; i <= 30; i++) {\\n            if (i % 4 == 0 || i % 9 == 0 || i % 25 == 0) {\\n                continue;\\n            }\\n\\n            for (int j = 0; j < PRIMES.size(); j++) {\\n                if (i % PRIMES.get(j) == 0) {\\n                    primeFactors[i] += 1 << j;\\n                }\\n            }\\n        }\\n\\n        int[] freqs = new int[31];\\n        for (int num : nums) {\\n            if (num % 4 == 0 || num % 9 == 0 || num % 25 == 0) {\\n                continue;\\n            }\\n            freqs[num]++;\\n        }\\n\\n        long[] dp = new long[1 << 6];\\n        dp[primeFactors[30]] = freqs[30] % MOD;\\n        for (int i = 29; i >= 2; i--) {\\n            if (freqs[i] == 0) {\\n                continue;\\n            }\\n\\n            long[] temp = dp.clone();\\n\\n            temp[primeFactors[i]] += freqs[i];\\n            temp[primeFactors[i]] %= MOD;\\n            for (int mask = 0; mask < dp.length; mask++) {\\n                if (dp[mask] != 0 && (mask & primeFactors[i]) == 0) {\\n                    temp[mask | primeFactors[i]] += freqs[i] * dp[mask];\\n                    temp[mask | primeFactors[i]] %= MOD;\\n                }\\n            }\\n\\n            dp = temp;\\n        }\\n\\n        long oneSubsets = BigInteger.TWO.modPow(BigInteger.valueOf(freqs[1]), BigInteger.valueOf(MOD)).longValue();\\n        long otherSubsets = Arrays.stream(dp).sum() % MOD;\\n\\n        return (int) (otherSubsets * oneSubsets % MOD + oneSubsets - 1) % MOD;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n\\n    /*\\n    Runtime 3 ms Beats 100%\\n    Memory 41.5 MB Beats 100%\\n     */\\n    private final int MOD = (int) (1e9 + 7);\\n    private final List<Integer> PRIMES = List.of(2, 3, 5, 7, 11, 13);\\n\\n    public int squareFreeSubsets(int[] nums) {\\n        int[] primeFactors = new int[31];\\n\\n        for (int i = 2; i <= 30; i++) {\\n            if (i % 4 == 0 || i % 9 == 0 || i % 25 == 0) {\\n                continue;\\n            }\\n\\n            for (int j = 0; j < PRIMES.size(); j++) {\\n                if (i % PRIMES.get(j) == 0) {\\n                    primeFactors[i] += 1 << j;\\n                }\\n            }\\n        }\\n\\n        int[] freqs = new int[31];\\n        for (int num : nums) {\\n            if (num % 4 == 0 || num % 9 == 0 || num % 25 == 0) {\\n                continue;\\n            }\\n            freqs[num]++;\\n        }\\n\\n        int mask = 0;\\n        int[][] cache = new int[31][1<<6];\\n        for (int[] row : cache) {\\n            Arrays.fill(row, -1);\\n        }\\n\\n        long oneSubsets = BigInteger.TWO.modPow(BigInteger.valueOf(freqs[1]), BigInteger.valueOf(MOD)).longValue();\\n        int otherSubsets = (int) (squareFreeSubsets(freqs, primeFactors, 2, mask, cache) % MOD);\\n\\n        return (int) (otherSubsets * oneSubsets % MOD + oneSubsets - 1) % MOD;\\n    }\\n\\n    private long squareFreeSubsets(int[] freqs, int[] primeFactors, int num, int mask, int[][] cache) {\\n        if (num == 30) {\\n            if ((primeFactors[num] & mask) != 0) {\\n                return 0;\\n            }\\n            return freqs[num];\\n        }\\n\\n        if (cache[num][mask] != -1) {\\n            return cache[num][mask];\\n        }\\n\\n        long countWithout = squareFreeSubsets(freqs, primeFactors, num + 1, mask, cache) % MOD;\\n\\n        if (freqs[num] == 0 || (primeFactors[num] & mask) != 0) {\\n            cache[num][mask] = (int) countWithout;\\n            return countWithout;\\n        }\\n\\n        long countWith = freqs[num] + freqs[num] * squareFreeSubsets(freqs, primeFactors, num + 1, primeFactors[num] | mask, cache) % MOD;\\n        countWith %= MOD;\\n\\n        cache[num][mask] = (int) ((countWithout + countWith) % MOD);\\n        return (countWithout + countWith) % MOD;\\n    }\\n}\\n```\n```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n\\n    private static final int MOD = (int) (1e9 + 7);\\n    private static final List<Integer> PRIMES = List.of(2, 3, 5, 7, 11, 13);\\n\\n    public int squareFreeSubsets(int[] nums) {\\n        int[] primeFactors = new int[31];\\n        for (int i = 2; i <= 30; i++) {\\n            if (i % 4 == 0 || i % 9 == 0 || i % 25 == 0) {\\n                continue;\\n            }\\n\\n            for (int j = 0; j < PRIMES.size(); j++) {\\n                if (i % PRIMES.get(j) == 0) {\\n                    primeFactors[i] += 1 << j;\\n                }\\n            }\\n        }\\n\\n        int[] freqs = new int[31];\\n        for (int num : nums) {\\n            if (num % 4 == 0 || num % 9 == 0 || num % 25 == 0) {\\n                continue;\\n            }\\n            freqs[num]++;\\n        }\\n\\n        long[] dp = new long[1 << 6];\\n        dp[primeFactors[30]] = freqs[30] % MOD;\\n        for (int i = 29; i >= 2; i--) {\\n            if (freqs[i] == 0) {\\n                continue;\\n            }\\n\\n            long[] temp = dp.clone();\\n\\n            temp[primeFactors[i]] += freqs[i];\\n            temp[primeFactors[i]] %= MOD;\\n            for (int mask = 0; mask < dp.length; mask++) {\\n                if (dp[mask] != 0 && (mask & primeFactors[i]) == 0) {\\n                    temp[mask | primeFactors[i]] += freqs[i] * dp[mask];\\n                    temp[mask | primeFactors[i]] %= MOD;\\n                }\\n            }\\n\\n            dp = temp;\\n        }\\n\\n        long oneSubsets = BigInteger.TWO.modPow(BigInteger.valueOf(freqs[1]), BigInteger.valueOf(MOD)).longValue();\\n        long otherSubsets = Arrays.stream(dp).sum() % MOD;\\n\\n        return (int) (otherSubsets * oneSubsets % MOD + oneSubsets - 1) % MOD;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653983,
                "title": "c-code-different-intuition-subset-generation-using-bitmasking-in-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOn first glance, I noticed that the integers in the nums array that are already divisible by perfect squares are already filtered out. And in any subset we take we cannot take same element twice since then of course the product would be divisible by a square.\\nBut at the same time we can take \\'1\\' multiple times as well since the questions says \"squares other than 1\".\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we create a map with the frequency of only those integers which are valid in the first i.e. are not divisible by a square.\\n\\nThen we create a vector of pair such that one value contains the integer and the other one contains it\\'s frequency but we do not include the integer 1 in this.\\n\\nAfterwards we have to observe that since one integer cannot be used twice in a subset to avoid the divisibility by a square problem we just need to make subsets of those distinct integers while multiplying their individual frequencies.\\n\\nWe account for the integer 1 differently because it can occur multiple times in a subset. For now just store it in a variable ones\\nand we\\'ll handle it later.\\n\\nNow consider,\\n> if nums = [2,2,2,3,3,5]\\n\\nwe find that the temp array with value and frequency becomes\\n> temp = [{2,3},{3,2},{5,1}]\\n\\nand our distinct subsets can be\\n> [{2},{3},{5},{2,3},{2,5},{3,5}]\\n\\nand the number of such subsets will be\\n- for {2}, n = freq(2)\\n- for {3}, n = freq(3)\\n- for {5}, n = freq(5)\\n- for {2,3}, n = freq(2) * freq(3)\\nand so on\\n\\nhence what we can do is we can use bitmasking to generate all the relevant distinct subsets from **temp.first** and **keep multiplying the frequency** of all the elements used in that subset. Simulataneously we keep another integer current number, in which we keep **multiplying the integers used** in that subset to check whether the subset is valid or not by passing through the check function.\\nfor example:\\n- [2,3,5,6] is not valid since it is divisble by 4 and 9\\n\\nso we we eliminate such subsets by using current number variable (**cnum**)\\n\\nNow that we have all the possible valid subsets we account for the 1s here.\\nWe find that for all the subsets we just found, we can use any number of 1s with it\\nfor example if we have number of ones = 2\\nwe can have for subset {2,3}, subsets as\\n- {2,3},{1,2,3},{1,2,3},{1,1,2,3};\\n(here subset 1 and 2 use different 1s)\\n\\nor we can say our answer become\\n> (nC0 + nC1 + nC2 +.....+nCn) * ans = 2^n * ans\\n\\nfurthermore it is also possible to have only 1s in a subset\\ne.g, \\n- {1}, {1}, {1,1}\\n\\nfor this the number will be = nC1 + nC2 + nC3 + .... + nCn = 2^n - 1\\n\\nHence the final answer becomes\\n\\nans = (2^n * ans) + (2 ^ n - 1);\\n\\nAll other required things have been explained in the code!\\n\\n\\n# Complexity\\n- Time complexity: O(k * 2^k) == O(2^k)\\nwhere k is the number of distinct integers, k <= 30\\n(here in the worst case it will be O(30 * 2 ^ 30))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n    only an array and a map of constant space have been used.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(long long n){\\n        //checking until 169 because that\\'s the highest square\\n        //factor of a prime number that can be achieved\\n        //by multiplying two valid number between 1 & 30\\n        for(long long i = 2; i * i <= 169; i++)\\n            if(n % (i * i) == 0) return false;;\\n        return true;\\n    }\\n\\n    //for modular exponentiation\\n    long long powerMod(long long base, long long exponent, long long modulus) {\\n        long long result = 1;\\n        base %= modulus;\\n        \\n        while (exponent > 0) {\\n            if (exponent & 1) {\\n                result = (result * base) % modulus;\\n            }\\n            base = (base * base) % modulus;\\n            exponent >>= 1;\\n        }\\n        \\n        return result;\\n    }\\n\\n    int squareFreeSubsets(vector<int>& nums) {\\n        //can\\'t take a number twice in any subset\\n        //can\\'t take a squared number\\n        //taken number must not be divisible by a square\\n\\n        int M = 1e9 + 7;\\n        unordered_map<int, int> mp;\\n        \\n        for(int i = 0; i < nums.size(); i++)\\n            if(check(nums[i])) mp[nums[i]]++; \\n        //adding only those elements to map which are not \\n        //already divisible by a square\\n\\n        vector<pair<int, int>> temp;\\n        \\n        for(auto it:mp){\\n            if(it.first != 1)\\n                temp.push_back({it.first, it.second});\\n            //adding elements to temp array with their value and \\n            //their frequency\\n        }\\n\\n        int ones = mp[1], n = temp.size();\\n        //here ones stores the frequency of 1\\'s on the \\n        //it is being considered differently since we can take\\n        //any number of ones in a subset\\n\\n        long long ans = 0;\\n        mp.clear();\\n\\n        for(int i = 1; i <= (1 << n) - 1; i++){\\n            //cnt keeps current count of subsets\\n            //cnum keeps product of current subset\\n            //cnum will help us to determine where the\\n            //subset is viable or not            \\n            long long cnt = 0, cnum = 1;\\n            //after that we use bitmasking to generate\\n            //all possible subsets and find the number of those\\n            //subsets since the same integer can be repeated\\n            for(int j = 0; j < n; j++){\\n                if((i & (1 << j)) != 0){\\n                    if(cnt == 0) cnt = 1;\\n                    cnt *= temp[j].second;\\n                    cnt %= M;\\n                    cnum *= temp[j].first;\\n                    if(cnum > LONG_MAX / 30 && !check(cnum)){\\n                        //To avoid overflow additional check \\n                        //has been placed\\n                        cnt = 0;\\n                        break;\\n                    }\\n                }\\n            }\\n            //to check if product of current subset is valid\\n            if(check(cnum))\\n            ans = (ans + cnt) % M;\\n        }\\n        //power stores the combinations of 1\\'s\\n        //taking 0 \\'1\\', taking 1 \\'1\\', taking 2 \\'1\\'..... i.e.,\\n        //nC0 + nC1 + nC2......+ nCn = 2^n\\n        //here n = number of 1s = ones\\n        int power = powerMod(2,ones,M);\\n        //for all these combination of ones\\n        //we can multiply with eariler number of subsets \\n        //without using 1s to get total number of subests\\n        ans *= power;\\n        //after that we add those subsets which have only 1s\\n        //similar to above while computing power\\n        //but here we don\\'t need nC0 i.e. 0 \\'1\\' so\\n        //nC1 + nC2 + nC3 .... + nCn = 2^n - nC0 = 2^n - 1;\\n        //2^n is already computed\\n        ans += power - 1;\\n        \\n        ans %= M;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(long long n){\\n        //checking until 169 because that\\'s the highest square\\n        //factor of a prime number that can be achieved\\n        //by multiplying two valid number between 1 & 30\\n        for(long long i = 2; i * i <= 169; i++)\\n            if(n % (i * i) == 0) return false;;\\n        return true;\\n    }\\n\\n    //for modular exponentiation\\n    long long powerMod(long long base, long long exponent, long long modulus) {\\n        long long result = 1;\\n        base %= modulus;\\n        \\n        while (exponent > 0) {\\n            if (exponent & 1) {\\n                result = (result * base) % modulus;\\n            }\\n            base = (base * base) % modulus;\\n            exponent >>= 1;\\n        }\\n        \\n        return result;\\n    }\\n\\n    int squareFreeSubsets(vector<int>& nums) {\\n        //can\\'t take a number twice in any subset\\n        //can\\'t take a squared number\\n        //taken number must not be divisible by a square\\n\\n        int M = 1e9 + 7;\\n        unordered_map<int, int> mp;\\n        \\n        for(int i = 0; i < nums.size(); i++)\\n            if(check(nums[i])) mp[nums[i]]++; \\n        //adding only those elements to map which are not \\n        //already divisible by a square\\n\\n        vector<pair<int, int>> temp;\\n        \\n        for(auto it:mp){\\n            if(it.first != 1)\\n                temp.push_back({it.first, it.second});\\n            //adding elements to temp array with their value and \\n            //their frequency\\n        }\\n\\n        int ones = mp[1], n = temp.size();\\n        //here ones stores the frequency of 1\\'s on the \\n        //it is being considered differently since we can take\\n        //any number of ones in a subset\\n\\n        long long ans = 0;\\n        mp.clear();\\n\\n        for(int i = 1; i <= (1 << n) - 1; i++){\\n            //cnt keeps current count of subsets\\n            //cnum keeps product of current subset\\n            //cnum will help us to determine where the\\n            //subset is viable or not            \\n            long long cnt = 0, cnum = 1;\\n            //after that we use bitmasking to generate\\n            //all possible subsets and find the number of those\\n            //subsets since the same integer can be repeated\\n            for(int j = 0; j < n; j++){\\n                if((i & (1 << j)) != 0){\\n                    if(cnt == 0) cnt = 1;\\n                    cnt *= temp[j].second;\\n                    cnt %= M;\\n                    cnum *= temp[j].first;\\n                    if(cnum > LONG_MAX / 30 && !check(cnum)){\\n                        //To avoid overflow additional check \\n                        //has been placed\\n                        cnt = 0;\\n                        break;\\n                    }\\n                }\\n            }\\n            //to check if product of current subset is valid\\n            if(check(cnum))\\n            ans = (ans + cnt) % M;\\n        }\\n        //power stores the combinations of 1\\'s\\n        //taking 0 \\'1\\', taking 1 \\'1\\', taking 2 \\'1\\'..... i.e.,\\n        //nC0 + nC1 + nC2......+ nCn = 2^n\\n        //here n = number of 1s = ones\\n        int power = powerMod(2,ones,M);\\n        //for all these combination of ones\\n        //we can multiply with eariler number of subsets \\n        //without using 1s to get total number of subests\\n        ans *= power;\\n        //after that we add those subsets which have only 1s\\n        //similar to above while computing power\\n        //but here we don\\'t need nC0 i.e. 0 \\'1\\' so\\n        //nC1 + nC2 + nC3 .... + nCn = 2^n - nC0 = 2^n - 1;\\n        //2^n is already computed\\n        ans += power - 1;\\n        \\n        ans %= M;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210914,
                "title": "small-clear-and-easily-understandable",
                "content": "```\\nclass Solution {\\n    long output = 0L;\\n    long primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};int mod = 1000000007;\\n    public int squareFreeSubsets(int[] nums) {\\n        HashMap<Integer,Integer> data = new HashMap<>();int count = 0;\\n        for(int i:nums) if(i!=1) data.put(i,data.getOrDefault(i,0)+1); else count++;\\n        int num[] = new int[data.size()],index=0;\\n        for(int i:data.keySet()) num[index++] = i;\\n        long op = (pow(2L,count,mod)+mod)%mod;\\n        return (int)(((find(data,num,0,1L)-1L)*op+op-1)%mod);\\n    }\\n    public long find(HashMap<Integer,Integer> data,int num[],int n,long val){\\n        if(n>=num.length) return 1L;\\n        long ret = 0L+find(data,num,n+1,val);\\n        if(check(val,1L*num[n])) ret=(ret+data.get(num[n])*find(data,num,n+1,val*num[n]))%mod;\\n        return ret;\\n    }\\n    public boolean check(long val,long num){\\n        for(long i:primes) if(num%(i*i)==0||val%i==0&&num%i==0) return false;\\n        return true;\\n    }\\n    public long pow(long x, int n, int M) {\\n        if(n==0) return 1L;\\n        else if(n%2 == 0) return pow((x*x) % M, n/2, M);\\n        else  return (x*pow((x*x) % M, (n-1)/2, M)) % M;\\n    }\\n}\\n```\\nnearlly same question 1994 and just one word change answer in \\nhttps://leetcode.com/problems/the-number-of-good-subsets/discuss/3210782/small-and-easily-understandable\\nhave a nice day",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    long output = 0L;\\n    long primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};int mod = 1000000007;\\n    public int squareFreeSubsets(int[] nums) {\\n        HashMap<Integer,Integer> data = new HashMap<>();int count = 0;\\n        for(int i:nums) if(i!=1) data.put(i,data.getOrDefault(i,0)+1); else count++;\\n        int num[] = new int[data.size()],index=0;\\n        for(int i:data.keySet()) num[index++] = i;\\n        long op = (pow(2L,count,mod)+mod)%mod;\\n        return (int)(((find(data,num,0,1L)-1L)*op+op-1)%mod);\\n    }\\n    public long find(HashMap<Integer,Integer> data,int num[],int n,long val){\\n        if(n>=num.length) return 1L;\\n        long ret = 0L+find(data,num,n+1,val);\\n        if(check(val,1L*num[n])) ret=(ret+data.get(num[n])*find(data,num,n+1,val*num[n]))%mod;\\n        return ret;\\n    }\\n    public boolean check(long val,long num){\\n        for(long i:primes) if(num%(i*i)==0||val%i==0&&num%i==0) return false;\\n        return true;\\n    }\\n    public long pow(long x, int n, int M) {\\n        if(n==0) return 1L;\\n        else if(n%2 == 0) return pow((x*x) % M, n/2, M);\\n        else  return (x*pow((x*x) % M, (n-1)/2, M)) % M;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208275,
                "title": "golang-step-by-step-explain",
                "content": "\\n# Code\\n```\\npackage main\\n\\nimport (\\n\\t\"fmt\"\\n\\t\"math\"\\n)\\n\\n// Ref: https://leetcode.com/problems/count-the-number-of-square-free-subsets/solutions/3206717/bitmask-very-detailed-explaination-titans-plz-skip-code-java/\\n// Ref: https://leetcode.com/problems/count-the-number-of-square-free-subsets/solutions/3204685/python-bitmask-dp-bottom-up-solution/\\n\\nfunc squareFreeSubsets(nums []int) int {\\n\\t// result should be returned after applying below mod\\n\\tMOD := int(math.Pow(10, 9) + 7)\\n\\t// 10 primes, each prime can be used at most once in any\\n\\t// number, because in a product of these nums all primes\\n\\t// should occur only once to maintain product sq-free\\n\\n\\t// these 10 primes can produce 2*10 combinations\\n\\t// (keep or leave a prime is a product) thus 2*10 products\\n\\t// are possible\\n\\t// in dp we keep track of which all products are achievable\\n\\t// with the subset of nums\\n\\tdp := make([]int, 1<<10)\\n\\tdp[0] = 1 // product 0 is always achievable\\n\\n\\tfor _, num := range nums {\\n\\t\\tmask := getMask(num)\\n\\t\\tif mask < 0 {\\n\\t\\t\\t// this number already have a square and can\\'t be\\n\\t\\t\\t// used in product subset\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\t// iterate over all possible products possible\\n\\t\\t// check if the current mask (number) when multiplied\\n\\t\\t// with some existing product, produce a new product\\n\\t\\t// which is sq-free, if so then inc the count of new\\n\\t\\t// product\\n\\t\\tfor prevProduct := 0; prevProduct < (1 << 10); prevProduct++ {\\n\\t\\t\\t// product of this number and existing product\\n\\t\\t\\t// do not have common prime - sq free\\n\\t\\t\\t// 15 * 7 = 105 = 3*5*7\\n\\t\\t\\t// (15) 0110 & (7) 1000 = 0000\\n\\t\\t\\tif (mask & prevProduct) == 0 {\\n\\t\\t\\t\\t// 15 * 7 = 105 = 3*5*7\\n\\t\\t\\t\\t// (15) 0110 | (7) 1000 = 1110 = 7*5*3 = 105\\n\\t\\t\\t\\tnewProduct := mask | prevProduct\\n\\t\\t\\t\\t// if there are n prevProduct achievable\\n\\t\\t\\t\\t// then with this new number (mask) there are\\n\\t\\t\\t\\t// n newProduct become achievable (that to sq-free)\\n\\t\\t\\t\\tdp[newProduct] += (dp[prevProduct] % MOD)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// take sum of all dp array values and return\\n\\t// sub 1 because we don\\'t count the product 0\\n\\t// rest all places in dp with value x\\n\\t// represent the product is reachable in x subsets\\n\\tsum := 0\\n\\tfor _, value := range dp {\\n\\t\\tsum += value\\n\\t}\\n\\treturn (sum - 1) % MOD\\n}\\n\\nfunc getMask(num int) int {\\n\\t// since there are 10 primes, 10 bits in mask represent\\n\\t// which all primes the number is composed of.\\n\\n\\t// due to nums[i] < 30 limit there are only 10 primes\\n\\t// under this range - each number can be represented as\\n\\t// factor of primes - 20 = 2*3*5\\n\\tprimes := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29}\\n\\tmask := 0\\n\\tfor i, prime := range primes {\\n\\t\\t// if the square of prime is present in this number\\n\\t\\t// then it can\\'t be part of any product subset\\n\\t\\t// else that product will be divisible by sq of that prime\\n\\t\\tif num%(prime*prime) == 0 {\\n\\t\\t\\tmask = -1\\n\\t\\t\\tbreak\\n\\t\\t} else if num%prime == 0 {\\n\\t\\t\\t// set the bit corresponding to the prime index\\n\\t\\t\\tmask = mask | (1 << i)\\n\\t\\t}\\n\\t}\\n\\t// 6 = 2*3  = bin 0011 (mask) = 3\\n\\t// 15 = 3*5 = bin 0110 (mask) = 6\\n\\t// 14 = 2*7 = bin 1001 (mask) = 9\\n\\treturn mask\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\nimport (\\n\\t\"fmt\"\\n\\t\"math\"\\n)\\n\\n// Ref: https://leetcode.com/problems/count-the-number-of-square-free-subsets/solutions/3206717/bitmask-very-detailed-explaination-titans-plz-skip-code-java/\\n// Ref: https://leetcode.com/problems/count-the-number-of-square-free-subsets/solutions/3204685/python-bitmask-dp-bottom-up-solution/\\n\\nfunc squareFreeSubsets(nums []int) int {\\n\\t// result should be returned after applying below mod\\n\\tMOD := int(math.Pow(10, 9) + 7)\\n\\t// 10 primes, each prime can be used at most once in any\\n\\t// number, because in a product of these nums all primes\\n\\t// should occur only once to maintain product sq-free\\n\\n\\t// these 10 primes can produce 2*10 combinations\\n\\t// (keep or leave a prime is a product) thus 2*10 products\\n\\t// are possible\\n\\t// in dp we keep track of which all products are achievable\\n\\t// with the subset of nums\\n\\tdp := make([]int, 1<<10)\\n\\tdp[0] = 1 // product 0 is always achievable\\n\\n\\tfor _, num := range nums {\\n\\t\\tmask := getMask(num)\\n\\t\\tif mask < 0 {\\n\\t\\t\\t// this number already have a square and can\\'t be\\n\\t\\t\\t// used in product subset\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\t// iterate over all possible products possible\\n\\t\\t// check if the current mask (number) when multiplied\\n\\t\\t// with some existing product, produce a new product\\n\\t\\t// which is sq-free, if so then inc the count of new\\n\\t\\t// product\\n\\t\\tfor prevProduct := 0; prevProduct < (1 << 10); prevProduct++ {\\n\\t\\t\\t// product of this number and existing product\\n\\t\\t\\t// do not have common prime - sq free\\n\\t\\t\\t// 15 * 7 = 105 = 3*5*7\\n\\t\\t\\t// (15) 0110 & (7) 1000 = 0000\\n\\t\\t\\tif (mask & prevProduct) == 0 {\\n\\t\\t\\t\\t// 15 * 7 = 105 = 3*5*7\\n\\t\\t\\t\\t// (15) 0110 | (7) 1000 = 1110 = 7*5*3 = 105\\n\\t\\t\\t\\tnewProduct := mask | prevProduct\\n\\t\\t\\t\\t// if there are n prevProduct achievable\\n\\t\\t\\t\\t// then with this new number (mask) there are\\n\\t\\t\\t\\t// n newProduct become achievable (that to sq-free)\\n\\t\\t\\t\\tdp[newProduct] += (dp[prevProduct] % MOD)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// take sum of all dp array values and return\\n\\t// sub 1 because we don\\'t count the product 0\\n\\t// rest all places in dp with value x\\n\\t// represent the product is reachable in x subsets\\n\\tsum := 0\\n\\tfor _, value := range dp {\\n\\t\\tsum += value\\n\\t}\\n\\treturn (sum - 1) % MOD\\n}\\n\\nfunc getMask(num int) int {\\n\\t// since there are 10 primes, 10 bits in mask represent\\n\\t// which all primes the number is composed of.\\n\\n\\t// due to nums[i] < 30 limit there are only 10 primes\\n\\t// under this range - each number can be represented as\\n\\t// factor of primes - 20 = 2*3*5\\n\\tprimes := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29}\\n\\tmask := 0\\n\\tfor i, prime := range primes {\\n\\t\\t// if the square of prime is present in this number\\n\\t\\t// then it can\\'t be part of any product subset\\n\\t\\t// else that product will be divisible by sq of that prime\\n\\t\\tif num%(prime*prime) == 0 {\\n\\t\\t\\tmask = -1\\n\\t\\t\\tbreak\\n\\t\\t} else if num%prime == 0 {\\n\\t\\t\\t// set the bit corresponding to the prime index\\n\\t\\t\\tmask = mask | (1 << i)\\n\\t\\t}\\n\\t}\\n\\t// 6 = 2*3  = bin 0011 (mask) = 3\\n\\t// 15 = 3*5 = bin 0110 (mask) = 6\\n\\t// 14 = 2*7 = bin 1001 (mask) = 9\\n\\treturn mask\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3207723,
                "title": "frequency-map-optimization-kotlin-100-o-n-2-8",
                "content": "We break the numbers `[1,30]` into the following categories:\\n\\n* `BAD_NUMBERS`: `4, 8, 9, 12, 16, 18, 20, 24, 25, 27, 28`   (11 numbers)\\n* `NON_PRIMES`: `6, 10, 14, 15, 21, 22, 26, 30` (8 numbers)\\n* `PRIMES`: `2, 3, 5, 7, 11, 13, 17, 19, 23, 29`    (10 numbers)\\n* `ONE`: `1` (1 number)\\n\\nThen, we can process in this order:\\n1. Get frequency map of the original array\\n2. Find the possiblity of all permutations of `NON_PRIMES` product that are square free,\\n3. For each of the product, times one of each `PRIMES`, this gives us another map of permutations\\n4. Sum up the permutations\\n5. Each permutation (and empty) can use any combinations of the products of `1`s\\n6. Derive the final answer\\n\\nCan my Lambda be improved? Please leave me a note.\\n\\n```kotlin\\nclass Solution {\\n  val PRIMES = intArrayOf(2, 3, 5, 7, 11, 13, 17, 19, 23, 29)\\n  val BAD_NUMS = (1..30).filter { PRIMES.any { p -> it % (p * p) == 0 } }.toSet()\\n  val NON_PRIMES = (2..30).filter { it !in PRIMES }.filter { it !in BAD_NUMS }.toList()\\n\\n  private fun gcd(a: Int, b: Int): Int {\\n    if (b == 0) return a else return gcd(b, a % b)\\n  }\\n\\n  fun squareFreeSubsets(nums: IntArray): Int {\\n    val MOD : Long = 1_000_000_007\\n\\n    // Get the frequency map\\n    val freqMap = nums.toTypedArray().groupingBy{it}.eachCount()\\n\\n    var dp = mutableMapOf<Int, Long>()\\n    for (v in NON_PRIMES) {\\n      if (v !in freqMap) continue\\n      val howmany = freqMap[v]!!\\n\\n      val prev = HashMap(dp)\\n      dp[v] = (dp[v] ?: 0) + howmany\\n      for ((product, quantity) in prev)\\n        if (gcd(product, v) == 1)\\n          dp[product * v] = ((dp[product * v] ?: 0L) + quantity * howmany.toLong()) % MOD\\n    }\\n    for (v in PRIMES) {\\n      if (v !in freqMap) continue\\n      val howmany = freqMap[v]!!.toLong()\\n      val prev = dp\\n      dp = mutableMapOf<Int, Long>()\\n      dp[v] = howmany\\n      for ((product, quantity) in prev)\\n        dp[product] = if (product % v != 0) quantity * (1 + howmany) else quantity\\n    }\\n\\t// Getting all possible subsets without `1`\\n    var res = dp.values.sum() % MOD\\n\\t\\n\\t// Find the permutations of `1`\\n    val possible = (1..(freqMap[1] ?: 0)).fold(1L) {sum, _ -> (sum shl 1) % MOD}\\n    res = (res * possible + possible + MOD - 1) % MOD\\n    return res.toInt()\\n  }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Dynamic Programming",
                    "Enumeration"
                ],
                "code": "```kotlin\\nclass Solution {\\n  val PRIMES = intArrayOf(2, 3, 5, 7, 11, 13, 17, 19, 23, 29)\\n  val BAD_NUMS = (1..30).filter { PRIMES.any { p -> it % (p * p) == 0 } }.toSet()\\n  val NON_PRIMES = (2..30).filter { it !in PRIMES }.filter { it !in BAD_NUMS }.toList()\\n\\n  private fun gcd(a: Int, b: Int): Int {\\n    if (b == 0) return a else return gcd(b, a % b)\\n  }\\n\\n  fun squareFreeSubsets(nums: IntArray): Int {\\n    val MOD : Long = 1_000_000_007\\n\\n    // Get the frequency map\\n    val freqMap = nums.toTypedArray().groupingBy{it}.eachCount()\\n\\n    var dp = mutableMapOf<Int, Long>()\\n    for (v in NON_PRIMES) {\\n      if (v !in freqMap) continue\\n      val howmany = freqMap[v]!!\\n\\n      val prev = HashMap(dp)\\n      dp[v] = (dp[v] ?: 0) + howmany\\n      for ((product, quantity) in prev)\\n        if (gcd(product, v) == 1)\\n          dp[product * v] = ((dp[product * v] ?: 0L) + quantity * howmany.toLong()) % MOD\\n    }\\n    for (v in PRIMES) {\\n      if (v !in freqMap) continue\\n      val howmany = freqMap[v]!!.toLong()\\n      val prev = dp\\n      dp = mutableMapOf<Int, Long>()\\n      dp[v] = howmany\\n      for ((product, quantity) in prev)\\n        dp[product] = if (product % v != 0) quantity * (1 + howmany) else quantity\\n    }\\n\\t// Getting all possible subsets without `1`\\n    var res = dp.values.sum() % MOD\\n\\t\\n\\t// Find the permutations of `1`\\n    val possible = (1..(freqMap[1] ?: 0)).fold(1L) {sum, _ -> (sum shl 1) % MOD}\\n    res = (res * possible + possible + MOD - 1) % MOD\\n    return res.toInt()\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207357,
                "title": "python-step-by-step-top-down-dp-detailed-explaination",
                "content": "```\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        ans = 0 \\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\\n        non_square = []\\n        mod = 1_000_000_007\\n        \\n        \\n        # get elemts in nums , whose common factors donot have more than 1 primes\\n        # why? for a number 25: common factors = 5, 5\\n        # every non prime can be expressed as multiple of primes\\n        # if a number is using 2 or more primes in common factors (like 25), its not square free\\n        \\n        for num in nums:\\n            real_num = num\\n            for p in primes:\\n                count_p = 0\\n                has_square = False\\n                while num % p == 0:\\n                    num = num // p\\n                    count_p += 1\\n                \\n                if count_p > 1:\\n                    has_square = True\\n                    break # yikes this num is not square free\\n            \\n            if has_square == False:\\n                non_square.append(real_num) # num is not divisble by any square number between[0-30]\\n            \\n        \\n        # now we have list of numbers\\n        # now we have to find all subsets of non_square which on multiply are non divisible by \\n        # any square number too. pseudo code\\n        \"\"\"\\n            def dp(ci, multiplied_num):\\n                if ci == len(non_square) : return 0\\n                skip = dp(ci + 1, multiplied_num)\\n                curr_mul = multiplied_num * non_square[ci]\\n                if square_free(curr_mul) : \\n                    no_skip = dp(ci + 1, curr_mul)\\n                \\n                return skip + no_skip\\n        \"\"\"\\n        # which will have time complexity of O(N* multiplied_num) = O(N*10**9) BAD\\n        # we will switch this multiplied_num with a bitwise/tuple mask.. how ?\\n        # lets say we have a number n1 = 6 and n2 = 10\\n        # how can we know if res = n1 * n2 , the res is sqaure_free or not?\\n        # ez, find common_factors of n1 = 2, 3 & n2 = 2 , 5\\n        # the mutiplication will give 2, 2, 3, 5 , i.e 2 comes twice\\n        # if any prime factor comes twice, we dont wanna consider multiplication..\\n        # so instead of multiplied_num, we can pass mask of prime_factors used, (2, 3)\\n        # then we find prime_factor of current_num, 10 which is (2, 5)\\n        # since 2 is already in our mask we will not take 10, else we take it, set new mask\\n        # and run no_skip = dp(ci + 1, new_mask)\\n        \\n        \"\"\"\\n        def primes_in_num(num):\\n            res = []\\n            for p in primes:\\n                if num % p == 0: # adding only ones is fine, since num is already square_free\\n                    res.append(p)\\n            \\n            return res\\n        \\n        @cache\\n        def dp(ci, mask):\\n            \\n            if ci == len(non_square):\\n                return 0\\n            \\n            skip = dp(ci + 1, mask)\\n            noskip = 0\\n            \\n            primes_list = primes_in_num(non_square[ci])\\n            can_take = True\\n            \\n            for p in primes_list:\\n                if p in mask:\\n                    can_take = False\\n                    break\\n            \\n            \\n            if can_take:\\n                new_mask = tuple(list(mask) + list(primes_list))\\n                noskip = dp(ci + 1, new_mask) + 1\\n            \\n            return noskip + skip\\n        \\n        return dp(0, ())\\n        \"\"\"\\n        # Now this solution ofc works but we are doing lot of linear extra work\\n        # to find if primes exist in prime list and array converted to tuples, etc\\n        # this can be furter improved by taking a bitmask. we only have 10 locations of primes\\n        # if have something like 1001000010 -> lets say this can be mapped as\\n        \"\"\"\\n            {index_0 = 2, index_1 = 3, index_2 = 5, index_3 = 7 ... all other primes mapped to index}\\n        \"\"\"\\n        # then we can have 2 masks to represent 2 nums:\\n        # mask1 = 101 and mask2 = 001\\n        # when doing (mask1 & mask2) , if the result is 0 , it means we have 2 distinct masks and we\\n        # want that only.. no 2 primes . but like in above case the (mask1 & mask2) will have a 1 at end\\n        # bcz in (101, 001) 3rd bit is set, index_3 lets suppose mean prime number 7, so this mean multiplication of these 2 numbers will have 2 sevens, so we cannot do it.\\n        # this will be exact same but more effieicent way to check if 2 primes exist \\n        \\n        def getfac(n):\\n            mask_for_n = 0\\n            index = 0\\n            while n != 1:\\n                while n % primes[index] == 0:\\n                    if mask_for_n & (1<<index):\\n                        # oh oh , the n has 2 primes in it. this will be a non square then\\n                        return -1\\n                    mask_for_n = mask_for_n | (1<<index) # set index\\'s bit\\n                    n = n // primes[index]\\n                index += 1\\n            return mask_for_n\\n        \\n        @cache\\n        def dp(ci, mask):\\n            \\n            if ci == len(non_square):\\n                return 0\\n            \\n            skip = dp(ci + 1, mask)\\n            noskip = 0\\n            \\n            curr_elem_mask = getfac(non_square[ci])\\n            \\n            if curr_elem_mask != -1 and curr_elem_mask & mask == 0:\\n                # no common elements exist\\n                noskip = 1 + dp(ci + 1, curr_elem_mask | mask) # set common in both\\n        \\n            return (skip + noskip) % mod\\n    \\n        \\n        return dp(0, 0) % mod\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        ans = 0 \\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\\n        non_square = []\\n        mod = 1_000_000_007\\n        \\n        \\n        # get elemts in nums , whose common factors donot have more than 1 primes\\n        # why? for a number 25: common factors = 5, 5\\n        # every non prime can be expressed as multiple of primes\\n        # if a number is using 2 or more primes in common factors (like 25), its not square free\\n        \\n        for num in nums:\\n            real_num = num\\n            for p in primes:\\n                count_p = 0\\n                has_square = False\\n                while num % p == 0:\\n                    num = num // p\\n                    count_p += 1\\n                \\n                if count_p > 1:\\n                    has_square = True\\n                    break # yikes this num is not square free\\n            \\n            if has_square == False:\\n                non_square.append(real_num) # num is not divisble by any square number between[0-30]\\n            \\n        \\n        # now we have list of numbers\\n        # now we have to find all subsets of non_square which on multiply are non divisible by \\n        # any square number too. pseudo code\\n        \"\"\"\\n            def dp(ci, multiplied_num):\\n                if ci == len(non_square) : return 0\\n                skip = dp(ci + 1, multiplied_num)\\n                curr_mul = multiplied_num * non_square[ci]\\n                if square_free(curr_mul) : \\n                    no_skip = dp(ci + 1, curr_mul)\\n                \\n                return skip + no_skip\\n        \"\"\"\\n        # which will have time complexity of O(N* multiplied_num) = O(N*10**9) BAD\\n        # we will switch this multiplied_num with a bitwise/tuple mask.. how ?\\n        # lets say we have a number n1 = 6 and n2 = 10\\n        # how can we know if res = n1 * n2 , the res is sqaure_free or not?\\n        # ez, find common_factors of n1 = 2, 3 & n2 = 2 , 5\\n        # the mutiplication will give 2, 2, 3, 5 , i.e 2 comes twice\\n        # if any prime factor comes twice, we dont wanna consider multiplication..\\n        # so instead of multiplied_num, we can pass mask of prime_factors used, (2, 3)\\n        # then we find prime_factor of current_num, 10 which is (2, 5)\\n        # since 2 is already in our mask we will not take 10, else we take it, set new mask\\n        # and run no_skip = dp(ci + 1, new_mask)\\n        \\n        \"\"\"\\n        def primes_in_num(num):\\n            res = []\\n            for p in primes:\\n                if num % p == 0: # adding only ones is fine, since num is already square_free\\n                    res.append(p)\\n            \\n            return res\\n        \\n        @cache\\n        def dp(ci, mask):\\n            \\n            if ci == len(non_square):\\n                return 0\\n            \\n            skip = dp(ci + 1, mask)\\n            noskip = 0\\n            \\n            primes_list = primes_in_num(non_square[ci])\\n            can_take = True\\n            \\n            for p in primes_list:\\n                if p in mask:\\n                    can_take = False\\n                    break\\n            \\n            \\n            if can_take:\\n                new_mask = tuple(list(mask) + list(primes_list))\\n                noskip = dp(ci + 1, new_mask) + 1\\n            \\n            return noskip + skip\\n        \\n        return dp(0, ())\\n        \"\"\"\\n        # Now this solution ofc works but we are doing lot of linear extra work\\n        # to find if primes exist in prime list and array converted to tuples, etc\\n        # this can be furter improved by taking a bitmask. we only have 10 locations of primes\\n        # if have something like 1001000010 -> lets say this can be mapped as\\n        \"\"\"\\n            {index_0 = 2, index_1 = 3, index_2 = 5, index_3 = 7 ... all other primes mapped to index}\\n        \"\"\"\\n        # then we can have 2 masks to represent 2 nums:\\n        # mask1 = 101 and mask2 = 001\\n        # when doing (mask1 & mask2) , if the result is 0 , it means we have 2 distinct masks and we\\n        # want that only.. no 2 primes . but like in above case the (mask1 & mask2) will have a 1 at end\\n        # bcz in (101, 001) 3rd bit is set, index_3 lets suppose mean prime number 7, so this mean multiplication of these 2 numbers will have 2 sevens, so we cannot do it.\\n        # this will be exact same but more effieicent way to check if 2 primes exist \\n        \\n        def getfac(n):\\n            mask_for_n = 0\\n            index = 0\\n            while n != 1:\\n                while n % primes[index] == 0:\\n                    if mask_for_n & (1<<index):\\n                        # oh oh , the n has 2 primes in it. this will be a non square then\\n                        return -1\\n                    mask_for_n = mask_for_n | (1<<index) # set index\\'s bit\\n                    n = n // primes[index]\\n                index += 1\\n            return mask_for_n\\n        \\n        @cache\\n        def dp(ci, mask):\\n            \\n            if ci == len(non_square):\\n                return 0\\n            \\n            skip = dp(ci + 1, mask)\\n            noskip = 0\\n            \\n            curr_elem_mask = getfac(non_square[ci])\\n            \\n            if curr_elem_mask != -1 and curr_elem_mask & mask == 0:\\n                # no common elements exist\\n                noskip = 1 + dp(ci + 1, curr_elem_mask | mask) # set common in both\\n        \\n            return (skip + noskip) % mod\\n    \\n        \\n        return dp(0, 0) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204740,
                "title": "using-dp-tabulation-bitmask",
                "content": "# Intuition\\nA[i]<=30 , Hence squares of numbers which are possible are only 10.\\nprime={2,3,5,7,11,13,17,19,23,29}\\n\\n# Approach\\nWe can use bitmask to store if prime number is present or not.\\nMax Bitmask Numer = 2^10 -1 = Binary (1111111111)\\nEach of these 1 correspond to a particular index in prime.\\n1 means Present.\\n0 means Absent.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n  *1024 * 10)$$\\nSize of Array= n\\nBitmask Max Value= 1024\\nPrimes to Check= 10\\n\\n- Space complexity:\\n$$O(n*1024)$$\\n\\n# Code\\n```\\n#define ll long long\\n#define md 1000000007\\nclass Solution\\n{\\npublic:\\n   int squareFreeSubsets(vector<int> &v)\\n   {\\n      ll n=v.size();\\n      ll a[10]={2,3,5,7,11,13,17,19,23,29};\\n      ll dp[n+1][1024];\\n      for(int i=0;i<1024;i++)\\n          dp[n][i]=1;\\n      for(ll i=n-1;i>=0;i--)\\n      {\\n          for(ll j=1023;j>=0;j--)\\n          {\\n              dp[i][j]=dp[i+1][j];\\n              bool ck=1;\\n              ll nj=j;\\n              ll ele=v[i];\\n              for(ll k=0;k<10;k++)\\n              {\\n                  while (ele%a[k]==0)\\n                  {\\n                      ele/=a[k];\\n                      if ((nj & 1<<k)>>k)\\n                      {\\n                          ck=0;\\n                          break;\\n                      }\\n                      else\\n                          nj=(nj | 1<<k);\\n                  }\\n              }\\n              if (ck)\\n              dp[i][j]=(dp[i][j]+dp[i+1][nj])%md;\\n          }\\n      }\\n      return (dp[0][0]-1+md)%md;\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\n#define md 1000000007\\nclass Solution\\n{\\npublic:\\n   int squareFreeSubsets(vector<int> &v)\\n   {\\n      ll n=v.size();\\n      ll a[10]={2,3,5,7,11,13,17,19,23,29};\\n      ll dp[n+1][1024];\\n      for(int i=0;i<1024;i++)\\n          dp[n][i]=1;\\n      for(ll i=n-1;i>=0;i--)\\n      {\\n          for(ll j=1023;j>=0;j--)\\n          {\\n              dp[i][j]=dp[i+1][j];\\n              bool ck=1;\\n              ll nj=j;\\n              ll ele=v[i];\\n              for(ll k=0;k<10;k++)\\n              {\\n                  while (ele%a[k]==0)\\n                  {\\n                      ele/=a[k];\\n                      if ((nj & 1<<k)>>k)\\n                      {\\n                          ck=0;\\n                          break;\\n                      }\\n                      else\\n                          nj=(nj | 1<<k);\\n                  }\\n              }\\n              if (ck)\\n              dp[i][j]=(dp[i][j]+dp[i+1][nj])%md;\\n          }\\n      }\\n      return (dp[0][0]-1+md)%md;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204115,
                "title": "python-approach-with-counting-no-dp-or-bitmask",
                "content": "# Intuition\\nAny list of numbers that doesn\\'t have duplicate prime factors works\\n\\n# Approach\\nWe first count and dedupe the input list to get at most 30 unique numbers. We then find the prime factorization of every number and removes ones and products of squares higher than 1.\\nThis further reduces our input to at most 17 inputs.\\nThis means there\\'s only 131,072 possible combinations of these numbers, allowing us to brute force all combinations. (we can also choose to do dp + recursion at this point if we wanted it to be really fast, but it hardly seems worth it with such small inputs)\\nNotice that if the length of set of all primes combined is the same as the original list, there was no intersection\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^{17}*17*10)$$\\n2^17 possible combinations, up to 17 numbers in subset, up to 10 primes per number.\\nexpressed in terms of possible numbers $c$ and number of primes $p$:\\n$$O(2^c*c*p)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        MOD = (10 ** 9 + 7)\\n        numsc = Counter(nums)\\n        ones = 1 << numsc[1] # get possible combinations of ones\\n        \\n        primefactors = [self.prime_factors(i) for i in numsc.keys()] # get prime factors\\n        primefactors = list(map(tuple, filter(lambda x: x != -1, primefactors))) # filter ones and square products\\n\\n        if not primefactors:\\n            return (ones - 1) % MOD\\n        primefactorscount = {}\\n        for primefac in primefactors: # map prime factors to count\\n            primefactorscount[primefac] = numsc[prod(primefac)]\\n        ans = 0\\n        if not ones:\\n            ones = 1\\n        else:\\n            ans = ones - 1\\n        del numsc\\n        \\n        for i in range(1, len(primefactors) + 1):  # iterate possible lengths\\n            for subset in combinations(primefactors, i): # iterate all possible combinations\\n                total = list(chain(*subset))\\n                if len(total) == len(set(total)):  # if square-free subset\\n                    plus = ones  # can use any possible combination of ones\\n                    for primelist in subset:\\n                        plus *= primefactorscount[primelist] # multiply by how many instances of this number exists (can choose any one)\\n                    ans += plus\\n        return ans % (MOD)\\n\\n\\n    def prime_factors(self, n):\\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\\n        factors = []\\n        for i in primes:\\n            if i * i > n:\\n                break\\n            if n % i == 0:\\n                n //= i\\n                if n % i == 0: # has square factor\\n                    return -1\\n                factors.append(i)\\n        if n > 1:\\n            factors.append(n)\\n        if not factors:\\n            return -1 # passed in 1\\n        return factors\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        MOD = (10 ** 9 + 7)\\n        numsc = Counter(nums)\\n        ones = 1 << numsc[1] # get possible combinations of ones\\n        \\n        primefactors = [self.prime_factors(i) for i in numsc.keys()] # get prime factors\\n        primefactors = list(map(tuple, filter(lambda x: x != -1, primefactors))) # filter ones and square products\\n\\n        if not primefactors:\\n            return (ones - 1) % MOD\\n        primefactorscount = {}\\n        for primefac in primefactors: # map prime factors to count\\n            primefactorscount[primefac] = numsc[prod(primefac)]\\n        ans = 0\\n        if not ones:\\n            ones = 1\\n        else:\\n            ans = ones - 1\\n        del numsc\\n        \\n        for i in range(1, len(primefactors) + 1):  # iterate possible lengths\\n            for subset in combinations(primefactors, i): # iterate all possible combinations\\n                total = list(chain(*subset))\\n                if len(total) == len(set(total)):  # if square-free subset\\n                    plus = ones  # can use any possible combination of ones\\n                    for primelist in subset:\\n                        plus *= primefactorscount[primelist] # multiply by how many instances of this number exists (can choose any one)\\n                    ans += plus\\n        return ans % (MOD)\\n\\n\\n    def prime_factors(self, n):\\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\\n        factors = []\\n        for i in primes:\\n            if i * i > n:\\n                break\\n            if n % i == 0:\\n                n //= i\\n                if n % i == 0: # has square factor\\n                    return -1\\n                factors.append(i)\\n        if n > 1:\\n            factors.append(n)\\n        if not factors:\\n            return -1 # passed in 1\\n        return factors\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203937,
                "title": "memorization-gcd",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        sq = {4, 8, 9, 12, 16, 18, 20, 24, 25, 27, 28}\\n        \\n        def gcd(a, b):\\n            while b != 0:\\n                a, b = b, a % b\\n            return a\\n        \\n        dic = {}\\n        for i in nums:\\n            if i in sq:\\n                continue\\n            tmp_dic = dict(dic)\\n            for k in dic.keys():\\n                if gcd(k, i) == 1:\\n                    cur = k * i\\n                    if cur in tmp_dic:\\n                        tmp_dic[cur] += dic[k]\\n                    else:\\n                        tmp_dic[cur] = dic[k]\\n            if i in tmp_dic:\\n                tmp_dic[i] += 1\\n            else:\\n                tmp_dic[i] = 1\\n            dic = tmp_dic\\n        # print(dic)\\n        return sum([dic[k] for k in dic.keys()]) % (10**9 + 7)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        sq = {4, 8, 9, 12, 16, 18, 20, 24, 25, 27, 28}\\n        \\n        def gcd(a, b):\\n            while b != 0:\\n                a, b = b, a % b\\n            return a\\n        \\n        dic = {}\\n        for i in nums:\\n            if i in sq:\\n                continue\\n            tmp_dic = dict(dic)\\n            for k in dic.keys():\\n                if gcd(k, i) == 1:\\n                    cur = k * i\\n                    if cur in tmp_dic:\\n                        tmp_dic[cur] += dic[k]\\n                    else:\\n                        tmp_dic[cur] = dic[k]\\n            if i in tmp_dic:\\n                tmp_dic[i] += 1\\n            else:\\n                tmp_dic[i] = 1\\n            dic = tmp_dic\\n        # print(dic)\\n        return sum([dic[k] for k in dic.keys()]) % (10**9 + 7)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203754,
                "title": "c-simple-and-efficient-c-solution-80-ms-beat-100-time-o-1024-n",
                "content": "# Intuition\\nThere are only 10 primes upto 30, so iterate over all subsets of prime fators that the product can have. \\n\\n# Approach\\n\\n- Define dp[i][mask] = number of ways to solve the question if we take only the first i numbers from nums and the product of the subset will have the primes with set bit in mask.\\n\\nmask = 0000000101 means that product is 2 * 5 = 10\\n\\n- If we have number where some prime factor occurs more than once, directly ignore them\\n- dp[i][j|mask] += dp[i-1][mask] if j has no bit set which are set in mask i.e. j&mask == 0  \\n\\n# Complexity\\n- Time complexity: O(n*2^p) = O(1024n)\\n\\n- Space complexity: O(1024n)\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nconst int M = 1e9 + 7;\\nvector<int> p = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n\\nclass Solution\\n{\\npublic:\\n    int Madd(int a, int b)\\n    {\\n        a += b;\\n        if (a >= M)\\n            a -= M;\\n        return a;\\n    }\\n\\n    int squareFreeSubsets(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        vector<vector<int>> f(n, vector<int>(10));\\n        for (int i = 0; i < n; i++)\\n        {\\n            int x = nums[i];\\n            for (int j = 0; j < 10; j++)\\n            {\\n                while (x % p[j] == 0)\\n                {\\n                    x /= p[j];\\n                    f[i][j]++;\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(1 << 10));\\n        for (int i = 0; i < n; i++)\\n        {\\n            dp[i + 1] = dp[i];\\n\\n            bool ok = true;\\n            int mask = 0;\\n\\n            for (int j = 0; j < 10; j++)\\n            {\\n                if (f[i][j] > 1)\\n                {\\n                    ok = false;\\n                    break;\\n                }\\n                if (f[i][j] == 1)\\n                {\\n                    mask |= (1 << j);\\n                }\\n            }\\n\\n            if (ok)\\n            {\\n                for (int j = 0; j < (1 << 10); j++)\\n                    if ((j & mask) == 0)\\n                        dp[i + 1][j | mask] = Madd(dp[i + 1][j | mask], dp[i][j]);\\n\\n                dp[i + 1][mask] = Madd(dp[i + 1][mask], 1);\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (int i = 0; i < (1 << 10); i++)\\n            ans = Madd(ans, dp[n][i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nconst int M = 1e9 + 7;\\nvector<int> p = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n\\nclass Solution\\n{\\npublic:\\n    int Madd(int a, int b)\\n    {\\n        a += b;\\n        if (a >= M)\\n            a -= M;\\n        return a;\\n    }\\n\\n    int squareFreeSubsets(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        vector<vector<int>> f(n, vector<int>(10));\\n        for (int i = 0; i < n; i++)\\n        {\\n            int x = nums[i];\\n            for (int j = 0; j < 10; j++)\\n            {\\n                while (x % p[j] == 0)\\n                {\\n                    x /= p[j];\\n                    f[i][j]++;\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(1 << 10));\\n        for (int i = 0; i < n; i++)\\n        {\\n            dp[i + 1] = dp[i];\\n\\n            bool ok = true;\\n            int mask = 0;\\n\\n            for (int j = 0; j < 10; j++)\\n            {\\n                if (f[i][j] > 1)\\n                {\\n                    ok = false;\\n                    break;\\n                }\\n                if (f[i][j] == 1)\\n                {\\n                    mask |= (1 << j);\\n                }\\n            }\\n\\n            if (ok)\\n            {\\n                for (int j = 0; j < (1 << 10); j++)\\n                    if ((j & mask) == 0)\\n                        dp[i + 1][j | mask] = Madd(dp[i + 1][j | mask], dp[i][j]);\\n\\n                dp[i + 1][mask] = Madd(dp[i + 1][mask], 1);\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (int i = 0; i < (1 << 10); i++)\\n            ans = Madd(ans, dp[n][i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4001080,
                "title": "careful-implementation-bitmask-recursion-with-almost-oneliner-variant-okey-3rd-is-oneliner",
                "content": "\\n```\\nclass Solution:\\n    def squareFreeSubsets(self, n: List[int]) -> int:\\n        m,c=10**9+7,Counter(n)\\n        o=pow(2,c[1],m)\\n        for i in 17,19,23,29:o=o*(c[i]+1)%m\\n        b={2:1,3:2,5:4,6:3,7:8,10:5,11:16,13:32,14:9,15:6,21:10,22:17,26:33,30:7}\\n        for i in set(range(1,30))-set(b):del c[i]\\n        l=len(k:=list(c))\\n        #@cache\\n        def f(p,s):return (1+sum(c[v]*f(i+1,s|x)%m for i in range(p,l) if not s&(x:=b[v:=k[i]])))%m\\n        o=f(0,0)%m*o%m\\n        return (o-1+m)%m\\n```\\n\\nalmost onliner:\\n```\\nclass Solution:\\n    def squareFreeSubsets(self, n: List[int]) -> int:\\n        for i in [d:=Counter(c:=Counter(n)),m:=10**9+7,set(range(1,30))-set(b:={2:1,3:2,5:4,6:3,7:8,10:5,11:16,13:32,14:9,15:6,21:10,22:17,26:33,30:7})].pop():del c[i]\\n        return (l:=len(k:=list(c)),(pow(2,d[1],m)*reduce(mul,(d[i]+1 for i in (17,19,23,29)))%m*(f:=lambda p,s:(1+sum(c[v]*f(i+1,s|x)%m for i in range(p,l) if not s&(x:=b[v:=k[i]])))%m)(0,0)+m-1)%m)[-1]\\n```\\n\\nvuala onliner it is:\\n```\\nclass Solution:\\n    squareFreeSubsets=lambda s,n:(b:={2:1,3:2,5:4,6:3,7:8,10:5,11:16,13:32,14:9,15:6,21:10,22:17,26:33,30:7},d:=Counter(c:=Counter(n)),m:=10**9+7,{c.pop(i,0) for i in set(range(1,30))-set(b)},l:=len(k:=list(c)),(pow(2,d[1],m)*reduce(mul,(d[i]+1 for i in (17,19,23,29)))%m*(f:=lambda p,s:(1+sum(c[v]*f(i+1,s|x)%m for i in range(p,l) if not s&(x:=b[v:=k[i]])))%m)(0,0)+m-1)%m)[-1]",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def squareFreeSubsets(self, n: List[int]) -> int:\\n        m,c=10**9+7,Counter(n)\\n        o=pow(2,c[1],m)\\n        for i in 17,19,23,29:o=o*(c[i]+1)%m\\n        b={2:1,3:2,5:4,6:3,7:8,10:5,11:16,13:32,14:9,15:6,21:10,22:17,26:33,30:7}\\n        for i in set(range(1,30))-set(b):del c[i]\\n        l=len(k:=list(c))\\n        #@cache\\n        def f(p,s):return (1+sum(c[v]*f(i+1,s|x)%m for i in range(p,l) if not s&(x:=b[v:=k[i]])))%m\\n        o=f(0,0)%m*o%m\\n        return (o-1+m)%m\\n```\n```\\nclass Solution:\\n    def squareFreeSubsets(self, n: List[int]) -> int:\\n        for i in [d:=Counter(c:=Counter(n)),m:=10**9+7,set(range(1,30))-set(b:={2:1,3:2,5:4,6:3,7:8,10:5,11:16,13:32,14:9,15:6,21:10,22:17,26:33,30:7})].pop():del c[i]\\n        return (l:=len(k:=list(c)),(pow(2,d[1],m)*reduce(mul,(d[i]+1 for i in (17,19,23,29)))%m*(f:=lambda p,s:(1+sum(c[v]*f(i+1,s|x)%m for i in range(p,l) if not s&(x:=b[v:=k[i]])))%m)(0,0)+m-1)%m)[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994490,
                "title": "c-memoization-bitmask-dp",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\n    long long MOD = 1e9 + 7;\\npublic:\\n    bool check_already_set_bits(int a, int b)\\n    {\\n        for(int i = 0; i < 11; ++i)\\n        {\\n            int temp = (1 << i);\\n            if((a & temp) && (b & temp)) return false;\\n        }\\n        return true;\\n    }\\n    int helper(vector<int>& nums, int index, vector<int> &bm, int res, vector<vector<int>> &dp)\\n    {\\n        \\n        if(index == nums.size())\\n        {\\n            return 1;\\n        }\\n        if(dp[index][res] != -1) return dp[index][res];\\n\\n        int include{};\\n        if(bm[index] != -1 && check_already_set_bits(res, bm[index])) //condition to include => check if the prime factor is not already present in result\\n        {       \\n            include =  helper(nums, index+1, bm, res | bm[index], dp);\\n        }\\n        int exclude = helper(nums, index + 1, bm, res, dp);\\n\\n        return dp[index][res] = (include + exclude) % MOD;\\n    }\\n\\n    int squareFreeSubsets(vector<int>& nums) {\\n\\n        vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n        vector<int> bm{};\\n        for(int i: nums)\\n        {\\n            int k{};\\n            int bitmask = 0;\\n            while(i != 1)\\n            {\\n                while(i%primes[k] == 0)\\n                {\\n                    i /= primes[k];\\n                    if(bitmask & (1 << k))  //if already set bit or prime number is already found\\n                    {\\n                        bitmask = -1;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        bitmask |= (1 << k);\\n                    }\\n                }\\n                if(bitmask == -1)\\n                {\\n                    bm.push_back(bitmask);\\n                    break;\\n                }\\n                k++;\\n            }\\n            if(bitmask != -1)\\n                bm.push_back(bitmask);\\n        }\\n\\n     \\n        vector<vector<int>> dp(nums.size(), vector<int>(1 << 11, -1));\\n        int  res{};\\n        int ans = helper(nums, 0, bm, res, dp) - 1;\\n        return ans != -1 ? ans: 1e9+6;\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\n    long long MOD = 1e9 + 7;\\npublic:\\n    bool check_already_set_bits(int a, int b)\\n    {\\n        for(int i = 0; i < 11; ++i)\\n        {\\n            int temp = (1 << i);\\n            if((a & temp) && (b & temp)) return false;\\n        }\\n        return true;\\n    }\\n    int helper(vector<int>& nums, int index, vector<int> &bm, int res, vector<vector<int>> &dp)\\n    {\\n        \\n        if(index == nums.size())\\n        {\\n            return 1;\\n        }\\n        if(dp[index][res] != -1) return dp[index][res];\\n\\n        int include{};\\n        if(bm[index] != -1 && check_already_set_bits(res, bm[index])) //condition to include => check if the prime factor is not already present in result\\n        {       \\n            include =  helper(nums, index+1, bm, res | bm[index], dp);\\n        }\\n        int exclude = helper(nums, index + 1, bm, res, dp);\\n\\n        return dp[index][res] = (include + exclude) % MOD;\\n    }\\n\\n    int squareFreeSubsets(vector<int>& nums) {\\n\\n        vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n        vector<int> bm{};\\n        for(int i: nums)\\n        {\\n            int k{};\\n            int bitmask = 0;\\n            while(i != 1)\\n            {\\n                while(i%primes[k] == 0)\\n                {\\n                    i /= primes[k];\\n                    if(bitmask & (1 << k))  //if already set bit or prime number is already found\\n                    {\\n                        bitmask = -1;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        bitmask |= (1 << k);\\n                    }\\n                }\\n                if(bitmask == -1)\\n                {\\n                    bm.push_back(bitmask);\\n                    break;\\n                }\\n                k++;\\n            }\\n            if(bitmask != -1)\\n                bm.push_back(bitmask);\\n        }\\n\\n     \\n        vector<vector<int>> dp(nums.size(), vector<int>(1 << 11, -1));\\n        int  res{};\\n        int ans = helper(nums, 0, bm, res, dp) - 1;\\n        return ans != -1 ? ans: 1e9+6;\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960222,
                "title": "clear-solution-with-comments-iterative-approach-used-basic-bit-techniques",
                "content": "```\\nDo UP-VOTE ,if i have benefitted you ,by God\\'s grace.\\n```\\n```\\n\\nclass Solution {\\npublic:\\n    long long mod = 1e9+7;\\n    // function to find power\\n    long long power(long long a,long long b){\\n            long long res = 1ll;\\n            \\n            while(b){\\n                if(b%2){\\n                    res*=a;\\n                    res%=mod;\\n                }\\n                b/=2ll;\\n                a*=a;\\n                a%=mod;\\n            }\\n            return res;\\n    }\\n\\n    int squareFreeSubsets(vector<int>& nums) {\\n        //range of nums is from [1....30]\\n        vector<int> m(31,0) ;\\n        for(auto & i : nums) m[i]++ ; \\n      \\n        for(int i = 2 ; i<=5 ; i++)\\n        {\\n            int square = i*i ; \\n            //setting frequnecy of all the factors of squares ,because they wont be used in any subset\\n            for(int j = square ; j<=30 ; j+=square) m[j] = 0 ; \\n        }\\n\\n        //taking all the numbers whose subset can be made and storing in seperate array\\n        vector<long long >a; \\n        for(int i = 0 ; i<m.size();i++)\\n        {\\n            if(m[i]) a.push_back(i) ;\\n        }\\n      \\n        //if there is a one in our number then if its freq is m[1],then it can contribute to 2 ^(m[1]) -1\\n        long long n = a.size(), \\n                  tot = (1<<n),subsets = 0,\\n                  one_contri = (power(2ll,m[1])-1) ;\\n\\n        // now iterate over all subsets\\n        for(int i =1;i<tot;i++)\\n        {\\n            long long pro=1, \\n                      gc=1, \\n                      pass=1, \\n                      count=1;\\n\\n\\n            for(int j = 0 ;j<n;j++)\\n            {\\n                // if jth bit is set consider jth number\\n                if(i&(1<<j))\\n                {\\n                    gc = __gcd(pro,a[j]) ;\\n                    pass = 1;\\n                    //if common factor is greater than 1 then product will result in a square\\n                    if(gc>1)\\n                    {\\n                        pass = 0 ;\\n                        break;\\n                    }\\n                    pro*=a[j] ; \\n\\n                    /* if there is one number and it has frequncy f ,then we can make f subsets ,\\n                    similarly if there are 2 numbers ,then we can make f1 * f2 subsets ,\\n                    for 3 numbers it would be f1*f2*f3, for n numbers it would be f1*f2*f3*...*fn */\\n\\n                    if(a[j] != 1) \\n                        count = (count*m[a[j]])%mod;\\n                    else \\n                        count = (count * one_contri)%mod;\\n                }\\n                //break statement applied 2 times to break out of if then for loop \\n                if(!pass) break;\\n            }\\n\\n            if(pass)\\n                subsets = (subsets+count)%mod;\\n            \\n        }\\n       return subsets ; \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nDo UP-VOTE ,if i have benefitted you ,by God\\'s grace.\\n```\n```\\n\\nclass Solution {\\npublic:\\n    long long mod = 1e9+7;\\n    // function to find power\\n    long long power(long long a,long long b){\\n            long long res = 1ll;\\n            \\n            while(b){\\n                if(b%2){\\n                    res*=a;\\n                    res%=mod;\\n                }\\n                b/=2ll;\\n                a*=a;\\n                a%=mod;\\n            }\\n            return res;\\n    }\\n\\n    int squareFreeSubsets(vector<int>& nums) {\\n        //range of nums is from [1....30]\\n        vector<int> m(31,0) ;\\n        for(auto & i : nums) m[i]++ ; \\n      \\n        for(int i = 2 ; i<=5 ; i++)\\n        {\\n            int square = i*i ; \\n            //setting frequnecy of all the factors of squares ,because they wont be used in any subset\\n            for(int j = square ; j<=30 ; j+=square) m[j] = 0 ; \\n        }\\n\\n        //taking all the numbers whose subset can be made and storing in seperate array\\n        vector<long long >a; \\n        for(int i = 0 ; i<m.size();i++)\\n        {\\n            if(m[i]) a.push_back(i) ;\\n        }\\n      \\n        //if there is a one in our number then if its freq is m[1],then it can contribute to 2 ^(m[1]) -1\\n        long long n = a.size(), \\n                  tot = (1<<n),subsets = 0,\\n                  one_contri = (power(2ll,m[1])-1) ;\\n\\n        // now iterate over all subsets\\n        for(int i =1;i<tot;i++)\\n        {\\n            long long pro=1, \\n                      gc=1, \\n                      pass=1, \\n                      count=1;\\n\\n\\n            for(int j = 0 ;j<n;j++)\\n            {\\n                // if jth bit is set consider jth number\\n                if(i&(1<<j))\\n                {\\n                    gc = __gcd(pro,a[j]) ;\\n                    pass = 1;\\n                    //if common factor is greater than 1 then product will result in a square\\n                    if(gc>1)\\n                    {\\n                        pass = 0 ;\\n                        break;\\n                    }\\n                    pro*=a[j] ; \\n\\n                    /* if there is one number and it has frequncy f ,then we can make f subsets ,\\n                    similarly if there are 2 numbers ,then we can make f1 * f2 subsets ,\\n                    for 3 numbers it would be f1*f2*f3, for n numbers it would be f1*f2*f3*...*fn */\\n\\n                    if(a[j] != 1) \\n                        count = (count*m[a[j]])%mod;\\n                    else \\n                        count = (count * one_contri)%mod;\\n                }\\n                //break statement applied 2 times to break out of if then for loop \\n                if(!pass) break;\\n            }\\n\\n            if(pass)\\n                subsets = (subsets+count)%mod;\\n            \\n        }\\n       return subsets ; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910122,
                "title": "python-recursive-strategy-beats-100-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA normal first strategy would be to test every combination of numbers, but this would have a runtime of O(N * 2^N) which is definitely too long. But this time complexity can be heavily minimized!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First, find the frequncy of each number in nums. \\n2. Separate each number between 1 and 30 into 3 categories: primes, composites with no duplicate factors, and composites with duplicate factors. Any number with duplicate factors already contains a square number factor and therefore cannot be present in any final solution. \\n3. Reduce your final list into just a single copy of all numbers in the first two categories. If 1 is present in the list, remove it and we\\'ll deal with it later. \\n4. Now use a recursive traversal of your shortened list. As you progress through the list, if none of the number\\'s factors have already been used, we can add this to our solution, make the appropriate changes, and continue. Otherwise, just skip the number (we will trigger this call either way). \\n5. For all of the possible solutions, we can add any amount of 1\\'s to end up in the same situation. This is why at the very end, we will multiply by 2 ^ (# of 1s). We can also have answers containing ONLY 1s. We add all those combinations and return our final answer. \\n\\n# Complexity\\n- Time complexity: k = length of set of primes in nums; O(2 ^ k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: k = length of set of primes in nums; O(2 ^ k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def squareFreeSubsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        # Find frequency of each value \\n        freqs = {}\\n        for val in nums:\\n            freqs[val] = freqs.get(val, 0) + 1\\n        \\n        # Factors of all composites with no dupcliate factors\\n        factors = {6: [2, 3], 10: [2,5], 14: [2,7], 15: [3, 5], 21: [3, 7], 22: [2, 11], 26: [2, 13], 30: [2, 3, 5]}\\n\\n        # List of primes \\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\\n        \\n        # List of composites WITH dupcliate factors \\n        invalid = [4, 8, 9, 12, 16, 18, 20, 24, 25, 27, 28]\\n        compressed = set(nums)\\n        \\n        # Sorted list without invalid numbers\\n        reduced = sorted([val for val in compressed if val not in invalid])\\n    \\n        # If no valid numbers, return 0\\n        if not reduced:\\n            return 0\\n    \\n        self.total = 0\\n\\n        if reduced[0] == 1:\\n            reduced.pop(0)\\n        \\n        def traverse(index, used, subtotal):\\n\\n            # Base Case: traversed through entire list\\n            if index == len(reduced):\\n                self.total += subtotal\\n                self.total %= 1000000007\\n                return \\n            \\n            # Check if factors have already been used \\n            valid = True \\n            number = reduced[index]\\n            if number in factors.keys():\\n                for factor in factors[number]:\\n                    if factor in used:\\n                        valid = False \\n                        break \\n            else:\\n                if number in used:\\n                    valid = False \\n            \\n            # Always trigger the skip call \\n            traverse(index + 1, used[:], subtotal)\\n\\n            # If none of the factors have been used, add them to the used list and call another traversal\\n            if valid:\\n                if number in factors.keys():\\n                    for factor in factors[number]:\\n                        used.append(factor) \\n                else:\\n                    used.append(number)\\n                \\n                # The idea here is we can select EXACTLY 1 copy of this number, so multiply to find the number of viable combinations up to this point\\n                subtotal *= freqs[number]\\n                subtotal %= 1000000007\\n\\n                traverse(index + 1, used[:], subtotal)\\n            \\n        traverse(0, [], 1)\\n        \\n        # Account for the 1\\'s in the original list \\n        if 1 in freqs.keys():\\n            return ((self.total - 1) * pow(2, freqs[1]) + (pow(2, freqs[1]) - 1)) % 1000000007\\n        \\n        return (self.total - 1) % 1000000007\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def squareFreeSubsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        # Find frequency of each value \\n        freqs = {}\\n        for val in nums:\\n            freqs[val] = freqs.get(val, 0) + 1\\n        \\n        # Factors of all composites with no dupcliate factors\\n        factors = {6: [2, 3], 10: [2,5], 14: [2,7], 15: [3, 5], 21: [3, 7], 22: [2, 11], 26: [2, 13], 30: [2, 3, 5]}\\n\\n        # List of primes \\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\\n        \\n        # List of composites WITH dupcliate factors \\n        invalid = [4, 8, 9, 12, 16, 18, 20, 24, 25, 27, 28]\\n        compressed = set(nums)\\n        \\n        # Sorted list without invalid numbers\\n        reduced = sorted([val for val in compressed if val not in invalid])\\n    \\n        # If no valid numbers, return 0\\n        if not reduced:\\n            return 0\\n    \\n        self.total = 0\\n\\n        if reduced[0] == 1:\\n            reduced.pop(0)\\n        \\n        def traverse(index, used, subtotal):\\n\\n            # Base Case: traversed through entire list\\n            if index == len(reduced):\\n                self.total += subtotal\\n                self.total %= 1000000007\\n                return \\n            \\n            # Check if factors have already been used \\n            valid = True \\n            number = reduced[index]\\n            if number in factors.keys():\\n                for factor in factors[number]:\\n                    if factor in used:\\n                        valid = False \\n                        break \\n            else:\\n                if number in used:\\n                    valid = False \\n            \\n            # Always trigger the skip call \\n            traverse(index + 1, used[:], subtotal)\\n\\n            # If none of the factors have been used, add them to the used list and call another traversal\\n            if valid:\\n                if number in factors.keys():\\n                    for factor in factors[number]:\\n                        used.append(factor) \\n                else:\\n                    used.append(number)\\n                \\n                # The idea here is we can select EXACTLY 1 copy of this number, so multiply to find the number of viable combinations up to this point\\n                subtotal *= freqs[number]\\n                subtotal %= 1000000007\\n\\n                traverse(index + 1, used[:], subtotal)\\n            \\n        traverse(0, [], 1)\\n        \\n        # Account for the 1\\'s in the original list \\n        if 1 in freqs.keys():\\n            return ((self.total - 1) * pow(2, freqs[1]) + (pow(2, freqs[1]) - 1)) % 1000000007\\n        \\n        return (self.total - 1) % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841829,
                "title": "easily-understandable-solution-using-bitmasking-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEasy solution!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBitmask each prime number and make sure in each subset no prime number should stay more than once.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*1024)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*1024)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        return b==0 ?  a :  gcd(b,a%b);\\n    }\\n    int primes[10]={2,3,5,7,11,13,17,19,23,29};\\n    int squares[4]={4,9,16,25};\\n\\n    int mod=1e9+7;\\n    \\n    bool poss(int x,vector<int>&vis){\\n        for(int i=0;i<10;i++){\\n            if(x%primes[i]==0 && vis[i]>0)return false;\\n        }\\n        for(int i=0;i<4;i++){\\n            if(x%squares[i]==0)return false;\\n        }\\n        return true;\\n    }\\n\\n    int solve(int n,vector<int>& nums,vector<int>&vis,vector<vector<int>>&dp){\\n        if(n==0)return 1;\\n        int ct=0;\\n        for(int i=0;i<10;i++){\\n            if(vis[i]==1){\\n                ct+=(1<<i);\\n            }\\n        }\\n        \\n        if(dp[n][ct]!=-1)return dp[n][ct];\\n\\n        int ans=solve(n-1,nums,vis,dp);\\n        \\n        if(poss(nums[n-1],vis)){\\n            for(int i=0;i<10;i++){\\n                if(nums[n-1]%primes[i]==0)vis[i]=1;\\n            }\\n            long long x=((long long)ans%mod + (solve(n-1,nums,vis,dp))%mod)%mod;\\n            ans=x;\\n            for(int i=0;i<10;i++){\\n                if(nums[n-1]%primes[i]==0)vis[i]=0;\\n            }\\n        }\\n        \\n        return dp[n][ct]=ans;\\n    }\\n\\n    int squareFreeSubsets(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>vis(11,0);\\n        vector<vector<int>>dp(n+1,vector<int>(1<<10,-1));\\n        int ans=solve(n,nums,vis,dp);\\n        if(ans-1==-1)return 1000000006;\\n        return ans-1;\\n    }\\n};\\n/*\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        return b==0 ?  a :  gcd(b,a%b);\\n    }\\n    int primes[10]={2,3,5,7,11,13,17,19,23,29};\\n    int squares[4]={4,9,16,25};\\n\\n    int mod=1e9+7;\\n    \\n    bool poss(int x,vector<int>&vis){\\n        for(int i=0;i<10;i++){\\n            if(x%primes[i]==0 && vis[i]>0)return false;\\n        }\\n        for(int i=0;i<4;i++){\\n            if(x%squares[i]==0)return false;\\n        }\\n        return true;\\n    }\\n\\n    int solve(int n,vector<int>& nums,vector<int>&vis,vector<vector<int>>&dp){\\n        if(n==0)return 1;\\n        int ct=0;\\n        for(int i=0;i<10;i++){\\n            if(vis[i]==1){\\n                ct+=(1<<i);\\n            }\\n        }\\n        \\n        if(dp[n][ct]!=-1)return dp[n][ct];\\n\\n        int ans=solve(n-1,nums,vis,dp);\\n        \\n        if(poss(nums[n-1],vis)){\\n            for(int i=0;i<10;i++){\\n                if(nums[n-1]%primes[i]==0)vis[i]=1;\\n            }\\n            long long x=((long long)ans%mod + (solve(n-1,nums,vis,dp))%mod)%mod;\\n            ans=x;\\n            for(int i=0;i<10;i++){\\n                if(nums[n-1]%primes[i]==0)vis[i]=0;\\n            }\\n        }\\n        \\n        return dp[n][ct]=ans;\\n    }\\n\\n    int squareFreeSubsets(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>vis(11,0);\\n        vector<vector<int>>dp(n+1,vector<int>(1<<10,-1));\\n        int ans=solve(n,nums,vis,dp);\\n        if(ans-1==-1)return 1000000006;\\n        return ans-1;\\n    }\\n};\\n/*\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821014,
                "title": "c-explained-solution-dp-bit-manipulation-powerfunction",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each number `x` in the nums vector, the number of subsets equals the valid subsets if we didn\\'t take `x`, plust the number of valid subset if we decide to take it. We are only allowed to take `x` if it 2 conditions are satisfied:\\n1) `x` is not a square itself\\n2) `x` has no common factors with the elements added to the subset so far. \\n\\nTo check for the first condition, `myPrimes` functions returns -1 for non square-free numbers. \\nFor square-free numbers, `myPrimes` outputs the prime factors of this number encoded in the bits of the output. So, to check for the second condition, you must make sure that the prime factors of `x` are different from all prime-factors of numbers added so far to the subset. We keep track of these in a mask variable `p`. In case `myPrimes(x) & p` is `0`, you can take `x` to the subset and set its primes in `p`. \\n\\nThe ONEs special case: when `x` is one, it primes mask is all zeros. Whether you take `1` or not, doesn\\'t result in any update to the `p`. So, the number of valid subsets `count` is calculated and then, for each valid subset, all ones combinations can be considered. \\n\\nThe final solution would be `count * (2** onesCount) -1`. Of course, the handling of huge numbers and returning the modulo introduces some complexity that is handled in the code. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI took a recursive DP approach. Noticing that we need to re-calculate the #subsets for repeating combination `p` and `x`, it is intuitive to keep these in `dp[idx][p]` array to accelerate computation. \\n\\nThe base case for recursion is when you reach a leave. In that case `1` is returned, regardless of whether the subset is empty or not. Later, the empty subset is accounted for by subtracting one from the total number of valid subsets. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n * 1024) = O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nsize of dp = 1<<10 * n = O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    const int MOD = 1e9 + 7;\\n    const int primes[10] = {2,3,5, 7, 11, 13, 17, 19, 23, 29};\\n    const int nPr = 10;\\n    int n;\\n    vector<int> cache;\\n    int dp[1000][1<<12];\\n    int onesCount = 0;\\n    int pf(int a,int b){\\n        int ans=1;\\n        while(b){\\n            if(b&1){\\n                ans=(ans*1LL*a)%MOD;\\n            }\\n            a=(a*1LL*a)%MOD;\\n            b=b>>1;\\n        }\\n        return ans%MOD;\\n    }\\n\\n    int squareFreeSubsets(vector<int>& nums) {\\n        n = nums.size();\\n        cout << \"n = \" << n << endl;\\n        cache.resize(n);\\n        for(int i = 0; i <n;i++){\\n            cache[i] = myPrimes(nums[i]);\\n            if (nums[i] == 1){\\n                onesCount++;\\n            }\\n            //cout<< cache[i] << \"--\";\\n        }\\n        cout<<endl;\\n\\n        memset(dp,-1,sizeof(dp));\\n        int count = recr(0, 0, true);\\n\\n        \\n        cout << \"onesCount\"<< onesCount<<\"__count \"<<count<< endl;\\n\\n        int onesComb = pf(2, onesCount);\\n        //cout << endl << onesComb <<endl;\\n        auto res = count * 1LL * onesComb;\\n        return (res-1) %MOD;\\n          \\n    }\\n\\n    int recr(int idx, int p){\\n        //cout << idx << \",\" << p << endl;\\n        // base case\\n        if (idx == n){\\n            //cout << \"reached a leave\" <<endl;\\n            return 1; //(p!=0);\\n        }\\n        // cached\\n        if(dp[idx][p]!=-1) return dp[idx][p];\\n\\n        // not take\\n        int notTake = recr(idx+1, p);\\n        \\n\\n        // take\\n       \\n        int take = 0;\\n        int ri = cache[idx];\\n        \\n        //int p_ = p & (~(1<<11)); // clear bit 11\\n        if (ri > 0 && ((p&ri) == 0)){ // primes of idx are not in p\\n            // adding idx makes a valid subset\\n            take = recr(idx+1, p|ri);\\n        }\\n        \\n        // DEBGUG \\n        /*\\n        if(dp[idx][p]!=-1 && (dp[idx][p] != (notTake + take)%MOD) ) {\\n            cout << dp[idx][p] << \"__\" << (notTake + take)%MOD << \"__\";\\n            cout << idx << \", \"<< p << endl;\\n        }*/\\n        \\n        dp[idx][p] = (notTake%MOD + take%MOD);\\n        //if (dp [idx][p] == 0){\\n        //cout << \"dp[\" <<idx << \"][\" << p << \"] = \"<<dp[idx][p] << endl;}\\n        return dp[idx][p];\\n\\n    }\\n    // sets all primes to 1\\n    int myPrimes(int num){\\n        int res = 0;\\n        for(int i = 0; i< nPr; i++){\\n            int p = primes[i];\\n            if(num % (p*p) == 0){\\n                // not square free \\n                //cache[num] = -1;\\n                return -1;\\n            }\\n            if( num % p == 0){\\n                // set bit i of res\\n                res |= (1<<i);\\n            }\\n        }\\n        //cout << \"res \"<< res << endl;\\n        //cache[num] = res;\\n        //if (res == 0){\\n        //    cout << num << endl;\\n        //}\\n        return res;\\n    }\\n\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    const int MOD = 1e9 + 7;\\n    const int primes[10] = {2,3,5, 7, 11, 13, 17, 19, 23, 29};\\n    const int nPr = 10;\\n    int n;\\n    vector<int> cache;\\n    int dp[1000][1<<12];\\n    int onesCount = 0;\\n    int pf(int a,int b){\\n        int ans=1;\\n        while(b){\\n            if(b&1){\\n                ans=(ans*1LL*a)%MOD;\\n            }\\n            a=(a*1LL*a)%MOD;\\n            b=b>>1;\\n        }\\n        return ans%MOD;\\n    }\\n\\n    int squareFreeSubsets(vector<int>& nums) {\\n        n = nums.size();\\n        cout << \"n = \" << n << endl;\\n        cache.resize(n);\\n        for(int i = 0; i <n;i++){\\n            cache[i] = myPrimes(nums[i]);\\n            if (nums[i] == 1){\\n                onesCount++;\\n            }\\n            //cout<< cache[i] << \"--\";\\n        }\\n        cout<<endl;\\n\\n        memset(dp,-1,sizeof(dp));\\n        int count = recr(0, 0, true);\\n\\n        \\n        cout << \"onesCount\"<< onesCount<<\"__count \"<<count<< endl;\\n\\n        int onesComb = pf(2, onesCount);\\n        //cout << endl << onesComb <<endl;\\n        auto res = count * 1LL * onesComb;\\n        return (res-1) %MOD;\\n          \\n    }\\n\\n    int recr(int idx, int p){\\n        //cout << idx << \",\" << p << endl;\\n        // base case\\n        if (idx == n){\\n            //cout << \"reached a leave\" <<endl;\\n            return 1; //(p!=0);\\n        }\\n        // cached\\n        if(dp[idx][p]!=-1) return dp[idx][p];\\n\\n        // not take\\n        int notTake = recr(idx+1, p);\\n        \\n\\n        // take\\n       \\n        int take = 0;\\n        int ri = cache[idx];\\n        \\n        //int p_ = p & (~(1<<11)); // clear bit 11\\n        if (ri > 0 && ((p&ri) == 0)){ // primes of idx are not in p\\n            // adding idx makes a valid subset\\n            take = recr(idx+1, p|ri);\\n        }\\n        \\n        // DEBGUG \\n        /*\\n        if(dp[idx][p]!=-1 && (dp[idx][p] != (notTake + take)%MOD) ) {\\n            cout << dp[idx][p] << \"__\" << (notTake + take)%MOD << \"__\";\\n            cout << idx << \", \"<< p << endl;\\n        }*/\\n        \\n        dp[idx][p] = (notTake%MOD + take%MOD);\\n        //if (dp [idx][p] == 0){\\n        //cout << \"dp[\" <<idx << \"][\" << p << \"] = \"<<dp[idx][p] << endl;}\\n        return dp[idx][p];\\n\\n    }\\n    // sets all primes to 1\\n    int myPrimes(int num){\\n        int res = 0;\\n        for(int i = 0; i< nPr; i++){\\n            int p = primes[i];\\n            if(num % (p*p) == 0){\\n                // not square free \\n                //cache[num] = -1;\\n                return -1;\\n            }\\n            if( num % p == 0){\\n                // set bit i of res\\n                res |= (1<<i);\\n            }\\n        }\\n        //cout << \"res \"<< res << endl;\\n        //cache[num] = res;\\n        //if (res == 0){\\n        //    cout << num << endl;\\n        //}\\n        return res;\\n    }\\n\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3820837,
                "title": "count-the-number-of-square-free-subsets-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint mod = 1e9 + 7;\\nclass Solution\\n{\\npublic:\\n    vector<int> primes{2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n    unordered_map<int, int> primeMap, freq;\\n    int power(long long x, long long y, int p = mod)\\n    {\\n        unsigned long long res = 1;\\n        x = x % p;\\n        while (y > 0)\\n        {\\n            if (y & 1)\\n                res = (res * x) % p;\\n            y = y >> 1;\\n            x = (x * x) % p;\\n        }\\n        return res;\\n    }\\n    int getMul(int mask, int num)\\n    {\\n        for (auto &p : primes)\\n        {\\n            if (num % p == 0)\\n            {\\n                if (mask & (1 << primeMap[p]))\\n                    return 0;\\n                num /= p;\\n\\n                if (num % p == 0)\\n                    return 0;\\n                mask |= (1 << primeMap[p]);\\n            }\\n        }\\n        return mask;\\n    }\\n\\n    int construct(int prod_mask, vector<int> &nums, int ind)\\n    {\\n        if (ind == nums.size())\\n            return prod_mask != 0;\\n\\n        int res = construct(prod_mask, nums, ind + 1);\\n        int mask_when_multiplied = getMul(prod_mask, nums[ind]);\\n        if (mask_when_multiplied != 0)\\n            res = (res + 1ll * freq[nums[ind]] * construct(mask_when_multiplied, nums, ind + 1)) % mod;\\n\\n        return res;\\n    }\\n\\n    int squareFreeSubsets(vector<int> &nums)\\n    {\\n        freq.clear();\\n        for (int i = 0; i < 10; i++)\\n            primeMap[primes[i]] = i;\\n        for (auto &i : nums)\\n            freq[i]++;\\n\\n        set<int> st(nums.begin(), nums.end());\\n        int ones = count(nums.begin(), nums.end(), 1);\\n        nums.clear();\\n        for (auto &x : st)\\n            if (x != 1)\\n                nums.push_back(x);\\n        int numberOfSets = construct(0, nums, 0) % mod;\\n        int nonEmpty1sets = (power(2, ones) - 1 + mod) % mod;\\n        numberOfSets = (numberOfSets + 1ll * numberOfSets * nonEmpty1sets % mod + nonEmpty1sets) % mod;\\n        return numberOfSets;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint mod = 1e9 + 7;\\nclass Solution\\n{\\npublic:\\n    vector<int> primes{2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n    unordered_map<int, int> primeMap, freq;\\n    int power(long long x, long long y, int p = mod)\\n    {\\n        unsigned long long res = 1;\\n        x = x % p;\\n        while (y > 0)\\n        {\\n            if (y & 1)\\n                res = (res * x) % p;\\n            y = y >> 1;\\n            x = (x * x) % p;\\n        }\\n        return res;\\n    }\\n    int getMul(int mask, int num)\\n    {\\n        for (auto &p : primes)\\n        {\\n            if (num % p == 0)\\n            {\\n                if (mask & (1 << primeMap[p]))\\n                    return 0;\\n                num /= p;\\n\\n                if (num % p == 0)\\n                    return 0;\\n                mask |= (1 << primeMap[p]);\\n            }\\n        }\\n        return mask;\\n    }\\n\\n    int construct(int prod_mask, vector<int> &nums, int ind)\\n    {\\n        if (ind == nums.size())\\n            return prod_mask != 0;\\n\\n        int res = construct(prod_mask, nums, ind + 1);\\n        int mask_when_multiplied = getMul(prod_mask, nums[ind]);\\n        if (mask_when_multiplied != 0)\\n            res = (res + 1ll * freq[nums[ind]] * construct(mask_when_multiplied, nums, ind + 1)) % mod;\\n\\n        return res;\\n    }\\n\\n    int squareFreeSubsets(vector<int> &nums)\\n    {\\n        freq.clear();\\n        for (int i = 0; i < 10; i++)\\n            primeMap[primes[i]] = i;\\n        for (auto &i : nums)\\n            freq[i]++;\\n\\n        set<int> st(nums.begin(), nums.end());\\n        int ones = count(nums.begin(), nums.end(), 1);\\n        nums.clear();\\n        for (auto &x : st)\\n            if (x != 1)\\n                nums.push_back(x);\\n        int numberOfSets = construct(0, nums, 0) % mod;\\n        int nonEmpty1sets = (power(2, ones) - 1 + mod) % mod;\\n        numberOfSets = (numberOfSets + 1ll * numberOfSets * nonEmpty1sets % mod + nonEmpty1sets) % mod;\\n        return numberOfSets;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811569,
                "title": "python-combinatorial-approach-100-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nWe exploit the fact that each of the numbers in the array only goes up to 30 and then use combinatorics to count up how many ways we can select a proper subset  of the numbers present in the array ````nums```` (i.e., select a nonempty subarray of ````nums````) such that each prime number appears only once as a factor in these numbers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nWe approach this as a pure combinatorial problem.\\n\\nFirst we count up the number of times $$c_i$$ each number $$i\\\\in\\\\{1,2,\\\\ldots,30\\\\}$$ appears in the array, which we can do in $$O(n)$$ time by running through the array only once.\\n\\nIt will be helpful to partition the numbers $$\\\\{1,2,\\\\ldots,30\\\\}$$ into four categories.\\n\\n1. **The number one:** $$\\\\{1\\\\}$$. We can include the number 1 any number of times in our subset without violating the square-free assumption.\\n2. **The square numbers and their multiples:** $$\\\\{4,8,9,12,16,18,20,24,25,27,28\\\\}$$. These are the numbers that are themselves not square-free, and hence, we cannot use any of these numbers in our subset.\\n3. **The prime numbers that are greater than 15:** $$\\\\{17,19,23,29\\\\}$$.  These are the prime numbers in the upper half of the range from $$\\\\{1,2,\\\\ldots,30\\\\}$$ and hence any multiple of these numbers exceeds 30, and so each of thse numbers is relatively prime to all of other numbers positive integers in $$\\\\{1,2,\\\\ldots,30\\\\}$$.  We can include each such up to 1 time in our subset, without concern for which other numbers are included in the subset.\\n4. **The remaining numbers:** $$\\\\{2,3,5,6,7,10,11,13,14,15,21,22,26,28\\\\}$$.  These numbers include the prime numbers that are no greater than 15 as well as their products that are no greater than 30 (i.e., the square-free multiples of these prime numbers the range $$\\\\{1,2,\\\\ldots,30\\\\}$$).  These are the trickiest numbers to deal with as when we include one such number in our subset, we can\\'t use another number that shares a divisor that is greater than 1 with it.  For example, if our subset includes 3, it can\\'t include 15 (as it is a multiple of 3), or if our subset includes 22, it can\\'t include 11 (as it is a divisor of 22), and if our subset includes 14 it can\\'t include 26 (as they share the divisor 2).\\n\\nIn order to count the number of square-free subsets, let us temporarily ignore the fact that our subset must be nonempty (and later adjust for thsi by subtracting 1 from the total number of subsets).  Going through the four categoreis above, we see that since we can include any numbers of 1s, for each 1 in ````nums```` we can either include it or not, yielding  $$2^{c_1}$$ choices of which 1s to include in our subset.  Next, we have the numbers that are divisible by the square of a prime $$\\\\{4,8,9,12,16,18,20,24,25,27,28\\\\}$$, and for each such number we have only a single choice: we must include exactly zero of them in our subset.  Next, for each $i\\\\in\\\\{17,19,23,29\\\\}$, we can choose any of the $c_i$ of these available for inclusion in our subset, or choose none of them (as we can choose up to one of each, if available), and hence we can make $$(c_{17}+1)(c_{19}+1)(c_{23}+1)(c_{29}+1)$$ choices containing these numbers.  The now turn to addressing the fourth category.\\n\\nLets name this remaining category of numbers $$S\\\\equiv\\\\{2,3,5,6,7,10,11,13,14,15,21,22,26,28\\\\}$$.  When it comes to the numbers in $$S$$, just as with the numbers in $$\\\\{17,19,23,29\\\\}$$, we can choose each such number at most once.  However, we cannot make all such choices freely as discussed above.  Hence the number of ways we can include these numbers is given by $$\\\\sum_{\\\\mathbf{x\\\\in X}}\\\\prod_{i\\\\in S}c_i^{x_i}$$, where for any subset, the 14-dimensional binary vector $$\\\\bold x\\\\equiv(x_i)_{i\\\\in S}=(x_2,x_3,x_5,x_6,\\\\ldots,x_{28},x_{30})\\\\in\\\\{0,1\\\\}^{14}$$ designates which numbers in $$S$$ are included in that subset (the number $$i\\\\in S$$ is included if and only if $$\\\\mathbf{x}$$ is such $$x_i=1$$); meanwhile, $$\\\\mathbf{X}$$ denotes the set of all $$\\\\mathbf{x}$$ that do not violate the square-free assumption (note that 1s or prime numbers greater than 15 do not affect $$\\\\mathbf{X}$$). \\n\\nWe can formulate $$\\\\mathbf{X}$$ as an integral polytope as follows:\\n\\n$$\\\\mathbf{X}=\\\\{\\\\mathbf{x}\\\\in\\\\{0,1\\\\}^{14}\\\\colon\\\\\\\\\\n\\\\qquad\\\\qquad x_{2}+x_{6}+x_{10}+x_{14}+x_{22}+x_{26}+x_{30}\\\\le 1,\\\\\\\\\\n\\\\qquad\\\\qquad x_{3}+x_{6}+x_{15}+x_{21}+x_{30}\\\\le 1,\\\\\\\\\\n\\\\qquad\\\\qquad x_{5}+x_{10}+x_{15}+x_{30}\\\\le 1,\\\\\\\\\\n\\\\qquad\\\\qquad x_{7}+x_{14}+x_{21}\\\\le 1,\\\\\\\\\\n\\\\qquad\\\\qquad x_{11}+x_{22}\\\\le 1,\\\\\\\\\\n\\\\qquad\\\\qquad x_{13}+x_{26}\\\\le 1\\\\\\\\\\n\\\\qquad\\\\ \\\\ \\\\ \\\\ \\\\}$$\\n\\nIt is possible to calculate $$\\\\mathbf{X}$$ by brute force through pre-computation (and then paste the result into the code), but I\\'ve chosen to compute the vector $$\\\\left(\\\\prod_{i\\\\in S}c_i^{x_i}\\\\right)_{\\\\mathbf x\\\\in\\\\mathbf{X}}$$ directly in the program.  In either case, in Python, this can be done via a list comprehension (this \"vector\" is actually the list I call ````bigList```` in my code).  We could have actually approached the problem in such a way that we could have formulated $\\\\mathbf{x}$ as a vector in 30-dimensional (or 29-dimensional, since we would still likely want to treat 1 as a specila case) rather than a 14-dimensional space $\\\\mathbf{X}$ without adding additional linear constraints, but this may lead to far slower run times.\\n\\nFinally, we have the a total count of  \\n$$C\\\\equiv2^{c_1}(c_{17}+1)(c_{19}+1)(c_{23}+1)(c_{29}+1)\\\\left(\\\\prod_{i\\\\in S}c_i^{x_i}\\\\right)_{\\\\mathbf x\\\\in\\\\mathbf{X}}$$\\nsubsets.  This count includes the empty subset, as we could choose to include no 1s, 17, 19s, 23s, 29s, and numbers in $$S$$ (the 14-dimensional zero vector is included in $$\\\\mathbf{X}$$ as it satisfies all of the constraints), which is consistent with the standard matheamtical convention that the empty product is 1.  However, the problem description specifically asks for nonempty subarrays, so we subtract 1 from this count, and we report this modified count modulo $$10^9+7$$ as instructed, yielding a final answer of $$C-1\\\\mod 7$$.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ as we only need to run through the array once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(\\\\log(n))$$ in exceess of the memory needed to store ````nums```` itself (if I\\'m not mistaken), as we may need to raise some numbers to the power of a number on the order of $n$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def squareFreeSubsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        c = [0 for i in range(31)] #use this like a 1-indexed array for convenience\\n        for j in range(len(nums)):\\n            c[nums[j]] += 1 #c[k] is the \\n of how many times each number k from 1 to 30 shows up in the array\\n        bigList = [c[2]**x2*c[3]**x3*c[5]**x5*c[7]**x7*c[11]**x11*c[13]**x13\\\\\\n        *c[6]**x6*c[10]**x10*c[14]**x14*c[15]**x15*c[21]**x21*c[22]**x22*c[26]**x26*c[30]**x30\\\\\\n        for x2 in range(2) for x3 in range(2) for x5 in range(2) for x7 in range(2) for x11 in range(2) for x13 in range(2)\\\\\\n        for x6 in range(2) for x10 in range(2) for x14 in range(2) for x15 in range(2) for x21 in range(2) for x22 in range(2)\\\\\\n        for x26 in range(2) for x30 in range(2)\\\\\\n        if all([x2+x6+x10+x14+x22+x26+x30<=1,x3+x6+x15+x21+x30<=1,x5+x10+x15+x30<=1,x7+x14+x21<=1,x11+x22<=1,x13+x26<=1])]\\n        return (2**c[1]*(1+c[17])*(1+c[19])*(1+c[23])*(1+c[29])*sum(bigList) - 1) % (10**9+7)\\n        #any subset of 1s can be included for 2**c[1] choices\\n        #up to one of each of 17, 19, 23, and 29 can be included allowing for (1+c[k]) choices for each such k\\n        #no 4, 8, 12, 16, 20, 24, 28, 9, 18, 27, or 25 may be included as these numbers are not square free\\n        #bigList counts how many ways each valid combination of the other 14 numbers (multiples of 2, 3, 5, 7, 11, and 13) can be used\\n        #there are dependencies between these, namely that only one multiple of each of 2, 3, 5, 7, 11, and 13 may be used\\n        #\\n 1 because the empty subset doesn\\'t count, even though it\\'s a square-free subset\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Counting"
                ],
                "code": "````nums```\n````nums```\n````nums```\n````bigList```\n````nums```\n```\\nclass Solution(object):\\n    def squareFreeSubsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        c = [0 for i in range(31)] #use this like a 1-indexed array for convenience\\n        for j in range(len(nums)):\\n            c[nums[j]] += 1 #c[k] is the \\n of how many times each number k from 1 to 30 shows up in the array\\n        bigList = [c[2]**x2*c[3]**x3*c[5]**x5*c[7]**x7*c[11]**x11*c[13]**x13\\\\\\n        *c[6]**x6*c[10]**x10*c[14]**x14*c[15]**x15*c[21]**x21*c[22]**x22*c[26]**x26*c[30]**x30\\\\\\n        for x2 in range(2) for x3 in range(2) for x5 in range(2) for x7 in range(2) for x11 in range(2) for x13 in range(2)\\\\\\n        for x6 in range(2) for x10 in range(2) for x14 in range(2) for x15 in range(2) for x21 in range(2) for x22 in range(2)\\\\\\n        for x26 in range(2) for x30 in range(2)\\\\\\n        if all([x2+x6+x10+x14+x22+x26+x30<=1,x3+x6+x15+x21+x30<=1,x5+x10+x15+x30<=1,x7+x14+x21<=1,x11+x22<=1,x13+x26<=1])]\\n        return (2**c[1]*(1+c[17])*(1+c[19])*(1+c[23])*(1+c[29])*sum(bigList) - 1) % (10**9+7)\\n        #any subset of 1s can be included for 2**c[1] choices\\n        #up to one of each of 17, 19, 23, and 29 can be included allowing for (1+c[k]) choices for each such k\\n        #no 4, 8, 12, 16, 20, 24, 28, 9, 18, 27, or 25 may be included as these numbers are not square free\\n        #bigList counts how many ways each valid combination of the other 14 numbers (multiples of 2, 3, 5, 7, 11, and 13) can be used\\n        #there are dependencies between these, namely that only one multiple of each of 2, 3, 5, 7, 11, and 13 may be used\\n        #\\n 1 because the empty subset doesn\\'t count, even though it\\'s a square-free subset\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791947,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int prime[]={2,3,5,7,11,13,17,19,23,29};\\n    int mod=(int)1e9+7;\\n    int isValid(int n,int mask){\\n        for(int i=0;i<prime.length;i++){\\n            if(n==4 || n==16 || n==9 || n==25)\\n            return -1;\\n            while(n%prime[i]==0){\\n                if((mask&(1<<i))>0)\\n                return -1;\\n                mask|=(1<<i);\\n                n/=prime[i];\\n            }\\n        }\\n        return mask;\\n    }\\n    long solve(int index,int nums[],int mask,Long dp[][]){\\n        if(index>=nums.length)\\n        return 0;\\n        if(dp[index][mask]!=null)\\n        return dp[index][mask];\\n        long notake=solve(index+1,nums,mask,dp)%mod;\\n        long take=0;\\n        int temp=isValid(nums[index],mask);\\n        if(temp!=-1){\\n            take=1+solve(index+1,nums,temp,dp)%mod;\\n        }\\n        return dp[index][mask]=(take%mod+notake%mod)%mod;\\n    }\\n    public int squareFreeSubsets(int[] nums) {\\n        int mask=0;\\n        Long dp[][]=new Long[nums.length][(1<<10+1)];\\n        return (int)solve(0,nums,mask,dp)%mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int prime[]={2,3,5,7,11,13,17,19,23,29};\\n    int mod=(int)1e9+7;\\n    int isValid(int n,int mask){\\n        for(int i=0;i<prime.length;i++){\\n            if(n==4 || n==16 || n==9 || n==25)\\n            return -1;\\n            while(n%prime[i]==0){\\n                if((mask&(1<<i))>0)\\n                return -1;\\n                mask|=(1<<i);\\n                n/=prime[i];\\n            }\\n        }\\n        return mask;\\n    }\\n    long solve(int index,int nums[],int mask,Long dp[][]){\\n        if(index>=nums.length)\\n        return 0;\\n        if(dp[index][mask]!=null)\\n        return dp[index][mask];\\n        long notake=solve(index+1,nums,mask,dp)%mod;\\n        long take=0;\\n        int temp=isValid(nums[index],mask);\\n        if(temp!=-1){\\n            take=1+solve(index+1,nums,temp,dp)%mod;\\n        }\\n        return dp[index][mask]=(take%mod+notake%mod)%mod;\\n    }\\n    public int squareFreeSubsets(int[] nums) {\\n        int mask=0;\\n        Long dp[][]=new Long[nums.length][(1<<10+1)];\\n        return (int)solve(0,nums,mask,dp)%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781096,
                "title": "java-o-n-with-o-1-space-1ms",
                "content": "# Complexity\\n- Time complexity:\\nO(N) if we consider range of input constant\\n\\n- Space complexity:\\nO(1) if we consider range of input constant\\n\\n# Code\\nOptimizations here and there\\n```\\nclass Solution {\\n    int[] count = new int[31], masks = new int[31];\\n    long[][] cache = new long[31][1 << 6];\\n    long mod = 1_000_000_007;\\n    public int squareFreeSubsets(int[] nums) {\\n        int[] p = {1, 2, 3, 5, 7, 11, 13};\\n        for (int i = 0; i < 7; ++i) { // O(6 * 6) = O(1)\\n            int mask = i == 0 ? 0 : 1 << (i - 1);\\n            for (int j = i + 1; j < 7; ++j) {\\n                if (p[i] * p[j] > 30) break;\\n                masks[p[i] * p[j]] = mask | (1 << (j - 1));\\n            }\\n        }\\n        masks[30] = 7; // 000111\\n        for (int k : nums) if (k % 4 != 0 && k % 9 != 0 && k % 25 != 0) ++count[k]; // O(N)\\n        count[1] = powof2(count[1]); // O(logN)\\n        return (int) ((dfs(30, 0) + mod - 1) % mod); // O(30 * 2^6) = O(1)\\n    }\\n    private long dfs(int k, int mask) {\\n        if (k == 1) return count[1];\\n        if (cache[k][mask] != 0) return cache[k][mask];\\n        long res = dfs(k - 1, mask);\\n        if (count[k] > 0 && (masks[k] & mask) == 0) res = (res + (count[k] * dfs(k - 1, mask | masks[k])) % mod) % mod;\\n        return cache[k][mask] = res;\\n    }\\n    private int powof2(int k) {\\n        long pow2 = 2, res = 1;\\n        while (k > 0) {\\n            if (k % 2 == 1) res = (res * pow2) % mod;\\n            pow2 = (pow2 * pow2) % mod;\\n            k >>= 1;\\n        }\\n        return (int) res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] count = new int[31], masks = new int[31];\\n    long[][] cache = new long[31][1 << 6];\\n    long mod = 1_000_000_007;\\n    public int squareFreeSubsets(int[] nums) {\\n        int[] p = {1, 2, 3, 5, 7, 11, 13};\\n        for (int i = 0; i < 7; ++i) { // O(6 * 6) = O(1)\\n            int mask = i == 0 ? 0 : 1 << (i - 1);\\n            for (int j = i + 1; j < 7; ++j) {\\n                if (p[i] * p[j] > 30) break;\\n                masks[p[i] * p[j]] = mask | (1 << (j - 1));\\n            }\\n        }\\n        masks[30] = 7; // 000111\\n        for (int k : nums) if (k % 4 != 0 && k % 9 != 0 && k % 25 != 0) ++count[k]; // O(N)\\n        count[1] = powof2(count[1]); // O(logN)\\n        return (int) ((dfs(30, 0) + mod - 1) % mod); // O(30 * 2^6) = O(1)\\n    }\\n    private long dfs(int k, int mask) {\\n        if (k == 1) return count[1];\\n        if (cache[k][mask] != 0) return cache[k][mask];\\n        long res = dfs(k - 1, mask);\\n        if (count[k] > 0 && (masks[k] & mask) == 0) res = (res + (count[k] * dfs(k - 1, mask | masks[k])) % mod) % mod;\\n        return cache[k][mask] = res;\\n    }\\n    private int powof2(int k) {\\n        long pow2 = 2, res = 1;\\n        while (k > 0) {\\n            if (k % 2 == 1) res = (res * pow2) % mod;\\n            pow2 = (pow2 * pow2) % mod;\\n            k >>= 1;\\n        }\\n        return (int) res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664210,
                "title": "dp-bitmask-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int dp[1000][1<<10];\\n\\n    int pf(int a,int b){\\n        int ans=1;\\n        while(b){\\n            if(b&1){\\n                ans=(ans*1LL*a)%mod;\\n            }\\n            a=(a*1LL*a)%mod;\\n            b=b>>1;\\n        }\\n        return ans%mod;\\n    }\\n    int help(int mask,int idx,vector<int> &tmp){\\n        if(idx==tmp.size()){\\n            return mask!=0;\\n        }\\n        if(dp[idx][mask]!=-1) return dp[idx][mask];\\n        int notTake=help(mask,idx+1,tmp);\\n        int take=0;\\n        if((tmp[idx]&mask)==0){\\n            take=help(mask^tmp[idx],idx+1,tmp);\\n        }\\n        return dp[idx][mask]=(take+notTake)%mod;\\n    }\\n\\n    int squareFreeSubsets(vector<int>& nums) {\\n        unordered_set<int> st={4,8,9,12,16,18,20,24,25,27,28};\\n        vector<int> factors={2,3,5,7,11,13,17,19,23,29};\\n        vector<int> tmp;\\n        int cnt0=0;\\n\\n        for(auto x:nums){\\n            if(x==1){\\n                cnt0++;\\n                continue;\\n            }\\n            if(!st.count(x)){\\n                int t=0;\\n                for(int i=0;i<10;i++){\\n                    if(x%factors[i]==0){\\n                        t=t^(1<<i);\\n                    }\\n                }\\n                tmp.push_back(t);\\n            }\\n        }\\n        memset(dp,-1,sizeof dp);\\n        int ans=help(0,0,tmp);\\n        ans=((ans*1LL*pf(2,cnt0))%mod + 1LL*pf(2,cnt0)-1+mod)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int dp[1000][1<<10];\\n\\n    int pf(int a,int b){\\n        int ans=1;\\n        while(b){\\n            if(b&1){\\n                ans=(ans*1LL*a)%mod;\\n            }\\n            a=(a*1LL*a)%mod;\\n            b=b>>1;\\n        }\\n        return ans%mod;\\n    }\\n    int help(int mask,int idx,vector<int> &tmp){\\n        if(idx==tmp.size()){\\n            return mask!=0;\\n        }\\n        if(dp[idx][mask]!=-1) return dp[idx][mask];\\n        int notTake=help(mask,idx+1,tmp);\\n        int take=0;\\n        if((tmp[idx]&mask)==0){\\n            take=help(mask^tmp[idx],idx+1,tmp);\\n        }\\n        return dp[idx][mask]=(take+notTake)%mod;\\n    }\\n\\n    int squareFreeSubsets(vector<int>& nums) {\\n        unordered_set<int> st={4,8,9,12,16,18,20,24,25,27,28};\\n        vector<int> factors={2,3,5,7,11,13,17,19,23,29};\\n        vector<int> tmp;\\n        int cnt0=0;\\n\\n        for(auto x:nums){\\n            if(x==1){\\n                cnt0++;\\n                continue;\\n            }\\n            if(!st.count(x)){\\n                int t=0;\\n                for(int i=0;i<10;i++){\\n                    if(x%factors[i]==0){\\n                        t=t^(1<<i);\\n                    }\\n                }\\n                tmp.push_back(t);\\n            }\\n        }\\n        memset(dp,-1,sizeof dp);\\n        int ans=help(0,0,tmp);\\n        ans=((ans*1LL*pf(2,cnt0))%mod + 1LL*pf(2,cnt0)-1+mod)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600666,
                "title": "try-to-understand-the-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n\\n    private static final int MOD = (int) (1e9 + 7);\\n    private static final List<Integer> PRIMES = List.of(2, 3, 5, 7, 11, 13);\\n\\n    public int squareFreeSubsets(int[] nums) {\\n        int[] primeFactors = new int[31];\\n        for (int i = 2; i <= 30; i++) {\\n            if (i % 4 == 0 || i % 9 == 0 || i % 25 == 0) {\\n                continue;\\n            }\\n\\n            for (int j = 0; j < PRIMES.size(); j++) {\\n                if (i % PRIMES.get(j) == 0) {\\n                    primeFactors[i] += 1 << j;\\n                }\\n            }\\n        }\\n\\n        int[] freqs = new int[31];\\n        for (int num : nums) {\\n            if (num % 4 == 0 || num % 9 == 0 || num % 25 == 0) {\\n                continue;\\n            }\\n            freqs[num]++;\\n        }\\n\\n        long[] dp = new long[1 << 6];\\n        dp[primeFactors[30]] = freqs[30] % MOD;\\n        for (int i = 29; i >= 2; i--) {\\n            if (freqs[i] == 0) {\\n                continue;\\n            }\\n\\n            long[] temp = dp.clone();\\n\\n            temp[primeFactors[i]] += freqs[i];\\n            temp[primeFactors[i]] %= MOD;\\n            for (int mask = 0; mask < dp.length; mask++) {\\n                if (dp[mask] != 0 && (mask & primeFactors[i]) == 0) {\\n                    temp[mask | primeFactors[i]] += freqs[i] * dp[mask];\\n                    temp[mask | primeFactors[i]] %= MOD;\\n                }\\n            }\\n\\n            dp = temp;\\n        }\\n\\n        long oneSubsets = BigInteger.TWO.modPow(BigInteger.valueOf(freqs[1]), BigInteger.valueOf(MOD)).longValue();\\n        long otherSubsets = Arrays.stream(dp).sum() % MOD;\\n\\n        return (int) (otherSubsets * oneSubsets % MOD + oneSubsets - 1) % MOD;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n\\n    private static final int MOD = (int) (1e9 + 7);\\n    private static final List<Integer> PRIMES = List.of(2, 3, 5, 7, 11, 13);\\n\\n    public int squareFreeSubsets(int[] nums) {\\n        int[] primeFactors = new int[31];\\n        for (int i = 2; i <= 30; i++) {\\n            if (i % 4 == 0 || i % 9 == 0 || i % 25 == 0) {\\n                continue;\\n            }\\n\\n            for (int j = 0; j < PRIMES.size(); j++) {\\n                if (i % PRIMES.get(j) == 0) {\\n                    primeFactors[i] += 1 << j;\\n                }\\n            }\\n        }\\n\\n        int[] freqs = new int[31];\\n        for (int num : nums) {\\n            if (num % 4 == 0 || num % 9 == 0 || num % 25 == 0) {\\n                continue;\\n            }\\n            freqs[num]++;\\n        }\\n\\n        long[] dp = new long[1 << 6];\\n        dp[primeFactors[30]] = freqs[30] % MOD;\\n        for (int i = 29; i >= 2; i--) {\\n            if (freqs[i] == 0) {\\n                continue;\\n            }\\n\\n            long[] temp = dp.clone();\\n\\n            temp[primeFactors[i]] += freqs[i];\\n            temp[primeFactors[i]] %= MOD;\\n            for (int mask = 0; mask < dp.length; mask++) {\\n                if (dp[mask] != 0 && (mask & primeFactors[i]) == 0) {\\n                    temp[mask | primeFactors[i]] += freqs[i] * dp[mask];\\n                    temp[mask | primeFactors[i]] %= MOD;\\n                }\\n            }\\n\\n            dp = temp;\\n        }\\n\\n        long oneSubsets = BigInteger.TWO.modPow(BigInteger.valueOf(freqs[1]), BigInteger.valueOf(MOD)).longValue();\\n        long otherSubsets = Arrays.stream(dp).sum() % MOD;\\n\\n        return (int) (otherSubsets * oneSubsets % MOD + oneSubsets - 1) % MOD;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492333,
                "title": "recursion-map-fully-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. It is noteworthy that the complexity of the question may be reduced by considering the given numbers as a set rather than an array.\\n2. The range of numbers within the set allows for the pre-definition of all numbers between 1 and 30 that are free from squares.\\n3. It is of paramount importance to recognize that the product of two square-free numbers is also square-free only if they are relatively prime, meaning that their greatest common divisor is equal to 1.\\n4. By excluding the ones, we can compute the number of square-free subsets and subsequently double the quantity obtained based on the number of ones.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Count the number of each square-free number in the array named it counter_map.\\n2. Using helper function to compute the number of non-empty square-free subset given set converted from counter_map.\\n3. Doublue the result number of ones times and minus 1.\\n# Complexity\\n- Time complexity: O(n) Where n is the size of nums\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe running time should be linear, since the counter_map is constant size.\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSince the size of candidates is constant.\\n# Code\\n```\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        MOD = 10 ** 9 + 7   # applied when the number is too large\\n        # helper function to count the number of non-empty square-free subset given a set of number\\n        def sfs_for_set(_set):\\n            if not _set:\\n                return 1\\n            current_set = []\\n            for num in _set[1:]:\\n                if math.gcd(num, _set[0]) == 1:\\n                    current_set.append(num)\\n            # recursively get the number of sf subset given the rest of set\\n            # each duplicated number contribute the same size so we do multiplication here \\n            return (sfs_for_set(_set[1:]) + counter_map[_set[0]] * sfs_for_set(current_set)) % MOD\\n        # the candidates which are square-free in the range [1, 30]\\n        candidates = set([2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30])\\n        # count the number of appearance for each canditate\\n        counter_map = defaultdict(int)\\n        for num in nums:\\n            if num in candidates:\\n                counter_map[num] += 1\\n        # for each additional one, it could double the number of square-free subse    \\n        return (sfs_for_set(list(counter_map)) * 2 ** nums.count(1) - 1) % MOD\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        MOD = 10 ** 9 + 7   # applied when the number is too large\\n        # helper function to count the number of non-empty square-free subset given a set of number\\n        def sfs_for_set(_set):\\n            if not _set:\\n                return 1\\n            current_set = []\\n            for num in _set[1:]:\\n                if math.gcd(num, _set[0]) == 1:\\n                    current_set.append(num)\\n            # recursively get the number of sf subset given the rest of set\\n            # each duplicated number contribute the same size so we do multiplication here \\n            return (sfs_for_set(_set[1:]) + counter_map[_set[0]] * sfs_for_set(current_set)) % MOD\\n        # the candidates which are square-free in the range [1, 30]\\n        candidates = set([2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30])\\n        # count the number of appearance for each canditate\\n        counter_map = defaultdict(int)\\n        for num in nums:\\n            if num in candidates:\\n                counter_map[num] += 1\\n        # for each additional one, it could double the number of square-free subse    \\n        return (sfs_for_set(list(counter_map)) * 2 ** nums.count(1) - 1) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463978,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nlong long mod;\\n    long long rec(int ind,vector<int>&nums,int cur,map<int,int>&mp,vector<vector<long long>>&dp)\\n    {\\n        if (ind==nums.size()) \\n        {\\n            return 1;\\n        }\\n        if (dp[ind][cur]!=-1) return dp[ind][cur];\\n        long long pick=0;\\n        if ((mp[nums[ind]]&cur)==0)\\n        {\\n            pick=rec(ind+1,nums,cur|(mp[nums[ind]]),mp,dp);\\n        }\\n        long long notPick=rec(ind+1,nums,cur,mp,dp);\\n        return dp[ind][cur]=(pick+notPick)%mod;\\n        \\n    }\\n    int primeFactors(int n)\\n{\\n    int number=n;\\n    int temp=0;\\n    while (n%2 == 0)\\n    {\\n       temp|=(1<<2);\\n        n = n/2;\\n    }\\n \\n    for (int i = 3; i*i <= n; i = i+2)\\n    {\\n        while (n%i == 0)\\n        {\\n            temp|=(1<<i);\\n            n = n/i;\\n        }\\n    }\\n    if (n > 2)\\n       temp|=(1<<n);\\n       return temp;\\n}\\n    int squareFreeSubsets(vector<int>& nums) {\\n        vector<int>v;\\n        mod=1e9+7;\\n         int cnt1=0;\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            // if (nums[i]==1) {cnt1++;\\n            // continue;}\\n            if (nums[i]%4==0 || nums[i]%9==0 || nums[i]%25==0) continue;\\n            v.push_back(nums[i]);\\n        }\\n        map<int,int>mp;\\n        vector<vector<long long>>dp(v.size(),vector<long long>(1024,-1));\\n       vector<int>arr={2,3,5,7,11,13,17,19,23,29};\\n        for (int i=0;i<v.size();i++)\\n        {\\n             int temp=primeFactors(v[i]);\\n             int c=0;\\n             for (int i=0;i<arr.size();i++)\\n             {\\n                 if ((temp&(1<<arr[i]))!=0) c|=(1<<i);\\n             }\\n\\n             mp[v[i]]=c;\\n        }\\n        mp[1]=0;\\n        int cur=0;\\n        long long ans=rec(0,v,cur,mp,dp);\\n        \\n        return( ans-1+mod)%mod;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long mod;\\n    long long rec(int ind,vector<int>&nums,int cur,map<int,int>&mp,vector<vector<long long>>&dp)\\n    {\\n        if (ind==nums.size()) \\n        {\\n            return 1;\\n        }\\n        if (dp[ind][cur]!=-1) return dp[ind][cur];\\n        long long pick=0;\\n        if ((mp[nums[ind]]&cur)==0)\\n        {\\n            pick=rec(ind+1,nums,cur|(mp[nums[ind]]),mp,dp);\\n        }\\n        long long notPick=rec(ind+1,nums,cur,mp,dp);\\n        return dp[ind][cur]=(pick+notPick)%mod;\\n        \\n    }\\n    int primeFactors(int n)\\n{\\n    int number=n;\\n    int temp=0;\\n    while (n%2 == 0)\\n    {\\n       temp|=(1<<2);\\n        n = n/2;\\n    }\\n \\n    for (int i = 3; i*i <= n; i = i+2)\\n    {\\n        while (n%i == 0)\\n        {\\n            temp|=(1<<i);\\n            n = n/i;\\n        }\\n    }\\n    if (n > 2)\\n       temp|=(1<<n);\\n       return temp;\\n}\\n    int squareFreeSubsets(vector<int>& nums) {\\n        vector<int>v;\\n        mod=1e9+7;\\n         int cnt1=0;\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            // if (nums[i]==1) {cnt1++;\\n            // continue;}\\n            if (nums[i]%4==0 || nums[i]%9==0 || nums[i]%25==0) continue;\\n            v.push_back(nums[i]);\\n        }\\n        map<int,int>mp;\\n        vector<vector<long long>>dp(v.size(),vector<long long>(1024,-1));\\n       vector<int>arr={2,3,5,7,11,13,17,19,23,29};\\n        for (int i=0;i<v.size();i++)\\n        {\\n             int temp=primeFactors(v[i]);\\n             int c=0;\\n             for (int i=0;i<arr.size();i++)\\n             {\\n                 if ((temp&(1<<arr[i]))!=0) c|=(1<<i);\\n             }\\n\\n             mp[v[i]]=c;\\n        }\\n        mp[1]=0;\\n        int cur=0;\\n        long long ans=rec(0,v,cur,mp,dp);\\n        \\n        return( ans-1+mod)%mod;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459799,
                "title": "dp-bitmask-easiely-understandable-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1050];\\n       int mod = 1e9+7;\\n    int prf(int n, vector<int> &m)\\n    {\\n        int d = 0;\\n        for(int i=0;i<10;i++)\\n        {\\n            if(n%m[i]==0)\\n            d = d| (1<<i);\\n        }\\n        return d;\\n    }\\n    long long fn(vector<int>& nums,int i,int bt,vector<int> &m)\\n    {\\n     \\n        if(i==nums.size()){\\n            //cout<<bt<<\"\\\\n\";\\n           return 1;\\n        }\\n        if(dp[i][bt]!=-1)\\n            return dp[i][bt];\\n        \\n        if(nums[i]%4==0 || nums[i]%9==0 || nums[i]%25==0)\\n            return dp[i][bt] = fn(nums,i+1,bt,m)%mod;\\n        \\n        int d = prf(nums[i],m);\\n        if((bt&d)>0)\\n        {\\n            return dp[i][bt] = fn(nums,i+1,bt,m)%mod;\\n        }\\n    return dp[i][bt] = (fn(nums,i+1,bt,m)+ 0LL + fn(nums,i+1,bt|d,m))%mod;\\n    }\\n    \\n    int squareFreeSubsets(vector<int>& nums) {\\n        vector<int> m = {2,3,5,7,11,13,17,19,23,29};\\n        int j = 0;\\n        \\n        int n = nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        return (fn(nums,0,0,m)-1 + mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1050];\\n       int mod = 1e9+7;\\n    int prf(int n, vector<int> &m)\\n    {\\n        int d = 0;\\n        for(int i=0;i<10;i++)\\n        {\\n            if(n%m[i]==0)\\n            d = d| (1<<i);\\n        }\\n        return d;\\n    }\\n    long long fn(vector<int>& nums,int i,int bt,vector<int> &m)\\n    {\\n     \\n        if(i==nums.size()){\\n            //cout<<bt<<\"\\\\n\";\\n           return 1;\\n        }\\n        if(dp[i][bt]!=-1)\\n            return dp[i][bt];\\n        \\n        if(nums[i]%4==0 || nums[i]%9==0 || nums[i]%25==0)\\n            return dp[i][bt] = fn(nums,i+1,bt,m)%mod;\\n        \\n        int d = prf(nums[i],m);\\n        if((bt&d)>0)\\n        {\\n            return dp[i][bt] = fn(nums,i+1,bt,m)%mod;\\n        }\\n    return dp[i][bt] = (fn(nums,i+1,bt,m)+ 0LL + fn(nums,i+1,bt|d,m))%mod;\\n    }\\n    \\n    int squareFreeSubsets(vector<int>& nums) {\\n        vector<int> m = {2,3,5,7,11,13,17,19,23,29};\\n        int j = 0;\\n        \\n        int n = nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        return (fn(nums,0,0,m)-1 + mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3446607,
                "title": "javascript-iterative-dynamic-programming-time-o-n-n-space-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n)$$\\n# Code\\n```\\nvar squareFreeSubsets = function(nums) {\\n    const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29], mod = 1e9 + 7;\\n    const numsFactors = nums\\n        .filter(num => primes.every((prime) => num % prime ** 2 > 0))\\n        .map((num) => primes.reduce((acc, prime) => (acc << 1) | (num % prime == 0), 0));\\n\\n    const prevState = Array(1024).fill(0), curState = Array(1024)\\n    prevState[0] = 1;\\n\\n    for (const numsFactor of numsFactors) {\\n        curState.fill(0);\\n\\n        for (let i = 0; i < 1024; i++) {\\n            if ((i & numsFactor) == 0)\\n                curState[i ^ numsFactor] = \\n                    (curState[i ^ numsFactor] + prevState[i]) % mod;\\n        }\\n\\n        curState.forEach((val, idx) =>\\n            prevState[idx] = (val + prevState[idx]) % mod);\\n    }\\n\\n    return (prevState.reduce((acc, cur) => (acc + cur) % mod) + mod - 1) % mod;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nvar squareFreeSubsets = function(nums) {\\n    const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29], mod = 1e9 + 7;\\n    const numsFactors = nums\\n        .filter(num => primes.every((prime) => num % prime ** 2 > 0))\\n        .map((num) => primes.reduce((acc, prime) => (acc << 1) | (num % prime == 0), 0));\\n\\n    const prevState = Array(1024).fill(0), curState = Array(1024)\\n    prevState[0] = 1;\\n\\n    for (const numsFactor of numsFactors) {\\n        curState.fill(0);\\n\\n        for (let i = 0; i < 1024; i++) {\\n            if ((i & numsFactor) == 0)\\n                curState[i ^ numsFactor] = \\n                    (curState[i ^ numsFactor] + prevState[i]) % mod;\\n        }\\n\\n        curState.forEach((val, idx) =>\\n            prevState[idx] = (val + prevState[idx]) % mod);\\n    }\\n\\n    return (prevState.reduce((acc, cur) => (acc + cur) % mod) + mod - 1) % mod;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3444810,
                "title": "c-full-search-good-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are three key observations to make here:\\n1) A square free integer is represented by a prime decomposition of the following form:\\n$$p^1_1, p^1_2, p^1_3, ..., p^1_k$$\\n\\n2) Given that our numbers are not larger than 30, any product of a subset of them does not contain a prime larger than 30.\\nThis vastly reduces the number of primes that can represent a product.\\nThese primes are: $$\\\\{2,3,5,7,11,13,17,19,23,29\\\\}$$.\\n\\n3) A number can\\'t be repeated on a square free subset, obviously. Yet if $$nums = \\\\{2,2,3\\\\}$$, there are two different subsets whose product is 6, $$\\\\{2,3\\\\}$$ and $$\\\\{2,3\\\\}$$. To generalize this idea: suppose we have $$k$$ different numbers in $$nums$$, for each number we know the number of times it appears in the array, this is going to be represented by a subscript. In the previous example we would have $$\\\\{2_2, 3_1\\\\}$$. To count the number of different subsets that only contain numbers $$\\\\{x_{c1}, y_{c2}, ...,z_{ck}\\\\}$$ is necesary to multiply their subsctripts $$c1, c2, ..., ck$$.\\n\\n4) (3.5 actually) The number $$1$$ is excempt from the previous observation. You may have an array $$\\\\{1,..,1\\\\}$$. Its product is $$1$$, thus not breaking the condition of square freeness. To deal with this we need to count every possible subarray of only ones. This is $$2^{c} - 1$$ where $$c$$ is the number of ones in the array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRepresent numbers number with an array of size 30 + guard. Each position of the array represents a number from 0 to 30. Each value in the array represents a power of that index. For instance, the number $$3^4$$ is represented by $$[0,0,0,4,...,0]$$. By observation 1) checking whether a number is square free or not is straightforward.\\n\\nTo start the algorithm, convert each number to its prime representation. By observation 2) we know there are  very few primes to test. Eliminate the numbers that are not square free (4, 25, etc). This leaves us with at most 18 different numbers to combine.\\n\\nMake all the possible subsets between the remaining numbers. To know the prime representation of the product of a subset, simply combine the representation of each number in the subset. If the product so far is not square free, prune. If a final subset is square free, then calculate all of its possible actual subsets as shown in 3).\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(2^{18})$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\n\\ntypedef long long ll;\\nstatic const int MOD = 1e9+7;\\n\\npublic:\\n\\n    vector<int> fprimes = {2,3,5,7,11,13,17,19,23,29};\\n    \\n    bool divisible_by_squared(array<int, 32>& prod) {\\n        for (int i=0; i<32; i++) {\\n            if (prod[i] > 1) return true;\\n        } \\n        return false;\\n    }\\n\\n    void mergeprod(array<int, 32>& prod, int x) {\\n        for (int& p : fprimes) {\\n            while (x % p == 0) {\\n                prod[p]++;\\n                x/=p;\\n            }\\n        }\\n    }\\n   \\n    void unmergeprod(array<int, 32>& prod, int x) {\\n        for (int& p : fprimes) {\\n            while (x % p == 0) {\\n                prod[p]--;\\n                x/=p;\\n            }\\n        }\\n    }\\n\\n    int mpow(int a, int e) {\\n        if (e == 0) return 1;\\n        if (e % 2 == 0) {\\n            ll r = mpow(a, e/2);\\n            return r*r % MOD;\\n        } else return ((ll)a * mpow(a, e-1)) % MOD;\\n    }\\n\\n    void subsets(map<int, int>::iterator it, array<int, 32>& prod, vector<int>& mprod, map<int, int>& nums, int& ans) {\\n        if (it == nums.end()) {\\n            if (!mprod.empty() && !divisible_by_squared(prod)) {\\n                ll a = 1;\\n                for (int& x : mprod) {\\n                    if (x == 1) a = mpow(2, nums[x]) - 1;\\n                    else {\\n                        a *= nums[x];\\n                    }\\n                    a%=MOD;\\n                }\\n                ans+=a;\\n                ans%=MOD;\\n            }\\n        } else if (!divisible_by_squared(prod)) {\\n            int x = it->first;\\n            mergeprod(prod, x);\\n            mprod.push_back(x);\\n            it++;\\n            subsets(it, prod, mprod, nums, ans);\\n            unmergeprod(prod, x);\\n            mprod.pop_back();\\n            subsets(it, prod, mprod, nums, ans);\\n            it--;\\n        }\\n    }\\n\\n    int squareFreeSubsets(vector<int>& nums) {\\n        map<int, int> cleannums;\\n        for (int& x : nums) {\\n            if (x % 4 != 0 && x % 9 != 0 && x % 25 != 0) {\\n                cleannums[x]++;\\n            }\\n        }\\n        vector<int> mprod;\\n        array<int, 32> prod = {0};\\n        int ans = 0;\\n        auto it = cleannums.begin();\\n        subsets(it, prod, mprod, cleannums, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\ntypedef long long ll;\\nstatic const int MOD = 1e9+7;\\n\\npublic:\\n\\n    vector<int> fprimes = {2,3,5,7,11,13,17,19,23,29};\\n    \\n    bool divisible_by_squared(array<int, 32>& prod) {\\n        for (int i=0; i<32; i++) {\\n            if (prod[i] > 1) return true;\\n        } \\n        return false;\\n    }\\n\\n    void mergeprod(array<int, 32>& prod, int x) {\\n        for (int& p : fprimes) {\\n            while (x % p == 0) {\\n                prod[p]++;\\n                x/=p;\\n            }\\n        }\\n    }\\n   \\n    void unmergeprod(array<int, 32>& prod, int x) {\\n        for (int& p : fprimes) {\\n            while (x % p == 0) {\\n                prod[p]--;\\n                x/=p;\\n            }\\n        }\\n    }\\n\\n    int mpow(int a, int e) {\\n        if (e == 0) return 1;\\n        if (e % 2 == 0) {\\n            ll r = mpow(a, e/2);\\n            return r*r % MOD;\\n        } else return ((ll)a * mpow(a, e-1)) % MOD;\\n    }\\n\\n    void subsets(map<int, int>::iterator it, array<int, 32>& prod, vector<int>& mprod, map<int, int>& nums, int& ans) {\\n        if (it == nums.end()) {\\n            if (!mprod.empty() && !divisible_by_squared(prod)) {\\n                ll a = 1;\\n                for (int& x : mprod) {\\n                    if (x == 1) a = mpow(2, nums[x]) - 1;\\n                    else {\\n                        a *= nums[x];\\n                    }\\n                    a%=MOD;\\n                }\\n                ans+=a;\\n                ans%=MOD;\\n            }\\n        } else if (!divisible_by_squared(prod)) {\\n            int x = it->first;\\n            mergeprod(prod, x);\\n            mprod.push_back(x);\\n            it++;\\n            subsets(it, prod, mprod, nums, ans);\\n            unmergeprod(prod, x);\\n            mprod.pop_back();\\n            subsets(it, prod, mprod, nums, ans);\\n            it--;\\n        }\\n    }\\n\\n    int squareFreeSubsets(vector<int>& nums) {\\n        map<int, int> cleannums;\\n        for (int& x : nums) {\\n            if (x % 4 != 0 && x % 9 != 0 && x % 25 != 0) {\\n                cleannums[x]++;\\n            }\\n        }\\n        vector<int> mprod;\\n        array<int, 32> prod = {0};\\n        int ans = 0;\\n        auto it = cleannums.begin();\\n        subsets(it, prod, mprod, cleannums, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374546,
                "title": "java-4-ms-bitmask-backtracking-faster-than-97-68-less-than-90-35",
                "content": "# Intuition\\nIf using backtracking on nums, definitely we will see TTL. (2^1000)\\nBut 1 <= nums[i] <= 30, means we can convert nums to the frequency of each num. Then, array lenght will become 30 and it is acceptable.\\n\\n\\n# Approach\\n1. Count the frequence on each num but skip non-squarefree number. Besides, Number 1 has different counting. EX: 2 times number 1 means 3 combination {{1}, {1}, {1,1}}\\n2. Get the bitmask of each num but convert non-squarefree number to 1023 and convert 1 to 0\\n3. Start backtracking from position 30 to position 0\\n4. Stop at position 0 and add count to result\\n\\n# Complexity\\n- Time complexity: O(n)\\n    - Count frequence O(n)\\n    - backtracking O(1), always backtracking from position 30 to position 0\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[] counts;\\n    int[] codes;\\n    long sum;\\n    public int squareFreeSubsets(int[] nums) {\\n        int test = 0;\\n        counts = new int[31];\\n        for (int num : nums) {\\n            if (num%4 == 0 || num%9 == 0 || num%16 == 0 || num%25 == 0) continue;\\n            if (num == 1) {\\n                counts[num] += (counts[num]+1);\\n                counts[num] %= 1000000007;\\n            }\\n            else counts[num]++;\\n        }\\n        codes = new int[] { 0, 0, 1, 2, 1023, 4, 3, 8, 1023, 1023, 5,\\n                            16, 1023, 32, 9, 6, 1023, 64, 1023, 128, 1023,\\n                            10, 17, 256, 1023, 1023, 33, 1023, 1023, 512, 7 };\\n        backtracking(30, 0, 0);\\n        return (int) sum;\\n    }\\n\\n    private void backtracking(int position, int code, long count) {\\n        if (position == 0) {\\n            sum += count;\\n            sum %= 1000000007;\\n        }\\n        else {\\n            backtracking(position-1, code, count);\\n            if (counts[position] != 0 && (code & codes[position]) == 0) {\\n                count = count == 0 ? counts[position] : count*counts[position];\\n                count %= 1000000007;\\n                backtracking(position-1, code | codes[position], count);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    int[] counts;\\n    int[] codes;\\n    long sum;\\n    public int squareFreeSubsets(int[] nums) {\\n        int test = 0;\\n        counts = new int[31];\\n        for (int num : nums) {\\n            if (num%4 == 0 || num%9 == 0 || num%16 == 0 || num%25 == 0) continue;\\n            if (num == 1) {\\n                counts[num] += (counts[num]+1);\\n                counts[num] %= 1000000007;\\n            }\\n            else counts[num]++;\\n        }\\n        codes = new int[] { 0, 0, 1, 2, 1023, 4, 3, 8, 1023, 1023, 5,\\n                            16, 1023, 32, 9, 6, 1023, 64, 1023, 128, 1023,\\n                            10, 17, 256, 1023, 1023, 33, 1023, 1023, 512, 7 };\\n        backtracking(30, 0, 0);\\n        return (int) sum;\\n    }\\n\\n    private void backtracking(int position, int code, long count) {\\n        if (position == 0) {\\n            sum += count;\\n            sum %= 1000000007;\\n        }\\n        else {\\n            backtracking(position-1, code, count);\\n            if (counts[position] != 0 && (code & codes[position]) == 0) {\\n                count = count == 0 ? counts[position] : count*counts[position];\\n                count %= 1000000007;\\n                backtracking(position-1, code | codes[position], count);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341432,
                "title": "c-o-n-recursively-via-dfs-count-build-subsets-based-on-ordered-frequency",
                "content": "```\\n// Recursively (via dfs) count/build subsets based on ordered frequency\\nclass Solution {\\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        map<int,int> freq;\\n        for(auto n : nums) {\\n            if(n%4 && n%9 && n%25) \\n                freq[n]++;\\n        }\\n        using ull = unsigned long long;\\n        constexpr int mod = 1000\\'000\\'007;\\n        \\n        function<ull(map<int,int>)> dfs;\\n        dfs = [this, &dfs] (map<int,int> freq) {\\n            //[1] base case: empty or all 1s\\n            if(freq.empty()) return 1ULL;\\n\\n            auto [n, occurrence] = *freq.rbegin();\\n            if(n == 1) { // subsets = 2^occurrence\\n                ull ret = 1;\\n                for(int pass = occurrence/32; pass; --pass)\\n                    ret = (ret << 32) % mod;\\n                return (ret << (occurrence % 32)) % mod;\\n            }\\n\\n            //[2] induction step: either pick or skip current on top of induction result\\n            //Note: there are \\'occurrence\\' ways to pick and 1 way to skip (see 2 returns below)\\n            freq.erase(n);\\n            ull recurse = dfs(freq);\\n\\n            bool hasconflict = false;\\n            for(auto i = freq.begin(); i != freq.end();) {\\n                if(gcd(n, i->first) > 1) {\\n                    i = freq.erase(i);\\n                    hasconflict = true;\\n                }\\n                else\\n                    ++i;\\n            }\\n            if(!hasconflict)\\n                return recurse * (occurrence+1) % mod; \\n\\n            return recurse + (dfs(freq) * occurrence) % mod;\\n        };\\n\\n        return (dfs(freq) - 1) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Recursively (via dfs) count/build subsets based on ordered frequency\\nclass Solution {\\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        map<int,int> freq;\\n        for(auto n : nums) {\\n            if(n%4 && n%9 && n%25) \\n                freq[n]++;\\n        }\\n        using ull = unsigned long long;\\n        constexpr int mod = 1000\\'000\\'007;\\n        \\n        function<ull(map<int,int>)> dfs;\\n        dfs = [this, &dfs] (map<int,int> freq) {\\n            //[1] base case: empty or all 1s\\n            if(freq.empty()) return 1ULL;\\n\\n            auto [n, occurrence] = *freq.rbegin();\\n            if(n == 1) { // subsets = 2^occurrence\\n                ull ret = 1;\\n                for(int pass = occurrence/32; pass; --pass)\\n                    ret = (ret << 32) % mod;\\n                return (ret << (occurrence % 32)) % mod;\\n            }\\n\\n            //[2] induction step: either pick or skip current on top of induction result\\n            //Note: there are \\'occurrence\\' ways to pick and 1 way to skip (see 2 returns below)\\n            freq.erase(n);\\n            ull recurse = dfs(freq);\\n\\n            bool hasconflict = false;\\n            for(auto i = freq.begin(); i != freq.end();) {\\n                if(gcd(n, i->first) > 1) {\\n                    i = freq.erase(i);\\n                    hasconflict = true;\\n                }\\n                else\\n                    ++i;\\n            }\\n            if(!hasconflict)\\n                return recurse * (occurrence+1) % mod; \\n\\n            return recurse + (dfs(freq) * occurrence) % mod;\\n        };\\n\\n        return (dfs(freq) - 1) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328357,
                "title": "c",
                "content": "```\\nclass Solution {\\n    int M  = 1e9 + 7 ;\\n    vector<int>primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29} ;\\n    int decode(int n){\\n        int ret = 0 ;\\n        for(int i = 0 ; i < 10; i++){\\n            int cn = 0 ;\\n            while((n % primes[i]) == 0){\\n                cn++ ;\\n                n /= primes[i] ;\\n            }\\n            if(cn > 1)\\n                return -1 ;\\n            if(cn == 1)\\n                ret += (1 << i) ;\\n        }\\n        return ret ;\\n    }\\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        long long ret = 0 ;\\n        nums.insert(nums.begin(), 0 ) ;\\n        int n = nums.size() ;\\n        vector<vector<long long>>dp(n, vector<long long>(1 << 10)) ;   // {items, state}\\n        dp[0][0] = 1 ;  // 0 itesm create state 0\\n        \\n        for(int i = 1; i < n; i++){\\n            for(int j = 0; j < (1 << 10) ; j++){\\n                if(nums[i] == 1){\\n                    dp[i][j] = 2 * dp[i-1][j] % M ;\\n                    continue ;\\n                }\\n                dp[i][j] = dp[i-1][j] ;   //i \\u4E0D\\u9078\\n                int d = decode(nums[i]) ;\\n                if(d == -1)\\n                    continue ;\\n                if((j & d) == d)\\n                    dp[i][j] =  (dp[i][j] + dp[i-1][j-d] ) % M;\\n            }   \\n        }\\n        \\n        for(int i = 0 ; i < 1 << 10; i++)\\n            ret  = (ret + dp[n-1][i]) % M ;\\n        \\n        return (ret + M - 1) % M ;   //\\u6E1B\\u53BBempty\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int M  = 1e9 + 7 ;\\n    vector<int>primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29} ;\\n    int decode(int n){\\n        int ret = 0 ;\\n        for(int i = 0 ; i < 10; i++){\\n            int cn = 0 ;\\n            while((n % primes[i]) == 0){\\n                cn++ ;\\n                n /= primes[i] ;\\n            }\\n            if(cn > 1)\\n                return -1 ;\\n            if(cn == 1)\\n                ret += (1 << i) ;\\n        }\\n        return ret ;\\n    }\\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        long long ret = 0 ;\\n        nums.insert(nums.begin(), 0 ) ;\\n        int n = nums.size() ;\\n        vector<vector<long long>>dp(n, vector<long long>(1 << 10)) ;   // {items, state}\\n        dp[0][0] = 1 ;  // 0 itesm create state 0\\n        \\n        for(int i = 1; i < n; i++){\\n            for(int j = 0; j < (1 << 10) ; j++){\\n                if(nums[i] == 1){\\n                    dp[i][j] = 2 * dp[i-1][j] % M ;\\n                    continue ;\\n                }\\n                dp[i][j] = dp[i-1][j] ;   //i \\u4E0D\\u9078\\n                int d = decode(nums[i]) ;\\n                if(d == -1)\\n                    continue ;\\n                if((j & d) == d)\\n                    dp[i][j] =  (dp[i][j] + dp[i-1][j-d] ) % M;\\n            }   \\n        }\\n        \\n        for(int i = 0 ; i < 1 << 10; i++)\\n            ret  = (ret + dp[n-1][i]) % M ;\\n        \\n        return (ret + M - 1) % M ;   //\\u6E1B\\u53BBempty\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268202,
                "title": "c-dp-bitmask-count-the-number-of-square-free-subsets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    ll binpow(ll a, ll b, ll md){ll res=1;a%=md;if(a==0)return 0;while(b!=0){if(b&1)res*=a,res%=md;a*=a,a%=md;b>>=1;}return res%md;}\\n\\n\\n    int dp[35][(1<<10)+10]; // # of distinct element <= 30 and # of primes <=10 if nums[i]<= 30         \\n    map<int,int> mp,revmp;\\n    vector<int> primes;\\n    int rec(int level, int mask, int n, vector<int> &nums, bool ff){\\n        int MOD = 1e9+7;\\n        if(level==n){\\n            if(mask != 0 || ff)\\n                return 1;\\n            return 0;\\n        }\\n        if(dp[level][mask] != -1) return dp[level][mask];\\n        int ans = 0;\\n        if(nums[level]==1){\\n            ans = (ans%MOD + ((binpow(2,mp2[nums[level]],MOD)%MOD)*(rec(level+1,mask,n,nums,1))%MOD)%MOD); \\n            return dp[level][mask]=ans%MOD;\\n        }\\n        ans = rec(level+1,mask,n,nums,ff);\\n        int ar = nums[level];\\n        vector<int> temp;\\n        for(auto x: primes){\\n            if(x*x>ar) break;\\n            if(ar%x==0){\\n                temp.push_back(x);\\n                while(ar && ar%x==0) ar/=x;\\n            }\\n        }        \\n        if(ar>1){\\n            temp.push_back(ar);\\n        }\\n        bool f = true;\\n        int nm = mask;\\n        for(auto x: temp){\\n            int id = revmp[x];\\n            if(mask & (1<<id)){\\n                f = false;\\n                break;\\n            }\\n            nm |= (1<<id);\\n        }\\n        if(f){\\n            long long t1 = rec(level+1,nm,n,nums,ff)%MOD;\\n            t1 = ((mp[nums[level]])*t1)%MOD;\\n           ans = (ans%MOD + t1)%MOD; \\n        }\\n        return dp[level][mask]=ans%MOD;\\n    }\\n    \\n    int squareFreeSubsets(vector<int>& nums) {\\n        set<int> st;\\n        vector<int> discard = {4,8,9,12,16,18,20,24,25,27,28};\\n        for(auto x: discard){\\n            st.insert(x);\\n            \\n        }\\n        primes = {2,3,5,7,11,13,17,19,23,29};\\n        for(int i=0; i<primes.size(); i++){\\n            revmp[primes[i]]=i; // Reverse Mapping the index to prime nos\\n        }\\n        vector<int> newnums;\\n        ll cnt = 0;\\n        for(auto x: nums){\\n            if(st.find(x) == st.end()) newnums.push_back(x);\\n            st.insert(x); // Removing duplicates in newnums array\\n            mp[x]++;\\n        }\\n        int mask = 0;\\n        int n = newnums.size();\\n        for(int i=0; i<=n; i++){\\n            for(int j=0; j<(1<<10)+5; j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        int MOD = 1e9+7;\\n        long long ans = rec(0,0,n,newnums,0);\\n        if(mp[1]) ans--; // It contains the case of when no one is taken, but we have to discard that case\\n        ans = (ans+MOD);\\n        ans = (ans)%MOD;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    ll binpow(ll a, ll b, ll md){ll res=1;a%=md;if(a==0)return 0;while(b!=0){if(b&1)res*=a,res%=md;a*=a,a%=md;b>>=1;}return res%md;}\\n\\n\\n    int dp[35][(1<<10)+10]; // # of distinct element <= 30 and # of primes <=10 if nums[i]<= 30         \\n    map<int,int> mp,revmp;\\n    vector<int> primes;\\n    int rec(int level, int mask, int n, vector<int> &nums, bool ff){\\n        int MOD = 1e9+7;\\n        if(level==n){\\n            if(mask != 0 || ff)\\n                return 1;\\n            return 0;\\n        }\\n        if(dp[level][mask] != -1) return dp[level][mask];\\n        int ans = 0;\\n        if(nums[level]==1){\\n            ans = (ans%MOD + ((binpow(2,mp2[nums[level]],MOD)%MOD)*(rec(level+1,mask,n,nums,1))%MOD)%MOD); \\n            return dp[level][mask]=ans%MOD;\\n        }\\n        ans = rec(level+1,mask,n,nums,ff);\\n        int ar = nums[level];\\n        vector<int> temp;\\n        for(auto x: primes){\\n            if(x*x>ar) break;\\n            if(ar%x==0){\\n                temp.push_back(x);\\n                while(ar && ar%x==0) ar/=x;\\n            }\\n        }        \\n        if(ar>1){\\n            temp.push_back(ar);\\n        }\\n        bool f = true;\\n        int nm = mask;\\n        for(auto x: temp){\\n            int id = revmp[x];\\n            if(mask & (1<<id)){\\n                f = false;\\n                break;\\n            }\\n            nm |= (1<<id);\\n        }\\n        if(f){\\n            long long t1 = rec(level+1,nm,n,nums,ff)%MOD;\\n            t1 = ((mp[nums[level]])*t1)%MOD;\\n           ans = (ans%MOD + t1)%MOD; \\n        }\\n        return dp[level][mask]=ans%MOD;\\n    }\\n    \\n    int squareFreeSubsets(vector<int>& nums) {\\n        set<int> st;\\n        vector<int> discard = {4,8,9,12,16,18,20,24,25,27,28};\\n        for(auto x: discard){\\n            st.insert(x);\\n            \\n        }\\n        primes = {2,3,5,7,11,13,17,19,23,29};\\n        for(int i=0; i<primes.size(); i++){\\n            revmp[primes[i]]=i; // Reverse Mapping the index to prime nos\\n        }\\n        vector<int> newnums;\\n        ll cnt = 0;\\n        for(auto x: nums){\\n            if(st.find(x) == st.end()) newnums.push_back(x);\\n            st.insert(x); // Removing duplicates in newnums array\\n            mp[x]++;\\n        }\\n        int mask = 0;\\n        int n = newnums.size();\\n        for(int i=0; i<=n; i++){\\n            for(int j=0; j<(1<<10)+5; j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        int MOD = 1e9+7;\\n        long long ans = rec(0,0,n,newnums,0);\\n        if(mp[1]) ans--; // It contains the case of when no one is taken, but we have to discard that case\\n        ans = (ans+MOD);\\n        ans = (ans)%MOD;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261957,
                "title": "dp-bitmask",
                "content": "\\n# Approach\\nfirst start with empty mask 00000000 \\nevery indx in the mask represent the prime number \\n1 if has appear ans 0 otherwise \\nwe can only take the number if and only if the prime was 0 in the mask\\n\\n# Complexity\\n- Time complexity:\\nO(n*1024)\\n\\n- Space complexity:\\nO(n*1024)\\n# Code\\n```\\nclass Solution {\\npublic:\\n int arr[11]={2,3,5,7,11,13,17,19,23,29};\\n  int idx[31];\\n vector<vector<int>>primes;\\n int dp[1001][1<<10|1];\\n int mod=1e9+7;\\n  int rec(int i,int msk,vector<int>&v){\\n   if(i==v.size())return 0;\\n    int &ret=dp[i][msk];\\n    if(~ret)return ret;\\n    ret=rec(i+1,msk,v)%mod; // leave \\n    bool ok=1;\\n    int tmsk=msk;\\n    for(auto &p : primes[v[i]]){\\n      ok &= (tmsk&(1<<idx[p]))==0; // if all prime numbers in v[i] does not present in msk then true\\n      tmsk|=(1<<idx[p]);\\n    }\\n    if(ok)ret+=1+rec(i+1,tmsk,v)%mod; // 1 + go with the new msk\\n    return ret%mod;\\n  }\\n\\n  int squareFreeSubsets(vector<int>& v) {\\n     primes=vector<vector<int>>(31);\\n     for(int i=0;i<11;++i)idx[arr[i]]=i;\\n\\n     for(int i=1;i<=30;++i){\\n          int m=i;\\n         for(int j=2;j*j<=m;++j){\\n             while(m%j==0){\\n                 m/=j;\\n                 primes[i].push_back(j);\\n             }\\n         }\\n         if(m>1)primes[i].push_back(m);\\n     }\\n      memset(dp,-1,sizeof dp);\\n     return rec(0,0,v)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int arr[11]={2,3,5,7,11,13,17,19,23,29};\\n  int idx[31];\\n vector<vector<int>>primes;\\n int dp[1001][1<<10|1];\\n int mod=1e9+7;\\n  int rec(int i,int msk,vector<int>&v){\\n   if(i==v.size())return 0;\\n    int &ret=dp[i][msk];\\n    if(~ret)return ret;\\n    ret=rec(i+1,msk,v)%mod; // leave \\n    bool ok=1;\\n    int tmsk=msk;\\n    for(auto &p : primes[v[i]]){\\n      ok &= (tmsk&(1<<idx[p]))==0; // if all prime numbers in v[i] does not present in msk then true\\n      tmsk|=(1<<idx[p]);\\n    }\\n    if(ok)ret+=1+rec(i+1,tmsk,v)%mod; // 1 + go with the new msk\\n    return ret%mod;\\n  }\\n\\n  int squareFreeSubsets(vector<int>& v) {\\n     primes=vector<vector<int>>(31);\\n     for(int i=0;i<11;++i)idx[arr[i]]=i;\\n\\n     for(int i=1;i<=30;++i){\\n          int m=i;\\n         for(int j=2;j*j<=m;++j){\\n             while(m%j==0){\\n                 m/=j;\\n                 primes[i].push_back(j);\\n             }\\n         }\\n         if(m>1)primes[i].push_back(m);\\n     }\\n      memset(dp,-1,sizeof dp);\\n     return rec(0,0,v)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259527,
                "title": "python-dp-solution-bitmask-leetcode-1994",
                "content": "```\\ndef squareFreeSubsets(self, nums: List[int]) -> int:\\n\\tcans, mod = {2,3,5,6,7,10,11,13,14,15,17,19,21,22,23,26,29,30}, 10**9+7\\n\\tcnter = {k:v for k, v in Counter(nums).items() if k in cans}\\n\\tdp, x = Counter([1]), pow(2, nums.count(1), mod)\\n\\tfor i in cnter:\\n\\t\\tdp_cur = Counter()\\n\\t\\tfor k in dp:\\n\\t\\t\\tdp_cur[k] += dp[k]\\n\\t\\t\\tif gcd(i, k)==1:\\n\\t\\t\\t\\tdp_cur[i*k] += dp[k]*cnter[i]\\n\\t\\tdp = {k:dp_cur[k]%mod for k in dp_cur}\\n\\treturn (sum(dp.values())*x-1)%mod\\n```\\nThe following solution is to apply `bitmask trick` for prime factor.\\nIt should work faster with large size of data\\n```\\ndef squareFreeSubsets(self, nums: List[int]) -> int:\\n\\tdef prime_mask(x):\\n\\t\\tmask = 0\\n\\t\\tfor i in range(2, int(sqrt(x))+1):\\n\\t\\t\\tif x%i==0:\\n\\t\\t\\t\\tx //= i\\n\\t\\t\\t\\tmask |= (1<<i)\\n\\t\\treturn mask|(1<<x) if x>1 else mask\\n\\n\\tcans, mod = {2,3,5,6,7,10,11,13,14,15,17,19,21,22,23,26,29,30}, 10**9+7\\n\\tcnter = {prime_mask(k):v for k, v in Counter(nums).items() if k in cans}\\n\\tdp, x = Counter([2]), pow(2, nums.count(1), mod)\\n\\t# bitmask of 1 is 1<<1=2\\n\\tfor i in cnter:\\n\\t\\tdp_cur = Counter()\\n\\t\\tfor k in dp:\\n\\t\\t\\tdp_cur[k] += dp[k]\\n\\t\\t\\tif i&k==0:\\n\\t\\t\\t\\tdp_cur[i|k]+=dp[k]*cnter[i]\\n\\t\\tdp = {k:dp_cur[k]%mod for k in dp_cur}\\n\\treturn (sum(dp.values())*x-1)%mod\\n```\\nNote this is an MEDIUM version of [**Leetcode 1994**](https://leetcode.com/problems/the-number-of-good-subsets/). \\nThe only difference is on **the subset with product 1**.\\nYou can check my post [**HERE**](https://leetcode.com/problems/the-number-of-good-subsets/discuss/3269570/Python-dp-solution-or-bitmask-or-Leetcode-2572).",
                "solutionTags": [],
                "code": "```\\ndef squareFreeSubsets(self, nums: List[int]) -> int:\\n\\tcans, mod = {2,3,5,6,7,10,11,13,14,15,17,19,21,22,23,26,29,30}, 10**9+7\\n\\tcnter = {k:v for k, v in Counter(nums).items() if k in cans}\\n\\tdp, x = Counter([1]), pow(2, nums.count(1), mod)\\n\\tfor i in cnter:\\n\\t\\tdp_cur = Counter()\\n\\t\\tfor k in dp:\\n\\t\\t\\tdp_cur[k] += dp[k]\\n\\t\\t\\tif gcd(i, k)==1:\\n\\t\\t\\t\\tdp_cur[i*k] += dp[k]*cnter[i]\\n\\t\\tdp = {k:dp_cur[k]%mod for k in dp_cur}\\n\\treturn (sum(dp.values())*x-1)%mod\\n```\n```\\ndef squareFreeSubsets(self, nums: List[int]) -> int:\\n\\tdef prime_mask(x):\\n\\t\\tmask = 0\\n\\t\\tfor i in range(2, int(sqrt(x))+1):\\n\\t\\t\\tif x%i==0:\\n\\t\\t\\t\\tx //= i\\n\\t\\t\\t\\tmask |= (1<<i)\\n\\t\\treturn mask|(1<<x) if x>1 else mask\\n\\n\\tcans, mod = {2,3,5,6,7,10,11,13,14,15,17,19,21,22,23,26,29,30}, 10**9+7\\n\\tcnter = {prime_mask(k):v for k, v in Counter(nums).items() if k in cans}\\n\\tdp, x = Counter([2]), pow(2, nums.count(1), mod)\\n\\t# bitmask of 1 is 1<<1=2\\n\\tfor i in cnter:\\n\\t\\tdp_cur = Counter()\\n\\t\\tfor k in dp:\\n\\t\\t\\tdp_cur[k] += dp[k]\\n\\t\\t\\tif i&k==0:\\n\\t\\t\\t\\tdp_cur[i|k]+=dp[k]*cnter[i]\\n\\t\\tdp = {k:dp_cur[k]%mod for k in dp_cur}\\n\\treturn (sum(dp.values())*x-1)%mod\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3253517,
                "title": "bitmask-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int mod=1000000007;\\n    long long dp[1000][1025][2];\\n    long long count(int j,int mask,vector<int>&res,int x){\\n        \\n        if(j==res.size()){\\n        \\n            if(x==0)return 0;\\n            return 1;\\n        }\\n        if(dp[j][mask][x]!=-1)return dp[j][mask][x];\\n        \\n        long long ans=0ll;\\n        \\n        if(res[j]==-1){\\n            return dp[j][mask][x]=count(j+1,mask,res,x);\\n        }\\n        \\n        ans=count(j+1,mask,res,x);\\n        \\n        if((mask&res[j])==0){\\n         ans= ((ans%mod)+count(j+1,mask|res[j],res,1)%mod)%mod;\\n        }\\n        \\n        return dp[j][mask][x]=ans;\\n       \\n    }\\n    \\n    int squareFreeSubsets(vector<int>& nums) {\\n        vector<int>prime{2,3,5,7,11,13,17,19,23,29};\\n        vector<int>res;\\n        int n= nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<n;i++){\\n            int x=nums[i];\\n            int j=0;\\n            int mask=0;\\n            while(x!=1){\\n                int k=0;\\n                while(x%prime[j]==0){\\n                    mask=(mask|(1<<j));\\n                    x=x/prime[j];\\n                    k++;\\n                }\\n                if(k>1){\\n                    mask=-1;\\n                    break;\\n                }\\n                j++;\\n            }\\n            res.push_back(mask);\\n        }\\n        return count(0,0,res,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int mod=1000000007;\\n    long long dp[1000][1025][2];\\n    long long count(int j,int mask,vector<int>&res,int x){\\n        \\n        if(j==res.size()){\\n        \\n            if(x==0)return 0;\\n            return 1;\\n        }\\n        if(dp[j][mask][x]!=-1)return dp[j][mask][x];\\n        \\n        long long ans=0ll;\\n        \\n        if(res[j]==-1){\\n            return dp[j][mask][x]=count(j+1,mask,res,x);\\n        }\\n        \\n        ans=count(j+1,mask,res,x);\\n        \\n        if((mask&res[j])==0){\\n         ans= ((ans%mod)+count(j+1,mask|res[j],res,1)%mod)%mod;\\n        }\\n        \\n        return dp[j][mask][x]=ans;\\n       \\n    }\\n    \\n    int squareFreeSubsets(vector<int>& nums) {\\n        vector<int>prime{2,3,5,7,11,13,17,19,23,29};\\n        vector<int>res;\\n        int n= nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<n;i++){\\n            int x=nums[i];\\n            int j=0;\\n            int mask=0;\\n            while(x!=1){\\n                int k=0;\\n                while(x%prime[j]==0){\\n                    mask=(mask|(1<<j));\\n                    x=x/prime[j];\\n                    k++;\\n                }\\n                if(k>1){\\n                    mask=-1;\\n                    break;\\n                }\\n                j++;\\n            }\\n            res.push_back(mask);\\n        }\\n        return count(0,0,res,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250256,
                "title": "100-java-bit-computing-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    final int MOD = 1_000_000_007;\\n    int[] pr = {2,3,5,7,11,13,17,19,23,29};\\n    int[] dp = new int[1<<10], tp = new int[1<<10];\\n    public int squareFreeSubsets(int[] nums) {\\n        dp[0]=0;\\n        int b;\\n        for(int n:nums){\\n            b = toBit(n);\\n            if(b<0)continue;\\n            tp[b]++; tp[b]%=MOD;\\n            for(int i=0; i< 1<<10; i++){\\n                if((b&i)>0)continue;\\n                tp[(b|i)]+=dp[i];\\n                tp[(b|i)]%=MOD;\\n            }\\n\\n            for(int i=0; i< 1<<10; i++){\\n                dp[i] += tp[i]; dp[i]%=MOD;\\n                tp[i]=0;\\n            }\\n        }\\n        int ans=0;\\n        for(int n:dp){\\n            ans+=n; ans%=MOD;\\n        }\\n        return ans;\\n    }\\n    private int toBit(int n){\\n        int r=0;\\n        for(int i=0; i<10; i++){\\n            if(n%pr[i]==0){\\n                r+=1<<i; n/=pr[i];\\n                if(n%pr[i]==0)return -1;\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    final int MOD = 1_000_000_007;\\n    int[] pr = {2,3,5,7,11,13,17,19,23,29};\\n    int[] dp = new int[1<<10], tp = new int[1<<10];\\n    public int squareFreeSubsets(int[] nums) {\\n        dp[0]=0;\\n        int b;\\n        for(int n:nums){\\n            b = toBit(n);\\n            if(b<0)continue;\\n            tp[b]++; tp[b]%=MOD;\\n            for(int i=0; i< 1<<10; i++){\\n                if((b&i)>0)continue;\\n                tp[(b|i)]+=dp[i];\\n                tp[(b|i)]%=MOD;\\n            }\\n\\n            for(int i=0; i< 1<<10; i++){\\n                dp[i] += tp[i]; dp[i]%=MOD;\\n                tp[i]=0;\\n            }\\n        }\\n        int ans=0;\\n        for(int n:dp){\\n            ans+=n; ans%=MOD;\\n        }\\n        return ans;\\n    }\\n    private int toBit(int n){\\n        int r=0;\\n        for(int i=0; i<10; i++){\\n            if(n%pr[i]==0){\\n                r+=1<<i; n/=pr[i];\\n                if(n%pr[i]==0)return -1;\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247630,
                "title": "bitmask-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbitmask + dp\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbitmask + dp\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    int getv(int p[], int v) \\n    {\\n        if (v == 1)\\n            return 0;\\n        int index = 1;\\n        int res = 0;\\n        for(int i=0; i<10; i++)\\n        {\\n            if (v % (p[i] * p[i]) == 0)\\n                return -1;\\n            if (v % p[i] == 0)\\n                res |= index;\\n            index <<= 1;\\n        }\\n        return res;\\n    }\\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        int p[] = {2,3,5,7,11,13,17,19,23,29};\\n        int c = 1<<10, rem = 1000000007;\\n        int res = 0;\\n        vector<int> sum(c,0);\\n        for (int j=0; j<nums.size(); j++)\\n        {\\n            int n = getv(p, nums[j]);\\n            if (n == -1)\\n                continue;\\n            //cout<<j<<\":\"<<n<<\"\\\\n\";\\n            for (int i=0; i<c; i++)\\n            {\\n                if ((n & i) == 0 && sum[i] != 0)\\n                {\\n                    res = (res + sum[i]) % rem;\\n                    sum[i|n] = (sum[i|n] + sum[i]) % rem;\\n                }\\n            }\\n            sum[n] = (sum[n] + 1) % rem;\\n            res = (res + 1) % rem;\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int getv(int p[], int v) \\n    {\\n        if (v == 1)\\n            return 0;\\n        int index = 1;\\n        int res = 0;\\n        for(int i=0; i<10; i++)\\n        {\\n            if (v % (p[i] * p[i]) == 0)\\n                return -1;\\n            if (v % p[i] == 0)\\n                res |= index;\\n            index <<= 1;\\n        }\\n        return res;\\n    }\\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        int p[] = {2,3,5,7,11,13,17,19,23,29};\\n        int c = 1<<10, rem = 1000000007;\\n        int res = 0;\\n        vector<int> sum(c,0);\\n        for (int j=0; j<nums.size(); j++)\\n        {\\n            int n = getv(p, nums[j]);\\n            if (n == -1)\\n                continue;\\n            //cout<<j<<\":\"<<n<<\"\\\\n\";\\n            for (int i=0; i<c; i++)\\n            {\\n                if ((n & i) == 0 && sum[i] != 0)\\n                {\\n                    res = (res + sum[i]) % rem;\\n                    sum[i|n] = (sum[i|n] + sum[i]) % rem;\\n                }\\n            }\\n            sum[n] = (sum[n] + 1) % rem;\\n            res = (res + 1) % rem;\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3240390,
                "title": "kotlin-bitmap-dp-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    val primeNumbers = intArrayOf(2, 3, 5, 7, 11, 13, 17, 19, 23, 29)\\n                                //0  0  0  0   0   0   0   0   0   0\\n    fun squareFreeSubsets(nums: IntArray): Int {\\n        val squareFreeList = nums.filter{ isSquareFree(it) }.map{ convertToBitmap(it) }\\n        val dp = Array(squareFreeList.size + 1){ IntArray(1 shl 11){ -1 } }\\n        \\n        return dfs(0, 0, dp, squareFreeList)\\n    }\\n    \\n    fun dfs(idx: Int, bitmask: Int, dp: Array<IntArray>, squareFreeList: List<Int>): Int {\\n        if (idx >= squareFreeList.size) return 0\\n        if (dp[idx][bitmask] > 0) return dp[idx][bitmask]\\n        \\n        val curr = squareFreeList.get(idx)\\n        var count = dfs(idx + 1, bitmask, dp, squareFreeList);\\n        \\n        if (bitmask and curr == 0) {\\n            count = (count + 1 + dfs(idx + 1, bitmask or curr, dp, squareFreeList)) % 1000000007;\\n        }\\n        \\n        dp[idx][bitmask] = count\\n        \\n        return count\\n    }\\n    \\n    fun convertToBitmap(num: Int): Int {\\n        var i = 0\\n        var result = 0\\n        for(pn in primeNumbers) {\\n            if (num % pn == 0) {\\n                result += 1 shl i\\n            }\\n            i++\\n        }\\n        \\n        return result\\n    }\\n    \\n    fun isSquareFree(num: Int): Boolean {\\n        for(pn in primeNumbers) {\\n            if (num % (pn * pn) == 0) return false\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    val primeNumbers = intArrayOf(2, 3, 5, 7, 11, 13, 17, 19, 23, 29)\\n                                //0  0  0  0   0   0   0   0   0   0\\n    fun squareFreeSubsets(nums: IntArray): Int {\\n        val squareFreeList = nums.filter{ isSquareFree(it) }.map{ convertToBitmap(it) }\\n        val dp = Array(squareFreeList.size + 1){ IntArray(1 shl 11){ -1 } }\\n        \\n        return dfs(0, 0, dp, squareFreeList)\\n    }\\n    \\n    fun dfs(idx: Int, bitmask: Int, dp: Array<IntArray>, squareFreeList: List<Int>): Int {\\n        if (idx >= squareFreeList.size) return 0\\n        if (dp[idx][bitmask] > 0) return dp[idx][bitmask]\\n        \\n        val curr = squareFreeList.get(idx)\\n        var count = dfs(idx + 1, bitmask, dp, squareFreeList);\\n        \\n        if (bitmask and curr == 0) {\\n            count = (count + 1 + dfs(idx + 1, bitmask or curr, dp, squareFreeList)) % 1000000007;\\n        }\\n        \\n        dp[idx][bitmask] = count\\n        \\n        return count\\n    }\\n    \\n    fun convertToBitmap(num: Int): Int {\\n        var i = 0\\n        var result = 0\\n        for(pn in primeNumbers) {\\n            if (num % pn == 0) {\\n                result += 1 shl i\\n            }\\n            i++\\n        }\\n        \\n        return result\\n    }\\n    \\n    fun isSquareFree(num: Int): Boolean {\\n        for(pn in primeNumbers) {\\n            if (num % (pn * pn) == 0) return false\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238484,
                "title": "java-gcd-backtracking-solution",
                "content": "```\\n    class Solution {\\n        long res = 0, mod = (long)1e9 + 7, multiplier;\\n        int[] count;\\n        public int squareFreeSubsets(int[] nums) {\\n            count = new int[31];\\n            for (int num : nums) {\\n                ++count[num];\\n            }\\n            // multiplier means we can take any number of \\'1\\' we want\\n            multiplier = (long)(Math.pow(2, count[1]) % mod);\\n            // initiate res to be only take \\'1\\'\\n            res = (multiplier - 1) % mod;\\n\\n            // start by taking number greater than 1\\n            for (int i = 2; i <= 30 ; i++) {\\n                // 4 9 16 25 and their multiplier cannot be chosen\\n                if (i % 4 == 0 || i % 9 == 0 || i % 16 == 0 || i % 25 == 0)\\n                    continue;\\n                dfs(i, 1, 1);\\n            }\\n\\n            return (int)res;\\n        }\\n\\n        private int gcd(int a, int b) {\\n            if (b == 0) {\\n                return a;\\n            }\\n            return gcd(b, a % b);\\n        }\\n\\n        private void dfs(int num, int cur, long c) {\\n            if (gcd(num, cur) != 1 || count[num] == 0) {\\n                return;\\n            }\\n            long next = (c * count[num]) % mod;\\n            \\n            // we can take the current solution together with any number of \\'1\\'\\n            res = (res + (next * multiplier) % mod) % mod;\\n            for (int i = num + 1; i <= 30 ; i++) {\\n                // 4 9 16 25 and their multiplier cannot be chosen\\n                if (i % 4 == 0 || i % 9 == 0 || i % 16 == 0 || i % 25 == 0)\\n                    continue;\\n                dfs(i, cur * num, next);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n        long res = 0, mod = (long)1e9 + 7, multiplier;\\n        int[] count;\\n        public int squareFreeSubsets(int[] nums) {\\n            count = new int[31];\\n            for (int num : nums) {\\n                ++count[num];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3235155,
                "title": "no-dp-plain-and-dumb-calculation-still-faster-than-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNumbers are very small (<=30) so we can check by hand which of these are already unacceptable. For example 4 (=2*2) or 20 (=2*2*5) can never be part of our solution because these numbers itself contain square number in their factor.\\n\\nAfter getting rid of such numbers, we can see one more thing, that we can not include one number more than once. So, if a number comes \\'m\\' times in the list, there are \\'m\\' ways to chose it (choose any of the indices where it occurs).\\n\\nBut, \\'1\\' is special, we can take 1 any number of times, so if it occurs \\'m\\' times, there are a total of $2^n$ ways to select it.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(2^n)$ but $n \\\\le 30$ and many paths get pruned early.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(1)$\\n\\n# Code\\n```\\nusing Bitset = bitset<32>;\\nconstexpr int64_t MOD{1\\'000\\'000\\'000 + 7};\\n\\n// hardcoded numbers which are allowed\\nconst Bitset allowed_nums = [](){\\n    Bitset bt{};\\n    for (const auto x: {1, 2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30})\\n        bt.set(x);\\n    return bt;\\n}();\\n\\n// Get prime factors of a number in the form of bitset\\nconstexpr Bitset get_factor(int number)\\n{\\n    Bitset bt{};\\n    for (const auto div: {2, 3, 5, 7, 11, 13, 17, 19, 23, 29})\\n        while (number % div == 0)\\n        {\\n            number /= div;\\n            bt.set(div);\\n        }\\n    return bt;\\n}\\n\\n// calculate huge powers of 2 in logarithmic time, also taking care of integer overflow\\nint64_t pow2(int64_t exp)\\n{\\n    if (exp < 31)\\n        return int64_t(1) << exp;\\n    const auto root = pow2(exp / 2);\\n    const auto root_sqr = (root * root) % MOD;\\n    return (root_sqr * (exp % 2 == 0 ? 1 : 2)) % MOD;\\n}\\n\\nclass Solution {\\n    vector<int> freqs = vector<int>(31);\\n    int64_t count(const int i, const Bitset bt)\\n    {\\n        // if we reached the end\\n        if (i == 31)\\n            return 1;\\n\\n        // if the number is not present, move ahead\\n        if (freqs[i] == 0)\\n            return count(i+1, bt);\\n        const Bitset factor = get_factor(i);\\n\\n        // check if the number can be taking into the set without conflict\\n        const int64_t with_it = (factor & bt).any() ? 0: ((freqs[i] * count(i+1, bt | factor)) % MOD);\\n        const int64_t without_it = count(i+1, bt);\\n        return (with_it + without_it) % MOD;\\n    }\\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        // Delete all numbers which are unacceptable such as 4 or 20\\n        nums.erase(std::remove_if(nums.begin(), nums.end(), [](const int x){ return not allowed_nums.test(x);}), nums.end());\\n\\n        // count frequencies of all the valid numbers\\n        for (const auto x: nums)\\n            ++freqs[x];\\n        \\n\\n        int64_t cnt1{pow2(freqs[1]) % MOD};\\n        Bitset bt;\\n        return (cnt1 * count(2, bt) - 1 + MOD) % MOD;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nusing Bitset = bitset<32>;\\nconstexpr int64_t MOD{1\\'000\\'000\\'000 + 7};\\n\\n// hardcoded numbers which are allowed\\nconst Bitset allowed_nums = [](){\\n    Bitset bt{};\\n    for (const auto x: {1, 2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30})\\n        bt.set(x);\\n    return bt;\\n}();\\n\\n// Get prime factors of a number in the form of bitset\\nconstexpr Bitset get_factor(int number)\\n{\\n    Bitset bt{};\\n    for (const auto div: {2, 3, 5, 7, 11, 13, 17, 19, 23, 29})\\n        while (number % div == 0)\\n        {\\n            number /= div;\\n            bt.set(div);\\n        }\\n    return bt;\\n}\\n\\n// calculate huge powers of 2 in logarithmic time, also taking care of integer overflow\\nint64_t pow2(int64_t exp)\\n{\\n    if (exp < 31)\\n        return int64_t(1) << exp;\\n    const auto root = pow2(exp / 2);\\n    const auto root_sqr = (root * root) % MOD;\\n    return (root_sqr * (exp % 2 == 0 ? 1 : 2)) % MOD;\\n}\\n\\nclass Solution {\\n    vector<int> freqs = vector<int>(31);\\n    int64_t count(const int i, const Bitset bt)\\n    {\\n        // if we reached the end\\n        if (i == 31)\\n            return 1;\\n\\n        // if the number is not present, move ahead\\n        if (freqs[i] == 0)\\n            return count(i+1, bt);\\n        const Bitset factor = get_factor(i);\\n\\n        // check if the number can be taking into the set without conflict\\n        const int64_t with_it = (factor & bt).any() ? 0: ((freqs[i] * count(i+1, bt | factor)) % MOD);\\n        const int64_t without_it = count(i+1, bt);\\n        return (with_it + without_it) % MOD;\\n    }\\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        // Delete all numbers which are unacceptable such as 4 or 20\\n        nums.erase(std::remove_if(nums.begin(), nums.end(), [](const int x){ return not allowed_nums.test(x);}), nums.end());\\n\\n        // count frequencies of all the valid numbers\\n        for (const auto x: nums)\\n            ++freqs[x];\\n        \\n\\n        int64_t cnt1{pow2(freqs[1]) % MOD};\\n        Bitset bt;\\n        return (cnt1 * count(2, bt) - 1 + MOD) % MOD;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225717,
                "title": "rust-bitmask-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are ten primes {2, 3, 5, 7, 11, 13, 17, 19, 23, 29} in the range. Excluding those that could be divided by 4, 9, & 25, each of nums could be represented as a binary number up to 10 bits.\\nWe can use a vector of size 1024 to track the # of subsets with its production and to go valid entries in nums on getting the results iteratively. \\n \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1024 * N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1024)\\n# Code\\n```\\nimpl Solution {\\n    pub fn square_free_subsets(nums: Vec<i32>) -> i32 {\\n        let mut dp = vec![0; 1024];\\n        let primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29];\\n\\n        for a in nums {\\n            if a % 4 == 0 || a % 9 == 0 || a % 25 == 0 { continue }\\n            let mut d = 0;\\n            for i in 0 .. primes.len() {\\n                if a % primes[i] == 0 { d += 1 << i; }\\n            }\\n            \\n            for k in 0 .. dp.len() {\\n                if k & d != 0 { continue }\\n                dp[k | d] = (dp[k | d] + dp[k]) % 1_000_000_007;\\n            }\\n            dp[d] += 1;\\n        }\\n\\n        (dp.into_iter().map(|a| a as i64).sum::<i64>() % 1_000_000_007) as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn square_free_subsets(nums: Vec<i32>) -> i32 {\\n        let mut dp = vec![0; 1024];\\n        let primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29];\\n\\n        for a in nums {\\n            if a % 4 == 0 || a % 9 == 0 || a % 25 == 0 { continue }\\n            let mut d = 0;\\n            for i in 0 .. primes.len() {\\n                if a % primes[i] == 0 { d += 1 << i; }\\n            }\\n            \\n            for k in 0 .. dp.len() {\\n                if k & d != 0 { continue }\\n                dp[k | d] = (dp[k | d] + dp[k]) % 1_000_000_007;\\n            }\\n            dp[d] += 1;\\n        }\\n\\n        (dp.into_iter().map(|a| a as i64).sum::<i64>() % 1_000_000_007) as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3221079,
                "title": "c-bit-mask-dp",
                "content": "# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll mod=1e9+7;\\n    int squareFreeSubsets(vector<int>& nums) \\n    {\\n        vector<ll>f(1025,0);\\n        f[0]=1;\\n        set<int>Set;\\n        Set.insert(2),Set.insert(3),Set.insert(5),Set.insert(6),Set.insert(7),Set.insert(10),Set.insert(11),Set.insert(13);\\n        Set.insert(14),Set.insert(15),Set.insert(17),Set.insert(19),Set.insert(21),Set.insert(22);\\n        Set.insert(23),Set.insert(26),Set.insert(29),Set.insert(30);\\n        vector<vector<int>>fac={{2},{3},{5},{2,3},{7},{2,5},{11},{13},{2,7},{3,5},{17},{19},{3,7},\\n        {2,11},{23},{2,13},{29},{2,3,5}};\\n        map<int,int>Map;\\n        Map[2]=0,Map[3]=1,Map[5]=2,Map[6]=3,Map[7]=4,Map[10]=5,Map[11]=6,Map[13]=7,Map[14]=8,Map[15]=9;\\n        Map[17]=10,Map[19]=11,Map[21]=12,Map[22]=13,Map[23]=14,Map[26]=15,Map[29]=16,Map[30]=17;\\n        map<int,int>Map2;\\n        Map2[2]=0,Map2[3]=1,Map2[5]=2,Map2[7]=3,Map2[11]=4,Map2[13]=5,Map2[17]=6,Map2[19]=7,Map2[23]=8,Map2[29]=9;\\n        for(auto &x:nums)\\n        {\\n            if(x==1)for(auto &x:f)x=(x*2)%mod;\\n            if(!Set.count(x))continue;\\n            ll cur=0;\\n            for(auto &x:fac[Map[x]])cur+=(1<<Map2[x]);\\n            for(int i=0;i<1024;i++)\\n            {\\n                if((i+cur)==(i|cur))f[i+cur]=(f[i+cur]+f[i])%mod;\\n            }\\n        }\\n        ll ans=0;\\n        for(auto &x:f)ans=(ans+x)%mod;\\n        return ((ans-1)+mod)%mod;\\n    }\\n};\\n\\n// 2 3 5 7 11 13 17 19 23 29\\n// 2 3 5 6 7 10 11 13 14 15 17 19 21 22 23 26 29 30 => 18\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll mod=1e9+7;\\n    int squareFreeSubsets(vector<int>& nums) \\n    {\\n        vector<ll>f(1025,0);\\n        f[0]=1;\\n        set<int>Set;\\n        Set.insert(2),Set.insert(3),Set.insert(5),Set.insert(6),Set.insert(7),Set.insert(10),Set.insert(11),Set.insert(13);\\n        Set.insert(14),Set.insert(15),Set.insert(17),Set.insert(19),Set.insert(21),Set.insert(22);\\n        Set.insert(23),Set.insert(26),Set.insert(29),Set.insert(30);\\n        vector<vector<int>>fac={{2},{3},{5},{2,3},{7},{2,5},{11},{13},{2,7},{3,5},{17},{19},{3,7},\\n        {2,11},{23},{2,13},{29},{2,3,5}};\\n        map<int,int>Map;\\n        Map[2]=0,Map[3]=1,Map[5]=2,Map[6]=3,Map[7]=4,Map[10]=5,Map[11]=6,Map[13]=7,Map[14]=8,Map[15]=9;\\n        Map[17]=10,Map[19]=11,Map[21]=12,Map[22]=13,Map[23]=14,Map[26]=15,Map[29]=16,Map[30]=17;\\n        map<int,int>Map2;\\n        Map2[2]=0,Map2[3]=1,Map2[5]=2,Map2[7]=3,Map2[11]=4,Map2[13]=5,Map2[17]=6,Map2[19]=7,Map2[23]=8,Map2[29]=9;\\n        for(auto &x:nums)\\n        {\\n            if(x==1)for(auto &x:f)x=(x*2)%mod;\\n            if(!Set.count(x))continue;\\n            ll cur=0;\\n            for(auto &x:fac[Map[x]])cur+=(1<<Map2[x]);\\n            for(int i=0;i<1024;i++)\\n            {\\n                if((i+cur)==(i|cur))f[i+cur]=(f[i+cur]+f[i])%mod;\\n            }\\n        }\\n        ll ans=0;\\n        for(auto &x:f)ans=(ans+x)%mod;\\n        return ((ans-1)+mod)%mod;\\n    }\\n};\\n\\n// 2 3 5 7 11 13 17 19 23 29\\n// 2 3 5 6 7 10 11 13 14 15 17 19 21 22 23 26 29 30 => 18\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220969,
                "title": "fundamental-approach-c-bit-masking-modular-arithmetic-subsets",
                "content": "# Code\\n```\\n#define ll long long\\nint power(long long x, long long y, int mod)\\n{\\n    unsigned ll out = 1;\\n    x %= mod;\\n    while(y > 0) {\\n        if(y & 1) out = (out*x)%mod;\\n        y >>= 1;\\n        x = (x*x)%mod;\\n    }\\n    return out;\\n}\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    vector<int> primes = {2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23, 29};\\n    unordered_map<int, int> primeMap;\\n    unordered_map<int, int> umap;\\n    int validMask(int mask, int n) {\\n        for(auto prime: primes) {\\n            if(n%prime == 0) {\\n                if(mask&(1<<primeMap[prime])) return 0;\\n                n /= prime;\\n                if(n%prime == 0) return 0;\\n                mask |= 1<<primeMap[prime];\\n            }\\n        }\\n        return mask;\\n    }\\n    int recurse(int idx, vector<int>& nums, int mask) {\\n        if(idx == nums.size())\\n            return mask != 0;\\n        int out = recurse(idx+1, nums, mask);\\n        int newMask = validMask(mask, nums[idx]);\\n        if(newMask != 0)\\n            out = (out+(1ll*umap[nums[idx]]*recurse(idx+1, nums, newMask))%mod)%mod;\\n        return out;\\n    }\\n    int squareFreeSubsets(vector<int>& nums) {\\n        for(int i=0;i<10;i++) {\\n            primeMap[primes[i]] = i+1;\\n        }\\n        for(int val: nums) {\\n            umap[val]++;\\n        }\\n        unordered_set<int> uset(nums.begin(), nums.end());\\n        nums.clear(); \\n        for(int val: uset) {\\n            if(val == 1)\\n                continue;\\n            nums.push_back(val);\\n        }\\n        int out =recurse(0,nums,0)%mod;       \\n        int ones =(power(2,umap[1], mod)-1+mod)%mod;\\n        out =(out+1ll*out*ones%mod+ones)%mod;    \\n        return out;\\n    }\\n};\\n// Please consider upvoting if the solution helped! Thank you :)\\n// Credits: https://leetcode.com/i_pranav/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nint power(long long x, long long y, int mod)\\n{\\n    unsigned ll out = 1;\\n    x %= mod;\\n    while(y > 0) {\\n        if(y & 1) out = (out*x)%mod;\\n        y >>= 1;\\n        x = (x*x)%mod;\\n    }\\n    return out;\\n}\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    vector<int> primes = {2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23, 29};\\n    unordered_map<int, int> primeMap;\\n    unordered_map<int, int> umap;\\n    int validMask(int mask, int n) {\\n        for(auto prime: primes) {\\n            if(n%prime == 0) {\\n                if(mask&(1<<primeMap[prime])) return 0;\\n                n /= prime;\\n                if(n%prime == 0) return 0;\\n                mask |= 1<<primeMap[prime];\\n            }\\n        }\\n        return mask;\\n    }\\n    int recurse(int idx, vector<int>& nums, int mask) {\\n        if(idx == nums.size())\\n            return mask != 0;\\n        int out = recurse(idx+1, nums, mask);\\n        int newMask = validMask(mask, nums[idx]);\\n        if(newMask != 0)\\n            out = (out+(1ll*umap[nums[idx]]*recurse(idx+1, nums, newMask))%mod)%mod;\\n        return out;\\n    }\\n    int squareFreeSubsets(vector<int>& nums) {\\n        for(int i=0;i<10;i++) {\\n            primeMap[primes[i]] = i+1;\\n        }\\n        for(int val: nums) {\\n            umap[val]++;\\n        }\\n        unordered_set<int> uset(nums.begin(), nums.end());\\n        nums.clear(); \\n        for(int val: uset) {\\n            if(val == 1)\\n                continue;\\n            nums.push_back(val);\\n        }\\n        int out =recurse(0,nums,0)%mod;       \\n        int ones =(power(2,umap[1], mod)-1+mod)%mod;\\n        out =(out+1ll*out*ones%mod+ones)%mod;    \\n        return out;\\n    }\\n};\\n// Please consider upvoting if the solution helped! Thank you :)\\n// Credits: https://leetcode.com/i_pranav/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218094,
                "title": "dynamic-programming-bitmask-memoization",
                "content": "```\\n//     if ith element is taken then what is the next element to be chosen??\\n//     we have to choose next element such that this and already present elements should not have any prime factor common \\n//     since all numbers between 0-30 primes between 0 and 30 is  2,3,5,7,11,13,17,19,23,29 only 10 primes are <30\\n//     so we can use bitmask to re-present these prime numbers while considering for the next element \\n//     and for each element we have two choice 1)take 2)no take\\n//     this form recursion and satisfying optimal substructure and overlapping subproblem \\n//     so this can be solved using dp\\n//     hence this can be solved by dp with bitmasking\\n//     2^10=1024\\n    int dp[1001][2500];\\n    const int mod=1e9+7;\\n    vector<int>prime={2,3,5,7,11,13,17,19,23,29};\\n    pair<int,int> generate_mask(int num){\\n        int mask=0;\\n        for(int i=0;i<10;++i){\\n            auto curr=prime[i];\\n            int count=0;\\n            while(num%curr==0)count++,num/=curr;\\n            if(count>1)return {-1,0};\\n            else if(count==1)mask|=(1<<(i+1));\\n        }\\n        return {1,mask};\\n    }\\n    int f(int i,int mask,vector<int>&nums){\\n        if(i==nums.size())return 1;\\n        if(dp[i][mask]!=-1)return dp[i][mask];\\n        int ans=f(i+1,mask,nums);\\n        ans%=mod;\\n        auto curr=generate_mask(nums[i]);\\n        if(curr.first==1 and (mask&curr.second)==0)\\n        ans+=f(i+1,mask|curr.second,nums);\\n        ans%=mod;\\n        return dp[i][mask]=ans;\\n    }\\n    int squareFreeSubsets(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return (f(0,1,nums)-1+mod)%mod;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\n//     if ith element is taken then what is the next element to be chosen??\\n//     we have to choose next element such that this and already present elements should not have any prime factor common \\n//     since all numbers between 0-30 primes between 0 and 30 is  2,3,5,7,11,13,17,19,23,29 only 10 primes are <30\\n//     so we can use bitmask to re-present these prime numbers while considering for the next element \\n//     and for each element we have two choice 1)take 2)no take\\n//     this form recursion and satisfying optimal substructure and overlapping subproblem \\n//     so this can be solved using dp\\n//     hence this can be solved by dp with bitmasking\\n//     2^10=1024\\n    int dp[1001][2500];\\n    const int mod=1e9+7;\\n    vector<int>prime={2,3,5,7,11,13,17,19,23,29};\\n    pair<int,int> generate_mask(int num){\\n        int mask=0;\\n        for(int i=0;i<10;++i){\\n            auto curr=prime[i];\\n            int count=0;\\n            while(num%curr==0)count++,num/=curr;\\n            if(count>1)return {-1,0};\\n            else if(count==1)mask|=(1<<(i+1));\\n        }\\n        return {1,mask};\\n    }\\n    int f(int i,int mask,vector<int>&nums){\\n        if(i==nums.size())return 1;\\n        if(dp[i][mask]!=-1)return dp[i][mask];\\n        int ans=f(i+1,mask,nums);\\n        ans%=mod;\\n        auto curr=generate_mask(nums[i]);\\n        if(curr.first==1 and (mask&curr.second)==0)\\n        ans+=f(i+1,mask|curr.second,nums);\\n        ans%=mod;\\n        return dp[i][mask]=ans;\\n    }\\n    int squareFreeSubsets(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return (f(0,1,nums)-1+mod)%mod;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3217074,
                "title": "javascript-dp-fast-power-169ms",
                "content": "```\\nconst ll = BigInt;\\nconst powmod = (a, b, mod) => { let r = 1n; while (b > 0n) { if (b % 2n == 1) r = r * a % mod; b >>= 1n; a = a * a % mod; } return r; };\\nconst gcd = (a, b) => b == 0 ? a : gcd(b, a % b);\\nconst minus_mod = (x, y, mod) => ((x - y) % mod + mod) % mod;\\n\\nconst mod = 1e9 + 7, bmod = ll(mod);\\nconst squareFreeSubsets = (a) => {\\n    let d = [2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30];\\n    let f = Array(31).fill(0), dp = new Map(), sum = 0;\\n    for (const x of a) f[x]++;\\n    dp.set(1, Number(powmod(2n, ll(f[1]), bmod)));\\n    for (const v of d) {\\n        for (const [x,] of dp) {\\n            if (gcd(v, x) == 1) {\\n                let occ = dp.get(x * v) || 0, occ2 = dp.get(x) || 0;\\n                dp.set(x * v, (occ + occ2 * f[v]) % mod);\\n            }\\n        }\\n    }\\n    for (const [, v] of dp) sum += v;\\n    return minus_mod(sum, 1, mod);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nconst ll = BigInt;\\nconst powmod = (a, b, mod) => { let r = 1n; while (b > 0n) { if (b % 2n == 1) r = r * a % mod; b >>= 1n; a = a * a % mod; } return r; };\\nconst gcd = (a, b) => b == 0 ? a : gcd(b, a % b);\\nconst minus_mod = (x, y, mod) => ((x - y) % mod + mod) % mod;\\n\\nconst mod = 1e9 + 7, bmod = ll(mod);\\nconst squareFreeSubsets = (a) => {\\n    let d = [2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30];\\n    let f = Array(31).fill(0), dp = new Map(), sum = 0;\\n    for (const x of a) f[x]++;\\n    dp.set(1, Number(powmod(2n, ll(f[1]), bmod)));\\n    for (const v of d) {\\n        for (const [x,] of dp) {\\n            if (gcd(v, x) == 1) {\\n                let occ = dp.get(x * v) || 0, occ2 = dp.get(x) || 0;\\n                dp.set(x * v, (occ + occ2 * f[v]) % mod);\\n            }\\n        }\\n    }\\n    for (const [, v] of dp) sum += v;\\n    return minus_mod(sum, 1, mod);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3216909,
                "title": "dart-explained-intuition-and-approach",
                "content": "The problem should be tagged as Hard, somehow it is medium.\\n\\n# Intuition\\nWe need to check two conditions. The nums is already not square free and prime * prime can not be square free. \\n\\n\\n# Approach\\nTo encounter the above cases, we have low constraint 0 to 30, find square free for 0 to 30, as if square free set the mask, else -1. If sqf[num] == -1 (means it is not square free themself) or mask already has that number(prime * prime is not square free, so not allowed to do that), we don\\'t pick it.\\n\\n# Complexity\\n- Time complexity:\\nO(N*1024)\\n\\n- Space complexity:\\nO(N*1024)\\n\\n# Code\\n```\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int squareFreeSubsets(List<int> nums) {\\n    int mod = 1e9.toInt() + 7;\\n    int n = nums.length;\\n\\n    List<List<int?>> dp = List.generate(\\n      n,\\n      (index) => List.filled(1 << 10, null),\\n    );\\n\\n    // If the nums is not square free -1 else mask\\n    // So, we don\\'t need to loop and check everytime for is the num square free or not\\n    var sqf = squareFreeList();\\n\\n    int f(int i, int mask) {\\n      if (i >= n) {\\n        return 1;\\n      }\\n\\n      if (dp[i][mask] != null) {\\n        return dp[i][mask]!;\\n      }\\n      int pick = 0;\\n      // If already multiply prime nums like 4, 9, 12, or mask already have the same currnent num we skipped\\n      // If not multiply prime nums and mask doesn\\'t have the duplicate\\n      if (sqf[nums[i]] != -1 && (mask & sqf[nums[i]]) == 0) {\\n        pick = f(i + 1, mask ^ sqf[nums[i]]);\\n      }\\n\\n      int notPick = f(i + 1, mask);\\n\\n      return dp[i][mask] = (pick + notPick) % mod;\\n    }\\n\\n    int ans = f(0, 0) - 1;\\n    if (ans.isNegative) {\\n      ans += mod;\\n    }\\n    return ans;\\n  }\\n\\n  List<int> squareFreeList() {\\n    var primes = [\\n      2,\\n      3,\\n      5,\\n      7,\\n      11,\\n      13,\\n      17,\\n      19,\\n      23,\\n      29\\n    ]; // list of all primes <= 30\\n\\n    var sqf = List.filled(31, -1);\\n\\n    for (int i = 1; i <= 30; i++) {\\n      if (i == 1) {\\n        sqf[i] = 0; // special case for 0\\n      } else {\\n        bool isSquareFree = true;\\n        int mask = 0;\\n        for (int j = 0; j < 10; j++) {\\n          if (i % primes[j] == 0) {\\n            if (i % (primes[j] * primes[j]) == 0) {\\n              isSquareFree = false;\\n              break;\\n            } else {\\n              mask ^= (1 << j);\\n            }\\n          }\\n        }\\n        if (isSquareFree) {\\n          sqf[i] = mask;\\n        }\\n      }\\n    }\\n    return sqf;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int squareFreeSubsets(List<int> nums) {\\n    int mod = 1e9.toInt() + 7;\\n    int n = nums.length;\\n\\n    List<List<int?>> dp = List.generate(\\n      n,\\n      (index) => List.filled(1 << 10, null),\\n    );\\n\\n    // If the nums is not square free -1 else mask\\n    // So, we don\\'t need to loop and check everytime for is the num square free or not\\n    var sqf = squareFreeList();\\n\\n    int f(int i, int mask) {\\n      if (i >= n) {\\n        return 1;\\n      }\\n\\n      if (dp[i][mask] != null) {\\n        return dp[i][mask]!;\\n      }\\n      int pick = 0;\\n      // If already multiply prime nums like 4, 9, 12, or mask already have the same currnent num we skipped\\n      // If not multiply prime nums and mask doesn\\'t have the duplicate\\n      if (sqf[nums[i]] != -1 && (mask & sqf[nums[i]]) == 0) {\\n        pick = f(i + 1, mask ^ sqf[nums[i]]);\\n      }\\n\\n      int notPick = f(i + 1, mask);\\n\\n      return dp[i][mask] = (pick + notPick) % mod;\\n    }\\n\\n    int ans = f(0, 0) - 1;\\n    if (ans.isNegative) {\\n      ans += mod;\\n    }\\n    return ans;\\n  }\\n\\n  List<int> squareFreeList() {\\n    var primes = [\\n      2,\\n      3,\\n      5,\\n      7,\\n      11,\\n      13,\\n      17,\\n      19,\\n      23,\\n      29\\n    ]; // list of all primes <= 30\\n\\n    var sqf = List.filled(31, -1);\\n\\n    for (int i = 1; i <= 30; i++) {\\n      if (i == 1) {\\n        sqf[i] = 0; // special case for 0\\n      } else {\\n        bool isSquareFree = true;\\n        int mask = 0;\\n        for (int j = 0; j < 10; j++) {\\n          if (i % primes[j] == 0) {\\n            if (i % (primes[j] * primes[j]) == 0) {\\n              isSquareFree = false;\\n              break;\\n            } else {\\n              mask ^= (1 << j);\\n            }\\n          }\\n        }\\n        if (isSquareFree) {\\n          sqf[i] = mask;\\n        }\\n      }\\n    }\\n    return sqf;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214320,
                "title": "python-bitmask-dp",
                "content": "# Code\\n```\\nfrom functools import cache\\nfrom collections import Counter\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        MOD = 10**9 + 7\\n        candidates = set([1, 2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30])\\n        factors = {2:[2],3:[3],5:[5],6:[2,3],7:[7],10:[2,5],11:[11],13:[13],14:[2,7],15:[3,5],17:[17],19:[19],21:[3,7],22:[2,11],23:[23],26:[2,13],29:[29],30:[2,3,5]}\\n        d = {1:0, 2:1, 3:2, 5:3, 7:4, 11:5, 13:6, 17:7, 19:8, 23:9, 29:10}\\n        masks = {}\\n        for v in factors:\\n            mask = 0\\n            for w in factors[v]:\\n                mask |= (1<<d[w])\\n            masks[v] = mask\\n        counter = Counter([num for num in nums if num in candidates])\\n        ones = counter[1]\\n        del counter[1]\\n        keylist = list(counter.keys())\\n        n = len(keylist)\\n        @cache \\n        def dfs(i, mask):\\n            if i == n: return 1\\n            res = 0\\n            res += dfs(i+1, mask)\\n            if not masks[keylist[i]] & mask:\\n                res = (res + counter[keylist[i]]*dfs(i+1, masks[keylist[i]] | mask))%MOD\\n            return res%MOD\\n        return (pow(2,ones)*dfs(0, 0)-1)%MOD\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import cache\\nfrom collections import Counter\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        MOD = 10**9 + 7\\n        candidates = set([1, 2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30])\\n        factors = {2:[2],3:[3],5:[5],6:[2,3],7:[7],10:[2,5],11:[11],13:[13],14:[2,7],15:[3,5],17:[17],19:[19],21:[3,7],22:[2,11],23:[23],26:[2,13],29:[29],30:[2,3,5]}\\n        d = {1:0, 2:1, 3:2, 5:3, 7:4, 11:5, 13:6, 17:7, 19:8, 23:9, 29:10}\\n        masks = {}\\n        for v in factors:\\n            mask = 0\\n            for w in factors[v]:\\n                mask |= (1<<d[w])\\n            masks[v] = mask\\n        counter = Counter([num for num in nums if num in candidates])\\n        ones = counter[1]\\n        del counter[1]\\n        keylist = list(counter.keys())\\n        n = len(keylist)\\n        @cache \\n        def dfs(i, mask):\\n            if i == n: return 1\\n            res = 0\\n            res += dfs(i+1, mask)\\n            if not masks[keylist[i]] & mask:\\n                res = (res + counter[keylist[i]]*dfs(i+1, masks[keylist[i]] | mask))%MOD\\n            return res%MOD\\n        return (pow(2,ones)*dfs(0, 0)-1)%MOD\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213675,
                "title": "c-bit-manipulation-dp",
                "content": "Almost the same as [1994. The Number of Good Subsets](https://leetcode.com/problems/the-number-of-good-subsets/solutions/1444213/python-dp-solution/comments/1809356)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        int cnt[31] = {};\\n        for (int num: nums)\\n            ++cnt[num];\\n        int primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n        long dp[1024] = {1};\\n        int mod = 1e9 + 7;\\n        for (int num = 2; num <= 30; ++num) {\\n            if (cnt[num] == 0 || num % 4 == 0 || num % 9 == 0 || num % 25 == 0)\\n                continue;\\n            int mask = 0;\\n            for (int i = 0; i < 10; ++i) {\\n                if (num % primes[i] == 0)\\n                    mask |= (1 << i);\\n            }\\n            for (int i = 0; i < 1024; ++i) {\\n                if ((i & mask) == 0)\\n                    dp[i|mask] = (dp[i|mask] + cnt[num] * dp[i]) % mod;\\n            }\\n        }\\n        auto pow2 = [] (int n, int mod) {\\n            int ret = 1;\\n            long base = 2;\\n            while (n) {\\n                if (n & 1)\\n                    ret = ret * base % mod;\\n                base = base * base % mod;\\n                n >>= 1;\\n            }\\n            return ret;\\n        };\\n        return (reduce(dp, dp+1024, 0LL, [&] (auto sum, int x) {\\n            return (sum + x) % mod;\\n        }) * pow2(cnt[1], mod) - 1 + mod) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        int cnt[31] = {};\\n        for (int num: nums)\\n            ++cnt[num];\\n        int primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n        long dp[1024] = {1};\\n        int mod = 1e9 + 7;\\n        for (int num = 2; num <= 30; ++num) {\\n            if (cnt[num] == 0 || num % 4 == 0 || num % 9 == 0 || num % 25 == 0)\\n                continue;\\n            int mask = 0;\\n            for (int i = 0; i < 10; ++i) {\\n                if (num % primes[i] == 0)\\n                    mask |= (1 << i);\\n            }\\n            for (int i = 0; i < 1024; ++i) {\\n                if ((i & mask) == 0)\\n                    dp[i|mask] = (dp[i|mask] + cnt[num] * dp[i]) % mod;\\n            }\\n        }\\n        auto pow2 = [] (int n, int mod) {\\n            int ret = 1;\\n            long base = 2;\\n            while (n) {\\n                if (n & 1)\\n                    ret = ret * base % mod;\\n                base = base * base % mod;\\n                n >>= 1;\\n            }\\n            return ret;\\n        };\\n        return (reduce(dp, dp+1024, 0LL, [&] (auto sum, int x) {\\n            return (sum + x) % mod;\\n        }) * pow2(cnt[1], mod) - 1 + mod) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212716,
                "title": "no-dfs-no-dp-just-bitmask-simple-counting",
                "content": "We just count all valid bitmasks.\\n```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    vector<int> primes = vector<int>{2,3,5,7,11,13,17,19,23,29};\\n    int getMask(int n)\\n    {\\n        if (n==1) return 0;\\n        int mask = 0;\\n        for (int i=0; i<primes.size();i++)\\n        {\\n            int ctr = 0;\\n            while (n%primes[i]==0)\\n            {\\n                n /= primes[i];\\n                ctr ++;\\n            }\\n            if (ctr>=2) return -1;\\n            if(ctr) mask |= (1<<i);\\n        }\\n        return mask;\\n    }\\n    int squareFreeSubsets(vector<int>& nums) \\n    {\\n        unordered_map<long long,long long> H;\\n        for (int n: nums)\\n        {\\n            unordered_map<long long,long long> Hcopy = H;\\n            int mask = getMask(n);\\n            if (mask==-1) continue;\\n            for (auto [k,v]: Hcopy) if ((k & mask)==0) H[ (k|mask) ] = (H[k|mask]%mod + v%mod)%mod;\\n            H[mask]++;\\n        }\\n        long long res = 0;\\n        for (auto [k,v]: H) res += v;\\n        return (int)(res%mod);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    vector<int> primes = vector<int>{2,3,5,7,11,13,17,19,23,29};\\n    int getMask(int n)\\n    {\\n        if (n==1) return 0;\\n        int mask = 0;\\n        for (int i=0; i<primes.size();i++)\\n        {\\n            int ctr = 0;\\n            while (n%primes[i]==0)\\n            {\\n                n /= primes[i];\\n                ctr ++;\\n            }\\n            if (ctr>=2) return -1;\\n            if(ctr) mask |= (1<<i);\\n        }\\n        return mask;\\n    }\\n    int squareFreeSubsets(vector<int>& nums) \\n    {\\n        unordered_map<long long,long long> H;\\n        for (int n: nums)\\n        {\\n            unordered_map<long long,long long> Hcopy = H;\\n            int mask = getMask(n);\\n            if (mask==-1) continue;\\n            for (auto [k,v]: Hcopy) if ((k & mask)==0) H[ (k|mask) ] = (H[k|mask]%mod + v%mod)%mod;\\n            H[mask]++;\\n        }\\n        long long res = 0;\\n        for (auto [k,v]: H) res += v;\\n        return (int)(res%mod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210623,
                "title": "c-knapsack-dp-recursive-memo-beginners-friendly-explained",
                "content": "Let us start by looking the constraints\\n\\n```\\n1 <= nums.length <= 1000\\n1 <= nums[i] <= 30\\n```\\n**Objective** - To count all the subsequences/subsets whose product is not divisible by an square Number. A square number is a number like 4,9,16,25 etc. **1 is a not a square number according to question**. We want our product of subset/subsequence to be square Free, i.e. , the product should not be divisible by any square number.\\n\\n123 -> \\u2705\\u2705\\u2705\\n8 -> \\u274C\\u274C\\u274C ( Divisible by 4 )\\n1248 -> \\u274C\\u274C\\u274C ( Divisible by 4 , 16 )\\n35 -> \\u2705\\u2705\\u2705\\n1 -> \\u2705\\u2705\\u2705 ( 1 is not a square number ACCORDING TO QUESTION )\\n\\nNow as we have our question statement and objective clarified. \\n\\n**Let us now understand how a square Free product is formed**.\\n\\nA square free product can ONLY be formed if there are no duplicate numbers in the subset/subsequence. RIGHT??\\n\\nTake 8 as example, why it is not a square free number?? \\n\\nIt is because the prime factorisation of 8 is 2, 2 ,2 . You can see there are duplicates here which will result in a square number. But 26 is a square free number because its prime factorization is 2 , 13 and there are no duplicates\\n\\nSo, now we realise a number is a square free number only and only if there are NO duplicates in its prime factorization.\\n\\n# Let us see the prime Factorization...\\n```\\n1 -> 1                    11 -> 11                    21 -> 3  7 \\n2 -> 2                    12 -> 2  2  3               22 -> 2  11\\n3 -> 3                    13 -> 13                    23 -> 23 \\n4 -> 2  2                 14 -> 2  7                  24 -> 2  2  2  3\\n5 -> 5                    15 -> 3  5                  25 -> 5  5\\n6 -> 2  3                 16 -> 2  2  2  2            26 -> 2  13\\n7 -> 7                    17 -> 17                    27 -> 3  3  3\\n8 -> 2  2  2              18 -> 2  3  2               28 -> 2  2  7\\n9 -> 3  3                 19 -> 19                    29 -> 29\\n10 -> 2  5                20 -> 2  2  5               30 -> 2  3  5\\n```\\n\\nNote that **{1  2  3  5  7  11  13  17  19  23  29}**. These are numbers that make up the prime factorizations of numbers from 1 - 30. We want to keep track of these numbers as we build up our subset/subsequence product.\\n \\n\\nWe want to mark these numbers. If we go the direct route of setting bits on to mark it as taken, it will be 2^29, highest. That\\'s **536870912**. We CANNOT create an array of that size. \\n\\nTo overcome this, we need to understand that our task is merely to mark the number visited. We can **re-map** these numbers to **lower bit places**. That is,\\n\\n```\\n0th bit will mark the status of 1\\n1st bit will mark the status of 2\\n2nd bit will mark the status of 3\\n.....\\n11th bit will mark the status of 29.\\n\\n\\t\\t\\t\\tCode snippet\\nint squareFreePrimes[]={1,2,3,5,7,11,13,17,19,23,29}\\nunordered_map<int,int> hash;\\nfor(int i=0;i<11;i++){ \\n\\thash[squareFreePrimes[i]]=i;\\n}\\n```\\n\\nThis reduced our higest bit from 29th place to 11th place. That\\'s **2048**. Which is insanly small than **536870912**.\\n\\n`We want to ignore numbers which have duplicate factors in them. These numbers are already NON SQUARE FREE numbers themselves. These numbers are {4,8,9,12,16,18,20,24,25,27,28}.`\\n\\nNow, all is left to do is to run a KNAPSACK CODE on numbers ,**apart from {4,8,9,12,16,18,20,24,25,27,28}**, from given array. We can create a mask for these numbers beforehand. \\nThe mask represents the factors that are present in the given number. We won\\'t take numbers having **COMMON PRIME FACTORS** in our subset as that would result in a square number. \\n\\n`For example, 14 , 21 have distint factors, but 7 is a COMMON factor between them which will get squared if 14 and 21 are multiplied resulting in a NON SQUARE FREE number.`\\n\\nIn short, an answer subset/subsequence product will **NEVER** have **duplicate** factors.\\n\\n# **CODE**\\n![image](https://assets.leetcode.com/users/images/4c70625b-5f5c-46b6-b7a5-4573f3d26843_1676911410.7013106.png)\\n\\n```\\nclass Solution {\\npublic:\\n    long long dp[1<<11][1001];\\n    \\n    unordered_map<int,int> hash;  // the numbers are mapped to reduce bit count\\n    \\n    int primeFactorisation_MASK(int num){\\n        int mask=0;\\n            \\n        if(num%2==0){\\n            mask|=(1<<hash[2]);\\n            num/=2;\\n        }\\n        for(int i=3;i<=sqrt(num);i+=2){\\n            while(num%i==0){\\n                mask|=(1<<hash[i]);\\n                num=num/i;\\n            }\\n        }\\n        if(num>2){\\n            mask|=(1<<hash[num]);\\n        }\\n        \\n        return mask;\\n    }\\n    \\n    long long helper(int mask, int curr, vector<int> &masks){\\n        if(curr==masks.size()){\\n            return 1;\\n        }\\n        if(dp[mask][curr]!=-1){\\n            return dp[mask][curr];\\n        }\\n        \\n        int ACCEPT=0;\\n        if((masks[curr] & mask)==0){ // checking that there is no common set bit in both masks cuz that will lead to a square number \\n            ACCEPT=helper(masks[curr] | mask,curr+1,masks);\\n        }\\n        \\n        int IGNORE=helper(mask,curr+1,masks);\\n        \\n        return dp[mask][curr]=(ACCEPT+IGNORE)%1000000007;\\n    }\\n    \\n    int squareFreeSubsets(vector<int>& nums) {\\n        int primeFactors[]={1,2,3,5,7,11,13,17,19,23,29}; // these numbers make up the prime factorizations from 1-30\\n\\n        for(int i=0;i<11;i++){ // mapping squareFreePrimes to smaller bit places\\n            hash[primeFactors[i]]=i;\\n        }\\n        \\n        vector<int> masks;\\n        for(auto x: nums){\\n            if(x==4 ||  x==8 || x==9 || x==12 || x==16 || x==18 || x==20 || x==24 || x==25 || x==27 || x==28){ // number having more than 1 duplicate primes leading to a square number\\n                continue;\\n            }\\n            \\n            int mask=primeFactorisation_MASK(x);\\n            masks.push_back(mask);\\n        }\\n        \\n        memset(dp,-1,sizeof(dp));\\n        return helper(0,0,masks)-1; // -1 because there is an empty subset in the answer\\n    }\\n};\\n\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\n1 <= nums.length <= 1000\\n1 <= nums[i] <= 30\\n```\n```\\n1 -> 1                    11 -> 11                    21 -> 3  7 \\n2 -> 2                    12 -> 2  2  3               22 -> 2  11\\n3 -> 3                    13 -> 13                    23 -> 23 \\n4 -> 2  2                 14 -> 2  7                  24 -> 2  2  2  3\\n5 -> 5                    15 -> 3  5                  25 -> 5  5\\n6 -> 2  3                 16 -> 2  2  2  2            26 -> 2  13\\n7 -> 7                    17 -> 17                    27 -> 3  3  3\\n8 -> 2  2  2              18 -> 2  3  2               28 -> 2  2  7\\n9 -> 3  3                 19 -> 19                    29 -> 29\\n10 -> 2  5                20 -> 2  2  5               30 -> 2  3  5\\n```\n```\\n0th bit will mark the status of 1\\n1st bit will mark the status of 2\\n2nd bit will mark the status of 3\\n.....\\n11th bit will mark the status of 29.\\n\\n\\t\\t\\t\\tCode snippet\\nint squareFreePrimes[]={1,2,3,5,7,11,13,17,19,23,29}\\nunordered_map<int,int> hash;\\nfor(int i=0;i<11;i++){ \\n\\thash[squareFreePrimes[i]]=i;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    long long dp[1<<11][1001];\\n    \\n    unordered_map<int,int> hash;  // the numbers are mapped to reduce bit count\\n    \\n    int primeFactorisation_MASK(int num){\\n        int mask=0;\\n            \\n        if(num%2==0){\\n            mask|=(1<<hash[2]);\\n            num/=2;\\n        }\\n        for(int i=3;i<=sqrt(num);i+=2){\\n            while(num%i==0){\\n                mask|=(1<<hash[i]);\\n                num=num/i;\\n            }\\n        }\\n        if(num>2){\\n            mask|=(1<<hash[num]);\\n        }\\n        \\n        return mask;\\n    }\\n    \\n    long long helper(int mask, int curr, vector<int> &masks){\\n        if(curr==masks.size()){\\n            return 1;\\n        }\\n        if(dp[mask][curr]!=-1){\\n            return dp[mask][curr];\\n        }\\n        \\n        int ACCEPT=0;\\n        if((masks[curr] & mask)==0){ // checking that there is no common set bit in both masks cuz that will lead to a square number \\n            ACCEPT=helper(masks[curr] | mask,curr+1,masks);\\n        }\\n        \\n        int IGNORE=helper(mask,curr+1,masks);\\n        \\n        return dp[mask][curr]=(ACCEPT+IGNORE)%1000000007;\\n    }\\n    \\n    int squareFreeSubsets(vector<int>& nums) {\\n        int primeFactors[]={1,2,3,5,7,11,13,17,19,23,29}; // these numbers make up the prime factorizations from 1-30\\n\\n        for(int i=0;i<11;i++){ // mapping squareFreePrimes to smaller bit places\\n            hash[primeFactors[i]]=i;\\n        }\\n        \\n        vector<int> masks;\\n        for(auto x: nums){\\n            if(x==4 ||  x==8 || x==9 || x==12 || x==16 || x==18 || x==20 || x==24 || x==25 || x==27 || x==28){ // number having more than 1 duplicate primes leading to a square number\\n                continue;\\n            }\\n            \\n            int mask=primeFactorisation_MASK(x);\\n            masks.push_back(mask);\\n        }\\n        \\n        memset(dp,-1,sizeof(dp));\\n        return helper(0,0,masks)-1; // -1 because there is an empty subset in the answer\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210207,
                "title": "c-dp-with-bitmasks-with-proper-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDP is kindof obvious for counting subsets. Now for each element we have choice of taking or not taking it. To decide whether I can take this element I should know if I havent taken any element that shares a common prime factor. Since elements of array are only upto 30 there are only 10 primes numbers to deal with. This hints towards keeping a mask for them which is 2^10 = 1024 and that fits in the time limit as well.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*1024)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n*1024)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    \\n    int dp[1001][1025];\\n    vector<int> nums;\\n    map<int,int> mp;\\n    int mod = 1e9+7;\\n    int n;\\n    int rec(int level,int mask){\\n        if(level == n){\\n            return 1;\\n        }\\n        if(dp[level][mask] != -1) return dp[level][mask];\\n        int ans = rec(level+1,mask)%mod;\\n                int temp = mask;\\n        if(mp.find(nums[level]) == mp.end()){\\n\\n        bool ok = true;\\n        for(int i=0;i<10;i++){\\n            if(nums[level]%v[i] == 0 && (mask&(1<<i))) ok = false;\\n            if(nums[level]%v[i] == 0) mask|=(1<<i);\\n        }\\n        if(ok) {\\n            ans+=(rec(level+1,mask))%mod;\\n            ans%=mod;\\n        }\\n        }\\n        return dp[level][temp] = ans;\\n    }\\n    \\n    int squareFreeSubsets(vector<int>& _nums) {\\n        nums = _nums;\\n        n = nums.size();\\n        mp[4] = 1;\\n        mp[9] = 1;\\n        mp[16] = 1;\\n        mp[25] = 1;\\n        mp[8] = 1;\\n        mp[27] = 1;\\n        mp[12] = 1;\\n        mp[20] = 1;\\n        mp[24] = 1;\\n        mp[28] =  1;\\n        mp[18] = 1;\\n        \\n        memset(dp,-1,sizeof(dp));\\n        v = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n        return (rec(0,0)-1+mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    \\n    int dp[1001][1025];\\n    vector<int> nums;\\n    map<int,int> mp;\\n    int mod = 1e9+7;\\n    int n;\\n    int rec(int level,int mask){\\n        if(level == n){\\n            return 1;\\n        }\\n        if(dp[level][mask] != -1) return dp[level][mask];\\n        int ans = rec(level+1,mask)%mod;\\n                int temp = mask;\\n        if(mp.find(nums[level]) == mp.end()){\\n\\n        bool ok = true;\\n        for(int i=0;i<10;i++){\\n            if(nums[level]%v[i] == 0 && (mask&(1<<i))) ok = false;\\n            if(nums[level]%v[i] == 0) mask|=(1<<i);\\n        }\\n        if(ok) {\\n            ans+=(rec(level+1,mask))%mod;\\n            ans%=mod;\\n        }\\n        }\\n        return dp[level][temp] = ans;\\n    }\\n    \\n    int squareFreeSubsets(vector<int>& _nums) {\\n        nums = _nums;\\n        n = nums.size();\\n        mp[4] = 1;\\n        mp[9] = 1;\\n        mp[16] = 1;\\n        mp[25] = 1;\\n        mp[8] = 1;\\n        mp[27] = 1;\\n        mp[12] = 1;\\n        mp[20] = 1;\\n        mp[24] = 1;\\n        mp[28] =  1;\\n        mp[18] = 1;\\n        \\n        memset(dp,-1,sizeof(dp));\\n        v = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n        return (rec(0,0)-1+mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209985,
                "title": "c-recursion-solution-faster-than-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_set<int> sq {4,8,9,12,16,18,20,24,25,27,28};//multiple of square numbers\\n    int cur = 0; \\n    long long subset(vector<int>& nums,vector<long long> &count,vector<int> &divider, int pos){       \\n        if (pos == nums.size()){\\n            return 0;\\n        }\\n        long long op1 = 0; \\n        long long op2 = 0;    \\n        //nums[pos] is not a multiple of square number\\n        //take nums[pos]\\n        //add all divider of nums[pos] to the current divider set\\n        int prev = cur;\\n        if ((cur & divider[nums[pos]]) ==0){//there are no duplicated prime factors in current combination and the new divider\\n            cur = cur | divider[nums[pos]];\\n            op1 = count[pos]  % 1000000007+ count[pos]  % 1000000007 *subset(nums,count,divider,pos+1);// take any one from nums[pos]\\n            cur = prev;//backtracking\\n        }\\n        op2 = subset(nums,count,divider,pos+1);//not take nums[pos]  % 1000000007\\n        //cout << pos << op1 << op2 << endl;\\n        return (op1+op2) % 1000000007;\\n    }   \\n    int squareFreeSubsets(vector<int>& nums) {\\n        vector<int> v = {2,3,5,7,11,13,17,19,23,29};\\n        unordered_map<int,int> index;\\n        for (int i=0; i< v.size();i++){\\n            index.emplace(v[i],pow(2,i));//gove each prime number < 30 a index of power of 2\\n        }\\n        vector<int> divider(31,0);// the prime factor of each number from 1 to 30\\n        for (int i=1; i<=30; i++){\\n            for (int j=0; j< v.size();j++){\\n                if (i <j){\\n                    continue; \\n                }\\n                if (i% v[j] ==0){//combine all prime factors into a binary number like 1010101\\n                    divider[i] = index[v[j]] | divider[i];                   \\n                }\\n            }\\n            //cout << i << \":\" << divider[i] << endl;\\n        }\\n        unordered_map<int,int> freq;//count the appearing time of each number in nums\\n        for (int i= nums.size()-1; i>=0; i--){\\n            if (sq.find(nums[i]) != sq.end()){//we can remove square numbers directly\\n                nums.erase(nums.begin()+i);\\n                continue;\\n            }\\n            if (freq.find(nums[i]) == freq.end()){\\n                freq.emplace(nums[i],1);\\n            } else{\\n                freq[nums[i]]++;\\n            }\\n        }\\n        vector<int> elem;\\n        vector<long long> count;\\n        long long multiplier = 1;\\n        for (auto &e: freq){\\n            if (e.first == 1){//we can choose any combination of 1 \\n                //multiplier = pow(2,e.second)-1;exceed the limit of long long\\n                while (e.second){\\n                    multiplier = multiplier *2 % 1000000007;\\n                    e.second--;\\n                }\\n                multiplier--;\\n                elem.push_back(e.first);\\n                count.push_back(multiplier);\\n                continue;\\n            }\\n            elem.push_back(e.first);\\n            count.push_back(e.second);\\n        }\\n\\n        return subset(elem,count, divider,0);\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<int> sq {4,8,9,12,16,18,20,24,25,27,28};//multiple of square numbers\\n    int cur = 0; \\n    long long subset(vector<int>& nums,vector<long long> &count,vector<int> &divider, int pos){       \\n        if (pos == nums.size()){\\n            return 0;\\n        }\\n        long long op1 = 0; \\n        long long op2 = 0;    \\n        //nums[pos] is not a multiple of square number\\n        //take nums[pos]\\n        //add all divider of nums[pos] to the current divider set\\n        int prev = cur;\\n        if ((cur & divider[nums[pos]]) ==0){//there are no duplicated prime factors in current combination and the new divider\\n            cur = cur | divider[nums[pos]];\\n            op1 = count[pos]  % 1000000007+ count[pos]  % 1000000007 *subset(nums,count,divider,pos+1);// take any one from nums[pos]\\n            cur = prev;//backtracking\\n        }\\n        op2 = subset(nums,count,divider,pos+1);//not take nums[pos]  % 1000000007\\n        //cout << pos << op1 << op2 << endl;\\n        return (op1+op2) % 1000000007;\\n    }   \\n    int squareFreeSubsets(vector<int>& nums) {\\n        vector<int> v = {2,3,5,7,11,13,17,19,23,29};\\n        unordered_map<int,int> index;\\n        for (int i=0; i< v.size();i++){\\n            index.emplace(v[i],pow(2,i));//gove each prime number < 30 a index of power of 2\\n        }\\n        vector<int> divider(31,0);// the prime factor of each number from 1 to 30\\n        for (int i=1; i<=30; i++){\\n            for (int j=0; j< v.size();j++){\\n                if (i <j){\\n                    continue; \\n                }\\n                if (i% v[j] ==0){//combine all prime factors into a binary number like 1010101\\n                    divider[i] = index[v[j]] | divider[i];                   \\n                }\\n            }\\n            //cout << i << \":\" << divider[i] << endl;\\n        }\\n        unordered_map<int,int> freq;//count the appearing time of each number in nums\\n        for (int i= nums.size()-1; i>=0; i--){\\n            if (sq.find(nums[i]) != sq.end()){//we can remove square numbers directly\\n                nums.erase(nums.begin()+i);\\n                continue;\\n            }\\n            if (freq.find(nums[i]) == freq.end()){\\n                freq.emplace(nums[i],1);\\n            } else{\\n                freq[nums[i]]++;\\n            }\\n        }\\n        vector<int> elem;\\n        vector<long long> count;\\n        long long multiplier = 1;\\n        for (auto &e: freq){\\n            if (e.first == 1){//we can choose any combination of 1 \\n                //multiplier = pow(2,e.second)-1;exceed the limit of long long\\n                while (e.second){\\n                    multiplier = multiplier *2 % 1000000007;\\n                    e.second--;\\n                }\\n                multiplier--;\\n                elem.push_back(e.first);\\n                count.push_back(multiplier);\\n                continue;\\n            }\\n            elem.push_back(e.first);\\n            count.push_back(e.second);\\n        }\\n\\n        return subset(elem,count, divider,0);\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3208988,
                "title": "c-using-bits-and-a-map-tree-100-beats-w-r-t-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Using an integer for representing what prime numbers are used to generate the integer.\\n- All the prime numbers required here are just 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 because intergers are less than or eqaul to 30.\\n- Numbers like 4 and 12 can be ignored because those are not square-free.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs shown above, there are only 10 primes numbers less than 30. From the definition of square-free, the number of a given prime number contained in a square-free integer is 0 or 1. This fact means each square free integer corresponds a 10-bits sequence, e.g, 2 <--> `1000000000`, 6 (=2*3)  <--> `1100000000`, and 29 <--> `0000000001`. Note that the integer `1` has to be assigned to `0000000000`,\\n\\nUsing the above fact, an algorithm is written as follows.\\n- For each integer contained in `nums`, map the integer to a 10-bits sequence. If the integer is not square free, then that integer is ignored. The integer and the count of its appearance are set into a map structure.\\n- Define a dp table. Here it is assumed all the square free integers in `nums` are aligned and their indices are given. Then a dp table is defined as `dp[i][s] = {the number of subsets to produce the bit sequence s using the first i square-free integers}`. \\n- Update the dp table by following the rules. Here the index `i+1` is considered and it is assumed that the corresponding integer is `x` ans its count is `c`.\\n  -  The number of the combinations using `x` to produce a square-free integer is: a): if x is not 1 (not a sequence with only 0), then the number of combination is `c` (Using some `x` yields producing non square-free integers). b) otherwise, the number of combinations is `2^c - 1`. Set this number as `v`.\\n  - `dp[i+1][x] += v`. This means subsets using only x.\\n  - For all the `s`, set `dp[i+1][s] += dp[i][s]`. This means subsets not using x.\\n  - For all the `s`, if `(s & x) == 0`, then the multiplication of `s` and `x` is square-free. In such a case, `dp[i+1][s^x] += dp[i][s]`.\\n\\nThe result is obtained as a sum of `dp[N][s]` over all the sequences `s`, where `N` is the number of non square free integers appeared in `nums`. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe bottle neck lies on calculating a dp table. The order is O(n). The order involving a map structure is ignored here because there are at most 30 elements.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe dominant order lies on calculating a dp table and it is O(n).\\n\\n# Code\\n```\\nusing ll = long long int;\\nconstexpr int MAXV = 1 << 10;\\nconstexpr ll MOD = (ll)(1e9 + 7);\\nll dp[31][MAXV];\\nint pnums[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\nclass Solution {\\npublic:\\n    void init(){\\n        for(int i=0;i<31;i++){\\n            for(int v=0;v<MAXV;v++)\\n              dp[i][v] = 0;\\n        }\\n    }\\n    int get_p(int x){\\n        init();\\n        int v = 0;\\n        for(int p : pnums){\\n            v = v << 1;\\n            int cnt = 0;\\n            while(x%p == 0){\\n                x = x/p;\\n                cnt++;\\n            }\\n            if(cnt > 1){\\n              return -1;\\n            }else if(cnt == 1){\\n                v = v + 1;\\n            }\\n        }\\n        return v;\\n    }\\n    ll get_num(const int x, int cnt){\\n        if(x > 0)\\n          return ((ll)cnt)%MOD;\\n        ll num = 1;\\n        ll tmp = 2;\\n        while(cnt > 0){\\n            if(cnt%2 == 1){\\n              num = (num * tmp) % MOD;\\n            }\\n            tmp = (tmp * tmp) % MOD;\\n            cnt = cnt >> 1;\\n        }\\n        return (num + MOD - 1)%MOD;\\n    }\\n    int squareFreeSubsets(vector<int>& nums) {\\n        ll ans = 0;\\n        map<int, int> m;\\n        for(int n : nums){\\n            int x = get_p(n);\\n            if(x < 0)\\n              continue;\\n            if(m.count(x) == 0){\\n                m.insert(make_pair(x, 1));\\n            }else{\\n                auto iter = m.find(x);\\n                iter->second = iter->second + 1;\\n            }\\n        }\\n        int cnt = 0;\\n        for(auto [k, v] : m){\\n            ll n = get_num(k, v);\\n            dp[cnt+1][k] = (dp[cnt+1][k] + n) % MOD; \\n            for(int i=0;i<MAXV;i++){\\n                dp[cnt+1][i] = (dp[cnt+1][i] + dp[cnt][i]) % MOD;\\n                if((k & i) == 0){\\n                    dp[cnt+1][(k ^ i)] =  (dp[cnt+1][(k ^ i)] + dp[cnt][i] * n) % MOD;\\n                }\\n            }\\n            cnt++;\\n        }\\n        for(int i=0;i<MAXV;i++){\\n            ans = (ans + dp[cnt][i]) % MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nusing ll = long long int;\\nconstexpr int MAXV = 1 << 10;\\nconstexpr ll MOD = (ll)(1e9 + 7);\\nll dp[31][MAXV];\\nint pnums[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\nclass Solution {\\npublic:\\n    void init(){\\n        for(int i=0;i<31;i++){\\n            for(int v=0;v<MAXV;v++)\\n              dp[i][v] = 0;\\n        }\\n    }\\n    int get_p(int x){\\n        init();\\n        int v = 0;\\n        for(int p : pnums){\\n            v = v << 1;\\n            int cnt = 0;\\n            while(x%p == 0){\\n                x = x/p;\\n                cnt++;\\n            }\\n            if(cnt > 1){\\n              return -1;\\n            }else if(cnt == 1){\\n                v = v + 1;\\n            }\\n        }\\n        return v;\\n    }\\n    ll get_num(const int x, int cnt){\\n        if(x > 0)\\n          return ((ll)cnt)%MOD;\\n        ll num = 1;\\n        ll tmp = 2;\\n        while(cnt > 0){\\n            if(cnt%2 == 1){\\n              num = (num * tmp) % MOD;\\n            }\\n            tmp = (tmp * tmp) % MOD;\\n            cnt = cnt >> 1;\\n        }\\n        return (num + MOD - 1)%MOD;\\n    }\\n    int squareFreeSubsets(vector<int>& nums) {\\n        ll ans = 0;\\n        map<int, int> m;\\n        for(int n : nums){\\n            int x = get_p(n);\\n            if(x < 0)\\n              continue;\\n            if(m.count(x) == 0){\\n                m.insert(make_pair(x, 1));\\n            }else{\\n                auto iter = m.find(x);\\n                iter->second = iter->second + 1;\\n            }\\n        }\\n        int cnt = 0;\\n        for(auto [k, v] : m){\\n            ll n = get_num(k, v);\\n            dp[cnt+1][k] = (dp[cnt+1][k] + n) % MOD; \\n            for(int i=0;i<MAXV;i++){\\n                dp[cnt+1][i] = (dp[cnt+1][i] + dp[cnt][i]) % MOD;\\n                if((k & i) == 0){\\n                    dp[cnt+1][(k ^ i)] =  (dp[cnt+1][(k ^ i)] + dp[cnt][i] * n) % MOD;\\n                }\\n            }\\n            cnt++;\\n        }\\n        for(int i=0;i<MAXV;i++){\\n            ans = (ans + dp[cnt][i]) % MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208177,
                "title": "golang-precalc-dm-primefact",
                "content": "```\\nfunc squareFreeSubsets(nums []int) int {\\n    bms:=[]int{-1, 0, 4, 8, -1, 32, 12, 128, -1, -1, 36, 2048, -1, 8192, 132, 40, -1, 131072, -1, 524288, -1, 136, 2052, 8388608, -1, -1, 8196, -1, -1, 536870912, 44}\\n    var dp func(i,bm int) int\\n    mem := make([]map[int]int, len(nums))\\n    for i := range mem { mem[i] = map[int]int{} }\\n    dp = func(i,bm int) int {\\n        if i>=len(nums) { return 0 }\\n        if v,ok:=mem[i][bm];ok{ return v }\\n        a := 0\\n        if bms[nums[i]]!=-1&&bms[nums[i]]&bm==0 { a+=1+dp(i+1,bms[nums[i]]|bm) }\\n        a += dp(i+1,bm)\\n        mem[i][bm]=a%(1000000007)\\n        return a%(1000000007)\\n    }\\n    return dp(0,0)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc squareFreeSubsets(nums []int) int {\\n    bms:=[]int{-1, 0, 4, 8, -1, 32, 12, 128, -1, -1, 36, 2048, -1, 8192, 132, 40, -1, 131072, -1, 524288, -1, 136, 2052, 8388608, -1, -1, 8196, -1, -1, 536870912, 44}\\n    var dp func(i,bm int) int\\n    mem := make([]map[int]int, len(nums))\\n    for i := range mem { mem[i] = map[int]int{} }\\n    dp = func(i,bm int) int {\\n        if i>=len(nums) { return 0 }\\n        if v,ok:=mem[i][bm];ok{ return v }\\n        a := 0\\n        if bms[nums[i]]!=-1&&bms[nums[i]]&bm==0 { a+=1+dp(i+1,bms[nums[i]]|bm) }\\n        a += dp(i+1,bm)\\n        mem[i][bm]=a%(1000000007)\\n        return a%(1000000007)\\n    }\\n    return dp(0,0)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3208090,
                "title": "python3-bottom-up-dp-bitmask",
                "content": "```\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\\n        def getMask(num: int) -> int:\\n            if num == 0: return -1\\n            mask = 0\\n            for i, prime in enumerate(primes):\\n                count = 0\\n                while num%prime == 0:\\n                    count += 1\\n                    num //=prime\\n                if count > 1: return -1\\n                if count == 1: mask |= (1<<i)\\n            return mask\\n            \\n        masks = [getMask(num) for num in range(31)];\\n        nums = [masks[num] for num in nums if masks[num] != -1]\\n        dp = [0]*(1<<10)\\n        mod = int(1e9)+7\\n        dp[0] = 1\\n        \\n        for num in nums:\\n            for mask in range(1<<10):\\n                if mask & num == 0:\\n                    dp[num|mask] = (dp[mask] + dp[num|mask])%mod\\n        \\n        return (sum(dp) - 1)%mod\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Iterator",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\\n        def getMask(num: int) -> int:\\n            if num == 0: return -1\\n            mask = 0\\n            for i, prime in enumerate(primes):\\n                count = 0\\n                while num%prime == 0:\\n                    count += 1\\n                    num //=prime\\n                if count > 1: return -1\\n                if count == 1: mask |= (1<<i)\\n            return mask\\n            \\n        masks = [getMask(num) for num in range(31)];\\n        nums = [masks[num] for num in nums if masks[num] != -1]\\n        dp = [0]*(1<<10)\\n        mod = int(1e9)+7\\n        dp[0] = 1\\n        \\n        for num in nums:\\n            for mask in range(1<<10):\\n                if mask & num == 0:\\n                    dp[num|mask] = (dp[mask] + dp[num|mask])%mod\\n        \\n        return (sum(dp) - 1)%mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207946,
                "title": "scala",
                "content": "```Scala\\nobject Solution {\\n  def squareFreeSubsets(nums: Array[Int]): Int = {\\n    val primes = Vector(2, 3, 5, 7, 11, 13, 17, 19, 23, 29)\\n    val m = (1e9 + 7).toLong\\n    def add(x: Long, y: Long) = ((x + y) % m + m) % m\\n\\n    def primeFactors(x: Int): Option[Int] = primes.indexWhere(x % _ == 0) match {\\n      case -1 => Some(0)\\n      case i => primeFactors(x / primes(i)) match {\\n        case Some(bits) if ((1 << i) & bits) == 0 => Some((1 << i) | bits)\\n        case _ => None\\n      }\\n    }\\n\\n    nums.foldLeft(Vector.fill(1 << primes.size)(1L)) {\\n      case (dp, n) => primeFactors(n) match {\\n        case None => dp\\n        case Some(factors) => Vector.tabulate(dp.size)(bits => {\\n          if ((factors & bits) != 0) dp(bits)\\n          else add(dp(bits | factors), dp(bits))\\n        })\\n      }\\n    }(0).toInt - 1\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```Scala\\nobject Solution {\\n  def squareFreeSubsets(nums: Array[Int]): Int = {\\n    val primes = Vector(2, 3, 5, 7, 11, 13, 17, 19, 23, 29)\\n    val m = (1e9 + 7).toLong\\n    def add(x: Long, y: Long) = ((x + y) % m + m) % m\\n\\n    def primeFactors(x: Int): Option[Int] = primes.indexWhere(x % _ == 0) match {\\n      case -1 => Some(0)\\n      case i => primeFactors(x / primes(i)) match {\\n        case Some(bits) if ((1 << i) & bits) == 0 => Some((1 << i) | bits)\\n        case _ => None\\n      }\\n    }\\n\\n    nums.foldLeft(Vector.fill(1 << primes.size)(1L)) {\\n      case (dp, n) => primeFactors(n) match {\\n        case None => dp\\n        case Some(factors) => Vector.tabulate(dp.size)(bits => {\\n          if ((factors & bits) != 0) dp(bits)\\n          else add(dp(bits | factors), dp(bits))\\n        })\\n      }\\n    }(0).toInt - 1\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3207714,
                "title": "swift-dp-fastest-300-ms",
                "content": "**DP (accepted answer)**\\n```\\nclass Solution {\\n    func squareFreeSubsets(_ nums: [Int]) -> Int {\\n        let primes = [2,3,5,7,11,13,17,19,23,29]\\n        let bitMasks = (0..<31).map {i in zip(0..., primes).filter{i % $0.1 == 0}.reduce(0) { $0 | 1 << $1.0}}\\n        let bits = nums.filter { ($0 % 4 != 0) && ($0 % 9 != 0) && ($0 != 25) }.map { bitMasks[$0] }\\n        var dp = Array(repeating: Array(repeating: 0, count: 1024), count: bits.count)\\n        \\n        func dfs(_ i: Int, _ mask: Int) -> Int {\\n            guard i < bits.count else { return 0 }\\n            guard dp[i][mask] == 0 else { return dp[i][mask]-1 }\\n            dp[i][mask] = 1 + dfs(i+1, mask) + (mask & bits[i] == 0 ? dfs(i+1, mask | bits[i]) + 1 : 0)\\n            return (dp[i][mask] - 1) % Int(1.0e9 + 7)\\n        }\\n        \\n        return dfs(0,0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func squareFreeSubsets(_ nums: [Int]) -> Int {\\n        let primes = [2,3,5,7,11,13,17,19,23,29]\\n        let bitMasks = (0..<31).map {i in zip(0..., primes).filter{i % $0.1 == 0}.reduce(0) { $0 | 1 << $1.0}}\\n        let bits = nums.filter { ($0 % 4 != 0) && ($0 % 9 != 0) && ($0 != 25) }.map { bitMasks[$0] }\\n        var dp = Array(repeating: Array(repeating: 0, count: 1024), count: bits.count)\\n        \\n        func dfs(_ i: Int, _ mask: Int) -> Int {\\n            guard i < bits.count else { return 0 }\\n            guard dp[i][mask] == 0 else { return dp[i][mask]-1 }\\n            dp[i][mask] = 1 + dfs(i+1, mask) + (mask & bits[i] == 0 ? dfs(i+1, mask | bits[i]) + 1 : 0)\\n            return (dp[i][mask] - 1) % Int(1.0e9 + 7)\\n        }\\n        \\n        return dfs(0,0)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207666,
                "title": "13ms-intuitive-c-solution-no-bit-mask",
                "content": "# Intuition\\nWe can use the fact that all elements are between 1 and 30. We need to store the counts of each element and recursively build the subsets.\\n\\n# Approach\\nForget about the 1s for now because they can be added to any subset. Start recursively building sets, an element can be added to a set if gcd of product of elements in the set and the new element is 1 and the element is not divisible by a square. So when we start with 2, we will add 3, 5, 7 and so on, each time an element is added, the new count so far is old count * count of new element (because we can chose any of them if there is more than one). \\nIf we have 1s, we can add any permutation of it to every subset so we need to multiply the final result with the (2^(number of 1s)) and also add (2^(number of 1s))-1 to consider the case where only 1s exist in the set, -1 because we don\\'t want the empty set\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    long long res = 0;\\n    int squareFreeSubsets(vector<int>& nums) {\\n        vector<int> counts(31);\\n        for (int i = 0; i < nums.size(); ++i) {\\n            counts[nums[i]]++;\\n        }\\n        \\n        unordered_set<int> forbidden{9,18,27,4,8,12,16,20,24,28,25};\\n        backtrack(2, 1, 1, counts, forbidden);\\n        \\n        long long pow = 1;\\n        for (int i = 1; i <= counts[1]; i++) {\\n            pow = (pow * 2) % mod;\\n        }\\n        return (res * pow + pow - 1) % mod;\\n    }\\n    \\n    void backtrack(int index, long long count, long long prod, vector<int> &counts, unordered_set<int> &forbidden) {   \\n        for (int i = index; i <= 30; ++i) {\\n            if (!forbidden.count(i) && gcd(i, prod) == 1 && counts[i]) {\\n                res = (res + (count * counts[i])%mod) % mod;\\n                backtrack(i+1, (count * counts[i])%mod, prod*i, counts, forbidden);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    long long res = 0;\\n    int squareFreeSubsets(vector<int>& nums) {\\n        vector<int> counts(31);\\n        for (int i = 0; i < nums.size(); ++i) {\\n            counts[nums[i]]++;\\n        }\\n        \\n        unordered_set<int> forbidden{9,18,27,4,8,12,16,20,24,28,25};\\n        backtrack(2, 1, 1, counts, forbidden);\\n        \\n        long long pow = 1;\\n        for (int i = 1; i <= counts[1]; i++) {\\n            pow = (pow * 2) % mod;\\n        }\\n        return (res * pow + pow - 1) % mod;\\n    }\\n    \\n    void backtrack(int index, long long count, long long prod, vector<int> &counts, unordered_set<int> &forbidden) {   \\n        for (int i = index; i <= 30; ++i) {\\n            if (!forbidden.count(i) && gcd(i, prod) == 1 && counts[i]) {\\n                res = (res + (count * counts[i])%mod) % mod;\\n                backtrack(i+1, (count * counts[i])%mod, prod*i, counts, forbidden);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207456,
                "title": "11-dimension-dp",
                "content": "At first I was using the array itself as the memoization key but my solution was getting TLE for the last few test cases... I didn\\'t want to start all the way over with a bitmask solution so I figured converting my solution to 11D memo would save me some time and might still pass.\\n\\n```\\nclass Solution {\\npublic:\\n    typedef array<int, 10> ai;\\n    map<int, int> comp;\\n    map<int, vector<int>> mp;\\n    int MOD = 1e9+7;\\n    void fac(int n){\\n        int og = n;\\n        vector<int> ans;\\n        for(int i = 2; i <= sqrt(n); i++){\\n            bool flag = false;\\n            while(n%i == 0){\\n                n/=i;\\n                ans.push_back(comp[i]);\\n            }\\n        }\\n        if(n>=2) ans.push_back(comp[n]);\\n        mp[og] = ans;\\n    }   \\n    int dp[1001][2][2][2][2][2][2][2][2][2][2][2];\\n    int dfs(vector<int>& nums, int pos, ai m, bool cnt){\\n        if(pos>= nums.size()) return cnt;\\n        if(dp[pos][cnt][m[0]][m[1]][m[2]][m[3]][m[4]][m[5]][m[6]][m[7]][m[8]][m[9]] != -1) \\n            return dp[pos][cnt][m[0]][m[1]][m[2]][m[3]][m[4]][m[5]][m[6]][m[7]][m[8]][m[9]];\\n        auto o = m;\\n        int ans = 0;\\n        ans += dfs(nums, pos+1, m, cnt);\\n        ans %= MOD;\\n        bool ok = true;\\n        for(auto i : mp[nums[pos]]){\\n            m[i]++;\\n            if(m[i]>1) ok = false;\\n        }\\n        if(ok) ans += dfs(nums, pos+1, m, true);\\n        ans %= MOD;\\n        return dp[pos][cnt][o[0]][o[1]][o[2]][o[3]][o[4]][o[5]][o[6]][o[7]][o[8]][o[9]] = ans;\\n    }\\n    int squareFreeSubsets(vector<int>& nums) {\\n        memset(dp, -1, sizeof dp);\\n        comp[2] = 0;\\n        comp[3] = 1;\\n        comp[5] = 2;\\n        comp[7] = 3;\\n        comp[11] = 4;\\n        comp[13] = 5;\\n        comp[17] = 6;\\n        comp[19] = 7;\\n        comp[23] = 8;\\n        comp[29] = 9;\\n        for(int i = 1; i <= 30; i++) fac(i);\\n        ai mask = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\\n        int ans = dfs(nums, 0, mask, false);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    typedef array<int, 10> ai;\\n    map<int, int> comp;\\n    map<int, vector<int>> mp;\\n    int MOD = 1e9+7;\\n    void fac(int n){\\n        int og = n;\\n        vector<int> ans;\\n        for(int i = 2; i <= sqrt(n); i++){\\n            bool flag = false;\\n            while(n%i == 0){\\n                n/=i;\\n                ans.push_back(comp[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3207318,
                "title": "c-simple-counter",
                "content": "```\\nclass Solution {\\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        map<long long, long long> cnt;\\n        const long long mod = 1e9+7;\\n        for(long long x:nums){\\n            if(x%4==0 || x%9==0 || x==25) continue;\\n            for(auto& [y, n] : cnt)\\n                if(gcd(x, y) == 1) cnt[x*y] = (cnt[x*y]+n) % mod;\\n            cnt[x]++;\\n        }\\n        long long sum = 0;\\n        for(auto [x,n] : cnt) sum += n;\\n        return sum % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        map<long long, long long> cnt;\\n        const long long mod = 1e9+7;\\n        for(long long x:nums){\\n            if(x%4==0 || x%9==0 || x==25) continue;\\n            for(auto& [y, n] : cnt)\\n                if(gcd(x, y) == 1) cnt[x*y] = (cnt[x*y]+n) % mod;\\n            cnt[x]++;\\n        }\\n        long long sum = 0;\\n        for(auto [x,n] : cnt) sum += n;\\n        return sum % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207305,
                "title": "prime-factorization-dp-on-subsequence",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int mod = 1e9 + 7;\\n    map<int,int> primefactors(int n){\\n        map<int,int> set;\\n        for(int i = 2; i * i <= n; i++){\\n            while(n % i == 0) {\\n                set[i]++;\\n                n /= i;\\n            }\\n        }\\n        if( n > 1 ) set[n]++;\\n        return set;\\n    }\\n    \\n    long long dp[1002][2055];\\n    \\n    long long memo(vector<long long> &another, int curr, int i){\\n        int n = another.size();\\n        if(i >= n) return 1;\\n        if(dp[i][curr] != -1) return dp[i][curr];\\n        \\n        long long first = memo(another, curr , i + 1), second = 0;\\n        if((curr | another[i]) == (curr ^ another[i]))\\n            second = memo(another,(curr | another[i]), i + 1);\\n        \\n        return dp[i][curr] = (first + second) % mod;\\n    }\\n    \\n    int squareFreeSubsets(vector<int>& nums) {\\n        int n = nums.size();\\n        int arr[] = {1,2,3,5,7,11,13,17,19,23,29};\\n\\n        map<int,int> hash;\\n        for(int i = 0; i < 11; i++) hash[arr[i]] = i;\\n\\n        vector<long long> another;\\n        for(int i = 0; i < n; i++){\\n            auto mp = primefactors(nums[i]);\\n            int mask = 0; bool flag = false;\\n            for(auto i: mp){\\n                if(i.second > 1){\\n                    flag = true;\\n                    break;\\n                }\\n                \\n                mask |= (1 << hash[i.first]);\\n                \\n            }\\n            if(flag) continue;\\n            another.push_back(mask);\\n        }\\n\\n        memset(dp,-1,sizeof dp);\\n        return memo(another,0,0) - 1 + mod % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int mod = 1e9 + 7;\\n    map<int,int> primefactors(int n){\\n        map<int,int> set;\\n        for(int i = 2; i * i <= n; i++){\\n            while(n % i == 0) {\\n                set[i]++;\\n                n /= i;\\n            }\\n        }\\n        if( n > 1 ) set[n]++;\\n        return set;\\n    }\\n    \\n    long long dp[1002][2055];\\n    \\n    long long memo(vector<long long> &another, int curr, int i){\\n        int n = another.size();\\n        if(i >= n) return 1;\\n        if(dp[i][curr] != -1) return dp[i][curr];\\n        \\n        long long first = memo(another, curr , i + 1), second = 0;\\n        if((curr | another[i]) == (curr ^ another[i]))\\n            second = memo(another,(curr | another[i]), i + 1);\\n        \\n        return dp[i][curr] = (first + second) % mod;\\n    }\\n    \\n    int squareFreeSubsets(vector<int>& nums) {\\n        int n = nums.size();\\n        int arr[] = {1,2,3,5,7,11,13,17,19,23,29};\\n\\n        map<int,int> hash;\\n        for(int i = 0; i < 11; i++) hash[arr[i]] = i;\\n\\n        vector<long long> another;\\n        for(int i = 0; i < n; i++){\\n            auto mp = primefactors(nums[i]);\\n            int mask = 0; bool flag = false;\\n            for(auto i: mp){\\n                if(i.second > 1){\\n                    flag = true;\\n                    break;\\n                }\\n                \\n                mask |= (1 << hash[i.first]);\\n                \\n            }\\n            if(flag) continue;\\n            another.push_back(mask);\\n        }\\n\\n        memset(dp,-1,sizeof dp);\\n        return memo(another,0,0) - 1 + mod % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207155,
                "title": "python3-bottom-up-dp",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/485c537c6fa9056ce656959ea352d2a68cef473f) for solutions of weekly 333. \\n\\n```\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        mod = 1_000_000_007\\n        primes = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29\\n        mask = [-1]*31 \\n        mask[1] = 0 \\n        for x in range(2, 31): \\n            m, v = 0, 1\\n            for i, p in enumerate(primes): \\n                if x % p == 0: \\n                    v *= p \\n                    m ^= 1<<i\\n            if v == x: mask[x] = m \\n        n = len(nums)\\n        dp = [[0]*(1<<10) for _ in range(n+1)]\\n        for j in range(1<<10): dp[n][j] = 1\\n        for i in range(n-1, -1, -1): \\n            m = mask[nums[i]]\\n            for j in range(1<<10): \\n                dp[i][j] = dp[i+1][j]\\n                if m >= 0 and j & m == 0: dp[i][j] = (dp[i][j] + dp[i+1][j ^ m]) % mod\\n        return (dp[0][0] - 1) % mod\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        mod = 1_000_000_007\\n        primes = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29\\n        mask = [-1]*31 \\n        mask[1] = 0 \\n        for x in range(2, 31): \\n            m, v = 0, 1\\n            for i, p in enumerate(primes): \\n                if x % p == 0: \\n                    v *= p \\n                    m ^= 1<<i\\n            if v == x: mask[x] = m \\n        n = len(nums)\\n        dp = [[0]*(1<<10) for _ in range(n+1)]\\n        for j in range(1<<10): dp[n][j] = 1\\n        for i in range(n-1, -1, -1): \\n            m = mask[nums[i]]\\n            for j in range(1<<10): \\n                dp[i][j] = dp[i+1][j]\\n                if m >= 0 and j & m == 0: dp[i][j] = (dp[i][j] + dp[i+1][j ^ m]) % mod\\n        return (dp[0][0] - 1) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206823,
                "title": "bottom-up-1d-bitmask-dp-count-the-number-of-ones",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n$1 <= nums[i] <= 30$ hints at bitmask DP since we only have 10 primes in this range.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nClassical 1D bottom-up bitmask DP.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(1024 * m + n)$ in which $m$ stands for the number of integers $> 1$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(1024) = O(1)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        vector<int> prime{2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n        unordered_map<int, int> cache;\\n        for (int i = 0; i < 10; i++) cache[prime[i]] = 1 << i;\\n        // 2 * 3 = 6, 2 * 5 = 10, ...., 3 * 7 = 21\\n        for (int i = 0; i < 2; i++) {\\n            for (int j = i + 1; j < 10; j++) {\\n                if (prime[i] * prime[j] > 30) break;\\n                cache[prime[i] * prime[j]] = (1 << i) + (1 << j);\\n            }\\n        }\\n        // 30 = 2 * 3 * 5\\n        cache[30] = 7;\\n        int N = 1 << 10, cnt_one = 0;\\n        vector<int> dp(N, 0);\\n        dp[0] = 1;\\n        int M = 1e9 + 7;\\n        for (const auto& num : nums) {\\n            if (num == 1) {\\n                cnt_one += 1;\\n                continue;\\n            }\\n            if (!cache.count(num)) continue;\\n            int mask = cache[num];\\n            for (int i = N - 1; i >= 0; i--) {\\n                if ((i & mask) == mask) {   // submask check\\n                    dp[i] += dp[i ^ mask];\\n                    dp[i] %= M;\\n                }\\n            }\\n        }\\n        // consider the ones we have counted\\n        int ans = 0;\\n        for (const auto& num : dp) ans = (ans + num) % M;\\n        while (cnt_one-- > 0) ans = (2 * ans) % M;\\n        ans = (ans - 1) % M;\\n        return ans < 0 ? ans + M : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        vector<int> prime{2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n        unordered_map<int, int> cache;\\n        for (int i = 0; i < 10; i++) cache[prime[i]] = 1 << i;\\n        // 2 * 3 = 6, 2 * 5 = 10, ...., 3 * 7 = 21\\n        for (int i = 0; i < 2; i++) {\\n            for (int j = i + 1; j < 10; j++) {\\n                if (prime[i] * prime[j] > 30) break;\\n                cache[prime[i] * prime[j]] = (1 << i) + (1 << j);\\n            }\\n        }\\n        // 30 = 2 * 3 * 5\\n        cache[30] = 7;\\n        int N = 1 << 10, cnt_one = 0;\\n        vector<int> dp(N, 0);\\n        dp[0] = 1;\\n        int M = 1e9 + 7;\\n        for (const auto& num : nums) {\\n            if (num == 1) {\\n                cnt_one += 1;\\n                continue;\\n            }\\n            if (!cache.count(num)) continue;\\n            int mask = cache[num];\\n            for (int i = N - 1; i >= 0; i--) {\\n                if ((i & mask) == mask) {   // submask check\\n                    dp[i] += dp[i ^ mask];\\n                    dp[i] %= M;\\n                }\\n            }\\n        }\\n        // consider the ones we have counted\\n        int ans = 0;\\n        for (const auto& num : dp) ans = (ans + num) % M;\\n        while (cnt_one-- > 0) ans = (2 * ans) % M;\\n        ans = (ans - 1) % M;\\n        return ans < 0 ? ans + M : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206499,
                "title": "java-counting-products",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(1024*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1024+n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static long MOD = (long)(1e9+7);\\n    public int squareFreeSubsets(int[] arr) {\\n        \\n        int[] primes = new int[]{2,3,5,7,11,13,17,19,23,29};\\n        int[] nonSq = new int[]{4,8,9,12,16,18,20,24,25,27,28};\\n        products=new long[1024];\\n        index=0;\\n\\n        rec(primes, 0, new HashSet<>());\\n        Arrays.sort(products);\\n        Arrays.sort(arr);\\n        \\n        Map<Long, Long> cntMap = new HashMap<>();\\n        for(long ele: products) \\n        {\\n            cntMap.put(ele, 0L);\\n        }\\n        cntMap.put(1L, 1L);\\n        long ans=0;\\n        int n=arr.length;\\n\\n        for(int i=0;i<n;++i)\\n        {\\n            int ele=arr[i];\\n            boolean isNonSq = false;\\n            for(int x: nonSq)\\n                if(x==ele)\\n                    isNonSq = true;\\n            \\n            if(isNonSq)\\n                continue;\\n                \\n            for(long x: products)\\n            {\\n                if(x<ele)\\n                    continue;\\n                else if(x%ele==0)\\n                {\\n                    long y=x/ele;\\n                    if(cntMap.get(y)!=0) \\n                    {\\n                        ans=(ans+cntMap.get(y))%MOD;\\n                        cntMap.put(x, (cntMap.get(x)+cntMap.get(y))%MOD);\\n                    }\\n                    \\n                }\\n            }\\n\\n        }\\n        return (int)(ans%MOD);\\n    }\\n    static long[] products;\\n    static int index;\\n    public void rec(int[] primes, int idx, Set<Integer> set)\\n    {\\n        if(idx==primes.length)\\n        {\\n            long pro =1;\\n            for(int x: set)\\n            {\\n                pro=pro*x;\\n            }\\n            products[index] = pro;\\n            index++;\\n            return;\\n        }\\n\\n        set.add(primes[idx]);\\n        rec(primes, idx+1, set);\\n        set.remove(primes[idx]);\\n\\n        rec(primes, idx+1, set);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static long MOD = (long)(1e9+7);\\n    public int squareFreeSubsets(int[] arr) {\\n        \\n        int[] primes = new int[]{2,3,5,7,11,13,17,19,23,29};\\n        int[] nonSq = new int[]{4,8,9,12,16,18,20,24,25,27,28};\\n        products=new long[1024];\\n        index=0;\\n\\n        rec(primes, 0, new HashSet<>());\\n        Arrays.sort(products);\\n        Arrays.sort(arr);\\n        \\n        Map<Long, Long> cntMap = new HashMap<>();\\n        for(long ele: products) \\n        {\\n            cntMap.put(ele, 0L);\\n        }\\n        cntMap.put(1L, 1L);\\n        long ans=0;\\n        int n=arr.length;\\n\\n        for(int i=0;i<n;++i)\\n        {\\n            int ele=arr[i];\\n            boolean isNonSq = false;\\n            for(int x: nonSq)\\n                if(x==ele)\\n                    isNonSq = true;\\n            \\n            if(isNonSq)\\n                continue;\\n                \\n            for(long x: products)\\n            {\\n                if(x<ele)\\n                    continue;\\n                else if(x%ele==0)\\n                {\\n                    long y=x/ele;\\n                    if(cntMap.get(y)!=0) \\n                    {\\n                        ans=(ans+cntMap.get(y))%MOD;\\n                        cntMap.put(x, (cntMap.get(x)+cntMap.get(y))%MOD);\\n                    }\\n                    \\n                }\\n            }\\n\\n        }\\n        return (int)(ans%MOD);\\n    }\\n    static long[] products;\\n    static int index;\\n    public void rec(int[] primes, int idx, Set<Integer> set)\\n    {\\n        if(idx==primes.length)\\n        {\\n            long pro =1;\\n            for(int x: set)\\n            {\\n                pro=pro*x;\\n            }\\n            products[index] = pro;\\n            index++;\\n            return;\\n        }\\n\\n        set.add(primes[idx]);\\n        rec(primes, idx+1, set);\\n        set.remove(primes[idx]);\\n\\n        rec(primes, idx+1, set);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206483,
                "title": "python-3-dp-bitmask",
                "content": "```\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        squared = {4, 8, 9, 12, 16, 18, 20, 24, 25, 27, 28}\\n        \\n        primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29}\\n        masks_map = {}\\n        \\n        for x in range(1, 31):\\n            if x in squared: continue\\n            mask = 0\\n            for p in primes:\\n                if x % p == 0: mask ^= (1 << p)\\n            masks_map[x] = mask\\n            \\n        \\n        \\n        @cache\\n        def helper(m1, m2):\\n            b1, b2 = m1.bit_count(), m2.bit_count()\\n            b12 = (m1 ^ m2).bit_count()\\n            return b1 + b2 == b12\\n        \\n        M = 10 ** 9 + 7\\n        nums = sorted([x for x in nums if x not in squared])\\n        \\n        @cache\\n        def dp(i, mask):\\n            if i == len(nums):\\n                return 0\\n            \\n            m1, m2 = masks_map[nums[i]], mask\\n            if m1 > m2:\\n                m1, m2 = m2, m1\\n            \\n            \\n            if not helper(m1, m2):\\n                return dp(i+1, mask) % M\\n            else:\\n                return (1 + dp(i+1, mask ^ masks_map[nums[i]]) + dp(i+1, mask)) % M\\n        \\n            \\n        \\n        return dp(0, 0)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bitmask"
                ],
                "code": "class Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        squared = {4, 8, 9, 12, 16, 18, 20, 24, 25, 27, 28}",
                "codeTag": "Java"
            },
            {
                "id": 3206109,
                "title": "my-solution",
                "content": "```\\nclass Solution {\\n private:\\n  static constexpr int primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n  static constexpr int n_primes = 10;\\n\\n public:\\n  int squareFreeSubsets(const vector<int> &nums) {\\n    constexpr int mod = 1000000007;\\n    constexpr int layouts = (1 << n_primes);\\n    \\n    vector<int> non_square_nums;\\n    for (const int num : nums) {\\n      if (!is_square_num(num)) {\\n        non_square_nums.emplace_back(num);\\n      }\\n    }\\n    \\n    unordered_map<int, int> num_to_mask;\\n    for (const int num : non_square_nums) {\\n      if (num_to_mask.find(num) == num_to_mask.end()) {\\n        num_to_mask[num] = get_non_square_num_mask(num);\\n      }\\n    }\\n    \\n    int dp[2][layouts];\\n    memset(dp, 0, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    dp[previous][0] = 1;\\n    for (const int num : non_square_nums) {\\n      const int mask = num_to_mask[num];\\n      memcpy(dp[current], dp[previous], sizeof(dp[current]));\\n      for (int layout = 0; layout < layouts; ++layout) {\\n        if ((mask & layout) == 0) {\\n          dp[current][mask | layout] = (dp[current][mask | layout] + dp[previous][layout]) % mod;\\n        }\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n    }\\n    \\n    int ret = 0;\\n    for (const int item : dp[previous]) {\\n      ret = (ret + item) % mod;\\n    }\\n    return (mod + ret - 1) % mod;\\n  }\\n  \\n private:\\n  bool is_square_num(const int num) {\\n    for (int i = 0; i < n_primes && primes[i] * primes[i] < num + 1; ++i) {\\n      if (num % (primes[i] * primes[i]) == 0) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n  \\n  int get_non_square_num_mask(const int num) {\\n    int ret = 0;\\n    for (int i = 0; i < n_primes; ++i) {\\n      if (num % primes[i] == 0) {\\n        ret |= (1 << i);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n private:\\n  static constexpr int primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n  static constexpr int n_primes = 10;\\n\\n public:\\n  int squareFreeSubsets(const vector<int> &nums) {\\n    constexpr int mod = 1000000007;\\n    constexpr int layouts = (1 << n_primes);\\n    \\n    vector<int> non_square_nums;\\n    for (const int num : nums) {\\n      if (!is_square_num(num)) {\\n        non_square_nums.emplace_back(num);\\n      }\\n    }\\n    \\n    unordered_map<int, int> num_to_mask;\\n    for (const int num : non_square_nums) {\\n      if (num_to_mask.find(num) == num_to_mask.end()) {\\n        num_to_mask[num] = get_non_square_num_mask(num);\\n      }\\n    }\\n    \\n    int dp[2][layouts];\\n    memset(dp, 0, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    dp[previous][0] = 1;\\n    for (const int num : non_square_nums) {\\n      const int mask = num_to_mask[num];\\n      memcpy(dp[current], dp[previous], sizeof(dp[current]));\\n      for (int layout = 0; layout < layouts; ++layout) {\\n        if ((mask & layout) == 0) {\\n          dp[current][mask | layout] = (dp[current][mask | layout] + dp[previous][layout]) % mod;\\n        }\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n    }\\n    \\n    int ret = 0;\\n    for (const int item : dp[previous]) {\\n      ret = (ret + item) % mod;\\n    }\\n    return (mod + ret - 1) % mod;\\n  }\\n  \\n private:\\n  bool is_square_num(const int num) {\\n    for (int i = 0; i < n_primes && primes[i] * primes[i] < num + 1; ++i) {\\n      if (num % (primes[i] * primes[i]) == 0) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n  \\n  int get_non_square_num_mask(const int num) {\\n    int ret = 0;\\n    for (int i = 0; i < n_primes; ++i) {\\n      if (num % primes[i] == 0) {\\n        ret |= (1 << i);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205970,
                "title": "java-solution-math-bfs-object-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int squareFreeSubsets(int[] nums) {\\n        // Map + Math - nums[i] <= 30, calculate gcd for nums[i]\\n        int[] primes = new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n        int[] valids = new int[]{2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30}; // basiceSquareFrees - exclude 1 here since it need special calculate\\n        int oneCnt = 0;\\n        Map<Integer, Set<Integer>> map = new HashMap<>(); // <valid num, gcd of the num>\\n        Map<Integer, Integer> numCnt = new HashMap<>(); // <valid num, count of num>\\n        for (int valid : valids) {\\n            map.put(valid, new HashSet<>());\\n            for (int prime : primes) {\\n                if (prime > valid) break;\\n                if (valid % prime == 0) map.get(valid).add(prime);\\n            }\\n            numCnt.put(valid, 0);\\n        }\\n        for (int num : nums) {\\n            if (num == 1) oneCnt++;\\n            if (!numCnt.containsKey(num)) continue;\\n            numCnt.put(num, numCnt.getOrDefault(num, 0) + 1);\\n        }\\n        for (int valid : valids) {\\n            if (numCnt.get(valid) == 0) numCnt.remove(valid);\\n        }\\n        \\n        long res = 0;\\n        // bfs\\n        Set<SubSet> queue = new LinkedHashSet<>();\\n        for (Map.Entry<Integer, Integer> entry : numCnt.entrySet()) {\\n            int num = entry.getKey(); int cnt = entry.getValue();\\n            Set<Integer> components = new HashSet<>(); components.add(num);\\n            queue.add(new SubSet(components, map.get(num), cnt));\\n        }\\n        for (int i=1; i<=numCnt.size(); i++) { // subset size\\n            int size = queue.size();\\n            while (size-- > 0) {\\n                SubSet lastSubSet = queue.iterator().next(); queue.remove(lastSubSet);\\n                res = (res + lastSubSet.combineCnt) % MOD;\\n                for (Map.Entry<Integer, Integer> entry : numCnt.entrySet()) {\\n                    int num = entry.getKey(); int cnt = entry.getValue();\\n                    if (Collections.disjoint(lastSubSet.primes, map.get(num))) {\\n                        Set<Integer> nextPrimes = new HashSet<>(map.get(num)); nextPrimes.addAll(lastSubSet.primes);\\n                        Set<Integer> nextComponents = new HashSet<>(lastSubSet.components); nextComponents.add(num);\\n                        queue.add(new SubSet(nextComponents, nextPrimes, lastSubSet.combineCnt * cnt % MOD));\\n                    }\\n                }\\n            }\\n        }\\n\\n        // process cases with 1\\n        if (oneCnt > 0) {\\n            // oneCombine = C(n, 0) + C(n, 1) + C(n, 2) + ... + C(n, n) <--> n == oneCnt\\n            // C(n, k) = n! / ((n-k)! * k!)\\n            // res = oneCombine * res + oneCombine - 1 // oneCombine - 1 \\u662F\\u56E0\\u4E3A\\u591A\\u7EDF\\u8BA1\\u4E86\\u4E00\\u4E2A\\u4E0D\\u9009\\u4EFB\\u4F55 1 \\u7684\\u60C5\\u51B5\\n            long tmpRes = res; res = 0;\\n            for (int i=0; i<=oneCnt; i++) {\\n                long tmpCombination = combination(oneCnt, i);\\n                res = ((res + tmpRes * tmpCombination % MOD) % MOD + tmpCombination) % MOD;\\n            }\\n            res -= 1;\\n        }\\n        \\n        return (int) res;\\n    }\\n\\n    long MOD = (long) 1e9 + 7;\\n    long[][] dp = new long[1001][1001];\\n    public long combination(int n, int k) { // Binomial Coefficient - C(n, k)\\n        if (dp[n][k] != 0) return dp[n][k]; // memoization to improve performance\\n        // base cases\\n        if (k > n) return 0;\\n        if (k == 0 || k == n) return 1;\\n        // recursive\\n        long res = (combination(n - 1, k - 1) + combination(n - 1, k)) % MOD;\\n        dp[n][k] = res;\\n        return res;\\n    }\\n\\n    class SubSet {\\n        Set<Integer> components;\\n        Set<Integer> primes;\\n        long combineCnt;\\n\\n        SubSet(Set<Integer> components, Set<Integer> primes, long combineCnt) {\\n            this.components = components;\\n            this.primes = primes;\\n            this.combineCnt = combineCnt;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return components.hashCode();\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (this == o) return true;\\n            if (o == null) return false;\\n            if (this.getClass() != o.getClass()) return false;\\n            SubSet obj = (SubSet) o;\\n            return this.components.equals(obj.components);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int squareFreeSubsets(int[] nums) {\\n        // Map + Math - nums[i] <= 30, calculate gcd for nums[i]\\n        int[] primes = new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n        int[] valids = new int[]{2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30}; // basiceSquareFrees - exclude 1 here since it need special calculate\\n        int oneCnt = 0;\\n        Map<Integer, Set<Integer>> map = new HashMap<>(); // <valid num, gcd of the num>\\n        Map<Integer, Integer> numCnt = new HashMap<>(); // <valid num, count of num>\\n        for (int valid : valids) {\\n            map.put(valid, new HashSet<>());\\n            for (int prime : primes) {\\n                if (prime > valid) break;\\n                if (valid % prime == 0) map.get(valid).add(prime);\\n            }\\n            numCnt.put(valid, 0);\\n        }\\n        for (int num : nums) {\\n            if (num == 1) oneCnt++;\\n            if (!numCnt.containsKey(num)) continue;\\n            numCnt.put(num, numCnt.getOrDefault(num, 0) + 1);\\n        }\\n        for (int valid : valids) {\\n            if (numCnt.get(valid) == 0) numCnt.remove(valid);\\n        }\\n        \\n        long res = 0;\\n        // bfs\\n        Set<SubSet> queue = new LinkedHashSet<>();\\n        for (Map.Entry<Integer, Integer> entry : numCnt.entrySet()) {\\n            int num = entry.getKey(); int cnt = entry.getValue();\\n            Set<Integer> components = new HashSet<>(); components.add(num);\\n            queue.add(new SubSet(components, map.get(num), cnt));\\n        }\\n        for (int i=1; i<=numCnt.size(); i++) { // subset size\\n            int size = queue.size();\\n            while (size-- > 0) {\\n                SubSet lastSubSet = queue.iterator().next(); queue.remove(lastSubSet);\\n                res = (res + lastSubSet.combineCnt) % MOD;\\n                for (Map.Entry<Integer, Integer> entry : numCnt.entrySet()) {\\n                    int num = entry.getKey(); int cnt = entry.getValue();\\n                    if (Collections.disjoint(lastSubSet.primes, map.get(num))) {\\n                        Set<Integer> nextPrimes = new HashSet<>(map.get(num)); nextPrimes.addAll(lastSubSet.primes);\\n                        Set<Integer> nextComponents = new HashSet<>(lastSubSet.components); nextComponents.add(num);\\n                        queue.add(new SubSet(nextComponents, nextPrimes, lastSubSet.combineCnt * cnt % MOD));\\n                    }\\n                }\\n            }\\n        }\\n\\n        // process cases with 1\\n        if (oneCnt > 0) {\\n            // oneCombine = C(n, 0) + C(n, 1) + C(n, 2) + ... + C(n, n) <--> n == oneCnt\\n            // C(n, k) = n! / ((n-k)! * k!)\\n            // res = oneCombine * res + oneCombine - 1 // oneCombine - 1 \\u662F\\u56E0\\u4E3A\\u591A\\u7EDF\\u8BA1\\u4E86\\u4E00\\u4E2A\\u4E0D\\u9009\\u4EFB\\u4F55 1 \\u7684\\u60C5\\u51B5\\n            long tmpRes = res; res = 0;\\n            for (int i=0; i<=oneCnt; i++) {\\n                long tmpCombination = combination(oneCnt, i);\\n                res = ((res + tmpRes * tmpCombination % MOD) % MOD + tmpCombination) % MOD;\\n            }\\n            res -= 1;\\n        }\\n        \\n        return (int) res;\\n    }\\n\\n    long MOD = (long) 1e9 + 7;\\n    long[][] dp = new long[1001][1001];\\n    public long combination(int n, int k) { // Binomial Coefficient - C(n, k)\\n        if (dp[n][k] != 0) return dp[n][k]; // memoization to improve performance\\n        // base cases\\n        if (k > n) return 0;\\n        if (k == 0 || k == n) return 1;\\n        // recursive\\n        long res = (combination(n - 1, k - 1) + combination(n - 1, k)) % MOD;\\n        dp[n][k] = res;\\n        return res;\\n    }\\n\\n    class SubSet {\\n        Set<Integer> components;\\n        Set<Integer> primes;\\n        long combineCnt;\\n\\n        SubSet(Set<Integer> components, Set<Integer> primes, long combineCnt) {\\n            this.components = components;\\n            this.primes = primes;\\n            this.combineCnt = combineCnt;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return components.hashCode();\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (this == o) return true;\\n            if (o == null) return false;\\n            if (this.getClass() != o.getClass()) return false;\\n            SubSet obj = (SubSet) o;\\n            return this.components.equals(obj.components);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205876,
                "title": "c-short-code-recursive-approach",
                "content": "Think it in this way : Whats the most naivest way to solve the problem ? \\nTo iterate over all subsets , right ? \\nBut we need to iterate only on those sets where the product is sqaure free integer. \\nThe search space here gets confined to the number of primes lesser than 30. \\nSo at each index we can have a combination 2^30 different states and that is where memoisation works out.\\n\\nThe problem looks so simple when we look at it in this way. \\nIts just another bloody recursive problem. I mean just look at the code itslef. \\nBut coming up with this was a tough time :).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        vector<int>v(30,0);\\n        int index = 0 ;\\n        for(auto it : vector<int>{1,2,3,5,7,11,13,17,19,23,29}){\\n            v[it] = index , index += 1 ;\\n        }\\n    \\n        vector<vector<long long int>>dp((1<<11),vector<long long>(nums.size(),-1ll));\\n        int mask = 0 ;\\n        const int M = 1e9 + 7 ;\\n        function<long long int(int)>recur = [&](int i){\\n            if(i == nums.size()) return 1ll ;\\n            if(dp[mask][i] != -1) return dp[mask][i];\\n            int cur = 0 ;\\n            int repeat = 0, x = nums[i] ;\\n            for(int i = 2 ; i <= x ; i++){\\n                if(x%i == 0){\\n                    x /= i ; \\n                    if(x%i == 0){ repeat = 1 ; break ;}\\n                    if((mask & (1<<v[i])) != 0) repeat = 1 ;\\n                    cur |= (1<<v[i]);\\n                }\\n            }\\n            long long int ans = recur(i+1) ;\\n            if(!repeat){\\n                mask |= cur ; ; \\n                ans = (ans % M + recur(i+1) % M) % M; \\n                mask ^= cur ;\\n            }\\n            return dp[mask][i] = ans ;    \\n\\n        };\\n\\n        return recur(0)-1 ;\\n\\n\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        vector<int>v(30,0);\\n        int index = 0 ;\\n        for(auto it : vector<int>{1,2,3,5,7,11,13,17,19,23,29}){\\n            v[it] = index , index += 1 ;\\n        }\\n    \\n        vector<vector<long long int>>dp((1<<11),vector<long long>(nums.size(),-1ll));\\n        int mask = 0 ;\\n        const int M = 1e9 + 7 ;\\n        function<long long int(int)>recur = [&](int i){\\n            if(i == nums.size()) return 1ll ;\\n            if(dp[mask][i] != -1) return dp[mask][i];\\n            int cur = 0 ;\\n            int repeat = 0, x = nums[i] ;\\n            for(int i = 2 ; i <= x ; i++){\\n                if(x%i == 0){\\n                    x /= i ; \\n                    if(x%i == 0){ repeat = 1 ; break ;}\\n                    if((mask & (1<<v[i])) != 0) repeat = 1 ;\\n                    cur |= (1<<v[i]);\\n                }\\n            }\\n            long long int ans = recur(i+1) ;\\n            if(!repeat){\\n                mask |= cur ; ; \\n                ans = (ans % M + recur(i+1) % M) % M; \\n                mask ^= cur ;\\n            }\\n            return dp[mask][i] = ans ;    \\n\\n        };\\n\\n        return recur(0)-1 ;\\n\\n\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205494,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def squareFreeSubsets(self, nums):\\n        n = len(nums)\\n\\n        primes = [2,3,5,7,11,13,17,19,23,29]\\n\\n        dp = [0]*(1<<10)\\n\\n        dp[0] = 1\\n\\n        for num in nums:\\n            mask = 0\\n            for i,p in enumerate(primes):\\n                if num%(p*p) == 0:\\n                    mask = -1\\n                    break\\n                if num%p == 0:\\n                    mask = mask|(1<<i)\\n\\n            if mask >= 0:\\n                for i in range(1<<10):\\n                    if i&mask == 0:\\n                        dp[i|mask] += dp[i]\\n\\n        return (sum(dp)-1)%(10**9+7)\\n\\n\\n\\n                \\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def squareFreeSubsets(self, nums):\\n        n = len(nums)\\n\\n        primes = [2,3,5,7,11,13,17,19,23,29]\\n\\n        dp = [0]*(1<<10)\\n\\n        dp[0] = 1\\n\\n        for num in nums:\\n            mask = 0\\n            for i,p in enumerate(primes):\\n                if num%(p*p) == 0:\\n                    mask = -1\\n                    break\\n                if num%p == 0:\\n                    mask = mask|(1<<i)\\n\\n            if mask >= 0:\\n                for i in range(1<<10):\\n                    if i&mask == 0:\\n                        dp[i|mask] += dp[i]\\n\\n        return (sum(dp)-1)%(10**9+7)\\n\\n\\n\\n                \\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205438,
                "title": "c-simple",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> primes = {2,3,5,7,11,13,17,19,23,29};\\n    int mod = 1e9+7;\\n    \\n    \\n    \\n    int f(vector<int>& a, int i, int state, vector<vector<int>> &dp){\\n        \\n        if(i==a.size()){\\n             return dp[i][state]=1;\\n        }\\n        \\n        if(dp[i][state]!=-1) return dp[i][state];\\n        \\n        int tempState = 0, j=0, temp=a[i], dontTake = 0;\\n        \\n        while(j<10 && temp>1){\\n            \\n            if(temp%primes[j]==0){\\n                int num = tempState&(1<<j);\\n                if(num){\\n                     dontTake = 1;\\n                     break;\\n                }\\n                temp=temp/primes[j];\\n                tempState = tempState | (1<<j);\\n            }\\n            else j++;\\n            \\n        }\\n        \\n        if(tempState&state){         \\n             dontTake = 1;\\n        }\\n        \\n        int newState = state|tempState;\\n      \\n        if(!dontTake) return dp[i][state]=(f(a,i+1,newState,dp) + f(a,i+1,state,dp))%mod;\\n        else return dp[i][state]=f(a,i+1,state,dp);\\n        \\n    }\\n    \\n    int squareFreeSubsets(vector<int>& a) {\\n        \\n        vector<vector<int>> dp(a.size()+1, vector<int>(1025,-1));\\n    \\n        return f(a,0,0,dp)-1;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> primes = {2,3,5,7,11,13,17,19,23,29};\\n    int mod = 1e9+7;\\n    \\n    \\n    \\n    int f(vector<int>& a, int i, int state, vector<vector<int>> &dp){\\n        \\n        if(i==a.size()){\\n             return dp[i][state]=1;\\n        }\\n        \\n        if(dp[i][state]!=-1) return dp[i][state];\\n        \\n        int tempState = 0, j=0, temp=a[i], dontTake = 0;\\n        \\n        while(j<10 && temp>1){\\n            \\n            if(temp%primes[j]==0){\\n                int num = tempState&(1<<j);\\n                if(num){\\n                     dontTake = 1;\\n                     break;\\n                }\\n                temp=temp/primes[j];\\n                tempState = tempState | (1<<j);\\n            }\\n            else j++;\\n            \\n        }\\n        \\n        if(tempState&state){         \\n             dontTake = 1;\\n        }\\n        \\n        int newState = state|tempState;\\n      \\n        if(!dontTake) return dp[i][state]=(f(a,i+1,newState,dp) + f(a,i+1,state,dp))%mod;\\n        else return dp[i][state]=f(a,i+1,state,dp);\\n        \\n    }\\n    \\n    int squareFreeSubsets(vector<int>& a) {\\n        \\n        vector<vector<int>> dp(a.size()+1, vector<int>(1025,-1));\\n    \\n        return f(a,0,0,dp)-1;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205371,
                "title": "runtime-beats-100-bitmask-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<long long> count;\\n    vector<int> factor;\\n    vector<long long> factorial;\\n    vector<long long> factorial_mi;//module inverse\\n    long long ans;\\n    long long mod;\\n    void dfs(vector<long long>& count, int i, int num, long long product)\\n    {\\n        if(i == count.size())\\n        {\\n            ans += product;\\n            ans %= mod;\\n            return;\\n        }\\n        dfs(count, i + 1, num, product);\\n        if(count[i] != 0 && (num & factor[i]) == 0)\\n        {\\n            if(product == 0)\\n            {\\n                dfs(count, i + 1, num | factor[i], count[i]);\\n            }\\n            else\\n            {\\n                dfs(count, i + 1, num | factor[i], (product * count[i]) % mod);\\n            }\\n        }\\n    }\\n    int cnr(int n, int r)\\n    {\\n        return ((factorial[n] * factorial_mi[r]) % mod * factorial_mi[n - r]) % mod;\\n    }\\n    long long fastPower(long long n, long long p)\\n    {\\n        long long ans = 1;\\n        while(p > 0)\\n        {\\n            if(p & 1)\\n            {\\n                ans = (ans * n) % mod;\\n            }\\n            n = (n * n) % mod;\\n            p >>= 1;\\n        }\\n        return ans;\\n    }\\n    int squareFreeSubsets(vector<int>& nums) \\n    {\\n        count.resize(31);\\n        factor.resize(31);\\n        factorial.resize(1001);\\n        factorial_mi.resize(1001);\\n        mod = 1e9 + 7;\\n        ans = 0;\\n        for(auto it : nums)\\n        {\\n            count[it]++;\\n        }\\n        for(int i = 1; i <= 30; i++)\\n        {\\n            for(int j = 2; j <= i; j++)\\n            {\\n                if(i % j == 0)\\n                {\\n                    factor[i] |= (1 << j);\\n                }\\n            }\\n        }\\n        //set the square number and square number\\'s multiple to 0\\n        for(int i = 2; i * i <= 30; i++)\\n        {\\n            for(int j = 1; j * i * i <= 30; j++)\\n            {\\n                count[j * i * i] = 0;\\n            }\\n        }\\n        //only one can be choose repeat, so the count[1] will be C(count[1], 1) + C(count[1], 2) + ... + C(count[1], count[1])\\n        factorial[0] = 1;\\n        factorial[1] = 1;\\n        factorial_mi[0] = 1;\\n        factorial_mi[1] = 1;\\n        for(int i = 2; i <= count[1]; i++)\\n        {\\n            factorial[i] = (factorial[i - 1] * i) % mod;\\n            factorial_mi[i] = fastPower(factorial[i], mod - 2);\\n        }\\n        long long buffer = 0;\\n        for(int i = 1; i <= count[1]; i++)\\n        {\\n            buffer += cnr(count[1], i);\\n            buffer %= mod;\\n        }\\n        count[1] = count[1] == 0 ? 0 : buffer;\\n        dfs(count, 1, 0, 0LL);\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<long long> count;\\n    vector<int> factor;\\n    vector<long long> factorial;\\n    vector<long long> factorial_mi;//module inverse\\n    long long ans;\\n    long long mod;\\n    void dfs(vector<long long>& count, int i, int num, long long product)\\n    {\\n        if(i == count.size())\\n        {\\n            ans += product;\\n            ans %= mod;\\n            return;\\n        }\\n        dfs(count, i + 1, num, product);\\n        if(count[i] != 0 && (num & factor[i]) == 0)\\n        {\\n            if(product == 0)\\n            {\\n                dfs(count, i + 1, num | factor[i], count[i]);\\n            }\\n            else\\n            {\\n                dfs(count, i + 1, num | factor[i], (product * count[i]) % mod);\\n            }\\n        }\\n    }\\n    int cnr(int n, int r)\\n    {\\n        return ((factorial[n] * factorial_mi[r]) % mod * factorial_mi[n - r]) % mod;\\n    }\\n    long long fastPower(long long n, long long p)\\n    {\\n        long long ans = 1;\\n        while(p > 0)\\n        {\\n            if(p & 1)\\n            {\\n                ans = (ans * n) % mod;\\n            }\\n            n = (n * n) % mod;\\n            p >>= 1;\\n        }\\n        return ans;\\n    }\\n    int squareFreeSubsets(vector<int>& nums) \\n    {\\n        count.resize(31);\\n        factor.resize(31);\\n        factorial.resize(1001);\\n        factorial_mi.resize(1001);\\n        mod = 1e9 + 7;\\n        ans = 0;\\n        for(auto it : nums)\\n        {\\n            count[it]++;\\n        }\\n        for(int i = 1; i <= 30; i++)\\n        {\\n            for(int j = 2; j <= i; j++)\\n            {\\n                if(i % j == 0)\\n                {\\n                    factor[i] |= (1 << j);\\n                }\\n            }\\n        }\\n        //set the square number and square number\\'s multiple to 0\\n        for(int i = 2; i * i <= 30; i++)\\n        {\\n            for(int j = 1; j * i * i <= 30; j++)\\n            {\\n                count[j * i * i] = 0;\\n            }\\n        }\\n        //only one can be choose repeat, so the count[1] will be C(count[1], 1) + C(count[1], 2) + ... + C(count[1], count[1])\\n        factorial[0] = 1;\\n        factorial[1] = 1;\\n        factorial_mi[0] = 1;\\n        factorial_mi[1] = 1;\\n        for(int i = 2; i <= count[1]; i++)\\n        {\\n            factorial[i] = (factorial[i - 1] * i) % mod;\\n            factorial_mi[i] = fastPower(factorial[i], mod - 2);\\n        }\\n        long long buffer = 0;\\n        for(int i = 1; i <= count[1]; i++)\\n        {\\n            buffer += cnr(count[1], i);\\n            buffer %= mod;\\n        }\\n        count[1] = count[1] == 0 ? 0 : buffer;\\n        dfs(count, 1, 0, 0LL);\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205220,
                "title": "c-o-n-1024-with-detailed-explanation",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        int res = 0;\\n        int mod = 1e9 + 7;\\n        int n = nums.size();\\n        // because 1 <= nums[i] <= 30\\n        vector<int> primes{2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n        \\n        // used[i] uses bitmask to record the prime factors nums[i] has, \\n        // e.g. 1000000100 means the number\\' factors are 5 and 29 only\\n        vector<int> used(n, 0);\\n\\n        // dp[i] represents the number of square-free subsets \\n        // whose product\\'s factors are expressed by bitmask\\n        vector<int> dp(1 << 10, 0);\\n\\n \\n        for(int i = 0; i < n; i ++) {\\n\\n            // 1 is a special case\\n            // because 1 * any valid subset product doesn\\'t change the validity of that subest\\n            if(nums[i] == 1) {\\n                for(int j = 0; j < (1 << 10); j ++) {\\n \\n                    // *2 represents choose the 1 or not\\n                    dp[j] = (2 * dp[j]) % mod;\\n                }\\n\\n                // add the subset consisting only of the current 1\\n                dp[0] = (1 + dp[0]) % mod;\\n                continue;\\n            }\\n\\n            // check whether nums[i] is square-free or not\\n            for(int j = 0; j < 10; j ++) {\\n                if(nums[i] % primes[j]) continue;\\n                if(nums[i] % (primes[j] * primes[j]) == 0) {\\n                    used[i] = 0;\\n                    break;\\n                }\\n\\n                // record primes[j] is nums[i]\\'s factor \\n                used[i] |= (1 << j);\\n            }\\n\\n            // used[i] == 0 means that nums[i] is not square-free\\n            if(!used[i]) continue;\\n\\n            // iterate all possible states\\n            // the state here means the bitmask of a valid subset\\n            for(int j = (1 << 10) - 1; j >= used[i]; j --) {\\n\\n                // state j cannot be acheived by used[i]\\n                if(used[i] & (used[i] ^ j)) continue;\\n\\n                // nums[i] with any subset of dp[used[i] ^ j]\\n                // their product\\'s factors\\' bitmask == state j\\n                // so we add them up\\n                dp[j] = (dp[j] + dp[used[i] ^ j]) % mod; \\n            }\\n\\n            // add the subset consisting only of nums[i]\\n            dp[used[i]] = (1 + dp[used[i]]) % mod;\\n        }\\n\\n        // summing up all the number of square-free subsets\\n        for(int i = 0; i < 1 << 10; i ++) {\\n            res = (res + dp[i]) % mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        int res = 0;\\n        int mod = 1e9 + 7;\\n        int n = nums.size();\\n        // because 1 <= nums[i] <= 30\\n        vector<int> primes{2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n        \\n        // used[i] uses bitmask to record the prime factors nums[i] has, \\n        // e.g. 1000000100 means the number\\' factors are 5 and 29 only\\n        vector<int> used(n, 0);\\n\\n        // dp[i] represents the number of square-free subsets \\n        // whose product\\'s factors are expressed by bitmask\\n        vector<int> dp(1 << 10, 0);\\n\\n \\n        for(int i = 0; i < n; i ++) {\\n\\n            // 1 is a special case\\n            // because 1 * any valid subset product doesn\\'t change the validity of that subest\\n            if(nums[i] == 1) {\\n                for(int j = 0; j < (1 << 10); j ++) {\\n \\n                    // *2 represents choose the 1 or not\\n                    dp[j] = (2 * dp[j]) % mod;\\n                }\\n\\n                // add the subset consisting only of the current 1\\n                dp[0] = (1 + dp[0]) % mod;\\n                continue;\\n            }\\n\\n            // check whether nums[i] is square-free or not\\n            for(int j = 0; j < 10; j ++) {\\n                if(nums[i] % primes[j]) continue;\\n                if(nums[i] % (primes[j] * primes[j]) == 0) {\\n                    used[i] = 0;\\n                    break;\\n                }\\n\\n                // record primes[j] is nums[i]\\'s factor \\n                used[i] |= (1 << j);\\n            }\\n\\n            // used[i] == 0 means that nums[i] is not square-free\\n            if(!used[i]) continue;\\n\\n            // iterate all possible states\\n            // the state here means the bitmask of a valid subset\\n            for(int j = (1 << 10) - 1; j >= used[i]; j --) {\\n\\n                // state j cannot be acheived by used[i]\\n                if(used[i] & (used[i] ^ j)) continue;\\n\\n                // nums[i] with any subset of dp[used[i] ^ j]\\n                // their product\\'s factors\\' bitmask == state j\\n                // so we add them up\\n                dp[j] = (dp[j] + dp[used[i] ^ j]) % mod; \\n            }\\n\\n            // add the subset consisting only of nums[i]\\n            dp[used[i]] = (1 + dp[used[i]]) % mod;\\n        }\\n\\n        // summing up all the number of square-free subsets\\n        for(int i = 0; i < 1 << 10; i ++) {\\n            res = (res + dp[i]) % mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205215,
                "title": "rust-dfs-dp-with-bit-mask",
                "content": "Rust adaptation of [this great solution](https://leetcode.com/problems/count-the-number-of-square-free-subsets/solutions/3203758/mask-of-factors/).\\n\\n$$DP[n][mask]$$ here is the number of square-free subsets for the $$nums$$ array suffix of length $$n$$ where product of numbers selected from the corresponding prefix $$nums[0..n-1]$$ contains a prime factors defined by the $$mask$$. These factors are blocked and must not be selected in further search.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn square_free_subsets(nums: Vec<i32>) -> i32 {\\n        const MOD: i32 = 1_000_000_007;\\n        const num_masks: [Option<usize>; 31] = [\\n            // 0        1        2        3     4        5        6        7     8     9       10\\n            None, Some(0), Some(1), Some(2), None, Some(4), Some(3), Some(8), None, None, Some(5),\\n            //    11    12        13       14       15    16        17    18         19    20\\n            Some(16), None, Some(32), Some(9), Some(6), None, Some(64), None, Some(128), None,\\n            //    21        22         23    24    25        26    27    28         29       30\\n            Some(10), Some(17), Some(256), None, None, Some(33), None, None, Some(512), Some(7)\\n        ];\\n        fn dfs(nums: &[i32], dp: &mut Vec<Vec<Option<i32>>>, mask: usize) -> i32 {\\n            let n = nums.len();\\n            if let Some(count) = dp[n][mask] {\\n                return count;\\n            }\\n            let mut count = dfs(&nums[1..], dp, mask);\\n            if let Some(num_mask) = num_masks[nums[0] as usize] {\\n                if (mask & num_mask) == 0 {\\n                    count = (count + 1 + dfs(&nums[1..], dp, mask | num_mask)) % MOD;\\n                }\\n            }\\n            dp[n][mask] = Some(count);\\n            count\\n        }\\n        let mut dp = vec![vec![None; 1024]; nums.len() + 1];\\n        for count in &mut dp[0] {\\n            *count = Some(0);\\n        }\\n        dfs(&nums[..], &mut dp, 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn square_free_subsets(nums: Vec<i32>) -> i32 {\\n        const MOD: i32 = 1_000_000_007;\\n        const num_masks: [Option<usize>; 31] = [\\n            // 0        1        2        3     4        5        6        7     8     9       10\\n            None, Some(0), Some(1), Some(2), None, Some(4), Some(3), Some(8), None, None, Some(5),\\n            //    11    12        13       14       15    16        17    18         19    20\\n            Some(16), None, Some(32), Some(9), Some(6), None, Some(64), None, Some(128), None,\\n            //    21        22         23    24    25        26    27    28         29       30\\n            Some(10), Some(17), Some(256), None, None, Some(33), None, None, Some(512), Some(7)\\n        ];\\n        fn dfs(nums: &[i32], dp: &mut Vec<Vec<Option<i32>>>, mask: usize) -> i32 {\\n            let n = nums.len();\\n            if let Some(count) = dp[n][mask] {\\n                return count;\\n            }\\n            let mut count = dfs(&nums[1..], dp, mask);\\n            if let Some(num_mask) = num_masks[nums[0] as usize] {\\n                if (mask & num_mask) == 0 {\\n                    count = (count + 1 + dfs(&nums[1..], dp, mask | num_mask)) % MOD;\\n                }\\n            }\\n            dp[n][mask] = Some(count);\\n            count\\n        }\\n        let mut dp = vec![vec![None; 1024]; nums.len() + 1];\\n        for count in &mut dp[0] {\\n            *count = Some(0);\\n        }\\n        dfs(&nums[..], &mut dp, 0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3205207,
                "title": "dfs",
                "content": "```cpp\\nclass Solution {\\n    long long dfs(int i, int prod, vector<int>& factor, vector<vector<long long>>& dp)\\n    {\\n        if (i == factor.size())\\n            return 1;\\n\\n        if (dp[i][prod] != -1)\\n            return dp[i][prod];\\n\\n        // case 1: don\\'t include this element.\\n        auto ret = dfs(i + 1, prod, factor, dp);\\n\\n        // case 2: we can include this element \\n        //         only if there are no common factors\\n        //         between this element and the product of previous select elements.\\n        //         we set the initial value of `prod\\' to 1, \\n        //         in order to avoid include `-1\\'.\\n        if ((prod & factor[i]) == 0)\\n            ret += dfs(i + 1, prod | factor[i], factor, dp);\\n\\n        int m = 1e9 + 7;\\n        return dp[i][prod] = ret % m;\\n    }\\n\\n    vector<int> fac(vector<int>& nums)\\n    {\\n        vector<int> prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n        vector<int> factor;\\n\\n        for (auto x : nums)\\n        {\\n            int f = 0;\\n\\n            for (int i = 0; i < prime.size() && f != -1; ++i)\\n            {\\n                int q = 0;\\n\\n                while (x % prime[i] == 0 && q < 2)\\n                {\\n                    ++ q;\\n                    x /= prime[i];\\n                }\\n\\n                // if `x\\' can be divided by any prime more than once,\\n                // it itself is an invalid square-free integer,\\n                // it should never be included into our square-free subset.\\n                // we set it to `-1\\' to set all its bits to 1. \\n                if (q == 2)\\n                    f = -1;\\n                // the least significant bit is preserved for other meaning.\\n                // i.e. the initial value of `prod\\'\\n                else if (q == 1)\\n                    f |= 1 << (i + 1);\\n            }\\n\\n            factor.push_back(f);\\n        }\\n\\n        return factor;\\n    }\\n\\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(1 << 11, -1));\\n        vector<int> factor = fac(nums);\\n        \\n        // we set the initial value of `prod\\' to 1, \\n        // in order to avoid taking `-1\\'.\\n        return dfs(0, 1, factor, dp) - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```cpp\\nclass Solution {\\n    long long dfs(int i, int prod, vector<int>& factor, vector<vector<long long>>& dp)\\n    {\\n        if (i == factor.size())\\n            return 1;\\n\\n        if (dp[i][prod] != -1)\\n            return dp[i][prod];\\n\\n        // case 1: don\\'t include this element.\\n        auto ret = dfs(i + 1, prod, factor, dp);\\n\\n        // case 2: we can include this element \\n        //         only if there are no common factors\\n        //         between this element and the product of previous select elements.\\n        //         we set the initial value of `prod\\' to 1, \\n        //         in order to avoid include `-1\\'.\\n        if ((prod & factor[i]) == 0)\\n            ret += dfs(i + 1, prod | factor[i], factor, dp);\\n\\n        int m = 1e9 + 7;\\n        return dp[i][prod] = ret % m;\\n    }\\n\\n    vector<int> fac(vector<int>& nums)\\n    {\\n        vector<int> prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n        vector<int> factor;\\n\\n        for (auto x : nums)\\n        {\\n            int f = 0;\\n\\n            for (int i = 0; i < prime.size() && f != -1; ++i)\\n            {\\n                int q = 0;\\n\\n                while (x % prime[i] == 0 && q < 2)\\n                {\\n                    ++ q;\\n                    x /= prime[i];\\n                }\\n\\n                // if `x\\' can be divided by any prime more than once,\\n                // it itself is an invalid square-free integer,\\n                // it should never be included into our square-free subset.\\n                // we set it to `-1\\' to set all its bits to 1. \\n                if (q == 2)\\n                    f = -1;\\n                // the least significant bit is preserved for other meaning.\\n                // i.e. the initial value of `prod\\'\\n                else if (q == 1)\\n                    f |= 1 << (i + 1);\\n            }\\n\\n            factor.push_back(f);\\n        }\\n\\n        return factor;\\n    }\\n\\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(1 << 11, -1));\\n        vector<int> factor = fac(nums);\\n        \\n        // we set the initial value of `prod\\' to 1, \\n        // in order to avoid taking `-1\\'.\\n        return dfs(0, 1, factor, dp) - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204726,
                "title": "easy-to-understand-cpp-hash",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int M = 1e9+7;\\n    long long int ans=0;\\n    \\n    int bin_expo(int a,int b) {\\n        long long int ans = 1;\\n        while(b) {\\n            if(b&1) {\\n                ans = (ans*1LL*a)%M;\\n            }\\n            a = (a*1LL*a)%M;\\n            b >>= 1;\\n        }\\n        return ans;\\n    }\\n    \\n    void solve(vector<int> &val,int i,unordered_map<int,int> &freq,unordered_map<int,unordered_map<int,int>> &factor,unordered_set<int> &st,long long int res,int pick) {\\n        if(i>=val.size()) {\\n            if(!pick) return ;\\n            ans = (res+ans)%M;\\n            return ;\\n        }\\n        for(auto j:st) {\\n            if(factor[val[i]].find(j)!=factor[val[i]].end() && factor[val[i]][j]>0) {\\n                solve(val,i+1,freq,factor,st,res,pick);\\n                return ;\\n            }\\n        }\\n        long long int ans=0;\\n        for(auto j:factor[val[i]]) {\\n            if(j.second>1) {\\n                solve(val,i+1,freq,factor,st,res,pick);\\n                return ;\\n            }\\n        }\\n        for(auto j:factor[val[i]]) {\\n            st.insert(j.first);\\n        }\\n        if(val[i]!=1)\\n            solve(val,i+1,freq,factor,st,((res%M)*freq[val[i]]%M)%M,1);\\n        else\\n            solve(val,i+1,freq,factor,st,res*(bin_expo(2,freq[val[i]])-1),1);\\n        for(auto j:factor[val[i]]) {\\n            st.erase(j.first);\\n        }\\n        solve(val,i+1,freq,factor,st,res,pick);\\n    }\\n    \\n    int squareFreeSubsets(vector<int>& nums) {\\n        unordered_map<int,int> freq;\\n        unordered_map<int,unordered_map<int,int>> factor;\\n        vector<int> temp;\\n        for(auto i:nums) freq[i]+=1;\\n        for(auto i:freq) {\\n            int k = i.first;\\n            bool add=true;\\n            int j=2;\\n            while(k!=1) {\\n                if(k%j==0) {\\n                    k/=j;\\n                    factor[i.first][j]+=1;\\n                    if(factor[i.first][j]>1) add=false;\\n                }\\n                else j+=1;\\n            }\\n            if(add) temp.push_back(i.first);\\n        }\\n        unordered_set<int> st;\\n        solve(temp,0,freq,factor,st,1,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int M = 1e9+7;\\n    long long int ans=0;\\n    \\n    int bin_expo(int a,int b) {\\n        long long int ans = 1;\\n        while(b) {\\n            if(b&1) {\\n                ans = (ans*1LL*a)%M;\\n            }\\n            a = (a*1LL*a)%M;\\n            b >>= 1;\\n        }\\n        return ans;\\n    }\\n    \\n    void solve(vector<int> &val,int i,unordered_map<int,int> &freq,unordered_map<int,unordered_map<int,int>> &factor,unordered_set<int> &st,long long int res,int pick) {\\n        if(i>=val.size()) {\\n            if(!pick) return ;\\n            ans = (res+ans)%M;\\n            return ;\\n        }\\n        for(auto j:st) {\\n            if(factor[val[i]].find(j)!=factor[val[i]].end() && factor[val[i]][j]>0) {\\n                solve(val,i+1,freq,factor,st,res,pick);\\n                return ;\\n            }\\n        }\\n        long long int ans=0;\\n        for(auto j:factor[val[i]]) {\\n            if(j.second>1) {\\n                solve(val,i+1,freq,factor,st,res,pick);\\n                return ;\\n            }\\n        }\\n        for(auto j:factor[val[i]]) {\\n            st.insert(j.first);\\n        }\\n        if(val[i]!=1)\\n            solve(val,i+1,freq,factor,st,((res%M)*freq[val[i]]%M)%M,1);\\n        else\\n            solve(val,i+1,freq,factor,st,res*(bin_expo(2,freq[val[i]])-1),1);\\n        for(auto j:factor[val[i]]) {\\n            st.erase(j.first);\\n        }\\n        solve(val,i+1,freq,factor,st,res,pick);\\n    }\\n    \\n    int squareFreeSubsets(vector<int>& nums) {\\n        unordered_map<int,int> freq;\\n        unordered_map<int,unordered_map<int,int>> factor;\\n        vector<int> temp;\\n        for(auto i:nums) freq[i]+=1;\\n        for(auto i:freq) {\\n            int k = i.first;\\n            bool add=true;\\n            int j=2;\\n            while(k!=1) {\\n                if(k%j==0) {\\n                    k/=j;\\n                    factor[i.first][j]+=1;\\n                    if(factor[i.first][j]>1) add=false;\\n                }\\n                else j+=1;\\n            }\\n            if(add) temp.push_back(i.first);\\n        }\\n        unordered_set<int> st;\\n        solve(temp,0,freq,factor,st,1,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204694,
                "title": "prime-factorization-frozenset-counter",
                "content": "# Intuition\\nA number is divisible by a square number > 1 iff the power for any of the primes is > 1 in its prime factorization.\\n\\n# Approach\\n1. Use a `Counter()` with `frozenset()` as keys to represent the prime factorization of the product of allowed subsets and their counts.\\n2. Initialize it with `c[frozenset()] = 1`: We can subtract it out at the end.\\n3. As we go through the elements in `nums`, compute their prime factorization. If the power for any of the primes is > 1, skip.\\n4. Otherwise, check each key in the counter. The ones that don\\'t share any prime factors with the current element result in new allowed subsets to add to the counter.\\n5. After going through all the elements in `nums`, return modulo of `total()` of the counter minus 1 as promised in 2.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n \\\\cdot 2 ^{10})$$, since there are 10 prime numbers < 30.\\n`frozenset()` tends to be slower than bitmask but it\\'s fast enough here.\\n\\n- Space complexity:\\n$$O(2 ^{10})$$\\n\\n# Code\\n```\\nprimes = [2, 3, 5]\\n\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        c = Counter()\\n        c[frozenset()] = 1\\n        for x in nums:\\n            factor = []\\n            for p in primes:\\n                if not x % p:\\n                    factor.append(p)\\n                    x //= p\\n                if not x % p:\\n                    break\\n            else:\\n                if x > 1:\\n                    factor.append(x)\\n                s = frozenset(factor)\\n                new = Counter({(k | s): v for k, v in c.items() if not k & s})\\n                c += new\\n        return (c.total() - 1) % (10 ** 9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nprimes = [2, 3, 5]\\n\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        c = Counter()\\n        c[frozenset()] = 1\\n        for x in nums:\\n            factor = []\\n            for p in primes:\\n                if not x % p:\\n                    factor.append(p)\\n                    x //= p\\n                if not x % p:\\n                    break\\n            else:\\n                if x > 1:\\n                    factor.append(x)\\n                s = frozenset(factor)\\n                new = Counter({(k | s): v for k, v in c.items() if not k & s})\\n                c += new\\n        return (c.total() - 1) % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204558,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn square_free_subsets(nums: Vec<i32>) -> i32 {\\n        fn dp(nums: &Vec<i64>, i: usize, mask: i64, memo: &mut Vec<Vec<i64>>) -> i64 {\\n            let mod_num = 1e9 as i64 + 7;\\n            let vec = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29];\\n            if i == nums.len() {\\n                return 1;\\n            }\\n            if memo[i][mask as usize] != -1 {\\n                return memo[i][mask as usize];\\n            }\\n            let mut temp = mask;\\n            let mut flag = 1;\\n            for (j, &item_j) in vec.iter().enumerate().take(10) {\\n                let mut num = nums[i];\\n                let mut count = 0;\\n                while num % item_j == 0 {\\n                    num /= item_j;\\n                    count += 1;\\n                }\\n                if count >= 2 || ((count == 1) && ((mask >> j) & 1) == 1) {\\n                    flag = 0;\\n                    break;\\n                }\\n                if count > 0 {\\n                    temp |= 1 << j;\\n                }\\n            }\\n            if flag == 1 {\\n                memo[i][mask as usize] = (dp(nums, i + 1, mask, memo) + dp(nums, i + 1, temp, memo)) % mod_num;\\n            } else {\\n                memo[i][mask as usize] = dp(nums, i + 1, mask, memo);\\n            }\\n            memo[i][mask as usize]\\n        }\\n\\n        let nums = nums.iter().map(|&x| x as i64).collect();\\n        let mut memo = vec![vec![-1; 1024]; 1001];\\n        (dp(&nums, 0, 0, &mut memo) - 1) as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn square_free_subsets(nums: Vec<i32>) -> i32 {\\n        fn dp(nums: &Vec<i64>, i: usize, mask: i64, memo: &mut Vec<Vec<i64>>) -> i64 {\\n            let mod_num = 1e9 as i64 + 7;\\n            let vec = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29];\\n            if i == nums.len() {\\n                return 1;\\n            }\\n            if memo[i][mask as usize] != -1 {\\n                return memo[i][mask as usize];\\n            }\\n            let mut temp = mask;\\n            let mut flag = 1;\\n            for (j, &item_j) in vec.iter().enumerate().take(10) {\\n                let mut num = nums[i];\\n                let mut count = 0;\\n                while num % item_j == 0 {\\n                    num /= item_j;\\n                    count += 1;\\n                }\\n                if count >= 2 || ((count == 1) && ((mask >> j) & 1) == 1) {\\n                    flag = 0;\\n                    break;\\n                }\\n                if count > 0 {\\n                    temp |= 1 << j;\\n                }\\n            }\\n            if flag == 1 {\\n                memo[i][mask as usize] = (dp(nums, i + 1, mask, memo) + dp(nums, i + 1, temp, memo)) % mod_num;\\n            } else {\\n                memo[i][mask as usize] = dp(nums, i + 1, mask, memo);\\n            }\\n            memo[i][mask as usize]\\n        }\\n\\n        let nums = nums.iter().map(|&x| x as i64).collect();\\n        let mut memo = vec![vec![-1; 1024]; 1001];\\n        (dp(&nums, 0, 0, &mut memo) - 1) as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3204549,
                "title": "dp-both-100-o-n-o-128-0-ms-8-mb-not-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nValues \\u200B\\u200Bwith square factors have no effect on the answer.\\n1 is a special case.\\nSince **max(nums[i]) <= 30** & **the order of the numbers doesn\\'t affect the answer**, using the trick of counting sort can drastically reduce the time and space.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet DP[i][...] indicate how many groups of factors are used before the i number (because the factors cannot be repeated, they need to be recorded separately).\\n\\nIt can be found that it is only necessary to record the times of factors in the six groups of 2, 3, 5, 7, 11, and 13.\\n\\nThe answer is multiplied by 2 for each occurrence of 1.\\n\\nNote that answers do not contain empty set.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSince 30*(2^6) = 1920, which is approximately equal to n.\\n(In fact, if you omit the number that will not be affected, you only need DP (30-12)*(2^6) times.)\\n\\nAlso, counting is O(n).\\n\\n- Space complexity: O(30*64)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIf you use the technique of State Compression, it can become O(2*64).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        //2 3 5 7 11 13\\n        long long ans=0,mod=1e9+7,dp[2][2][2][2][2][2][2],ct[31]={};\\n        for(int i=0;i<nums.size();++i)++ct[nums[i]];\\n        ct[4]=ct[8]=ct[9]=ct[12]=ct[16]=ct[18]=ct[20]=ct[24]=ct[25]=ct[27]=ct[28]=0;\\n        memset(dp,0,sizeof(dp));\\n        dp[0][0][0][0][0][0][0]=1;\\n        for(int ii=2,la=1;ii<=31;++ii){\\n            if(ii==31){\\n                for(int i=0;i<2;++i)\\n                    for(int j=0;j<2;++j)\\n                        for(int k=0;k<2;++k)\\n                            for(int l=0;l<2;++l)\\n                                for(int m=0;m<2;++m)\\n                                    for(int n=0;n<2;++n)\\n                                        ans+=dp[la^1][i][j][k][l][m][n],ans%=mod;\\n                break;\\n            }\\n            if(ct[ii]){\\n                for(int i=0;i<2;++i)\\n                    for(int j=0;j<2;++j)\\n                        for(int k=0;k<2;++k)\\n                            for(int l=0;l<2;++l)\\n                                for(int m=0;m<2;++m)\\n                                    for(int n=0;n<2;++n)\\n                                        dp[la][i][j][k][l][m][n]=dp[la^1][i][j][k][l][m][n];\\n                bool x=!(ii%2),y=!(ii%3),z=!(ii%5),s=!(ii%7),a=!(ii%11),b=!(ii%13);\\n                for(int i=0;i<2-x;++i)\\n                    for(int j=0;j<2-y;++j)\\n                        for(int k=0;k<2-z;++k)\\n                            for(int l=0;l<2-s;++l)\\n                                for(int m=0;m<2-a;++m)\\n                                    for(int n=0;n<2-b;++n)\\n                                        dp[la][i+x][j+y][k+z][l+s][m+a][n+b]+=(ct[ii]*dp[la^1][i][j][k][l][m][n])%mod;\\n                la^=1;\\n            }\\n        }\\n        for(int i=0;i<ct[1];++i){\\n            ans<<=1;\\n            ans%=mod;\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int squareFreeSubsets(vector<int>& nums) {\\n        //2 3 5 7 11 13\\n        long long ans=0,mod=1e9+7,dp[2][2][2][2][2][2][2],ct[31]={};\\n        for(int i=0;i<nums.size();++i)++ct[nums[i]];\\n        ct[4]=ct[8]=ct[9]=ct[12]=ct[16]=ct[18]=ct[20]=ct[24]=ct[25]=ct[27]=ct[28]=0;\\n        memset(dp,0,sizeof(dp));\\n        dp[0][0][0][0][0][0][0]=1;\\n        for(int ii=2,la=1;ii<=31;++ii){\\n            if(ii==31){\\n                for(int i=0;i<2;++i)\\n                    for(int j=0;j<2;++j)\\n                        for(int k=0;k<2;++k)\\n                            for(int l=0;l<2;++l)\\n                                for(int m=0;m<2;++m)\\n                                    for(int n=0;n<2;++n)\\n                                        ans+=dp[la^1][i][j][k][l][m][n],ans%=mod;\\n                break;\\n            }\\n            if(ct[ii]){\\n                for(int i=0;i<2;++i)\\n                    for(int j=0;j<2;++j)\\n                        for(int k=0;k<2;++k)\\n                            for(int l=0;l<2;++l)\\n                                for(int m=0;m<2;++m)\\n                                    for(int n=0;n<2;++n)\\n                                        dp[la][i][j][k][l][m][n]=dp[la^1][i][j][k][l][m][n];\\n                bool x=!(ii%2),y=!(ii%3),z=!(ii%5),s=!(ii%7),a=!(ii%11),b=!(ii%13);\\n                for(int i=0;i<2-x;++i)\\n                    for(int j=0;j<2-y;++j)\\n                        for(int k=0;k<2-z;++k)\\n                            for(int l=0;l<2-s;++l)\\n                                for(int m=0;m<2-a;++m)\\n                                    for(int n=0;n<2-b;++n)\\n                                        dp[la][i+x][j+y][k+z][l+s][m+a][n+b]+=(ct[ii]*dp[la^1][i][j][k][l][m][n])%mod;\\n                la^=1;\\n            }\\n        }\\n        for(int i=0;i<ct[1];++i){\\n            ans<<=1;\\n            ans%=mod;\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204512,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        modulo = 1000000007\\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\\n        # map from number to factor\\n        n2f = {}\\n        for n in range(1, 31):\\n            if n % 4 == 0 or n % 9 == 0 or n % 25 == 0: continue\\n            factor = 0\\n            for i, p in enumerate(primes):\\n                if n % p == 0:\\n                    # prime factorization using bitmask\\n                    factor += (1 << i)\\n            n2f[n] = factor\\n\\n        # map from number to its count\\n        n2c = {}\\n        for num in nums:\\n            if num in n2f:\\n                n2c[num] = n2c.get(num, 0) + 1\\n            \\n        # some subset can have multiple ones, so speacially handle it\\n        one_count = n2c.get(1, 0)\\n        if 1 in n2c:\\n            del n2c[1]\\n\\n        ret = 0\\n        # iterate over all possible number subsets\\n        for i in range(1, len(n2c.keys()) + 1):\\n            for x in combinations(n2c, i):\\n\\n                # check square-free-ness\\n                factor_total = 0\\n                cont_flag = False\\n                for n in x:\\n                    if factor_total & n2f[n]:\\n                        cont_flag = True\\n                        break\\n                    factor_total |= n2f[n]\\n                if cont_flag: continue\\n                \\n                tmp = 1\\n                for n in x:\\n                    tmp = (tmp * n2c[n]) % modulo\\n                ret = (ret + tmp) % modulo\\n                    \\n        return ((ret + 1) * (2 ** one_count) - 1) % modulo\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        modulo = 1000000007\\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\\n        # map from number to factor\\n        n2f = {}\\n        for n in range(1, 31):\\n            if n % 4 == 0 or n % 9 == 0 or n % 25 == 0: continue\\n            factor = 0\\n            for i, p in enumerate(primes):\\n                if n % p == 0:\\n                    # prime factorization using bitmask\\n                    factor += (1 << i)\\n            n2f[n] = factor\\n\\n        # map from number to its count\\n        n2c = {}\\n        for num in nums:\\n            if num in n2f:\\n                n2c[num] = n2c.get(num, 0) + 1\\n            \\n        # some subset can have multiple ones, so speacially handle it\\n        one_count = n2c.get(1, 0)\\n        if 1 in n2c:\\n            del n2c[1]\\n\\n        ret = 0\\n        # iterate over all possible number subsets\\n        for i in range(1, len(n2c.keys()) + 1):\\n            for x in combinations(n2c, i):\\n\\n                # check square-free-ness\\n                factor_total = 0\\n                cont_flag = False\\n                for n in x:\\n                    if factor_total & n2f[n]:\\n                        cont_flag = True\\n                        break\\n                    factor_total |= n2f[n]\\n                if cont_flag: continue\\n                \\n                tmp = 1\\n                for n in x:\\n                    tmp = (tmp * n2c[n]) % modulo\\n                ret = (ret + tmp) % modulo\\n                    \\n        return ((ret + 1) * (2 ** one_count) - 1) % modulo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204284,
                "title": "python-improved-bitmasking-90ms-tc-100-o-30-1024",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEach prime can only appear at most once in subset thus we use bit masks to keep track of primes in current subset.\\nTo improve performance, we use counter to make TC to 30* from n*.\\nSince 1 can appear any number of time, need to take care of this separately.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(30*1024)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(30*1024)$$\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        primes = [2,3,5,7,11,13,17,19,23,29]\\n        MOD = 10**9 + 7\\n        cnt = Counter(nums)\\n        nums = list((cnt.keys()))\\n        pre = 1\\n        if(1 in nums):\\n            pre = pow(2,cnt[1],MOD)\\n            nums.remove(1)\\n        dp = [[-1]*(1<<10) for i in range(len(nums))]\\n        @cache\\n        def prime_mask(num):\\n            mask = 0\\n            for i in range(len(primes)):\\n                times = 0\\n                while(num%primes[i]==0): \\n                    num //=primes[i];\\n                    times+=1\\n                if(times>1): return -1 # not valid \\n                if(times==1): mask |= 1<<i\\n            return mask\\n        def pick(idx,product_mask):\\n            if(len(nums)==idx): return 1\\n            if(dp[idx][product_mask]!=-1): return dp[idx][product_mask];\\n            res = pick(idx+1,product_mask)\\n            mask = prime_mask(nums[idx])\\n            if(mask!=-1 and (mask&product_mask)==0): # if no common primes\\n                res = (res+pick(idx+1,product_mask|mask)*cnt[nums[idx]])%MOD\\n            dp[idx][product_mask] = res\\n            return res\\n        return ((pre*pick(0,0)) - 1)%MOD        \\n                    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        primes = [2,3,5,7,11,13,17,19,23,29]\\n        MOD = 10**9 + 7\\n        cnt = Counter(nums)\\n        nums = list((cnt.keys()))\\n        pre = 1\\n        if(1 in nums):\\n            pre = pow(2,cnt[1],MOD)\\n            nums.remove(1)\\n        dp = [[-1]*(1<<10) for i in range(len(nums))]\\n        @cache\\n        def prime_mask(num):\\n            mask = 0\\n            for i in range(len(primes)):\\n                times = 0\\n                while(num%primes[i]==0): \\n                    num //=primes[i];\\n                    times+=1\\n                if(times>1): return -1 # not valid \\n                if(times==1): mask |= 1<<i\\n            return mask\\n        def pick(idx,product_mask):\\n            if(len(nums)==idx): return 1\\n            if(dp[idx][product_mask]!=-1): return dp[idx][product_mask];\\n            res = pick(idx+1,product_mask)\\n            mask = prime_mask(nums[idx])\\n            if(mask!=-1 and (mask&product_mask)==0): # if no common primes\\n                res = (res+pick(idx+1,product_mask|mask)*cnt[nums[idx]])%MOD\\n            dp[idx][product_mask] = res\\n            return res\\n        return ((pre*pick(0,0)) - 1)%MOD        \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204117,
                "title": "backtracking-counter-pie",
                "content": "```python3 []\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        \\n        squares = set([4, 8, 9, 12, 16, 18, 20, 24, 25, 27, 28])\\n        primes = { 2: [1,0,0,0,0,0,0,0,0,0],\\n                   3: [0,1,0,0,0,0,0,0,0,0],\\n                   5: [0,0,1,0,0,0,0,0,0,0],\\n                   6: [1,1,0,0,0,0,0,0,0,0],\\n                   7: [0,0,0,1,0,0,0,0,0,0],\\n                  10: [1,0,1,0,0,0,0,0,0,0],\\n                  11: [0,0,0,0,1,0,0,0,0,0],\\n                  13: [0,0,0,0,0,1,0,0,0,0],\\n                  14: [1,0,0,1,0,0,0,0,0,0],\\n                  15: [0,1,1,0,0,0,0,0,0,0],\\n                  17: [0,0,0,0,0,0,1,0,0,0],\\n                  19: [0,0,0,0,0,0,0,1,0,0],\\n                  21: [0,1,0,1,0,0,0,0,0,0],\\n                  22: [1,0,0,0,1,0,0,0,0,0],\\n                  23: [0,0,0,0,0,0,0,0,1,0],\\n                  26: [1,0,0,0,0,1,0,0,0,0],\\n                  29: [0,0,0,0,0,0,0,0,0,1],\\n                  30: [1,1,1,0,0,0,0,0,0,0]\\n                 }\\n        \\n        nums = [num for num in nums if num not in squares]; countNums = Counter(nums)\\n        \\n        notOnes = [key for key in countNums.keys() if key != 1]; n = len(notOnes)\\n        count = 0; currentSubset = []; currentProduct = [0,0,0,0,0,0,0,0,0,0]\\n        def backtrack(i: int = 0) -> None:\\n            nonlocal count\\n            if currentSubset:\\n                # find number of possible subsets with current keys\\n                product = 1\\n                for key in currentSubset:\\n                    product *= countNums[key]\\n                count = (count + product) % (10 ** 9 + 7)\\n            for j in range(i, n):\\n                key = notOnes[j]\\n                if all(curr + num <= 1 for curr, num in zip(currentProduct, primes[key])):\\n                    currentSubset.append(key)\\n                    for k in range(10):\\n                        currentProduct[k] += primes[key][k]\\n                    backtrack(j + 1)\\n                    currentSubset.pop()\\n                    for k in range(10):\\n                        currentProduct[k] -= primes[key][k]\\n\\n        backtrack()\\n        # add ones using PIE\\n        return ((count + 1) * 2 ** countNums[1] - 1) % (10 ** 9 + 7)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        \\n        squares = set([4, 8, 9, 12, 16, 18, 20, 24, 25, 27, 28])\\n        primes = { 2: [1,0,0,0,0,0,0,0,0,0],\\n                   3: [0,1,0,0,0,0,0,0,0,0],\\n                   5: [0,0,1,0,0,0,0,0,0,0],\\n                   6: [1,1,0,0,0,0,0,0,0,0],\\n                   7: [0,0,0,1,0,0,0,0,0,0],\\n                  10: [1,0,1,0,0,0,0,0,0,0],\\n                  11: [0,0,0,0,1,0,0,0,0,0],\\n                  13: [0,0,0,0,0,1,0,0,0,0],\\n                  14: [1,0,0,1,0,0,0,0,0,0],\\n                  15: [0,1,1,0,0,0,0,0,0,0],\\n                  17: [0,0,0,0,0,0,1,0,0,0],\\n                  19: [0,0,0,0,0,0,0,1,0,0],\\n                  21: [0,1,0,1,0,0,0,0,0,0],\\n                  22: [1,0,0,0,1,0,0,0,0,0],\\n                  23: [0,0,0,0,0,0,0,0,1,0],\\n                  26: [1,0,0,0,0,1,0,0,0,0],\\n                  29: [0,0,0,0,0,0,0,0,0,1],\\n                  30: [1,1,1,0,0,0,0,0,0,0]\\n                 }\\n        \\n        nums = [num for num in nums if num not in squares]; countNums = Counter(nums)\\n        \\n        notOnes = [key for key in countNums.keys() if key != 1]; n = len(notOnes)\\n        count = 0; currentSubset = []; currentProduct = [0,0,0,0,0,0,0,0,0,0]\\n        def backtrack(i: int = 0) -> None:\\n            nonlocal count\\n            if currentSubset:\\n                # find number of possible subsets with current keys\\n                product = 1\\n                for key in currentSubset:\\n                    product *= countNums[key]\\n                count = (count + product) % (10 ** 9 + 7)\\n            for j in range(i, n):\\n                key = notOnes[j]\\n                if all(curr + num <= 1 for curr, num in zip(currentProduct, primes[key])):\\n                    currentSubset.append(key)\\n                    for k in range(10):\\n                        currentProduct[k] += primes[key][k]\\n                    backtrack(j + 1)\\n                    currentSubset.pop()\\n                    for k in range(10):\\n                        currentProduct[k] -= primes[key][k]\\n\\n        backtrack()\\n        # add ones using PIE\\n        return ((count + 1) * 2 ** countNums[1] - 1) % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204086,
                "title": "c-dp-with-bitmasking-prime-factorization-precomputation-o-n-2-11-time-and-space",
                "content": "# Approach\\n* Find all the **prime factors of numbers <= 30** which are valid(invalid numbers have duplicate prime factors, so don\\'t consider them)\\n* Then perform **index compression** to map each prime number <= 30 to a unique integer between **0 and 9**(since there are only 10 prime numbers <= 30)\\n* let\\'s define a dp state dp(i, mask, non_empty) = number of subsets in `a[0..i]` such that we have chosen `mask` prime numbers(meaning if ith bit is set in the mask, we\\'ve chosen the ith prime number) and whether our subset is `non_empty`\\n* Base case is when we reach the end of the array, we return 1 if the current subset is non empty and the answer is `dp(0, 0, 0)` since we initially start at `0th` index with no elements chosen\\n* At each index we can either choose `a[i]` or don\\'t choose it. We can only choose `a[i]` if either `a[i] = 1` or if none of `a[i]`\\'s prime factors are already chosen before(can be checked with the help of mask)\\n\\n# Complexity\\n- Time complexity: O(n * 2 ^11) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * 2 ^11) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int squareFreeSubsets(vector<int>& a) {\\n      int n = a.size();\\n      const int MOD = 1e9 + 7;\\n      \\n      vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n      vector<int> valids = {1, 2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30};\\n      vector<vector<int>> pfs(31);\\n      for (auto &ai: valids) {\\n        int x = ai;\\n        for (auto &p: primes) {\\n          while (x % p == 0) {\\n            pfs[ai].push_back(p);\\n            x /= p;\\n          }\\n        }\\n      }\\n      \\n      vector<int> idx_of(31);\\n      for (int i = 0; i < 10; i++)\\n        idx_of[primes[i]] = i;\\n      \\n      vector<bool> is_invalid(31, true);\\n      for (auto &ai: valids)\\n        is_invalid[ai] = false;\\n      \\n      int memo[n][1025][2];\\n      memset(memo, -1, sizeof memo);\\n      function<int(int, int, bool)> dp = [&] (int i, int mask, bool non_empty) -> int {\\n        if (i == n) return non_empty;  \\n        \\n        if (memo[i][mask][non_empty] != -1) return memo[i][mask][non_empty];\\n        \\n        int ans1 = dp(i + 1, mask, non_empty);\\n        \\n        int ans2 = 0;\\n        if (a[i] == 1) {\\n          ans2 = dp(i + 1, mask, 1);\\n        } else if (!is_invalid[a[i]]) {\\n          bool ok = true;\\n          for (auto &pi: pfs[a[i]])\\n            ok &= !(mask & (1 << idx_of[pi]));\\n          \\n          if (ok) {\\n            int nm = mask;\\n            for (auto &pi: pfs[a[i]])\\n              nm |= (1 << idx_of[pi]);\\n            \\n            ans2 = dp(i + 1, nm, 1);\\n          }\\n        }\\n        \\n        return memo[i][mask][non_empty] = (ans1 + ans2) % MOD;\\n      };\\n      \\n      return dp(0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int squareFreeSubsets(vector<int>& a) {\\n      int n = a.size();\\n      const int MOD = 1e9 + 7;\\n      \\n      vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\\n      vector<int> valids = {1, 2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30};\\n      vector<vector<int>> pfs(31);\\n      for (auto &ai: valids) {\\n        int x = ai;\\n        for (auto &p: primes) {\\n          while (x % p == 0) {\\n            pfs[ai].push_back(p);\\n            x /= p;\\n          }\\n        }\\n      }\\n      \\n      vector<int> idx_of(31);\\n      for (int i = 0; i < 10; i++)\\n        idx_of[primes[i]] = i;\\n      \\n      vector<bool> is_invalid(31, true);\\n      for (auto &ai: valids)\\n        is_invalid[ai] = false;\\n      \\n      int memo[n][1025][2];\\n      memset(memo, -1, sizeof memo);\\n      function<int(int, int, bool)> dp = [&] (int i, int mask, bool non_empty) -> int {\\n        if (i == n) return non_empty;  \\n        \\n        if (memo[i][mask][non_empty] != -1) return memo[i][mask][non_empty];\\n        \\n        int ans1 = dp(i + 1, mask, non_empty);\\n        \\n        int ans2 = 0;\\n        if (a[i] == 1) {\\n          ans2 = dp(i + 1, mask, 1);\\n        } else if (!is_invalid[a[i]]) {\\n          bool ok = true;\\n          for (auto &pi: pfs[a[i]])\\n            ok &= !(mask & (1 << idx_of[pi]));\\n          \\n          if (ok) {\\n            int nm = mask;\\n            for (auto &pi: pfs[a[i]])\\n              nm |= (1 << idx_of[pi]);\\n            \\n            ans2 = dp(i + 1, nm, 1);\\n          }\\n        }\\n        \\n        return memo[i][mask][non_empty] = (ans1 + ans2) % MOD;\\n      };\\n      \\n      return dp(0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204036,
                "title": "begineer-friendly-bitmask-solution-dp",
                "content": "\\n\\n\\n# Approach\\n    - Ideas is to pick numbers which don\\'t share the factors \\n    - we can not pick element which already has square of elements present in it as factor . example : 18 = (3^2) * 2\\n    - we use bitmask to respresent factors \\n\\n\\nTime complexity: o(n^2)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long mod = 1e9+7; \\n\\n    long long solve(int i,long long mask,vector<int>& nums,unordered_map<int,int>& mem,vector<vector<long long>>& dp){\\n\\n        if(i>nums.size()-1) return 0 ;\\n\\n        if(dp[i][mask]!=-1) return dp[i][mask];\\n\\n        int notPick = solve(i+1,mask,nums,mem,dp);\\n\\n        // it is not possible to pick if it contain square element as factor \\n\\n        for(int j=2;j<=sqrt(nums[i]);j++){\\n            \\n            if(nums[i]%(j*j)==0) return dp[i][mask] = notPick ;\\n\\n        }\\n\\n        // it is not possible to pick if its factor is already picked\\n\\n        for(int j=0;j<10;j++){\\n\\n            int k = mem[j] ,isSet= (mask&(1<<j)); \\n\\n            if(nums[i]%k==0 && isSet) return dp[i][mask] = notPick ; \\n\\n        }\\n\\n        long long prev = mask; \\n\\n        // set new mask \\n\\n        for(auto j:mem){\\n\\n            if(nums[i]%j.second==0) mask^=(1<<j.first);\\n\\n        }\\n\\n        int pick = 1+solve(i+1,mask,nums,mem,dp);\\n\\n        return dp[i][prev]= (pick+notPick)%mod; \\n\\n    }\\n\\n    int squareFreeSubsets(vector<int>& nums) {\\n        \\n        unordered_map<int,int> mem ;\\n\\n        vector<int> visited(31);\\n\\n        vector<vector<long long>> dp(nums.size()+1,vector<long long>((1<<10)+1,-1));\\n\\n        int count =0 ;\\n\\n        for(int i=2;i<30;i++){\\n\\n            if(visited[i]) continue ;\\n\\n            for(int j=2*i;j<30;j+=i) visited[j] = true ;\\n            \\n            mem[count++] = i ;\\n    \\n        }\\n\\n        return solve(0,0,nums,mem,dp);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long mod = 1e9+7; \\n\\n    long long solve(int i,long long mask,vector<int>& nums,unordered_map<int,int>& mem,vector<vector<long long>>& dp){\\n\\n        if(i>nums.size()-1) return 0 ;\\n\\n        if(dp[i][mask]!=-1) return dp[i][mask];\\n\\n        int notPick = solve(i+1,mask,nums,mem,dp);\\n\\n        // it is not possible to pick if it contain square element as factor \\n\\n        for(int j=2;j<=sqrt(nums[i]);j++){\\n            \\n            if(nums[i]%(j*j)==0) return dp[i][mask] = notPick ;\\n\\n        }\\n\\n        // it is not possible to pick if its factor is already picked\\n\\n        for(int j=0;j<10;j++){\\n\\n            int k = mem[j] ,isSet= (mask&(1<<j)); \\n\\n            if(nums[i]%k==0 && isSet) return dp[i][mask] = notPick ; \\n\\n        }\\n\\n        long long prev = mask; \\n\\n        // set new mask \\n\\n        for(auto j:mem){\\n\\n            if(nums[i]%j.second==0) mask^=(1<<j.first);\\n\\n        }\\n\\n        int pick = 1+solve(i+1,mask,nums,mem,dp);\\n\\n        return dp[i][prev]= (pick+notPick)%mod; \\n\\n    }\\n\\n    int squareFreeSubsets(vector<int>& nums) {\\n        \\n        unordered_map<int,int> mem ;\\n\\n        vector<int> visited(31);\\n\\n        vector<vector<long long>> dp(nums.size()+1,vector<long long>((1<<10)+1,-1));\\n\\n        int count =0 ;\\n\\n        for(int i=2;i<30;i++){\\n\\n            if(visited[i]) continue ;\\n\\n            for(int j=2*i;j<30;j+=i) visited[j] = true ;\\n            \\n            mem[count++] = i ;\\n    \\n        }\\n\\n        return solve(0,0,nums,mem,dp);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203957,
                "title": "preconstruct-multiplication-of-all-prime-numbers-please-check-complexity",
                "content": "# Intuition\\npreConstruct prime number multiplication, and solve dp.\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\n- O(N^2)\\n\\n# Code\\n```\\nclass Solution {\\n    public int squareFreeSubsets(int[] nums) {\\n        int mod = 1000000007;\\n        int ans = 0;\\n        Set<Long> set = new HashSet<>();\\n        Map<Long, Integer> map = new HashMap<>();\\n        List<Long> arr = new ArrayList<Long>(Arrays.asList(2L,3L,5L,7L,11L,13L,17L,19L,23L,29L));\\n        \\n        for(int i=2; i<=arr.size(); i++) {\\n            for(int j=0; j<arr.size(); j++) {\\n                getNums(set, arr, j, 1, i, arr.get(j));    \\n            }\\n        }\\n        for(int i=0; i<arr.size(); i++) {\\n            set.add(arr.get(i));\\n        }\\n        set.add(1L);\\n        map.put(1L,1);\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            boolean flag = set.contains((long)nums[i]);\\n            if(!flag) {\\n                continue;\\n            }\\n            Map<Long, Integer> tmp = new HashMap<>();\\n            for(long key: map.keySet()) {\\n                long cur = key*nums[i];\\n                \\n                if(set.contains(cur)) {\\n                    ans = (ans+map.get(key))%mod;\\n                    tmp.put(cur, (map.getOrDefault(cur,0)+map.get(key))%mod);\\n                }\\n            }\\n            for(long key: tmp.keySet()) {\\n                map.put(key, tmp.get(key));\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    private void getNums(Set<Long> set, List<Long> arr, int idx, int curCount, int max, long cur) {\\n        if(curCount == max) {\\n            set.add(cur);\\n            return;\\n        }\\n        \\n        if(idx >= arr.size()) return;\\n        \\n        for(int i=idx+1; i<arr.size(); i++) {\\n            getNums(set, arr, i, curCount+1, max, cur*arr.get(i));\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int squareFreeSubsets(int[] nums) {\\n        int mod = 1000000007;\\n        int ans = 0;\\n        Set<Long> set = new HashSet<>();\\n        Map<Long, Integer> map = new HashMap<>();\\n        List<Long> arr = new ArrayList<Long>(Arrays.asList(2L,3L,5L,7L,11L,13L,17L,19L,23L,29L));\\n        \\n        for(int i=2; i<=arr.size(); i++) {\\n            for(int j=0; j<arr.size(); j++) {\\n                getNums(set, arr, j, 1, i, arr.get(j));    \\n            }\\n        }\\n        for(int i=0; i<arr.size(); i++) {\\n            set.add(arr.get(i));\\n        }\\n        set.add(1L);\\n        map.put(1L,1);\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            boolean flag = set.contains((long)nums[i]);\\n            if(!flag) {\\n                continue;\\n            }\\n            Map<Long, Integer> tmp = new HashMap<>();\\n            for(long key: map.keySet()) {\\n                long cur = key*nums[i];\\n                \\n                if(set.contains(cur)) {\\n                    ans = (ans+map.get(key))%mod;\\n                    tmp.put(cur, (map.getOrDefault(cur,0)+map.get(key))%mod);\\n                }\\n            }\\n            for(long key: tmp.keySet()) {\\n                map.put(key, tmp.get(key));\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    private void getNums(Set<Long> set, List<Long> arr, int idx, int curCount, int max, long cur) {\\n        if(curCount == max) {\\n            set.add(cur);\\n            return;\\n        }\\n        \\n        if(idx >= arr.size()) return;\\n        \\n        for(int i=idx+1; i<arr.size(); i++) {\\n            getNums(set, arr, i, curCount+1, max, cur*arr.get(i));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203897,
                "title": "java-dp-solution",
                "content": "\\n\\n# Code\\n```\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.ArrayList;\\n\\nclass Solution {\\n    static long[][] dp = new long[1111][1 << 11];\\n    static long mod;\\n    static List<Integer> primes;\\n\\n    public int squareFreeSubsets(int[] nums) {\\n        mod = (long)1e9 + 7;\\n        Arrays.stream(dp).forEach(a -> Arrays.fill(a, -1));\\n        primes = new ArrayList<>(Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29));\\n\\n        return (int)dfs(0, 1, nums) - 1;\\n    }\\n\\n    static int getMask(int num) {\\n        int mask = 0;\\n        for (int i = 0; i < 10; i++) {\\n            int tim = 0;\\n            while (num % primes.get(i) == 0) {\\n                tim += 1;\\n                num /= primes.get(i);\\n            }\\n            if (tim > 1) return -1;\\n            if (tim == 1) mask |= (1 << (i + 1));\\n        }\\n        return mask;\\n    }\\n\\n    static long dfs(int ind, int prodmask, int[] nums) {\\n        if (ind >= nums.length) return 1;\\n        if (dp[ind][prodmask] != -1) return dp[ind][prodmask];\\n\\n        int mask = getMask(nums[ind]);\\n        long ans = dfs(ind + 1, prodmask, nums);\\n\\n        if ((prodmask & mask) == 0) {\\n            ans += dfs(ind + 1, prodmask | mask, nums);\\n        }\\n\\n        return dp[ind][prodmask] = ans % mod;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.ArrayList;\\n\\nclass Solution {\\n    static long[][] dp = new long[1111][1 << 11];\\n    static long mod;\\n    static List<Integer> primes;\\n\\n    public int squareFreeSubsets(int[] nums) {\\n        mod = (long)1e9 + 7;\\n        Arrays.stream(dp).forEach(a -> Arrays.fill(a, -1));\\n        primes = new ArrayList<>(Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29));\\n\\n        return (int)dfs(0, 1, nums) - 1;\\n    }\\n\\n    static int getMask(int num) {\\n        int mask = 0;\\n        for (int i = 0; i < 10; i++) {\\n            int tim = 0;\\n            while (num % primes.get(i) == 0) {\\n                tim += 1;\\n                num /= primes.get(i);\\n            }\\n            if (tim > 1) return -1;\\n            if (tim == 1) mask |= (1 << (i + 1));\\n        }\\n        return mask;\\n    }\\n\\n    static long dfs(int ind, int prodmask, int[] nums) {\\n        if (ind >= nums.length) return 1;\\n        if (dp[ind][prodmask] != -1) return dp[ind][prodmask];\\n\\n        int mask = getMask(nums[ind]);\\n        long ans = dfs(ind + 1, prodmask, nums);\\n\\n        if ((prodmask & mask) == 0) {\\n            ans += dfs(ind + 1, prodmask | mask, nums);\\n        }\\n\\n        return dp[ind][prodmask] = ans % mod;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1806414,
                "content": [
                    {
                        "username": "Blake_Han12",
                        "content": "5.7% ACCEPTANCE RATE. Lowest ever???"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "This should be tagged as HARD!!!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "Finally understood the solution.\\nThis is probably one of the hardest questions I have seen."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Taking me more time to figure out than most of Hard problems, so why it is medium?"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "According even to acceptance - this must be hard problem."
                    },
                    {
                        "username": "aa871788",
                        "content": "Brute force solution returns TLE."
                    },
                    {
                        "username": "dj_khalid",
                        "content": "Can someone please explain why the answer for this testcase is 3 ->\\n[26,6,4,27,6,18]\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`4`, `27`, and `18` are all divisible by squares so they aren't square-free. They're divisible by `4`, `9`, and `9` respectively. So none of the subsets can include those numbers.\n\nThat leaves only `[26,6,6]`. The single element subsets are all square-free: `[26]`,`[6]`, and `[6]`. **That's 3 subsets**.\n\nLet's look at the larger subsets like `[26,6]`, `[6,6]`, and `[26,6,6]`. `26 * 6 = 156` is divisible by `4` so it's not square-free. Similarly `6 * 6 = 36` is divisible by `36` so it's also not square-free. That means all of the other subsets are not square-free."
                    },
                    {
                        "username": "shivansh961",
                        "content": "In Example-1, why  [3,4] is not a square free subarray ?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) Now I understand the question. Thanks for the help !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@Tensor08](/Tensor08) Understood !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  got it, thanks "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "if you make its product, it will become 3*4 = 12, and this set is not square free because 12%4 = 0, where 4 is a perfect square"
                    },
                    {
                        "username": "Tensor08",
                        "content": "[@shivansh961](/shivansh961)  27 can't be included because 27 - 3 * 3 * 3 which include squareOf(3) * 3."
                    },
                    {
                        "username": "ynchsung",
                        "content": "[@shivansh961](/shivansh961)\n- 27, 18 cannot be selected.\n- [26, 6] is not a valid set, either.\n\nThe question means: When you select [a, b, c], you have to multiply them all (a * b * c), and a valid set definition: a * b * c is not divisible by any \"square number\", e.g. 4, 9, 25."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) For this test case : [26,6,4,27,6,18] answer is coming 3 but there are 5 such subsets.\\n[26], [6], [26, 6], [27], [27, 6], [27, 6, 18]. \\n\\nI think I am misunderstanding the questions. Can you spend some time and tell me the mistake ?\\n"
                    },
                    {
                        "username": "ynchsung",
                        "content": "4 itself is a square."
                    },
                    {
                        "username": "ynchsung",
                        "content": "1 is special case.\n\nFor 2, 3, 5, 7, ..., we only can select them once.\nFor example, consider a subset that only contains 2, 3, 5, 7.\nMost people's method will calculate (# of 2) * (# of 3) * (# of 5) * (# of 7),\nwhich is the total # of subsets that only contains \"exact one 2, 3, 5, and 7\" in the array.\n\nHowever, for 1, we can select any # of 1s. The brute force will miss the case for \"selecting more than 1 1s\".\n\nIOW when we're computing \"subsets with 1, 2, 3\", we will do something like (# of 1) * (# of 2) * (# of 3), and add to the ans.\nBut this is incorrect, because 1 can actually be selected more than once.\n\nSaying we have [1, 1, 2, 2, 2, 3, 3, 3, 3], most people's solution will calculate 2 * 3 * 4.\nThis number is # of subset of [1, 2, 3], but you can actually select [1, 1, 2, 3], which is not included in 2 * 3 * 4.\n\nIn fact, there will be (2^(# of 1s))x more subsets.\n\nSo let's modify the brute force algorithm:\n- Remove 1s from the collection\n- Run your original brute force algorithm to calculate # of subsets (which doesn't include 1s). For convenience, let's name it `tmp_ans`.\n- Now, saying we have `N` 1s, then `tmp_ans` subsets can result in `tmp_ans * (2^N)` subsets when combining with 1.\n- Also remember, you can select \"NON-EMPTY subsets with only 1s\", which results in another additional `2^N - 1` subsets.\n- So the final answer is `tmp_ans * (2^N) + (2^N - 1)`. Remember to mod 10^9 + 7."
                    },
                    {
                        "username": "sushruti",
                        "content": "this is not a medium problem..."
                    }
                ]
            },
            {
                "id": 1807385,
                "content": [
                    {
                        "username": "Blake_Han12",
                        "content": "5.7% ACCEPTANCE RATE. Lowest ever???"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "This should be tagged as HARD!!!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "Finally understood the solution.\\nThis is probably one of the hardest questions I have seen."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Taking me more time to figure out than most of Hard problems, so why it is medium?"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "According even to acceptance - this must be hard problem."
                    },
                    {
                        "username": "aa871788",
                        "content": "Brute force solution returns TLE."
                    },
                    {
                        "username": "dj_khalid",
                        "content": "Can someone please explain why the answer for this testcase is 3 ->\\n[26,6,4,27,6,18]\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`4`, `27`, and `18` are all divisible by squares so they aren't square-free. They're divisible by `4`, `9`, and `9` respectively. So none of the subsets can include those numbers.\n\nThat leaves only `[26,6,6]`. The single element subsets are all square-free: `[26]`,`[6]`, and `[6]`. **That's 3 subsets**.\n\nLet's look at the larger subsets like `[26,6]`, `[6,6]`, and `[26,6,6]`. `26 * 6 = 156` is divisible by `4` so it's not square-free. Similarly `6 * 6 = 36` is divisible by `36` so it's also not square-free. That means all of the other subsets are not square-free."
                    },
                    {
                        "username": "shivansh961",
                        "content": "In Example-1, why  [3,4] is not a square free subarray ?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) Now I understand the question. Thanks for the help !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@Tensor08](/Tensor08) Understood !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  got it, thanks "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "if you make its product, it will become 3*4 = 12, and this set is not square free because 12%4 = 0, where 4 is a perfect square"
                    },
                    {
                        "username": "Tensor08",
                        "content": "[@shivansh961](/shivansh961)  27 can't be included because 27 - 3 * 3 * 3 which include squareOf(3) * 3."
                    },
                    {
                        "username": "ynchsung",
                        "content": "[@shivansh961](/shivansh961)\n- 27, 18 cannot be selected.\n- [26, 6] is not a valid set, either.\n\nThe question means: When you select [a, b, c], you have to multiply them all (a * b * c), and a valid set definition: a * b * c is not divisible by any \"square number\", e.g. 4, 9, 25."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) For this test case : [26,6,4,27,6,18] answer is coming 3 but there are 5 such subsets.\\n[26], [6], [26, 6], [27], [27, 6], [27, 6, 18]. \\n\\nI think I am misunderstanding the questions. Can you spend some time and tell me the mistake ?\\n"
                    },
                    {
                        "username": "ynchsung",
                        "content": "4 itself is a square."
                    },
                    {
                        "username": "ynchsung",
                        "content": "1 is special case.\n\nFor 2, 3, 5, 7, ..., we only can select them once.\nFor example, consider a subset that only contains 2, 3, 5, 7.\nMost people's method will calculate (# of 2) * (# of 3) * (# of 5) * (# of 7),\nwhich is the total # of subsets that only contains \"exact one 2, 3, 5, and 7\" in the array.\n\nHowever, for 1, we can select any # of 1s. The brute force will miss the case for \"selecting more than 1 1s\".\n\nIOW when we're computing \"subsets with 1, 2, 3\", we will do something like (# of 1) * (# of 2) * (# of 3), and add to the ans.\nBut this is incorrect, because 1 can actually be selected more than once.\n\nSaying we have [1, 1, 2, 2, 2, 3, 3, 3, 3], most people's solution will calculate 2 * 3 * 4.\nThis number is # of subset of [1, 2, 3], but you can actually select [1, 1, 2, 3], which is not included in 2 * 3 * 4.\n\nIn fact, there will be (2^(# of 1s))x more subsets.\n\nSo let's modify the brute force algorithm:\n- Remove 1s from the collection\n- Run your original brute force algorithm to calculate # of subsets (which doesn't include 1s). For convenience, let's name it `tmp_ans`.\n- Now, saying we have `N` 1s, then `tmp_ans` subsets can result in `tmp_ans * (2^N)` subsets when combining with 1.\n- Also remember, you can select \"NON-EMPTY subsets with only 1s\", which results in another additional `2^N - 1` subsets.\n- So the final answer is `tmp_ans * (2^N) + (2^N - 1)`. Remember to mod 10^9 + 7."
                    },
                    {
                        "username": "sushruti",
                        "content": "this is not a medium problem..."
                    }
                ]
            },
            {
                "id": 1809659,
                "content": [
                    {
                        "username": "Blake_Han12",
                        "content": "5.7% ACCEPTANCE RATE. Lowest ever???"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "This should be tagged as HARD!!!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "Finally understood the solution.\\nThis is probably one of the hardest questions I have seen."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Taking me more time to figure out than most of Hard problems, so why it is medium?"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "According even to acceptance - this must be hard problem."
                    },
                    {
                        "username": "aa871788",
                        "content": "Brute force solution returns TLE."
                    },
                    {
                        "username": "dj_khalid",
                        "content": "Can someone please explain why the answer for this testcase is 3 ->\\n[26,6,4,27,6,18]\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`4`, `27`, and `18` are all divisible by squares so they aren't square-free. They're divisible by `4`, `9`, and `9` respectively. So none of the subsets can include those numbers.\n\nThat leaves only `[26,6,6]`. The single element subsets are all square-free: `[26]`,`[6]`, and `[6]`. **That's 3 subsets**.\n\nLet's look at the larger subsets like `[26,6]`, `[6,6]`, and `[26,6,6]`. `26 * 6 = 156` is divisible by `4` so it's not square-free. Similarly `6 * 6 = 36` is divisible by `36` so it's also not square-free. That means all of the other subsets are not square-free."
                    },
                    {
                        "username": "shivansh961",
                        "content": "In Example-1, why  [3,4] is not a square free subarray ?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) Now I understand the question. Thanks for the help !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@Tensor08](/Tensor08) Understood !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  got it, thanks "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "if you make its product, it will become 3*4 = 12, and this set is not square free because 12%4 = 0, where 4 is a perfect square"
                    },
                    {
                        "username": "Tensor08",
                        "content": "[@shivansh961](/shivansh961)  27 can't be included because 27 - 3 * 3 * 3 which include squareOf(3) * 3."
                    },
                    {
                        "username": "ynchsung",
                        "content": "[@shivansh961](/shivansh961)\n- 27, 18 cannot be selected.\n- [26, 6] is not a valid set, either.\n\nThe question means: When you select [a, b, c], you have to multiply them all (a * b * c), and a valid set definition: a * b * c is not divisible by any \"square number\", e.g. 4, 9, 25."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) For this test case : [26,6,4,27,6,18] answer is coming 3 but there are 5 such subsets.\\n[26], [6], [26, 6], [27], [27, 6], [27, 6, 18]. \\n\\nI think I am misunderstanding the questions. Can you spend some time and tell me the mistake ?\\n"
                    },
                    {
                        "username": "ynchsung",
                        "content": "4 itself is a square."
                    },
                    {
                        "username": "ynchsung",
                        "content": "1 is special case.\n\nFor 2, 3, 5, 7, ..., we only can select them once.\nFor example, consider a subset that only contains 2, 3, 5, 7.\nMost people's method will calculate (# of 2) * (# of 3) * (# of 5) * (# of 7),\nwhich is the total # of subsets that only contains \"exact one 2, 3, 5, and 7\" in the array.\n\nHowever, for 1, we can select any # of 1s. The brute force will miss the case for \"selecting more than 1 1s\".\n\nIOW when we're computing \"subsets with 1, 2, 3\", we will do something like (# of 1) * (# of 2) * (# of 3), and add to the ans.\nBut this is incorrect, because 1 can actually be selected more than once.\n\nSaying we have [1, 1, 2, 2, 2, 3, 3, 3, 3], most people's solution will calculate 2 * 3 * 4.\nThis number is # of subset of [1, 2, 3], but you can actually select [1, 1, 2, 3], which is not included in 2 * 3 * 4.\n\nIn fact, there will be (2^(# of 1s))x more subsets.\n\nSo let's modify the brute force algorithm:\n- Remove 1s from the collection\n- Run your original brute force algorithm to calculate # of subsets (which doesn't include 1s). For convenience, let's name it `tmp_ans`.\n- Now, saying we have `N` 1s, then `tmp_ans` subsets can result in `tmp_ans * (2^N)` subsets when combining with 1.\n- Also remember, you can select \"NON-EMPTY subsets with only 1s\", which results in another additional `2^N - 1` subsets.\n- So the final answer is `tmp_ans * (2^N) + (2^N - 1)`. Remember to mod 10^9 + 7."
                    },
                    {
                        "username": "sushruti",
                        "content": "this is not a medium problem..."
                    }
                ]
            },
            {
                "id": 1807480,
                "content": [
                    {
                        "username": "Blake_Han12",
                        "content": "5.7% ACCEPTANCE RATE. Lowest ever???"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "This should be tagged as HARD!!!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "Finally understood the solution.\\nThis is probably one of the hardest questions I have seen."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Taking me more time to figure out than most of Hard problems, so why it is medium?"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "According even to acceptance - this must be hard problem."
                    },
                    {
                        "username": "aa871788",
                        "content": "Brute force solution returns TLE."
                    },
                    {
                        "username": "dj_khalid",
                        "content": "Can someone please explain why the answer for this testcase is 3 ->\\n[26,6,4,27,6,18]\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`4`, `27`, and `18` are all divisible by squares so they aren't square-free. They're divisible by `4`, `9`, and `9` respectively. So none of the subsets can include those numbers.\n\nThat leaves only `[26,6,6]`. The single element subsets are all square-free: `[26]`,`[6]`, and `[6]`. **That's 3 subsets**.\n\nLet's look at the larger subsets like `[26,6]`, `[6,6]`, and `[26,6,6]`. `26 * 6 = 156` is divisible by `4` so it's not square-free. Similarly `6 * 6 = 36` is divisible by `36` so it's also not square-free. That means all of the other subsets are not square-free."
                    },
                    {
                        "username": "shivansh961",
                        "content": "In Example-1, why  [3,4] is not a square free subarray ?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) Now I understand the question. Thanks for the help !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@Tensor08](/Tensor08) Understood !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  got it, thanks "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "if you make its product, it will become 3*4 = 12, and this set is not square free because 12%4 = 0, where 4 is a perfect square"
                    },
                    {
                        "username": "Tensor08",
                        "content": "[@shivansh961](/shivansh961)  27 can't be included because 27 - 3 * 3 * 3 which include squareOf(3) * 3."
                    },
                    {
                        "username": "ynchsung",
                        "content": "[@shivansh961](/shivansh961)\n- 27, 18 cannot be selected.\n- [26, 6] is not a valid set, either.\n\nThe question means: When you select [a, b, c], you have to multiply them all (a * b * c), and a valid set definition: a * b * c is not divisible by any \"square number\", e.g. 4, 9, 25."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) For this test case : [26,6,4,27,6,18] answer is coming 3 but there are 5 such subsets.\\n[26], [6], [26, 6], [27], [27, 6], [27, 6, 18]. \\n\\nI think I am misunderstanding the questions. Can you spend some time and tell me the mistake ?\\n"
                    },
                    {
                        "username": "ynchsung",
                        "content": "4 itself is a square."
                    },
                    {
                        "username": "ynchsung",
                        "content": "1 is special case.\n\nFor 2, 3, 5, 7, ..., we only can select them once.\nFor example, consider a subset that only contains 2, 3, 5, 7.\nMost people's method will calculate (# of 2) * (# of 3) * (# of 5) * (# of 7),\nwhich is the total # of subsets that only contains \"exact one 2, 3, 5, and 7\" in the array.\n\nHowever, for 1, we can select any # of 1s. The brute force will miss the case for \"selecting more than 1 1s\".\n\nIOW when we're computing \"subsets with 1, 2, 3\", we will do something like (# of 1) * (# of 2) * (# of 3), and add to the ans.\nBut this is incorrect, because 1 can actually be selected more than once.\n\nSaying we have [1, 1, 2, 2, 2, 3, 3, 3, 3], most people's solution will calculate 2 * 3 * 4.\nThis number is # of subset of [1, 2, 3], but you can actually select [1, 1, 2, 3], which is not included in 2 * 3 * 4.\n\nIn fact, there will be (2^(# of 1s))x more subsets.\n\nSo let's modify the brute force algorithm:\n- Remove 1s from the collection\n- Run your original brute force algorithm to calculate # of subsets (which doesn't include 1s). For convenience, let's name it `tmp_ans`.\n- Now, saying we have `N` 1s, then `tmp_ans` subsets can result in `tmp_ans * (2^N)` subsets when combining with 1.\n- Also remember, you can select \"NON-EMPTY subsets with only 1s\", which results in another additional `2^N - 1` subsets.\n- So the final answer is `tmp_ans * (2^N) + (2^N - 1)`. Remember to mod 10^9 + 7."
                    },
                    {
                        "username": "sushruti",
                        "content": "this is not a medium problem..."
                    }
                ]
            },
            {
                "id": 1807369,
                "content": [
                    {
                        "username": "Blake_Han12",
                        "content": "5.7% ACCEPTANCE RATE. Lowest ever???"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "This should be tagged as HARD!!!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "Finally understood the solution.\\nThis is probably one of the hardest questions I have seen."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Taking me more time to figure out than most of Hard problems, so why it is medium?"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "According even to acceptance - this must be hard problem."
                    },
                    {
                        "username": "aa871788",
                        "content": "Brute force solution returns TLE."
                    },
                    {
                        "username": "dj_khalid",
                        "content": "Can someone please explain why the answer for this testcase is 3 ->\\n[26,6,4,27,6,18]\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`4`, `27`, and `18` are all divisible by squares so they aren't square-free. They're divisible by `4`, `9`, and `9` respectively. So none of the subsets can include those numbers.\n\nThat leaves only `[26,6,6]`. The single element subsets are all square-free: `[26]`,`[6]`, and `[6]`. **That's 3 subsets**.\n\nLet's look at the larger subsets like `[26,6]`, `[6,6]`, and `[26,6,6]`. `26 * 6 = 156` is divisible by `4` so it's not square-free. Similarly `6 * 6 = 36` is divisible by `36` so it's also not square-free. That means all of the other subsets are not square-free."
                    },
                    {
                        "username": "shivansh961",
                        "content": "In Example-1, why  [3,4] is not a square free subarray ?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) Now I understand the question. Thanks for the help !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@Tensor08](/Tensor08) Understood !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  got it, thanks "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "if you make its product, it will become 3*4 = 12, and this set is not square free because 12%4 = 0, where 4 is a perfect square"
                    },
                    {
                        "username": "Tensor08",
                        "content": "[@shivansh961](/shivansh961)  27 can't be included because 27 - 3 * 3 * 3 which include squareOf(3) * 3."
                    },
                    {
                        "username": "ynchsung",
                        "content": "[@shivansh961](/shivansh961)\n- 27, 18 cannot be selected.\n- [26, 6] is not a valid set, either.\n\nThe question means: When you select [a, b, c], you have to multiply them all (a * b * c), and a valid set definition: a * b * c is not divisible by any \"square number\", e.g. 4, 9, 25."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) For this test case : [26,6,4,27,6,18] answer is coming 3 but there are 5 such subsets.\\n[26], [6], [26, 6], [27], [27, 6], [27, 6, 18]. \\n\\nI think I am misunderstanding the questions. Can you spend some time and tell me the mistake ?\\n"
                    },
                    {
                        "username": "ynchsung",
                        "content": "4 itself is a square."
                    },
                    {
                        "username": "ynchsung",
                        "content": "1 is special case.\n\nFor 2, 3, 5, 7, ..., we only can select them once.\nFor example, consider a subset that only contains 2, 3, 5, 7.\nMost people's method will calculate (# of 2) * (# of 3) * (# of 5) * (# of 7),\nwhich is the total # of subsets that only contains \"exact one 2, 3, 5, and 7\" in the array.\n\nHowever, for 1, we can select any # of 1s. The brute force will miss the case for \"selecting more than 1 1s\".\n\nIOW when we're computing \"subsets with 1, 2, 3\", we will do something like (# of 1) * (# of 2) * (# of 3), and add to the ans.\nBut this is incorrect, because 1 can actually be selected more than once.\n\nSaying we have [1, 1, 2, 2, 2, 3, 3, 3, 3], most people's solution will calculate 2 * 3 * 4.\nThis number is # of subset of [1, 2, 3], but you can actually select [1, 1, 2, 3], which is not included in 2 * 3 * 4.\n\nIn fact, there will be (2^(# of 1s))x more subsets.\n\nSo let's modify the brute force algorithm:\n- Remove 1s from the collection\n- Run your original brute force algorithm to calculate # of subsets (which doesn't include 1s). For convenience, let's name it `tmp_ans`.\n- Now, saying we have `N` 1s, then `tmp_ans` subsets can result in `tmp_ans * (2^N)` subsets when combining with 1.\n- Also remember, you can select \"NON-EMPTY subsets with only 1s\", which results in another additional `2^N - 1` subsets.\n- So the final answer is `tmp_ans * (2^N) + (2^N - 1)`. Remember to mod 10^9 + 7."
                    },
                    {
                        "username": "sushruti",
                        "content": "this is not a medium problem..."
                    }
                ]
            },
            {
                "id": 1806401,
                "content": [
                    {
                        "username": "Blake_Han12",
                        "content": "5.7% ACCEPTANCE RATE. Lowest ever???"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "This should be tagged as HARD!!!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "Finally understood the solution.\\nThis is probably one of the hardest questions I have seen."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Taking me more time to figure out than most of Hard problems, so why it is medium?"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "According even to acceptance - this must be hard problem."
                    },
                    {
                        "username": "aa871788",
                        "content": "Brute force solution returns TLE."
                    },
                    {
                        "username": "dj_khalid",
                        "content": "Can someone please explain why the answer for this testcase is 3 ->\\n[26,6,4,27,6,18]\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`4`, `27`, and `18` are all divisible by squares so they aren't square-free. They're divisible by `4`, `9`, and `9` respectively. So none of the subsets can include those numbers.\n\nThat leaves only `[26,6,6]`. The single element subsets are all square-free: `[26]`,`[6]`, and `[6]`. **That's 3 subsets**.\n\nLet's look at the larger subsets like `[26,6]`, `[6,6]`, and `[26,6,6]`. `26 * 6 = 156` is divisible by `4` so it's not square-free. Similarly `6 * 6 = 36` is divisible by `36` so it's also not square-free. That means all of the other subsets are not square-free."
                    },
                    {
                        "username": "shivansh961",
                        "content": "In Example-1, why  [3,4] is not a square free subarray ?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) Now I understand the question. Thanks for the help !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@Tensor08](/Tensor08) Understood !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  got it, thanks "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "if you make its product, it will become 3*4 = 12, and this set is not square free because 12%4 = 0, where 4 is a perfect square"
                    },
                    {
                        "username": "Tensor08",
                        "content": "[@shivansh961](/shivansh961)  27 can't be included because 27 - 3 * 3 * 3 which include squareOf(3) * 3."
                    },
                    {
                        "username": "ynchsung",
                        "content": "[@shivansh961](/shivansh961)\n- 27, 18 cannot be selected.\n- [26, 6] is not a valid set, either.\n\nThe question means: When you select [a, b, c], you have to multiply them all (a * b * c), and a valid set definition: a * b * c is not divisible by any \"square number\", e.g. 4, 9, 25."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) For this test case : [26,6,4,27,6,18] answer is coming 3 but there are 5 such subsets.\\n[26], [6], [26, 6], [27], [27, 6], [27, 6, 18]. \\n\\nI think I am misunderstanding the questions. Can you spend some time and tell me the mistake ?\\n"
                    },
                    {
                        "username": "ynchsung",
                        "content": "4 itself is a square."
                    },
                    {
                        "username": "ynchsung",
                        "content": "1 is special case.\n\nFor 2, 3, 5, 7, ..., we only can select them once.\nFor example, consider a subset that only contains 2, 3, 5, 7.\nMost people's method will calculate (# of 2) * (# of 3) * (# of 5) * (# of 7),\nwhich is the total # of subsets that only contains \"exact one 2, 3, 5, and 7\" in the array.\n\nHowever, for 1, we can select any # of 1s. The brute force will miss the case for \"selecting more than 1 1s\".\n\nIOW when we're computing \"subsets with 1, 2, 3\", we will do something like (# of 1) * (# of 2) * (# of 3), and add to the ans.\nBut this is incorrect, because 1 can actually be selected more than once.\n\nSaying we have [1, 1, 2, 2, 2, 3, 3, 3, 3], most people's solution will calculate 2 * 3 * 4.\nThis number is # of subset of [1, 2, 3], but you can actually select [1, 1, 2, 3], which is not included in 2 * 3 * 4.\n\nIn fact, there will be (2^(# of 1s))x more subsets.\n\nSo let's modify the brute force algorithm:\n- Remove 1s from the collection\n- Run your original brute force algorithm to calculate # of subsets (which doesn't include 1s). For convenience, let's name it `tmp_ans`.\n- Now, saying we have `N` 1s, then `tmp_ans` subsets can result in `tmp_ans * (2^N)` subsets when combining with 1.\n- Also remember, you can select \"NON-EMPTY subsets with only 1s\", which results in another additional `2^N - 1` subsets.\n- So the final answer is `tmp_ans * (2^N) + (2^N - 1)`. Remember to mod 10^9 + 7."
                    },
                    {
                        "username": "sushruti",
                        "content": "this is not a medium problem..."
                    }
                ]
            },
            {
                "id": 1806868,
                "content": [
                    {
                        "username": "Blake_Han12",
                        "content": "5.7% ACCEPTANCE RATE. Lowest ever???"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "This should be tagged as HARD!!!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "Finally understood the solution.\\nThis is probably one of the hardest questions I have seen."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Taking me more time to figure out than most of Hard problems, so why it is medium?"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "According even to acceptance - this must be hard problem."
                    },
                    {
                        "username": "aa871788",
                        "content": "Brute force solution returns TLE."
                    },
                    {
                        "username": "dj_khalid",
                        "content": "Can someone please explain why the answer for this testcase is 3 ->\\n[26,6,4,27,6,18]\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`4`, `27`, and `18` are all divisible by squares so they aren't square-free. They're divisible by `4`, `9`, and `9` respectively. So none of the subsets can include those numbers.\n\nThat leaves only `[26,6,6]`. The single element subsets are all square-free: `[26]`,`[6]`, and `[6]`. **That's 3 subsets**.\n\nLet's look at the larger subsets like `[26,6]`, `[6,6]`, and `[26,6,6]`. `26 * 6 = 156` is divisible by `4` so it's not square-free. Similarly `6 * 6 = 36` is divisible by `36` so it's also not square-free. That means all of the other subsets are not square-free."
                    },
                    {
                        "username": "shivansh961",
                        "content": "In Example-1, why  [3,4] is not a square free subarray ?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) Now I understand the question. Thanks for the help !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@Tensor08](/Tensor08) Understood !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  got it, thanks "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "if you make its product, it will become 3*4 = 12, and this set is not square free because 12%4 = 0, where 4 is a perfect square"
                    },
                    {
                        "username": "Tensor08",
                        "content": "[@shivansh961](/shivansh961)  27 can't be included because 27 - 3 * 3 * 3 which include squareOf(3) * 3."
                    },
                    {
                        "username": "ynchsung",
                        "content": "[@shivansh961](/shivansh961)\n- 27, 18 cannot be selected.\n- [26, 6] is not a valid set, either.\n\nThe question means: When you select [a, b, c], you have to multiply them all (a * b * c), and a valid set definition: a * b * c is not divisible by any \"square number\", e.g. 4, 9, 25."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) For this test case : [26,6,4,27,6,18] answer is coming 3 but there are 5 such subsets.\\n[26], [6], [26, 6], [27], [27, 6], [27, 6, 18]. \\n\\nI think I am misunderstanding the questions. Can you spend some time and tell me the mistake ?\\n"
                    },
                    {
                        "username": "ynchsung",
                        "content": "4 itself is a square."
                    },
                    {
                        "username": "ynchsung",
                        "content": "1 is special case.\n\nFor 2, 3, 5, 7, ..., we only can select them once.\nFor example, consider a subset that only contains 2, 3, 5, 7.\nMost people's method will calculate (# of 2) * (# of 3) * (# of 5) * (# of 7),\nwhich is the total # of subsets that only contains \"exact one 2, 3, 5, and 7\" in the array.\n\nHowever, for 1, we can select any # of 1s. The brute force will miss the case for \"selecting more than 1 1s\".\n\nIOW when we're computing \"subsets with 1, 2, 3\", we will do something like (# of 1) * (# of 2) * (# of 3), and add to the ans.\nBut this is incorrect, because 1 can actually be selected more than once.\n\nSaying we have [1, 1, 2, 2, 2, 3, 3, 3, 3], most people's solution will calculate 2 * 3 * 4.\nThis number is # of subset of [1, 2, 3], but you can actually select [1, 1, 2, 3], which is not included in 2 * 3 * 4.\n\nIn fact, there will be (2^(# of 1s))x more subsets.\n\nSo let's modify the brute force algorithm:\n- Remove 1s from the collection\n- Run your original brute force algorithm to calculate # of subsets (which doesn't include 1s). For convenience, let's name it `tmp_ans`.\n- Now, saying we have `N` 1s, then `tmp_ans` subsets can result in `tmp_ans * (2^N)` subsets when combining with 1.\n- Also remember, you can select \"NON-EMPTY subsets with only 1s\", which results in another additional `2^N - 1` subsets.\n- So the final answer is `tmp_ans * (2^N) + (2^N - 1)`. Remember to mod 10^9 + 7."
                    },
                    {
                        "username": "sushruti",
                        "content": "this is not a medium problem..."
                    }
                ]
            },
            {
                "id": 1806590,
                "content": [
                    {
                        "username": "Blake_Han12",
                        "content": "5.7% ACCEPTANCE RATE. Lowest ever???"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "This should be tagged as HARD!!!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "Finally understood the solution.\\nThis is probably one of the hardest questions I have seen."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Taking me more time to figure out than most of Hard problems, so why it is medium?"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "According even to acceptance - this must be hard problem."
                    },
                    {
                        "username": "aa871788",
                        "content": "Brute force solution returns TLE."
                    },
                    {
                        "username": "dj_khalid",
                        "content": "Can someone please explain why the answer for this testcase is 3 ->\\n[26,6,4,27,6,18]\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`4`, `27`, and `18` are all divisible by squares so they aren't square-free. They're divisible by `4`, `9`, and `9` respectively. So none of the subsets can include those numbers.\n\nThat leaves only `[26,6,6]`. The single element subsets are all square-free: `[26]`,`[6]`, and `[6]`. **That's 3 subsets**.\n\nLet's look at the larger subsets like `[26,6]`, `[6,6]`, and `[26,6,6]`. `26 * 6 = 156` is divisible by `4` so it's not square-free. Similarly `6 * 6 = 36` is divisible by `36` so it's also not square-free. That means all of the other subsets are not square-free."
                    },
                    {
                        "username": "shivansh961",
                        "content": "In Example-1, why  [3,4] is not a square free subarray ?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) Now I understand the question. Thanks for the help !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@Tensor08](/Tensor08) Understood !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  got it, thanks "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "if you make its product, it will become 3*4 = 12, and this set is not square free because 12%4 = 0, where 4 is a perfect square"
                    },
                    {
                        "username": "Tensor08",
                        "content": "[@shivansh961](/shivansh961)  27 can't be included because 27 - 3 * 3 * 3 which include squareOf(3) * 3."
                    },
                    {
                        "username": "ynchsung",
                        "content": "[@shivansh961](/shivansh961)\n- 27, 18 cannot be selected.\n- [26, 6] is not a valid set, either.\n\nThe question means: When you select [a, b, c], you have to multiply them all (a * b * c), and a valid set definition: a * b * c is not divisible by any \"square number\", e.g. 4, 9, 25."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) For this test case : [26,6,4,27,6,18] answer is coming 3 but there are 5 such subsets.\\n[26], [6], [26, 6], [27], [27, 6], [27, 6, 18]. \\n\\nI think I am misunderstanding the questions. Can you spend some time and tell me the mistake ?\\n"
                    },
                    {
                        "username": "ynchsung",
                        "content": "4 itself is a square."
                    },
                    {
                        "username": "ynchsung",
                        "content": "1 is special case.\n\nFor 2, 3, 5, 7, ..., we only can select them once.\nFor example, consider a subset that only contains 2, 3, 5, 7.\nMost people's method will calculate (# of 2) * (# of 3) * (# of 5) * (# of 7),\nwhich is the total # of subsets that only contains \"exact one 2, 3, 5, and 7\" in the array.\n\nHowever, for 1, we can select any # of 1s. The brute force will miss the case for \"selecting more than 1 1s\".\n\nIOW when we're computing \"subsets with 1, 2, 3\", we will do something like (# of 1) * (# of 2) * (# of 3), and add to the ans.\nBut this is incorrect, because 1 can actually be selected more than once.\n\nSaying we have [1, 1, 2, 2, 2, 3, 3, 3, 3], most people's solution will calculate 2 * 3 * 4.\nThis number is # of subset of [1, 2, 3], but you can actually select [1, 1, 2, 3], which is not included in 2 * 3 * 4.\n\nIn fact, there will be (2^(# of 1s))x more subsets.\n\nSo let's modify the brute force algorithm:\n- Remove 1s from the collection\n- Run your original brute force algorithm to calculate # of subsets (which doesn't include 1s). For convenience, let's name it `tmp_ans`.\n- Now, saying we have `N` 1s, then `tmp_ans` subsets can result in `tmp_ans * (2^N)` subsets when combining with 1.\n- Also remember, you can select \"NON-EMPTY subsets with only 1s\", which results in another additional `2^N - 1` subsets.\n- So the final answer is `tmp_ans * (2^N) + (2^N - 1)`. Remember to mod 10^9 + 7."
                    },
                    {
                        "username": "sushruti",
                        "content": "this is not a medium problem..."
                    }
                ]
            },
            {
                "id": 1806589,
                "content": [
                    {
                        "username": "Blake_Han12",
                        "content": "5.7% ACCEPTANCE RATE. Lowest ever???"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "This should be tagged as HARD!!!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "Finally understood the solution.\\nThis is probably one of the hardest questions I have seen."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Taking me more time to figure out than most of Hard problems, so why it is medium?"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "According even to acceptance - this must be hard problem."
                    },
                    {
                        "username": "aa871788",
                        "content": "Brute force solution returns TLE."
                    },
                    {
                        "username": "dj_khalid",
                        "content": "Can someone please explain why the answer for this testcase is 3 ->\\n[26,6,4,27,6,18]\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`4`, `27`, and `18` are all divisible by squares so they aren't square-free. They're divisible by `4`, `9`, and `9` respectively. So none of the subsets can include those numbers.\n\nThat leaves only `[26,6,6]`. The single element subsets are all square-free: `[26]`,`[6]`, and `[6]`. **That's 3 subsets**.\n\nLet's look at the larger subsets like `[26,6]`, `[6,6]`, and `[26,6,6]`. `26 * 6 = 156` is divisible by `4` so it's not square-free. Similarly `6 * 6 = 36` is divisible by `36` so it's also not square-free. That means all of the other subsets are not square-free."
                    },
                    {
                        "username": "shivansh961",
                        "content": "In Example-1, why  [3,4] is not a square free subarray ?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) Now I understand the question. Thanks for the help !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@Tensor08](/Tensor08) Understood !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  got it, thanks "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "if you make its product, it will become 3*4 = 12, and this set is not square free because 12%4 = 0, where 4 is a perfect square"
                    },
                    {
                        "username": "Tensor08",
                        "content": "[@shivansh961](/shivansh961)  27 can't be included because 27 - 3 * 3 * 3 which include squareOf(3) * 3."
                    },
                    {
                        "username": "ynchsung",
                        "content": "[@shivansh961](/shivansh961)\n- 27, 18 cannot be selected.\n- [26, 6] is not a valid set, either.\n\nThe question means: When you select [a, b, c], you have to multiply them all (a * b * c), and a valid set definition: a * b * c is not divisible by any \"square number\", e.g. 4, 9, 25."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) For this test case : [26,6,4,27,6,18] answer is coming 3 but there are 5 such subsets.\\n[26], [6], [26, 6], [27], [27, 6], [27, 6, 18]. \\n\\nI think I am misunderstanding the questions. Can you spend some time and tell me the mistake ?\\n"
                    },
                    {
                        "username": "ynchsung",
                        "content": "4 itself is a square."
                    },
                    {
                        "username": "ynchsung",
                        "content": "1 is special case.\n\nFor 2, 3, 5, 7, ..., we only can select them once.\nFor example, consider a subset that only contains 2, 3, 5, 7.\nMost people's method will calculate (# of 2) * (# of 3) * (# of 5) * (# of 7),\nwhich is the total # of subsets that only contains \"exact one 2, 3, 5, and 7\" in the array.\n\nHowever, for 1, we can select any # of 1s. The brute force will miss the case for \"selecting more than 1 1s\".\n\nIOW when we're computing \"subsets with 1, 2, 3\", we will do something like (# of 1) * (# of 2) * (# of 3), and add to the ans.\nBut this is incorrect, because 1 can actually be selected more than once.\n\nSaying we have [1, 1, 2, 2, 2, 3, 3, 3, 3], most people's solution will calculate 2 * 3 * 4.\nThis number is # of subset of [1, 2, 3], but you can actually select [1, 1, 2, 3], which is not included in 2 * 3 * 4.\n\nIn fact, there will be (2^(# of 1s))x more subsets.\n\nSo let's modify the brute force algorithm:\n- Remove 1s from the collection\n- Run your original brute force algorithm to calculate # of subsets (which doesn't include 1s). For convenience, let's name it `tmp_ans`.\n- Now, saying we have `N` 1s, then `tmp_ans` subsets can result in `tmp_ans * (2^N)` subsets when combining with 1.\n- Also remember, you can select \"NON-EMPTY subsets with only 1s\", which results in another additional `2^N - 1` subsets.\n- So the final answer is `tmp_ans * (2^N) + (2^N - 1)`. Remember to mod 10^9 + 7."
                    },
                    {
                        "username": "sushruti",
                        "content": "this is not a medium problem..."
                    }
                ]
            },
            {
                "id": 2066400,
                "content": [
                    {
                        "username": "Blake_Han12",
                        "content": "5.7% ACCEPTANCE RATE. Lowest ever???"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "This should be tagged as HARD!!!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "Finally understood the solution.\\nThis is probably one of the hardest questions I have seen."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Taking me more time to figure out than most of Hard problems, so why it is medium?"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "According even to acceptance - this must be hard problem."
                    },
                    {
                        "username": "aa871788",
                        "content": "Brute force solution returns TLE."
                    },
                    {
                        "username": "dj_khalid",
                        "content": "Can someone please explain why the answer for this testcase is 3 ->\\n[26,6,4,27,6,18]\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`4`, `27`, and `18` are all divisible by squares so they aren't square-free. They're divisible by `4`, `9`, and `9` respectively. So none of the subsets can include those numbers.\n\nThat leaves only `[26,6,6]`. The single element subsets are all square-free: `[26]`,`[6]`, and `[6]`. **That's 3 subsets**.\n\nLet's look at the larger subsets like `[26,6]`, `[6,6]`, and `[26,6,6]`. `26 * 6 = 156` is divisible by `4` so it's not square-free. Similarly `6 * 6 = 36` is divisible by `36` so it's also not square-free. That means all of the other subsets are not square-free."
                    },
                    {
                        "username": "shivansh961",
                        "content": "In Example-1, why  [3,4] is not a square free subarray ?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) Now I understand the question. Thanks for the help !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@Tensor08](/Tensor08) Understood !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  got it, thanks "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "if you make its product, it will become 3*4 = 12, and this set is not square free because 12%4 = 0, where 4 is a perfect square"
                    },
                    {
                        "username": "Tensor08",
                        "content": "[@shivansh961](/shivansh961)  27 can't be included because 27 - 3 * 3 * 3 which include squareOf(3) * 3."
                    },
                    {
                        "username": "ynchsung",
                        "content": "[@shivansh961](/shivansh961)\n- 27, 18 cannot be selected.\n- [26, 6] is not a valid set, either.\n\nThe question means: When you select [a, b, c], you have to multiply them all (a * b * c), and a valid set definition: a * b * c is not divisible by any \"square number\", e.g. 4, 9, 25."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) For this test case : [26,6,4,27,6,18] answer is coming 3 but there are 5 such subsets.\\n[26], [6], [26, 6], [27], [27, 6], [27, 6, 18]. \\n\\nI think I am misunderstanding the questions. Can you spend some time and tell me the mistake ?\\n"
                    },
                    {
                        "username": "ynchsung",
                        "content": "4 itself is a square."
                    },
                    {
                        "username": "ynchsung",
                        "content": "1 is special case.\n\nFor 2, 3, 5, 7, ..., we only can select them once.\nFor example, consider a subset that only contains 2, 3, 5, 7.\nMost people's method will calculate (# of 2) * (# of 3) * (# of 5) * (# of 7),\nwhich is the total # of subsets that only contains \"exact one 2, 3, 5, and 7\" in the array.\n\nHowever, for 1, we can select any # of 1s. The brute force will miss the case for \"selecting more than 1 1s\".\n\nIOW when we're computing \"subsets with 1, 2, 3\", we will do something like (# of 1) * (# of 2) * (# of 3), and add to the ans.\nBut this is incorrect, because 1 can actually be selected more than once.\n\nSaying we have [1, 1, 2, 2, 2, 3, 3, 3, 3], most people's solution will calculate 2 * 3 * 4.\nThis number is # of subset of [1, 2, 3], but you can actually select [1, 1, 2, 3], which is not included in 2 * 3 * 4.\n\nIn fact, there will be (2^(# of 1s))x more subsets.\n\nSo let's modify the brute force algorithm:\n- Remove 1s from the collection\n- Run your original brute force algorithm to calculate # of subsets (which doesn't include 1s). For convenience, let's name it `tmp_ans`.\n- Now, saying we have `N` 1s, then `tmp_ans` subsets can result in `tmp_ans * (2^N)` subsets when combining with 1.\n- Also remember, you can select \"NON-EMPTY subsets with only 1s\", which results in another additional `2^N - 1` subsets.\n- So the final answer is `tmp_ans * (2^N) + (2^N - 1)`. Remember to mod 10^9 + 7."
                    },
                    {
                        "username": "sushruti",
                        "content": "this is not a medium problem..."
                    }
                ]
            },
            {
                "id": 1806414,
                "content": [
                    {
                        "username": "Blake_Han12",
                        "content": "5.7% ACCEPTANCE RATE. Lowest ever???"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "This should be tagged as HARD!!!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "Finally understood the solution.\\nThis is probably one of the hardest questions I have seen."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Taking me more time to figure out than most of Hard problems, so why it is medium?"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "According even to acceptance - this must be hard problem."
                    },
                    {
                        "username": "aa871788",
                        "content": "Brute force solution returns TLE."
                    },
                    {
                        "username": "dj_khalid",
                        "content": "Can someone please explain why the answer for this testcase is 3 ->\\n[26,6,4,27,6,18]\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`4`, `27`, and `18` are all divisible by squares so they aren't square-free. They're divisible by `4`, `9`, and `9` respectively. So none of the subsets can include those numbers.\n\nThat leaves only `[26,6,6]`. The single element subsets are all square-free: `[26]`,`[6]`, and `[6]`. **That's 3 subsets**.\n\nLet's look at the larger subsets like `[26,6]`, `[6,6]`, and `[26,6,6]`. `26 * 6 = 156` is divisible by `4` so it's not square-free. Similarly `6 * 6 = 36` is divisible by `36` so it's also not square-free. That means all of the other subsets are not square-free."
                    },
                    {
                        "username": "shivansh961",
                        "content": "In Example-1, why  [3,4] is not a square free subarray ?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) Now I understand the question. Thanks for the help !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@Tensor08](/Tensor08) Understood !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  got it, thanks "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "if you make its product, it will become 3*4 = 12, and this set is not square free because 12%4 = 0, where 4 is a perfect square"
                    },
                    {
                        "username": "Tensor08",
                        "content": "[@shivansh961](/shivansh961)  27 can't be included because 27 - 3 * 3 * 3 which include squareOf(3) * 3."
                    },
                    {
                        "username": "ynchsung",
                        "content": "[@shivansh961](/shivansh961)\n- 27, 18 cannot be selected.\n- [26, 6] is not a valid set, either.\n\nThe question means: When you select [a, b, c], you have to multiply them all (a * b * c), and a valid set definition: a * b * c is not divisible by any \"square number\", e.g. 4, 9, 25."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) For this test case : [26,6,4,27,6,18] answer is coming 3 but there are 5 such subsets.\\n[26], [6], [26, 6], [27], [27, 6], [27, 6, 18]. \\n\\nI think I am misunderstanding the questions. Can you spend some time and tell me the mistake ?\\n"
                    },
                    {
                        "username": "ynchsung",
                        "content": "4 itself is a square."
                    },
                    {
                        "username": "ynchsung",
                        "content": "1 is special case.\n\nFor 2, 3, 5, 7, ..., we only can select them once.\nFor example, consider a subset that only contains 2, 3, 5, 7.\nMost people's method will calculate (# of 2) * (# of 3) * (# of 5) * (# of 7),\nwhich is the total # of subsets that only contains \"exact one 2, 3, 5, and 7\" in the array.\n\nHowever, for 1, we can select any # of 1s. The brute force will miss the case for \"selecting more than 1 1s\".\n\nIOW when we're computing \"subsets with 1, 2, 3\", we will do something like (# of 1) * (# of 2) * (# of 3), and add to the ans.\nBut this is incorrect, because 1 can actually be selected more than once.\n\nSaying we have [1, 1, 2, 2, 2, 3, 3, 3, 3], most people's solution will calculate 2 * 3 * 4.\nThis number is # of subset of [1, 2, 3], but you can actually select [1, 1, 2, 3], which is not included in 2 * 3 * 4.\n\nIn fact, there will be (2^(# of 1s))x more subsets.\n\nSo let's modify the brute force algorithm:\n- Remove 1s from the collection\n- Run your original brute force algorithm to calculate # of subsets (which doesn't include 1s). For convenience, let's name it `tmp_ans`.\n- Now, saying we have `N` 1s, then `tmp_ans` subsets can result in `tmp_ans * (2^N)` subsets when combining with 1.\n- Also remember, you can select \"NON-EMPTY subsets with only 1s\", which results in another additional `2^N - 1` subsets.\n- So the final answer is `tmp_ans * (2^N) + (2^N - 1)`. Remember to mod 10^9 + 7."
                    },
                    {
                        "username": "sushruti",
                        "content": "this is not a medium problem..."
                    }
                ]
            },
            {
                "id": 1807385,
                "content": [
                    {
                        "username": "Blake_Han12",
                        "content": "5.7% ACCEPTANCE RATE. Lowest ever???"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "This should be tagged as HARD!!!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "Finally understood the solution.\\nThis is probably one of the hardest questions I have seen."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Taking me more time to figure out than most of Hard problems, so why it is medium?"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "According even to acceptance - this must be hard problem."
                    },
                    {
                        "username": "aa871788",
                        "content": "Brute force solution returns TLE."
                    },
                    {
                        "username": "dj_khalid",
                        "content": "Can someone please explain why the answer for this testcase is 3 ->\\n[26,6,4,27,6,18]\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`4`, `27`, and `18` are all divisible by squares so they aren't square-free. They're divisible by `4`, `9`, and `9` respectively. So none of the subsets can include those numbers.\n\nThat leaves only `[26,6,6]`. The single element subsets are all square-free: `[26]`,`[6]`, and `[6]`. **That's 3 subsets**.\n\nLet's look at the larger subsets like `[26,6]`, `[6,6]`, and `[26,6,6]`. `26 * 6 = 156` is divisible by `4` so it's not square-free. Similarly `6 * 6 = 36` is divisible by `36` so it's also not square-free. That means all of the other subsets are not square-free."
                    },
                    {
                        "username": "shivansh961",
                        "content": "In Example-1, why  [3,4] is not a square free subarray ?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) Now I understand the question. Thanks for the help !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@Tensor08](/Tensor08) Understood !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  got it, thanks "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "if you make its product, it will become 3*4 = 12, and this set is not square free because 12%4 = 0, where 4 is a perfect square"
                    },
                    {
                        "username": "Tensor08",
                        "content": "[@shivansh961](/shivansh961)  27 can't be included because 27 - 3 * 3 * 3 which include squareOf(3) * 3."
                    },
                    {
                        "username": "ynchsung",
                        "content": "[@shivansh961](/shivansh961)\n- 27, 18 cannot be selected.\n- [26, 6] is not a valid set, either.\n\nThe question means: When you select [a, b, c], you have to multiply them all (a * b * c), and a valid set definition: a * b * c is not divisible by any \"square number\", e.g. 4, 9, 25."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) For this test case : [26,6,4,27,6,18] answer is coming 3 but there are 5 such subsets.\\n[26], [6], [26, 6], [27], [27, 6], [27, 6, 18]. \\n\\nI think I am misunderstanding the questions. Can you spend some time and tell me the mistake ?\\n"
                    },
                    {
                        "username": "ynchsung",
                        "content": "4 itself is a square."
                    },
                    {
                        "username": "ynchsung",
                        "content": "1 is special case.\n\nFor 2, 3, 5, 7, ..., we only can select them once.\nFor example, consider a subset that only contains 2, 3, 5, 7.\nMost people's method will calculate (# of 2) * (# of 3) * (# of 5) * (# of 7),\nwhich is the total # of subsets that only contains \"exact one 2, 3, 5, and 7\" in the array.\n\nHowever, for 1, we can select any # of 1s. The brute force will miss the case for \"selecting more than 1 1s\".\n\nIOW when we're computing \"subsets with 1, 2, 3\", we will do something like (# of 1) * (# of 2) * (# of 3), and add to the ans.\nBut this is incorrect, because 1 can actually be selected more than once.\n\nSaying we have [1, 1, 2, 2, 2, 3, 3, 3, 3], most people's solution will calculate 2 * 3 * 4.\nThis number is # of subset of [1, 2, 3], but you can actually select [1, 1, 2, 3], which is not included in 2 * 3 * 4.\n\nIn fact, there will be (2^(# of 1s))x more subsets.\n\nSo let's modify the brute force algorithm:\n- Remove 1s from the collection\n- Run your original brute force algorithm to calculate # of subsets (which doesn't include 1s). For convenience, let's name it `tmp_ans`.\n- Now, saying we have `N` 1s, then `tmp_ans` subsets can result in `tmp_ans * (2^N)` subsets when combining with 1.\n- Also remember, you can select \"NON-EMPTY subsets with only 1s\", which results in another additional `2^N - 1` subsets.\n- So the final answer is `tmp_ans * (2^N) + (2^N - 1)`. Remember to mod 10^9 + 7."
                    },
                    {
                        "username": "sushruti",
                        "content": "this is not a medium problem..."
                    }
                ]
            },
            {
                "id": 1809659,
                "content": [
                    {
                        "username": "Blake_Han12",
                        "content": "5.7% ACCEPTANCE RATE. Lowest ever???"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "This should be tagged as HARD!!!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "Finally understood the solution.\\nThis is probably one of the hardest questions I have seen."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Taking me more time to figure out than most of Hard problems, so why it is medium?"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "According even to acceptance - this must be hard problem."
                    },
                    {
                        "username": "aa871788",
                        "content": "Brute force solution returns TLE."
                    },
                    {
                        "username": "dj_khalid",
                        "content": "Can someone please explain why the answer for this testcase is 3 ->\\n[26,6,4,27,6,18]\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`4`, `27`, and `18` are all divisible by squares so they aren't square-free. They're divisible by `4`, `9`, and `9` respectively. So none of the subsets can include those numbers.\n\nThat leaves only `[26,6,6]`. The single element subsets are all square-free: `[26]`,`[6]`, and `[6]`. **That's 3 subsets**.\n\nLet's look at the larger subsets like `[26,6]`, `[6,6]`, and `[26,6,6]`. `26 * 6 = 156` is divisible by `4` so it's not square-free. Similarly `6 * 6 = 36` is divisible by `36` so it's also not square-free. That means all of the other subsets are not square-free."
                    },
                    {
                        "username": "shivansh961",
                        "content": "In Example-1, why  [3,4] is not a square free subarray ?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) Now I understand the question. Thanks for the help !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@Tensor08](/Tensor08) Understood !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  got it, thanks "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "if you make its product, it will become 3*4 = 12, and this set is not square free because 12%4 = 0, where 4 is a perfect square"
                    },
                    {
                        "username": "Tensor08",
                        "content": "[@shivansh961](/shivansh961)  27 can't be included because 27 - 3 * 3 * 3 which include squareOf(3) * 3."
                    },
                    {
                        "username": "ynchsung",
                        "content": "[@shivansh961](/shivansh961)\n- 27, 18 cannot be selected.\n- [26, 6] is not a valid set, either.\n\nThe question means: When you select [a, b, c], you have to multiply them all (a * b * c), and a valid set definition: a * b * c is not divisible by any \"square number\", e.g. 4, 9, 25."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) For this test case : [26,6,4,27,6,18] answer is coming 3 but there are 5 such subsets.\\n[26], [6], [26, 6], [27], [27, 6], [27, 6, 18]. \\n\\nI think I am misunderstanding the questions. Can you spend some time and tell me the mistake ?\\n"
                    },
                    {
                        "username": "ynchsung",
                        "content": "4 itself is a square."
                    },
                    {
                        "username": "ynchsung",
                        "content": "1 is special case.\n\nFor 2, 3, 5, 7, ..., we only can select them once.\nFor example, consider a subset that only contains 2, 3, 5, 7.\nMost people's method will calculate (# of 2) * (# of 3) * (# of 5) * (# of 7),\nwhich is the total # of subsets that only contains \"exact one 2, 3, 5, and 7\" in the array.\n\nHowever, for 1, we can select any # of 1s. The brute force will miss the case for \"selecting more than 1 1s\".\n\nIOW when we're computing \"subsets with 1, 2, 3\", we will do something like (# of 1) * (# of 2) * (# of 3), and add to the ans.\nBut this is incorrect, because 1 can actually be selected more than once.\n\nSaying we have [1, 1, 2, 2, 2, 3, 3, 3, 3], most people's solution will calculate 2 * 3 * 4.\nThis number is # of subset of [1, 2, 3], but you can actually select [1, 1, 2, 3], which is not included in 2 * 3 * 4.\n\nIn fact, there will be (2^(# of 1s))x more subsets.\n\nSo let's modify the brute force algorithm:\n- Remove 1s from the collection\n- Run your original brute force algorithm to calculate # of subsets (which doesn't include 1s). For convenience, let's name it `tmp_ans`.\n- Now, saying we have `N` 1s, then `tmp_ans` subsets can result in `tmp_ans * (2^N)` subsets when combining with 1.\n- Also remember, you can select \"NON-EMPTY subsets with only 1s\", which results in another additional `2^N - 1` subsets.\n- So the final answer is `tmp_ans * (2^N) + (2^N - 1)`. Remember to mod 10^9 + 7."
                    },
                    {
                        "username": "sushruti",
                        "content": "this is not a medium problem..."
                    }
                ]
            },
            {
                "id": 1807480,
                "content": [
                    {
                        "username": "Blake_Han12",
                        "content": "5.7% ACCEPTANCE RATE. Lowest ever???"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "This should be tagged as HARD!!!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "Finally understood the solution.\\nThis is probably one of the hardest questions I have seen."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Taking me more time to figure out than most of Hard problems, so why it is medium?"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "According even to acceptance - this must be hard problem."
                    },
                    {
                        "username": "aa871788",
                        "content": "Brute force solution returns TLE."
                    },
                    {
                        "username": "dj_khalid",
                        "content": "Can someone please explain why the answer for this testcase is 3 ->\\n[26,6,4,27,6,18]\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`4`, `27`, and `18` are all divisible by squares so they aren't square-free. They're divisible by `4`, `9`, and `9` respectively. So none of the subsets can include those numbers.\n\nThat leaves only `[26,6,6]`. The single element subsets are all square-free: `[26]`,`[6]`, and `[6]`. **That's 3 subsets**.\n\nLet's look at the larger subsets like `[26,6]`, `[6,6]`, and `[26,6,6]`. `26 * 6 = 156` is divisible by `4` so it's not square-free. Similarly `6 * 6 = 36` is divisible by `36` so it's also not square-free. That means all of the other subsets are not square-free."
                    },
                    {
                        "username": "shivansh961",
                        "content": "In Example-1, why  [3,4] is not a square free subarray ?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) Now I understand the question. Thanks for the help !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@Tensor08](/Tensor08) Understood !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  got it, thanks "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "if you make its product, it will become 3*4 = 12, and this set is not square free because 12%4 = 0, where 4 is a perfect square"
                    },
                    {
                        "username": "Tensor08",
                        "content": "[@shivansh961](/shivansh961)  27 can't be included because 27 - 3 * 3 * 3 which include squareOf(3) * 3."
                    },
                    {
                        "username": "ynchsung",
                        "content": "[@shivansh961](/shivansh961)\n- 27, 18 cannot be selected.\n- [26, 6] is not a valid set, either.\n\nThe question means: When you select [a, b, c], you have to multiply them all (a * b * c), and a valid set definition: a * b * c is not divisible by any \"square number\", e.g. 4, 9, 25."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) For this test case : [26,6,4,27,6,18] answer is coming 3 but there are 5 such subsets.\\n[26], [6], [26, 6], [27], [27, 6], [27, 6, 18]. \\n\\nI think I am misunderstanding the questions. Can you spend some time and tell me the mistake ?\\n"
                    },
                    {
                        "username": "ynchsung",
                        "content": "4 itself is a square."
                    },
                    {
                        "username": "ynchsung",
                        "content": "1 is special case.\n\nFor 2, 3, 5, 7, ..., we only can select them once.\nFor example, consider a subset that only contains 2, 3, 5, 7.\nMost people's method will calculate (# of 2) * (# of 3) * (# of 5) * (# of 7),\nwhich is the total # of subsets that only contains \"exact one 2, 3, 5, and 7\" in the array.\n\nHowever, for 1, we can select any # of 1s. The brute force will miss the case for \"selecting more than 1 1s\".\n\nIOW when we're computing \"subsets with 1, 2, 3\", we will do something like (# of 1) * (# of 2) * (# of 3), and add to the ans.\nBut this is incorrect, because 1 can actually be selected more than once.\n\nSaying we have [1, 1, 2, 2, 2, 3, 3, 3, 3], most people's solution will calculate 2 * 3 * 4.\nThis number is # of subset of [1, 2, 3], but you can actually select [1, 1, 2, 3], which is not included in 2 * 3 * 4.\n\nIn fact, there will be (2^(# of 1s))x more subsets.\n\nSo let's modify the brute force algorithm:\n- Remove 1s from the collection\n- Run your original brute force algorithm to calculate # of subsets (which doesn't include 1s). For convenience, let's name it `tmp_ans`.\n- Now, saying we have `N` 1s, then `tmp_ans` subsets can result in `tmp_ans * (2^N)` subsets when combining with 1.\n- Also remember, you can select \"NON-EMPTY subsets with only 1s\", which results in another additional `2^N - 1` subsets.\n- So the final answer is `tmp_ans * (2^N) + (2^N - 1)`. Remember to mod 10^9 + 7."
                    },
                    {
                        "username": "sushruti",
                        "content": "this is not a medium problem..."
                    }
                ]
            },
            {
                "id": 1807369,
                "content": [
                    {
                        "username": "Blake_Han12",
                        "content": "5.7% ACCEPTANCE RATE. Lowest ever???"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "This should be tagged as HARD!!!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "Finally understood the solution.\\nThis is probably one of the hardest questions I have seen."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Taking me more time to figure out than most of Hard problems, so why it is medium?"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "According even to acceptance - this must be hard problem."
                    },
                    {
                        "username": "aa871788",
                        "content": "Brute force solution returns TLE."
                    },
                    {
                        "username": "dj_khalid",
                        "content": "Can someone please explain why the answer for this testcase is 3 ->\\n[26,6,4,27,6,18]\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`4`, `27`, and `18` are all divisible by squares so they aren't square-free. They're divisible by `4`, `9`, and `9` respectively. So none of the subsets can include those numbers.\n\nThat leaves only `[26,6,6]`. The single element subsets are all square-free: `[26]`,`[6]`, and `[6]`. **That's 3 subsets**.\n\nLet's look at the larger subsets like `[26,6]`, `[6,6]`, and `[26,6,6]`. `26 * 6 = 156` is divisible by `4` so it's not square-free. Similarly `6 * 6 = 36` is divisible by `36` so it's also not square-free. That means all of the other subsets are not square-free."
                    },
                    {
                        "username": "shivansh961",
                        "content": "In Example-1, why  [3,4] is not a square free subarray ?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) Now I understand the question. Thanks for the help !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@Tensor08](/Tensor08) Understood !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  got it, thanks "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "if you make its product, it will become 3*4 = 12, and this set is not square free because 12%4 = 0, where 4 is a perfect square"
                    },
                    {
                        "username": "Tensor08",
                        "content": "[@shivansh961](/shivansh961)  27 can't be included because 27 - 3 * 3 * 3 which include squareOf(3) * 3."
                    },
                    {
                        "username": "ynchsung",
                        "content": "[@shivansh961](/shivansh961)\n- 27, 18 cannot be selected.\n- [26, 6] is not a valid set, either.\n\nThe question means: When you select [a, b, c], you have to multiply them all (a * b * c), and a valid set definition: a * b * c is not divisible by any \"square number\", e.g. 4, 9, 25."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) For this test case : [26,6,4,27,6,18] answer is coming 3 but there are 5 such subsets.\\n[26], [6], [26, 6], [27], [27, 6], [27, 6, 18]. \\n\\nI think I am misunderstanding the questions. Can you spend some time and tell me the mistake ?\\n"
                    },
                    {
                        "username": "ynchsung",
                        "content": "4 itself is a square."
                    },
                    {
                        "username": "ynchsung",
                        "content": "1 is special case.\n\nFor 2, 3, 5, 7, ..., we only can select them once.\nFor example, consider a subset that only contains 2, 3, 5, 7.\nMost people's method will calculate (# of 2) * (# of 3) * (# of 5) * (# of 7),\nwhich is the total # of subsets that only contains \"exact one 2, 3, 5, and 7\" in the array.\n\nHowever, for 1, we can select any # of 1s. The brute force will miss the case for \"selecting more than 1 1s\".\n\nIOW when we're computing \"subsets with 1, 2, 3\", we will do something like (# of 1) * (# of 2) * (# of 3), and add to the ans.\nBut this is incorrect, because 1 can actually be selected more than once.\n\nSaying we have [1, 1, 2, 2, 2, 3, 3, 3, 3], most people's solution will calculate 2 * 3 * 4.\nThis number is # of subset of [1, 2, 3], but you can actually select [1, 1, 2, 3], which is not included in 2 * 3 * 4.\n\nIn fact, there will be (2^(# of 1s))x more subsets.\n\nSo let's modify the brute force algorithm:\n- Remove 1s from the collection\n- Run your original brute force algorithm to calculate # of subsets (which doesn't include 1s). For convenience, let's name it `tmp_ans`.\n- Now, saying we have `N` 1s, then `tmp_ans` subsets can result in `tmp_ans * (2^N)` subsets when combining with 1.\n- Also remember, you can select \"NON-EMPTY subsets with only 1s\", which results in another additional `2^N - 1` subsets.\n- So the final answer is `tmp_ans * (2^N) + (2^N - 1)`. Remember to mod 10^9 + 7."
                    },
                    {
                        "username": "sushruti",
                        "content": "this is not a medium problem..."
                    }
                ]
            },
            {
                "id": 1806401,
                "content": [
                    {
                        "username": "Blake_Han12",
                        "content": "5.7% ACCEPTANCE RATE. Lowest ever???"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "This should be tagged as HARD!!!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "Finally understood the solution.\\nThis is probably one of the hardest questions I have seen."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Taking me more time to figure out than most of Hard problems, so why it is medium?"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "According even to acceptance - this must be hard problem."
                    },
                    {
                        "username": "aa871788",
                        "content": "Brute force solution returns TLE."
                    },
                    {
                        "username": "dj_khalid",
                        "content": "Can someone please explain why the answer for this testcase is 3 ->\\n[26,6,4,27,6,18]\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`4`, `27`, and `18` are all divisible by squares so they aren't square-free. They're divisible by `4`, `9`, and `9` respectively. So none of the subsets can include those numbers.\n\nThat leaves only `[26,6,6]`. The single element subsets are all square-free: `[26]`,`[6]`, and `[6]`. **That's 3 subsets**.\n\nLet's look at the larger subsets like `[26,6]`, `[6,6]`, and `[26,6,6]`. `26 * 6 = 156` is divisible by `4` so it's not square-free. Similarly `6 * 6 = 36` is divisible by `36` so it's also not square-free. That means all of the other subsets are not square-free."
                    },
                    {
                        "username": "shivansh961",
                        "content": "In Example-1, why  [3,4] is not a square free subarray ?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) Now I understand the question. Thanks for the help !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@Tensor08](/Tensor08) Understood !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  got it, thanks "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "if you make its product, it will become 3*4 = 12, and this set is not square free because 12%4 = 0, where 4 is a perfect square"
                    },
                    {
                        "username": "Tensor08",
                        "content": "[@shivansh961](/shivansh961)  27 can't be included because 27 - 3 * 3 * 3 which include squareOf(3) * 3."
                    },
                    {
                        "username": "ynchsung",
                        "content": "[@shivansh961](/shivansh961)\n- 27, 18 cannot be selected.\n- [26, 6] is not a valid set, either.\n\nThe question means: When you select [a, b, c], you have to multiply them all (a * b * c), and a valid set definition: a * b * c is not divisible by any \"square number\", e.g. 4, 9, 25."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) For this test case : [26,6,4,27,6,18] answer is coming 3 but there are 5 such subsets.\\n[26], [6], [26, 6], [27], [27, 6], [27, 6, 18]. \\n\\nI think I am misunderstanding the questions. Can you spend some time and tell me the mistake ?\\n"
                    },
                    {
                        "username": "ynchsung",
                        "content": "4 itself is a square."
                    },
                    {
                        "username": "ynchsung",
                        "content": "1 is special case.\n\nFor 2, 3, 5, 7, ..., we only can select them once.\nFor example, consider a subset that only contains 2, 3, 5, 7.\nMost people's method will calculate (# of 2) * (# of 3) * (# of 5) * (# of 7),\nwhich is the total # of subsets that only contains \"exact one 2, 3, 5, and 7\" in the array.\n\nHowever, for 1, we can select any # of 1s. The brute force will miss the case for \"selecting more than 1 1s\".\n\nIOW when we're computing \"subsets with 1, 2, 3\", we will do something like (# of 1) * (# of 2) * (# of 3), and add to the ans.\nBut this is incorrect, because 1 can actually be selected more than once.\n\nSaying we have [1, 1, 2, 2, 2, 3, 3, 3, 3], most people's solution will calculate 2 * 3 * 4.\nThis number is # of subset of [1, 2, 3], but you can actually select [1, 1, 2, 3], which is not included in 2 * 3 * 4.\n\nIn fact, there will be (2^(# of 1s))x more subsets.\n\nSo let's modify the brute force algorithm:\n- Remove 1s from the collection\n- Run your original brute force algorithm to calculate # of subsets (which doesn't include 1s). For convenience, let's name it `tmp_ans`.\n- Now, saying we have `N` 1s, then `tmp_ans` subsets can result in `tmp_ans * (2^N)` subsets when combining with 1.\n- Also remember, you can select \"NON-EMPTY subsets with only 1s\", which results in another additional `2^N - 1` subsets.\n- So the final answer is `tmp_ans * (2^N) + (2^N - 1)`. Remember to mod 10^9 + 7."
                    },
                    {
                        "username": "sushruti",
                        "content": "this is not a medium problem..."
                    }
                ]
            },
            {
                "id": 1806868,
                "content": [
                    {
                        "username": "Blake_Han12",
                        "content": "5.7% ACCEPTANCE RATE. Lowest ever???"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "This should be tagged as HARD!!!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "Finally understood the solution.\\nThis is probably one of the hardest questions I have seen."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Taking me more time to figure out than most of Hard problems, so why it is medium?"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "According even to acceptance - this must be hard problem."
                    },
                    {
                        "username": "aa871788",
                        "content": "Brute force solution returns TLE."
                    },
                    {
                        "username": "dj_khalid",
                        "content": "Can someone please explain why the answer for this testcase is 3 ->\\n[26,6,4,27,6,18]\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`4`, `27`, and `18` are all divisible by squares so they aren't square-free. They're divisible by `4`, `9`, and `9` respectively. So none of the subsets can include those numbers.\n\nThat leaves only `[26,6,6]`. The single element subsets are all square-free: `[26]`,`[6]`, and `[6]`. **That's 3 subsets**.\n\nLet's look at the larger subsets like `[26,6]`, `[6,6]`, and `[26,6,6]`. `26 * 6 = 156` is divisible by `4` so it's not square-free. Similarly `6 * 6 = 36` is divisible by `36` so it's also not square-free. That means all of the other subsets are not square-free."
                    },
                    {
                        "username": "shivansh961",
                        "content": "In Example-1, why  [3,4] is not a square free subarray ?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) Now I understand the question. Thanks for the help !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@Tensor08](/Tensor08) Understood !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  got it, thanks "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "if you make its product, it will become 3*4 = 12, and this set is not square free because 12%4 = 0, where 4 is a perfect square"
                    },
                    {
                        "username": "Tensor08",
                        "content": "[@shivansh961](/shivansh961)  27 can't be included because 27 - 3 * 3 * 3 which include squareOf(3) * 3."
                    },
                    {
                        "username": "ynchsung",
                        "content": "[@shivansh961](/shivansh961)\n- 27, 18 cannot be selected.\n- [26, 6] is not a valid set, either.\n\nThe question means: When you select [a, b, c], you have to multiply them all (a * b * c), and a valid set definition: a * b * c is not divisible by any \"square number\", e.g. 4, 9, 25."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) For this test case : [26,6,4,27,6,18] answer is coming 3 but there are 5 such subsets.\\n[26], [6], [26, 6], [27], [27, 6], [27, 6, 18]. \\n\\nI think I am misunderstanding the questions. Can you spend some time and tell me the mistake ?\\n"
                    },
                    {
                        "username": "ynchsung",
                        "content": "4 itself is a square."
                    },
                    {
                        "username": "ynchsung",
                        "content": "1 is special case.\n\nFor 2, 3, 5, 7, ..., we only can select them once.\nFor example, consider a subset that only contains 2, 3, 5, 7.\nMost people's method will calculate (# of 2) * (# of 3) * (# of 5) * (# of 7),\nwhich is the total # of subsets that only contains \"exact one 2, 3, 5, and 7\" in the array.\n\nHowever, for 1, we can select any # of 1s. The brute force will miss the case for \"selecting more than 1 1s\".\n\nIOW when we're computing \"subsets with 1, 2, 3\", we will do something like (# of 1) * (# of 2) * (# of 3), and add to the ans.\nBut this is incorrect, because 1 can actually be selected more than once.\n\nSaying we have [1, 1, 2, 2, 2, 3, 3, 3, 3], most people's solution will calculate 2 * 3 * 4.\nThis number is # of subset of [1, 2, 3], but you can actually select [1, 1, 2, 3], which is not included in 2 * 3 * 4.\n\nIn fact, there will be (2^(# of 1s))x more subsets.\n\nSo let's modify the brute force algorithm:\n- Remove 1s from the collection\n- Run your original brute force algorithm to calculate # of subsets (which doesn't include 1s). For convenience, let's name it `tmp_ans`.\n- Now, saying we have `N` 1s, then `tmp_ans` subsets can result in `tmp_ans * (2^N)` subsets when combining with 1.\n- Also remember, you can select \"NON-EMPTY subsets with only 1s\", which results in another additional `2^N - 1` subsets.\n- So the final answer is `tmp_ans * (2^N) + (2^N - 1)`. Remember to mod 10^9 + 7."
                    },
                    {
                        "username": "sushruti",
                        "content": "this is not a medium problem..."
                    }
                ]
            },
            {
                "id": 1806590,
                "content": [
                    {
                        "username": "Blake_Han12",
                        "content": "5.7% ACCEPTANCE RATE. Lowest ever???"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "This should be tagged as HARD!!!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "Finally understood the solution.\\nThis is probably one of the hardest questions I have seen."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Taking me more time to figure out than most of Hard problems, so why it is medium?"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "According even to acceptance - this must be hard problem."
                    },
                    {
                        "username": "aa871788",
                        "content": "Brute force solution returns TLE."
                    },
                    {
                        "username": "dj_khalid",
                        "content": "Can someone please explain why the answer for this testcase is 3 ->\\n[26,6,4,27,6,18]\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`4`, `27`, and `18` are all divisible by squares so they aren't square-free. They're divisible by `4`, `9`, and `9` respectively. So none of the subsets can include those numbers.\n\nThat leaves only `[26,6,6]`. The single element subsets are all square-free: `[26]`,`[6]`, and `[6]`. **That's 3 subsets**.\n\nLet's look at the larger subsets like `[26,6]`, `[6,6]`, and `[26,6,6]`. `26 * 6 = 156` is divisible by `4` so it's not square-free. Similarly `6 * 6 = 36` is divisible by `36` so it's also not square-free. That means all of the other subsets are not square-free."
                    },
                    {
                        "username": "shivansh961",
                        "content": "In Example-1, why  [3,4] is not a square free subarray ?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) Now I understand the question. Thanks for the help !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@Tensor08](/Tensor08) Understood !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  got it, thanks "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "if you make its product, it will become 3*4 = 12, and this set is not square free because 12%4 = 0, where 4 is a perfect square"
                    },
                    {
                        "username": "Tensor08",
                        "content": "[@shivansh961](/shivansh961)  27 can't be included because 27 - 3 * 3 * 3 which include squareOf(3) * 3."
                    },
                    {
                        "username": "ynchsung",
                        "content": "[@shivansh961](/shivansh961)\n- 27, 18 cannot be selected.\n- [26, 6] is not a valid set, either.\n\nThe question means: When you select [a, b, c], you have to multiply them all (a * b * c), and a valid set definition: a * b * c is not divisible by any \"square number\", e.g. 4, 9, 25."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) For this test case : [26,6,4,27,6,18] answer is coming 3 but there are 5 such subsets.\\n[26], [6], [26, 6], [27], [27, 6], [27, 6, 18]. \\n\\nI think I am misunderstanding the questions. Can you spend some time and tell me the mistake ?\\n"
                    },
                    {
                        "username": "ynchsung",
                        "content": "4 itself is a square."
                    },
                    {
                        "username": "ynchsung",
                        "content": "1 is special case.\n\nFor 2, 3, 5, 7, ..., we only can select them once.\nFor example, consider a subset that only contains 2, 3, 5, 7.\nMost people's method will calculate (# of 2) * (# of 3) * (# of 5) * (# of 7),\nwhich is the total # of subsets that only contains \"exact one 2, 3, 5, and 7\" in the array.\n\nHowever, for 1, we can select any # of 1s. The brute force will miss the case for \"selecting more than 1 1s\".\n\nIOW when we're computing \"subsets with 1, 2, 3\", we will do something like (# of 1) * (# of 2) * (# of 3), and add to the ans.\nBut this is incorrect, because 1 can actually be selected more than once.\n\nSaying we have [1, 1, 2, 2, 2, 3, 3, 3, 3], most people's solution will calculate 2 * 3 * 4.\nThis number is # of subset of [1, 2, 3], but you can actually select [1, 1, 2, 3], which is not included in 2 * 3 * 4.\n\nIn fact, there will be (2^(# of 1s))x more subsets.\n\nSo let's modify the brute force algorithm:\n- Remove 1s from the collection\n- Run your original brute force algorithm to calculate # of subsets (which doesn't include 1s). For convenience, let's name it `tmp_ans`.\n- Now, saying we have `N` 1s, then `tmp_ans` subsets can result in `tmp_ans * (2^N)` subsets when combining with 1.\n- Also remember, you can select \"NON-EMPTY subsets with only 1s\", which results in another additional `2^N - 1` subsets.\n- So the final answer is `tmp_ans * (2^N) + (2^N - 1)`. Remember to mod 10^9 + 7."
                    },
                    {
                        "username": "sushruti",
                        "content": "this is not a medium problem..."
                    }
                ]
            },
            {
                "id": 1806589,
                "content": [
                    {
                        "username": "Blake_Han12",
                        "content": "5.7% ACCEPTANCE RATE. Lowest ever???"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "This should be tagged as HARD!!!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "Finally understood the solution.\\nThis is probably one of the hardest questions I have seen."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Taking me more time to figure out than most of Hard problems, so why it is medium?"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "According even to acceptance - this must be hard problem."
                    },
                    {
                        "username": "aa871788",
                        "content": "Brute force solution returns TLE."
                    },
                    {
                        "username": "dj_khalid",
                        "content": "Can someone please explain why the answer for this testcase is 3 ->\\n[26,6,4,27,6,18]\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`4`, `27`, and `18` are all divisible by squares so they aren't square-free. They're divisible by `4`, `9`, and `9` respectively. So none of the subsets can include those numbers.\n\nThat leaves only `[26,6,6]`. The single element subsets are all square-free: `[26]`,`[6]`, and `[6]`. **That's 3 subsets**.\n\nLet's look at the larger subsets like `[26,6]`, `[6,6]`, and `[26,6,6]`. `26 * 6 = 156` is divisible by `4` so it's not square-free. Similarly `6 * 6 = 36` is divisible by `36` so it's also not square-free. That means all of the other subsets are not square-free."
                    },
                    {
                        "username": "shivansh961",
                        "content": "In Example-1, why  [3,4] is not a square free subarray ?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) Now I understand the question. Thanks for the help !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@Tensor08](/Tensor08) Understood !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  got it, thanks "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "if you make its product, it will become 3*4 = 12, and this set is not square free because 12%4 = 0, where 4 is a perfect square"
                    },
                    {
                        "username": "Tensor08",
                        "content": "[@shivansh961](/shivansh961)  27 can't be included because 27 - 3 * 3 * 3 which include squareOf(3) * 3."
                    },
                    {
                        "username": "ynchsung",
                        "content": "[@shivansh961](/shivansh961)\n- 27, 18 cannot be selected.\n- [26, 6] is not a valid set, either.\n\nThe question means: When you select [a, b, c], you have to multiply them all (a * b * c), and a valid set definition: a * b * c is not divisible by any \"square number\", e.g. 4, 9, 25."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) For this test case : [26,6,4,27,6,18] answer is coming 3 but there are 5 such subsets.\\n[26], [6], [26, 6], [27], [27, 6], [27, 6, 18]. \\n\\nI think I am misunderstanding the questions. Can you spend some time and tell me the mistake ?\\n"
                    },
                    {
                        "username": "ynchsung",
                        "content": "4 itself is a square."
                    },
                    {
                        "username": "ynchsung",
                        "content": "1 is special case.\n\nFor 2, 3, 5, 7, ..., we only can select them once.\nFor example, consider a subset that only contains 2, 3, 5, 7.\nMost people's method will calculate (# of 2) * (# of 3) * (# of 5) * (# of 7),\nwhich is the total # of subsets that only contains \"exact one 2, 3, 5, and 7\" in the array.\n\nHowever, for 1, we can select any # of 1s. The brute force will miss the case for \"selecting more than 1 1s\".\n\nIOW when we're computing \"subsets with 1, 2, 3\", we will do something like (# of 1) * (# of 2) * (# of 3), and add to the ans.\nBut this is incorrect, because 1 can actually be selected more than once.\n\nSaying we have [1, 1, 2, 2, 2, 3, 3, 3, 3], most people's solution will calculate 2 * 3 * 4.\nThis number is # of subset of [1, 2, 3], but you can actually select [1, 1, 2, 3], which is not included in 2 * 3 * 4.\n\nIn fact, there will be (2^(# of 1s))x more subsets.\n\nSo let's modify the brute force algorithm:\n- Remove 1s from the collection\n- Run your original brute force algorithm to calculate # of subsets (which doesn't include 1s). For convenience, let's name it `tmp_ans`.\n- Now, saying we have `N` 1s, then `tmp_ans` subsets can result in `tmp_ans * (2^N)` subsets when combining with 1.\n- Also remember, you can select \"NON-EMPTY subsets with only 1s\", which results in another additional `2^N - 1` subsets.\n- So the final answer is `tmp_ans * (2^N) + (2^N - 1)`. Remember to mod 10^9 + 7."
                    },
                    {
                        "username": "sushruti",
                        "content": "this is not a medium problem..."
                    }
                ]
            },
            {
                "id": 2066400,
                "content": [
                    {
                        "username": "Blake_Han12",
                        "content": "5.7% ACCEPTANCE RATE. Lowest ever???"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "This should be tagged as HARD!!!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "Finally understood the solution.\\nThis is probably one of the hardest questions I have seen."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Taking me more time to figure out than most of Hard problems, so why it is medium?"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "According even to acceptance - this must be hard problem."
                    },
                    {
                        "username": "aa871788",
                        "content": "Brute force solution returns TLE."
                    },
                    {
                        "username": "dj_khalid",
                        "content": "Can someone please explain why the answer for this testcase is 3 ->\\n[26,6,4,27,6,18]\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`4`, `27`, and `18` are all divisible by squares so they aren't square-free. They're divisible by `4`, `9`, and `9` respectively. So none of the subsets can include those numbers.\n\nThat leaves only `[26,6,6]`. The single element subsets are all square-free: `[26]`,`[6]`, and `[6]`. **That's 3 subsets**.\n\nLet's look at the larger subsets like `[26,6]`, `[6,6]`, and `[26,6,6]`. `26 * 6 = 156` is divisible by `4` so it's not square-free. Similarly `6 * 6 = 36` is divisible by `36` so it's also not square-free. That means all of the other subsets are not square-free."
                    },
                    {
                        "username": "shivansh961",
                        "content": "In Example-1, why  [3,4] is not a square free subarray ?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) Now I understand the question. Thanks for the help !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@Tensor08](/Tensor08) Understood !!!\\n"
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  got it, thanks "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "if you make its product, it will become 3*4 = 12, and this set is not square free because 12%4 = 0, where 4 is a perfect square"
                    },
                    {
                        "username": "Tensor08",
                        "content": "[@shivansh961](/shivansh961)  27 can't be included because 27 - 3 * 3 * 3 which include squareOf(3) * 3."
                    },
                    {
                        "username": "ynchsung",
                        "content": "[@shivansh961](/shivansh961)\n- 27, 18 cannot be selected.\n- [26, 6] is not a valid set, either.\n\nThe question means: When you select [a, b, c], you have to multiply them all (a * b * c), and a valid set definition: a * b * c is not divisible by any \"square number\", e.g. 4, 9, 25."
                    },
                    {
                        "username": "shivansh961",
                        "content": "[@ynchsung](/ynchsung) For this test case : [26,6,4,27,6,18] answer is coming 3 but there are 5 such subsets.\\n[26], [6], [26, 6], [27], [27, 6], [27, 6, 18]. \\n\\nI think I am misunderstanding the questions. Can you spend some time and tell me the mistake ?\\n"
                    },
                    {
                        "username": "ynchsung",
                        "content": "4 itself is a square."
                    },
                    {
                        "username": "ynchsung",
                        "content": "1 is special case.\n\nFor 2, 3, 5, 7, ..., we only can select them once.\nFor example, consider a subset that only contains 2, 3, 5, 7.\nMost people's method will calculate (# of 2) * (# of 3) * (# of 5) * (# of 7),\nwhich is the total # of subsets that only contains \"exact one 2, 3, 5, and 7\" in the array.\n\nHowever, for 1, we can select any # of 1s. The brute force will miss the case for \"selecting more than 1 1s\".\n\nIOW when we're computing \"subsets with 1, 2, 3\", we will do something like (# of 1) * (# of 2) * (# of 3), and add to the ans.\nBut this is incorrect, because 1 can actually be selected more than once.\n\nSaying we have [1, 1, 2, 2, 2, 3, 3, 3, 3], most people's solution will calculate 2 * 3 * 4.\nThis number is # of subset of [1, 2, 3], but you can actually select [1, 1, 2, 3], which is not included in 2 * 3 * 4.\n\nIn fact, there will be (2^(# of 1s))x more subsets.\n\nSo let's modify the brute force algorithm:\n- Remove 1s from the collection\n- Run your original brute force algorithm to calculate # of subsets (which doesn't include 1s). For convenience, let's name it `tmp_ans`.\n- Now, saying we have `N` 1s, then `tmp_ans` subsets can result in `tmp_ans * (2^N)` subsets when combining with 1.\n- Also remember, you can select \"NON-EMPTY subsets with only 1s\", which results in another additional `2^N - 1` subsets.\n- So the final answer is `tmp_ans * (2^N) + (2^N - 1)`. Remember to mod 10^9 + 7."
                    },
                    {
                        "username": "sushruti",
                        "content": "this is not a medium problem..."
                    }
                ]
            },
            {
                "id": 2049688,
                "content": [
                    {
                        "username": "user1040JO",
                        "content": "This problem is either poorly worded or outright incorrect. Not sure I follow their logic for creating subsetss. Can anyone explain how [8,11,17,2,25,29,21,20,4,22] can lead to 39? Simple discrete maths would put the answer at 63. Of the 63 combinations, which values are they ignoring and what is the reasoning for ignoring them?\n\n{11 17 2 29 21 22 }\n{11 17 2 29 21 }\n{11 17 2 29 22 }\n{11 17 2 29 }\n{11 17 2 21 22 }\n{11 17 2 21 }\n{11 17 2 22 }\n{11 17 2 }\n{11 17 29 21 22 }\n{11 17 29 21 }\n{11 17 29 22 }\n{11 17 29 }\n{11 17 21 22 }\n{11 17 21 }\n{11 17 22 }\n{11 17 }\n{11 2 29 21 22 }\n{11 2 29 21 }\n{11 2 29 22 }\n{11 2 29 }\n{11 2 21 22 }\n{11 2 21 }\n{11 2 22 }\n{11 2 }\n{11 29 21 22 }\n{11 29 21 }\n{11 29 22 }\n{11 29 }\n{11 21 22 }\n{11 21 }\n{11 22 }\n{11 }\n{17 2 29 21 22 }\n{17 2 29 21 }\n{17 2 29 22 }\n{17 2 29 }\n{17 2 21 22 }\n{17 2 21 }\n{17 2 22 }\n{17 2 }\n{17 29 21 22 }\n{17 29 21 }\n{17 29 22 }\n{17 29 }\n{17 21 22 }\n{17 21 }\n{17 22 }\n{17 }\n{2 29 21 22 }\n{2 29 21 }\n{2 29 22 }\n{2 29 }\n{2 21 22 }\n{2 21 }\n{2 22 }\n{2 }\n{29 21 22 }\n{29 21 }\n{29 22 }\n{29 }\n{21 22 }\n{21 }\n{22 }\n\nAll of them are unique and delete different set of indices. "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Inadvertently, I overlooked the statement asserting that \"Two subsets are distinct only if the selected indices for removal differ,\" resulting in a delay in resolving the logical issue at hand. Anyway, I only want to deal with Medium level question and this one was picked randomly from the list lol."
                    },
                    {
                        "username": "summer_2",
                        "content": "It\\'s clearly mentioned that we need to find out total number of subsets, then why solutions which are using bit masking to find SUBSEQUENCE works !?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "The reason behind this is due to a constraint that states, \"Two subsets can be considered different only if the chosen indices for deletion differ.\""
                    },
                    {
                        "username": "sindy",
                        "content": "Can someone tell me which subset is missing in testcase [8, 11, 17, 2, 25, 29, 21, 20, 4, 22]? Expected 39 but I got 38.\\n\\n[11]\\n[17]\\n[2]\\n[29]\\n[21]\\n[22]\\n\\n[22, 21]\\n[21, 29]\\n[22, 29]\\n[29, 2]\\n[21, 2]\\n[2, 17]\\n[29, 17]\\n[21, 17]\\n[22, 17]\\n[17, 11]\\n[2, 11]\\n[29, 11]\\n[21, 11]\\n\\n[22, 21, 29]\\n[21, 29, 2]\\n[22, 21, 17]\\n[21, 29, 17]\\n[22, 29, 17]\\n[29, 2, 17]\\n[21, 2, 17]\\n[21, 29, 11]\\n[29, 2, 11]\\n[21, 2, 11]\\n[2, 17, 11]\\n[29, 17, 11]\\n[21, 17, 11]\\n\\n[22, 21, 29, 17]\\n[21, 29, 2, 11]\\n[21, 29, 2, 11]\\n[21, 29, 17, 11]\\n[29, 2, 17, 11]\\n[21, 2, 17, 11]"
                    },
                    {
                        "username": "NISHANTH2004",
                        "content": "I tried this code in 6 programming languages its not running.. this one of the hardest problem i have ever seen.   "
                    },
                    {
                        "username": "colins",
                        "content": "Can anybody explain why we dont need to look at prime number large than 30? E.g. a product that is divisible by 31^2? Thanks!"
                    },
                    {
                        "username": "vtarakan",
                        "content": "Take any 2 numbers less than 30, say a and b.\\nBy fundamental theorem of arithmetics, a and b are products of some prime factors , where no factor is larger than a or b respectively. \\nInductively, this means that for any product of a1  * a2 *...* an,  we wont have any prime factor more than max(a1,a2...,an)<=30.\\n\\nReally the constraint of 30 on each factor + prime factorisation theorem is the magic here. If factors were larger, i dont see a tractable solution (yet?)"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The constraints say `1 <= nums[i] <= 30` so no individual number can have a prime factor larger than 30.\\n\\nWhy did you give 31^2 as an example? 31^2 is not a prime number since it\\'s obviously divisible by 31. You can\\'t get prime numbers by multiplying primes. So even if we have a subset like `{31,31}` or `{29,19}`, when we multiply all the elements we don\\'t need to check any larger primes."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Interesting fact is: This is a medium, and \\'Number of Island\\' is also a medium..."
                    },
                    {
                        "username": "shivansh961",
                        "content": "This is so annoying questions."
                    },
                    {
                        "username": "mhmakelvin",
                        "content": "Almost same problem as [1994. The Number of Good Subsets](https://leetcode.com/problems/the-number-of-good-subsets/) which is a hard."
                    },
                    {
                        "username": "KhacLong",
                        "content": "Nice problem. I think the hardest part is realize that this is dp + bitmasking, after that, it\\'s quite ez to implement"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "I got the solution eventually, but it\\'s hard to believe that both this question and today\\'s daily are considered \"medium\""
                    }
                ]
            },
            {
                "id": 1884466,
                "content": [
                    {
                        "username": "user1040JO",
                        "content": "This problem is either poorly worded or outright incorrect. Not sure I follow their logic for creating subsetss. Can anyone explain how [8,11,17,2,25,29,21,20,4,22] can lead to 39? Simple discrete maths would put the answer at 63. Of the 63 combinations, which values are they ignoring and what is the reasoning for ignoring them?\n\n{11 17 2 29 21 22 }\n{11 17 2 29 21 }\n{11 17 2 29 22 }\n{11 17 2 29 }\n{11 17 2 21 22 }\n{11 17 2 21 }\n{11 17 2 22 }\n{11 17 2 }\n{11 17 29 21 22 }\n{11 17 29 21 }\n{11 17 29 22 }\n{11 17 29 }\n{11 17 21 22 }\n{11 17 21 }\n{11 17 22 }\n{11 17 }\n{11 2 29 21 22 }\n{11 2 29 21 }\n{11 2 29 22 }\n{11 2 29 }\n{11 2 21 22 }\n{11 2 21 }\n{11 2 22 }\n{11 2 }\n{11 29 21 22 }\n{11 29 21 }\n{11 29 22 }\n{11 29 }\n{11 21 22 }\n{11 21 }\n{11 22 }\n{11 }\n{17 2 29 21 22 }\n{17 2 29 21 }\n{17 2 29 22 }\n{17 2 29 }\n{17 2 21 22 }\n{17 2 21 }\n{17 2 22 }\n{17 2 }\n{17 29 21 22 }\n{17 29 21 }\n{17 29 22 }\n{17 29 }\n{17 21 22 }\n{17 21 }\n{17 22 }\n{17 }\n{2 29 21 22 }\n{2 29 21 }\n{2 29 22 }\n{2 29 }\n{2 21 22 }\n{2 21 }\n{2 22 }\n{2 }\n{29 21 22 }\n{29 21 }\n{29 22 }\n{29 }\n{21 22 }\n{21 }\n{22 }\n\nAll of them are unique and delete different set of indices. "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Inadvertently, I overlooked the statement asserting that \"Two subsets are distinct only if the selected indices for removal differ,\" resulting in a delay in resolving the logical issue at hand. Anyway, I only want to deal with Medium level question and this one was picked randomly from the list lol."
                    },
                    {
                        "username": "summer_2",
                        "content": "It\\'s clearly mentioned that we need to find out total number of subsets, then why solutions which are using bit masking to find SUBSEQUENCE works !?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "The reason behind this is due to a constraint that states, \"Two subsets can be considered different only if the chosen indices for deletion differ.\""
                    },
                    {
                        "username": "sindy",
                        "content": "Can someone tell me which subset is missing in testcase [8, 11, 17, 2, 25, 29, 21, 20, 4, 22]? Expected 39 but I got 38.\\n\\n[11]\\n[17]\\n[2]\\n[29]\\n[21]\\n[22]\\n\\n[22, 21]\\n[21, 29]\\n[22, 29]\\n[29, 2]\\n[21, 2]\\n[2, 17]\\n[29, 17]\\n[21, 17]\\n[22, 17]\\n[17, 11]\\n[2, 11]\\n[29, 11]\\n[21, 11]\\n\\n[22, 21, 29]\\n[21, 29, 2]\\n[22, 21, 17]\\n[21, 29, 17]\\n[22, 29, 17]\\n[29, 2, 17]\\n[21, 2, 17]\\n[21, 29, 11]\\n[29, 2, 11]\\n[21, 2, 11]\\n[2, 17, 11]\\n[29, 17, 11]\\n[21, 17, 11]\\n\\n[22, 21, 29, 17]\\n[21, 29, 2, 11]\\n[21, 29, 2, 11]\\n[21, 29, 17, 11]\\n[29, 2, 17, 11]\\n[21, 2, 17, 11]"
                    },
                    {
                        "username": "NISHANTH2004",
                        "content": "I tried this code in 6 programming languages its not running.. this one of the hardest problem i have ever seen.   "
                    },
                    {
                        "username": "colins",
                        "content": "Can anybody explain why we dont need to look at prime number large than 30? E.g. a product that is divisible by 31^2? Thanks!"
                    },
                    {
                        "username": "vtarakan",
                        "content": "Take any 2 numbers less than 30, say a and b.\\nBy fundamental theorem of arithmetics, a and b are products of some prime factors , where no factor is larger than a or b respectively. \\nInductively, this means that for any product of a1  * a2 *...* an,  we wont have any prime factor more than max(a1,a2...,an)<=30.\\n\\nReally the constraint of 30 on each factor + prime factorisation theorem is the magic here. If factors were larger, i dont see a tractable solution (yet?)"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The constraints say `1 <= nums[i] <= 30` so no individual number can have a prime factor larger than 30.\\n\\nWhy did you give 31^2 as an example? 31^2 is not a prime number since it\\'s obviously divisible by 31. You can\\'t get prime numbers by multiplying primes. So even if we have a subset like `{31,31}` or `{29,19}`, when we multiply all the elements we don\\'t need to check any larger primes."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Interesting fact is: This is a medium, and \\'Number of Island\\' is also a medium..."
                    },
                    {
                        "username": "shivansh961",
                        "content": "This is so annoying questions."
                    },
                    {
                        "username": "mhmakelvin",
                        "content": "Almost same problem as [1994. The Number of Good Subsets](https://leetcode.com/problems/the-number-of-good-subsets/) which is a hard."
                    },
                    {
                        "username": "KhacLong",
                        "content": "Nice problem. I think the hardest part is realize that this is dp + bitmasking, after that, it\\'s quite ez to implement"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "I got the solution eventually, but it\\'s hard to believe that both this question and today\\'s daily are considered \"medium\""
                    }
                ]
            },
            {
                "id": 1861157,
                "content": [
                    {
                        "username": "user1040JO",
                        "content": "This problem is either poorly worded or outright incorrect. Not sure I follow their logic for creating subsetss. Can anyone explain how [8,11,17,2,25,29,21,20,4,22] can lead to 39? Simple discrete maths would put the answer at 63. Of the 63 combinations, which values are they ignoring and what is the reasoning for ignoring them?\n\n{11 17 2 29 21 22 }\n{11 17 2 29 21 }\n{11 17 2 29 22 }\n{11 17 2 29 }\n{11 17 2 21 22 }\n{11 17 2 21 }\n{11 17 2 22 }\n{11 17 2 }\n{11 17 29 21 22 }\n{11 17 29 21 }\n{11 17 29 22 }\n{11 17 29 }\n{11 17 21 22 }\n{11 17 21 }\n{11 17 22 }\n{11 17 }\n{11 2 29 21 22 }\n{11 2 29 21 }\n{11 2 29 22 }\n{11 2 29 }\n{11 2 21 22 }\n{11 2 21 }\n{11 2 22 }\n{11 2 }\n{11 29 21 22 }\n{11 29 21 }\n{11 29 22 }\n{11 29 }\n{11 21 22 }\n{11 21 }\n{11 22 }\n{11 }\n{17 2 29 21 22 }\n{17 2 29 21 }\n{17 2 29 22 }\n{17 2 29 }\n{17 2 21 22 }\n{17 2 21 }\n{17 2 22 }\n{17 2 }\n{17 29 21 22 }\n{17 29 21 }\n{17 29 22 }\n{17 29 }\n{17 21 22 }\n{17 21 }\n{17 22 }\n{17 }\n{2 29 21 22 }\n{2 29 21 }\n{2 29 22 }\n{2 29 }\n{2 21 22 }\n{2 21 }\n{2 22 }\n{2 }\n{29 21 22 }\n{29 21 }\n{29 22 }\n{29 }\n{21 22 }\n{21 }\n{22 }\n\nAll of them are unique and delete different set of indices. "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Inadvertently, I overlooked the statement asserting that \"Two subsets are distinct only if the selected indices for removal differ,\" resulting in a delay in resolving the logical issue at hand. Anyway, I only want to deal with Medium level question and this one was picked randomly from the list lol."
                    },
                    {
                        "username": "summer_2",
                        "content": "It\\'s clearly mentioned that we need to find out total number of subsets, then why solutions which are using bit masking to find SUBSEQUENCE works !?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "The reason behind this is due to a constraint that states, \"Two subsets can be considered different only if the chosen indices for deletion differ.\""
                    },
                    {
                        "username": "sindy",
                        "content": "Can someone tell me which subset is missing in testcase [8, 11, 17, 2, 25, 29, 21, 20, 4, 22]? Expected 39 but I got 38.\\n\\n[11]\\n[17]\\n[2]\\n[29]\\n[21]\\n[22]\\n\\n[22, 21]\\n[21, 29]\\n[22, 29]\\n[29, 2]\\n[21, 2]\\n[2, 17]\\n[29, 17]\\n[21, 17]\\n[22, 17]\\n[17, 11]\\n[2, 11]\\n[29, 11]\\n[21, 11]\\n\\n[22, 21, 29]\\n[21, 29, 2]\\n[22, 21, 17]\\n[21, 29, 17]\\n[22, 29, 17]\\n[29, 2, 17]\\n[21, 2, 17]\\n[21, 29, 11]\\n[29, 2, 11]\\n[21, 2, 11]\\n[2, 17, 11]\\n[29, 17, 11]\\n[21, 17, 11]\\n\\n[22, 21, 29, 17]\\n[21, 29, 2, 11]\\n[21, 29, 2, 11]\\n[21, 29, 17, 11]\\n[29, 2, 17, 11]\\n[21, 2, 17, 11]"
                    },
                    {
                        "username": "NISHANTH2004",
                        "content": "I tried this code in 6 programming languages its not running.. this one of the hardest problem i have ever seen.   "
                    },
                    {
                        "username": "colins",
                        "content": "Can anybody explain why we dont need to look at prime number large than 30? E.g. a product that is divisible by 31^2? Thanks!"
                    },
                    {
                        "username": "vtarakan",
                        "content": "Take any 2 numbers less than 30, say a and b.\\nBy fundamental theorem of arithmetics, a and b are products of some prime factors , where no factor is larger than a or b respectively. \\nInductively, this means that for any product of a1  * a2 *...* an,  we wont have any prime factor more than max(a1,a2...,an)<=30.\\n\\nReally the constraint of 30 on each factor + prime factorisation theorem is the magic here. If factors were larger, i dont see a tractable solution (yet?)"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The constraints say `1 <= nums[i] <= 30` so no individual number can have a prime factor larger than 30.\\n\\nWhy did you give 31^2 as an example? 31^2 is not a prime number since it\\'s obviously divisible by 31. You can\\'t get prime numbers by multiplying primes. So even if we have a subset like `{31,31}` or `{29,19}`, when we multiply all the elements we don\\'t need to check any larger primes."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Interesting fact is: This is a medium, and \\'Number of Island\\' is also a medium..."
                    },
                    {
                        "username": "shivansh961",
                        "content": "This is so annoying questions."
                    },
                    {
                        "username": "mhmakelvin",
                        "content": "Almost same problem as [1994. The Number of Good Subsets](https://leetcode.com/problems/the-number-of-good-subsets/) which is a hard."
                    },
                    {
                        "username": "KhacLong",
                        "content": "Nice problem. I think the hardest part is realize that this is dp + bitmasking, after that, it\\'s quite ez to implement"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "I got the solution eventually, but it\\'s hard to believe that both this question and today\\'s daily are considered \"medium\""
                    }
                ]
            },
            {
                "id": 1845642,
                "content": [
                    {
                        "username": "user1040JO",
                        "content": "This problem is either poorly worded or outright incorrect. Not sure I follow their logic for creating subsetss. Can anyone explain how [8,11,17,2,25,29,21,20,4,22] can lead to 39? Simple discrete maths would put the answer at 63. Of the 63 combinations, which values are they ignoring and what is the reasoning for ignoring them?\n\n{11 17 2 29 21 22 }\n{11 17 2 29 21 }\n{11 17 2 29 22 }\n{11 17 2 29 }\n{11 17 2 21 22 }\n{11 17 2 21 }\n{11 17 2 22 }\n{11 17 2 }\n{11 17 29 21 22 }\n{11 17 29 21 }\n{11 17 29 22 }\n{11 17 29 }\n{11 17 21 22 }\n{11 17 21 }\n{11 17 22 }\n{11 17 }\n{11 2 29 21 22 }\n{11 2 29 21 }\n{11 2 29 22 }\n{11 2 29 }\n{11 2 21 22 }\n{11 2 21 }\n{11 2 22 }\n{11 2 }\n{11 29 21 22 }\n{11 29 21 }\n{11 29 22 }\n{11 29 }\n{11 21 22 }\n{11 21 }\n{11 22 }\n{11 }\n{17 2 29 21 22 }\n{17 2 29 21 }\n{17 2 29 22 }\n{17 2 29 }\n{17 2 21 22 }\n{17 2 21 }\n{17 2 22 }\n{17 2 }\n{17 29 21 22 }\n{17 29 21 }\n{17 29 22 }\n{17 29 }\n{17 21 22 }\n{17 21 }\n{17 22 }\n{17 }\n{2 29 21 22 }\n{2 29 21 }\n{2 29 22 }\n{2 29 }\n{2 21 22 }\n{2 21 }\n{2 22 }\n{2 }\n{29 21 22 }\n{29 21 }\n{29 22 }\n{29 }\n{21 22 }\n{21 }\n{22 }\n\nAll of them are unique and delete different set of indices. "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Inadvertently, I overlooked the statement asserting that \"Two subsets are distinct only if the selected indices for removal differ,\" resulting in a delay in resolving the logical issue at hand. Anyway, I only want to deal with Medium level question and this one was picked randomly from the list lol."
                    },
                    {
                        "username": "summer_2",
                        "content": "It\\'s clearly mentioned that we need to find out total number of subsets, then why solutions which are using bit masking to find SUBSEQUENCE works !?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "The reason behind this is due to a constraint that states, \"Two subsets can be considered different only if the chosen indices for deletion differ.\""
                    },
                    {
                        "username": "sindy",
                        "content": "Can someone tell me which subset is missing in testcase [8, 11, 17, 2, 25, 29, 21, 20, 4, 22]? Expected 39 but I got 38.\\n\\n[11]\\n[17]\\n[2]\\n[29]\\n[21]\\n[22]\\n\\n[22, 21]\\n[21, 29]\\n[22, 29]\\n[29, 2]\\n[21, 2]\\n[2, 17]\\n[29, 17]\\n[21, 17]\\n[22, 17]\\n[17, 11]\\n[2, 11]\\n[29, 11]\\n[21, 11]\\n\\n[22, 21, 29]\\n[21, 29, 2]\\n[22, 21, 17]\\n[21, 29, 17]\\n[22, 29, 17]\\n[29, 2, 17]\\n[21, 2, 17]\\n[21, 29, 11]\\n[29, 2, 11]\\n[21, 2, 11]\\n[2, 17, 11]\\n[29, 17, 11]\\n[21, 17, 11]\\n\\n[22, 21, 29, 17]\\n[21, 29, 2, 11]\\n[21, 29, 2, 11]\\n[21, 29, 17, 11]\\n[29, 2, 17, 11]\\n[21, 2, 17, 11]"
                    },
                    {
                        "username": "NISHANTH2004",
                        "content": "I tried this code in 6 programming languages its not running.. this one of the hardest problem i have ever seen.   "
                    },
                    {
                        "username": "colins",
                        "content": "Can anybody explain why we dont need to look at prime number large than 30? E.g. a product that is divisible by 31^2? Thanks!"
                    },
                    {
                        "username": "vtarakan",
                        "content": "Take any 2 numbers less than 30, say a and b.\\nBy fundamental theorem of arithmetics, a and b are products of some prime factors , where no factor is larger than a or b respectively. \\nInductively, this means that for any product of a1  * a2 *...* an,  we wont have any prime factor more than max(a1,a2...,an)<=30.\\n\\nReally the constraint of 30 on each factor + prime factorisation theorem is the magic here. If factors were larger, i dont see a tractable solution (yet?)"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The constraints say `1 <= nums[i] <= 30` so no individual number can have a prime factor larger than 30.\\n\\nWhy did you give 31^2 as an example? 31^2 is not a prime number since it\\'s obviously divisible by 31. You can\\'t get prime numbers by multiplying primes. So even if we have a subset like `{31,31}` or `{29,19}`, when we multiply all the elements we don\\'t need to check any larger primes."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Interesting fact is: This is a medium, and \\'Number of Island\\' is also a medium..."
                    },
                    {
                        "username": "shivansh961",
                        "content": "This is so annoying questions."
                    },
                    {
                        "username": "mhmakelvin",
                        "content": "Almost same problem as [1994. The Number of Good Subsets](https://leetcode.com/problems/the-number-of-good-subsets/) which is a hard."
                    },
                    {
                        "username": "KhacLong",
                        "content": "Nice problem. I think the hardest part is realize that this is dp + bitmasking, after that, it\\'s quite ez to implement"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "I got the solution eventually, but it\\'s hard to believe that both this question and today\\'s daily are considered \"medium\""
                    }
                ]
            },
            {
                "id": 1832013,
                "content": [
                    {
                        "username": "user1040JO",
                        "content": "This problem is either poorly worded or outright incorrect. Not sure I follow their logic for creating subsetss. Can anyone explain how [8,11,17,2,25,29,21,20,4,22] can lead to 39? Simple discrete maths would put the answer at 63. Of the 63 combinations, which values are they ignoring and what is the reasoning for ignoring them?\n\n{11 17 2 29 21 22 }\n{11 17 2 29 21 }\n{11 17 2 29 22 }\n{11 17 2 29 }\n{11 17 2 21 22 }\n{11 17 2 21 }\n{11 17 2 22 }\n{11 17 2 }\n{11 17 29 21 22 }\n{11 17 29 21 }\n{11 17 29 22 }\n{11 17 29 }\n{11 17 21 22 }\n{11 17 21 }\n{11 17 22 }\n{11 17 }\n{11 2 29 21 22 }\n{11 2 29 21 }\n{11 2 29 22 }\n{11 2 29 }\n{11 2 21 22 }\n{11 2 21 }\n{11 2 22 }\n{11 2 }\n{11 29 21 22 }\n{11 29 21 }\n{11 29 22 }\n{11 29 }\n{11 21 22 }\n{11 21 }\n{11 22 }\n{11 }\n{17 2 29 21 22 }\n{17 2 29 21 }\n{17 2 29 22 }\n{17 2 29 }\n{17 2 21 22 }\n{17 2 21 }\n{17 2 22 }\n{17 2 }\n{17 29 21 22 }\n{17 29 21 }\n{17 29 22 }\n{17 29 }\n{17 21 22 }\n{17 21 }\n{17 22 }\n{17 }\n{2 29 21 22 }\n{2 29 21 }\n{2 29 22 }\n{2 29 }\n{2 21 22 }\n{2 21 }\n{2 22 }\n{2 }\n{29 21 22 }\n{29 21 }\n{29 22 }\n{29 }\n{21 22 }\n{21 }\n{22 }\n\nAll of them are unique and delete different set of indices. "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Inadvertently, I overlooked the statement asserting that \"Two subsets are distinct only if the selected indices for removal differ,\" resulting in a delay in resolving the logical issue at hand. Anyway, I only want to deal with Medium level question and this one was picked randomly from the list lol."
                    },
                    {
                        "username": "summer_2",
                        "content": "It\\'s clearly mentioned that we need to find out total number of subsets, then why solutions which are using bit masking to find SUBSEQUENCE works !?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "The reason behind this is due to a constraint that states, \"Two subsets can be considered different only if the chosen indices for deletion differ.\""
                    },
                    {
                        "username": "sindy",
                        "content": "Can someone tell me which subset is missing in testcase [8, 11, 17, 2, 25, 29, 21, 20, 4, 22]? Expected 39 but I got 38.\\n\\n[11]\\n[17]\\n[2]\\n[29]\\n[21]\\n[22]\\n\\n[22, 21]\\n[21, 29]\\n[22, 29]\\n[29, 2]\\n[21, 2]\\n[2, 17]\\n[29, 17]\\n[21, 17]\\n[22, 17]\\n[17, 11]\\n[2, 11]\\n[29, 11]\\n[21, 11]\\n\\n[22, 21, 29]\\n[21, 29, 2]\\n[22, 21, 17]\\n[21, 29, 17]\\n[22, 29, 17]\\n[29, 2, 17]\\n[21, 2, 17]\\n[21, 29, 11]\\n[29, 2, 11]\\n[21, 2, 11]\\n[2, 17, 11]\\n[29, 17, 11]\\n[21, 17, 11]\\n\\n[22, 21, 29, 17]\\n[21, 29, 2, 11]\\n[21, 29, 2, 11]\\n[21, 29, 17, 11]\\n[29, 2, 17, 11]\\n[21, 2, 17, 11]"
                    },
                    {
                        "username": "NISHANTH2004",
                        "content": "I tried this code in 6 programming languages its not running.. this one of the hardest problem i have ever seen.   "
                    },
                    {
                        "username": "colins",
                        "content": "Can anybody explain why we dont need to look at prime number large than 30? E.g. a product that is divisible by 31^2? Thanks!"
                    },
                    {
                        "username": "vtarakan",
                        "content": "Take any 2 numbers less than 30, say a and b.\\nBy fundamental theorem of arithmetics, a and b are products of some prime factors , where no factor is larger than a or b respectively. \\nInductively, this means that for any product of a1  * a2 *...* an,  we wont have any prime factor more than max(a1,a2...,an)<=30.\\n\\nReally the constraint of 30 on each factor + prime factorisation theorem is the magic here. If factors were larger, i dont see a tractable solution (yet?)"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The constraints say `1 <= nums[i] <= 30` so no individual number can have a prime factor larger than 30.\\n\\nWhy did you give 31^2 as an example? 31^2 is not a prime number since it\\'s obviously divisible by 31. You can\\'t get prime numbers by multiplying primes. So even if we have a subset like `{31,31}` or `{29,19}`, when we multiply all the elements we don\\'t need to check any larger primes."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Interesting fact is: This is a medium, and \\'Number of Island\\' is also a medium..."
                    },
                    {
                        "username": "shivansh961",
                        "content": "This is so annoying questions."
                    },
                    {
                        "username": "mhmakelvin",
                        "content": "Almost same problem as [1994. The Number of Good Subsets](https://leetcode.com/problems/the-number-of-good-subsets/) which is a hard."
                    },
                    {
                        "username": "KhacLong",
                        "content": "Nice problem. I think the hardest part is realize that this is dp + bitmasking, after that, it\\'s quite ez to implement"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "I got the solution eventually, but it\\'s hard to believe that both this question and today\\'s daily are considered \"medium\""
                    }
                ]
            },
            {
                "id": 1808697,
                "content": [
                    {
                        "username": "user1040JO",
                        "content": "This problem is either poorly worded or outright incorrect. Not sure I follow their logic for creating subsetss. Can anyone explain how [8,11,17,2,25,29,21,20,4,22] can lead to 39? Simple discrete maths would put the answer at 63. Of the 63 combinations, which values are they ignoring and what is the reasoning for ignoring them?\n\n{11 17 2 29 21 22 }\n{11 17 2 29 21 }\n{11 17 2 29 22 }\n{11 17 2 29 }\n{11 17 2 21 22 }\n{11 17 2 21 }\n{11 17 2 22 }\n{11 17 2 }\n{11 17 29 21 22 }\n{11 17 29 21 }\n{11 17 29 22 }\n{11 17 29 }\n{11 17 21 22 }\n{11 17 21 }\n{11 17 22 }\n{11 17 }\n{11 2 29 21 22 }\n{11 2 29 21 }\n{11 2 29 22 }\n{11 2 29 }\n{11 2 21 22 }\n{11 2 21 }\n{11 2 22 }\n{11 2 }\n{11 29 21 22 }\n{11 29 21 }\n{11 29 22 }\n{11 29 }\n{11 21 22 }\n{11 21 }\n{11 22 }\n{11 }\n{17 2 29 21 22 }\n{17 2 29 21 }\n{17 2 29 22 }\n{17 2 29 }\n{17 2 21 22 }\n{17 2 21 }\n{17 2 22 }\n{17 2 }\n{17 29 21 22 }\n{17 29 21 }\n{17 29 22 }\n{17 29 }\n{17 21 22 }\n{17 21 }\n{17 22 }\n{17 }\n{2 29 21 22 }\n{2 29 21 }\n{2 29 22 }\n{2 29 }\n{2 21 22 }\n{2 21 }\n{2 22 }\n{2 }\n{29 21 22 }\n{29 21 }\n{29 22 }\n{29 }\n{21 22 }\n{21 }\n{22 }\n\nAll of them are unique and delete different set of indices. "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Inadvertently, I overlooked the statement asserting that \"Two subsets are distinct only if the selected indices for removal differ,\" resulting in a delay in resolving the logical issue at hand. Anyway, I only want to deal with Medium level question and this one was picked randomly from the list lol."
                    },
                    {
                        "username": "summer_2",
                        "content": "It\\'s clearly mentioned that we need to find out total number of subsets, then why solutions which are using bit masking to find SUBSEQUENCE works !?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "The reason behind this is due to a constraint that states, \"Two subsets can be considered different only if the chosen indices for deletion differ.\""
                    },
                    {
                        "username": "sindy",
                        "content": "Can someone tell me which subset is missing in testcase [8, 11, 17, 2, 25, 29, 21, 20, 4, 22]? Expected 39 but I got 38.\\n\\n[11]\\n[17]\\n[2]\\n[29]\\n[21]\\n[22]\\n\\n[22, 21]\\n[21, 29]\\n[22, 29]\\n[29, 2]\\n[21, 2]\\n[2, 17]\\n[29, 17]\\n[21, 17]\\n[22, 17]\\n[17, 11]\\n[2, 11]\\n[29, 11]\\n[21, 11]\\n\\n[22, 21, 29]\\n[21, 29, 2]\\n[22, 21, 17]\\n[21, 29, 17]\\n[22, 29, 17]\\n[29, 2, 17]\\n[21, 2, 17]\\n[21, 29, 11]\\n[29, 2, 11]\\n[21, 2, 11]\\n[2, 17, 11]\\n[29, 17, 11]\\n[21, 17, 11]\\n\\n[22, 21, 29, 17]\\n[21, 29, 2, 11]\\n[21, 29, 2, 11]\\n[21, 29, 17, 11]\\n[29, 2, 17, 11]\\n[21, 2, 17, 11]"
                    },
                    {
                        "username": "NISHANTH2004",
                        "content": "I tried this code in 6 programming languages its not running.. this one of the hardest problem i have ever seen.   "
                    },
                    {
                        "username": "colins",
                        "content": "Can anybody explain why we dont need to look at prime number large than 30? E.g. a product that is divisible by 31^2? Thanks!"
                    },
                    {
                        "username": "vtarakan",
                        "content": "Take any 2 numbers less than 30, say a and b.\\nBy fundamental theorem of arithmetics, a and b are products of some prime factors , where no factor is larger than a or b respectively. \\nInductively, this means that for any product of a1  * a2 *...* an,  we wont have any prime factor more than max(a1,a2...,an)<=30.\\n\\nReally the constraint of 30 on each factor + prime factorisation theorem is the magic here. If factors were larger, i dont see a tractable solution (yet?)"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The constraints say `1 <= nums[i] <= 30` so no individual number can have a prime factor larger than 30.\\n\\nWhy did you give 31^2 as an example? 31^2 is not a prime number since it\\'s obviously divisible by 31. You can\\'t get prime numbers by multiplying primes. So even if we have a subset like `{31,31}` or `{29,19}`, when we multiply all the elements we don\\'t need to check any larger primes."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Interesting fact is: This is a medium, and \\'Number of Island\\' is also a medium..."
                    },
                    {
                        "username": "shivansh961",
                        "content": "This is so annoying questions."
                    },
                    {
                        "username": "mhmakelvin",
                        "content": "Almost same problem as [1994. The Number of Good Subsets](https://leetcode.com/problems/the-number-of-good-subsets/) which is a hard."
                    },
                    {
                        "username": "KhacLong",
                        "content": "Nice problem. I think the hardest part is realize that this is dp + bitmasking, after that, it\\'s quite ez to implement"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "I got the solution eventually, but it\\'s hard to believe that both this question and today\\'s daily are considered \"medium\""
                    }
                ]
            },
            {
                "id": 1807484,
                "content": [
                    {
                        "username": "user1040JO",
                        "content": "This problem is either poorly worded or outright incorrect. Not sure I follow their logic for creating subsetss. Can anyone explain how [8,11,17,2,25,29,21,20,4,22] can lead to 39? Simple discrete maths would put the answer at 63. Of the 63 combinations, which values are they ignoring and what is the reasoning for ignoring them?\n\n{11 17 2 29 21 22 }\n{11 17 2 29 21 }\n{11 17 2 29 22 }\n{11 17 2 29 }\n{11 17 2 21 22 }\n{11 17 2 21 }\n{11 17 2 22 }\n{11 17 2 }\n{11 17 29 21 22 }\n{11 17 29 21 }\n{11 17 29 22 }\n{11 17 29 }\n{11 17 21 22 }\n{11 17 21 }\n{11 17 22 }\n{11 17 }\n{11 2 29 21 22 }\n{11 2 29 21 }\n{11 2 29 22 }\n{11 2 29 }\n{11 2 21 22 }\n{11 2 21 }\n{11 2 22 }\n{11 2 }\n{11 29 21 22 }\n{11 29 21 }\n{11 29 22 }\n{11 29 }\n{11 21 22 }\n{11 21 }\n{11 22 }\n{11 }\n{17 2 29 21 22 }\n{17 2 29 21 }\n{17 2 29 22 }\n{17 2 29 }\n{17 2 21 22 }\n{17 2 21 }\n{17 2 22 }\n{17 2 }\n{17 29 21 22 }\n{17 29 21 }\n{17 29 22 }\n{17 29 }\n{17 21 22 }\n{17 21 }\n{17 22 }\n{17 }\n{2 29 21 22 }\n{2 29 21 }\n{2 29 22 }\n{2 29 }\n{2 21 22 }\n{2 21 }\n{2 22 }\n{2 }\n{29 21 22 }\n{29 21 }\n{29 22 }\n{29 }\n{21 22 }\n{21 }\n{22 }\n\nAll of them are unique and delete different set of indices. "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Inadvertently, I overlooked the statement asserting that \"Two subsets are distinct only if the selected indices for removal differ,\" resulting in a delay in resolving the logical issue at hand. Anyway, I only want to deal with Medium level question and this one was picked randomly from the list lol."
                    },
                    {
                        "username": "summer_2",
                        "content": "It\\'s clearly mentioned that we need to find out total number of subsets, then why solutions which are using bit masking to find SUBSEQUENCE works !?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "The reason behind this is due to a constraint that states, \"Two subsets can be considered different only if the chosen indices for deletion differ.\""
                    },
                    {
                        "username": "sindy",
                        "content": "Can someone tell me which subset is missing in testcase [8, 11, 17, 2, 25, 29, 21, 20, 4, 22]? Expected 39 but I got 38.\\n\\n[11]\\n[17]\\n[2]\\n[29]\\n[21]\\n[22]\\n\\n[22, 21]\\n[21, 29]\\n[22, 29]\\n[29, 2]\\n[21, 2]\\n[2, 17]\\n[29, 17]\\n[21, 17]\\n[22, 17]\\n[17, 11]\\n[2, 11]\\n[29, 11]\\n[21, 11]\\n\\n[22, 21, 29]\\n[21, 29, 2]\\n[22, 21, 17]\\n[21, 29, 17]\\n[22, 29, 17]\\n[29, 2, 17]\\n[21, 2, 17]\\n[21, 29, 11]\\n[29, 2, 11]\\n[21, 2, 11]\\n[2, 17, 11]\\n[29, 17, 11]\\n[21, 17, 11]\\n\\n[22, 21, 29, 17]\\n[21, 29, 2, 11]\\n[21, 29, 2, 11]\\n[21, 29, 17, 11]\\n[29, 2, 17, 11]\\n[21, 2, 17, 11]"
                    },
                    {
                        "username": "NISHANTH2004",
                        "content": "I tried this code in 6 programming languages its not running.. this one of the hardest problem i have ever seen.   "
                    },
                    {
                        "username": "colins",
                        "content": "Can anybody explain why we dont need to look at prime number large than 30? E.g. a product that is divisible by 31^2? Thanks!"
                    },
                    {
                        "username": "vtarakan",
                        "content": "Take any 2 numbers less than 30, say a and b.\\nBy fundamental theorem of arithmetics, a and b are products of some prime factors , where no factor is larger than a or b respectively. \\nInductively, this means that for any product of a1  * a2 *...* an,  we wont have any prime factor more than max(a1,a2...,an)<=30.\\n\\nReally the constraint of 30 on each factor + prime factorisation theorem is the magic here. If factors were larger, i dont see a tractable solution (yet?)"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The constraints say `1 <= nums[i] <= 30` so no individual number can have a prime factor larger than 30.\\n\\nWhy did you give 31^2 as an example? 31^2 is not a prime number since it\\'s obviously divisible by 31. You can\\'t get prime numbers by multiplying primes. So even if we have a subset like `{31,31}` or `{29,19}`, when we multiply all the elements we don\\'t need to check any larger primes."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Interesting fact is: This is a medium, and \\'Number of Island\\' is also a medium..."
                    },
                    {
                        "username": "shivansh961",
                        "content": "This is so annoying questions."
                    },
                    {
                        "username": "mhmakelvin",
                        "content": "Almost same problem as [1994. The Number of Good Subsets](https://leetcode.com/problems/the-number-of-good-subsets/) which is a hard."
                    },
                    {
                        "username": "KhacLong",
                        "content": "Nice problem. I think the hardest part is realize that this is dp + bitmasking, after that, it\\'s quite ez to implement"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "I got the solution eventually, but it\\'s hard to believe that both this question and today\\'s daily are considered \"medium\""
                    }
                ]
            },
            {
                "id": 1806867,
                "content": [
                    {
                        "username": "user1040JO",
                        "content": "This problem is either poorly worded or outright incorrect. Not sure I follow their logic for creating subsetss. Can anyone explain how [8,11,17,2,25,29,21,20,4,22] can lead to 39? Simple discrete maths would put the answer at 63. Of the 63 combinations, which values are they ignoring and what is the reasoning for ignoring them?\n\n{11 17 2 29 21 22 }\n{11 17 2 29 21 }\n{11 17 2 29 22 }\n{11 17 2 29 }\n{11 17 2 21 22 }\n{11 17 2 21 }\n{11 17 2 22 }\n{11 17 2 }\n{11 17 29 21 22 }\n{11 17 29 21 }\n{11 17 29 22 }\n{11 17 29 }\n{11 17 21 22 }\n{11 17 21 }\n{11 17 22 }\n{11 17 }\n{11 2 29 21 22 }\n{11 2 29 21 }\n{11 2 29 22 }\n{11 2 29 }\n{11 2 21 22 }\n{11 2 21 }\n{11 2 22 }\n{11 2 }\n{11 29 21 22 }\n{11 29 21 }\n{11 29 22 }\n{11 29 }\n{11 21 22 }\n{11 21 }\n{11 22 }\n{11 }\n{17 2 29 21 22 }\n{17 2 29 21 }\n{17 2 29 22 }\n{17 2 29 }\n{17 2 21 22 }\n{17 2 21 }\n{17 2 22 }\n{17 2 }\n{17 29 21 22 }\n{17 29 21 }\n{17 29 22 }\n{17 29 }\n{17 21 22 }\n{17 21 }\n{17 22 }\n{17 }\n{2 29 21 22 }\n{2 29 21 }\n{2 29 22 }\n{2 29 }\n{2 21 22 }\n{2 21 }\n{2 22 }\n{2 }\n{29 21 22 }\n{29 21 }\n{29 22 }\n{29 }\n{21 22 }\n{21 }\n{22 }\n\nAll of them are unique and delete different set of indices. "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Inadvertently, I overlooked the statement asserting that \"Two subsets are distinct only if the selected indices for removal differ,\" resulting in a delay in resolving the logical issue at hand. Anyway, I only want to deal with Medium level question and this one was picked randomly from the list lol."
                    },
                    {
                        "username": "summer_2",
                        "content": "It\\'s clearly mentioned that we need to find out total number of subsets, then why solutions which are using bit masking to find SUBSEQUENCE works !?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "The reason behind this is due to a constraint that states, \"Two subsets can be considered different only if the chosen indices for deletion differ.\""
                    },
                    {
                        "username": "sindy",
                        "content": "Can someone tell me which subset is missing in testcase [8, 11, 17, 2, 25, 29, 21, 20, 4, 22]? Expected 39 but I got 38.\\n\\n[11]\\n[17]\\n[2]\\n[29]\\n[21]\\n[22]\\n\\n[22, 21]\\n[21, 29]\\n[22, 29]\\n[29, 2]\\n[21, 2]\\n[2, 17]\\n[29, 17]\\n[21, 17]\\n[22, 17]\\n[17, 11]\\n[2, 11]\\n[29, 11]\\n[21, 11]\\n\\n[22, 21, 29]\\n[21, 29, 2]\\n[22, 21, 17]\\n[21, 29, 17]\\n[22, 29, 17]\\n[29, 2, 17]\\n[21, 2, 17]\\n[21, 29, 11]\\n[29, 2, 11]\\n[21, 2, 11]\\n[2, 17, 11]\\n[29, 17, 11]\\n[21, 17, 11]\\n\\n[22, 21, 29, 17]\\n[21, 29, 2, 11]\\n[21, 29, 2, 11]\\n[21, 29, 17, 11]\\n[29, 2, 17, 11]\\n[21, 2, 17, 11]"
                    },
                    {
                        "username": "NISHANTH2004",
                        "content": "I tried this code in 6 programming languages its not running.. this one of the hardest problem i have ever seen.   "
                    },
                    {
                        "username": "colins",
                        "content": "Can anybody explain why we dont need to look at prime number large than 30? E.g. a product that is divisible by 31^2? Thanks!"
                    },
                    {
                        "username": "vtarakan",
                        "content": "Take any 2 numbers less than 30, say a and b.\\nBy fundamental theorem of arithmetics, a and b are products of some prime factors , where no factor is larger than a or b respectively. \\nInductively, this means that for any product of a1  * a2 *...* an,  we wont have any prime factor more than max(a1,a2...,an)<=30.\\n\\nReally the constraint of 30 on each factor + prime factorisation theorem is the magic here. If factors were larger, i dont see a tractable solution (yet?)"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The constraints say `1 <= nums[i] <= 30` so no individual number can have a prime factor larger than 30.\\n\\nWhy did you give 31^2 as an example? 31^2 is not a prime number since it\\'s obviously divisible by 31. You can\\'t get prime numbers by multiplying primes. So even if we have a subset like `{31,31}` or `{29,19}`, when we multiply all the elements we don\\'t need to check any larger primes."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Interesting fact is: This is a medium, and \\'Number of Island\\' is also a medium..."
                    },
                    {
                        "username": "shivansh961",
                        "content": "This is so annoying questions."
                    },
                    {
                        "username": "mhmakelvin",
                        "content": "Almost same problem as [1994. The Number of Good Subsets](https://leetcode.com/problems/the-number-of-good-subsets/) which is a hard."
                    },
                    {
                        "username": "KhacLong",
                        "content": "Nice problem. I think the hardest part is realize that this is dp + bitmasking, after that, it\\'s quite ez to implement"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "I got the solution eventually, but it\\'s hard to believe that both this question and today\\'s daily are considered \"medium\""
                    }
                ]
            },
            {
                "id": 1806815,
                "content": [
                    {
                        "username": "user1040JO",
                        "content": "This problem is either poorly worded or outright incorrect. Not sure I follow their logic for creating subsetss. Can anyone explain how [8,11,17,2,25,29,21,20,4,22] can lead to 39? Simple discrete maths would put the answer at 63. Of the 63 combinations, which values are they ignoring and what is the reasoning for ignoring them?\n\n{11 17 2 29 21 22 }\n{11 17 2 29 21 }\n{11 17 2 29 22 }\n{11 17 2 29 }\n{11 17 2 21 22 }\n{11 17 2 21 }\n{11 17 2 22 }\n{11 17 2 }\n{11 17 29 21 22 }\n{11 17 29 21 }\n{11 17 29 22 }\n{11 17 29 }\n{11 17 21 22 }\n{11 17 21 }\n{11 17 22 }\n{11 17 }\n{11 2 29 21 22 }\n{11 2 29 21 }\n{11 2 29 22 }\n{11 2 29 }\n{11 2 21 22 }\n{11 2 21 }\n{11 2 22 }\n{11 2 }\n{11 29 21 22 }\n{11 29 21 }\n{11 29 22 }\n{11 29 }\n{11 21 22 }\n{11 21 }\n{11 22 }\n{11 }\n{17 2 29 21 22 }\n{17 2 29 21 }\n{17 2 29 22 }\n{17 2 29 }\n{17 2 21 22 }\n{17 2 21 }\n{17 2 22 }\n{17 2 }\n{17 29 21 22 }\n{17 29 21 }\n{17 29 22 }\n{17 29 }\n{17 21 22 }\n{17 21 }\n{17 22 }\n{17 }\n{2 29 21 22 }\n{2 29 21 }\n{2 29 22 }\n{2 29 }\n{2 21 22 }\n{2 21 }\n{2 22 }\n{2 }\n{29 21 22 }\n{29 21 }\n{29 22 }\n{29 }\n{21 22 }\n{21 }\n{22 }\n\nAll of them are unique and delete different set of indices. "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Inadvertently, I overlooked the statement asserting that \"Two subsets are distinct only if the selected indices for removal differ,\" resulting in a delay in resolving the logical issue at hand. Anyway, I only want to deal with Medium level question and this one was picked randomly from the list lol."
                    },
                    {
                        "username": "summer_2",
                        "content": "It\\'s clearly mentioned that we need to find out total number of subsets, then why solutions which are using bit masking to find SUBSEQUENCE works !?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "The reason behind this is due to a constraint that states, \"Two subsets can be considered different only if the chosen indices for deletion differ.\""
                    },
                    {
                        "username": "sindy",
                        "content": "Can someone tell me which subset is missing in testcase [8, 11, 17, 2, 25, 29, 21, 20, 4, 22]? Expected 39 but I got 38.\\n\\n[11]\\n[17]\\n[2]\\n[29]\\n[21]\\n[22]\\n\\n[22, 21]\\n[21, 29]\\n[22, 29]\\n[29, 2]\\n[21, 2]\\n[2, 17]\\n[29, 17]\\n[21, 17]\\n[22, 17]\\n[17, 11]\\n[2, 11]\\n[29, 11]\\n[21, 11]\\n\\n[22, 21, 29]\\n[21, 29, 2]\\n[22, 21, 17]\\n[21, 29, 17]\\n[22, 29, 17]\\n[29, 2, 17]\\n[21, 2, 17]\\n[21, 29, 11]\\n[29, 2, 11]\\n[21, 2, 11]\\n[2, 17, 11]\\n[29, 17, 11]\\n[21, 17, 11]\\n\\n[22, 21, 29, 17]\\n[21, 29, 2, 11]\\n[21, 29, 2, 11]\\n[21, 29, 17, 11]\\n[29, 2, 17, 11]\\n[21, 2, 17, 11]"
                    },
                    {
                        "username": "NISHANTH2004",
                        "content": "I tried this code in 6 programming languages its not running.. this one of the hardest problem i have ever seen.   "
                    },
                    {
                        "username": "colins",
                        "content": "Can anybody explain why we dont need to look at prime number large than 30? E.g. a product that is divisible by 31^2? Thanks!"
                    },
                    {
                        "username": "vtarakan",
                        "content": "Take any 2 numbers less than 30, say a and b.\\nBy fundamental theorem of arithmetics, a and b are products of some prime factors , where no factor is larger than a or b respectively. \\nInductively, this means that for any product of a1  * a2 *...* an,  we wont have any prime factor more than max(a1,a2...,an)<=30.\\n\\nReally the constraint of 30 on each factor + prime factorisation theorem is the magic here. If factors were larger, i dont see a tractable solution (yet?)"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The constraints say `1 <= nums[i] <= 30` so no individual number can have a prime factor larger than 30.\\n\\nWhy did you give 31^2 as an example? 31^2 is not a prime number since it\\'s obviously divisible by 31. You can\\'t get prime numbers by multiplying primes. So even if we have a subset like `{31,31}` or `{29,19}`, when we multiply all the elements we don\\'t need to check any larger primes."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Interesting fact is: This is a medium, and \\'Number of Island\\' is also a medium..."
                    },
                    {
                        "username": "shivansh961",
                        "content": "This is so annoying questions."
                    },
                    {
                        "username": "mhmakelvin",
                        "content": "Almost same problem as [1994. The Number of Good Subsets](https://leetcode.com/problems/the-number-of-good-subsets/) which is a hard."
                    },
                    {
                        "username": "KhacLong",
                        "content": "Nice problem. I think the hardest part is realize that this is dp + bitmasking, after that, it\\'s quite ez to implement"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "I got the solution eventually, but it\\'s hard to believe that both this question and today\\'s daily are considered \"medium\""
                    }
                ]
            },
            {
                "id": 1806731,
                "content": [
                    {
                        "username": "user1040JO",
                        "content": "This problem is either poorly worded or outright incorrect. Not sure I follow their logic for creating subsetss. Can anyone explain how [8,11,17,2,25,29,21,20,4,22] can lead to 39? Simple discrete maths would put the answer at 63. Of the 63 combinations, which values are they ignoring and what is the reasoning for ignoring them?\n\n{11 17 2 29 21 22 }\n{11 17 2 29 21 }\n{11 17 2 29 22 }\n{11 17 2 29 }\n{11 17 2 21 22 }\n{11 17 2 21 }\n{11 17 2 22 }\n{11 17 2 }\n{11 17 29 21 22 }\n{11 17 29 21 }\n{11 17 29 22 }\n{11 17 29 }\n{11 17 21 22 }\n{11 17 21 }\n{11 17 22 }\n{11 17 }\n{11 2 29 21 22 }\n{11 2 29 21 }\n{11 2 29 22 }\n{11 2 29 }\n{11 2 21 22 }\n{11 2 21 }\n{11 2 22 }\n{11 2 }\n{11 29 21 22 }\n{11 29 21 }\n{11 29 22 }\n{11 29 }\n{11 21 22 }\n{11 21 }\n{11 22 }\n{11 }\n{17 2 29 21 22 }\n{17 2 29 21 }\n{17 2 29 22 }\n{17 2 29 }\n{17 2 21 22 }\n{17 2 21 }\n{17 2 22 }\n{17 2 }\n{17 29 21 22 }\n{17 29 21 }\n{17 29 22 }\n{17 29 }\n{17 21 22 }\n{17 21 }\n{17 22 }\n{17 }\n{2 29 21 22 }\n{2 29 21 }\n{2 29 22 }\n{2 29 }\n{2 21 22 }\n{2 21 }\n{2 22 }\n{2 }\n{29 21 22 }\n{29 21 }\n{29 22 }\n{29 }\n{21 22 }\n{21 }\n{22 }\n\nAll of them are unique and delete different set of indices. "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Inadvertently, I overlooked the statement asserting that \"Two subsets are distinct only if the selected indices for removal differ,\" resulting in a delay in resolving the logical issue at hand. Anyway, I only want to deal with Medium level question and this one was picked randomly from the list lol."
                    },
                    {
                        "username": "summer_2",
                        "content": "It\\'s clearly mentioned that we need to find out total number of subsets, then why solutions which are using bit masking to find SUBSEQUENCE works !?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "The reason behind this is due to a constraint that states, \"Two subsets can be considered different only if the chosen indices for deletion differ.\""
                    },
                    {
                        "username": "sindy",
                        "content": "Can someone tell me which subset is missing in testcase [8, 11, 17, 2, 25, 29, 21, 20, 4, 22]? Expected 39 but I got 38.\\n\\n[11]\\n[17]\\n[2]\\n[29]\\n[21]\\n[22]\\n\\n[22, 21]\\n[21, 29]\\n[22, 29]\\n[29, 2]\\n[21, 2]\\n[2, 17]\\n[29, 17]\\n[21, 17]\\n[22, 17]\\n[17, 11]\\n[2, 11]\\n[29, 11]\\n[21, 11]\\n\\n[22, 21, 29]\\n[21, 29, 2]\\n[22, 21, 17]\\n[21, 29, 17]\\n[22, 29, 17]\\n[29, 2, 17]\\n[21, 2, 17]\\n[21, 29, 11]\\n[29, 2, 11]\\n[21, 2, 11]\\n[2, 17, 11]\\n[29, 17, 11]\\n[21, 17, 11]\\n\\n[22, 21, 29, 17]\\n[21, 29, 2, 11]\\n[21, 29, 2, 11]\\n[21, 29, 17, 11]\\n[29, 2, 17, 11]\\n[21, 2, 17, 11]"
                    },
                    {
                        "username": "NISHANTH2004",
                        "content": "I tried this code in 6 programming languages its not running.. this one of the hardest problem i have ever seen.   "
                    },
                    {
                        "username": "colins",
                        "content": "Can anybody explain why we dont need to look at prime number large than 30? E.g. a product that is divisible by 31^2? Thanks!"
                    },
                    {
                        "username": "vtarakan",
                        "content": "Take any 2 numbers less than 30, say a and b.\\nBy fundamental theorem of arithmetics, a and b are products of some prime factors , where no factor is larger than a or b respectively. \\nInductively, this means that for any product of a1  * a2 *...* an,  we wont have any prime factor more than max(a1,a2...,an)<=30.\\n\\nReally the constraint of 30 on each factor + prime factorisation theorem is the magic here. If factors were larger, i dont see a tractable solution (yet?)"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The constraints say `1 <= nums[i] <= 30` so no individual number can have a prime factor larger than 30.\\n\\nWhy did you give 31^2 as an example? 31^2 is not a prime number since it\\'s obviously divisible by 31. You can\\'t get prime numbers by multiplying primes. So even if we have a subset like `{31,31}` or `{29,19}`, when we multiply all the elements we don\\'t need to check any larger primes."
                    },
                    {
                        "username": "EthanLi0203",
                        "content": "Interesting fact is: This is a medium, and \\'Number of Island\\' is also a medium..."
                    },
                    {
                        "username": "shivansh961",
                        "content": "This is so annoying questions."
                    },
                    {
                        "username": "mhmakelvin",
                        "content": "Almost same problem as [1994. The Number of Good Subsets](https://leetcode.com/problems/the-number-of-good-subsets/) which is a hard."
                    },
                    {
                        "username": "KhacLong",
                        "content": "Nice problem. I think the hardest part is realize that this is dp + bitmasking, after that, it\\'s quite ez to implement"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "I got the solution eventually, but it\\'s hard to believe that both this question and today\\'s daily are considered \"medium\""
                    }
                ]
            }
        ]
    }
]