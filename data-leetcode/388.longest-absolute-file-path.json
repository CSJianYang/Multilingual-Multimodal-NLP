[
    {
        "title": "Merge Sorted Array",
        "question_content": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\n&nbsp;\nExample 1:\n\nInput: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\nOutput: [1,2,2,3,5,6]\nExplanation: The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.\n\nExample 2:\n\nInput: nums1 = [1], m = 1, nums2 = [], n = 0\nOutput: [1]\nExplanation: The arrays we are merging are [1] and [].\nThe result of the merge is [1].\n\nExample 3:\n\nInput: nums1 = [0], m = 0, nums2 = [1], n = 1\nOutput: [1]\nExplanation: The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\n\n&nbsp;\nConstraints:\n\n\tnums1.length == m + n\n\tnums2.length == n\n\t0 <= m, n <= 200\n\t1 <= m + n <= 200\n\t-109 <= nums1[i], nums2[j] <= 109\n\n&nbsp;\nFollow up: Can you come up with an algorithm that runs in O(m + n) time?",
        "solutions": [
            {
                "id": 29522,
                "title": "this-is-my-ac-code-may-help-you",
                "content": "The signature of the function has been changed by Leetcode Team, So I update the solution to this:\\n   \\n   ```\\n   class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1, j = n - 1, k = m + n - 1;\\n        while(i >= 0 and j >= 0) {\\n            if(nums1[i] < nums2[j]) {\\n                nums1[k--] = nums2[j--];\\n            } else {\\n                nums1[k--] = nums1[i--];\\n            }\\n        }\\n        while(j >= 0) {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n};\\n```\\n\\nSolution in 2012:\\n\\n```\\n   class Solution {\\n    public:\\n        void merge(int A[], int m, int B[], int n) {\\n            int i=m-1;\\n    \\t\\tint j=n-1;\\n    \\t\\tint k = m+n-1;\\n    \\t\\twhile(i >=0 && j>=0)\\n    \\t\\t{\\n    \\t\\t\\tif(A[i] > B[j])\\n    \\t\\t\\t\\tA[k--] = A[i--];\\n    \\t\\t\\telse\\n    \\t\\t\\t\\tA[k--] = B[j--];\\n    \\t\\t}\\n    \\t\\twhile(j>=0)\\n    \\t\\t\\tA[k--] = B[j--];\\n        }\\n    };\\n\\t```",
                "solutionTags": [],
                "code": "```\\n   class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1, j = n - 1, k = m + n - 1;\\n        while(i >= 0 and j >= 0) {\\n            if(nums1[i] < nums2[j]) {\\n                nums1[k--] = nums2[j--];\\n            } else {\\n                nums1[k--] = nums1[i--];\\n            }\\n        }\\n        while(j >= 0) {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n};\\n```\n```\\n   class Solution {\\n    public:\\n        void merge(int A[], int m, int B[], int n) {\\n            int i=m-1;\\n    \\t\\tint j=n-1;\\n    \\t\\tint k = m+n-1;\\n    \\t\\twhile(i >=0 && j>=0)\\n    \\t\\t{\\n    \\t\\t\\tif(A[i] > B[j])\\n    \\t\\t\\t\\tA[k--] = A[i--];\\n    \\t\\t\\telse\\n    \\t\\t\\t\\tA[k--] = B[j--];\\n    \\t\\t}\\n    \\t\\twhile(j>=0)\\n    \\t\\t\\tA[k--] = B[j--];\\n        }\\n    };\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3436053,
                "title": "beats-100-best-c-java-python-and-javascript-solution-two-pointer-stl",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nWe are given two sorted arrays nums1 and nums2 of sizes m and n, respectively. We need to merge these two arrays into a single sorted array, and the result should be stored inside nums1. Since nums1 is of size m+n, we can use this extra space to store the merged array. We can iterate through the arrays from the end and place the larger element in the end of nums1.\\n\\n---\\n# Approach : ***Using STL***\\n1. Traverse through nums2 and append its elements to the end of nums1 starting from index m.\\n2. Sort the entire nums1 array using sort() function.\\n\\n# Complexity\\n- Time complexity: O((m+n)log(m+n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n> *due to the sort() function*\\n\\n- Space complexity: O(1)\\n> *We are not using any extra space, so the space complexity is O(1).*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        for (int j = 0, i = m; j<n; j++){\\n            nums1[i] = nums2[j];\\n            i++;\\n        }\\n        sort(nums1.begin(),nums1.end());\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for (int j = 0, i = m; j < n; j++) {\\n            nums1[i] = nums2[j];\\n            i++;\\n        }\\n        Arrays.sort(nums1);\\n    }\\n}\\n\\n\\n```\\n```python []\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n      for j in range(n):\\n          nums1[m+j] = nums2[j]\\n      nums1.sort()\\n\\n```\\n```javascript []\\nvar merge = function(nums1, m, nums2, n) {\\n    for (let i = m, j = 0; j < n; i++, j++) {\\n        nums1[i] = nums2[j];\\n    }\\n    nums1.sort((a, b) => a - b);\\n};\\n\\n```\\n\\n---\\n\\n\\n\\n# Approach : ***Two Pointer***\\n<!-- Describe your approach to solving the problem. -->\\n\\nWe can start with two pointers i and j, initialized to m-1 and n-1, respectively. We will also have another pointer k initialized to m+n-1, which will be used to keep track of the position in nums1 where we will be placing the larger element. Then we can start iterating from the end of the arrays i and j, and compare the elements at these positions. We will place the larger element in nums1 at position k, and decrement the corresponding pointer i or j accordingly. We will continue doing this until we have iterated through all the elements in nums2. If there are still elements left in nums1, we don\\'t need to do anything because they are already in their correct place.\\n\\n# Complexity\\n- Time complexity: O(m+n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n> *We are iterating through both arrays once, so the time complexity is O(m+n).*\\n\\n- Space complexity: O(1)\\n> *We are not using any extra space, so the space complexity is O(1).*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1;\\n        int j = n - 1;\\n        int k = m + n - 1;\\n        \\n        while (j >= 0) {\\n            if (i >= 0 && nums1[i] > nums2[j]) {\\n                nums1[k--] = nums1[i--];\\n            } else {\\n                nums1[k--] = nums2[j--];\\n            }\\n        }\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m - 1;\\n        int j = n - 1;\\n        int k = m + n - 1;\\n        \\n        while (j >= 0) {\\n            if (i >= 0 && nums1[i] > nums2[j]) {\\n                nums1[k--] = nums1[i--];\\n            } else {\\n                nums1[k--] = nums2[j--];\\n            }\\n        }\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        i = m - 1\\n        j = n - 1\\n        k = m + n - 1\\n        \\n        while j >= 0:\\n            if i >= 0 and nums1[i] > nums2[j]:\\n                nums1[k] = nums1[i]\\n                i -= 1\\n            else:\\n                nums1[k] = nums2[j]\\n                j -= 1\\n            k -= 1\\n\\n```\\n```javascript []\\nvar merge = function(nums1, m, nums2, n) {\\n    let i = m - 1;\\n    let j = n - 1;\\n    let k = m + n - 1;\\n    \\n    while (j >= 0) {\\n        if (i >= 0 && nums1[i] > nums2[j]) {\\n            nums1[k--] = nums1[i--];\\n        } else {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n};\\n```\\n\\n\\n---\\n\\n![upvote.jpeg](https://assets.leetcode.com/users/images/c820c5fe-b23b-4706-96ff-a73382fb2d7f_1681930936.4185076.jpeg)\\n\\n---\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        for (int j = 0, i = m; j<n; j++){\\n            nums1[i] = nums2[j];\\n            i++;\\n        }\\n        sort(nums1.begin(),nums1.end());\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for (int j = 0, i = m; j < n; j++) {\\n            nums1[i] = nums2[j];\\n            i++;\\n        }\\n        Arrays.sort(nums1);\\n    }\\n}\\n\\n\\n```\n```python []\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n      for j in range(n):\\n          nums1[m+j] = nums2[j]\\n      nums1.sort()\\n\\n```\n```javascript []\\nvar merge = function(nums1, m, nums2, n) {\\n    for (let i = m, j = 0; j < n; i++, j++) {\\n        nums1[i] = nums2[j];\\n    }\\n    nums1.sort((a, b) => a - b);\\n};\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1;\\n        int j = n - 1;\\n        int k = m + n - 1;\\n        \\n        while (j >= 0) {\\n            if (i >= 0 && nums1[i] > nums2[j]) {\\n                nums1[k--] = nums1[i--];\\n            } else {\\n                nums1[k--] = nums2[j--];\\n            }\\n        }\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m - 1;\\n        int j = n - 1;\\n        int k = m + n - 1;\\n        \\n        while (j >= 0) {\\n            if (i >= 0 && nums1[i] > nums2[j]) {\\n                nums1[k--] = nums1[i--];\\n            } else {\\n                nums1[k--] = nums2[j--];\\n            }\\n        }\\n    }\\n}\\n\\n```\n```python []\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        i = m - 1\\n        j = n - 1\\n        k = m + n - 1\\n        \\n        while j >= 0:\\n            if i >= 0 and nums1[i] > nums2[j]:\\n                nums1[k] = nums1[i]\\n                i -= 1\\n            else:\\n                nums1[k] = nums2[j]\\n                j -= 1\\n            k -= 1\\n\\n```\n```javascript []\\nvar merge = function(nums1, m, nums2, n) {\\n    let i = m - 1;\\n    let j = n - 1;\\n    let k = m + n - 1;\\n    \\n    while (j >= 0) {\\n        if (i >= 0 && nums1[i] > nums2[j]) {\\n            nums1[k--] = nums1[i--];\\n        } else {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29503,
                "title": "beautiful-python-solution",
                "content": "    def merge(self, nums1, m, nums2, n):\\n            while m > 0 and n > 0:\\n                if nums1[m-1] >= nums2[n-1]:\\n                    nums1[m+n-1] = nums1[m-1]\\n                    m -= 1\\n                else:\\n                    nums1[m+n-1] = nums2[n-1]\\n                    n -= 1\\n            if n > 0:\\n                nums1[:n] = nums2[:n]",
                "solutionTags": [],
                "code": "    def merge(self, nums1, m, nums2, n):\\n            while m > 0 and n > 0:\\n                if nums1[m-1] >= nums2[n-1]:\\n                    nums1[m+n-1] = nums1[m-1]\\n                    m -= 1\\n                else:\\n                    nums1[m+n-1] = nums2[n-1]\\n                    n -= 1\\n            if n > 0:\\n                nums1[:n] = nums2[:n]",
                "codeTag": "Python3"
            },
            {
                "id": 3186051,
                "title": "best-c-2-solution-two-pointers-sorting-brute-force-optimize-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Array + Sorting. (Brute Force Approach).\\n2. Solved using Array + Two Pointers. (Optimize Approach).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(MlogM), Sorting the array(nums1) costs O(MlogM). Where M is the size of the\\n    Array(nums1).\\n\\n    Space Complexity : O(1), Constant Space. \\n\\n    Solved using Array + Sorting.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        for(int i=0; i<n; i++){\\n            nums1[m+i] = nums2[i];\\n        }\\n        sort(nums1.begin(), nums1.end());\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N+M), Because we iterate N+M times for both the Array(nums1 and nums2). Where\\n    M is the number of elements in Array(nums1) and N is the number of elements in Array(nums2).\\n\\n    Space Complexity : O(1), Constant Space. \\n\\n    Solved using Array + Two Pointers. \\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m-1;\\n        int j = n-1;\\n        int k = m+n-1;\\n        while(i>=0 && j>=0){\\n            if(nums1[i] > nums2[j]){\\n                nums1[k] = nums1[i];\\n                i--; k--;\\n            }\\n            else{\\n                nums1[k] = nums2[j];\\n                j--; k--;\\n            }\\n        }\\n        while(j>=0){\\n            nums1[k] = nums2[j];\\n            j--; k--;\\n        }\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(MlogM), Sorting the array(nums1) costs O(MlogM). Where M is the size of the\\n    Array(nums1).\\n\\n    Space Complexity : O(1), Constant Space. \\n\\n    Solved using Array + Sorting.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        for(int i=0; i<n; i++){\\n            nums1[m+i] = nums2[i];\\n        }\\n        sort(nums1.begin(), nums1.end());\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N+M), Because we iterate N+M times for both the Array(nums1 and nums2). Where\\n    M is the number of elements in Array(nums1) and N is the number of elements in Array(nums2).\\n\\n    Space Complexity : O(1), Constant Space. \\n\\n    Solved using Array + Two Pointers. \\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m-1;\\n        int j = n-1;\\n        int k = m+n-1;\\n        while(i>=0 && j>=0){\\n            if(nums1[i] > nums2[j]){\\n                nums1[k] = nums1[i];\\n                i--; k--;\\n            }\\n            else{\\n                nums1[k] = nums2[j];\\n                j--; k--;\\n            }\\n        }\\n        while(j>=0){\\n            nums1[k] = nums2[j];\\n            j--; k--;\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29704,
                "title": "my-clean-java-solution",
                "content": "Thanks @der for the idea of solving from the end, which avoid extra moving manipulation.\\n\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int tail1 = m - 1, tail2 = n - 1, finished = m + n - 1;\\n        while (tail1 >= 0 && tail2 >= 0) {\\n            nums1[finished--] = (nums1[tail1] > nums2[tail2]) ? \\n                                 nums1[tail1--] : nums2[tail2--];\\n        }\\n\\n        while (tail2 >= 0) { //only need to combine with remaining nums2, if any\\n            nums1[finished--] = nums2[tail2--];\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Thanks @der for the idea of solving from the end, which avoid extra moving manipulation.\\n\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int tail1 = m - 1, tail2 = n - 1, finished = m + n - 1;\\n        while (tail1 >= 0 && tail2 >= 0) {\\n            nums1[finished--] = (nums1[tail1] > nums2[tail2]) ? \\n                                 nums1[tail1--] : nums2[tail2--];\\n        }\\n\\n        while (tail2 >= 0) { //only need to combine with remaining nums2, if any\\n            nums1[finished--] = nums2[tail2--];\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1189409,
                "title": "my-java-solution",
                "content": "**The logic is written using the Two-Pointer Approach \\nBasically the main logic behind this approach is to start filling the from the largest element at the back of the array given to us.**\\n\\nLet\\u2019s consider an Example:                                                         \\n![image](https://assets.leetcode.com/users/images/7b67174e-1593-4897-8ba7-b674f0a8814c_1620047705.8573153.png)\\n\\nInitially p1 = m-1 , p2 = n-1 , i = m+n-1 \\nSo lets takes two pointers that mark the end of 2 arrays  and  i ,that would be the index at which we are going to write the value , now we will compare the values  at p1 and p2 and write the value that is larger at index i , after writing we decrement the respective indexes .\\nAnd the another edge case is that if any one of the array is empty arr[i] = [0] , index  i-1  and another one is arr[j] = [1,2,3] , index = j-1\\nSo if we consider the index as i-1 then it becomes  negative , which is ArrayIndexOutOfBounds ,so we have to take index >=0 .\\n\\n```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int p1 = m-1 , p2 = n-1 ,i = m+n-1;\\n        while(p2 >=0 ){\\n            if(p1 >=0 && nums1[p1] > nums2[p2]){\\n                nums1[i--] = nums1[p1--];\\n            } \\n            else{\\n                nums1[i--] = nums2[p2--];\\n            }\\n        }\\n       }\\n}\\n```\\nPlease Upvote if you understand it easily.\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int p1 = m-1 , p2 = n-1 ,i = m+n-1;\\n        while(p2 >=0 ){\\n            if(p1 >=0 && nums1[p1] > nums2[p2]){\\n                nums1[i--] = nums1[p1--];\\n            } \\n            else{\\n                nums1[i--] = nums2[p2--];\\n            }\\n        }\\n       }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1176400,
                "title": "best-python-solution-faster-than-99-one-loop-no-splicing-no-special-case-loop",
                "content": "I was super confused why many solutions had a final check for a special case. This is in-place, and doesn\\'t have a weird final loop to deal with any special cases.\\n```\\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n\\ta, b, write_index = m-1, n-1, m + n - 1\\n\\n\\twhile b >= 0:\\n\\t\\tif a >= 0 and nums1[a] > nums2[b]:\\n\\t\\t\\tnums1[write_index] = nums1[a]\\n\\t\\t\\ta -= 1\\n\\t\\telse:\\n\\t\\t\\tnums1[write_index] = nums2[b]\\n\\t\\t\\tb -= 1\\n\\n\\t\\twrite_index -= 1\\n```\\n\\n*Note: edited since the variable names changed in the question*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n\\ta, b, write_index = m-1, n-1, m + n - 1\\n\\n\\twhile b >= 0:\\n\\t\\tif a >= 0 and nums1[a] > nums2[b]:\\n\\t\\t\\tnums1[write_index] = nums1[a]\\n\\t\\t\\ta -= 1\\n\\t\\telse:\\n\\t\\t\\tnums1[write_index] = nums2[b]\\n\\t\\t\\tb -= 1\\n\\n\\t\\twrite_index -= 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 600243,
                "title": "c-solution-o-m-n-solution-with-detailed-explanation",
                "content": "```\\nThe way to think about the solution is that we will have to do a reverse sorting.\\nWe initialize k=m+n-1 as that will be the last location of nums1.\\nWe will keep checking for the greater element of the two arrays(i=m-1,j=n-1) and insert the values.\\nnums1 = [1,2,3,0,0,0], m = 3\\nnums2 = [2,5,6],       n = 3\\n\\nnums1 = [1,2,3,0,0,0]\\n             |     |\\n             i     k\\n\\nnums2 = [2,5,6]\\n             |\\n             j\\nnums2[j]>nums1[i] thus nums1[k]=6\\nk and j are decremented.\\n\\nnums1 = [1,2,3,0,0,6]\\n             |     |\\n             i     k\\n\\nnums2 = [2,5,6]\\n           |\\n           j\\nnums2[j]>nums1[i] thus nums1[k]=5\\nk and j are decremented.\\n\\nnums1 = [1,2,3,0,5,6]\\n             |   |\\n             i   k\\n\\nnums2 = [2,5,6]\\n         |\\n         j\\nWe keep following up this procedure and we get the desired reult.\\n\\n\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=m-1,j=n-1,k=m+n-1;\\n        while(i>=0&&j>=0)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                nums1[k]=nums1[i];\\n                i--;\\n                k--;\\n            }\\n            else\\n            {\\n                nums1[k]=nums2[j];\\n                j--;\\n                k--;\\n            }\\n        }\\n        while(i>=0)\\n            nums1[k--]=nums1[i--];\\n        while(j>=0)\\n            nums1[k--]=nums2[j--];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nThe way to think about the solution is that we will have to do a reverse sorting.\\nWe initialize k=m+n-1 as that will be the last location of nums1.\\nWe will keep checking for the greater element of the two arrays(i=m-1,j=n-1) and insert the values.\\nnums1 = [1,2,3,0,0,0], m = 3\\nnums2 = [2,5,6],       n = 3\\n\\nnums1 = [1,2,3,0,0,0]\\n             |     |\\n             i     k\\n\\nnums2 = [2,5,6]\\n             |\\n             j\\nnums2[j]>nums1[i] thus nums1[k]=6\\nk and j are decremented.\\n\\nnums1 = [1,2,3,0,0,6]\\n             |     |\\n             i     k\\n\\nnums2 = [2,5,6]\\n           |\\n           j\\nnums2[j]>nums1[i] thus nums1[k]=5\\nk and j are decremented.\\n\\nnums1 = [1,2,3,0,5,6]\\n             |   |\\n             i   k\\n\\nnums2 = [2,5,6]\\n         |\\n         j\\nWe keep following up this procedure and we get the desired reult.\\n\\n\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=m-1,j=n-1,k=m+n-1;\\n        while(i>=0&&j>=0)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                nums1[k]=nums1[i];\\n                i--;\\n                k--;\\n            }\\n            else\\n            {\\n                nums1[k]=nums2[j];\\n                j--;\\n                k--;\\n            }\\n        }\\n        while(i>=0)\\n            nums1[k--]=nums1[i--];\\n        while(j>=0)\\n            nums1[k--]=nums2[j--];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29515,
                "title": "4ms-c-solution-with-single-loop",
                "content": "This code relies on the simple observation that once all of the numbers from `nums2` have been merged into `nums1`, the rest of the numbers in `nums1` that were not moved are already in the correct place.\\n\\n    class Solution {\\n    public:\\n        void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n            int i = m - 1, j = n - 1, tar = m + n - 1;\\n            while (j >= 0) {\\n                nums1[tar--] = i >= 0 && nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n            int i = m - 1, j = n - 1, tar = m + n - 1;\\n            while (j >= 0) {\\n                nums1[tar--] = i >= 0 && nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 29614,
                "title": "c-solution-runtime-o-n-in-place-easy-to-understand",
                "content": "The idea is to go from the last indexes of both arrays, compare and put elements from either A or B to the final position, which can easily get since we know that A have enough space to store them all and we know size of A and B. Please refer to the comments for details.\\n\\n    class Solution {\\n    public:\\n        void merge(int A[], int m, int B[], int n) {\\n            \\n            int a=m-1;\\n            int b=n-1;\\n            int i=m+n-1;    // calculate the index of the last element of the merged array\\n            \\n            // go from the back by A and B and compare and put to the A element which is larger\\n            while(a>=0 && b>=0){\\n                if(A[a]>B[b])   A[i--]=A[a--];\\n                else            A[i--]=B[b--];\\n            }\\n            \\n            // if B is longer than A just copy the rest of B to A location, otherwise no need to do anything\\n            while(b>=0)         A[i--]=B[b--];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void merge(int A[], int m, int B[], int n) {\\n            \\n            int a=m-1;\\n            int b=n-1;\\n            int i=m+n-1;    // calculate the index of the last element of the merged array\\n            \\n            // go from the back by A and B and compare and put to the A element which is larger\\n            while(a>=0 && b>=0){\\n                if(A[a]>B[b])   A[i--]=A[a--];\\n                else            A[i--]=B[b--];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3037315,
                "title": "fully-explained-java-code-with-approach-in-o-m-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will traverse nums2 array from the end (We are traversing nums2 array as it is given that nums1 array will always be greater than or equal to nums2 array and we will traverse nums2 array from end as the array is sorted and we need largest element to solve the problem).\\n\\nWe will compare the largest element of the nums2 array with the largest element of the nums1 array (stored at m-1 index).  \\n\\nThe largest element after comparing both the arrays will be stored at the end of nums1 array (at (nums1.length-1) index).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will use three variables i,j,k which will work as pointers.\\n\\n![leetcodemergesortedarrays.jpeg](https://assets.leetcode.com/users/images/6e9bad1b-c9f7-44e1-86f5-eaa834a74632_1673465370.762181.jpeg)\\n\\ni will point at (m-1) index of the nums1 array and holds the largest element of the nums1 array.\\nj will point at (n-1) index that is the last position of the nums2 array and holds the largest element of the nums2 array.\\nk will point at the last position of the nums1 array and we will insert the largest element after comparing both the arrays.\\n\\nWe will traverse the nums2 array and will check the 2 conditions : \\n1 : If index i is greater than 0 and also the element at i index of nums1 array is greater than the element at j index of nums2 array.\\nIf this condition is true, it means element at i index of nums1 array is largest among both the arrays and will be stored at last index/position of the nums1 array.\\nAfter this we will decrease the value of i as we have to compare the other element of nums1 array with element of nums2 array.\\nWe will also decrease the value of k as the last position is filled and now new position is needed.\\n2 : If condition 1 fails, it means that either the element at j index of nums2 array is greater than the element at i index of nums1 array or there is no element left to compare with the nums1 array and we just have to push the elements of nums2 array in the nums1 array (They are the remaining smallest elements).\\nWe will decrease the value of j for other comparisons and also the value of k to store other elements.\\n\\n# Complexity\\n- Time complexity: O(m+n) as we are inserting m+n elements in the nums1 array.\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) no extra space required.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        //variables to work as pointers\\n        int i=m-1; // will point at m-1 index of nums1 array\\n        int j=n-1; // will point at n-1 index of nums2 array\\n        int k=nums1.length-1; //will point at the last position of the nums1 array\\n\\n        // Now traversing the nums2 array\\n        while(j>=0){\\n            // If element at i index of nums1 > element at j index of nums2\\n            // then it is largest among two arrays and will be stored at k position of nums1\\n            // using i>=0 to make sure we have elements to compare in nums1 array\\n            if(i>=0 && nums1[i]>nums2[j]){\\n                nums1[k]=nums1[i];\\n                k--; \\n                i--; //updating pointer for further comparisons\\n            }else{\\n                // element at j index of nums2 array is greater than the element at i index of nums1 array \\n                // or there is no element left to compare with the nums1 array \\n                // and we just have to push the elements of nums2 array in the nums1 array.\\n                nums1[k] = nums2[j];\\n                k--; \\n                j--; //updating pointer for further comparisons\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        //variables to work as pointers\\n        int i=m-1; // will point at m-1 index of nums1 array\\n        int j=n-1; // will point at n-1 index of nums2 array\\n        int k=nums1.length-1; //will point at the last position of the nums1 array\\n\\n        // Now traversing the nums2 array\\n        while(j>=0){\\n            // If element at i index of nums1 > element at j index of nums2\\n            // then it is largest among two arrays and will be stored at k position of nums1\\n            // using i>=0 to make sure we have elements to compare in nums1 array\\n            if(i>=0 && nums1[i]>nums2[j]){\\n                nums1[k]=nums1[i];\\n                k--; \\n                i--; //updating pointer for further comparisons\\n            }else{\\n                // element at j index of nums2 array is greater than the element at i index of nums1 array \\n                // or there is no element left to compare with the nums1 array \\n                // and we just have to push the elements of nums2 array in the nums1 array.\\n                nums1[k] = nums2[j];\\n                k--; \\n                j--; //updating pointer for further comparisons\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120234,
                "title": "visual-explanation-o-1-space-java",
                "content": "### Logic\\nWe\\'d like to attempt this question in-place because all the space we need is already provided by our first array; there\\'s no need to create extra space. We\\'d like to use a two-pointer approach but it can get quite messy dealing with certain cases. Since our extra space starts at the end of the first array, let\\'s see if we can do this by iterating backwards! \\n\\n**Three Pointers:**\\nLet\\'s use three pointers for this operation:\\n* The main pointer, `i`, will be starting from the end of the first array and will work its way to index 0.\\n* The pointer for the first array, `a`, and;\\n* The pointer for the second array, `b`, will be used for comparing the two sorted arrays and deciding what value to place at `i` next.\\n\\nWe\\'ll decide which value at index `a` or `b` is larger, place that value at index `i`, and decrement either `a` or `b` depending on which was larger. This sounds a bit confusing so I\\'ve illustrated below how this would work with two example arrays:\\n\\n![image](https://assets.leetcode.com/users/images/c677fb0a-96f3-4738-bbfa-28f6b4e3e97e_1654564101.5492318.png)\\n\\nI hope the above illustration sufficiently details the three pointer approach. In summary, we compare two values, pick the larger one, and move to the next comparison. The reason we move the pointer of the larger value is because we already know that that number is larger than (or equal to) ANY number that comes before it. So we can confidently place it at `i` and move on.\\n___\\n### But won\\'t some values at array A be overridden by the main pointer?\\nGood question! Yes you\\'re right; our `i` pointer will eventually land at values of `A` that are non-zero. Is this a problem? Turns out it isn\\'t. This is because we\\'re guaranteed to have already used those values at `A` before they become overridden. Think about it like this:\\n\\n`A` is of length `m+n`. All our meaningful values are the first `m` values. This means that the last `n` values are empty. Therefore, our `i` pointer needs to process the `nth` largest numbers in both arrays before overriding values at `A`. It\\'s not possible for `i` to override any unused values of `A` by the time it reaches `A`. \\n\\nLet\\'s consider the two extremes:\\n* If the `nth` largest values are all at `A`, our pointer `a` pointer will be moving with `i` so there\\'s no issues there. \\n* If the `nth` largest values are all at `B`, then our `b` pointer will trigger our exit condition \"`b >= 0`\" since our `b` pointer would be negative eventually. Therefore, `i` won\\'t get a chance to override values at `A`. \\n \\nIf this all sounds a bit confusing, don\\'t worry about it! Took me a while to get this explanation in order and if your interviewer expects you to spit this out in an interview, they don\\'t want to hire you haha.  \\n___\\n### Code\\nJust for clarity, the for loop initialises all three pointers and it maintains the `b >= 0` condition that\\'s necessary for our algorithm as aforementioned.\\nIf you have any questions, suggestions or improvements, feel free to let me know. Thanks for reading!\\n```java\\npublic void merge(int[] A, int m, int[] B, int n) {\\n\\tfor (int i = m+n-1, a = m-1, b = n-1; b>=0; i--) {\\n\\t\\tif (a >= 0 && A[a] > B[b]) A[i] = A[a--]; \\n\\t\\telse A[i] = B[b--];\\n\\t}        \\n}\\n```\\n**Time Complexity:** `O(n+m)` \\n**Space Complexity:** `O(1)`",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic void merge(int[] A, int m, int[] B, int n) {\\n\\tfor (int i = m+n-1, a = m-1, b = n-1; b>=0; i--) {\\n\\t\\tif (a >= 0 && A[a] > B[b]) A[i] = A[a--]; \\n\\t\\telse A[i] = B[b--];\\n\\t}        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2847423,
                "title": "runtime-0-ms-beats-100-c-java",
                "content": "\\nIf you Learned something new please give it upvote;\\notherwise thank you for having a look \\uD83D\\uDE4F\\uD83C\\uDFFB\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n\\n\\n```Java []\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i=m-1 , j=n-1 ;\\n        while(i>=0 && j>=0 ){\\n            if(nums1[i]>=nums2[j]){\\n                nums1[i+j+1]=nums1[i] ;\\n                i-- ;\\n                }else{\\n                    nums1[i+j+1]=nums2[j];\\n                    j-- ;\\n                }\\n        }\\n        while(j>=0){\\n                    nums1[j]=nums2[j];\\n                    j-- ;\\n                }\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\n        int i=m-1 , j=n-1 ;\\n        while(i>=0 && j>=0 ){\\n            if(nums1[i]>=nums2[j]){\\n                nums1[i+j+1]=nums1[i] ;\\n                i-- ;\\n                }else{\\n                    nums1[i+j+1]=nums2[j];\\n                    j-- ;\\n                }\\n        }\\n        while(j>=0){\\n                    nums1[j]=nums2[j];\\n                    j-- ;\\n                }      \\n    }\\n};\\n```\\n```Dart []\\nclass Solution {\\n  void merge(List<int> nums1, int m, List<int> nums2, int n) {\\n\\n      int i=m-1 , j=n-1 ;\\n        while(i>=0 && j>=0 ){\\n            if(nums1[i]>=nums2[j]){\\n                nums1[i+j+1]=nums1[i] ;\\n                i-- ;\\n                }else{\\n                    nums1[i+j+1]=nums2[j];\\n                    j-- ;\\n                }\\n        }\\n        while(j>=0){\\n                    nums1[j]=nums2[j];\\n                    j-- ;\\n                }\\n  }\\n}\\n```\\n\\n\\n\\n\\n\\n\\nPls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding :)\\n![images.jfif](https://assets.leetcode.com/users/images/d4b72d10-6e72-452b-92f1-43205a5af564_1675351797.5099416.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dart"
                ],
                "code": "```Java []\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i=m-1 , j=n-1 ;\\n        while(i>=0 && j>=0 ){\\n            if(nums1[i]>=nums2[j]){\\n                nums1[i+j+1]=nums1[i] ;\\n                i-- ;\\n                }else{\\n                    nums1[i+j+1]=nums2[j];\\n                    j-- ;\\n                }\\n        }\\n        while(j>=0){\\n                    nums1[j]=nums2[j];\\n                    j-- ;\\n                }\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\n        int i=m-1 , j=n-1 ;\\n        while(i>=0 && j>=0 ){\\n            if(nums1[i]>=nums2[j]){\\n                nums1[i+j+1]=nums1[i] ;\\n                i-- ;\\n                }else{\\n                    nums1[i+j+1]=nums2[j];\\n                    j-- ;\\n                }\\n        }\\n        while(j>=0){\\n                    nums1[j]=nums2[j];\\n                    j-- ;\\n                }      \\n    }\\n};\\n```\n```Dart []\\nclass Solution {\\n  void merge(List<int> nums1, int m, List<int> nums2, int n) {\\n\\n      int i=m-1 , j=n-1 ;\\n        while(i>=0 && j>=0 ){\\n            if(nums1[i]>=nums2[j]){\\n                nums1[i+j+1]=nums1[i] ;\\n                i-- ;\\n                }else{\\n                    nums1[i+j+1]=nums2[j];\\n                    j-- ;\\n                }\\n        }\\n        while(j>=0){\\n                    nums1[j]=nums2[j];\\n                    j-- ;\\n                }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2360538,
                "title": "easy-0-ms-100-fully-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution (Two Pointers Approach):**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Merge Sorted Array.\\n```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        // Initialize i and j to store indices of the last element of 1st and 2nd array respectively...\\n        int i = m - 1 , j = n - 1;\\n        // Initialize a variable k to store the last index of the 1st array...\\n        int k = m + n - 1;\\n        // Create a loop until either of i or j becomes zero...\\n        while(i >= 0 && j >= 0) {\\n            if(nums1[i] >= nums2[j]) {\\n                nums1[k] = nums1[i];\\n                i--;\\n            } else {\\n                nums1[k] = nums2[j];\\n                j--;\\n            }\\n            k--;\\n        // Either of i or j is not zero, which means some elements are yet to be merged.\\n        // Being already in a sorted manner, append them to the 1st array in the front.\\n        }\\n        // While i does not become zero...\\n        while(i >= 0)\\n            nums1[k--] = nums1[i--];\\n        // While j does not become zero...\\n        while(j >= 0)\\n            nums1[k--] = nums2[j--];\\n        // Now 1st array has all the elements in the required sorted order...\\n        return;\\n    }\\n}\\n```\\n\\n# **C++ Solution (Sorting Function Approach):**\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Merge Sorted Array.\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        // Here, nums1 =1st array, nums2 = 2nd array...\\n        for(int i = 0 ; i < n ; i++)\\n            nums1[i + m] = nums2[i];\\n            // Sort the 1st array...\\n            sort(nums1.begin() , nums1.end());\\n        // Print the required result...\\n        return;\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\nRuntime: 23 ms, faster than 89.40% of Python online submissions for Merge Sorted Array.\\n```\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        # Initialize nums1\\'s index\\n        i = m - 1\\n        # Initialize nums2\\'s index\\n        j = n - 1\\n        # Initialize a variable k to store the last index of the 1st array...\\n        k = m + n - 1\\n        while j >= 0:\\n            if i >= 0 and nums1[i] > nums2[j]:\\n                nums1[k] = nums1[i]\\n                k -= 1\\n                i -= 1\\n            else:\\n                nums1[k] = nums2[j]\\n                k -= 1\\n                j -= 1\\n```\\n                    \\n# **JavaScript Solution:**\\n```\\nvar merge = function(nums1, m, nums2, n) {\\n    // Initialize i and j to store indices of the last element of 1st and 2nd array respectively...\\n    let i = m - 1 , j = n - 1;\\n    // Initialize a variable k to store the last index of the 1st array...\\n    let k = m + n - 1;\\n    // Create a loop until either of i or j becomes zero...\\n    while(i >= 0 && j >= 0) {\\n        if(nums1[i] >= nums2[j]) {\\n            nums1[k] = nums1[i];\\n            i--;\\n        } else {\\n            nums1[k] = nums2[j];\\n            j--;\\n        }\\n        k--;\\n    // Either of i or j is not zero, which means some elements are yet to be merged.\\n    // Being already in a sorted manner, append them to the 1st array in the front.\\n    }\\n    // While i does not become zero...\\n    while(i >= 0)\\n        nums1[k--] = nums1[i--];\\n    // While j does not become zero...\\n    while(j >= 0)\\n        nums1[k--] = nums2[j--];\\n    // Now 1st array has all the elements in the required sorted order...\\n    return;\\n};\\n```\\n\\n# **C Language (Two Pointers Approach):**\\n```\\nvoid merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){\\n    // Initialize i and j to store indices of the last element of 1st and 2nd array respectively...\\n    int i = m - 1;\\n    int j = n -1;\\n    // Create a loop until either of i or j becomes zero...\\n    while(i>=0 && j>=0) {\\n        if(nums1[i] > nums2[j]) {\\n            nums1[i+j+1] = nums1[i];\\n            i--;\\n        } else {\\n            nums1[i+j+1] = nums2[j];\\n            j--;\\n        }\\n    }\\n    // While j does not become zero...\\n    while(j >= 0) {\\n        nums1[i+j+1] = nums2[j];\\n        j--;\\n    }\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        idx = 0\\n        for i in range(len(nums1)):\\n            if idx >= n:\\n                break\\n            if nums1[i] == 0:\\n                nums1[i]=nums2[idx]\\n                idx += 1\\n        nums1.sort()\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Array",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        // Initialize i and j to store indices of the last element of 1st and 2nd array respectively...\\n        int i = m - 1 , j = n - 1;\\n        // Initialize a variable k to store the last index of the 1st array...\\n        int k = m + n - 1;\\n        // Create a loop until either of i or j becomes zero...\\n        while(i >= 0 && j >= 0) {\\n            if(nums1[i] >= nums2[j]) {\\n                nums1[k] = nums1[i];\\n                i--;\\n            } else {\\n                nums1[k] = nums2[j];\\n                j--;\\n            }\\n            k--;\\n        // Either of i or j is not zero, which means some elements are yet to be merged.\\n        // Being already in a sorted manner, append them to the 1st array in the front.\\n        }\\n        // While i does not become zero...\\n        while(i >= 0)\\n            nums1[k--] = nums1[i--];\\n        // While j does not become zero...\\n        while(j >= 0)\\n            nums1[k--] = nums2[j--];\\n        // Now 1st array has all the elements in the required sorted order...\\n        return;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        // Here, nums1 =1st array, nums2 = 2nd array...\\n        for(int i = 0 ; i < n ; i++)\\n            nums1[i + m] = nums2[i];\\n            // Sort the 1st array...\\n            sort(nums1.begin() , nums1.end());\\n        // Print the required result...\\n        return;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        # Initialize nums1\\'s index\\n        i = m - 1\\n        # Initialize nums2\\'s index\\n        j = n - 1\\n        # Initialize a variable k to store the last index of the 1st array...\\n        k = m + n - 1\\n        while j >= 0:\\n            if i >= 0 and nums1[i] > nums2[j]:\\n                nums1[k] = nums1[i]\\n                k -= 1\\n                i -= 1\\n            else:\\n                nums1[k] = nums2[j]\\n                k -= 1\\n                j -= 1\\n```\n```\\nvar merge = function(nums1, m, nums2, n) {\\n    // Initialize i and j to store indices of the last element of 1st and 2nd array respectively...\\n    let i = m - 1 , j = n - 1;\\n    // Initialize a variable k to store the last index of the 1st array...\\n    let k = m + n - 1;\\n    // Create a loop until either of i or j becomes zero...\\n    while(i >= 0 && j >= 0) {\\n        if(nums1[i] >= nums2[j]) {\\n            nums1[k] = nums1[i];\\n            i--;\\n        } else {\\n            nums1[k] = nums2[j];\\n            j--;\\n        }\\n        k--;\\n    // Either of i or j is not zero, which means some elements are yet to be merged.\\n    // Being already in a sorted manner, append them to the 1st array in the front.\\n    }\\n    // While i does not become zero...\\n    while(i >= 0)\\n        nums1[k--] = nums1[i--];\\n    // While j does not become zero...\\n    while(j >= 0)\\n        nums1[k--] = nums2[j--];\\n    // Now 1st array has all the elements in the required sorted order...\\n    return;\\n};\\n```\n```\\nvoid merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){\\n    // Initialize i and j to store indices of the last element of 1st and 2nd array respectively...\\n    int i = m - 1;\\n    int j = n -1;\\n    // Create a loop until either of i or j becomes zero...\\n    while(i>=0 && j>=0) {\\n        if(nums1[i] > nums2[j]) {\\n            nums1[i+j+1] = nums1[i];\\n            i--;\\n        } else {\\n            nums1[i+j+1] = nums2[j];\\n            j--;\\n        }\\n    }\\n    // While j does not become zero...\\n    while(j >= 0) {\\n        nums1[i+j+1] = nums2[j];\\n        j--;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        idx = 0\\n        for i in range(len(nums1)):\\n            if idx >= n:\\n                break\\n            if nums1[i] == 0:\\n                nums1[i]=nums2[idx]\\n                idx += 1\\n        nums1.sort()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29699,
                "title": "clean-python-code",
                "content": "    class Solution(object):\\n        def merge(self, nums1, m, nums2, n):\\n            while m > 0 and n > 0:\\n                if nums1[m - 1] > nums2[n - 1]:\\n                    nums1[m + n - 1] = nums1[m - 1]\\n                    m -= 1\\n                else:\\n                    nums1[m + n - 1] = nums2[n - 1]\\n                    n -= 1\\n            nums1[:n] = nums2[:n]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def merge(self, nums1, m, nums2, n):\\n            while m > 0 and n > 0:\\n                if nums1[m - 1] > nums2[n - 1]:\\n                    nums1[m + n - 1] = nums1[m - 1]\\n                    m -= 1\\n                else:\\n                    nums1[m + n - 1] = nums2[n - 1]\\n                    n -= 1\\n            nums1[:n] = nums2[:n]",
                "codeTag": "Java"
            },
            {
                "id": 29755,
                "title": "python-easy-to-understand-in-place-solution",
                "content": "```\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        while m > 0 and n > 0:\\n            if nums1[m-1] > nums2[n-1]:\\n                nums1[m+n-1] = nums1[m-1]\\n                m -= 1\\n            else:\\n                nums1[m+n-1] = nums2[n-1]\\n                n -= 1\\n        while n > 0:\\n            nums1[n-1] = nums2[n-1]\\n            n -= 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        while m > 0 and n > 0:\\n            if nums1[m-1] > nums2[n-1]:\\n                nums1[m+n-1] = nums1[m-1]\\n                m -= 1\\n            else:\\n                nums1[m+n-1] = nums2[n-1]\\n                n -= 1\\n        while n > 0:\\n            nums1[n-1] = nums2[n-1]\\n            n -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307658,
                "title": "3-lines-of-code-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        for i in range(m,m+n):\\n            nums1[i]=nums2[i-m]\\n        nums1.sort()\\n    #please upvote me it would encourage me alot\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        for i in range(m,m+n):\\n            nums1[i]=nums2[i-m]\\n        nums1.sort()\\n    #please upvote me it would encourage me alot\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 344765,
                "title": "cleanest-javascript-solution",
                "content": "Inserting into the back of the `nums1` we only need to insert until we run out of `nums2` since everything else is already inplace at the front of `nums1`\\n```\\nvar merge = function (nums1, m, nums2, n) {\\n    var insertPos = m + n - 1;\\n    m--; n--;\\n    while (n >= 0) {\\n        nums1[insertPos--] = (nums1[m] > nums2[n]) ? nums1[m--] : nums2[n--];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar merge = function (nums1, m, nums2, n) {\\n    var insertPos = m + n - 1;\\n    m--; n--;\\n    while (n >= 0) {\\n        nums1[insertPos--] = (nums1[m] > nums2[n]) ? nums1[m--] : nums2[n--];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29578,
                "title": "share-my-accepted-java-solution",
                "content": "    public class Solution {\\n        public void merge(int A[], int m, int B[], int n) {\\n            int i = m - 1, j = n - 1, k = m + n - 1;\\n            while(i >= 0 && j >= 0) {\\n                A[k--] = A[i] > B[j] ? A[i--] : B[j--];\\n            }\\n            while(j >= 0) {\\n                A[k--] = B[j--];\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void merge(int A[], int m, int B[], int n) {\\n            int i = m - 1, j = n - 1, k = m + n - 1;\\n            while(i >= 0 && j >= 0) {\\n                A[k--] = A[i] > B[j] ? A[i--] : B[j--];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3958223,
                "title": "java-runtime-0-ms-beats-100-o-m-n",
                "content": "# Intuition\\nMy approach to solving this problem involves merging two sorted arrays while ensuring that the merged array remains sorted. Instead of merging from the end, I\\'ll merge from the beginning by placing elements in their correct positions.\\n\\n# Approach\\nI will initialize three pointers, \\'p1\\', \\'p2\\', and \\'pMerge\\', where \\'p1\\' and \\'p2\\' point to the last valid elements in nums1 and nums2, respectively. \\'pMerge\\' will point to the last available position in nums1. I\\'ll start from the end of both arrays and compare elements at \\'p1\\' and \\'p2\\'. I\\'ll place the larger element at \\'pMerge\\' and decrement the corresponding pointers and \\'pMerge\\'. I\\'ll continue this process until all elements from nums2 are merged into nums1.\\n\\n# Complexity\\n- Time complexity: O(m + n)\\n  The algorithm iterates through both arrays once, where \\'m\\' is the length of nums1 and \\'n\\' is the length of nums2.\\n\\n- Space complexity: O(1)\\n  The algorithm uses a constant amount of extra space for variables, so the space complexity is constant.\\n\\n# Code\\n```\\nclass Solution {\\n   public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int p1 = m - 1;\\n        int p2 = n - 1;\\n        int pMerge = m + n - 1;\\n        \\n        while (p2 >= 0) {\\n            if (p1 >= 0 && nums1[p1] > nums2[p2]) {\\n                nums1[pMerge--] = nums1[p1--];\\n            } else {\\n                nums1[pMerge--] = nums2[p2--];\\n            }\\n        }\\n    }\\n}\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/8a3b41d1-f0ca-472f-a9f7-8346b34a824e_1693297402.2918687.webp)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int p1 = m - 1;\\n        int p2 = n - 1;\\n        int pMerge = m + n - 1;\\n        \\n        while (p2 >= 0) {\\n            if (p1 >= 0 && nums1[p1] > nums2[p2]) {\\n                nums1[pMerge--] = nums1[p1--];\\n            } else {\\n                nums1[pMerge--] = nums2[p2--];\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365703,
                "title": "c-two-pointer-faster-than-100",
                "content": "```\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=m-1,j=n-1,k=m+n-1;\\n        while(i>=0 && j>=0)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                nums1[k]=nums1[i];\\n                k--;\\n                i--;\\n            }\\n            else\\n            {\\n                nums1[k]=nums2[j];\\n                k--;\\n                j--;\\n            }\\n        }\\n        while(j>=0)\\n        {\\n            nums1[k]=nums2[j];\\n            k--;\\n            j--;\\n        }\\n    }\\n};\\n```\\n**If you like it , Do upvote\\nHappy Coding;**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=m-1,j=n-1,k=m+n-1;\\n        while(i>=0 && j>=0)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                nums1[k]=nums1[i];\\n                k--;\\n                i--;\\n            }\\n            else\\n            {\\n                nums1[k]=nums2[j];\\n                k--;\\n                j--;\\n            }\\n        }\\n        while(j>=0)\\n        {\\n            nums1[k]=nums2[j];\\n            k--;\\n            j--;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29498,
                "title": "3-line-java-solution",
                "content": "    public void merge(int A[], int m, int B[], int n) {\\n        int i=m-1, j=n-1, k=m+n-1;\\n        while (i>-1 && j>-1) A[k--]= (A[i]>B[j]) ? A[i--] : B[j--];\\n        while (j>-1)         A[k--]=B[j--];\\n    }",
                "solutionTags": [],
                "code": "    public void merge(int A[], int m, int B[], int n) {\\n        int i=m-1, j=n-1, k=m+n-1;\\n        while (i>-1 && j>-1) A[k--]= (A[i]>B[j]) ? A[i--] : B[j--];\\n        while (j>-1)         A[k--]=B[j--];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 29572,
                "title": "my-simple-solution",
                "content": "    class Solution {\\n    public:\\n        void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n            int i = m - 1;\\n            int j = n - 1;\\n            int k = m + n - 1;\\n        \\n            while( i >= 0 && j >= 0 )\\n            {\\n                if( nums1[ i ] > nums2[ j ] )\\n                    nums1[ k-- ] = nums1[ i-- ];\\n                else\\n                    nums1[ k-- ] = nums2[ j-- ];\\n            }\\n        \\n            while( j >= 0 )\\n                nums1[ k-- ] = nums2[ j-- ];\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n            int i = m - 1;\\n            int j = n - 1;\\n            int k = m + n - 1;\\n        \\n            while( i >= 0 && j >= 0 )\\n            {\\n                if( nums1[ i ] > nums2[ j ] )\\n                    nums1[ k-- ] = nums1[ i-- ];\\n                else\\n                    nums1[ k-- ] = nums2[ j-- ];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2120130,
                "title": "python-easy-o-1-space",
                "content": "1. ## **Make a Copy**\\n\\n```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n       \\n        tmp_nums1 = nums1[:m]  # copy the non zero elements of nums1\\n               \\n        p1 = 0\\n        p2 = 0\\n               \\n        for p in range(n + m):\\n      \\n            if p2 >= n or (p1 < m and tmp_nums1[p1] <= nums2[p2]):\\n                nums1[p] = tmp_nums1[p1] \\n                p1 += 1\\n            else:\\n                nums1[p] = nums2[p2]\\n                p2 += 1\\n```\\n\\n**Time - O(n+m)**\\n**Space - O(m)**\\n\\n----\\n\\n2. ## **O(1) Space**\\n\\nBelow is my implementation done without extra space. [saja4007](https://leetcode.com/saja4007/) helped with the formatting and comments.\\n\\n```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n       \\n       # start merging from the ends of the lists\\n        p1, p2 = m-1, n-1\\n        # destination d index to insert into nums1\\n        for d in range(m+n-1, -1, -1):\\n            # if second list is empty, nothing more to merge\\n            if p2 < 0:\\n                return\\n            # only merge from nums1 if there are items left to merge\\n            # insert at d the larger of the two values from nums1 and nums2\\n            if p1 >= 0 and nums1[p1] > nums2[p2]:                \\n                nums1[d] = nums1[p1]\\n                p1 -= 1\\n            else:\\n                nums1[d] = nums2[p2]\\n                p2 -= 1\\n                      \\n```\\n\\n**Time - O(n+m)**\\n**Space - O(1)**\\n\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n       \\n        tmp_nums1 = nums1[:m]  # copy the non zero elements of nums1\\n               \\n        p1 = 0\\n        p2 = 0\\n               \\n        for p in range(n + m):\\n      \\n            if p2 >= n or (p1 < m and tmp_nums1[p1] <= nums2[p2]):\\n                nums1[p] = tmp_nums1[p1] \\n                p1 += 1\\n            else:\\n                nums1[p] = nums2[p2]\\n                p2 += 1\\n```\n```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n       \\n       # start merging from the ends of the lists\\n        p1, p2 = m-1, n-1\\n        # destination d index to insert into nums1\\n        for d in range(m+n-1, -1, -1):\\n            # if second list is empty, nothing more to merge\\n            if p2 < 0:\\n                return\\n            # only merge from nums1 if there are items left to merge\\n            # insert at d the larger of the two values from nums1 and nums2\\n            if p1 >= 0 and nums1[p1] > nums2[p2]:                \\n                nums1[d] = nums1[p1]\\n                p1 -= 1\\n            else:\\n                nums1[d] = nums2[p2]\\n                p2 -= 1\\n                      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044429,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=m-1,j=n-1;\\n        int ind=m+n-1;\\n        while(i>=0 && j>=0)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                nums1[ind]=nums1[i];\\n                i--;\\n            }\\n            else\\n            {\\n                nums1[ind]=nums2[j];\\n                j--;\\n            }\\n            ind--;\\n        }\\n        while(i>=0)\\n        {\\n            nums1[ind]=nums1[i];\\n            i--;\\n            ind--;\\n        }\\n        while(j>=0)\\n        {\\n            nums1[ind]=nums2[j];\\n            j--;\\n            ind--;\\n        }\\n    }\\n};\\n```\\nPlease Please **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=m-1,j=n-1;\\n        int ind=m+n-1;\\n        while(i>=0 && j>=0)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                nums1[ind]=nums1[i];\\n                i--;\\n            }\\n            else\\n            {\\n                nums1[ind]=nums2[j];\\n                j--;\\n            }\\n            ind--;\\n        }\\n        while(i>=0)\\n        {\\n            nums1[ind]=nums1[i];\\n            i--;\\n            ind--;\\n        }\\n        while(j>=0)\\n        {\\n            nums1[ind]=nums2[j];\\n            j--;\\n            ind--;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29680,
                "title": "short-javascript-solution",
                "content": "    var merge = function (nums1, m, nums2, n) {\\n        var len = m + n;\\n        m--;\\n        n--;\\n        while (len--) {\\n            if (n < 0 || nums1[m] > nums2[n]) {\\n                nums1[len] = nums1[m--];\\n            } else {\\n                nums1[len] = nums2[n--];\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "    var merge = function (nums1, m, nums2, n) {\\n        var len = m + n;\\n        m--;\\n        n--;\\n        while (len--) {\\n            if (n < 0 || nums1[m] > nums2[n]) {\\n                nums1[len] = nums1[m--];\\n            } else {\\n                nums1[len] = nums2[n--];\\n            }\\n        }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3109283,
                "title": "beats-100-c-simple-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse form back and check if $$arr[i]<arr[j]$$ then add $$arr[j]$$ at last and keep decremnting the pointer and if $$arr[i]>arr[j]$$ then add $$arr[i]$$\\nat last and do same . And at last check if  some emlement is left in second array then push that also.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo pointer can used here by keeping pointers from back and keep decrementing our pointers and keep adding the larger elements in back.\\nNOTE: Since arr1 can accomadate all the elemnts but m is given without zeroes counting so take care of that i.e take `k=m+n-1`\\n**Some confusion that can occur: Why we check if arr2 is empty why not arr1**\\nSince we have to fill the  first array so we only need to cover the second array because if second will be empty we can directly return our first one as its but if first one is empty we have to move second array in first and then return. Since first can\\'t be actually empty but m is given without zeroes counting so when m=0 we might take that as empty so just traverse second wholely. And check the pointer of first array if it has gone to end still there might be some elemnts in arr2.But when pointer of arr2 has gone to end we don\\'t need any comparsion then juut keep the remnaing elemnts as it is .\\n\\n# Complexity\\n- Time complexity:O(N+M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Biginer Friendly Code but SPACE is $$O(N)$$**\\n```\\nvoid merge(vector<int>& arr, int m, vector<int>& arr2, int n) {\\n        int i=0,j=0;\\n        vector<int>v(m+n);\\n        int k=0;\\n        while(i<m and j<n){\\n            \\n           if(arr[i]<arr2[j])v[k++]=arr[i],i++;\\n           else {\\n               v[k++]=arr2[j],j++;\\n           }\\n        }\\n        while(i<m)v[k++]=arr[i++];\\n          while(j<n)v[k++]=arr2[j++];\\n        \\n        for(int i=0;i<m+n;i++)arr[i]=v[i];\\n    }\\n```\\n**Actual Code with O(1) SPACE**\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& arr, int m, vector<int>& arr2, int n) {\\n      int i=m-1,j=n-1;\\n      int k=m+n-1;\\n      while(j>=0 and i>=0){\\n          if(arr[i]<arr2[j])arr[k--]=arr2[j--];\\n          else arr[k--]=arr[i--];\\n      }\\n      while(j>=0)arr[k--]=arr2[j--];\\n    }\\n};\\n```\\n****ONE LINER with same logic only simpler implementation****\\n```\\n void merge(vector<int>& arr, int m, vector<int>& arr2, int n) {\\n      int i=m-1,j=n-1,k=m+n-1;\\n      while(j>=0 ){\\n         arr[k--]=(i<0 || arr[i]<arr2[j])?arr2[j--]:arr[i--];\\n      }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nvoid merge(vector<int>& arr, int m, vector<int>& arr2, int n) {\\n        int i=0,j=0;\\n        vector<int>v(m+n);\\n        int k=0;\\n        while(i<m and j<n){\\n            \\n           if(arr[i]<arr2[j])v[k++]=arr[i],i++;\\n           else {\\n               v[k++]=arr2[j],j++;\\n           }\\n        }\\n        while(i<m)v[k++]=arr[i++];\\n          while(j<n)v[k++]=arr2[j++];\\n        \\n        for(int i=0;i<m+n;i++)arr[i]=v[i];\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& arr, int m, vector<int>& arr2, int n) {\\n      int i=m-1,j=n-1;\\n      int k=m+n-1;\\n      while(j>=0 and i>=0){\\n          if(arr[i]<arr2[j])arr[k--]=arr2[j--];\\n          else arr[k--]=arr[i--];\\n      }\\n      while(j>=0)arr[k--]=arr2[j--];\\n    }\\n};\\n```\n```\\n void merge(vector<int>& arr, int m, vector<int>& arr2, int n) {\\n      int i=m-1,j=n-1,k=m+n-1;\\n      while(j>=0 ){\\n         arr[k--]=(i<0 || arr[i]<arr2[j])?arr2[j--]:arr[i--];\\n      }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446544,
                "title": "concise-o-n-javascript",
                "content": "```\\nvar merge = function(nums1, m, nums2, n) {\\n  let idx1 = m - 1, idx2 = n - 1, idx3 = m + n - 1;\\n  while (idx2 >= 0) {\\n    nums1[idx3--] = nums1[idx1] > nums2[idx2]\\n      ? nums1[idx1--]\\n      : nums2[idx2--];\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar merge = function(nums1, m, nums2, n) {\\n  let idx1 = m - 1, idx2 = n - 1, idx3 = m + n - 1;\\n  while (idx2 >= 0) {\\n    nums1[idx3--] = nums1[idx1] > nums2[idx2]\\n      ? nums1[idx1--]\\n      : nums2[idx2--];\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 785646,
                "title": "python-3-99-78-faster",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nHere the approach is to update nums1 from the reverse side.\\n\\n```\\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n\\twriteIndex = m + n - 1\\n\\tm, n = m-1, n-1\\n\\t\\n\\twhile n>=0 and m>=0:\\n\\t\\tif nums1[m] > nums2[n]:\\n\\t\\t\\tnums1[writeIndex] = nums1[m]\\n\\t\\t\\t#nums1[m] = float(\"-inf\")           We don\\'t need to change this value because m will be pointing to m-1\\n\\t\\t\\tm -= 1\\n\\t\\telse:\\n\\t\\t\\tnums1[writeIndex] = nums2[n]\\n\\t\\t\\tn -= 1\\n\\t\\twriteIndex -= 1\\n\\t\\t\\n\\tif n>-1:\\n\\t\\tnums1[0:n+1] = nums2[0:n+1]\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n\\twriteIndex = m + n - 1\\n\\tm, n = m-1, n-1\\n\\t\\n\\twhile n>=0 and m>=0:\\n\\t\\tif nums1[m] > nums2[n]:\\n\\t\\t\\tnums1[writeIndex] = nums1[m]\\n\\t\\t\\t#nums1[m] = float(\"-inf\")           We don\\'t need to change this value because m will be pointing to m-1\\n\\t\\t\\tm -= 1\\n\\t\\telse:\\n\\t\\t\\tnums1[writeIndex] = nums2[n]\\n\\t\\t\\tn -= 1\\n\\t\\twriteIndex -= 1\\n\\t\\t\\n\\tif n>-1:\\n\\t\\tnums1[0:n+1] = nums2[0:n+1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2643064,
                "title": "javascript-two-pointer-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/03a2c588-2945-43da-be7e-dd80af375103_1664558052.505162.jpeg)\\n![image](https://assets.leetcode.com/users/images/87b49497-8469-4c51-86c4-f0abecdf53cd_1664558063.441468.jpeg)\\n![image](https://assets.leetcode.com/users/images/e6dfcc8e-cc27-4e3b-a4cd-9143a83021fc_1664558071.0522919.jpeg)\\n![image](https://assets.leetcode.com/users/images/0ee08371-e226-473c-b95b-3e8bb8818774_1664558082.9409328.jpeg)\\n![image](https://assets.leetcode.com/users/images/74fc1cb1-9f5a-4276-8e1f-57a87c73e979_1664558090.4406307.jpeg)\\n\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number} m\\n * @param {number[]} nums2\\n * @param {number} n\\n * @return {void} Do not return anything, modify nums1 in-place instead.\\n */\\nvar merge = function(nums1, m, nums2, n) {\\n    let i = m - 1;\\n    let j = n - 1;\\n    let k = m + n - 1;\\n    \\n    while (i >= 0 && j >= 0) {\\n        if (nums1[i] < nums2[j]) {\\n            nums1[k] = nums2[j];\\n            k--;\\n            j--;\\n        } else {\\n            nums1[k] = nums1[i];\\n            k--;\\n            i--;\\n        }\\n    }\\n    \\n    while (j >= 0) {\\n        nums1[k] = nums2[j];\\n        k--;\\n        j--;\\n    }\\n    \\n    while (i >= 0) {\\n        nums1[k] = nums1[i];\\n        k--;\\n        i--;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number} m\\n * @param {number[]} nums2\\n * @param {number} n\\n * @return {void} Do not return anything, modify nums1 in-place instead.\\n */\\nvar merge = function(nums1, m, nums2, n) {\\n    let i = m - 1;\\n    let j = n - 1;\\n    let k = m + n - 1;\\n    \\n    while (i >= 0 && j >= 0) {\\n        if (nums1[i] < nums2[j]) {\\n            nums1[k] = nums2[j];\\n            k--;\\n            j--;\\n        } else {\\n            nums1[k] = nums1[i];\\n            k--;\\n            i--;\\n        }\\n    }\\n    \\n    while (j >= 0) {\\n        nums1[k] = nums2[j];\\n        k--;\\n        j--;\\n    }\\n    \\n    while (i >= 0) {\\n        nums1[k] = nums1[i];\\n        k--;\\n        i--;\\n    }\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29825,
                "title": "cleanest-solution",
                "content": "    class Solution {\\n    public:\\n        void merge(int A[], int m, int B[], int n) {\\n            int i = m-1;\\n            int j = n-1;\\n            for (int k = m+n-1; k >= 0; k--) {\\n                if (i < 0)              A[k] = B[j--];\\n                else if (j < 0)         A[k] = A[i--];\\n                else if (A[i] < B[j])   A[k] = B[j--];\\n                else                    A[k] = A[i--];\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void merge(int A[], int m, int B[], int n) {\\n            int i = m-1;\\n            int j = n-1;\\n            for (int k = m+n-1; k >= 0; k--) {\\n                if (i < 0)              A[k] = B[j--];\\n                else if (j < 0)         A[k] = A[i--];\\n                else if (A[i] < B[j])   A[k] = B[j--];\\n                else                    A[k] = A[i--];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1661668,
                "title": "multiple-c-solution-with-full-explanation",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n## Explanation:\\n\\n### Solution 01\\n\\n- We took j=0 to iterate nums2 from the beginning.\\n- As we know nums1 has a size of m+n & only first m elements should be in the final array.\\n- So we replace all the elements from m index with all the elements of nums2.\\n- Finally, we\\u2019ll sort the array nums1 to get the final sorted array.\\n- **Time complexity:** O(nlogn) //as sorting takes nlogn time.\\n\\n### Solution 02\\n\\n- Same logic as Solution 01, But here we used **resize().**\\n- Resize() will simply keep the elements till m index in muns1 array.\\n- Then we\\u2019ll insert all the elements of nums2 array by using insert().\\n- Lastly, we\\u2019ll sort the array nums1 to get the final sorted array.\\n- **Time complexity:** O(nlogn) //as sorting takes nlogn time.\\n\\n### Solution 03\\n\\n- As both solutions 01 & 02 takes O(nlogn), now we try to solve it with O(n+m).\\n- We will use the reverse sorting method.\\n- We took 3 variables: i (last valid element of nums1 that will present in final array), j (last element of nums2) & k ( last index of nums1)\\n- First, while loop will compare nums1 & nums2 and the greater element will be in nums1[k].\\n- After the loop end if there is still any elements left in any array that will be added by next 2 while loop.\\n- **Time complexity:** O(m+n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int j=0;\\n        for(int i=m; i<nums1.size(); i++){\\n            nums1[i]=nums2[j];\\n            j++;\\n        }\\n        sort(nums1.begin(), nums1.end());\\n        return;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        nums1.resize(m);\\n        nums1.insert(nums1.end(), nums2.begin(), nums2.end());\\n        sort(nums1.begin(), nums1.end());\\n    }\\n};\\n\\n//Solution 03:\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=m-1, j=n-1, k=m+n-1;\\n        \\n        while(i>=0 && j>=0){\\n            if(nums1[i]>nums2[j]){\\n                nums1[k] = nums1[i];\\n                k--;\\n                i--;\\n            }\\n            else{\\n                nums1[k] = nums2[j];\\n                k--;\\n                j--;\\n            }\\n        }\\n        while(i>=0){\\n            nums1[k] = nums1[i];\\n            k--;\\n            i--;\\n        }\\n        while(j>=0){\\n            nums1[k] = nums2[j];\\n            k--;\\n            j--;\\n        }\\n    }\\n};\\n```\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int j=0;\\n        for(int i=m; i<nums1.size(); i++){\\n            nums1[i]=nums2[j];\\n            j++;\\n        }\\n        sort(nums1.begin(), nums1.end());\\n        return;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        nums1.resize(m);\\n        nums1.insert(nums1.end(), nums2.begin(), nums2.end());\\n        sort(nums1.begin(), nums1.end());\\n    }\\n};\\n\\n//Solution 03:\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=m-1, j=n-1, k=m+n-1;\\n        \\n        while(i>=0 && j>=0){\\n            if(nums1[i]>nums2[j]){\\n                nums1[k] = nums1[i];\\n                k--;\\n                i--;\\n            }\\n            else{\\n                nums1[k] = nums2[j];\\n                k--;\\n                j--;\\n            }\\n        }\\n        while(i>=0){\\n            nums1[k] = nums1[i];\\n            k--;\\n            i--;\\n        }\\n        while(j>=0){\\n            nums1[k] = nums2[j];\\n            k--;\\n            j--;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011556,
                "title": "python-2-pointers-solution-explained",
                "content": "Easy problem if you know the trick, but not so easy if you see this type of idea first time. Here we need to use two observations:\\n1. It is definitely `2` pointers approach, we need to iterate through `nums1` and `nums2` and build solution, using merge.\\n2. Also, we need to start from **end** of our lists, and this is essential, if you start from the beginning of lists, you can accidentely rewrite you data, so you need to think where to put it first and it will be extra space.\\n\\nSo, all we do is:\\n1. define `p1 = m - 1` and `p2 = n - 1`: pointers for `nums1` and `nums2`.\\n2. We start from `i = m + n - 1` and move in backward direction: we compare `nums1[p1]` and `nums2[p2]`, write biggest number to `nums1[i]` and move one of the pointers: `p1` or `p2`.\\n3. This is not all: it can happen, that when we reached `p1 = 0`, there are still some numbers we need to copy from `nums2` to `nums1`, and in next step we do this.\\n\\n**Complexity**: time complexity is `O(n + m)`, space complexity is `O(1)`: we did everything inplace.\\n\\n```\\nclass Solution:\\n    def merge(self, nums1, m, nums2, n):\\n        p1, p2 = m - 1, n - 1\\n        for i in range(m+n-1, -1, -1):\\n            if p1 < 0 or p2 < 0: break\\n            if nums1[p1] > nums2[p2]:\\n                nums1[i] = nums1[p1]\\n                p1 -= 1\\n            else:\\n                nums1[i] = nums2[p2]\\n                p2 -= 1\\n              \\n        while p2 >= 0:\\n            nums1[i] = nums2[p2]\\n            i -= 1\\n            p2 -= 1\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, nums1, m, nums2, n):\\n        p1, p2 = m - 1, n - 1\\n        for i in range(m+n-1, -1, -1):\\n            if p1 < 0 or p2 < 0: break\\n            if nums1[p1] > nums2[p2]:\\n                nums1[i] = nums1[p1]\\n                p1 -= 1\\n            else:\\n                nums1[i] = nums2[p2]\\n                p2 -= 1\\n              \\n        while p2 >= 0:\\n            nums1[i] = nums2[p2]\\n            i -= 1\\n            p2 -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 577078,
                "title": "java-100-time-beating-0ms-in-place-solution",
                "content": "The  thing to observe is that, if we start merging from back side, there will never be any conflict observed in in-place merging if we start putting elements from (m + n - 1)th index of nums1 array. The solution (Java code) can easily be written as:\\n```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i1 = m - 1, i2 = n - 1, here = m + n - 1;\\n        while(i1 >= 0 && i2 >= 0) {\\n            if(nums1[i1] >= nums2[i2]) {\\n                nums1[here--] = nums1[i1--];\\n            } else {\\n                nums1[here--] = nums2[i2--];\\n            }\\n        }\\n        while(i2 >= 0) {\\n            nums1[here--] = nums2[i2--];\\n        }\\n    }\\n}\\n```\\nHope you like it!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i1 = m - 1, i2 = n - 1, here = m + n - 1;\\n        while(i1 >= 0 && i2 >= 0) {\\n            if(nums1[i1] >= nums2[i2]) {\\n                nums1[here--] = nums1[i1--];\\n            } else {\\n                nums1[here--] = nums2[i2--];\\n            }\\n        }\\n        while(i2 >= 0) {\\n            nums1[here--] = nums2[i2--];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343299,
                "title": "python-3-solution-using-2-pointers-easy",
                "content": "Please comment for any doubt\\n\\n```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        i=m-1\\n        j=n-1\\n        k=m+n-1\\n        while i>=0 and j>=0:\\n            if nums1[i]>nums2[j]:\\n                nums1[k]=nums1[i]\\n                i-=1\\n            else:\\n                nums1[k]=nums2[j]\\n                j-=1\\n            k-=1\\n        if j>=0:\\n            nums1[:k+1]=nums2[:j+1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        i=m-1\\n        j=n-1\\n        k=m+n-1\\n        while i>=0 and j>=0:\\n            if nums1[i]>nums2[j]:\\n                nums1[k]=nums1[i]\\n                i-=1\\n            else:\\n                nums1[k]=nums2[j]\\n                j-=1\\n            k-=1\\n        if j>=0:\\n            nums1[:k+1]=nums2[:j+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192286,
                "title": "very-easy-solution-merge-sorted-array",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number} m\\n * @param {number[]} nums2\\n * @param {number} n\\n * @return {void} Do not return anything, modify nums1 in-place instead.\\n */\\nvar merge = function(nums1, m, nums2, n) {\\n  let i = m-1; // last element of nums1 which is now 3\\n  let j = n-1; // last element of nums2 which is now 6\\n  let k = m+n-1 // last element of nums1 which is now 0\\n  \\n   while(j >= 0){\\n    if(i >= 0 && nums1[i] > nums2[j]){\\n      nums1[k--] = nums1[i--]\\n    }else {\\n      nums1[k--] = nums2[j--]\\n    }\\n  }\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/767088f2-d5f1-42c5-b4db-d40dc6823def_1676532062.649848.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number} m\\n * @param {number[]} nums2\\n * @param {number} n\\n * @return {void} Do not return anything, modify nums1 in-place instead.\\n */\\nvar merge = function(nums1, m, nums2, n) {\\n  let i = m-1; // last element of nums1 which is now 3\\n  let j = n-1; // last element of nums2 which is now 6\\n  let k = m+n-1 // last element of nums1 which is now 0\\n  \\n   while(j >= 0){\\n    if(i >= 0 && nums1[i] > nums2[j]){\\n      nums1[k--] = nums1[i--]\\n    }else {\\n      nums1[k--] = nums2[j--]\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1505004,
                "title": "java-merge-sort-o-m-n-time-o-1-space",
                "content": "**Idea**\\nSince we know that nums1 having n empty elements and we are just storing largest elements in nums1 from the back by comparing both array elements.\\n\\nThis is concept of merge sort in which we check both sorted array elements indexes and store them wisely in sorted manner! \\n\\n```\\npublic void merge(int[] nums1, int m, int[] nums2, int n) {\\n    \\n        int i,j,k;\\n        i=m-1;\\n        j=n-1;\\n        for(k=n+m-1;k>=0;k--)\\n        {\\n            if(i>=0&&(j==-1||nums1[i]>nums2[j]))\\n                nums1[k]=nums1[i--];\\n            else if(j>=0)\\n                nums1[k]=nums2[j--];\\n        }\\n    }\\n```\\n\\nIf you get it then please **upvote** it:))",
                "solutionTags": [
                    "Java",
                    "Merge Sort"
                ],
                "code": "```\\npublic void merge(int[] nums1, int m, int[] nums2, int n) {\\n    \\n        int i,j,k;\\n        i=m-1;\\n        j=n-1;\\n        for(k=n+m-1;k>=0;k--)\\n        {\\n            if(i>=0&&(j==-1||nums1[i]>nums2[j]))\\n                nums1[k]=nums1[i--];\\n            else if(j>=0)\\n                nums1[k]=nums2[j--];\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2806395,
                "title": "simple-10-line-solution-in-place-solution",
                "content": "# Intuition\\nLoop through the list reversely and fill the elements\\n\\n# Approach\\n1. Loop through the list reversely\\n2. assign max value of two list one-by-one to the last unfilled index of nums1\\n\\n---\\ni.e, \\n```\\nif i >= 0 and nums1[i] > nums2[j]:\\n    nums1[right] = nums1[i]\\n    i -= 1\\nelse:\\n    nums1[right] = nums2[j]\\n    j -= 1\\n```\\n\\n---\\n\\n\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        i, j = m-1, n-1\\n        for right in range(m+n-1, -1, -1):\\n            if j < 0:\\n                break\\n            if i >= 0 and nums1[i] > nums2[j]:\\n                nums1[right] = nums1[i]\\n                i -= 1\\n            else:\\n                nums1[right] = nums2[j]\\n                j -= 1\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nif i >= 0 and nums1[i] > nums2[j]:\\n    nums1[right] = nums1[i]\\n    i -= 1\\nelse:\\n    nums1[right] = nums2[j]\\n    j -= 1\\n```\n```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        i, j = m-1, n-1\\n        for right in range(m+n-1, -1, -1):\\n            if j < 0:\\n                break\\n            if i >= 0 and nums1[i] > nums2[j]:\\n                nums1[right] = nums1[i]\\n                i -= 1\\n            else:\\n                nums1[right] = nums2[j]\\n                j -= 1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210180,
                "title": "c-detailed-explaination-optimized",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Solution 1 :**\\n**Time complexity:** O(nlogn)\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        nums1.resize(m); // removes the additional zeroes at end of num1\\n        nums1.insert(nums1.end(), nums2.begin(), nums2.end()); // vector_name.insert(position, iterator1, iterator2)\\n        sort(nums1.begin(), nums1.end()); // sorts the merged array\\n    }\\n};\\n```\\n\\n**Solution 2 :**\\n**Time complexity:** O(m+n)\\n```\\nclass Solution\\n{\\npublic:\\n    void merge(vector<int> &nums1, int m, vector<int> &nums2, int n)\\n    {\\n        vector<int> nums(m + n, 0); // make a new vector with size (m+n)\\n        int i = 0; // pointer to keep track for num1\\n\\t\\tint j = 0; // pointer to keep track for num2\\n\\t\\tint k = 0; // pointer to keep track for new vector nums\\n\\t\\t\\n\\t\\t// if number of elements in nums2 is 0, then just return since there\\'s nothing to do\\n        if (n == 0)\\n            return;\\n\\t\\t\\n\\t\\t// while both the pointers are within the limits\\n        while (i < m && j < n)\\n        {\\n            // element of num1 is smaller, we will insert that in nums\\n            if (nums1[i] < nums2[j])\\n                nums[k++] = nums1[i++];\\n\\t\\t\\t// element of num2 is smaller, we will insert that in nums\\n            else\\n                nums[k++] = nums2[j++];\\n        }\\n\\n\\t\\t// now which ever array has pointer still within its limits needs to be inserted into nums \\n        while (i < m)\\n            nums[k++] = nums1[i++];\\n        while (j < n)\\n            nums[k++] = nums2[j++];\\n\\n\\t\\tnow copy the new vector to the nums1\\n        nums1 = nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        nums1.resize(m); // removes the additional zeroes at end of num1\\n        nums1.insert(nums1.end(), nums2.begin(), nums2.end()); // vector_name.insert(position, iterator1, iterator2)\\n        sort(nums1.begin(), nums1.end()); // sorts the merged array\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    void merge(vector<int> &nums1, int m, vector<int> &nums2, int n)\\n    {\\n        vector<int> nums(m + n, 0); // make a new vector with size (m+n)\\n        int i = 0; // pointer to keep track for num1\\n\\t\\tint j = 0; // pointer to keep track for num2\\n\\t\\tint k = 0; // pointer to keep track for new vector nums\\n\\t\\t\\n\\t\\t// if number of elements in nums2 is 0, then just return since there\\'s nothing to do\\n        if (n == 0)\\n            return;\\n\\t\\t\\n\\t\\t// while both the pointers are within the limits\\n        while (i < m && j < n)\\n        {\\n            // element of num1 is smaller, we will insert that in nums\\n            if (nums1[i] < nums2[j])\\n                nums[k++] = nums1[i++];\\n\\t\\t\\t// element of num2 is smaller, we will insert that in nums\\n            else\\n                nums[k++] = nums2[j++];\\n        }\\n\\n\\t\\t// now which ever array has pointer still within its limits needs to be inserted into nums \\n        while (i < m)\\n            nums[k++] = nums1[i++];\\n        while (j < n)\\n            nums[k++] = nums2[j++];\\n\\n\\t\\tnow copy the new vector to the nums1\\n        nums1 = nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29556,
                "title": "2-lines-very-simple-c-solution",
                "content": "    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       for(int i=m-1, j=n-1, k=m+n-1; j>=0; )\\n           nums1[k--] = i>=0 && nums1[i]>nums2[j]? nums1[i--]: nums2[j--];\\n    }",
                "solutionTags": [],
                "code": "    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       for(int i=m-1, j=n-1, k=m+n-1; j>=0; )\\n           nums1[k--] = i>=0 && nums1[i]>nums2[j]? nums1[i--]: nums2[j--];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 164963,
                "title": "three-javascript-approaches-with-explanations",
                "content": "**Method 1**\\n\\nThis was the first and simplest method that popped into my head. Copy the second array into the \"empty\" half of the first array, and then sort it. Around 56ms (~80%) run time.\\n\\nSimply using .sort() isn\\'t enough as it will sort lexigraphically (worth remembering), so we have to pass it a custom sort function.\\n\\n```\\nvar merge = function(nums1, m, nums2, n) {\\n    \\n    if (!n) return;    \\n    \\n    for (let i = 0; i < n; i++) {\\n        nums1[m+i] = nums2[i];\\n    }\\n    \\n    nums1.sort(function (a,b) {\\n        return a - b;\\n    });\\n    \\n}; \\n```\\n\\n**Method 2**\\n\\nThis is essentially a dual pointer approach. Make a copy of nums1, and then step through the nums1 copy and nums2, from the front, adding whichever is smallest back into nums1.\\n\\nThis obviously will increase memory use, but produces 52ms runtime (i.e 100%).\\n\\n```\\nvar merge = function(nums1, m, nums2, n) {\\n    \\n    if (n == 0) return;\\n    \\n    let nums1copy = [...nums1], mm = 0, nn = 0;\\n    \\n    for (let i = 0; i < (m+n); i++) {\\n        //Is it smaller, or have we run out of the second list?\\n        if ( (nums1copy[mm] < nums2[nn] && mm < m) || nn >= n ) {\\n            nums1[i] = nums1copy[mm];\\n            mm++;\\n        } else {\\n            nums1[i] = nums2[nn];\\n            nn++;\\n        }   \\n    }\\n}\\n```\\n\\n**Method 3**\\n\\nThis method uses no additional memory and retains the 52ms (100%) runtime.\\n\\nThe biggest problem with starting from the front, is that you run into trouble with overwriting values etc. and it likely won\\'t work.\\n\\nThis method starts from the back - where our \"empty\" spaces are. Similar to method 2, we are basically keeping two pointers, but starting at the back and looking for the bigger of the two numbers instead of the smaller.\\n\\nThe code would be a lot more legible if we simply \"let i = m + n\" but I quite liked the zero memory consumption of this approach.\\n\\n```\\nvar merge = function(nums1, m, nums2, n) {\\n    //we don\\'t want the length, we want the start position of the final elements\\n    m--;\\n    n--;\\n    \\n    while (m + n >= -1) {\\n        //If bigger, or nothing left in nums2, copy it over\\n        if ( (nums1[m] > nums2[n] ) || n < 0) {\\n            nums1[m + n + 1] = nums1[m];\\n            m--;\\n        } else {\\n            nums1[m + n + 1] = nums2[n];\\n            n--;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvar merge = function(nums1, m, nums2, n) {\\n    \\n    if (!n) return;    \\n    \\n    for (let i = 0; i < n; i++) {\\n        nums1[m+i] = nums2[i];\\n    }\\n    \\n    nums1.sort(function (a,b) {\\n        return a - b;\\n    });\\n    \\n}; \\n```\n```\\nvar merge = function(nums1, m, nums2, n) {\\n    \\n    if (n == 0) return;\\n    \\n    let nums1copy = [...nums1], mm = 0, nn = 0;\\n    \\n    for (let i = 0; i < (m+n); i++) {\\n        //Is it smaller, or have we run out of the second list?\\n        if ( (nums1copy[mm] < nums2[nn] && mm < m) || nn >= n ) {\\n            nums1[i] = nums1copy[mm];\\n            mm++;\\n        } else {\\n            nums1[i] = nums2[nn];\\n            nn++;\\n        }   \\n    }\\n}\\n```\n```\\nvar merge = function(nums1, m, nums2, n) {\\n    //we don\\'t want the length, we want the start position of the final elements\\n    m--;\\n    n--;\\n    \\n    while (m + n >= -1) {\\n        //If bigger, or nothing left in nums2, copy it over\\n        if ( (nums1[m] > nums2[n] ) || n < 0) {\\n            nums1[m + n + 1] = nums1[m];\\n            m--;\\n        } else {\\n            nums1[m + n + 1] = nums2[n];\\n            n--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 550278,
                "title": "c-o-n-time-o-1-space-highly-commented-0ms-stay-home-flatten-the-curve-socially-distance",
                "content": "A simple algorithm which sweeps right to left, back to front through both the input ranges and the output.\\nEven though the output is in the same vector as one of the inputs, it manages to not corrupt that input by having the input index always stay ahead of the output index in the same vector, by virtue of this right to left ordering.\\nThe C++ standard library already has an algorithm for this and [that version fits on one line](https://leetcode.com/problems/merge-sorted-array/discuss/550236/C%2B%2B-1-line-std%3A%3Amerge()), so you\\'d probably use that in real life.\\n\\n# Code\\n\\n```c++\\n        void static merge(vector<int>& nums1, int m, const vector<int>& nums2, int n)\\n        {\\n            // We will write from the back of the first array to its front,\\n            // starting at what will be the last entry in it:\\n            unsigned write = n + m - 1;\\n            \\n            // Make m and n index the last source entry in each of the two input ranges:\\n            --m;\\n            --n;\\n            \\n            // Loop right to left over input ranges, at each step choosing the,\\n            // greatest of the two inputs to write into the current destination position:\\n            while(n >= 0 && m >= 0){\\n                const int num1 = nums1[m];\\n                const int num2 = nums2[n];\\n                nums1[write] = std::max(num1, num2);\\n                if(num1 > num2){\\n                    --m;\\n                } else {\\n                    --n;\\n                }\\n                --write;\\n            }\\n            \\n            // Drain the tail from the input range with spare entries:\\n            // If the first input is the one with spare, they are already in place\\n            // so only actually loop if the spares are in the second input and thus\\n            // need copying over.\\n            while(n >= 0){\\n                nums1[write] = nums2[n];\\n                --n;\\n                --write;\\n            }\\n        }\\n```\\n\\t\\n# Results\\n\\t\\n> Runtime: 0 ms, faster than 100.00% of C++ online submissions for Merge Sorted Array.\\n> Memory Usage: 6.5 MB, less than 100.00% of C++ online submissions for Merge Sorted Array.\\n\\n# Assembly for Inner Loop\\nIf you look at the main inner loop, you\\'ll notice we do a `std::max` and then we retest the condition that `max` presumably already tested internally. Is that a good idea? The only way to know for sure is to profile on the hardware of interest, but short of that, we can take a look at the assembly generated by the compiler. Here\\'s that loop again:\\n\\n```c++\\nwhile(n >= 0 && m >= 0){\\n\\tconst int num1 = nums1[m];\\n\\tconst int num2 = nums2[n];\\n\\tnums1[write] = std::max(num1, num2);\\n\\tif(num1 > num2){\\n\\t\\t--m;\\n\\t} else {\\n\\t\\t--n;\\n\\t}\\n\\t--write;\\n}\\n```\\n\\nThis was an attempt to keep the code inside the branch as short as possible. Let\\'s use Godbolt to see what a compiler (clang trunk in this case) does with that:\\n\\n```\\n.LBB0_2: # =>This Inner Loop Header: Depth=1\\n  movsxd rsi, esi\\n  mov ebp, dword ptr [r9 + 4*rsi]\\n  movsxd rcx, ecx\\n  mov ebx, dword ptr [r8 + 4*rcx]\\n  xor r10d, r10d\\n  xor eax, eax\\n  cmp ebp, ebx\\n  cmovl ebp, ebx\\n  mov ebx, r15d\\n  mov dword ptr [r9 + 4*rbx], ebp\\n  setle r10b\\n  setg al\\n  sub esi, eax\\n  sub ecx, r10d\\n  dec r15d\\n  mov eax, ecx\\n  or eax, esi\\n  jns .LBB0_2\\n```\\n\\nCool, the `std::max` becomes a conditional move:\\n\\n```\\n  cmp ebp, ebx\\n  cmovl ebp, ebx\\n  mov ebx, r15d\\n  mov dword ptr [r9 + 4*rbx], ebp\\n  ```\\n  Going into this, register ebp contains `nums1[m]` and ebx `nums2[n]`. The two registers are compared, one is conditionally moved on top of the other, and then that is written out to memory, all without a branch.\\n\\nNow we have a very simple branch at the source level to update either `m` or `n`:\\n\\n```c++\\nif(num1 > num2){\\n\\t--m;\\n} else {\\n\\t--n;\\n}\\n```\\n\\nLet\\'s look at what code that generates:\\n\\n```\\n  setle r10b\\n  setg al\\n  sub esi, eax\\n  sub ecx, r10d\\n```\\nAs we go into this, the processor condition codes still reflect the earlier `cmp ebp, ebx` which we used to find the ordering betwen the elements of the two arrays. Now we use the codes again for the two conditional set instructions, `setle` (_set if less than or equal_) and `setg` (_set if greater than_). This gives us either a 0 in register 10 and a 1 in register al, or a 1 in register 10 and a 0 register al. The next two lines then subtract either a 0 or a 1 from the registers holding the values of m and n without any branches being used. \\n\\nNow we can consider what code is generated with the more straightforward formulation of the same loop, not using `std::max` and instead having just a single extra line on each side of the `if` statement. \\n\\n```c++\\nwhile(n >= 0 && m >= 0){\\n\\tconst int num1 = nums1[m];\\n\\tconst int num2 = nums2[n];\\n\\tif(num1 > num2){\\n\\t\\tnums1[write] = num1;\\n\\t\\t--m;\\n\\t} else {\\n\\t\\tnums1[write] = num2;\\n\\t\\t--n;\\n\\t}\\n\\t--write;\\n}\\n```\\n\\nIn the dissassembly below, we jump into it at label `.LBB1_2`. The body of the loop then features a branch `jle` for our `if` statement and a control flow which bounces around a lot more.\\n\\n```\\n.LBB1_22: # in Loop: Header=BB1_2 Depth=1\\n  mov dword ptr [r9 + 4*rax], ecx\\n  dec r10d\\n.LBB1_23: # in Loop: Header=BB1_2 Depth=1\\n  dec eax\\n  mov ecx, esi\\n  or ecx, r10d\\n  js .LBB1_4\\n.LBB1_2: # =>This Inner Loop Header: Depth=1 <----- We enter here from a jump not shown.\\n  movsxd rcx, esi\\n  mov ebx, dword ptr [r9 + 4*rcx]\\n  movsxd rcx, r10d\\n  mov ecx, dword ptr [r8 + 4*rcx]\\n  mov eax, eax\\n  cmp ebx, ecx\\n  jle .LBB1_22\\n  mov dword ptr [r9 + 4*rax], ebx\\n  dec esi\\n  jmp .LBB1_23\\n.LBB1_4:    # Go on to the cleanup loop ...\\n```\\n\\nThis is just the result of one compiler with a particular set of flags. Which of these two is actually faster is still not certain. \\n\\nFull assembly listing on Godbolt [here](https://godbolt.org/z/XqEH9-).\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```c++\\n        void static merge(vector<int>& nums1, int m, const vector<int>& nums2, int n)\\n        {\\n            // We will write from the back of the first array to its front,\\n            // starting at what will be the last entry in it:\\n            unsigned write = n + m - 1;\\n            \\n            // Make m and n index the last source entry in each of the two input ranges:\\n            --m;\\n            --n;\\n            \\n            // Loop right to left over input ranges, at each step choosing the,\\n            // greatest of the two inputs to write into the current destination position:\\n            while(n >= 0 && m >= 0){\\n                const int num1 = nums1[m];\\n                const int num2 = nums2[n];\\n                nums1[write] = std::max(num1, num2);\\n                if(num1 > num2){\\n                    --m;\\n                } else {\\n                    --n;\\n                }\\n                --write;\\n            }\\n            \\n            // Drain the tail from the input range with spare entries:\\n            // If the first input is the one with spare, they are already in place\\n            // so only actually loop if the spares are in the second input and thus\\n            // need copying over.\\n            while(n >= 0){\\n                nums1[write] = nums2[n];\\n                --n;\\n                --write;\\n            }\\n        }\\n```\n```c++\\nwhile(n >= 0 && m >= 0){\\n\\tconst int num1 = nums1[m];\\n\\tconst int num2 = nums2[n];\\n\\tnums1[write] = std::max(num1, num2);\\n\\tif(num1 > num2){\\n\\t\\t--m;\\n\\t} else {\\n\\t\\t--n;\\n\\t}\\n\\t--write;\\n}\\n```\n```\\n.LBB0_2: # =>This Inner Loop Header: Depth=1\\n  movsxd rsi, esi\\n  mov ebp, dword ptr [r9 + 4*rsi]\\n  movsxd rcx, ecx\\n  mov ebx, dword ptr [r8 + 4*rcx]\\n  xor r10d, r10d\\n  xor eax, eax\\n  cmp ebp, ebx\\n  cmovl ebp, ebx\\n  mov ebx, r15d\\n  mov dword ptr [r9 + 4*rbx], ebp\\n  setle r10b\\n  setg al\\n  sub esi, eax\\n  sub ecx, r10d\\n  dec r15d\\n  mov eax, ecx\\n  or eax, esi\\n  jns .LBB0_2\\n```\n```\\n  cmp ebp, ebx\\n  cmovl ebp, ebx\\n  mov ebx, r15d\\n  mov dword ptr [r9 + 4*rbx], ebp\\n  ```\n```c++\\nif(num1 > num2){\\n\\t--m;\\n} else {\\n\\t--n;\\n}\\n```\n```\\n  setle r10b\\n  setg al\\n  sub esi, eax\\n  sub ecx, r10d\\n```\n```c++\\nwhile(n >= 0 && m >= 0){\\n\\tconst int num1 = nums1[m];\\n\\tconst int num2 = nums2[n];\\n\\tif(num1 > num2){\\n\\t\\tnums1[write] = num1;\\n\\t\\t--m;\\n\\t} else {\\n\\t\\tnums1[write] = num2;\\n\\t\\t--n;\\n\\t}\\n\\t--write;\\n}\\n```\n```\\n.LBB1_22: # in Loop: Header=BB1_2 Depth=1\\n  mov dword ptr [r9 + 4*rax], ecx\\n  dec r10d\\n.LBB1_23: # in Loop: Header=BB1_2 Depth=1\\n  dec eax\\n  mov ecx, esi\\n  or ecx, r10d\\n  js .LBB1_4\\n.LBB1_2: # =>This Inner Loop Header: Depth=1 <----- We enter here from a jump not shown.\\n  movsxd rcx, esi\\n  mov ebx, dword ptr [r9 + 4*rcx]\\n  movsxd rcx, r10d\\n  mov ecx, dword ptr [r8 + 4*rcx]\\n  mov eax, eax\\n  cmp ebx, ecx\\n  jle .LBB1_22\\n  mov dword ptr [r9 + 4*rax], ebx\\n  dec esi\\n  jmp .LBB1_23\\n.LBB1_4:    # Go on to the cleanup loop ...\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 608383,
                "title": "explained-java-code",
                "content": "This problem was asked to me an year back in an On-campus interview, and I wasn\\'t not able to solve it without using extra space. Well I can now. \\nWe are given that the nums1 array can accomodate the elements of the nums2 easily so we simply pick element from the end sides of both these array and compare their values and insert them into the nums1 array. \\nThe first case is basically if the first array(nums1) doesn\\'t contain any element, then we simply insert the second array(nums2) inside nums1, the second case is if nums2 doesn\\'t contain any element then we do nothing as the nums1 would simply justify the answer.\\n<br>\\n<b> Things to remember </b>\\n<ul>\\n<li>We are given that nums1 can accomodate nums2, if it is given that nums1 cannot then simply insert 0\\'s at the end of the array and this will work just fine.</li>\\n<li>Running from the end gives us privilege more than running the pointers from the start.</li>\\n</ul>\\n\\n<b> Java Code </b>\\n```\\npublic void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m-1, j = n- 1, k = m + n - 1;\\n        while(i>=0 && j>=0){\\n            if(nums1[i] > nums2[j]){\\n                nums1[k--] = nums1[i--];\\n            }else{\\n                nums1[k--] = nums2[j--];\\n            }\\n        }\\n\\t\\t// this while loop is for the condition when nums1 doesn\\'t contain any element.\\n        while(j>=0){\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m-1, j = n- 1, k = m + n - 1;\\n        while(i>=0 && j>=0){\\n            if(nums1[i] > nums2[j]){\\n                nums1[k--] = nums1[i--];\\n            }else{\\n                nums1[k--] = nums2[j--];\\n            }\\n        }\\n\\t\\t// this while loop is for the condition when nums1 doesn\\'t contain any element.\\n        while(j>=0){\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29727,
                "title": "0ms-java-intuitive-solution-insert-from-the-back-keep-3-pointers",
                "content": "it is ok to use two pointers, just tracking the end of nums1 and nums2; But i feel that the three pointer solution is easier to visualize.\\n\\n\\n    public class Solution {\\n        public void merge(int[] nums1, int m, int[] nums2, int n) {\\n            // insert from the m+n-1 position at the bigger array\\n            // keep 3 pointers: one at the insertion point\\n            // one at the end of nums1; one at the end of nums2\\n            int insertP = m + n - 1;\\n            int nums1P = m - 1;\\n            int nums2P = n - 1;\\n            \\n            while (nums1P >= 0 && nums2P >= 0) {\\n                if (nums1[nums1P] > nums2[nums2P]) {\\n                    nums1[insertP--] = nums1[nums1P--];\\n                } else {\\n                    nums1[insertP--] = nums2[nums2P--];\\n                }\\n            }\\n            while (nums2P >= 0) {\\n                nums1[insertP--] = nums2[nums2P--];\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void merge(int[] nums1, int m, int[] nums2, int n) {\\n            // insert from the m+n-1 position at the bigger array\\n            // keep 3 pointers: one at the insertion point\\n            // one at the end of nums1; one at the end of nums2\\n            int insertP = m + n - 1;\\n            int nums1P = m - 1;\\n            int nums2P = n - 1;\\n            \\n            while (nums1P >= 0 && nums2P >= 0) {\\n                if (nums1[nums1P] > nums2[nums2P]) {\\n                    nums1[insertP--] = nums1[nums1P--];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 29505,
                "title": "1-line-solution",
                "content": "    while(n>0) A[m+n-1] = (m==0||B[n-1] > A[m-1]) ? B[--n] : A[--m];",
                "solutionTags": [
                    "Java"
                ],
                "code": "    while(n>0) A[m+n-1] = (m==0||B[n-1] > A[m-1]) ? B[--n] : A[--m];",
                "codeTag": "Unknown"
            },
            {
                "id": 2737265,
                "title": "just-3-lines-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\tfor(int i=m,j=0;i<m+n,j<n;i++,j++)\\n\\t     nums1[i]=nums2[j];\\n\\tsort(nums1.begin(),nums1.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\tfor(int i=m,j=0;i<m+n,j<n;i++,j++)\\n\\t     nums1[i]=nums2[j];\\n\\tsort(nums1.begin(),nums1.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 972587,
                "title": "basically-the-cracking-the-code-interview-solution-with-explanation",
                "content": "This is not my solution.  It\\'s a tweak of the solution in _Cracking the Code Interview_. But I wanted to share it, since it\\'s clever and I didn\\'t see it mentioned in the top discussions. Everything I saw had more than 2 conditionals or loops, or ternaries that made the solution harder to read.\\n\\nHere\\'s how it works.  Instead of starting at the beginning, then having to shift the array over when you\\'ve inserted into the first array, work backwards.  Start at the end of both arrays, you know that the biggest of these two must be the last one in the merged array, so replace the (empty) spot at the end of the merged array, then move your indexes to the left and repeat. Also, keep an index on the current spot to insert at.  Eventually you\\'ll run out of empty spots, and start overwriting spots in `nums1`.  This is OK though, because at the point this happens, all the elements that are bigger than the index at which you\\'re inserting area already present in the array where there used to be empty space!\\n\\nHere\\'s what it looks like at the point we start overwriting values in the first array\\na = 3, 4, 5, 4, 5, 6\\nb = 1, 2, 6\\naPointer = 3 (index 0)\\nbPointer = 2 (index 1)\\ninsertAt = the first 5 (index 2)\\n\\nThen, we start replacing, and the first replacement will actually be from `a` itself, since it\\'s the next biggest\\na = 3, 4, 3, 4, 5, 6\\nb = 1, 2, 6\\naPointer = null (index -1)\\nbPointer = 2 (index 1)\\ninsertAt = the first 4 (index 1)\\n\\nThen all that\\'s left is the last 2 (`1` and `2`) from `b`, which replace the first `3` and `4`, giving us the final result.\\na = 1, 2, 3, 4, 5, 6\\nb = 1, 2, 6\\naPointer = null (index -1)\\nbPointer = null (index -1)\\ninsertAt = null (index -1)\\n\\n```\\npublic void merge(int[] a, int aLength, int[] b, int bLength) {\\n    int aIndex = aLength - 1;  // initialize to the end of a, not including empty space\\n    int bIndex = bLength - 1;  // initialize to end of b\\n    int insertAt = aLength + bLength - 1;  // initialize to end of a, including empty space\\n    while (bIndex >= 0)  // looping over b, because once we\\'re out of b\\'s, the a\\'s remaining are already sorted (since input is sorted)\\n        if (aIndex >= 0 && a[aIndex] >= b[bIndex])  // a >= b\\n            a[insertAt--] = a[aIndex--];  // insert value from a, then shift indexes for a and insert\\n        else  // b < a\\n            a[insertAt--] = b[bIndex--];  // insert value from b, then shift indexes for b and insert\\n}\\n```\\n\\n**Analysis**\\n**Time:**\\n&nbsp;&nbsp;&nbsp;&nbsp;**Worst Case:** O(m + n), we iterate over each of m and n once.\\n&nbsp;&nbsp;&nbsp;&nbsp;**Best Case:** O(n), we insert b\\'s into a, and they all happen to fit exactly at the end.\\n**Memory:** O(1)\\n&nbsp;&nbsp;&nbsp;&nbsp;We introduce 3 variables.  If we used `aLength` and `bLength` instead of making new variables of `aIndex` and `bIndex`, it would actually be just 1 variable, but this is less readable.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic void merge(int[] a, int aLength, int[] b, int bLength) {\\n    int aIndex = aLength - 1;  // initialize to the end of a, not including empty space\\n    int bIndex = bLength - 1;  // initialize to end of b\\n    int insertAt = aLength + bLength - 1;  // initialize to end of a, including empty space\\n    while (bIndex >= 0)  // looping over b, because once we\\'re out of b\\'s, the a\\'s remaining are already sorted (since input is sorted)\\n        if (aIndex >= 0 && a[aIndex] >= b[bIndex])  // a >= b\\n            a[insertAt--] = a[aIndex--];  // insert value from a, then shift indexes for a and insert\\n        else  // b < a\\n            a[insertAt--] = b[bIndex--];  // insert value from b, then shift indexes for b and insert\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 197002,
                "title": "go-solution",
                "content": "```\\nfunc merge(nums1 []int, m int, nums2 []int, n int) {\\n\\tfor n > 0 {\\n\\t\\tif m == 0 || nums2[n-1] > nums1[m-1] {\\n\\t\\t\\tnums1[m+n-1] = nums2[n-1]\\n\\t\\t\\tn--\\n\\t\\t} else {\\n\\t\\t\\tnums1[m+n-1] = nums1[m-1]\\n\\t\\t\\tm--\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc merge(nums1 []int, m int, nums2 []int, n int) {\\n\\tfor n > 0 {\\n\\t\\tif m == 0 || nums2[n-1] > nums1[m-1] {\\n\\t\\t\\tnums1[m+n-1] = nums2[n-1]\\n\\t\\t\\tn--\\n\\t\\t} else {\\n\\t\\t\\tnums1[m+n-1] = nums1[m-1]\\n\\t\\t\\tm--\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 161726,
                "title": "python-in-place-o-1-extra-memory-doesn-t-use-any-library-functions-beats-100",
                "content": "It\\'s a shame this question has been down-voted. It\\'s actually a really cool question with the right constraints. In order to make it more fun/ worthwhile, I set the following rules for myself:\\n* No using library functions\\n* Only O(1) extra memory is allowed.\\n\\nI think that most interviewers would be setting these kinds of constraints too. It converts it into an awesome question!\\n\\nThe key idea is to start from the end of the arrays rather than the start. The problem with starting at the start is that we\\'d need to use extra memory (or maintain a circular array in the start of nums2... that is an option I think!).\\n\\nThen, we just keep track of our current reading point in each array, and the current point we are writing into. As long as we are working from end to start, we\\'ll never overwrite anything in nums1 that we still needed to look at.\\n\\n```py\\n    def merge(self, nums1, m, nums2, n):\\n        read_pointer_1 = m - 1\\n        read_pointer_2 = n - 1\\n        write_pointer = m + n - 1\\n        while read_pointer_2 >= 0:\\n            if read_pointer_1 >= 0 and nums1[read_pointer_1] >= nums2[read_pointer_2]:\\n                nums1[write_pointer] = nums1[read_pointer_1]\\n                read_pointer_1 -= 1\\n            else:\\n                nums1[write_pointer] = nums2[read_pointer_2]\\n                read_pointer_2 -= 1\\n            write_pointer -= 1\\n```",
                "solutionTags": [],
                "code": "```py\\n    def merge(self, nums1, m, nums2, n):\\n        read_pointer_1 = m - 1\\n        read_pointer_2 = n - 1\\n        write_pointer = m + n - 1\\n        while read_pointer_2 >= 0:\\n            if read_pointer_1 >= 0 and nums1[read_pointer_1] >= nums2[read_pointer_2]:\\n                nums1[write_pointer] = nums1[read_pointer_1]\\n                read_pointer_1 -= 1\\n            else:\\n                nums1[write_pointer] = nums2[read_pointer_2]\\n                read_pointer_2 -= 1\\n            write_pointer -= 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3061727,
                "title": "clean-python-high-speed-o-n-time-o-1-space-beats-96-9-with-explanation",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        # Initialize nums1\\'s index\\n        i = m - 1\\n        # Initialize nums2\\'s index\\n        j = n - 1\\n        # Initialize a variable k to store the last index of the 1st array...\\n        k = m + n - 1\\n        while j >= 0:\\n            if i >= 0 and nums1[i] > nums2[j]:\\n                nums1[k] = nums1[i]\\n                k -= 1\\n                i -= 1\\n            else:\\n                nums1[k] = nums2[j]\\n                k -= 1\\n                j -= 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        # Initialize nums1\\'s index\\n        i = m - 1\\n        # Initialize nums2\\'s index\\n        j = n - 1\\n        # Initialize a variable k to store the last index of the 1st array...\\n        k = m + n - 1\\n        while j >= 0:\\n            if i >= 0 and nums1[i] > nums2[j]:\\n                nums1[k] = nums1[i]\\n                k -= 1\\n                i -= 1\\n            else:\\n                nums1[k] = nums2[j]\\n                k -= 1\\n                j -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921923,
                "title": "100-fastest-swift-solution-time-o-m-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(m + n), where m is the number of elements in nums1, and n is the number of elements in nums2.\\n    //   - space: O(1), only constant space is used.\\n\\n    func merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) {\\n        var lastA = m - 1\\n        var lastB = n - 1\\n        var curr = nums1.count - 1\\n\\n        while lastA >= 0, lastB >= 0 {\\n            if nums1[lastA] >= nums2[lastB] {\\n                nums1[curr] = nums1[lastA]\\n                lastA -= 1\\n            } else {\\n                nums1[curr] = nums2[lastB]\\n                lastB -= 1\\n            }\\n            curr -= 1\\n        }\\n\\n        while lastB >= 0 {\\n            nums1[curr] = nums2[lastB]\\n            lastB -= 1\\n            curr -= 1\\n        }\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(m + n), where m is the number of elements in nums1, and n is the number of elements in nums2.\\n    //   - space: O(1), only constant space is used.\\n\\n    func merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) {\\n        var lastA = m - 1\\n        var lastB = n - 1\\n        var curr = nums1.count - 1\\n\\n        while lastA >= 0, lastB >= 0 {\\n            if nums1[lastA] >= nums2[lastB] {\\n                nums1[curr] = nums1[lastA]\\n                lastA -= 1\\n            } else {\\n                nums1[curr] = nums2[lastB]\\n                lastB -= 1\\n            }\\n            curr -= 1\\n        }\\n\\n        while lastB >= 0 {\\n            nums1[curr] = nums2[lastB]\\n            lastB -= 1\\n            curr -= 1\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875759,
                "title": "easy-js-solution-iteration-with-simple-compare-and-splice",
                "content": "```\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1.splice(m, nums1.length - m);\\n    \\n    var i = 0;\\n    var j = 0;\\n    \\n    while (j < nums2.length) {\\n        if (nums1[i] === undefined || nums1[i] > nums2[j]) {\\n            nums1.splice(i, 0, nums2[j]);\\n            j++;\\n            i++;\\n        } else {\\n            i++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1.splice(m, nums1.length - m);\\n    \\n    var i = 0;\\n    var j = 0;\\n    \\n    while (j < nums2.length) {\\n        if (nums1[i] === undefined || nums1[i] > nums2[j]) {\\n            nums1.splice(i, 0, nums2[j]);\\n            j++;\\n            i++;\\n        } else {\\n            i++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 621955,
                "title": "simple-and-concise-rust-solution-fill-from-the-end",
                "content": "```\\nimpl Solution {\\n    pub fn merge(nums1: &mut Vec<i32>, m: i32, nums2: &mut Vec<i32>, n: i32) {\\n        let (mut m, mut n) = (m as usize, n as usize);\\n        \\n        while n > 0 {\\n            if m > 0 && nums1[m - 1] > nums2[n - 1] {\\n                nums1[m + n - 1] = nums1[m - 1];\\n                m -= 1;\\n            } else {\\n                nums1[m + n - 1] = nums2[n - 1];\\n                n -= 1;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn merge(nums1: &mut Vec<i32>, m: i32, nums2: &mut Vec<i32>, n: i32) {\\n        let (mut m, mut n) = (m as usize, n as usize);\\n        \\n        while n > 0 {\\n            if m > 0 && nums1[m - 1] > nums2[n - 1] {\\n                nums1[m + n - 1] = nums1[m - 1];\\n                m -= 1;\\n            } else {\\n                nums1[m + n - 1] = nums2[n - 1];\\n                n -= 1;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 552466,
                "title": "javascript-solution",
                "content": "Runtime: 44 ms, faster than 99.13% of JavaScript online submissions for Merge Sorted Array.\\nMemory Usage: 33.8 MB, less than 80.77% of JavaScript online submissions for Merge Sorted Array.\\n\\n```\\nvar merge = function(nums1, m, nums2, n) {\\n  m--;\\n  n--;\\n  let i = nums1.length - 1;\\n  while (i >= 0) {\\n    if (n > -1 && m > -1 && nums1[m] >= nums2[n]) {\\n      nums1[i] = nums1[m];\\n      nums1[m] = nums2[n];\\n      m--;\\n    }\\n    else if (n > -1) {\\n      nums1[i] = nums2[n--];\\n    }\\n    i--;\\n  }\\n};\\n```\\n\\nI don\\'t know why, but it took me several hours to solve this :(",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar merge = function(nums1, m, nums2, n) {\\n  m--;\\n  n--;\\n  let i = nums1.length - 1;\\n  while (i >= 0) {\\n    if (n > -1 && m > -1 && nums1[m] >= nums2[n]) {\\n      nums1[i] = nums1[m];\\n      nums1[m] = nums2[n];\\n      m--;\\n    }\\n    else if (n > -1) {\\n      nums1[i] = nums2[n--];\\n    }\\n    i--;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29691,
                "title": "one-loop-solution-simple",
                "content": "```\\npublic void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\twhile (n > 0) {\\n\\t\\tif (m > 0 && nums1[m-1] > nums2[n-1]) {\\n\\t\\t\\tnums1[m+n-1] = nums1[m-1];\\n\\t\\t\\tm--;\\n\\t\\t} else {\\n\\t\\t\\tnums1[m+n-1] = nums2[n-1];\\n\\t\\t\\tn--;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\twhile (n > 0) {\\n\\t\\tif (m > 0 && nums1[m-1] > nums2[n-1]) {\\n\\t\\t\\tnums1[m+n-1] = nums1[m-1];\\n\\t\\t\\tm--;\\n\\t\\t} else {\\n\\t\\t\\tnums1[m+n-1] = nums2[n-1];\\n\\t\\t\\tn--;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3164253,
                "title": "runtime-0ms-beats-100-tricky-2-lines",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\nfor(int i=m+n-1,a=m-1,b=n-1;b>=0;i--){\\n    nums1[i] = (a>=0 && nums1[a]>nums2[b]) ? nums1[a--]: nums2[b--];\\n}\\n\\n    }\\n}\\n```\\n`Please UPVOTE. It\\'s free.`\\n\\n![upvote1.png](https://assets.leetcode.com/users/images/adf0a94e-3f33-4065-a704-285926472ad3_1675947346.75221.png)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\nfor(int i=m+n-1,a=m-1,b=n-1;b>=0;i--){\\n    nums1[i] = (a>=0 && nums1[a]>nums2[b]) ? nums1[a--]: nums2[b--];\\n}\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539414,
                "title": "python-o-m-n-time-o-1-space-solution-explained",
                "content": "### Intuition\\n\\nInstead of trying to merge from the start of ```nums1```, we can instead **start from the back and fix the largest values first**. This is simple enough; at each index ```i```, we can check the values of ```nums1[m-1]``` and ```nums2[n-1]``` and store the larger one into ```nums[i]```.\\n\\nWhile performing this operation, we need to be aware of edge cases:\\n\\n- If ```n == 0```, we\\'ve successfully merged ```nums2``` into ```nums1```. Hence, we can return straightaway since there is nothing more to be done.\\n- If ```m == 0```, we are only left with ```nums2``` elements to fix. Since we started with largest elements first, we can guarantee that the remaining ```k``` elements in ```nums2``` (where ```k <= n```) are smaller than the rest of the elements we\\'ve previously fixed. Then, since these ```k``` elements are already sorted, **we can insert ```nums2``` at the front of ```nums1``` instantly and be done with the merging**.\\n\\n---\\n\\n### Code\\n\\n```python\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        while m > 0 and n > 0:\\n\\t\\t\\t# Index to append to: len(nums1)-1 = m+n-1\\n            if nums1[m-1] > nums2[n-1]:\\n                nums1[m+n-1] = nums1[m-1]\\n                m -= 1  # Check the next element in nums1\\n            else:\\n                nums1[m+n-1] = nums2[n-1]\\n                n -= 1  # Check the next element in nums2\\n\\t\\t# The remaining k elements in nums2 can just be inserted into the front\\n\\t\\t# If k == 0, nums2 has already been merged, so this for loop is also skipped\\n        for i in range(n):\\n            nums1[i] = nums2[i]\\n\\t\\t# nums1[:n] = nums2[:n]  # one-liner\\n```\\n\\n---\\n\\n### Final Result\\n\\n![image](https://assets.leetcode.com/users/images/67c4722c-04f8-431f-bfed-74308e153b00_1635134680.1653547.png)\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```nums1```\n```i```\n```nums1[m-1]```\n```nums2[n-1]```\n```nums[i]```\n```n == 0```\n```nums2```\n```nums1```\n```m == 0```\n```nums2```\n```k```\n```nums2```\n```k <= n```\n```k```\n```nums2```\n```nums1```\n```python\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        while m > 0 and n > 0:\\n\\t\\t\\t# Index to append to: len(nums1)-1 = m+n-1\\n            if nums1[m-1] > nums2[n-1]:\\n                nums1[m+n-1] = nums1[m-1]\\n                m -= 1  # Check the next element in nums1\\n            else:\\n                nums1[m+n-1] = nums2[n-1]\\n                n -= 1  # Check the next element in nums2\\n\\t\\t# The remaining k elements in nums2 can just be inserted into the front\\n\\t\\t# If k == 0, nums2 has already been merged, so this for loop is also skipped\\n        for i in range(n):\\n            nums1[i] = nums2[i]\\n\\t\\t# nums1[:n] = nums2[:n]  # one-liner\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310926,
                "title": "java-100-faster-solution-with-explanatory-comments",
                "content": "```\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        if(m == 0){                             // First check if \\'m\\' is 0 or not\\n            for(int i = 0; i < n; i++)          // If Yes, then run a loop that traverse \\'n\\' times\\n                nums1[i] = nums2[i];            // And add all the elements of \\'nums2\\' to \\'nums1\\'\\n        }\\n                                                // Else, first initialize some variables\\n        int i = m-1;                            // A var to point the (m-1)th index of the \\'nums1\\' array\\n        int j = n-1;                            // A var to point the last index of the \\'nums2\\' array\\n        int k = m+j;                            // A var to point the last index of the \\'nums1\\' array\\n        \\n        while(i >= 0 && j >= 0){                // Now, run a loop till both \\'i\\' and \\'j\\' is not 0\\n            if(nums1[i] > nums2[j]){            // Check, if the \\'i\\'th element of \\'nums1\\' is greater than the \\'j\\'th element of \\'nums2\\' or not\\n                nums1[k] = nums1[i--];          // If Yes, then update the \\'k\\'th element of \\'nums1\\' with the \\'i\\'th element of \\'nums1\\'\\n            }\\n            else{                               // Else\\n                nums1[k] = nums2[j--];          // Update the \\'k\\'th element of \\'nums1\\' with the \\'j\\'th element of \\'nums2\\'\\n            }\\n            k--;                                // Decrease \\'k\\' to move to the previous index\\n        }\\n        \\n        while(j >= 0)                           // If \\'j\\' is still greater than 0; then it means that not all the elements of \\'nums2\\' are not added to \\'nums1\\'\\n            nums1[k--] = nums2[j--];            // So, keep adding them to the \\'k\\'th element of \\'nums1\\'\\n    }\\n}\\n\\n```\\n![image](https://assets.leetcode.com/users/images/485ec90d-0230-40b8-b944-a0d67d2d0377_1625218081.2268775.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        if(m == 0){                             // First check if \\'m\\' is 0 or not\\n            for(int i = 0; i < n; i++)          // If Yes, then run a loop that traverse \\'n\\' times\\n                nums1[i] = nums2[i];            // And add all the elements of \\'nums2\\' to \\'nums1\\'\\n        }\\n                                                // Else, first initialize some variables\\n        int i = m-1;                            // A var to point the (m-1)th index of the \\'nums1\\' array\\n        int j = n-1;                            // A var to point the last index of the \\'nums2\\' array\\n        int k = m+j;                            // A var to point the last index of the \\'nums1\\' array\\n        \\n        while(i >= 0 && j >= 0){                // Now, run a loop till both \\'i\\' and \\'j\\' is not 0\\n            if(nums1[i] > nums2[j]){            // Check, if the \\'i\\'th element of \\'nums1\\' is greater than the \\'j\\'th element of \\'nums2\\' or not\\n                nums1[k] = nums1[i--];          // If Yes, then update the \\'k\\'th element of \\'nums1\\' with the \\'i\\'th element of \\'nums1\\'\\n            }\\n            else{                               // Else\\n                nums1[k] = nums2[j--];          // Update the \\'k\\'th element of \\'nums1\\' with the \\'j\\'th element of \\'nums2\\'\\n            }\\n            k--;                                // Decrease \\'k\\' to move to the previous index\\n        }\\n        \\n        while(j >= 0)                           // If \\'j\\' is still greater than 0; then it means that not all the elements of \\'nums2\\' are not added to \\'nums1\\'\\n            nums1[k--] = nums2[j--];            // So, keep adding them to the \\'k\\'th element of \\'nums1\\'\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998135,
                "title": "go-solution-one-loop",
                "content": "```\\nfunc merge(nums1 []int, m int, nums2 []int, n int)  {   \\n    i, j, k := m-1, n-1, m+n-1\\n    for ; j>=0; k-- {\\n        if i >=0 && nums1[i] > nums2[j] {\\n            nums1[k] = nums1[i]\\n            i--\\n        } else {\\n            nums1[k] = nums2[j]\\n            j--\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc merge(nums1 []int, m int, nums2 []int, n int)  {   \\n    i, j, k := m-1, n-1, m+n-1\\n    for ; j>=0; k-- {\\n        if i >=0 && nums1[i] > nums2[j] {\\n            nums1[k] = nums1[i]\\n            i--\\n        } else {\\n            nums1[k] = nums2[j]\\n            j--\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2558954,
                "title": "go-multiple-solutions-in-go-golang-0ms-100",
                "content": "Hello Gophers!\\n\\n# Problem: Merge Sorted Array (Easy)\\n\\nI think this is an easy-medium question. If you don\\'t understand the optimal solution and it\\'s the first time you read about the \"Two/Three Pointers\" algorithm/pattern, don\\'t worry, you will master it soon!\\n\\n## Solution 1: brute force - merge and sort\\n\\nTime: `O((n+m)log(n+m))`\\nSpace: `O(log(n+m))`\\n\\n```go\\n// Time: O((n+m)log(n+m)\\n// Space: O(log(n+m))\\nfunc merge(nums1 []int, m int, nums2 []int, n int)  {\\n    // Merge nums1 and nums2\\n    nums1 = append(nums1[:n], nums2...)\\n    \\n    // Sort nums1\\n    sort.Ints(nums1)\\n}\\n```\\n\\nBecause some people like one line:\\n\\n```go\\n// Time: O((n+m)log(n+m)\\n// Space: O(log(n+m))\\nfunc merge(nums1 []int, m int, nums2 []int, n int)  {\\n    sort.Ints(append(nums1[:n], nums2...))\\n}\\n```\\n\\n## Solution 2: Three Pointers\\n\\nTime: `O(n+m)`\\nSpace: `O(1)`\\n\\n```go\\n// TIme: O(ptr3) = O(m+n-1) = O(m+n)\\n// Spac: O(1)\\nfunc merge(nums1 []int, m int, nums2 []int, n int)  { \\n    var ptr1, ptr2, ptr3 int = m-1, n-1, m+n-1\\n    for ; ptr1 >= 0 && ptr2 >= 0; ptr3-- {\\n        if nums2[ptr2] >= nums1[ptr1] {\\n            nums1[ptr3] = nums2[ptr2]\\n            ptr2--\\n        } else {\\n            nums1[ptr3] = nums1[ptr1]\\n            ptr1--\\n        }\\n    }\\n    \\n    if ptr2 >= 0 {\\n        copy(nums1[:ptr3+1], nums2[:ptr2+1])\\n    }\\n}\\n```\\n\\nIf you want to print to debug\\n\\n```go\\nfunc print(nums1, nums2 []int, ptr1, ptr2, ptr3 int) {\\n        fmt.Printf(\"ptr1=%v ptr2=%v ptr3=%v\\\\n\", ptr1, ptr2, ptr3)\\n        fmt.Printf(\"nums1=%v nums2=%v\\\\n\\\\n\", nums1, nums2)\\n}\\n```\\n\\nNext question:\\n- [1. Two Sum (Easy)](https://leetcode.com/problems/two-sum/) (see my solution [here](https://leetcode.com/problems/two-sum/discuss/1768668/Go-Many-Solutions-Clean-Code-(0ms-100)))\\n- [21. Merge Two Sorted Lists (Easy)](https://leetcode.com/problems/merge-two-sorted-lists/) (See my solution [here](https://leetcode.com/problems/merge-two-sorted-lists/discuss/2551415/Go-Clean-using-recursive-in-Go-(GoLang)-0ms-100))\\n\\nI hope it heped! =)",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\n// Time: O((n+m)log(n+m)\\n// Space: O(log(n+m))\\nfunc merge(nums1 []int, m int, nums2 []int, n int)  {\\n    // Merge nums1 and nums2\\n    nums1 = append(nums1[:n], nums2...)\\n    \\n    // Sort nums1\\n    sort.Ints(nums1)\\n}\\n```\n```go\\n// Time: O((n+m)log(n+m)\\n// Space: O(log(n+m))\\nfunc merge(nums1 []int, m int, nums2 []int, n int)  {\\n    sort.Ints(append(nums1[:n], nums2...))\\n}\\n```\n```go\\n// TIme: O(ptr3) = O(m+n-1) = O(m+n)\\n// Spac: O(1)\\nfunc merge(nums1 []int, m int, nums2 []int, n int)  { \\n    var ptr1, ptr2, ptr3 int = m-1, n-1, m+n-1\\n    for ; ptr1 >= 0 && ptr2 >= 0; ptr3-- {\\n        if nums2[ptr2] >= nums1[ptr1] {\\n            nums1[ptr3] = nums2[ptr2]\\n            ptr2--\\n        } else {\\n            nums1[ptr3] = nums1[ptr1]\\n            ptr1--\\n        }\\n    }\\n    \\n    if ptr2 >= 0 {\\n        copy(nums1[:ptr3+1], nums2[:ptr2+1])\\n    }\\n}\\n```\n```go\\nfunc print(nums1, nums2 []int, ptr1, ptr2, ptr3 int) {\\n        fmt.Printf(\"ptr1=%v ptr2=%v ptr3=%v\\\\n\", ptr1, ptr2, ptr3)\\n        fmt.Printf(\"nums1=%v nums2=%v\\\\n\\\\n\", nums1, nums2)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1467093,
                "title": "in-o-m-n-python",
                "content": "# update nums1 from the reverse side.\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        while m > 0 and n > 0:\\n            if nums1[m-1] > nums2[n-1]:\\n                nums1[m+n-1] = nums1[m-1]\\n                m -= 1\\n            else:\\n                nums1[m+n-1] = nums2[n-1]\\n                n -= 1\\n        nums1[:n] = nums2[:n]  # copying the remaining element at the begining of nums1\\n\\t\\t```\\n\\t\\tFeel free to ask Q...\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t## Approach 2 - o(nlogn) - sorting\\n\\t\\t```\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        if m == 0 :\\n            for i in range(n):\\n                nums1[i] = nums2[i]\\n        elif n == 0:\\n            pass\\n        t = m+n\\n        for i in range(m,t):\\n            x = i%n\\n            nums1[i] = nums2[x]\\n        nums1.sort()\\n\\t\\t```\\n\\n\\t\\tfeel free to ask Q...\\n\\t\\tyou can find my solution using #happytohelpu",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\t\\tFeel free to ask Q...\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t## Approach 2 - o(nlogn) - sorting\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1206661,
                "title": "javascript-solution-2-pointers",
                "content": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number} m\\n * @param {number[]} nums2\\n * @param {number} n\\n * @return {void} Do not return anything, modify nums1 in-place instead.\\n */\\nconst merge = (nums1, m, nums2, n) => {\\n  let left = m - 1\\n  let right = n - 1\\n\\n  for (let i = nums1.length - 1; i >= 0; i--) {\\n    if (right < 0) {\\n      break\\n    }\\n\\n    if (left >= 0 && nums1[left] > nums2[right]) {\\n      nums1[i] = nums1[left--]\\n    } else {\\n      nums1[i] = nums2[right--]\\n    }\\n  }\\n}\\n```\\nTime : O(n + m)\\nSpace : O(1)",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number} m\\n * @param {number[]} nums2\\n * @param {number} n\\n * @return {void} Do not return anything, modify nums1 in-place instead.\\n */\\nconst merge = (nums1, m, nums2, n) => {\\n  let left = m - 1\\n  let right = n - 1\\n\\n  for (let i = nums1.length - 1; i >= 0; i--) {\\n    if (right < 0) {\\n      break\\n    }\\n\\n    if (left >= 0 && nums1[left] > nums2[right]) {\\n      nums1[i] = nums1[left--]\\n    } else {\\n      nums1[i] = nums2[right--]\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1060482,
                "title": "simple-python-solution-92-time-o-n",
                "content": "```\\nclass Solution:\\n    def merge(self, n1: List[int], m: int, n2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        while m > 0 and n > 0:\\n            if n1[m - 1] > n2[n - 1]:\\n                n1[m + n - 1] = n1[m - 1]\\n                m -= 1\\n            else:\\n                n1[m + n - 1] = n2[n - 1]\\n                n -= 1\\n        n1[:n] = n2[:n]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, n1: List[int], m: int, n2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        while m > 0 and n > 0:\\n            if n1[m - 1] > n2[n - 1]:\\n                n1[m + n - 1] = n1[m - 1]\\n                m -= 1\\n            else:\\n                n1[m + n - 1] = n2[n - 1]\\n                n -= 1\\n        n1[:n] = n2[:n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787109,
                "title": "javascript-alternative-solution",
                "content": "Runtime: 97 ms, faster than 53.47% of JavaScript online submissions for Merge Sorted Array.\\nMemory Usage: 42.4 MB, less than 28.35% of JavaScript online submissions for Merge Sorted Array.\\n\\n```\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1.length = m;\\n    nums2.length = n;\\n    nums1.push(...nums2);\\n    nums1.sort(function(a,b){return a - b})\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1.length = m;\\n    nums2.length = n;\\n    nums1.push(...nums2);\\n    nums1.sort(function(a,b){return a - b})\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2549697,
                "title": "clean-c-solution",
                "content": "![image](https://assets.leetcode.com/users/images/480f9dec-6166-4454-a255-fc3d54fcf9e6_1662642558.6817596.png)\\n\\nI have used an extra vector because we cannot assign values with indices as we traverse from 0 to last element of the vector(the values of the element changes as we initialise it by comparing the values at the two pointers).\\n\\nAnother solution can be traversing in reverse order as the last few elements are zero.\\n\\nThis is my solution using an extra vector,because it is easier to understand\\n\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int k=0;\\n        int i=0;\\n        int j=0;\\n        vector<int> nums3;\\n        while(i<m and j<n){\\n            if(nums1[i]<nums2[j])\\n                nums3.push_back(nums1[i++]);\\n        else\\n            nums3.push_back(nums2[j++]);\\n        }\\n        \\n        while(i<m){\\n            nums3.push_back(nums1[i++]);\\n        }\\n        while(j<n){\\n            nums3.push_back(nums2[j++]);\\n        }\\n    nums1=nums3;\\n    }\\n} ;\\n````\\n\\nIt takes only 1 sec to upvote!!!\\nThanks in advance!\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int k=0;\\n        int i=0;\\n        int j=0;\\n        vector<int> nums3;\\n        while(i<m and j<n){\\n            if(nums1[i]<nums2[j])\\n                nums3.push_back(nums1[i++]);\\n        else\\n            nums3.push_back(nums2[j++]);\\n        }\\n        \\n        while(i<m){\\n            nums3.push_back(nums1[i++]);\\n        }\\n        while(j<n){\\n            nums3.push_back(nums2[j++]);\\n        }\\n    nums1=nums3;\\n    }\\n} ;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519863,
                "title": "c-java-python-javascript-2-approaches-o-m-n-log-m-n-o-m-n",
                "content": "# Intuition:\\nThe problem requires merging two sorted arrays, `nums1` and `nums2`, into `nums1`. To solve this, we can start from the end of the two arrays and compare the elements. We place the larger element at the end of `nums1` and continue this process until we reach the beginning of either array.\\n\\n# Approach 1:\\n1. Initialize a variable `n2` to store the value of `n`.\\n2. Iterate `i` from 0 to `n` (exclusive).\\n    a. Assign `nums2[n2-1]` to `nums1[m+i]` to merge the elements from `nums2` to `nums1`.\\n    b. Check if `n2` is less than or equal to 0. If true, return from the function.\\n    c. Decrement `n2` by 1.\\n3. Sort `nums1` using the `sort` function to ensure the merged array is sorted.\\n\\n# Complexity Analysis:\\n- Time Complexity: The time complexity of this approach is O((m+n)log(m+n)), where m and n are the lengths of `nums1` and `nums2` respectively. This is because we perform a sort operation on `nums1` after merging.\\n- Space Complexity: The space complexity is O(1) as we are not using any additional space that grows with the input size. We are performing the merge operation in-place.\\n# Code: \\n\\n### C++\\n```cpp\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int n2 = n;\\n        for(int i=0;i<n;i++){\\n            nums1[(m+i)]=nums2[n2-1];\\n            while(n2<0){\\n            return;\\n            }\\n            n2--;\\n        }\\n        sort(nums1.begin(),nums1.end());\\n    }\\n};\\n```\\n### Java\\n```java\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int n2 = n;\\n        for (int i = 0; i < n; i++) {\\n            nums1[m + i] = nums2[n2 - 1];\\n            while (n2 < 0) {\\n                return;\\n            }\\n            n2--;\\n        }\\n        Arrays.sort(nums1);\\n    }\\n}\\n```\\n### Python\\n```py\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        n2 = n\\n        for i in range(n):\\n            nums1[m + i] = nums2[n2 - 1]\\n            while n2 < 0:\\n                return\\n            n2 -= 1\\n        nums1.sort()\\n\\n```\\n### JavaScript\\n```js\\nvar merge = function(nums1, m, nums2, n) {\\n    let n2 = n;\\n    for (let i = 0; i < n; i++) {\\n        nums1[m + i] = nums2[n2 - 1];\\n        while (n2 < 0) {\\n            return;\\n        }\\n        n2--;\\n    }\\n    nums1.sort((a, b) => a - b);\\n};\\n```\\n\\n---\\n\\n# Optimized Approach:\\n1. We start from the end of both `nums1` and `nums2` arrays and compare the elements.\\n2. We have three pointers: `i`, `j`, and `k`. `i` points to the last element in `nums1`, `j` points to the last element in `nums2`, and `k` points to the last position in the merged array.\\n3. While `i` and `j` are greater than or equal to 0, we compare `nums1[i]` and `nums2[j]`. We place the larger element at `nums1[k]` and decrement the corresponding pointers (`i`, `j`, and `k`).\\n4. After the above loop, if there are any remaining elements in `nums2`, they should be copied to `nums1` starting from position `k` downwards.\\n5. The merged array in `nums1` is now sorted and contains all the elements from `nums1` and `nums2`.\\n\\n# Optimized Complexity:\\n- Time Complexity: The optimized approach has a time complexity of O(m + n) since we perform a linear scan through both `nums1` and `nums2`.\\n- Space Complexity: The space complexity is O(1) as we are performing the merge in-place without using any additional data structures.\\n\\n# Code:\\n\\n### C++\\n```cpp\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1;  // Index of last element in nums1\\n        int j = n - 1;  // Index of last element in nums2\\n        int k = m + n - 1;  // Index of last element in the merged array\\n\\n        while (i >= 0 && j >= 0) {\\n            if (nums1[i] > nums2[j]) {\\n                nums1[k] = nums1[i];\\n                i--;\\n            } else {\\n                nums1[k] = nums2[j];\\n                j--;\\n            }\\n            k--;\\n        }\\n\\n        // If there are any remaining elements in nums2, they should be copied to nums1\\n        while (j >= 0) {\\n            nums1[k] = nums2[j];\\n            j--;\\n            k--;\\n        }\\n    }\\n};\\n```\\n### Java\\n```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m - 1;  // Index of last element in nums1\\n        int j = n - 1;  // Index of last element in nums2\\n        int k = m + n - 1;  // Index of last element in the merged array\\n\\n        while (i >= 0 && j >= 0) {\\n            if (nums1[i] > nums2[j]) {\\n                nums1[k] = nums1[i];\\n                i--;\\n            } else {\\n                nums1[k] = nums2[j];\\n                j--;\\n            }\\n            k--;\\n        }\\n\\n        // If there are any remaining elements in nums2, they should be copied to nums1\\n        while (j >= 0) {\\n            nums1[k] = nums2[j];\\n            j--;\\n            k--;\\n        }\\n    }\\n}\\n```\\n### Python\\n```\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        i = m - 1  # Index of last element in nums1\\n        j = n - 1  # Index of last element in nums2\\n        k = m + n - 1  # Index of last element in the merged array\\n\\n        while i >= 0 and j >= 0:\\n            if nums1[i] > nums2[j]:\\n                nums1[k] = nums1[i]\\n                i -= 1\\n            else:\\n                nums1[k] = nums2[j]\\n                j -= 1\\n            k -= 1\\n\\n        # If there are any remaining elements in nums2, they should be copied to nums1\\n        while j >= 0:\\n            nums1[k] = nums2[j]\\n            j -= 1\\n            k -= 1\\n\\n```\\n### JavaScript\\n```\\nvar merge = function(nums1, m, nums2, n) {\\n    let i = m - 1;  // Index of last element in nums1\\n    let j = n - 1;  // Index of last element in nums2\\n    let k = m + n - 1;  // Index of last element in the merged array\\n\\n    while (i >= 0 && j >= 0) {\\n        if (nums1[i] > nums2[j]) {\\n            nums1[k] = nums1[i];\\n            i--;\\n        } else {\\n            nums1[k] = nums2[j];\\n            j--;\\n        }\\n        k--;\\n    }\\n\\n    // If there are any remaining elements in nums2, they should be copied to nums1\\n    while (j >= 0) {\\n        nums1[k] = nums2[j];\\n        j--;\\n        k--;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int n2 = n;\\n        for(int i=0;i<n;i++){\\n            nums1[(m+i)]=nums2[n2-1];\\n            while(n2<0){\\n            return;\\n            }\\n            n2--;\\n        }\\n        sort(nums1.begin(),nums1.end());\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int n2 = n;\\n        for (int i = 0; i < n; i++) {\\n            nums1[m + i] = nums2[n2 - 1];\\n            while (n2 < 0) {\\n                return;\\n            }\\n            n2--;\\n        }\\n        Arrays.sort(nums1);\\n    }\\n}\\n```\n```py\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        n2 = n\\n        for i in range(n):\\n            nums1[m + i] = nums2[n2 - 1]\\n            while n2 < 0:\\n                return\\n            n2 -= 1\\n        nums1.sort()\\n\\n```\n```js\\nvar merge = function(nums1, m, nums2, n) {\\n    let n2 = n;\\n    for (let i = 0; i < n; i++) {\\n        nums1[m + i] = nums2[n2 - 1];\\n        while (n2 < 0) {\\n            return;\\n        }\\n        n2--;\\n    }\\n    nums1.sort((a, b) => a - b);\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1;  // Index of last element in nums1\\n        int j = n - 1;  // Index of last element in nums2\\n        int k = m + n - 1;  // Index of last element in the merged array\\n\\n        while (i >= 0 && j >= 0) {\\n            if (nums1[i] > nums2[j]) {\\n                nums1[k] = nums1[i];\\n                i--;\\n            } else {\\n                nums1[k] = nums2[j];\\n                j--;\\n            }\\n            k--;\\n        }\\n\\n        // If there are any remaining elements in nums2, they should be copied to nums1\\n        while (j >= 0) {\\n            nums1[k] = nums2[j];\\n            j--;\\n            k--;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m - 1;  // Index of last element in nums1\\n        int j = n - 1;  // Index of last element in nums2\\n        int k = m + n - 1;  // Index of last element in the merged array\\n\\n        while (i >= 0 && j >= 0) {\\n            if (nums1[i] > nums2[j]) {\\n                nums1[k] = nums1[i];\\n                i--;\\n            } else {\\n                nums1[k] = nums2[j];\\n                j--;\\n            }\\n            k--;\\n        }\\n\\n        // If there are any remaining elements in nums2, they should be copied to nums1\\n        while (j >= 0) {\\n            nums1[k] = nums2[j];\\n            j--;\\n            k--;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        i = m - 1  # Index of last element in nums1\\n        j = n - 1  # Index of last element in nums2\\n        k = m + n - 1  # Index of last element in the merged array\\n\\n        while i >= 0 and j >= 0:\\n            if nums1[i] > nums2[j]:\\n                nums1[k] = nums1[i]\\n                i -= 1\\n            else:\\n                nums1[k] = nums2[j]\\n                j -= 1\\n            k -= 1\\n\\n        # If there are any remaining elements in nums2, they should be copied to nums1\\n        while j >= 0:\\n            nums1[k] = nums2[j]\\n            j -= 1\\n            k -= 1\\n\\n```\n```\\nvar merge = function(nums1, m, nums2, n) {\\n    let i = m - 1;  // Index of last element in nums1\\n    let j = n - 1;  // Index of last element in nums2\\n    let k = m + n - 1;  // Index of last element in the merged array\\n\\n    while (i >= 0 && j >= 0) {\\n        if (nums1[i] > nums2[j]) {\\n            nums1[k] = nums1[i];\\n            i--;\\n        } else {\\n            nums1[k] = nums2[j];\\n            j--;\\n        }\\n        k--;\\n    }\\n\\n    // If there are any remaining elements in nums2, they should be copied to nums1\\n    while (j >= 0) {\\n        nums1[k] = nums2[j];\\n        j--;\\n        k--;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765184,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        for (int i=m; i<m+n; i++) {\\n            nums1[i]=nums2[i-m];\\n        }\\n        sort(nums1.begin(), nums1.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        for (int i=m; i<m+n; i++) {\\n            nums1[i]=nums2[i-m];\\n        }\\n        sort(nums1.begin(), nums1.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099478,
                "title": "java-easy-solution-100-faster-explanation",
                "content": "```\\nclass Solution {\\n\\t    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\t        int i=m-1;\\n\\t        int j=n-1;\\n\\t        while(j>=0 && i>=0){\\n\\t            if(nums2[j]>=nums1[i]){\\n\\t                nums1[j+i+1]=nums2[j--];\\n\\t            }else{\\n\\t                nums1[j+i+1] = nums1[i--];\\n\\t            }\\n\\t        }\\n\\t         while(j >= 0) {\\n\\t         nums1[i+j+1] = nums2[j--];\\n\\t     }\\n\\t    }\\n\\t}\\n```\\n**See below if you are interested in explanation!!**\\nIn this approach we start from the last index of the given arrays, the idea is that the two arrays are already sorted and we will start putting the largest element from the last place.\\n\\nInput: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\\ni=2 & j= 2\\nIter 1 =>  6>=3 => nums[2+2+1] = 6               j-- =>1;  [1,2,3,0,0,6]\\nIter 2 =>  5>=3 => nums[2+1+1] = 5               j-- =>0;  [1,2,3,0,5,6]\\nIter 3 =>  2<3  => nums[1+2+0] = 3                i-- =>1;   [1,2,3,3,5,6]\\nIter 4 =>  2>=2  => nums[1+2+0] = 3              j-- =>1;   [1,2,2,3,5,6]\\n....\\n\\n**Please like and upvote if this was helpful to you**\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\t    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\t        int i=m-1;\\n\\t        int j=n-1;\\n\\t        while(j>=0 && i>=0){\\n\\t            if(nums2[j]>=nums1[i]){\\n\\t                nums1[j+i+1]=nums2[j--];\\n\\t            }else{\\n\\t                nums1[j+i+1] = nums1[i--];\\n\\t            }\\n\\t        }\\n\\t         while(j >= 0) {\\n\\t         nums1[i+j+1] = nums2[j--];\\n\\t     }\\n\\t    }\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652626,
                "title": "c-runtime-0ms-time-o-m-n-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       int i=m-1,j=n-1,k=m+n-1;\\n        \\n        // start inserting the element from the end nums1[]\\n        while(j>=0){\\n            if(i>=0 && nums1[i]>nums2[j]){\\n                nums1[k--]=nums1[i--];\\n            }\\n            else{\\n                nums1[k--]=nums2[j--];\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       int i=m-1,j=n-1,k=m+n-1;\\n        \\n        // start inserting the element from the end nums1[]\\n        while(j>=0){\\n            if(i>=0 && nums1[i]>nums2[j]){\\n                nums1[k--]=nums1[i--];\\n            }\\n            else{\\n                nums1[k--]=nums2[j--];\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1073589,
                "title": "python-2-pointers-beats-90",
                "content": "```\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        i = m-1\\n        j = n-1\\n        index1 = m+n-1\\n        \\n        while i >= 0 and j >= 0:\\n            if nums1[i] > nums2[j]:\\n                nums1[index1] = nums1[i]\\n                i -= 1\\n                index1 -= 1\\n            \\n            elif nums2[j] > nums1[i]:\\n                nums1[index1] = nums2[j]\\n                j -= 1\\n                index1 -= 1\\n                \\n            else:\\n                nums1[index1] = nums1[i]\\n                nums1[index1-1] = nums2[j]\\n                i -= 1\\n                j -= 1\\n                index1 -= 2\\n                \\n        while j >= 0:\\n            nums1[index1] = nums2[j]\\n            j -= 1\\n            index1 -= 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        i = m-1\\n        j = n-1\\n        index1 = m+n-1\\n        \\n        while i >= 0 and j >= 0:\\n            if nums1[i] > nums2[j]:\\n                nums1[index1] = nums1[i]\\n                i -= 1\\n                index1 -= 1\\n            \\n            elif nums2[j] > nums1[i]:\\n                nums1[index1] = nums2[j]\\n                j -= 1\\n                index1 -= 1\\n                \\n            else:\\n                nums1[index1] = nums1[i]\\n                nums1[index1-1] = nums2[j]\\n                i -= 1\\n                j -= 1\\n                index1 -= 2\\n                \\n        while j >= 0:\\n            nums1[index1] = nums2[j]\\n            j -= 1\\n            index1 -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29571,
                "title": "accepted-java-solution-o-m-n-no-extra-space",
                "content": "    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int curr1 = m -1, curr2 = n -1, start = m + n-1;\\n        while (curr1 >= 0 && curr2 >=0){\\n            if(nums1[curr1] > nums2[curr2]) nums1[start--] = nums1[curr1--];\\n            else nums1[start--] = nums2[curr2--];\\n        }\\n        if(curr1 <= 0) {\\n            while(curr2>= 0) nums1[start--] = nums2[curr2--];\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int curr1 = m -1, curr2 = n -1, start = m + n-1;\\n        while (curr1 >= 0 && curr2 >=0){\\n            if(nums1[curr1] > nums2[curr2]) nums1[start--] = nums1[curr1--];\\n            else nums1[start--] = nums2[curr2--];\\n        }\\n        if(curr1 <= 0) {\\n            while(curr2>= 0) nums1[start--] = nums2[curr2--];\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2304828,
                "title": "clean-100-faster-c-solution-brute-optimal-solution-c-gap-algorithm",
                "content": "#### **Brute-Force Solution (100% Faster )**\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        for(int i=0;i<n;i++)\\n        {\\n            nums1[m+i]=nums2[i];\\n        }\\n        sort(nums1.begin(),nums1.end());\\n    }\\n};\\nTime Complexity : O(N)+O(NlogN)\\n```\\n\\n#### **Optimal Solution (100% Faster )**\\n```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int p1=m-1;\\n        int p2=n-1;\\n        int i= m+n-1;\\n        while(p2>=0)\\n        {\\n            if(p1>=0&&nums1[p1]>nums2[p2])\\n            {\\n                nums1[i--]=nums1[p1--];\\n            }\\n            else\\n            {\\n                nums1[i--]=nums2[p2--];\\n            }\\n        }\\n    }\\n}\\nTime Complexity : O(N)\\n```\\n#### **Optimal Solution || GAP ALGORITHM**\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        for(int i=0;i<n;i++)\\n        {\\n            nums1[m+i]=nums2[i];\\n        }\\n        int gap = ceil((n+m)/2);\\n        int s = 0, e=s+gap;\\n        while(gap>=1)\\n        {\\n            s=0;\\n            e = s+gap;\\n            while(e<(m+n))\\n            {\\n                if(nums1[s]>nums1[e])\\n                {\\n                    swap(nums1[s],nums1[e]);\\n                }\\n                s++;\\n                e++;\\n            }\\n            if(gap==1)\\n            {\\n                break;\\n            }\\n            if(gap%2)\\n            {\\n                gap=gap/2+1;\\n            }\\n            else\\n            {\\n                gap = gap/2;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n### Please Upvote if you find these solutions  and Algorithms helpful !\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        for(int i=0;i<n;i++)\\n        {\\n            nums1[m+i]=nums2[i];\\n        }\\n        sort(nums1.begin(),nums1.end());\\n    }\\n};\\nTime Complexity : O(N)+O(NlogN)\\n```\n```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int p1=m-1;\\n        int p2=n-1;\\n        int i= m+n-1;\\n        while(p2>=0)\\n        {\\n            if(p1>=0&&nums1[p1]>nums2[p2])\\n            {\\n                nums1[i--]=nums1[p1--];\\n            }\\n            else\\n            {\\n                nums1[i--]=nums2[p2--];\\n            }\\n        }\\n    }\\n}\\nTime Complexity : O(N)\\n```\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        for(int i=0;i<n;i++)\\n        {\\n            nums1[m+i]=nums2[i];\\n        }\\n        int gap = ceil((n+m)/2);\\n        int s = 0, e=s+gap;\\n        while(gap>=1)\\n        {\\n            s=0;\\n            e = s+gap;\\n            while(e<(m+n))\\n            {\\n                if(nums1[s]>nums1[e])\\n                {\\n                    swap(nums1[s],nums1[e]);\\n                }\\n                s++;\\n                e++;\\n            }\\n            if(gap==1)\\n            {\\n                break;\\n            }\\n            if(gap%2)\\n            {\\n                gap=gap/2+1;\\n            }\\n            else\\n            {\\n                gap = gap/2;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120517,
                "title": "java-o-1-extra-space-explained",
                "content": "**UPVOTE IF HELPFUL**\\n\\nIn classic **merge two sorted array** question,we put two pointers in the begining on both arrays,  we compare the first elements and select minimum and move that pointer ahead.\\nIn this time is **O ( M + N )** but extra space **O ( M + N )** is used.\\n\\nIn the question we are provided with **num1** with size **N + M**, so we make use of it.\\nWe put two pointers \\n* At **m-1 for nums1**\\n* At **n-1 for nums2**\\nWe compare these values and put the larger of them at the end of array **nums1**.\\nDecrement the pointer of value chosen and keep track of where next value is to be added.\\n```\\nclass Solution \\n{\\n    public void merge(int[] nums1, int m, int[] nums2, int n) \\n    {    \\n        if(n==0)\\n            return;\\n        \\n        int lastIndex = m+n-1;\\n        m--;\\n        n--;\\n        \\n        while(n>=0)\\n        {\\n            if(m>=0 && nums1[m]>nums2[n])\\n            {\\n                nums1[lastIndex] = nums1[m--];\\n            }\\n            else\\n            {\\n                nums1[lastIndex] = nums2[n--];\\n            }\\n            lastIndex--;\\n        }\\n        return;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/c6142241-29f9-4219-b0f8-316a4f1677d3_1654572192.7052877.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public void merge(int[] nums1, int m, int[] nums2, int n) \\n    {    \\n        if(n==0)\\n            return;\\n        \\n        int lastIndex = m+n-1;\\n        m--;\\n        n--;\\n        \\n        while(n>=0)\\n        {\\n            if(m>=0 && nums1[m]>nums2[n])\\n            {\\n                nums1[lastIndex] = nums1[m--];\\n            }\\n            else\\n            {\\n                nums1[lastIndex] = nums2[n--];\\n            }\\n            lastIndex--;\\n        }\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020024,
                "title": "javascript-simple-solution",
                "content": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number} m\\n * @param {number[]} nums2\\n * @param {number} n\\n * @return {void} Do not return anything, modify nums1 in-place instead.\\n */\\nvar merge = function(nums1, m, nums2, n) {\\n    \\n    for(let i = 0; i < n; i++) {\\n        nums1[i + m] = nums2[i]\\n    }\\n    \\n    nums1.sort((a, b) => a - b);\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number} m\\n * @param {number[]} nums2\\n * @param {number} n\\n * @return {void} Do not return anything, modify nums1 in-place instead.\\n */\\nvar merge = function(nums1, m, nums2, n) {\\n    \\n    for(let i = 0; i < n; i++) {\\n        nums1[i + m] = nums2[i]\\n    }\\n    \\n    nums1.sort((a, b) => a - b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1561318,
                "title": "python-explained",
                "content": "```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        # if the second array is empty, there\\'s nothing to do\\n        if nums2:\\n            # pointer for each one of the arrays\\n            i = j = 0\\n            # while we don\\'t reach the end of any of the arrays\\n            while i < m and j < n:\\n                # if the currect element of nums1 is bigger than the current element of nums2\\n                if nums1[i] > nums2[j]:\\n                    # insert the current element of nums2 into nums1 at the current\\n                    # position of nums1 that we are inspecting\\n                    nums1.insert(i, nums2[j])\\n                    # move the nums2 pointer\\n                    j+=1\\n                    # the insertion will push all elements beyond the position i to the back\\n                    # meaning that now the final valid element of of nums1 is at position m+1\\n                    m+=1\\n                # and we always move the nums1 pointer because either the current value of nums1 \\n                # is in the correct position or it was moved one poistion further in the array \\n                # to accomodate one value from nums2\\n                i+=1\\n            # finally, if we didn\\'t reach the end of nums2\\n            if j < n:\\n                # replace all the zeros at the end of nums1 with the rest of the values of nums2 \\n                # that are not in nums1\\n                nums1[m:] = nums2[j:]\\n            else:\\n                # otherwise, we inserted all `n` elements of nums2 into nums1 and,\\n                # in this case, we need to delete the last `n` elements of nums1 \\n                # (they are the zeros that we pushed back to acomodate the nums2 values)\\n                del nums1[-n:]\\n            \\n        \\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        # if the second array is empty, there\\'s nothing to do\\n        if nums2:\\n            # pointer for each one of the arrays\\n            i = j = 0\\n            # while we don\\'t reach the end of any of the arrays\\n            while i < m and j < n:\\n                # if the currect element of nums1 is bigger than the current element of nums2\\n                if nums1[i] > nums2[j]:\\n                    # insert the current element of nums2 into nums1 at the current\\n                    # position of nums1 that we are inspecting\\n                    nums1.insert(i, nums2[j])\\n                    # move the nums2 pointer\\n                    j+=1\\n                    # the insertion will push all elements beyond the position i to the back\\n                    # meaning that now the final valid element of of nums1 is at position m+1\\n                    m+=1\\n                # and we always move the nums1 pointer because either the current value of nums1 \\n                # is in the correct position or it was moved one poistion further in the array \\n                # to accomodate one value from nums2\\n                i+=1\\n            # finally, if we didn\\'t reach the end of nums2\\n            if j < n:\\n                # replace all the zeros at the end of nums1 with the rest of the values of nums2 \\n                # that are not in nums1\\n                nums1[m:] = nums2[j:]\\n            else:\\n                # otherwise, we inserted all `n` elements of nums2 into nums1 and,\\n                # in this case, we need to delete the last `n` elements of nums1 \\n                # (they are the zeros that we pushed back to acomodate the nums2 values)\\n                del nums1[-n:]\\n            \\n        \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 545797,
                "title": "in-c",
                "content": "```\\nvoid merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n)\\n{\\n    int i, i1, i2;\\n\\n    i1 = m - 1;\\n    i2 = n - 1;\\n    i = nums1Size - 1;\\n    \\n    while (i1 >= 0 && i2 >= 0) {\\n        if (nums1[i1] > nums2[i2]) {\\n            nums1[i--] = nums1[i1--];\\n        } else {\\n            nums1[i--] = nums2[i2--];\\n        }\\n    }\\n    \\n    while (i2 >= 0) {\\n        nums1[i--] = nums2[i2--];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n)\\n{\\n    int i, i1, i2;\\n\\n    i1 = m - 1;\\n    i2 = n - 1;\\n    i = nums1Size - 1;\\n    \\n    while (i1 >= 0 && i2 >= 0) {\\n        if (nums1[i1] > nums2[i2]) {\\n            nums1[i--] = nums1[i1--];\\n        } else {\\n            nums1[i--] = nums2[i2--];\\n        }\\n    }\\n    \\n    while (i2 >= 0) {\\n        nums1[i--] = nums2[i2--];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3209013,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public void Merge(int[] nums1, int m, int[] nums2, int n) \\n    {\\n           int p1 = m-1;\\n           int p2 = n-1;\\n           int i = m+n-1;\\n\\n           while(p2>=0)\\n           {\\n               if(p1 >=0 && nums1[p1] > nums2[p2])\\n                   nums1[i--] = nums1[p1--];\\n               else\\n                  nums1[i--]= nums2[p2--];\\n           }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public void Merge(int[] nums1, int m, int[] nums2, int n) \\n    {\\n           int p1 = m-1;\\n           int p2 = n-1;\\n           int i = m+n-1;\\n\\n           while(p2>=0)\\n           {\\n               if(p1 >=0 && nums1[p1] > nums2[p2])\\n                   nums1[i--] = nums1[p1--];\\n               else\\n                  nums1[i--]= nums2[p2--];\\n           }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129990,
                "title": "python-3-last-elements-comparing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically the filled zeroes in the nums1 have to be filled with the elements in the second array..\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust traverse right from the end of the array and donnot forget to consider the left more elements in the another array...\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m+n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        last=m+n-1\\n        #index of the element\\n        while(m>0 and n>0):\\n            if(nums1[m-1]>nums2[n-1]):\\n                nums1[last]=nums1[m-1]\\n                m-=1\\n            else:\\n                nums1[last]=nums2[n-1]\\n                n-=1\\n            last-=1\\n        while(n>0):\\n            nums1[last]=nums2[n-1]\\n            n-=1\\n            last-=1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        last=m+n-1\\n        #index of the element\\n        while(m>0 and n>0):\\n            if(nums1[m-1]>nums2[n-1]):\\n                nums1[last]=nums1[m-1]\\n                m-=1\\n            else:\\n                nums1[last]=nums2[n-1]\\n                n-=1\\n            last-=1\\n        while(n>0):\\n            nums1[last]=nums2[n-1]\\n            n-=1\\n            last-=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2123074,
                "title": "easy-python-one-liner",
                "content": "```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        nums1[:] = sorted(nums1[:m]+nums2)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        nums1[:] = sorted(nums1[:m]+nums2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120436,
                "title": "0ms-solution-in-c-using-two-pointers",
                "content": "The idea here is to initialize two pointers(m&n) and point them to the end of both the arrays...\\n\\nNow, we also track the position where new element is to be inserted (k)\\n\\nNow, we traverse both the arrays from end and compare the value of elements at intex m and n.\\nSince the elements in both the arrays are sorted, we follow the following rules...\\nIf element at m is greater than n then we place it in kth index and decrement both k and m...\\nIf element at n is greater than m, then we place it in kth index and decrement both k and n...\\n\\n**Pls upvote this thread if you found this solution helpful.**\\n\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\t\\t//Size of nums1 including 0\\'s\\n        int k=m+n-1;\\n\\t\\t\\n\\t\\t//Both the pointers to point at last index\\n        m--;\\n        n--;\\n\\t\\t\\n        while(m>=0 && n>=0) {\\n\\t\\t\\t//Comparing the values and adjusting the k value accordingly\\n            if(nums1[m]>nums2[n]) nums1[k--]=nums1[m--];\\n            else nums1[k--]=nums2[n--];\\n        }\\n\\t\\t\\n\\t\\t//It might happen that elements of second array are smaller than smallest element of first array\\n        while(n>=0) nums1[k--]=nums2[n--];\\n\\t\\t\\n\\t\\t//We need not cover the otherwise case of first array elements begin smaller, because they are already in first half of the array\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\t\\t//Size of nums1 including 0\\'s\\n        int k=m+n-1;\\n\\t\\t\\n\\t\\t//Both the pointers to point at last index\\n        m--;\\n        n--;\\n\\t\\t\\n        while(m>=0 && n>=0) {\\n\\t\\t\\t//Comparing the values and adjusting the k value accordingly\\n            if(nums1[m]>nums2[n]) nums1[k--]=nums1[m--];\\n            else nums1[k--]=nums2[n--];\\n        }\\n\\t\\t\\n\\t\\t//It might happen that elements of second array are smaller than smallest element of first array\\n        while(n>=0) nums1[k--]=nums2[n--];\\n\\t\\t\\n\\t\\t//We need not cover the otherwise case of first array elements begin smaller, because they are already in first half of the array\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 376069,
                "title": "a-simple-o-m-n-c-solution",
                "content": "A simple O(m + n) C# solution that involves a linear scan starting from then end to start. Feel free to suggest improvements. Thanks! \\n\\nRuntime: 252 ms, faster than 90.82% of C# online submissions for Merge Sorted Array.\\nMemory Usage: 28.6 MB, less than 50.00% of C# online submissions for Merge Sorted Array.\\n\\n\\n```\\n    public void Merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m - 1;\\n        int j = n - 1;\\n        int k = m + n - 1;\\n        \\n        while(i >= 0 && j >= 0){\\n            if(nums1[i] > nums2[j]){\\n                nums1[k] = nums1[i];\\n                i--;\\n            }else{\\n                nums1[k] = nums2[j];\\n                j--;\\n            }\\n            k--;\\n        }\\n\\n        while(j >= 0){\\n            nums1[k] = nums2[j];\\n            k--;\\n            j--;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public void Merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m - 1;\\n        int j = n - 1;\\n        int k = m + n - 1;\\n        \\n        while(i >= 0 && j >= 0){\\n            if(nums1[i] > nums2[j]){\\n                nums1[k] = nums1[i];\\n                i--;\\n            }else{\\n                nums1[k] = nums2[j];\\n                j--;\\n            }\\n            k--;\\n        }\\n\\n        while(j >= 0){\\n            nums1[k] = nums2[j];\\n            k--;\\n            j--;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 253083,
                "title": "swift",
                "content": "```swift\\nfunc merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) {\\n        var k = m+n-1\\n        var i = m-1\\n        var j = n-1\\n        while k >= 0 && j>=0 {\\n            if i>=0 && nums1[i] > nums2[j] {\\n                nums1[k] = nums1[i]\\n                i-=1\\n            } else {\\n                nums1[k] = nums2[j]\\n                j-=1\\n            }\\n            k-=1\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```swift\\nfunc merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) {\\n        var k = m+n-1\\n        var i = m-1\\n        var j = n-1\\n        while k >= 0 && j>=0 {\\n            if i>=0 && nums1[i] > nums2[j] {\\n                nums1[k] = nums1[i]\\n                i-=1\\n            } else {\\n                nums1[k] = nums2[j]\\n                j-=1\\n            }\\n            k-=1\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29496,
                "title": "simple-java-solution-with-1-loop",
                "content": "```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m - 1;\\n        int j = n - 1;\\n        int k = m + n - 1;\\n        while (j >= 0) {\\n            if (i < 0 || nums1[i] < nums2[j]) {\\n                nums1[k--] = nums2[j--];\\n            } else {\\n                nums1[k--] = nums1[i--];\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m - 1;\\n        int j = n - 1;\\n        int k = m + n - 1;\\n        while (j >= 0) {\\n            if (i < 0 || nums1[i] < nums2[j]) {\\n                nums1[k--] = nums2[j--];\\n            } else {\\n                nums1[k--] = nums1[i--];\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29826,
                "title": "concise-solution-without-any-new-variable-3-lines",
                "content": "Like other solution, we put the largest element to the end. Use m, n for assistance.\\n\\n    void merge(int A[], int m, int B[], int n) {\\n        while (m >= 1 || n >= 1)\\n        {\\n            A[m + n - 1] = n < 1 || (m >= 1 && A[m - 1] >= B[n - 1]) ? A[--m] : B[--n];\\n        }\\n    }",
                "solutionTags": [],
                "code": "Like other solution, we put the largest element to the end. Use m, n for assistance.\\n\\n    void merge(int A[], int m, int B[], int n) {\\n        while (m >= 1 || n >= 1)\\n        {\\n            A[m + n - 1] = n < 1 || (m >= 1 && A[m - 1] >= B[n - 1]) ? A[--m] : B[--n];\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2446842,
                "title": "python-100-o-n-two-pointers-easy-solution",
                "content": "```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n\\t\\t\\n\\t\\t# merge two array from the back\\n        p1 = m - 1\\n        p2 = n - 1\\n        k = m + n - 1\\n        \\n        while p1 >= 0 and p2 >= 0:\\n            if nums1[p1] > nums2[p2]:\\n                nums1[k] = nums1[p1]\\n                p1 -= 1\\n            else: \\n                nums1[k] = nums2[p2]\\n                p2 -= 1\\n            k -= 1\\n            \\n        if p2 >= 0:\\n            nums1[:k + 1] = nums2[:p2 + 1]\\n```\\n**Please UPVOTE if you Like !!**",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n\\t\\t\\n\\t\\t# merge two array from the back\\n        p1 = m - 1\\n        p2 = n - 1\\n        k = m + n - 1\\n        \\n        while p1 >= 0 and p2 >= 0:\\n            if nums1[p1] > nums2[p2]:\\n                nums1[k] = nums1[p1]\\n                p1 -= 1\\n            else: \\n                nums1[k] = nums2[p2]\\n                p2 -= 1\\n            k -= 1\\n            \\n        if p2 >= 0:\\n            nums1[:k + 1] = nums2[:p2 + 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339925,
                "title": "java-short-solution-0ms-100-faster",
                "content": "```\\nclass Solution {\\n    public void merge(int[] A, int m, int[] B, int n) {\\n        int i = m - 1, j = n - 1, k = m + n - 1;\\n        while(i >= 0 && j >= 0) {\\n            A[k--] = A[i] > B[j] ? A[i--] : B[j--];\\n        }\\n        while(j >= 0) {\\n            A[k--] = B[j--];\\n        }\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void merge(int[] A, int m, int[] B, int n) {\\n        int i = m - 1, j = n - 1, k = m + n - 1;\\n        while(i >= 0 && j >= 0) {\\n            A[k--] = A[i] > B[j] ? A[i--] : B[j--];\\n        }\\n        while(j >= 0) {\\n            A[k--] = B[j--];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555774,
                "title": "java-tc-o-m-n-sc-o-1-simple-concise-one-pass-three-pointer-solution",
                "content": "```java\\n/**\\n * One Pass, Three Pointer Solution. Fill the numbers from right-side.\\n *\\n * Time Complexity: O(M + N)\\n *\\n * Space Complexity: O(1)\\n *\\n * M = nums1 length. N = nums2 length.\\n */\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        if (nums1 == null || nums2 == null || m < 0 || n < 0 || nums1.length < m + n || nums2.length < n) {\\n            throw new IllegalArgumentException(\"Invalid Input\");\\n        }\\n        if (n == 0) {\\n            return;\\n        }\\n\\n        int k = m + n - 1;\\n        m--;\\n        n--;\\n\\n        while (m >= 0 && n >= 0) {\\n            if (nums1[m] >= nums2[n]) {\\n                nums1[k--] = nums1[m--];\\n            } else {\\n                nums1[k--] = nums2[n--];\\n            }\\n        }\\n\\n        // Adding remaining numbers in nums2.\\n        while (n >= 0) {\\n            nums1[k--] = nums2[n--];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n/**\\n * One Pass, Three Pointer Solution. Fill the numbers from right-side.\\n *\\n * Time Complexity: O(M + N)\\n *\\n * Space Complexity: O(1)\\n *\\n * M = nums1 length. N = nums2 length.\\n */\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        if (nums1 == null || nums2 == null || m < 0 || n < 0 || nums1.length < m + n || nums2.length < n) {\\n            throw new IllegalArgumentException(\"Invalid Input\");\\n        }\\n        if (n == 0) {\\n            return;\\n        }\\n\\n        int k = m + n - 1;\\n        m--;\\n        n--;\\n\\n        while (m >= 0 && n >= 0) {\\n            if (nums1[m] >= nums2[n]) {\\n                nums1[k--] = nums1[m--];\\n            } else {\\n                nums1[k--] = nums2[n--];\\n            }\\n        }\\n\\n        // Adding remaining numbers in nums2.\\n        while (n >= 0) {\\n            nums1[k--] = nums2[n--];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29656,
                "title": "simple-clean-solution-4ms-in-c",
                "content": "    class Solution {\\n    public:\\n        void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n        {\\n            int r1 = m-1, r2 = n-1, r = m+n-1;\\n            while(r1>=0 && r2>=0)\\n                nums1[r--] = nums1[r1]>nums2[r2]? nums1[r1--] : nums2[r2--];\\n            while(r2 >= 0)\\n                nums1[r--] = nums2[r2--];\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n        {\\n            int r1 = m-1, r2 = n-1, r = m+n-1;\\n            while(r1>=0 && r2>=0)\\n                nums1[r--] = nums1[r1]>nums2[r2]? nums1[r1--] : nums2[r2--];\\n            while(r2 >= 0)\\n                nums1[r--] = nums2[r2--];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 29689,
                "title": "java-one-pass-4-lines-0ms",
                "content": "    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\t\\tint p = m+n, p1 = m-1, p2 = n-1;\\n\\t\\twhile(--p>=0) {\\n\\t\\t\\tif(p1<0 || (p2>=0 && nums1[p1]<nums2[p2])) nums1[p] = nums2[p2--];\\n\\t\\t\\telse nums1[p] = nums1[p1--];\\n\\t\\t}\\n    }",
                "solutionTags": [],
                "code": "    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\t\\tint p = m+n, p1 = m-1, p2 = n-1;\\n\\t\\twhile(--p>=0) {\\n\\t\\t\\tif(p1<0 || (p2>=0 && nums1[p1]<nums2[p2])) nums1[p] = nums2[p2--];\\n\\t\\t\\telse nums1[p] = nums1[p1--];\\n\\t\\t}\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 29702,
                "title": "ugly-python-solution",
                "content": "\\n\\n    def merge(self, nums1, m, nums2, n):\\n        i, j, k = m-1, n-1, m+n-1\\n        while i>=0 and j>=0:\\n            if nums1[i] > nums2[j]:\\n                nums1[k] = nums1[i]\\n                i -= 1\\n            else:\\n                nums1[k] = nums2[j]\\n                j -= 1\\n            k -= 1\\n        \\n        if j>=0:\\n            nums1[:k+1] = nums2[:j+1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\n    def merge(self, nums1, m, nums2, n):\\n        i, j, k = m-1, n-1, m+n-1\\n        while i>=0 and j>=0:\\n            if nums1[i] > nums2[j]:\\n                nums1[k] = nums1[i]\\n                i -= 1\\n            else:\\n                nums1[k] = nums2[j]\\n                j -= 1\\n            k -= 1\\n        \\n        if j>=0:\\n            nums1[:k+1] = nums2[:j+1]",
                "codeTag": "Python3"
            },
            {
                "id": 3662413,
                "title": "just-little-variation-of-merge-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse two pointer like merge sort.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nkeep pointers i,j,k on m-1,n-1,m+n-1 index respectively now no need to shift element from nums1 in each step. If you would have kept pointers on 0th index, shifting would have be the issue. If nums2\\'s pointer ends no need to do **while(i>=0) nums1[k--]=nums1[i--];** as we are just modifying nums1 only so i and k will point on same index and on same element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(m+n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n     O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=m-1,j=n-1,k=m+n-1;\\n        while(i>=0 && j>=0){\\n            if(nums1[i]>nums2[j]){\\n                nums1[k--]=nums1[i--];\\n            }else{\\n                nums1[k--]=nums2[j--];\\n            }\\n        }\\n        //while(i>=0) nums1[k--]=nums1[i--];\\n        while(j>=0) nums1[k--]=nums2[j--];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=m-1,j=n-1,k=m+n-1;\\n        while(i>=0 && j>=0){\\n            if(nums1[i]>nums2[j]){\\n                nums1[k--]=nums1[i--];\\n            }else{\\n                nums1[k--]=nums2[j--];\\n            }\\n        }\\n        //while(i>=0) nums1[k--]=nums1[i--];\\n        while(j>=0) nums1[k--]=nums2[j--];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650707,
                "title": "o-n-faster-solution-single-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& arr1, int m, vector<int>& arr2, int n) {\\n        int p1 = m-1, p2 = n-1, i = n+m-1;\\n        while(p2 >= 0){\\n            if(p1 >= 0 && arr1[p1] > arr2[p2]) arr1[i--] = arr1[p1--];\\n            else arr1[i--] = arr2[p2--];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& arr1, int m, vector<int>& arr2, int n) {\\n        int p1 = m-1, p2 = n-1, i = n+m-1;\\n        while(p2 >= 0){\\n            if(p1 >= 0 && arr1[p1] > arr2[p2]) arr1[i--] = arr1[p1--];\\n            else arr1[i--] = arr2[p2--];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597716,
                "title": "3-line-code-in-java-both-approaches-space-complexity-o-n-o-1",
                "content": "Hi Coders,\\n\\n**3 lines code in java**\\n\\n```\\n\\tpublic void merge(int[] nums1, int m, int[] nums2, int n) {\\n       // Space complexity O(1)\\n        int i = m-1, j = n-1, k = m+n-1;\\n        while (i>=0 && j>=0){ nums1[k--] = (nums1[i] > nums2[j]) ? nums1[i--] : nums2[j--] ; }        \\n        while (j>=0) nums1[k--] = nums2[j--];\\n    }\\n```\\n\\n**Space Complexity :- O(N)**\\n\\n```\\n\\tpublic void merge(int[] nums1, int m, int[] nums2, int n) {\\n        // Using Space Complexity O(N)\\n        int ar[]=new int[m+n];\\n        int i=0,j=0;\\n        int k=0;\\n        while(i<m && j<n){\\n            if (nums1[i] <= nums2[j]){\\n                ar[k++]=nums1[i++];\\n            }else{\\n                ar[k++]=nums2[j++];\\n            }\\n        }\\n        while (i<m){\\n            ar[k++]=nums1[i++];\\n        }\\n        while (j<n){\\n            ar[k++]=nums2[j++];\\n        }\\n        \\n        for (int a=0;a<m+n;a++){\\n            nums1[a]=ar[a];\\n        }\\n    }\\n```\\n\\n**Space Complexity :- O(1)**\\n\\n```\\n\\tpublic void merge(int[] nums1, int m, int[] nums2, int n) {\\n        \\n        // Space complexity O(1)\\n        int i = m-1;\\n        int j = n-1;\\n        int k = m+n-1;\\n        while (i>=0 && j>=0){\\n            nums1[k--] = (nums1[i] > nums2[j]) ? nums1[i--] : nums2[j--] ;\\n            /*\\n            if (nums1[i] > nums2[j]){\\n                nums1[k--] = nums1[i--];\\n            }else{\\n                nums1[k--] = nums2[j--];\\n            }\\n            */\\n        }\\n        while (j>=0) nums1[k--] = nums2[j--];\\n    }\\n```\\n\\nIf you liked the approach Please Please upvote it\\n\\nThanks!!!\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n\\tpublic void merge(int[] nums1, int m, int[] nums2, int n) {\\n       // Space complexity O(1)\\n        int i = m-1, j = n-1, k = m+n-1;\\n        while (i>=0 && j>=0){ nums1[k--] = (nums1[i] > nums2[j]) ? nums1[i--] : nums2[j--] ; }        \\n        while (j>=0) nums1[k--] = nums2[j--];\\n    }\\n```\n```\\n\\tpublic void merge(int[] nums1, int m, int[] nums2, int n) {\\n        // Using Space Complexity O(N)\\n        int ar[]=new int[m+n];\\n        int i=0,j=0;\\n        int k=0;\\n        while(i<m && j<n){\\n            if (nums1[i] <= nums2[j]){\\n                ar[k++]=nums1[i++];\\n            }else{\\n                ar[k++]=nums2[j++];\\n            }\\n        }\\n        while (i<m){\\n            ar[k++]=nums1[i++];\\n        }\\n        while (j<n){\\n            ar[k++]=nums2[j++];\\n        }\\n        \\n        for (int a=0;a<m+n;a++){\\n            nums1[a]=ar[a];\\n        }\\n    }\\n```\n```\\n\\tpublic void merge(int[] nums1, int m, int[] nums2, int n) {\\n        \\n        // Space complexity O(1)\\n        int i = m-1;\\n        int j = n-1;\\n        int k = m+n-1;\\n        while (i>=0 && j>=0){\\n            nums1[k--] = (nums1[i] > nums2[j]) ? nums1[i--] : nums2[j--] ;\\n            /*\\n            if (nums1[i] > nums2[j]){\\n                nums1[k--] = nums1[i--];\\n            }else{\\n                nums1[k--] = nums2[j--];\\n            }\\n            */\\n        }\\n        while (j>=0) nums1[k--] = nums2[j--];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1327361,
                "title": "c-linear-time-constant-space-faster-than-100",
                "content": "```\\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m-1, j = n-1, k = n+m-1;\\n        \\n        while(i>=0 && j>=0) {\\n            if(nums1[i] >= nums2[j]) {\\n                nums1[k] = nums1[i];\\n                i--;\\n            }\\n            else {\\n                nums1[k] = nums2[j];\\n                j--;\\n            }\\n            k--;\\n        }\\n        \\n        while(j>=0)\\n            nums1[k--] = nums2[j--];\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m-1, j = n-1, k = n+m-1;\\n        \\n        while(i>=0 && j>=0) {\\n            if(nums1[i] >= nums2[j]) {\\n                nums1[k] = nums1[i];\\n                i--;\\n            }\\n            else {\\n                nums1[k] = nums2[j];\\n                j--;\\n            }\\n            k--;\\n        }\\n        \\n        while(j>=0)\\n            nums1[k--] = nums2[j--];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1011768,
                "title": "merge-sorted-array-python-completely-in-place-with-explanation",
                "content": "The fillers are in the back, so we can start filling from the back. This way the original numbers in `a` won\\'t get overwritten. \\n\\nOperationally, we maintain pointers `i`, `j`, `k` for the current number in `a`, the current number in `b`, and the current position to put the number in `a`. \\n\\nIn the end, if we run out of `b` first, we need to do nothing, because all the remaining numbers in `a` are already there in place. If we run out of `a` first, the first `j` numbers in `b` are the first `j` numbers in the merged array. so we move the remaining numbers in `b` to their corresponding locations in `a`.\\n\\n```python\\nclass Solution:\\n    def merge(self, a: List[int], m: int, b: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        i,j,k = m-1, n-1, m+n-1\\n        while i >= 0 and j >= 0:\\n            if a[i] >= b[j]:\\n                a[k] = a[i]\\n                i -= 1\\n            else:\\n                a[k] = b[j]\\n                j -= 1\\n            k -= 1\\n        while j >= 0:\\n            a[j] = b[j]\\n            j -= 1\\n```\\n\\n---\\nIf you find this helpful, please **upvote**! Thank you!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def merge(self, a: List[int], m: int, b: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        i,j,k = m-1, n-1, m+n-1\\n        while i >= 0 and j >= 0:\\n            if a[i] >= b[j]:\\n                a[k] = a[i]\\n                i -= 1\\n            else:\\n                a[k] = b[j]\\n                j -= 1\\n            k -= 1\\n        while j >= 0:\\n            a[j] = b[j]\\n            j -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29708,
                "title": "java-easy-to-understand-solution",
                "content": "        \\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m-1, j = n-1, k = m+n-1;\\n        while (i>=0 && j>=0) {\\n             nums1[k--] = nums1[i]>nums2[j]?nums1[i--]:nums2[j--];\\n        }\\n        while (i==-1 && j>=0) \\n            nums1[j] = nums2[j--];\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "        \\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m-1, j = n-1, k = m+n-1;\\n        while (i>=0 && j>=0) {\\n             nums1[k--] = nums1[i]>nums2[j]?nums1[i--]:nums2[j--];\\n        }\\n        while (i==-1 && j>=0) \\n            nums1[j] = nums2[j--];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3301533,
                "title": "two-pointer-o-m-n-time-o-1-space-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\n**The intuition behind this function is to perform a merge similar to that in merge sort. Starting from the end of both arrays, we compare the last elements of nums1 and nums2, and place the larger element at the end of nums1. We continue this process until we have merged all the elements of nums1 and nums2.**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Set indices i, j, and k to m - 1, n - 1, and nums1.size() - 1, respectively.\\n2. While j is greater than or equal to 0, do the following:\\n    - a. If i is greater than or equal to 0 and the element at index i in nums1 is less than or equal to the element at index j in nums2, set the element at index k in nums1 to the element at index j in nums2 and decrement j.\\n    - b. Otherwise, set the element at index k in nums1 to the element at index i in nums1 and decrement i.\\n1. Return the modified nums1.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1, j = n - 1, k = m + n - 1;\\n        while (i >= 0 && j >= 0) {\\n            if (nums1[i] < nums2[j]) \\n                nums1[k--] = nums2[j--];\\n            else\\n                nums1[k--] = nums1[i--];\\n        } \\n        while (i >= 0)\\n            nums1[k--] = nums1[i--];\\n        while (j >= 0)\\n            nums1[k--] = nums2[j--];\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m - 1, j = n - 1, k = m + n - 1;\\n        while (i >= 0 && j >= 0) {\\n            if (nums1[i] < nums2[j]) \\n                nums1[k--] = nums2[j--];\\n            else\\n                nums1[k--] = nums1[i--];\\n        } \\n        while (i >= 0)\\n            nums1[k--] = nums1[i--];\\n        while (j >= 0)\\n            nums1[k--] = nums2[j--];\\n    }\\n}\\n\\n```\\n```Python []\\ndef merge(nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n    i, j, k = m - 1, n - 1, m + n - 1\\n    while i >= 0 and j >= 0:\\n        if nums1[i] < nums2[j]:\\n            nums1[k] = nums2[j]\\n            j -= 1\\n        else:\\n            nums1[k] = nums1[i]\\n            i -= 1\\n        k -= 1\\n    while j >= 0:\\n        nums1[k] = nums2[j]\\n        j -= 1\\n        k -= 1\\n\\n```\\n\\n# Time Complexity and Space Complexity :\\n- Time complexity : **O(m + n)**, where m and n are the sizes of the input arrays nums1 and nums2, respectively. This is because we iterate over both arrays once, comparing and merging elements into nums1. The time complexity is linear with respect to the size of the input arrays.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1, j = n - 1, k = m + n - 1;\\n        while (i >= 0 && j >= 0) {\\n            if (nums1[i] < nums2[j]) \\n                nums1[k--] = nums2[j--];\\n            else\\n                nums1[k--] = nums1[i--];\\n        } \\n        while (i >= 0)\\n            nums1[k--] = nums1[i--];\\n        while (j >= 0)\\n            nums1[k--] = nums2[j--];\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m - 1, j = n - 1, k = m + n - 1;\\n        while (i >= 0 && j >= 0) {\\n            if (nums1[i] < nums2[j]) \\n                nums1[k--] = nums2[j--];\\n            else\\n                nums1[k--] = nums1[i--];\\n        } \\n        while (i >= 0)\\n            nums1[k--] = nums1[i--];\\n        while (j >= 0)\\n            nums1[k--] = nums2[j--];\\n    }\\n}\\n\\n```\n```Python []\\ndef merge(nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n    i, j, k = m - 1, n - 1, m + n - 1\\n    while i >= 0 and j >= 0:\\n        if nums1[i] < nums2[j]:\\n            nums1[k] = nums2[j]\\n            j -= 1\\n        else:\\n            nums1[k] = nums1[i]\\n            i -= 1\\n        k -= 1\\n    while j >= 0:\\n        nums1[k] = nums2[j]\\n        j -= 1\\n        k -= 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181839,
                "title": "clean-simple-python-solution-beats-94",
                "content": "# Understand\\n\\nFirst of all we think of going from start and check \\n$$if (nums1[i] > nums2[j])$$   \\n- then we need to swap it with nums2[j] \\n- and we need to make sure nums2 remain sorted \\n\\nAfter break of condition $$i < m$$\\n- we can put nums2 remaining elements at the end because until now not a single element from $$nums2$$ had put into $$nums1$$ (because we swaped)\\nBy doing so we end up solving this problem.\\n\\n``` python [1]\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        i = j = 0\\n        while i < m and j < n:\\n            if nums1[i] > nums2[j]:\\n                nums1[i], nums2[j] = nums2[j], nums1[i]\\n\\n                k = j\\n                while j + 1 < n and nums2[j] > nums2[j + 1]:\\n                    nums2[j], nums2[j + 1] = nums2[j + 1], nums2[j]\\n                    j += 1\\n                j = k\\n\\n            i += 1\\n\\n        while j < n:\\n            nums1[i] = nums2[j]\\n            i += 1\\n            j += 1\\n\\n```\\n\\nlittle Optimized One,\\nHere, we will go from the last to first\\n- We have $$nums1$$ last elements empty so it can be used to reduce time complexity even more\\n- now we check for larger element and put it into the end of $$nums1$$ by doing this\\n\\n``` python [0]\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        i = m - 1\\n        j = n - 1 \\n        k = m + n - 1\\n        while i >= 0 and j>=0:\\n            if nums1[i] > nums2[j]:\\n                nums1[k] = nums1[i]\\n                i = i - 1\\n            else:\\n                nums1[k] = nums2[j]\\n                j = j - 1 \\n            k = k - 1\\n        \\n        while j >= 0:\\n            nums1[k] = nums2[j]\\n            j = j - 1 \\n            k = k - 1\\n```\\n\\n\\n# Complexity\\n- Time complexity: $$O(m + n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nModified by [sheff-](https://leetcode.com/sheff-/)\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` python [1]\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        i = j = 0\\n        while i < m and j < n:\\n            if nums1[i] > nums2[j]:\\n                nums1[i], nums2[j] = nums2[j], nums1[i]\\n\\n                k = j\\n                while j + 1 < n and nums2[j] > nums2[j + 1]:\\n                    nums2[j], nums2[j + 1] = nums2[j + 1], nums2[j]\\n                    j += 1\\n                j = k\\n\\n            i += 1\\n\\n        while j < n:\\n            nums1[i] = nums2[j]\\n            i += 1\\n            j += 1\\n\\n```\n``` python [0]\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        i = m - 1\\n        j = n - 1 \\n        k = m + n - 1\\n        while i >= 0 and j>=0:\\n            if nums1[i] > nums2[j]:\\n                nums1[k] = nums1[i]\\n                i = i - 1\\n            else:\\n                nums1[k] = nums2[j]\\n                j = j - 1 \\n            k = k - 1\\n        \\n        while j >= 0:\\n            nums1[k] = nums2[j]\\n            j = j - 1 \\n            k = k - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3155713,
                "title": "two-pointer-on-kotlin",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor the case where the array of numbers is ordered, the two-pointer approach is ideal.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe first pointer i points to the last element of the subarray of size m in the nums1 array, the second pointer j points to the last element of the nums2 array of size n. The pointer k points to the end of the array nums1 of size m + n.\\nUntil the pointer j reaches 0 (that is, until we reach the beginning of the nums2 array), we check the following conditions:\\n1. If the pointer i < 0 (i.e. we have reached the beginning of the nums1 array) OR nums1[i] < nums2[j] => write nums2[j] to nums1[k] and then decrease the value of j and k by 1\\n2. In all other cases, write nums1[i] to nums1[k] and then decrease the value of i and k by 1\\n\\n# Complexity\\n- Time complexity: $$O(n+m)$$\\n- Space complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    fun merge(nums1: IntArray, m: Int, nums2: IntArray, n: Int): Unit {\\n        var i = m - 1\\n        var j = n - 1\\n        var k = m + n -1\\n        while (j >= 0) {\\n            nums1[k--] = if (i < 0 || nums1[i] < nums2[j]) nums2[j--] else nums1[i--]\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun merge(nums1: IntArray, m: Int, nums2: IntArray, n: Int): Unit {\\n        var i = m - 1\\n        var j = n - 1\\n        var k = m + n -1\\n        while (j >= 0) {\\n            nums1[k--] = if (i < 0 || nums1[i] < nums2[j]) nums2[j--] else nums1[i--]\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762156,
                "title": "c-two-pointer-faster-than-100-easy-approch",
                "content": "\\n**Approch 1 : **\\n\\t\\t\\t\\t\\t\\tJust making a new vector and pushing back the elements to it as per both the pointers value this approch is very fast but it also got higher space complexity therefore use second approch for better space complexity\\n\\t\\t\\t\\t\\t\\t\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n                vector <int> v3;\\n        int i = 0; int j =0;\\n        while(i<m && j<n){\\n            \\n            if(nums1[i]>nums2[j]){\\n                v3.push_back(nums2[j]);\\n                j++;\\n            }else {\\n\\n            v3.push_back(nums1[i]);\\n                i++;\\n                \\n            }   \\n        }\\n        \\n        while(i<m){\\n            v3.push_back(nums1[i]);\\n                i++; \\n        }\\n        \\n          while(j<n){\\n            v3.push_back(nums2[j]);\\n                j++; \\n        \\n              \\n    }\\n        nums1=v3;\\n           \\n       \\n        \\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n\\n\\n# **Approch 2 : **\\n\\nThe way to think about the solution is that we will have to do a reverse sorting.\\nWe initialize k=m+n-1 as that will be the last location of nums1.\\nWe will keep checking for the greater element of the two arrays(i=m-1,j=n-1) and insert the values.\\nnums1 = [1,2,3,0,0,0],  m = 3\\nnums2 = [2,5,6],         n = 3\\n\\nnums1 = [1,2,3,0,0,0]\\nnums2 = [2,5,6]\\n                    \\nnums2[j]>nums1[i] thus nums1[k]=6\\nk and j are decremented.\\n\\nnums1 = [1,2,3,0,0,6]\\n        \\n\\nnums2 = [2,5,6]\\n                   |\\n                   j\\nnums2[j]>nums1[i] thus nums1[k]=5\\nk and j are decremented.\\n\\nnums1 = [1,2,3,0,5,6]\\n                 \\n\\nnums2 = [2,5,6]\\n                 \\nWe keep following up this procedure and we get the desired result.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n    \\n        \\n int i=m-1,j=n-1,k=m+n-1;\\n        while(i>=0&&j>=0)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                nums1[k--]=nums1[i--];\\n               \\n            }\\n            else\\n            {\\n                nums1[k--]=nums2[j--];\\n               \\n            }\\n        }\\n       \\n        while(j>=0)\\n            nums1[k--]=nums2[j--];   \\n        \\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n                vector <int> v3;\\n        int i = 0; int j =0;\\n        while(i<m && j<n){\\n            \\n            if(nums1[i]>nums2[j]){\\n                v3.push_back(nums2[j]);\\n                j++;\\n            }else {\\n\\n            v3.push_back(nums1[i]);\\n                i++;\\n                \\n            }   \\n        }\\n        \\n        while(i<m){\\n            v3.push_back(nums1[i]);\\n                i++; \\n        }\\n        \\n          while(j<n){\\n            v3.push_back(nums2[j]);\\n                j++; \\n        \\n              \\n    }\\n        nums1=v3;\\n           \\n       \\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n    \\n        \\n int i=m-1,j=n-1,k=m+n-1;\\n        while(i>=0&&j>=0)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                nums1[k--]=nums1[i--];\\n               \\n            }\\n            else\\n            {\\n                nums1[k--]=nums2[j--];\\n               \\n            }\\n        }\\n       \\n        while(j>=0)\\n            nums1[k--]=nums2[j--];   \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406224,
                "title": "python3-one-line-faster-than-96",
                "content": "```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        nums1[:] = sorted(nums1[:m]+nums2)\\n```\\n\\nEnjoy :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        nums1[:] = sorted(nums1[:m]+nums2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770023,
                "title": "c-easy-solution",
                "content": "Easy Solution Merge Sorted array\\n\\n```\\nclass Solution {\\npublic:\\n    void merge(int A[], int m, int B[], int n) {\\n        \\n        int a=m-1;\\n        int b=n-1;\\n        int i=m+n-1;    // calculate the index of the last element of the merged array\\n        \\n        // go from the back by A and B and compare and put to the A element which is larger\\n        while(a>=0 && b>=0){\\n            if(A[a]>B[b])   A[i--]=A[a--];\\n            else            A[i--]=B[b--];\\n        }\\n        \\n        // if B is longer than A just copy the rest of B to A location, otherwise no need to do anything\\n        while(b>=0)         A[i--]=B[b--];\\n    }\\n};\\n\\n```\\n\\nYou like my solution please upvote",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(int A[], int m, int B[], int n) {\\n        \\n        int a=m-1;\\n        int b=n-1;\\n        int i=m+n-1;    // calculate the index of the last element of the merged array\\n        \\n        // go from the back by A and B and compare and put to the A element which is larger\\n        while(a>=0 && b>=0){\\n            if(A[a]>B[b])   A[i--]=A[a--];\\n            else            A[i--]=B[b--];\\n        }\\n        \\n        // if B is longer than A just copy the rest of B to A location, otherwise no need to do anything\\n        while(b>=0)         A[i--]=B[b--];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 228730,
                "title": "python-solution-w-explanation",
                "content": "Doing this problem for almost 2 hours (yes, I know what you are thinking), you will be probably thinking why I spent so much time in it.\\n\\nBasically, I tried to learn shifty ways to do a merge of the sorted arrays with a funky loop from Geeksforgeeks, but I had no luck and I will come to it later again.\\n\\nHowever, there is this solution with list slicing and usingthe `sorted` function. **BE AWARE**: If you are doing job interviews and use the `sorted` function, please let your interviewer know because they are expecting how you think also. If they let you, go ahead.\\n\\nThis is the implementation:\\n\\n```\\nclass Solution:\\n    def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: void Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1[:] = sorted(nums1[:m] + nums2[:n])\\n```\\n\\nWhat it does is that slices the array that you want to store it and it will sort both `nums1` and `nums2` with their sizes (`m` and `n`). Thus, will return you the elements from the sorted array and size of it into `nums1[:]`.\\n\\nHope this helps :)",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: void Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1[:] = sorted(nums1[:m] + nums2[:n])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254724,
                "title": "optimize-code-o-m-n-java",
                "content": "# Intuition\\n- First of all, to merge in one of the given array, we have to iterate from end\\n- Which of the element is larger than other in the given array than we have to place it at the end of the first array.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Creating three variables\\n\\n        - int i=m-1;\\n        - int j=n-1;\\n        - int k=nums1.length-1;\\n\\n- We have to check i & j is greater than zero,\\n        \\n        if(i>=0 && j>=0) \\n\\n- Then check the last Element of i & j which is greater\\n    \\n (NOTE: i=(m-1) not last index bcoz we already have extra space to fill ) \\n \\n       if(nums1[i]>nums2[j]){\\n           nums1[k]=nums1[i];\\n           k--;\\n           i--;\\n        }else{\\n           nums1[k]=nums2[j];\\n           k--;\\n           j--;\\n       }\\n    \\n\\nIn this way, reducing i & j we iterate from last to first element & add all the sorted elements in Nums1[i] \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m + n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i=m-1; \\n        int j=n-1; \\n        int k=nums1.length-1; \\n\\n        while(j>=0){\\n            if(i>=0 && nums1[i]>nums2[j]){\\n                nums1[k]=nums1[i];\\n                k--; \\n                i--; \\n            } else{\\n                nums1[k] = nums2[j];\\n                k--; \\n                j--; \\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i=m-1; \\n        int j=n-1; \\n        int k=nums1.length-1; \\n\\n        while(j>=0){\\n            if(i>=0 && nums1[i]>nums2[j]){\\n                nums1[k]=nums1[i];\\n                k--; \\n                i--; \\n            } else{\\n                nums1[k] = nums2[j];\\n                k--; \\n                j--; \\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128791,
                "title": "java-c-easy-2-lines-code-with-comments-100-working-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n    // inialize j;\\n        int j = 0;  \\n        // traversal start from length of nums1  \\n        for(int i = m;i < m + n; i ++){\\n            nums1[i] = nums2[j ++];\\n        }\\n        // after sorting this\\n        Arrays.sort(nums1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n    // inialize j;\\n        int j = 0;  \\n        // traversal start from length of nums1  \\n        for(int i = m;i < m + n; i ++){\\n            nums1[i] = nums2[j ++];\\n        }\\n        // after sorting this\\n        Arrays.sort(nums1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354752,
                "title": "easy-to-understand-solution-in-java",
                "content": "Easy to understand solution in Java\\n```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n    int temp1 = m - 1; \\n    int temp2 = n - 1;\\n    int finale = m + n - 1;\\n        \\n    while (temp1 >= 0 && temp2 >= 0) {\\n        nums1[finale--] = (nums1[temp1] > nums2[temp2]) ? \\n                             nums1[temp1--] : nums2[temp2--];\\n    }\\n\\n    while (temp2 >= 0) {\\n        nums1[finale--] = nums2[temp2--];\\n    }\\n}\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n    int temp1 = m - 1; \\n    int temp2 = n - 1;\\n    int finale = m + n - 1;\\n        \\n    while (temp1 >= 0 && temp2 >= 0) {\\n        nums1[finale--] = (nums1[temp1] > nums2[temp2]) ? \\n                             nums1[temp1--] : nums2[temp2--];\\n    }\\n\\n    while (temp2 >= 0) {\\n        nums1[finale--] = nums2[temp2--];\\n    }\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120428,
                "title": "c-easy-w-two-approaches",
                "content": "**Please do upvote if you like the post :)**\\nSo basically we are given two integer arrays `nums1` and `nums2`, sorted in `non-decreasing `order, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively.\\n\\nWe need to Merge **nums1** and **nums2** into a single array sorted in non-decreasing order.\\n\\n**Intuitive/Brute Force Approach**\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       for(int i = 0 ;i<n;i++){\\n           nums1[m+i] = nums2[i];\\n       }\\n       sort(nums1.begin(),nums1.begin()+m+n);\\n   }\\n};\\n```\\n**Time Complexity : O((m+n)log(m+n))**\\n**Space Complexity : O(1)**\\n****\\n****\\n**Two Pointers Approach**\\nBasically we need take a pointer `TotalArrangements` pointing at last index of `nums1` and \\nby comparing both array take `maximum` and store at the `TotalArrangements`\\'th index and `decrement` it & keep doing this untill we finish operation for all the elements\\n\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m-1, j = n-1, TotalArrangements =m+n-1;\\n        while(j>=0){\\n            nums1[TotalArrangements--] = i>=0 && nums1[i]>nums2[j] ?nums1[i--]:nums2[j--];\\n        }\\n    }\\n};\\n```\\n**Time Complexity : O(m+n)**\\n**Space Complexity : O(1)**\\n\\n****\\n****\\n\\n![image](https://assets.leetcode.com/users/images/228bf1c2-2963-4da1-9923-aaf6cc652d41_1654570549.985409.png)\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       for(int i = 0 ;i<n;i++){\\n           nums1[m+i] = nums2[i];\\n       }\\n       sort(nums1.begin(),nums1.begin()+m+n);\\n   }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m-1, j = n-1, TotalArrangements =m+n-1;\\n        while(j>=0){\\n            nums1[TotalArrangements--] = i>=0 && nums1[i]>nums2[j] ?nums1[i--]:nums2[j--];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832326,
                "title": "single-iteration-solution-o-n-time-complexity",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int *arr = new int[m+n];\\n        int i=0,j=0;\\n        while(i<m and j<n){\\n            if(nums1[i]<nums2[j]){\\n                arr[i+j]=nums1[i];\\n                i++;\\n            }\\n            else{\\n                arr[i+j]=nums2[j];\\n                j++;\\n            }\\n        }\\n        while(i<m){\\n            arr[i+j]=nums1[i];i++;\\n        }\\n        while(j<n){\\n            arr[i+j]=nums2[j];j++;\\n        }\\n        for(int i =0;i<nums1.size();i++){\\n            nums1[i] = arr[i];\\n        }\\n        delete []arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int *arr = new int[m+n];\\n        int i=0,j=0;\\n        while(i<m and j<n){\\n            if(nums1[i]<nums2[j]){\\n                arr[i+j]=nums1[i];\\n                i++;\\n            }\\n            else{\\n                arr[i+j]=nums2[j];\\n                j++;\\n            }\\n        }\\n        while(i<m){\\n            arr[i+j]=nums1[i];i++;\\n        }\\n        while(j<n){\\n            arr[i+j]=nums2[j];j++;\\n        }\\n        for(int i =0;i<nums1.size();i++){\\n            nums1[i] = arr[i];\\n        }\\n        delete []arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718091,
                "title": "100-faster-than-any-other-java-solution-o-n-time",
                "content": "//Here use 3 pointers and start all from end of array, compare highest number first and then put at the last of nums1 and then compare remaining and then keep on inserting till we reach nums1[0]\\n        \\n        \\n```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int p1=m-1;\\n        int p2=n-1;\\n        int p3 = m+n-1;\\n        \\n        \\n        while(p2>=0){\\n           \\n            if(p1>=0 && nums1[p1]>=nums2[p2]){\\n                nums1[p3]=nums1[p1];\\n                p3--;\\n                p1--;\\n            }else{\\n                nums1[p3]=nums2[p2];\\n                p3--;\\n                p2--;\\n            }\\n        } \\n}\\n}\\n```\\n\\nDon\\'t forget to **Upvote** if you like and understand the solution !  \\nAll the best for your interviews , I am sure you can do it  :thumbsup:",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int p1=m-1;\\n        int p2=n-1;\\n        int p3 = m+n-1;\\n        \\n        \\n        while(p2>=0){\\n           \\n            if(p1>=0 && nums1[p1]>=nums2[p2]){\\n                nums1[p3]=nums1[p1];\\n                p3--;\\n                p1--;\\n            }else{\\n                nums1[p3]=nums2[p2];\\n                p3--;\\n                p2--;\\n            }\\n        } \\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616279,
                "title": "simple-java-solution-with-explaination-0ms",
                "content": "we want to merge two sorted array into one. for that since we have extra space in nums1 we don\\'t need additional memory here. the only trick is to use extra 0 present in nums1. so we start comparing element from backwards. and check if nums1[m-1] < nums2[n-1] and if yes copy nums2[n-1] at last of nums1 array else nums1[m-1] to last of nums1 array.\\nby this approach if length of any nums1 m or nums2 n reached. we know remaining element are already sorted and hence can be copied directly.\\nnow in case only num1 element left we dont need to copy it either. why? because they are already present in sorted manner in nums1 already so why to copy it again to same position where they are already present.\\n```\\npublic void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\t\\tint c = nums1.length - 1;\\n\\t\\tm--;\\n\\t\\tn--;\\n\\t\\twhile (m >= 0 && n >= 0) {\\n\\t\\t\\tnums1[c--] = nums1[m] < nums2[n] ? nums2[n--] : nums1[m--];\\n\\t\\t}\\n\\n\\t\\twhile (n >= 0) {\\n\\t\\t\\tnums1[c--] = nums2[n--];\\n\\t\\t}\\n//\\t\\tnow in case only num1 element left we dont need to copy it either. \\n//\\t\\twhy? because they are already present in sorted manner in nums1 already so why to copy it again to same position where they are already present.\\n//\\t\\twhile (m >= 0) {\\n//\\t\\t\\tnums1[c--] = nums1[m--];\\n//\\t\\t}\\n\\t}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\t\\tint c = nums1.length - 1;\\n\\t\\tm--;\\n\\t\\tn--;\\n\\t\\twhile (m >= 0 && n >= 0) {\\n\\t\\t\\tnums1[c--] = nums1[m] < nums2[n] ? nums2[n--] : nums1[m--];\\n\\t\\t}\\n\\n\\t\\twhile (n >= 0) {\\n\\t\\t\\tnums1[c--] = nums2[n--];\\n\\t\\t}\\n//\\t\\tnow in case only num1 element left we dont need to copy it either. \\n//\\t\\twhy? because they are already present in sorted manner in nums1 already so why to copy it again to same position where they are already present.\\n//\\t\\twhile (m >= 0) {\\n//\\t\\t\\tnums1[c--] = nums1[m--];\\n//\\t\\t}\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1553297,
                "title": "java-0ms-easy-to-understand",
                "content": "Go from the last element and fill nums1 with the larger of the two array\\n```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m-1, j = n-1, k = (m+n)-1;\\n        while(i>=0 && j>=0){\\n            if(nums1[i]<nums2[j]){\\n                nums1[k--] = nums2[j--];\\n            }else{\\n                nums1[k--] = nums1[i--];\\n            }\\n        }\\n        //If length of nums2 is more than length of nums1\\n        while(j>=0){\\n            nums1[k--] = nums2[j--];\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m-1, j = n-1, k = (m+n)-1;\\n        while(i>=0 && j>=0){\\n            if(nums1[i]<nums2[j]){\\n                nums1[k--] = nums2[j--];\\n            }else{\\n                nums1[k--] = nums1[i--];\\n            }\\n        }\\n        //If length of nums2 is more than length of nums1\\n        while(j>=0){\\n            nums1[k--] = nums2[j--];\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29716,
                "title": "my-c-answer-easy-to-understand",
                "content": "    void merge(int* nums1, int m, int* nums2, int n) {\\n        \\n      int k;\\n      for( k=m+n-1;k>=0;k--)\\n        {\\n            if ((nums1[m-1]>nums2[n-1]&&m>0)||n<=0)\\n            {\\n                nums1[n+m-1]=nums1[m-1];\\n                m--;\\n            }\\n            else\\n            {\\n                 nums1[n+m-1]=nums2[n-1];\\n                 n--;\\n            }\\n            \\n        }\\n    \\n     \\n    }",
                "solutionTags": [
                    "Merge Sort"
                ],
                "code": "    void merge(int* nums1, int m, int* nums2, int n) {\\n        \\n      int k;\\n      for( k=m+n-1;k>=0;k--)\\n        {\\n            if ((nums1[m-1]>nums2[n-1]&&m>0)||n<=0)\\n            {\\n                nums1[n+m-1]=nums1[m-1];\\n                m--;\\n            }\\n            else\\n            {\\n                 nums1[n+m-1]=nums2[n-1];\\n                 n--;\\n            }\\n            \\n        }\\n    \\n     \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2442861,
                "title": "100-faster-solution-for-c-and-java",
                "content": "Basically we are filling nums1 from back side so that we do not require any additional array .\\nJust take maximum of the two arrays and fill it at the end .\\n\\nJava:\\n```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=m+n-1,p1=m-1,p2=n-1;i>=0;){\\n            if(p2<0){\\n                nums1[i--]=nums1[p1--];\\n            }else if(p1<0){\\n                nums1[i--]=nums2[p2--];\\n            }else if(nums1[p1]>=nums2[p2]){\\n                nums1[i--]=nums1[p1--];\\n            }else {\\n                nums1[i--]=nums2[p2--];\\n            }\\n        }\\n        \\n    }\\n}\\n```\\n\\nC++:\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        for(int i=m+n-1,p1=m-1,p2=n-1;i>=0;){\\n            if(p2<0){\\n                nums1[i--]=nums1[p1--];\\n            }else if(p1<0){\\n                nums1[i--]=nums2[p2--];\\n            }else if(nums1[p1]>=nums2[p2]){\\n                nums1[i--]=nums1[p1--];\\n            }else {\\n                nums1[i--]=nums2[p2--];\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Array",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=m+n-1,p1=m-1,p2=n-1;i>=0;){\\n            if(p2<0){\\n                nums1[i--]=nums1[p1--];\\n            }else if(p1<0){\\n                nums1[i--]=nums2[p2--];\\n            }else if(nums1[p1]>=nums2[p2]){\\n                nums1[i--]=nums1[p1--];\\n            }else {\\n                nums1[i--]=nums2[p2--];\\n            }\\n        }\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        for(int i=m+n-1,p1=m-1,p2=n-1;i>=0;){\\n            if(p2<0){\\n                nums1[i--]=nums1[p1--];\\n            }else if(p1<0){\\n                nums1[i--]=nums2[p2--];\\n            }else if(nums1[p1]>=nums2[p2]){\\n                nums1[i--]=nums1[p1--];\\n            }else {\\n                nums1[i--]=nums2[p2--];\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2374953,
                "title": "100-faster-simple-logic-with-explanation",
                "content": "##### UPVOTE if it helps !!\\n~~~\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int p=m-1, q=n-1, cur=m+n-1;\\n        \\n        while(p>=0 && q>=0){\\n            int a = nums1[p], b = nums2[q];\\n            if(a>=b){\\n                nums1[cur] = a;\\n                p--;\\n            }\\n            else if(a<b){\\n                nums1[cur] = b;\\n                q--;\\n            }\\n            cur--;\\n        }\\n// there can be a case where one array won\\'t exhaust after above iteration. If its nums1 then it doesn\\'t matter cuz. \\n// we r placing elements in nums1 but if its nums2 that means nums2 element still left to be placed in nums1. \\n// so then we have to pick all rest nums2 element & place as it is in nums1.\\n        \\n        while(q>=0){\\n            int b = nums2[q];\\n            nums1[cur] = b;\\n            cur--; q--;\\n        }\\n    }\\n}\\n~~~\\n\\n---\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Merge Sorted Array.\\nMemory Usage: 43.3 MB, less than 15.40% of Java online submissions for Merge Sorted Array.\\n\\n---",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int p=m-1, q=n-1, cur=m+n-1;\\n        \\n        while(p>=0 && q>=0){\\n            int a = nums1[p], b = nums2[q];\\n            if(a>=b){\\n                nums1[cur] = a;\\n                p--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2122405,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public void Merge(int[] nums1, int m, int[] nums2, int n) {        \\n        int i = m - 1,\\n            j = n - 1,\\n            k = m + n - 1;\\n        \\n        while (i > -1 && j > -1)\\n        {\\n            if (nums1[i] >= nums2[j])\\n            {\\n                nums1[k] = nums1[i--];\\n            }\\n            else\\n            {\\n                nums1[k] = nums2[j--];\\n            }\\n            \\n            k--;\\n        }\\n        \\n        while (j > -1)\\n        {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public void Merge(int[] nums1, int m, int[] nums2, int n) {        \\n        int i = m - 1,\\n            j = n - 1,\\n            k = m + n - 1;\\n        \\n        while (i > -1 && j > -1)\\n        {\\n            if (nums1[i] >= nums2[j])\\n            {\\n                nums1[k] = nums1[i--];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2065261,
                "title": "python-two-pointers-with-explanation",
                "content": "Hope my explanation helps other LeetCode newbies like me =)\\n\\n\\tclass Solution:\\n\\t\\tdef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n\\t\\t\\t# while there are still elements in m and n\\n\\t\\t\\twhile m > 0 and n > 0:\\n\\n\\t\\t\\t\\t# compare the last element of nums1 and nums2,\\n\\t\\t\\t\\t# if the last element in nums1 > last element in\\n\\t\\t\\t\\t# nums2, then we can insert the last element in\\n\\t\\t\\t\\t# nums1 into the last position of nums1+nums2 array.\\n\\t\\t\\t\\t# Then continue searching to the left of nums1 by\\n\\t\\t\\t\\t# decrease the m index by 1\\n\\t\\t\\t\\tif nums1[m-1] > nums2[n-1]:\\n\\t\\t\\t\\t\\tnums1[m+n-1] = nums1[m-1]\\n\\t\\t\\t\\t\\tm -= 1\\n\\n\\t\\t\\t\\t# compare the last element of nums1 and nums2,\\n\\t\\t\\t\\t# if the last element in nums1 <= last element in\\n\\t\\t\\t\\t# nums2, then we can insert the last element in\\n\\t\\t\\t\\t# nums2 into the last position of nums1+nums2 array.\\n\\t\\t\\t\\t# Then continue searching to the left of nums2 by\\n\\t\\t\\t\\t# decrease the n index by 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tnums1[m+n-1] = nums2[n-1]\\n\\t\\t\\t\\t\\tn -= 1\\n\\n\\t\\t\\t# after searching through all elements in nums1, if there\\n\\t\\t\\t# are still some leftovers in nums2, we can insert the remainings\\n\\t\\t\\t# in nums2 into the positions in nums1\\n\\t\\t\\tnums1[:n] = nums2[:n]",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "Hope my explanation helps other LeetCode newbies like me =)\\n\\n\\tclass Solution:\\n\\t\\tdef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n\\t\\t\\t# while there are still elements in m and n\\n\\t\\t\\twhile m > 0 and n > 0:\\n\\n\\t\\t\\t\\t# compare the last element of nums1 and nums2,\\n\\t\\t\\t\\t# if the last element in nums1 > last element in\\n\\t\\t\\t\\t# nums2, then we can insert the last element in\\n\\t\\t\\t\\t# nums1 into the last position of nums1+nums2 array.\\n\\t\\t\\t\\t# Then continue searching to the left of nums1 by\\n\\t\\t\\t\\t# decrease the m index by 1\\n\\t\\t\\t\\tif nums1[m-1] > nums2[n-1]:\\n\\t\\t\\t\\t\\tnums1[m+n-1] = nums1[m-1]\\n\\t\\t\\t\\t\\tm -= 1\\n\\n\\t\\t\\t\\t# compare the last element of nums1 and nums2,\\n\\t\\t\\t\\t# if the last element in nums1 <= last element in\\n\\t\\t\\t\\t# nums2, then we can insert the last element in\\n\\t\\t\\t\\t# nums2 into the last position of nums1+nums2 array.\\n\\t\\t\\t\\t# Then continue searching to the left of nums2 by\\n\\t\\t\\t\\t# decrease the n index by 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tnums1[m+n-1] = nums2[n-1]\\n\\t\\t\\t\\t\\tn -= 1\\n\\n\\t\\t\\t# after searching through all elements in nums1, if there\\n\\t\\t\\t# are still some leftovers in nums2, we can insert the remainings\\n\\t\\t\\t# in nums2 into the positions in nums1\\n\\t\\t\\tnums1[:n] = nums2[:n]",
                "codeTag": "Java"
            },
            {
                "id": 1689056,
                "title": "very-simple-approach-2-pointer-linear-time-complexity-and-o-1-space-complexity",
                "content": "```\\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       int i = m-1;\\n        int j = n-1;\\n        int k=m+n-1;\\n        while(j>=0){\\n            if(i>=0&&nums1[i]>nums2[j]){\\n                nums1[k--] = nums1[i--];\\n            }else{\\n                nums1[k--] = nums2[j--];\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       int i = m-1;\\n        int j = n-1;\\n        int k=m+n-1;\\n        while(j>=0){\\n            if(i>=0&&nums1[i]>nums2[j]){\\n                nums1[k--] = nums1[i--];\\n            }else{\\n                nums1[k--] = nums2[j--];\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1663659,
                "title": "c-easy-and-simple-time-o-n-space-o-1",
                "content": "\\t\\tExample taken:  \\n\\t\\t\\t\\t\\t\\t-> a: [1, 2, 3, 0, 0, 0]\\n\\t\\t\\t\\t\\t\\t-> b: [2, 5, 6]\\nSteps: \\n\\t\\t\\t\\t\\t\\t\\n1. Reverse both the arrays.\\n\\t-> Then it would be like this: \\n\\t\\t\\t\\ta: ``` [0, 0, 0, 3, 2, 1] ```\\n\\t\\t\\t\\tb: ``` [6, 5, 2] ```\\n\\t\\t\\t\\t\\n2. Take three pointers: \\n\\ti) **i** pointing to the first participating element from **a** // Here it is 3\\n\\tii) **j** pointing to the first participating element from **b** // Here it is 6\\n\\tiii) **ind** pointing to the first empty space in **a** to be filled // Here it is ind = 0\\n\\n3. Then iterate until **i** reach the end of **a** OR **j** reach the end of **b**:\\n\\ti) Simply put the bigger element on index \"**ind**\" in **a** and increase the corresponding **i** OR **j**\\n\\n4. At last just put the remaining elements of **b** into **a**.\\n\\n```\\nvoid merge(vector<int>& a, int n, vector<int>& b, int m) \\n    {\\n\\t\\t// Reversing the arrays\\n\\t\\treverse(a.begin(), a.end());\\n        reverse(b.begin(), b.end());\\n\\n\\t\\t// Taking pointers\\n        int i = m, j = 0, ind = 0;\\n\\t\\t\\n        while(i < (n + m) && j < m)\\n        {\\n\\t\\t\\t// Inserting the bigger element into \"a\" at \"ind\"\\n\\t\\t\\tif(a[i] > b[j])\\n            {\\n                a[ind] = a[i];\\n                i++;\\n            }\\n            else \\n            {\\n                a[ind] = b[j];\\n                j++;\\n            }\\n            ind++;\\n        }\\n\\t\\t\\n\\t\\t//Inserting the remaining elements\\n        while(j < m) \\n        {\\n            a[ind++] = b[j++];\\n        }        \\n\\t\\t\\n\\t\\t//Reversing the array \"a\" to get the final result\\n        reverse(a.begin(), a.end());\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "``` [0, 0, 0, 3, 2, 1] ```\n``` [6, 5, 2] ```\n```\\nvoid merge(vector<int>& a, int n, vector<int>& b, int m) \\n    {\\n\\t\\t// Reversing the arrays\\n\\t\\treverse(a.begin(), a.end());\\n        reverse(b.begin(), b.end());\\n\\n\\t\\t// Taking pointers\\n        int i = m, j = 0, ind = 0;\\n\\t\\t\\n        while(i < (n + m) && j < m)\\n        {\\n\\t\\t\\t// Inserting the bigger element into \"a\" at \"ind\"\\n\\t\\t\\tif(a[i] > b[j])\\n            {\\n                a[ind] = a[i];\\n                i++;\\n            }\\n            else \\n            {\\n                a[ind] = b[j];\\n                j++;\\n            }\\n            ind++;\\n        }\\n\\t\\t\\n\\t\\t//Inserting the remaining elements\\n        while(j < m) \\n        {\\n            a[ind++] = b[j++];\\n        }        \\n\\t\\t\\n\\t\\t//Reversing the array \"a\" to get the final result\\n        reverse(a.begin(), a.end());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1617947,
                "title": "python3-short-clean-solution-1-loop-o-n-time-o-1-space",
                "content": "Below is the code. Please let me know if you have any questions!\\n```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        index1, index2 = m - 1, n - 1\\n        for i in range(len(nums1) - 1, -1, -1):\\n            val1 = nums1[index1] if index1 >= 0 else float(\\'-inf\\')\\n            val2 = nums2[index2] if index2 >= 0 else float(\\'-inf\\')\\n            if val1 >= val2:\\n                nums1[i] = val1\\n                index1 -= 1\\n            else:\\n                nums1[i] = val2\\n                index2 -= 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        index1, index2 = m - 1, n - 1\\n        for i in range(len(nums1) - 1, -1, -1):\\n            val1 = nums1[index1] if index1 >= 0 else float(\\'-inf\\')\\n            val2 = nums2[index2] if index2 >= 0 else float(\\'-inf\\')\\n            if val1 >= val2:\\n                nums1[i] = val1\\n                index1 -= 1\\n            else:\\n                nums1[i] = val2\\n                index2 -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1595446,
                "title": "c-two-pointer-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Merge Sorted Array.\\nMemory Usage: 9.1 MB, less than 28.89% of C++ online submissions for Merge Sorted Array.\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1, j = n - 1, k = nums1.size() - 1;\\n        while (i >= 0 && j >= 0) {\\n            if (nums1[i] > nums2[j]) {\\n                nums1[k--] = nums1[i--];\\n            } else {\\n                nums1[k--] = nums2[j--];\\n            }\\n        }\\n        while (j >= 0) {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1, j = n - 1, k = nums1.size() - 1;\\n        while (i >= 0 && j >= 0) {\\n            if (nums1[i] > nums2[j]) {\\n                nums1[k--] = nums1[i--];\\n            } else {\\n                nums1[k--] = nums2[j--];\\n            }\\n        }\\n        while (j >= 0) {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455890,
                "title": "java-100-short-simple-solution-2-pointers",
                "content": "\\tpublic void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\t\\tint i = m - 1;\\n\\t\\tint j = n - 1;\\n\\t\\tint index = nums1.length - 1;\\n\\t\\twhile (index >= 0 && i >= 0 && j >= 0) {\\n\\t\\t\\tnums1[index--] = nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];\\n\\t\\t}\\n\\t\\t// Check in case some elements from nums2 are still there. \\n\\t\\t// No need to do the same for nums1, it would be already sorted and in place\\n\\t\\twhile (j >= 0) {\\n\\t\\t\\tnums1[index--] = nums2[j--];\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "\\tpublic void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\t\\tint i = m - 1;\\n\\t\\tint j = n - 1;\\n\\t\\tint index = nums1.length - 1;\\n\\t\\twhile (index >= 0 && i >= 0 && j >= 0) {\\n\\t\\t\\tnums1[index--] = nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];\\n\\t\\t}\\n\\t\\t// Check in case some elements from nums2 are still there. \\n\\t\\t// No need to do the same for nums1, it would be already sorted and in place\\n\\t\\twhile (j >= 0) {\\n\\t\\t\\tnums1[index--] = nums2[j--];\\n\\t\\t}\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1406693,
                "title": "two-pointer",
                "content": "You can read more about LeetCode Notes in my blog [iamyqhp.com](http://iamyqhp.com/),Thanks for reading \\n# 88. Merge Sorted Array\\n\\nThis problem is a very easy problem.We can use double pointer solve this problem easily.\\n\\n![](https://assets.leetcode.com/users/images/7c3170ac-600e-41f0-ab88-4d3af819084a_1629105666.4874687.gif)\\n\\n\\n**solution**\\n\\n```java\\n  public void merge(int[] nums1, int m, int[] nums2, int n) {\\n    //make a new array to get the answer\\n    int[] result = new int[m + n];\\n    //beginning from both head\\n    int i = 0, j = 0, temp;\\n    while (i < m || j < n) {\\n      if (i == m) {\\n        //if nums1 is ending just copy the nums2\\n        temp = nums2[j++];\\n      } else if (j == n) {\\n        //if nums2 is ending just copy the nums1\\n        temp = nums1[i++];\\n      } else if (nums1[i] < nums2[j]) {\\n        //copy the smaller number\\n        temp = nums1[i++];\\n      } else {\\n        temp = nums2[j++];\\n      }\\n      result[i + j - 1] = temp;\\n    }\\n    //copy the answer to the nums1\\n    for (int length = 0; length < n + m; length++) {\\n      nums1[length] = result[length];\\n    }\\n  }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n  public void merge(int[] nums1, int m, int[] nums2, int n) {\\n    //make a new array to get the answer\\n    int[] result = new int[m + n];\\n    //beginning from both head\\n    int i = 0, j = 0, temp;\\n    while (i < m || j < n) {\\n      if (i == m) {\\n        //if nums1 is ending just copy the nums2\\n        temp = nums2[j++];\\n      } else if (j == n) {\\n        //if nums2 is ending just copy the nums1\\n        temp = nums1[i++];\\n      } else if (nums1[i] < nums2[j]) {\\n        //copy the smaller number\\n        temp = nums1[i++];\\n      } else {\\n        temp = nums2[j++];\\n      }\\n      result[i + j - 1] = temp;\\n    }\\n    //copy the answer to the nums1\\n    for (int length = 0; length < n + m; length++) {\\n      nums1[length] = result[length];\\n    }\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1081677,
                "title": "easy-java-solution-beat-100",
                "content": "```\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=m;i<nums1.length;++i){\\n            nums1[i]=nums2[i-m];\\n        }\\n        Arrays.sort(nums1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=m;i<nums1.length;++i){\\n            nums1[i]=nums2[i-m];\\n        }\\n        Arrays.sort(nums1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563033,
                "title": "javascript",
                "content": "```\\nvar merge = function(nums1, m, nums2, n) {\\n    let curIndex = m + n;\\n    let num1 = nums1[--m];\\n    let num2 = nums2[--n];\\n    \\n    while (curIndex) {\\n        if (n < 0) {\\n            break;\\n        };\\n        if (num1 > num2) {\\n            nums1[--curIndex] = num1;\\n            num1 = nums1[--m];\\n        } else {\\n            nums1[--curIndex] = num2;\\n            num2 = nums2[--n];\\n        };\\n    };\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar merge = function(nums1, m, nums2, n) {\\n    let curIndex = m + n;\\n    let num1 = nums1[--m];\\n    let num2 = nums2[--n];\\n    \\n    while (curIndex) {\\n        if (n < 0) {\\n            break;\\n        };\\n        if (num1 > num2) {\\n            nums1[--curIndex] = num1;\\n            num1 = nums1[--m];\\n        } else {\\n            nums1[--curIndex] = num2;\\n            num2 = nums2[--n];\\n        };\\n    };\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29501,
                "title": "javascript-solution",
                "content": "````\\nvar merge = function(nums1, m, nums2, n) {\\n    var x = 0,\\n        y = 0;\\n    \\n    nums1.splice(m, nums1.length);\\n    nums2.splice(n, nums2.length);\\n    \\n    while(y < n){\\n        if(nums2[y] < nums1[x] || nums1[x] === undefined){\\n            nums1.splice(x, 0, nums2[y]);\\n            x++;\\n            y++;    \\n        } else {\\n            x++;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "````\\nvar merge = function(nums1, m, nums2, n) {\\n    var x = 0,\\n        y = 0;\\n    \\n    nums1.splice(m, nums1.length);\\n    nums2.splice(n, nums2.length);\\n    \\n    while(y < n){\\n        if(nums2[y] < nums1[x] || nums1[x] === undefined){\\n            nums1.splice(x, 0, nums2[y]);\\n            x++;\\n            y++;    \\n        } else {\\n            x++;\\n        }\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3544442,
                "title": "easy-solution-with-array-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public void Merge(int[] nums1, int m, int[] nums2, int n) {\\n    Array.Copy(nums2, 0, nums1, m, n);\\n    Array.Sort(nums1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public void Merge(int[] nums1, int m, int[] nums2, int n) {\\n    Array.Copy(nums2, 0, nums1, m, n);\\n    Array.Sort(nums1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457487,
                "title": "beats-86-27-11-145-top-interview-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n*Sorting comes to the mind , then shifted to two-pointer approach*\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\nThis code implements the merging of two sorted arrays `nums1` and `nums2` into a single sorted array `nums1`. \\n\\nThe approach used here is to start from the end of `nums1` and `nums2` and compare the elements at their respective positions. The larger element is placed at the end of `nums1`, and the respective counter (i or j) is decremented. The loop continues until either `nums1` or `nums2` has been completely merged into `nums1`.\\n\\nAfter this initial merge, if there are still elements left in `nums2`, they are added to the beginning of `nums1`.\\n\\nHere is a step-by-step explanation of the approach:\\n\\n1. Initialize two pointers `i` and `j` to the last valid index of `nums1` and `nums2`, respectively.\\n2. Initialize a counter `counter` to the last valid index of `nums1`.\\n3. While both `i` and `j` are greater than or equal to 0, compare `nums1[i]` and `nums2[j]`. \\n   - If `nums2[j]` is greater or equal to `nums1[i]`, set `nums1[counter]` to `nums2[j]`, decrement `j` and `counter`.\\n   - Otherwise, set `nums1[counter]` to `nums1[i]`, set `nums1[i]` to 0 (to mark the element as \"used\"), decrement `i` and `counter`.\\n4. If there are still elements left in `nums2`, copy them to the beginning of `nums1`.\\n\\n# Complexity\\n- Time complexity:\\n    O(m+n)\\n\\n- Space complexity:\\n    O(1)\\n\\nThe `time complexity` of the given code is `O(m + n)`, where `m` and `n` are the lengths of the input arrays `nums1` and `nums2`, respectively. This is because the code iterates through both arrays only once, comparing and copying elements as needed.\\n\\nThe `space complexity` of the code is `O(1)`, as it uses constant extra space for the `i`, `j`, and `counter` variables. The original input array `nums1` is modified in place to hold the merged elements, and no additional data structures are used. Therefore, the space used by the algorithm does not depend on the size of the input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n \\n        i , j = m-1 , n-1\\n        counter = (m+n)-1\\n        while j >= 0  and i >= 0 :\\n            if nums2[j] >= nums1[i]: \\n                nums1[counter] = nums2[j]\\n                counter -= 1\\n                j -= 1\\n            else:\\n                nums1[counter] = nums1[i]\\n                nums1[i] = 0\\n                counter -= 1\\n                i -=1\\n        \\n        if j >= 0:\\n            for k in range(j+1):\\n                nums1[k] = nums2[k]\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n \\n        i , j = m-1 , n-1\\n        counter = (m+n)-1\\n        while j >= 0  and i >= 0 :\\n            if nums2[j] >= nums1[i]: \\n                nums1[counter] = nums2[j]\\n                counter -= 1\\n                j -= 1\\n            else:\\n                nums1[counter] = nums1[i]\\n                nums1[i] = 0\\n                counter -= 1\\n                i -=1\\n        \\n        if j >= 0:\\n            for k in range(j+1):\\n                nums1[k] = nums2[k]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432899,
                "title": "simple-python-solution-with-3-pointers",
                "content": "# Code\\n```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        i,j,k = m-1,n-1,m+n-1\\n        while j>=0:\\n            if i>=0 and nums1[i]>nums2[j]:\\n                nums1[k]=nums1[i]\\n                i-=1\\n            else:\\n                nums1[k]=nums2[j]                \\n                j-=1\\n            k-=1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        i,j,k = m-1,n-1,m+n-1\\n        while j>=0:\\n            if i>=0 and nums1[i]>nums2[j]:\\n                nums1[k]=nums1[i]\\n                i-=1\\n            else:\\n                nums1[k]=nums2[j]                \\n                j-=1\\n            k-=1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083138,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O((n+m)*log(n+m))$$\\n\\n- Space complexity:$$O(n+m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        while(nums1.size()>m){\\n            nums1.pop_back();\\n        }\\n        for(int j=0; j<n; j++){\\n            nums1.push_back(nums2[j]);\\n        }\\n        sort(nums1.begin(), nums1.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        while(nums1.size()>m){\\n            nums1.pop_back();\\n        }\\n        for(int j=0; j<n; j++){\\n            nums1.push_back(nums2[j]);\\n        }\\n        sort(nums1.begin(), nums1.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686085,
                "title": "typescript-solution-in-o-m-n-time-explanation",
                "content": "The solution is actually looping once on `nums1` array from its end (which is empty) to the start. \\nOn each iteration, we decide whether to copy an element from `nums1` or from `nums2` (starting from their end and using `index1` and `index2` to keep pointing to the remaining elements of each array). \\nIt\\'s better to start inserting elements into the back of the array of `nums1`, where there\\'s empty space...\\n\\nNote that there\\'s no need to continue looping after running out of elements in `nums2`, since `nums1` is already sorted.\\n\\n```\\n// Space complexity: O(1) - no additional space\\n// Time complexity: O(n+m)\\n\\n/**\\n Do not return anything, modify nums1 in-place instead.\\n */\\nfunction merge(nums1: number[], m: number, nums2: number[], n: number): void {\\n    let index1 = m-1;\\n    let index2 = n-1;\\n    \\n    for (let i = n+m-1; i >= 0 && index2 >= 0; i--){\\n        const num1 = nums1[index1];\\n        const num2 = nums2[index2]\\n        \\n        if (index1 >= 0 && num1 > num2){\\n            nums1[i] = num1;\\n            index1--;\\n        } else {\\n            nums1[i] = num2;\\n            index2--;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Sorting"
                ],
                "code": "```\\n// Space complexity: O(1) - no additional space\\n// Time complexity: O(n+m)\\n\\n/**\\n Do not return anything, modify nums1 in-place instead.\\n */\\nfunction merge(nums1: number[], m: number, nums2: number[], n: number): void {\\n    let index1 = m-1;\\n    let index2 = n-1;\\n    \\n    for (let i = n+m-1; i >= 0 && index2 >= 0; i--){\\n        const num1 = nums1[index1];\\n        const num2 = nums2[index2]\\n        \\n        if (index1 >= 0 && num1 > num2){\\n            nums1[i] = num1;\\n            index1--;\\n        } else {\\n            nums1[i] = num2;\\n            index2--;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2334169,
                "title": "python-o-n-two-pointers-easy-solution",
                "content": "```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n\\t\\t\\n\\t\\t# merge two array from the back\\n        p1 = m - 1\\n        p2 = n - 1\\n        k = m + n - 1\\n        \\n        while p1 >= 0 and p2 >= 0:\\n            if nums1[p1] > nums2[p2]:\\n                nums1[k] = nums1[p1]\\n                p1 -= 1\\n            else: \\n                nums1[k] = nums2[p2]\\n                p2 -= 1\\n            k -= 1\\n            \\n        if p2 >= 0:\\n            nums1[:k + 1] = nums2[:p2 + 1]\\n```\\nPlease UPVOTE if you Like !!",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n\\t\\t\\n\\t\\t# merge two array from the back\\n        p1 = m - 1\\n        p2 = n - 1\\n        k = m + n - 1\\n        \\n        while p1 >= 0 and p2 >= 0:\\n            if nums1[p1] > nums2[p2]:\\n                nums1[k] = nums1[p1]\\n                p1 -= 1\\n            else: \\n                nums1[k] = nums2[p2]\\n                p2 -= 1\\n            k -= 1\\n            \\n        if p2 >= 0:\\n            nums1[:k + 1] = nums2[:p2 + 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267596,
                "title": "2-line-o-n-optimal-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m-1, j = n-1, k = m+n-1;\\n        while(j >= 0) nums1[k--] = (i >= 0 && nums1[i] > nums2[j]) ? nums1[i--] : nums2[j--];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m-1, j = n-1, k = m+n-1;\\n        while(j >= 0) nums1[k--] = (i >= 0 && nums1[i] > nums2[j]) ? nums1[i--] : nums2[j--];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2179969,
                "title": "c-two-pointers-sorting-brute-optimal-clean-n-easy",
                "content": "##### \\u2705 Brute force approach using sorting\\n```\\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\tint size = nums1.size();\\n\\tint cnt = 0;\\n\\t// inserting the nums2 values at the 0 values of nums1\\n\\tfor(int i = m ; i<size; i++){\\n\\t\\t  nums1[i] = nums2[cnt];\\n\\t\\t  cnt++;\\n\\t}\\n\\tsort(nums1.begin(), nums1.end());\\n}\\n```\\n TC - O(mlogm)\\n \\n------------\\n##### \\u2705 Optimal approach using Two Pointers\\n```\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=m-1, j=n-1, k = m+n-1;\\n        while(i >= 0 && j >= 0){\\n            if(nums1[i] > nums2[j]){\\n                nums1[k--] = nums1[i--];\\n            }else{\\n                nums1[k--] = nums2[j--];\\n            }\\n        }\\n        // to insert the leftover elements in the array\\n        while(i>= 0)nums1[k--] = nums1[i--];\\n        \\n        while(j >= 0)nums1[k--] = nums2[j--];\\n        // this will handle the nums1 = [0] & m = 0, nums2 = [1] & m = 1 case   \\n    }\\n```\\nTC - O(m+n)\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\tint size = nums1.size();\\n\\tint cnt = 0;\\n\\t// inserting the nums2 values at the 0 values of nums1\\n\\tfor(int i = m ; i<size; i++){\\n\\t\\t  nums1[i] = nums2[cnt];\\n\\t\\t  cnt++;\\n\\t}\\n\\tsort(nums1.begin(), nums1.end());\\n}\\n```\n```\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=m-1, j=n-1, k = m+n-1;\\n        while(i >= 0 && j >= 0){\\n            if(nums1[i] > nums2[j]){\\n                nums1[k--] = nums1[i--];\\n            }else{\\n                nums1[k--] = nums2[j--];\\n            }\\n        }\\n        // to insert the leftover elements in the array\\n        while(i>= 0)nums1[k--] = nums1[i--];\\n        \\n        while(j >= 0)nums1[k--] = nums2[j--];\\n        // this will handle the nums1 = [0] & m = 0, nums2 = [1] & m = 1 case   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2120468,
                "title": "o-n-m-time-o-1-extra-space-python",
                "content": "In classic **merge two sorted array** question,we put two pointers in the begining on both arrays,  we compare the first elements and select minimum and move that pointer ahead.\\nIn this time is **O ( M + N )** but extra space **O ( M + N )** is used.\\n\\nIn the question we are provided with **num1** with size **N + M**, so we make use of it.\\nWe put two pointers \\n* At **m-1 for nums1**\\n* At **n-1 for nums2**\\nWe compare these values and put the larger of them at the end of array **nums1**.\\nDecrement the pointer of value chosen and keep track of where next value is to be added.\\n\\n# PYTHON CODE\\n```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        k=n+m-1\\n        n-=1\\n        m-=1\\n        while (n>=0 and m>=0):\\n            if nums1[m]>nums2[n]:\\n                nums1[k]=nums1[m]\\n                m-=1\\n            else:\\n                nums1[k]=nums2[n]\\n                n-=1\\n            k-=1\\n        while n>=0:\\n            nums1[k]=nums2[n]\\n            n-=1\\n            k-=1\\n```\\n![image](https://assets.leetcode.com/users/images/0ee6ee55-3dfe-4ef6-b430-465648aedb41_1654571340.430216.jpeg)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        k=n+m-1\\n        n-=1\\n        m-=1\\n        while (n>=0 and m>=0):\\n            if nums1[m]>nums2[n]:\\n                nums1[k]=nums1[m]\\n                m-=1\\n            else:\\n                nums1[k]=nums2[n]\\n                n-=1\\n            k-=1\\n        while n>=0:\\n            nums1[k]=nums2[n]\\n            n-=1\\n            k-=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2080452,
                "title": "merge-sorted-array-o-m-n",
                "content": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int i=m-1,j=n-1,k=m+n-1;\\n        \\n        \\n        while(j>=0) // Don\\'t need to worry about i\\n        {\\n            if(i<0) // if nums1 is traversed\\n            {\\n                nums1[k]=nums2[j];\\n                k--;\\n                j--;\\n            }\\n            else if(nums1[i]>=nums2[j])\\n            {\\n                nums1[k]=nums1[i];\\n                i--;\\n                k--;\\n            }\\n            else\\n            {\\n                nums1[k]=nums2[j];\\n                j--;\\n                k--; \\n            }\\n            \\n        }\\n        \\n        return;\\n        \\n    }\\n};\\n```\\n\\nPlease do upvote if you like it !!!!!!!!!!!!!!\\nand Subscribe for more sol.\\n\\nUpvote button is in top-left corner.\\nPlease do Upvote !!!!!!!!!!!!!!!!!!!!.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int i=m-1,j=n-1,k=m+n-1;\\n        \\n        \\n        while(j>=0) // Don\\'t need to worry about i\\n        {\\n            if(i<0) // if nums1 is traversed\\n            {\\n                nums1[k]=nums2[j];\\n                k--;\\n                j--;\\n            }\\n            else if(nums1[i]>=nums2[j])\\n            {\\n                nums1[k]=nums1[i];\\n                i--;\\n                k--;\\n            }\\n            else\\n            {\\n                nums1[k]=nums2[j];\\n                j--;\\n                k--; \\n            }\\n            \\n        }\\n        \\n        return;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899791,
                "title": "c-4-lines-code-neat-and-clean",
                "content": "if you find helpful please ipvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n             int p1=m-1;\\n             int p2=n-1;\\n             int i=(m+n)-1;\\n        while(p2>=0){\\n            if(p1>=0 && nums1[p1]>nums2[p2]){\\n                nums1[i--]=nums1[p1--];\\n               \\n            }else{\\n                nums1[i--]=nums2[p2--];\\n            \\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n             int p1=m-1;\\n             int p2=n-1;\\n             int i=(m+n)-1;\\n        while(p2>=0){\\n            if(p1>=0 && nums1[p1]>nums2[p2]){\\n                nums1[i--]=nums1[p1--];\\n               \\n            }else{\\n                nums1[i--]=nums2[p2--];\\n            \\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548142,
                "title": "two-pointer-approach-without-auxiliary-array",
                "content": "Without using Auxillary Array, use the already available space\\n```\\n       int i = m-1;\\n        int j = n-1;\\n        int k = m + n - 1;\\n        \\n        while(i > -1 && j > -1){\\n            \\n            if(nums1[i] > nums2[j]){\\n                nums1[k] = nums1[i];\\n                i--;\\n            }else{\\n                nums1[k] = nums2[j];\\n                j--;\\n            }\\n            \\n            k--;\\n        } \\n        \\n        while(i > -1){\\n            nums1[k] = nums1[i];\\n            i--;\\n            k--;\\n        }\\n        \\n        while(j > -1){\\n            nums1[k] = nums2[j];\\n            j--;\\n            k--;\\n        }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n       int i = m-1;\\n        int j = n-1;\\n        int k = m + n - 1;\\n        \\n        while(i > -1 && j > -1){\\n            \\n            if(nums1[i] > nums2[j]){\\n                nums1[k] = nums1[i];\\n                i--;\\n            }else{\\n                nums1[k] = nums2[j];\\n                j--;\\n            }\\n            \\n            k--;\\n        } \\n        \\n        while(i > -1){\\n            nums1[k] = nums1[i];\\n            i--;\\n            k--;\\n        }\\n        \\n        while(j > -1){\\n            nums1[k] = nums2[j];\\n            j--;\\n            k--;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1398945,
                "title": "c-two-pointer-approch-tc-o-n-sc-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n      //two pointer approch\\n        int p1=m-1,p2=n-1,i=m+n-1;\\n        while(p2>=0)\\n        {\\n            if(p1>=0 && nums1[p1]>nums2[p2])\\n            {\\n                nums1[i--]=nums1[p1--]; //if nums1 >nums2 then at i position nums1 will come\\n             }\\n            else\\n            {\\n                nums1[i--]=nums2[p2--]; //else nums2 will come at i position then pointer decreases\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n      //two pointer approch\\n        int p1=m-1,p2=n-1,i=m+n-1;\\n        while(p2>=0)\\n        {\\n            if(p1>=0 && nums1[p1]>nums2[p2])\\n            {\\n                nums1[i--]=nums1[p1--]; //if nums1 >nums2 then at i position nums1 will come\\n             }\\n            else\\n            {\\n                nums1[i--]=nums2[p2--]; //else nums2 will come at i position then pointer decreases\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011664,
                "title": "o-n-0ms-time-complexity-c",
                "content": "If We Focus In Ascending Sorted Order Arry then We Have To Use 1 Extra Arry but Alrady In First Arry We Have Space So Now We Use That Space And Easly get solution In Linear Time Complexity And Constant Space O(1).\\nHere Is My Solution\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int p1=m-1,p2=n-1,p=nums1.size()-1;\\n        while(p>=0)\\n        {\\n            if(p1>=0 && p2>=0)\\n            {\\n                if(nums1[p1]>nums2[p2])\\n                {\\n                    nums1[p--]=nums1[p1--];\\n                }\\n                else\\n                {\\n                    nums1[p--]=nums2[p2--];\\n                }\\n            }\\n            else if(p1>=0)\\n            {\\n                nums1[p--]=nums1[p1--];\\n            }\\n            else\\n            {\\n                nums1[p--]=nums2[p2--];\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int p1=m-1,p2=n-1,p=nums1.size()-1;\\n        while(p>=0)\\n        {\\n            if(p1>=0 && p2>=0)\\n            {\\n                if(nums1[p1]>nums2[p2])\\n                {\\n                    nums1[p--]=nums1[p1--];\\n                }\\n                else\\n                {\\n                    nums1[p--]=nums2[p2--];\\n                }\\n            }\\n            else if(p1>=0)\\n            {\\n                nums1[p--]=nums1[p1--];\\n            }\\n            else\\n            {\\n                nums1[p--]=nums2[p2--];\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 974336,
                "title": "beats-90-55-python-without-using-sort-easy-in-python-explained",
                "content": "Take max number from nums1 and compare with nums2 item. If nums2 item is greater than max of nums1 then simply add from last index of nums1 and keep continue until you iterate whole nums2.\\n```\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        m -=1\\n        n -=1\\n        index = len(nums1) -1\\n        while n >= 0:\\n            if m >=0 and nums1[m] > nums2[n]:\\n                nums1[index] = nums1[m]\\n                m-=1\\n            else:\\n                nums1[index] = nums2[n]\\n                n-=1\\n            index-=1\\n                \\n\\t```\\n\\tUpvote once you get it.",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        m -=1\\n        n -=1\\n        index = len(nums1) -1\\n        while n >= 0:\\n            if m >=0 and nums1[m] > nums2[n]:\\n                nums1[index] = nums1[m]\\n                m-=1\\n            else:\\n                nums1[index] = nums2[n]\\n                n-=1\\n            index-=1\\n                \\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 29508,
                "title": "3ms-c-solution",
                "content": "```\\nvoid merge(vector<int> &nums1, int m, vector<int> &nums2, int n)\\n{\\n    int i = n + m - 1, j = m - 1, k = n - 1;\\n    while(j >= 0 || k >= 0) {\\n        if(j >= 0 && (k < 0 || nums1[j] >= nums2[k])) nums1[i--] = nums1[j--];\\n        if(k >= 0 && (j < 0 || nums1[j] < nums2[k])) nums1[i--] = nums2[k--];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid merge(vector<int> &nums1, int m, vector<int> &nums2, int n)\\n{\\n    int i = n + m - 1, j = m - 1, k = n - 1;\\n    while(j >= 0 || k >= 0) {\\n        if(j >= 0 && (k < 0 || nums1[j] >= nums2[k])) nums1[i--] = nums1[j--];\\n        if(k >= 0 && (j < 0 || nums1[j] < nums2[k])) nums1[i--] = nums2[k--];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29646,
                "title": "accepted-ruby-solution",
                "content": "```\\ndef merge(nums1, m, nums2, n)\\n    while m > 0 and n > 0\\n        if nums1[m-1] >= nums2[n-1]\\n            nums1[m+n-1] = nums1[m-1]\\n            m -= 1\\n        else\\n            nums1[m+n-1] = nums2[n-1]\\n            n -= 1\\n        end\\n    end\\n    if n > 0\\n        nums1[0...n] = nums2[0...n]\\n    end\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef merge(nums1, m, nums2, n)\\n    while m > 0 and n > 0\\n        if nums1[m-1] >= nums2[n-1]\\n            nums1[m+n-1] = nums1[m-1]\\n            m -= 1\\n        else\\n            nums1[m+n-1] = nums2[n-1]\\n            n -= 1\\n        end\\n    end\\n    if n > 0\\n        nums1[0...n] = nums2[0...n]\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 29745,
                "title": "cpp-solution-insert-from-the-end-looks-fine-4ms",
                "content": "   \\n    class Solution {\\n    public:\\n        void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n            \\n            int end = m + n - 1;\\n            m = m - 1;\\n            n = n - 1;\\n            \\n            while(n >=0)\\n            {\\n                if (m < 0 || nums2.at(n) > nums1.at(m))\\n                    nums1.at(end--) = nums2.at(n--);\\n                else\\n                    nums1.at(end--) = nums1.at(m--);\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n            \\n            int end = m + n - 1;\\n            m = m - 1;\\n            n = n - 1;\\n            \\n            while(n >=0)\\n            {\\n                if (m < 0 || nums2.at(n) > nums1.at(m))\\n                    nums1.at(end--) = nums2.at(n--);\\n                else\\n                    nums1.at(end--) = nums1.at(m--);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 29783,
                "title": "my-5-lines-ac-solution-9ms",
                "content": "    class Solution {\\n         public:\\n              void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n                  int index = m + n - 1, i = m - 1, j = n - 1;\\n                  while(j >=0)\\n                      if(i < 0 || nums1[i] < nums2[j])\\n                          nums1[index--] = nums2[j--];\\n                      else nums1[index--] = nums1[i--];\\n               }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n         public:\\n              void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n                  int index = m + n - 1, i = m - 1, j = n - 1;\\n                  while(j >=0)\\n                      if(i < 0 || nums1[i] < nums2[j])\\n                          nums1[index--] = nums2[j--];\\n                      else nums1[index--] = nums1[i--];\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 3646745,
                "title": "go-o-m-n-o-1",
                "content": "```\\nfunc merge(nums1 []int, m int, nums2 []int, n int)  {\\n    for n != 0 {\\n        if m != 0 && nums1[m-1] > nums2[n-1] {\\n            nums1[m+n-1] = nums1[m-1]\\n            m--\\n        } else {\\n            nums1[m+n-1] = nums2[n-1]\\n            n--\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc merge(nums1 []int, m int, nums2 []int, n int)  {\\n    for n != 0 {\\n        if m != 0 && nums1[m-1] > nums2[n-1] {\\n            nums1[m+n-1] = nums1[m-1]\\n            m--\\n        } else {\\n            nums1[m+n-1] = nums2[n-1]\\n            n--\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3445073,
                "title": "best-solution-in-java-runtime-1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) \\n    {\\n    \\n       for (int i = m ; i <  m+ n  ; i++)\\n        {\\n                nums1[i] = nums2[i-m];\\n        }\\n\\n        Arrays.sort(nums1);\\n       // System.out.println(Arrays.toString(nums1));    \\n    }\\n}\\n```\\n\\n![b0e5afaa-48ec-4dcc-bd96-e39aa7a524f8_1681948924.2890832.png](https://assets.leetcode.com/users/images/651b1167-f9d8-4033-940d-2968c026be6c_1682192142.3201554.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) \\n    {\\n    \\n       for (int i = m ; i <  m+ n  ; i++)\\n        {\\n                nums1[i] = nums2[i-m];\\n        }\\n\\n        Arrays.sort(nums1);\\n       // System.out.println(Arrays.toString(nums1));    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3403049,
                "title": "best-typescript-solution",
                "content": "# Code\\n```\\n/**\\n Do not return anything, modify nums1 in-place instead.\\n */\\nfunction merge(nums1: number[], m: number, nums2: number[], n: number): void {\\n\\n    let p1: number = m - 1\\n    let p2: number = n - 1\\n    let k: number = nums1.length - 1\\n\\n    while(p2 >= 0){\\n        if(nums1[p1] > nums2[p2]){\\n            nums1[k] = nums1[p1]\\n            p1--\\n        } else {\\n            nums1[k] = nums2[p2]\\n            p2--\\n        }\\n      k--\\n    }\\n};\\n```\\nPlease upvote if the solution is useful for you!",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n/**\\n Do not return anything, modify nums1 in-place instead.\\n */\\nfunction merge(nums1: number[], m: number, nums2: number[], n: number): void {\\n\\n    let p1: number = m - 1\\n    let p2: number = n - 1\\n    let k: number = nums1.length - 1\\n\\n    while(p2 >= 0){\\n        if(nums1[p1] > nums2[p2]){\\n            nums1[k] = nums1[p1]\\n            p1--\\n        } else {\\n            nums1[k] = nums2[p2]\\n            p2--\\n        }\\n      k--\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3313032,
                "title": "easy-c-implementation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n         vector<int> v;\\n        int i=0;\\n        int j=0;\\n        while(i<m&&j<n){\\n            if(nums1[i]<nums2[j]){\\n                v.push_back(nums1[i]);\\n                i++;\\n                \\n            }\\n                else{\\n                    v.push_back(nums2[j]);\\n                    j++;   \\n            }\\n        }\\n        while(i<m){\\n            v.push_back(nums1[i]);\\n            i++;\\n        }\\n        \\n        while(j<n){\\n           v.push_back(nums2[j]);\\n            j++;\\n        }\\n        nums1=v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n         vector<int> v;\\n        int i=0;\\n        int j=0;\\n        while(i<m&&j<n){\\n            if(nums1[i]<nums2[j]){\\n                v.push_back(nums1[i]);\\n                i++;\\n                \\n            }\\n                else{\\n                    v.push_back(nums2[j]);\\n                    j++;   \\n            }\\n        }\\n        while(i<m){\\n            v.push_back(nums1[i]);\\n            i++;\\n        }\\n        \\n        while(j<n){\\n           v.push_back(nums2[j]);\\n            j++;\\n        }\\n        nums1=v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188723,
                "title": "best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number} m\\n * @param {number[]} nums2\\n * @param {number} n\\n * @return {void} Do not return anything, modify nums1 in-place instead.\\n */\\nvar merge = function(nums1, m, nums2, n) {\\n    let i=m-1;\\n    let j=n-1;\\n    let temp=nums1.length-1; \\n     while(j>=0){\\n        if(i>=0 && nums1[i]>nums2[j]){\\n            nums1[temp]=nums1[i];\\n            temp--; \\n            i--;\\n         }else{\\n            nums1[temp] = nums2[j];\\n            temp--; \\n            j--; \\n        }     \\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number} m\\n * @param {number[]} nums2\\n * @param {number} n\\n * @return {void} Do not return anything, modify nums1 in-place instead.\\n */\\nvar merge = function(nums1, m, nums2, n) {\\n    let i=m-1;\\n    let j=n-1;\\n    let temp=nums1.length-1; \\n     while(j>=0){\\n        if(i>=0 && nums1[i]>nums2[j]){\\n            nums1[temp]=nums1[i];\\n            temp--; \\n            i--;\\n         }else{\\n            nums1[temp] = nums2[j];\\n            temp--; \\n            j--; \\n        }     \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2743674,
                "title": "easy-c-solution",
                "content": "``` C++ []\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        for (int i=m; i<m+n; i++) {\\n            nums1[i]=nums2[i-m];\\n        }\\n        sort(nums1.begin(), nums1.end());\\n    }\\n};\\n```\\n\\n*If this solution helps, please upvote it*\\n\\n## My GitHub: https://github.com/crimsonKn1ght",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        for (int i=m; i<m+n; i++) {\\n            nums1[i]=nums2[i-m];\\n        }\\n        sort(nums1.begin(), nums1.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1572679,
                "content": [
                    {
                        "username": "BigMangos",
                        "content": "> https://leetcode.com/problems/merge-sorted-array/discuss/29503/Beautiful-Python-Solution\\n> \\n\\nI make a flash to understand better.\\n![88.gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n[gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n"
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "i think there is a bug in this . it is taking nums1 as Output not the Stdout. [@LeetCode](/LeetCode)  please fix this issue."
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "I am running this code in my IntelliJ IDE and its giving the expected result but in this leetcode compiler its failing my case. is there any issue"
                    },
                    {
                        "username": "Nitya100",
                        "content": "How you did this kind of gif?"
                    },
                    {
                        "username": "suman_saini",
                        "content": "thanks"
                    },
                    {
                        "username": "Alterra",
                        "content": "I wouldn\\'t work for number smaller than 0\\n"
                    },
                    {
                        "username": "ajitt7381",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "aman1908",
                        "content": "It\\'s working in local system same test cases. so why it\\'s showing error in complier."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@AlteriusOmega](/AlteriusOmega) so how we can solve it then ?"
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "[@blandprix](/blandprix) Bro.. There is even problem with compiling when i try to do this simple case:\\nif(nums1[0]>nums2[nums2Size-1])"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "Make sure you are not using the assignment operator like \"nums1 = ...\" or anything like that because in most programming languages that will just create a new local variable that happens to have the same name, but will not be a reference to the same nums1 input. From then on in your function any time you modify nums1, it will be your local nums1, and so the real nums1 will be unaffected. Can\\'t use the global keyword in Python either since its an argument, not an actual global variable, though it does reference a global variable."
                    },
                    {
                        "username": "Susmita_Patra",
                        "content": "[@blandprix](/blandprix) Same problem"
                    },
                    {
                        "username": "blandprix",
                        "content": "Old question, but for others with the same issue: something like `nums1 = sortedArray` will not work because the variable in the calling scope will still reference the original array. You\\'ll have to mutate the existing array instead of trying to change the reference.\\nSome more detail [here](https://leetcode.com/problems/merge-sorted-array/description/comments/1968717)."
                    },
                    {
                        "username": "dev_kbujak",
                        "content": "Same here, it\\'s annoying!"
                    },
                    {
                        "username": "MoonHalo8088",
                        "content": "Same problem with you(\\u2565\\uFE4F\\u2565)"
                    },
                    {
                        "username": "osmanbaskok",
                        "content": "Yes, the same. It\\'s annoying!"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "yes brother same problem here"
                    },
                    {
                        "username": "mlafortune1223",
                        "content": "When I run console.log(nums1.filter(num => num !== 0).concat(nums2).sort((a,b) => a - b)) it shows [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut then when I remove the console log and just run the functions on num1, it says I\\'m outputting[1,2,3,0,0,0]\\n\\nWhat?"
                    },
                    {
                        "username": "vinjenks",
                        "content": "You can\\'t reassign a param as a whole, but you can reassign the individual array values. Maybe that\\'s an easier way of understanding it."
                    },
                    {
                        "username": "ballanibalaji",
                        "content": "[@TheHood02](/TheHood02)  when you assign a new value to a parameter within a function, it doesn\\'t affect the original variable outside the function. that is the problem\\nIn that case update is recommended instead of reassignment\\n"
                    },
                    {
                        "username": "TheHood02",
                        "content": "When you do a filter, the function returns a new array. It does not mutate the array you applied the filter function on."
                    },
                    {
                        "username": "zuborev_michael",
                        "content": "You don\\'t have to store your values in any buffer if you go backwards"
                    },
                    {
                        "username": "Harshal0409",
                        "content": "This hint is the only one required!"
                    },
                    {
                        "username": "firuz97",
                        "content": "your comment gave me a good hint after that i solved the task in O(n) time"
                    },
                    {
                        "username": "superplane",
                        "content": "I found that for corner case\\nnums1 = [1], m = 1;\\nnums2 = [0], n = 1.\\nThe result should be [0,1], but Leetcode gives [1].\\nDoes Leetcode go wrong here?"
                    },
                    {
                        "username": "agatekartik",
                        "content": "you\\'ll need nums1 to be of size 2 i.e. nums1 = [1,0] initially to satisfy all constraints"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "According to the ques, nums1 is of length (m+n) where m is no of elements to be inserted from nums1 and rest n elements \\'0\\' s  which are to be replaced by nums2 elements. So if m=1, nums1 should be [1,0] in which last \\'0\\' is replaced by nums2 element "
                    },
                    {
                        "username": "prathore28647",
                        "content": "In the given corner case, nums1 contains a single element of value 1, and nums2 contains a single element of value 0. According to the problem statement, the arrays are expected to be merged in non-decreasing order, which means the resulting array should be [0,1], with 0 preceding 1.\\n\\nIf LeetCode is returning [1] instead of [0,1], this would suggest that the solution is not correctly handling the given input, or that there is a mistake in the test cases.\\n\\nIt may be worth checking the solution code for any edge cases or boundary conditions that may not have been handled correctly. Additionally, you may want to try submitting a bug report to LeetCode to bring the issue to their attention."
                    },
                    {
                        "username": "LeetCode_AbdulRehman",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) for that case according to the problem, nums1 should be nums1 = [1, 0], m=1;\\nin order to accommodate the n=1 element of nums2,\\nseems leetcode was right we were not ..."
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\n\nnums1 = [0], m = 0,\n nums2 = [1], n = 1"
                    },
                    {
                        "username": "sl8517",
                        "content": "Apperently nums1 should be [1,0] instead of [1]."
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Please read the question carefully, it is clearly written that \"To accommodate this, nums1 has a length of m + n\". So therefore if nums2 have 1 element in it then nums1 should have minimum 1 element in it.\n"
                    },
                    {
                        "username": "muralivicky",
                        "content": "its not wanting 0\\'s in its nums1. That is also a condition given by leetcode to be considered by the solvers buddy."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well size of nums 1 is always m+n so according to your case if nums1.size is 1 --> m+n = 1 --> n=0 , and in that case ans would be 1 only."
                    },
                    {
                        "username": "gokutruns8",
                        "content": "i think 0 represents null value"
                    },
                    {
                        "username": "t_guzma",
                        "content": "\"non-decreasing order\", so increasing order? :D"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "[@gurlakshpreetKaur](/gurlakshpreetKaur) It\\'s kind of a pedantic term. Almost anyone when you ask them if sorting an Amazon search by increasing price might also include two items with the same price next to each-other, they would say yes. Increasing order includes numbers that are the same. It\\'s just needlessly obtuse wording"
                    },
                    {
                        "username": "akanksha1996",
                        "content": "Non decreasing order is when the numbers may or may not increase but they never deccrease for eg 1 2 2 3 3 4 5 6 6."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Not necessarily. If it is 9,9,10,11 then the 9s are equal, therefore no increase was made, hence the non-decreasing."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Merge and sort\n\n  \n**Approach 2:** Three Pointers (Start From the Beginning)\n\n  \n**Approach 3:** Three Pointers (Start From the End)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/3re-K02xQ_g?t=59"
                    },
                    {
                        "username": "alik",
                        "content": "Can it be done without creating a new merged array, meaning sorting using only B and A?"
                    },
                    {
                        "username": "azuregcp",
                        "content": "10 year old comment. Funny.\\nPeople replying with solutions. Hilarious."
                    },
                    {
                        "username": "janis__",
                        "content": "Yes it is possible."
                    },
                    {
                        "username": "dip_018",
                        "content": "[@stanislav888](/stanislav888) try by using logic of insertion sort"
                    },
                    {
                        "username": "stanislav888",
                        "content": "Sure, dude! Just merge vectors from highest values to lowest into the tail of  nums1. I.e. replacing tail nulls with merged(high) values."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 and JavaScript solution\\nThe easiest way is iterate n times then use function to sort?\\nCan we find out a faster solution? Sure !\\n\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/)\\u2B50**\\n\\n**All solution was written by myself, so all have been tested.**\\n![image](https://assets.leetcode.com/users/images/1b85cd5f-8f55-4cce-8aab-bc51e740c66b_1654587254.4308908.jpeg)\\n\\nFor example, here is the Java submission detail.\\n\\n\\n**See more problems solutions : [Zyrastory - More LeetCode Solutions with Explanation](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.\\n\\n**Thanks**\\uD83E\\uDDE1"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "Did you buy the domain name, How did you blog here, I am intrigued, :)"
                    },
                    {
                        "username": "TheKarateKid",
                        "content": "I have tried copying the contents of my sorted array to nums1 using both `nums1 = sortedArray.clone()` and even `nums1 = sortedArray;`\\n\\nThe debugger shows that nums1 has the correct sorted values at the end of the function, but LeetCode\\'s case tester is still giving a \"Wrong Answer\" and showing the original value of nums1 before the copy.\\n\\nAnyone have any advice? Is this an issue with the LeetCode tester?\\n\\n**Update:** Using `System.arraycopy()` fixed the issue, but I think the other ways of copying should still be correct."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "Isn\\'t it because the question says in-place?"
                    }
                ]
            },
            {
                "id": 1778733,
                "content": [
                    {
                        "username": "BigMangos",
                        "content": "> https://leetcode.com/problems/merge-sorted-array/discuss/29503/Beautiful-Python-Solution\\n> \\n\\nI make a flash to understand better.\\n![88.gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n[gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n"
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "i think there is a bug in this . it is taking nums1 as Output not the Stdout. [@LeetCode](/LeetCode)  please fix this issue."
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "I am running this code in my IntelliJ IDE and its giving the expected result but in this leetcode compiler its failing my case. is there any issue"
                    },
                    {
                        "username": "Nitya100",
                        "content": "How you did this kind of gif?"
                    },
                    {
                        "username": "suman_saini",
                        "content": "thanks"
                    },
                    {
                        "username": "Alterra",
                        "content": "I wouldn\\'t work for number smaller than 0\\n"
                    },
                    {
                        "username": "ajitt7381",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "aman1908",
                        "content": "It\\'s working in local system same test cases. so why it\\'s showing error in complier."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@AlteriusOmega](/AlteriusOmega) so how we can solve it then ?"
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "[@blandprix](/blandprix) Bro.. There is even problem with compiling when i try to do this simple case:\\nif(nums1[0]>nums2[nums2Size-1])"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "Make sure you are not using the assignment operator like \"nums1 = ...\" or anything like that because in most programming languages that will just create a new local variable that happens to have the same name, but will not be a reference to the same nums1 input. From then on in your function any time you modify nums1, it will be your local nums1, and so the real nums1 will be unaffected. Can\\'t use the global keyword in Python either since its an argument, not an actual global variable, though it does reference a global variable."
                    },
                    {
                        "username": "Susmita_Patra",
                        "content": "[@blandprix](/blandprix) Same problem"
                    },
                    {
                        "username": "blandprix",
                        "content": "Old question, but for others with the same issue: something like `nums1 = sortedArray` will not work because the variable in the calling scope will still reference the original array. You\\'ll have to mutate the existing array instead of trying to change the reference.\\nSome more detail [here](https://leetcode.com/problems/merge-sorted-array/description/comments/1968717)."
                    },
                    {
                        "username": "dev_kbujak",
                        "content": "Same here, it\\'s annoying!"
                    },
                    {
                        "username": "MoonHalo8088",
                        "content": "Same problem with you(\\u2565\\uFE4F\\u2565)"
                    },
                    {
                        "username": "osmanbaskok",
                        "content": "Yes, the same. It\\'s annoying!"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "yes brother same problem here"
                    },
                    {
                        "username": "mlafortune1223",
                        "content": "When I run console.log(nums1.filter(num => num !== 0).concat(nums2).sort((a,b) => a - b)) it shows [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut then when I remove the console log and just run the functions on num1, it says I\\'m outputting[1,2,3,0,0,0]\\n\\nWhat?"
                    },
                    {
                        "username": "vinjenks",
                        "content": "You can\\'t reassign a param as a whole, but you can reassign the individual array values. Maybe that\\'s an easier way of understanding it."
                    },
                    {
                        "username": "ballanibalaji",
                        "content": "[@TheHood02](/TheHood02)  when you assign a new value to a parameter within a function, it doesn\\'t affect the original variable outside the function. that is the problem\\nIn that case update is recommended instead of reassignment\\n"
                    },
                    {
                        "username": "TheHood02",
                        "content": "When you do a filter, the function returns a new array. It does not mutate the array you applied the filter function on."
                    },
                    {
                        "username": "zuborev_michael",
                        "content": "You don\\'t have to store your values in any buffer if you go backwards"
                    },
                    {
                        "username": "Harshal0409",
                        "content": "This hint is the only one required!"
                    },
                    {
                        "username": "firuz97",
                        "content": "your comment gave me a good hint after that i solved the task in O(n) time"
                    },
                    {
                        "username": "superplane",
                        "content": "I found that for corner case\\nnums1 = [1], m = 1;\\nnums2 = [0], n = 1.\\nThe result should be [0,1], but Leetcode gives [1].\\nDoes Leetcode go wrong here?"
                    },
                    {
                        "username": "agatekartik",
                        "content": "you\\'ll need nums1 to be of size 2 i.e. nums1 = [1,0] initially to satisfy all constraints"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "According to the ques, nums1 is of length (m+n) where m is no of elements to be inserted from nums1 and rest n elements \\'0\\' s  which are to be replaced by nums2 elements. So if m=1, nums1 should be [1,0] in which last \\'0\\' is replaced by nums2 element "
                    },
                    {
                        "username": "prathore28647",
                        "content": "In the given corner case, nums1 contains a single element of value 1, and nums2 contains a single element of value 0. According to the problem statement, the arrays are expected to be merged in non-decreasing order, which means the resulting array should be [0,1], with 0 preceding 1.\\n\\nIf LeetCode is returning [1] instead of [0,1], this would suggest that the solution is not correctly handling the given input, or that there is a mistake in the test cases.\\n\\nIt may be worth checking the solution code for any edge cases or boundary conditions that may not have been handled correctly. Additionally, you may want to try submitting a bug report to LeetCode to bring the issue to their attention."
                    },
                    {
                        "username": "LeetCode_AbdulRehman",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) for that case according to the problem, nums1 should be nums1 = [1, 0], m=1;\\nin order to accommodate the n=1 element of nums2,\\nseems leetcode was right we were not ..."
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\n\nnums1 = [0], m = 0,\n nums2 = [1], n = 1"
                    },
                    {
                        "username": "sl8517",
                        "content": "Apperently nums1 should be [1,0] instead of [1]."
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Please read the question carefully, it is clearly written that \"To accommodate this, nums1 has a length of m + n\". So therefore if nums2 have 1 element in it then nums1 should have minimum 1 element in it.\n"
                    },
                    {
                        "username": "muralivicky",
                        "content": "its not wanting 0\\'s in its nums1. That is also a condition given by leetcode to be considered by the solvers buddy."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well size of nums 1 is always m+n so according to your case if nums1.size is 1 --> m+n = 1 --> n=0 , and in that case ans would be 1 only."
                    },
                    {
                        "username": "gokutruns8",
                        "content": "i think 0 represents null value"
                    },
                    {
                        "username": "t_guzma",
                        "content": "\"non-decreasing order\", so increasing order? :D"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "[@gurlakshpreetKaur](/gurlakshpreetKaur) It\\'s kind of a pedantic term. Almost anyone when you ask them if sorting an Amazon search by increasing price might also include two items with the same price next to each-other, they would say yes. Increasing order includes numbers that are the same. It\\'s just needlessly obtuse wording"
                    },
                    {
                        "username": "akanksha1996",
                        "content": "Non decreasing order is when the numbers may or may not increase but they never deccrease for eg 1 2 2 3 3 4 5 6 6."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Not necessarily. If it is 9,9,10,11 then the 9s are equal, therefore no increase was made, hence the non-decreasing."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Merge and sort\n\n  \n**Approach 2:** Three Pointers (Start From the Beginning)\n\n  \n**Approach 3:** Three Pointers (Start From the End)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/3re-K02xQ_g?t=59"
                    },
                    {
                        "username": "alik",
                        "content": "Can it be done without creating a new merged array, meaning sorting using only B and A?"
                    },
                    {
                        "username": "azuregcp",
                        "content": "10 year old comment. Funny.\\nPeople replying with solutions. Hilarious."
                    },
                    {
                        "username": "janis__",
                        "content": "Yes it is possible."
                    },
                    {
                        "username": "dip_018",
                        "content": "[@stanislav888](/stanislav888) try by using logic of insertion sort"
                    },
                    {
                        "username": "stanislav888",
                        "content": "Sure, dude! Just merge vectors from highest values to lowest into the tail of  nums1. I.e. replacing tail nulls with merged(high) values."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 and JavaScript solution\\nThe easiest way is iterate n times then use function to sort?\\nCan we find out a faster solution? Sure !\\n\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/)\\u2B50**\\n\\n**All solution was written by myself, so all have been tested.**\\n![image](https://assets.leetcode.com/users/images/1b85cd5f-8f55-4cce-8aab-bc51e740c66b_1654587254.4308908.jpeg)\\n\\nFor example, here is the Java submission detail.\\n\\n\\n**See more problems solutions : [Zyrastory - More LeetCode Solutions with Explanation](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.\\n\\n**Thanks**\\uD83E\\uDDE1"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "Did you buy the domain name, How did you blog here, I am intrigued, :)"
                    },
                    {
                        "username": "TheKarateKid",
                        "content": "I have tried copying the contents of my sorted array to nums1 using both `nums1 = sortedArray.clone()` and even `nums1 = sortedArray;`\\n\\nThe debugger shows that nums1 has the correct sorted values at the end of the function, but LeetCode\\'s case tester is still giving a \"Wrong Answer\" and showing the original value of nums1 before the copy.\\n\\nAnyone have any advice? Is this an issue with the LeetCode tester?\\n\\n**Update:** Using `System.arraycopy()` fixed the issue, but I think the other ways of copying should still be correct."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "Isn\\'t it because the question says in-place?"
                    }
                ]
            },
            {
                "id": 1768684,
                "content": [
                    {
                        "username": "BigMangos",
                        "content": "> https://leetcode.com/problems/merge-sorted-array/discuss/29503/Beautiful-Python-Solution\\n> \\n\\nI make a flash to understand better.\\n![88.gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n[gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n"
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "i think there is a bug in this . it is taking nums1 as Output not the Stdout. [@LeetCode](/LeetCode)  please fix this issue."
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "I am running this code in my IntelliJ IDE and its giving the expected result but in this leetcode compiler its failing my case. is there any issue"
                    },
                    {
                        "username": "Nitya100",
                        "content": "How you did this kind of gif?"
                    },
                    {
                        "username": "suman_saini",
                        "content": "thanks"
                    },
                    {
                        "username": "Alterra",
                        "content": "I wouldn\\'t work for number smaller than 0\\n"
                    },
                    {
                        "username": "ajitt7381",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "aman1908",
                        "content": "It\\'s working in local system same test cases. so why it\\'s showing error in complier."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@AlteriusOmega](/AlteriusOmega) so how we can solve it then ?"
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "[@blandprix](/blandprix) Bro.. There is even problem with compiling when i try to do this simple case:\\nif(nums1[0]>nums2[nums2Size-1])"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "Make sure you are not using the assignment operator like \"nums1 = ...\" or anything like that because in most programming languages that will just create a new local variable that happens to have the same name, but will not be a reference to the same nums1 input. From then on in your function any time you modify nums1, it will be your local nums1, and so the real nums1 will be unaffected. Can\\'t use the global keyword in Python either since its an argument, not an actual global variable, though it does reference a global variable."
                    },
                    {
                        "username": "Susmita_Patra",
                        "content": "[@blandprix](/blandprix) Same problem"
                    },
                    {
                        "username": "blandprix",
                        "content": "Old question, but for others with the same issue: something like `nums1 = sortedArray` will not work because the variable in the calling scope will still reference the original array. You\\'ll have to mutate the existing array instead of trying to change the reference.\\nSome more detail [here](https://leetcode.com/problems/merge-sorted-array/description/comments/1968717)."
                    },
                    {
                        "username": "dev_kbujak",
                        "content": "Same here, it\\'s annoying!"
                    },
                    {
                        "username": "MoonHalo8088",
                        "content": "Same problem with you(\\u2565\\uFE4F\\u2565)"
                    },
                    {
                        "username": "osmanbaskok",
                        "content": "Yes, the same. It\\'s annoying!"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "yes brother same problem here"
                    },
                    {
                        "username": "mlafortune1223",
                        "content": "When I run console.log(nums1.filter(num => num !== 0).concat(nums2).sort((a,b) => a - b)) it shows [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut then when I remove the console log and just run the functions on num1, it says I\\'m outputting[1,2,3,0,0,0]\\n\\nWhat?"
                    },
                    {
                        "username": "vinjenks",
                        "content": "You can\\'t reassign a param as a whole, but you can reassign the individual array values. Maybe that\\'s an easier way of understanding it."
                    },
                    {
                        "username": "ballanibalaji",
                        "content": "[@TheHood02](/TheHood02)  when you assign a new value to a parameter within a function, it doesn\\'t affect the original variable outside the function. that is the problem\\nIn that case update is recommended instead of reassignment\\n"
                    },
                    {
                        "username": "TheHood02",
                        "content": "When you do a filter, the function returns a new array. It does not mutate the array you applied the filter function on."
                    },
                    {
                        "username": "zuborev_michael",
                        "content": "You don\\'t have to store your values in any buffer if you go backwards"
                    },
                    {
                        "username": "Harshal0409",
                        "content": "This hint is the only one required!"
                    },
                    {
                        "username": "firuz97",
                        "content": "your comment gave me a good hint after that i solved the task in O(n) time"
                    },
                    {
                        "username": "superplane",
                        "content": "I found that for corner case\\nnums1 = [1], m = 1;\\nnums2 = [0], n = 1.\\nThe result should be [0,1], but Leetcode gives [1].\\nDoes Leetcode go wrong here?"
                    },
                    {
                        "username": "agatekartik",
                        "content": "you\\'ll need nums1 to be of size 2 i.e. nums1 = [1,0] initially to satisfy all constraints"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "According to the ques, nums1 is of length (m+n) where m is no of elements to be inserted from nums1 and rest n elements \\'0\\' s  which are to be replaced by nums2 elements. So if m=1, nums1 should be [1,0] in which last \\'0\\' is replaced by nums2 element "
                    },
                    {
                        "username": "prathore28647",
                        "content": "In the given corner case, nums1 contains a single element of value 1, and nums2 contains a single element of value 0. According to the problem statement, the arrays are expected to be merged in non-decreasing order, which means the resulting array should be [0,1], with 0 preceding 1.\\n\\nIf LeetCode is returning [1] instead of [0,1], this would suggest that the solution is not correctly handling the given input, or that there is a mistake in the test cases.\\n\\nIt may be worth checking the solution code for any edge cases or boundary conditions that may not have been handled correctly. Additionally, you may want to try submitting a bug report to LeetCode to bring the issue to their attention."
                    },
                    {
                        "username": "LeetCode_AbdulRehman",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) for that case according to the problem, nums1 should be nums1 = [1, 0], m=1;\\nin order to accommodate the n=1 element of nums2,\\nseems leetcode was right we were not ..."
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\n\nnums1 = [0], m = 0,\n nums2 = [1], n = 1"
                    },
                    {
                        "username": "sl8517",
                        "content": "Apperently nums1 should be [1,0] instead of [1]."
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Please read the question carefully, it is clearly written that \"To accommodate this, nums1 has a length of m + n\". So therefore if nums2 have 1 element in it then nums1 should have minimum 1 element in it.\n"
                    },
                    {
                        "username": "muralivicky",
                        "content": "its not wanting 0\\'s in its nums1. That is also a condition given by leetcode to be considered by the solvers buddy."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well size of nums 1 is always m+n so according to your case if nums1.size is 1 --> m+n = 1 --> n=0 , and in that case ans would be 1 only."
                    },
                    {
                        "username": "gokutruns8",
                        "content": "i think 0 represents null value"
                    },
                    {
                        "username": "t_guzma",
                        "content": "\"non-decreasing order\", so increasing order? :D"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "[@gurlakshpreetKaur](/gurlakshpreetKaur) It\\'s kind of a pedantic term. Almost anyone when you ask them if sorting an Amazon search by increasing price might also include two items with the same price next to each-other, they would say yes. Increasing order includes numbers that are the same. It\\'s just needlessly obtuse wording"
                    },
                    {
                        "username": "akanksha1996",
                        "content": "Non decreasing order is when the numbers may or may not increase but they never deccrease for eg 1 2 2 3 3 4 5 6 6."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Not necessarily. If it is 9,9,10,11 then the 9s are equal, therefore no increase was made, hence the non-decreasing."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Merge and sort\n\n  \n**Approach 2:** Three Pointers (Start From the Beginning)\n\n  \n**Approach 3:** Three Pointers (Start From the End)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/3re-K02xQ_g?t=59"
                    },
                    {
                        "username": "alik",
                        "content": "Can it be done without creating a new merged array, meaning sorting using only B and A?"
                    },
                    {
                        "username": "azuregcp",
                        "content": "10 year old comment. Funny.\\nPeople replying with solutions. Hilarious."
                    },
                    {
                        "username": "janis__",
                        "content": "Yes it is possible."
                    },
                    {
                        "username": "dip_018",
                        "content": "[@stanislav888](/stanislav888) try by using logic of insertion sort"
                    },
                    {
                        "username": "stanislav888",
                        "content": "Sure, dude! Just merge vectors from highest values to lowest into the tail of  nums1. I.e. replacing tail nulls with merged(high) values."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 and JavaScript solution\\nThe easiest way is iterate n times then use function to sort?\\nCan we find out a faster solution? Sure !\\n\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/)\\u2B50**\\n\\n**All solution was written by myself, so all have been tested.**\\n![image](https://assets.leetcode.com/users/images/1b85cd5f-8f55-4cce-8aab-bc51e740c66b_1654587254.4308908.jpeg)\\n\\nFor example, here is the Java submission detail.\\n\\n\\n**See more problems solutions : [Zyrastory - More LeetCode Solutions with Explanation](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.\\n\\n**Thanks**\\uD83E\\uDDE1"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "Did you buy the domain name, How did you blog here, I am intrigued, :)"
                    },
                    {
                        "username": "TheKarateKid",
                        "content": "I have tried copying the contents of my sorted array to nums1 using both `nums1 = sortedArray.clone()` and even `nums1 = sortedArray;`\\n\\nThe debugger shows that nums1 has the correct sorted values at the end of the function, but LeetCode\\'s case tester is still giving a \"Wrong Answer\" and showing the original value of nums1 before the copy.\\n\\nAnyone have any advice? Is this an issue with the LeetCode tester?\\n\\n**Update:** Using `System.arraycopy()` fixed the issue, but I think the other ways of copying should still be correct."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "Isn\\'t it because the question says in-place?"
                    }
                ]
            },
            {
                "id": 1573374,
                "content": [
                    {
                        "username": "BigMangos",
                        "content": "> https://leetcode.com/problems/merge-sorted-array/discuss/29503/Beautiful-Python-Solution\\n> \\n\\nI make a flash to understand better.\\n![88.gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n[gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n"
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "i think there is a bug in this . it is taking nums1 as Output not the Stdout. [@LeetCode](/LeetCode)  please fix this issue."
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "I am running this code in my IntelliJ IDE and its giving the expected result but in this leetcode compiler its failing my case. is there any issue"
                    },
                    {
                        "username": "Nitya100",
                        "content": "How you did this kind of gif?"
                    },
                    {
                        "username": "suman_saini",
                        "content": "thanks"
                    },
                    {
                        "username": "Alterra",
                        "content": "I wouldn\\'t work for number smaller than 0\\n"
                    },
                    {
                        "username": "ajitt7381",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "aman1908",
                        "content": "It\\'s working in local system same test cases. so why it\\'s showing error in complier."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@AlteriusOmega](/AlteriusOmega) so how we can solve it then ?"
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "[@blandprix](/blandprix) Bro.. There is even problem with compiling when i try to do this simple case:\\nif(nums1[0]>nums2[nums2Size-1])"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "Make sure you are not using the assignment operator like \"nums1 = ...\" or anything like that because in most programming languages that will just create a new local variable that happens to have the same name, but will not be a reference to the same nums1 input. From then on in your function any time you modify nums1, it will be your local nums1, and so the real nums1 will be unaffected. Can\\'t use the global keyword in Python either since its an argument, not an actual global variable, though it does reference a global variable."
                    },
                    {
                        "username": "Susmita_Patra",
                        "content": "[@blandprix](/blandprix) Same problem"
                    },
                    {
                        "username": "blandprix",
                        "content": "Old question, but for others with the same issue: something like `nums1 = sortedArray` will not work because the variable in the calling scope will still reference the original array. You\\'ll have to mutate the existing array instead of trying to change the reference.\\nSome more detail [here](https://leetcode.com/problems/merge-sorted-array/description/comments/1968717)."
                    },
                    {
                        "username": "dev_kbujak",
                        "content": "Same here, it\\'s annoying!"
                    },
                    {
                        "username": "MoonHalo8088",
                        "content": "Same problem with you(\\u2565\\uFE4F\\u2565)"
                    },
                    {
                        "username": "osmanbaskok",
                        "content": "Yes, the same. It\\'s annoying!"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "yes brother same problem here"
                    },
                    {
                        "username": "mlafortune1223",
                        "content": "When I run console.log(nums1.filter(num => num !== 0).concat(nums2).sort((a,b) => a - b)) it shows [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut then when I remove the console log and just run the functions on num1, it says I\\'m outputting[1,2,3,0,0,0]\\n\\nWhat?"
                    },
                    {
                        "username": "vinjenks",
                        "content": "You can\\'t reassign a param as a whole, but you can reassign the individual array values. Maybe that\\'s an easier way of understanding it."
                    },
                    {
                        "username": "ballanibalaji",
                        "content": "[@TheHood02](/TheHood02)  when you assign a new value to a parameter within a function, it doesn\\'t affect the original variable outside the function. that is the problem\\nIn that case update is recommended instead of reassignment\\n"
                    },
                    {
                        "username": "TheHood02",
                        "content": "When you do a filter, the function returns a new array. It does not mutate the array you applied the filter function on."
                    },
                    {
                        "username": "zuborev_michael",
                        "content": "You don\\'t have to store your values in any buffer if you go backwards"
                    },
                    {
                        "username": "Harshal0409",
                        "content": "This hint is the only one required!"
                    },
                    {
                        "username": "firuz97",
                        "content": "your comment gave me a good hint after that i solved the task in O(n) time"
                    },
                    {
                        "username": "superplane",
                        "content": "I found that for corner case\\nnums1 = [1], m = 1;\\nnums2 = [0], n = 1.\\nThe result should be [0,1], but Leetcode gives [1].\\nDoes Leetcode go wrong here?"
                    },
                    {
                        "username": "agatekartik",
                        "content": "you\\'ll need nums1 to be of size 2 i.e. nums1 = [1,0] initially to satisfy all constraints"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "According to the ques, nums1 is of length (m+n) where m is no of elements to be inserted from nums1 and rest n elements \\'0\\' s  which are to be replaced by nums2 elements. So if m=1, nums1 should be [1,0] in which last \\'0\\' is replaced by nums2 element "
                    },
                    {
                        "username": "prathore28647",
                        "content": "In the given corner case, nums1 contains a single element of value 1, and nums2 contains a single element of value 0. According to the problem statement, the arrays are expected to be merged in non-decreasing order, which means the resulting array should be [0,1], with 0 preceding 1.\\n\\nIf LeetCode is returning [1] instead of [0,1], this would suggest that the solution is not correctly handling the given input, or that there is a mistake in the test cases.\\n\\nIt may be worth checking the solution code for any edge cases or boundary conditions that may not have been handled correctly. Additionally, you may want to try submitting a bug report to LeetCode to bring the issue to their attention."
                    },
                    {
                        "username": "LeetCode_AbdulRehman",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) for that case according to the problem, nums1 should be nums1 = [1, 0], m=1;\\nin order to accommodate the n=1 element of nums2,\\nseems leetcode was right we were not ..."
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\n\nnums1 = [0], m = 0,\n nums2 = [1], n = 1"
                    },
                    {
                        "username": "sl8517",
                        "content": "Apperently nums1 should be [1,0] instead of [1]."
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Please read the question carefully, it is clearly written that \"To accommodate this, nums1 has a length of m + n\". So therefore if nums2 have 1 element in it then nums1 should have minimum 1 element in it.\n"
                    },
                    {
                        "username": "muralivicky",
                        "content": "its not wanting 0\\'s in its nums1. That is also a condition given by leetcode to be considered by the solvers buddy."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well size of nums 1 is always m+n so according to your case if nums1.size is 1 --> m+n = 1 --> n=0 , and in that case ans would be 1 only."
                    },
                    {
                        "username": "gokutruns8",
                        "content": "i think 0 represents null value"
                    },
                    {
                        "username": "t_guzma",
                        "content": "\"non-decreasing order\", so increasing order? :D"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "[@gurlakshpreetKaur](/gurlakshpreetKaur) It\\'s kind of a pedantic term. Almost anyone when you ask them if sorting an Amazon search by increasing price might also include two items with the same price next to each-other, they would say yes. Increasing order includes numbers that are the same. It\\'s just needlessly obtuse wording"
                    },
                    {
                        "username": "akanksha1996",
                        "content": "Non decreasing order is when the numbers may or may not increase but they never deccrease for eg 1 2 2 3 3 4 5 6 6."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Not necessarily. If it is 9,9,10,11 then the 9s are equal, therefore no increase was made, hence the non-decreasing."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Merge and sort\n\n  \n**Approach 2:** Three Pointers (Start From the Beginning)\n\n  \n**Approach 3:** Three Pointers (Start From the End)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/3re-K02xQ_g?t=59"
                    },
                    {
                        "username": "alik",
                        "content": "Can it be done without creating a new merged array, meaning sorting using only B and A?"
                    },
                    {
                        "username": "azuregcp",
                        "content": "10 year old comment. Funny.\\nPeople replying with solutions. Hilarious."
                    },
                    {
                        "username": "janis__",
                        "content": "Yes it is possible."
                    },
                    {
                        "username": "dip_018",
                        "content": "[@stanislav888](/stanislav888) try by using logic of insertion sort"
                    },
                    {
                        "username": "stanislav888",
                        "content": "Sure, dude! Just merge vectors from highest values to lowest into the tail of  nums1. I.e. replacing tail nulls with merged(high) values."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 and JavaScript solution\\nThe easiest way is iterate n times then use function to sort?\\nCan we find out a faster solution? Sure !\\n\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/)\\u2B50**\\n\\n**All solution was written by myself, so all have been tested.**\\n![image](https://assets.leetcode.com/users/images/1b85cd5f-8f55-4cce-8aab-bc51e740c66b_1654587254.4308908.jpeg)\\n\\nFor example, here is the Java submission detail.\\n\\n\\n**See more problems solutions : [Zyrastory - More LeetCode Solutions with Explanation](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.\\n\\n**Thanks**\\uD83E\\uDDE1"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "Did you buy the domain name, How did you blog here, I am intrigued, :)"
                    },
                    {
                        "username": "TheKarateKid",
                        "content": "I have tried copying the contents of my sorted array to nums1 using both `nums1 = sortedArray.clone()` and even `nums1 = sortedArray;`\\n\\nThe debugger shows that nums1 has the correct sorted values at the end of the function, but LeetCode\\'s case tester is still giving a \"Wrong Answer\" and showing the original value of nums1 before the copy.\\n\\nAnyone have any advice? Is this an issue with the LeetCode tester?\\n\\n**Update:** Using `System.arraycopy()` fixed the issue, but I think the other ways of copying should still be correct."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "Isn\\'t it because the question says in-place?"
                    }
                ]
            },
            {
                "id": 1565020,
                "content": [
                    {
                        "username": "BigMangos",
                        "content": "> https://leetcode.com/problems/merge-sorted-array/discuss/29503/Beautiful-Python-Solution\\n> \\n\\nI make a flash to understand better.\\n![88.gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n[gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n"
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "i think there is a bug in this . it is taking nums1 as Output not the Stdout. [@LeetCode](/LeetCode)  please fix this issue."
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "I am running this code in my IntelliJ IDE and its giving the expected result but in this leetcode compiler its failing my case. is there any issue"
                    },
                    {
                        "username": "Nitya100",
                        "content": "How you did this kind of gif?"
                    },
                    {
                        "username": "suman_saini",
                        "content": "thanks"
                    },
                    {
                        "username": "Alterra",
                        "content": "I wouldn\\'t work for number smaller than 0\\n"
                    },
                    {
                        "username": "ajitt7381",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "aman1908",
                        "content": "It\\'s working in local system same test cases. so why it\\'s showing error in complier."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@AlteriusOmega](/AlteriusOmega) so how we can solve it then ?"
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "[@blandprix](/blandprix) Bro.. There is even problem with compiling when i try to do this simple case:\\nif(nums1[0]>nums2[nums2Size-1])"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "Make sure you are not using the assignment operator like \"nums1 = ...\" or anything like that because in most programming languages that will just create a new local variable that happens to have the same name, but will not be a reference to the same nums1 input. From then on in your function any time you modify nums1, it will be your local nums1, and so the real nums1 will be unaffected. Can\\'t use the global keyword in Python either since its an argument, not an actual global variable, though it does reference a global variable."
                    },
                    {
                        "username": "Susmita_Patra",
                        "content": "[@blandprix](/blandprix) Same problem"
                    },
                    {
                        "username": "blandprix",
                        "content": "Old question, but for others with the same issue: something like `nums1 = sortedArray` will not work because the variable in the calling scope will still reference the original array. You\\'ll have to mutate the existing array instead of trying to change the reference.\\nSome more detail [here](https://leetcode.com/problems/merge-sorted-array/description/comments/1968717)."
                    },
                    {
                        "username": "dev_kbujak",
                        "content": "Same here, it\\'s annoying!"
                    },
                    {
                        "username": "MoonHalo8088",
                        "content": "Same problem with you(\\u2565\\uFE4F\\u2565)"
                    },
                    {
                        "username": "osmanbaskok",
                        "content": "Yes, the same. It\\'s annoying!"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "yes brother same problem here"
                    },
                    {
                        "username": "mlafortune1223",
                        "content": "When I run console.log(nums1.filter(num => num !== 0).concat(nums2).sort((a,b) => a - b)) it shows [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut then when I remove the console log and just run the functions on num1, it says I\\'m outputting[1,2,3,0,0,0]\\n\\nWhat?"
                    },
                    {
                        "username": "vinjenks",
                        "content": "You can\\'t reassign a param as a whole, but you can reassign the individual array values. Maybe that\\'s an easier way of understanding it."
                    },
                    {
                        "username": "ballanibalaji",
                        "content": "[@TheHood02](/TheHood02)  when you assign a new value to a parameter within a function, it doesn\\'t affect the original variable outside the function. that is the problem\\nIn that case update is recommended instead of reassignment\\n"
                    },
                    {
                        "username": "TheHood02",
                        "content": "When you do a filter, the function returns a new array. It does not mutate the array you applied the filter function on."
                    },
                    {
                        "username": "zuborev_michael",
                        "content": "You don\\'t have to store your values in any buffer if you go backwards"
                    },
                    {
                        "username": "Harshal0409",
                        "content": "This hint is the only one required!"
                    },
                    {
                        "username": "firuz97",
                        "content": "your comment gave me a good hint after that i solved the task in O(n) time"
                    },
                    {
                        "username": "superplane",
                        "content": "I found that for corner case\\nnums1 = [1], m = 1;\\nnums2 = [0], n = 1.\\nThe result should be [0,1], but Leetcode gives [1].\\nDoes Leetcode go wrong here?"
                    },
                    {
                        "username": "agatekartik",
                        "content": "you\\'ll need nums1 to be of size 2 i.e. nums1 = [1,0] initially to satisfy all constraints"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "According to the ques, nums1 is of length (m+n) where m is no of elements to be inserted from nums1 and rest n elements \\'0\\' s  which are to be replaced by nums2 elements. So if m=1, nums1 should be [1,0] in which last \\'0\\' is replaced by nums2 element "
                    },
                    {
                        "username": "prathore28647",
                        "content": "In the given corner case, nums1 contains a single element of value 1, and nums2 contains a single element of value 0. According to the problem statement, the arrays are expected to be merged in non-decreasing order, which means the resulting array should be [0,1], with 0 preceding 1.\\n\\nIf LeetCode is returning [1] instead of [0,1], this would suggest that the solution is not correctly handling the given input, or that there is a mistake in the test cases.\\n\\nIt may be worth checking the solution code for any edge cases or boundary conditions that may not have been handled correctly. Additionally, you may want to try submitting a bug report to LeetCode to bring the issue to their attention."
                    },
                    {
                        "username": "LeetCode_AbdulRehman",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) for that case according to the problem, nums1 should be nums1 = [1, 0], m=1;\\nin order to accommodate the n=1 element of nums2,\\nseems leetcode was right we were not ..."
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\n\nnums1 = [0], m = 0,\n nums2 = [1], n = 1"
                    },
                    {
                        "username": "sl8517",
                        "content": "Apperently nums1 should be [1,0] instead of [1]."
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Please read the question carefully, it is clearly written that \"To accommodate this, nums1 has a length of m + n\". So therefore if nums2 have 1 element in it then nums1 should have minimum 1 element in it.\n"
                    },
                    {
                        "username": "muralivicky",
                        "content": "its not wanting 0\\'s in its nums1. That is also a condition given by leetcode to be considered by the solvers buddy."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well size of nums 1 is always m+n so according to your case if nums1.size is 1 --> m+n = 1 --> n=0 , and in that case ans would be 1 only."
                    },
                    {
                        "username": "gokutruns8",
                        "content": "i think 0 represents null value"
                    },
                    {
                        "username": "t_guzma",
                        "content": "\"non-decreasing order\", so increasing order? :D"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "[@gurlakshpreetKaur](/gurlakshpreetKaur) It\\'s kind of a pedantic term. Almost anyone when you ask them if sorting an Amazon search by increasing price might also include two items with the same price next to each-other, they would say yes. Increasing order includes numbers that are the same. It\\'s just needlessly obtuse wording"
                    },
                    {
                        "username": "akanksha1996",
                        "content": "Non decreasing order is when the numbers may or may not increase but they never deccrease for eg 1 2 2 3 3 4 5 6 6."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Not necessarily. If it is 9,9,10,11 then the 9s are equal, therefore no increase was made, hence the non-decreasing."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Merge and sort\n\n  \n**Approach 2:** Three Pointers (Start From the Beginning)\n\n  \n**Approach 3:** Three Pointers (Start From the End)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/3re-K02xQ_g?t=59"
                    },
                    {
                        "username": "alik",
                        "content": "Can it be done without creating a new merged array, meaning sorting using only B and A?"
                    },
                    {
                        "username": "azuregcp",
                        "content": "10 year old comment. Funny.\\nPeople replying with solutions. Hilarious."
                    },
                    {
                        "username": "janis__",
                        "content": "Yes it is possible."
                    },
                    {
                        "username": "dip_018",
                        "content": "[@stanislav888](/stanislav888) try by using logic of insertion sort"
                    },
                    {
                        "username": "stanislav888",
                        "content": "Sure, dude! Just merge vectors from highest values to lowest into the tail of  nums1. I.e. replacing tail nulls with merged(high) values."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 and JavaScript solution\\nThe easiest way is iterate n times then use function to sort?\\nCan we find out a faster solution? Sure !\\n\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/)\\u2B50**\\n\\n**All solution was written by myself, so all have been tested.**\\n![image](https://assets.leetcode.com/users/images/1b85cd5f-8f55-4cce-8aab-bc51e740c66b_1654587254.4308908.jpeg)\\n\\nFor example, here is the Java submission detail.\\n\\n\\n**See more problems solutions : [Zyrastory - More LeetCode Solutions with Explanation](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.\\n\\n**Thanks**\\uD83E\\uDDE1"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "Did you buy the domain name, How did you blog here, I am intrigued, :)"
                    },
                    {
                        "username": "TheKarateKid",
                        "content": "I have tried copying the contents of my sorted array to nums1 using both `nums1 = sortedArray.clone()` and even `nums1 = sortedArray;`\\n\\nThe debugger shows that nums1 has the correct sorted values at the end of the function, but LeetCode\\'s case tester is still giving a \"Wrong Answer\" and showing the original value of nums1 before the copy.\\n\\nAnyone have any advice? Is this an issue with the LeetCode tester?\\n\\n**Update:** Using `System.arraycopy()` fixed the issue, but I think the other ways of copying should still be correct."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "Isn\\'t it because the question says in-place?"
                    }
                ]
            },
            {
                "id": 1894027,
                "content": [
                    {
                        "username": "BigMangos",
                        "content": "> https://leetcode.com/problems/merge-sorted-array/discuss/29503/Beautiful-Python-Solution\\n> \\n\\nI make a flash to understand better.\\n![88.gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n[gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n"
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "i think there is a bug in this . it is taking nums1 as Output not the Stdout. [@LeetCode](/LeetCode)  please fix this issue."
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "I am running this code in my IntelliJ IDE and its giving the expected result but in this leetcode compiler its failing my case. is there any issue"
                    },
                    {
                        "username": "Nitya100",
                        "content": "How you did this kind of gif?"
                    },
                    {
                        "username": "suman_saini",
                        "content": "thanks"
                    },
                    {
                        "username": "Alterra",
                        "content": "I wouldn\\'t work for number smaller than 0\\n"
                    },
                    {
                        "username": "ajitt7381",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "aman1908",
                        "content": "It\\'s working in local system same test cases. so why it\\'s showing error in complier."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@AlteriusOmega](/AlteriusOmega) so how we can solve it then ?"
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "[@blandprix](/blandprix) Bro.. There is even problem with compiling when i try to do this simple case:\\nif(nums1[0]>nums2[nums2Size-1])"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "Make sure you are not using the assignment operator like \"nums1 = ...\" or anything like that because in most programming languages that will just create a new local variable that happens to have the same name, but will not be a reference to the same nums1 input. From then on in your function any time you modify nums1, it will be your local nums1, and so the real nums1 will be unaffected. Can\\'t use the global keyword in Python either since its an argument, not an actual global variable, though it does reference a global variable."
                    },
                    {
                        "username": "Susmita_Patra",
                        "content": "[@blandprix](/blandprix) Same problem"
                    },
                    {
                        "username": "blandprix",
                        "content": "Old question, but for others with the same issue: something like `nums1 = sortedArray` will not work because the variable in the calling scope will still reference the original array. You\\'ll have to mutate the existing array instead of trying to change the reference.\\nSome more detail [here](https://leetcode.com/problems/merge-sorted-array/description/comments/1968717)."
                    },
                    {
                        "username": "dev_kbujak",
                        "content": "Same here, it\\'s annoying!"
                    },
                    {
                        "username": "MoonHalo8088",
                        "content": "Same problem with you(\\u2565\\uFE4F\\u2565)"
                    },
                    {
                        "username": "osmanbaskok",
                        "content": "Yes, the same. It\\'s annoying!"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "yes brother same problem here"
                    },
                    {
                        "username": "mlafortune1223",
                        "content": "When I run console.log(nums1.filter(num => num !== 0).concat(nums2).sort((a,b) => a - b)) it shows [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut then when I remove the console log and just run the functions on num1, it says I\\'m outputting[1,2,3,0,0,0]\\n\\nWhat?"
                    },
                    {
                        "username": "vinjenks",
                        "content": "You can\\'t reassign a param as a whole, but you can reassign the individual array values. Maybe that\\'s an easier way of understanding it."
                    },
                    {
                        "username": "ballanibalaji",
                        "content": "[@TheHood02](/TheHood02)  when you assign a new value to a parameter within a function, it doesn\\'t affect the original variable outside the function. that is the problem\\nIn that case update is recommended instead of reassignment\\n"
                    },
                    {
                        "username": "TheHood02",
                        "content": "When you do a filter, the function returns a new array. It does not mutate the array you applied the filter function on."
                    },
                    {
                        "username": "zuborev_michael",
                        "content": "You don\\'t have to store your values in any buffer if you go backwards"
                    },
                    {
                        "username": "Harshal0409",
                        "content": "This hint is the only one required!"
                    },
                    {
                        "username": "firuz97",
                        "content": "your comment gave me a good hint after that i solved the task in O(n) time"
                    },
                    {
                        "username": "superplane",
                        "content": "I found that for corner case\\nnums1 = [1], m = 1;\\nnums2 = [0], n = 1.\\nThe result should be [0,1], but Leetcode gives [1].\\nDoes Leetcode go wrong here?"
                    },
                    {
                        "username": "agatekartik",
                        "content": "you\\'ll need nums1 to be of size 2 i.e. nums1 = [1,0] initially to satisfy all constraints"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "According to the ques, nums1 is of length (m+n) where m is no of elements to be inserted from nums1 and rest n elements \\'0\\' s  which are to be replaced by nums2 elements. So if m=1, nums1 should be [1,0] in which last \\'0\\' is replaced by nums2 element "
                    },
                    {
                        "username": "prathore28647",
                        "content": "In the given corner case, nums1 contains a single element of value 1, and nums2 contains a single element of value 0. According to the problem statement, the arrays are expected to be merged in non-decreasing order, which means the resulting array should be [0,1], with 0 preceding 1.\\n\\nIf LeetCode is returning [1] instead of [0,1], this would suggest that the solution is not correctly handling the given input, or that there is a mistake in the test cases.\\n\\nIt may be worth checking the solution code for any edge cases or boundary conditions that may not have been handled correctly. Additionally, you may want to try submitting a bug report to LeetCode to bring the issue to their attention."
                    },
                    {
                        "username": "LeetCode_AbdulRehman",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) for that case according to the problem, nums1 should be nums1 = [1, 0], m=1;\\nin order to accommodate the n=1 element of nums2,\\nseems leetcode was right we were not ..."
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\n\nnums1 = [0], m = 0,\n nums2 = [1], n = 1"
                    },
                    {
                        "username": "sl8517",
                        "content": "Apperently nums1 should be [1,0] instead of [1]."
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Please read the question carefully, it is clearly written that \"To accommodate this, nums1 has a length of m + n\". So therefore if nums2 have 1 element in it then nums1 should have minimum 1 element in it.\n"
                    },
                    {
                        "username": "muralivicky",
                        "content": "its not wanting 0\\'s in its nums1. That is also a condition given by leetcode to be considered by the solvers buddy."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well size of nums 1 is always m+n so according to your case if nums1.size is 1 --> m+n = 1 --> n=0 , and in that case ans would be 1 only."
                    },
                    {
                        "username": "gokutruns8",
                        "content": "i think 0 represents null value"
                    },
                    {
                        "username": "t_guzma",
                        "content": "\"non-decreasing order\", so increasing order? :D"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "[@gurlakshpreetKaur](/gurlakshpreetKaur) It\\'s kind of a pedantic term. Almost anyone when you ask them if sorting an Amazon search by increasing price might also include two items with the same price next to each-other, they would say yes. Increasing order includes numbers that are the same. It\\'s just needlessly obtuse wording"
                    },
                    {
                        "username": "akanksha1996",
                        "content": "Non decreasing order is when the numbers may or may not increase but they never deccrease for eg 1 2 2 3 3 4 5 6 6."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Not necessarily. If it is 9,9,10,11 then the 9s are equal, therefore no increase was made, hence the non-decreasing."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Merge and sort\n\n  \n**Approach 2:** Three Pointers (Start From the Beginning)\n\n  \n**Approach 3:** Three Pointers (Start From the End)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/3re-K02xQ_g?t=59"
                    },
                    {
                        "username": "alik",
                        "content": "Can it be done without creating a new merged array, meaning sorting using only B and A?"
                    },
                    {
                        "username": "azuregcp",
                        "content": "10 year old comment. Funny.\\nPeople replying with solutions. Hilarious."
                    },
                    {
                        "username": "janis__",
                        "content": "Yes it is possible."
                    },
                    {
                        "username": "dip_018",
                        "content": "[@stanislav888](/stanislav888) try by using logic of insertion sort"
                    },
                    {
                        "username": "stanislav888",
                        "content": "Sure, dude! Just merge vectors from highest values to lowest into the tail of  nums1. I.e. replacing tail nulls with merged(high) values."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 and JavaScript solution\\nThe easiest way is iterate n times then use function to sort?\\nCan we find out a faster solution? Sure !\\n\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/)\\u2B50**\\n\\n**All solution was written by myself, so all have been tested.**\\n![image](https://assets.leetcode.com/users/images/1b85cd5f-8f55-4cce-8aab-bc51e740c66b_1654587254.4308908.jpeg)\\n\\nFor example, here is the Java submission detail.\\n\\n\\n**See more problems solutions : [Zyrastory - More LeetCode Solutions with Explanation](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.\\n\\n**Thanks**\\uD83E\\uDDE1"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "Did you buy the domain name, How did you blog here, I am intrigued, :)"
                    },
                    {
                        "username": "TheKarateKid",
                        "content": "I have tried copying the contents of my sorted array to nums1 using both `nums1 = sortedArray.clone()` and even `nums1 = sortedArray;`\\n\\nThe debugger shows that nums1 has the correct sorted values at the end of the function, but LeetCode\\'s case tester is still giving a \"Wrong Answer\" and showing the original value of nums1 before the copy.\\n\\nAnyone have any advice? Is this an issue with the LeetCode tester?\\n\\n**Update:** Using `System.arraycopy()` fixed the issue, but I think the other ways of copying should still be correct."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "Isn\\'t it because the question says in-place?"
                    }
                ]
            },
            {
                "id": 1565819,
                "content": [
                    {
                        "username": "BigMangos",
                        "content": "> https://leetcode.com/problems/merge-sorted-array/discuss/29503/Beautiful-Python-Solution\\n> \\n\\nI make a flash to understand better.\\n![88.gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n[gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n"
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "i think there is a bug in this . it is taking nums1 as Output not the Stdout. [@LeetCode](/LeetCode)  please fix this issue."
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "I am running this code in my IntelliJ IDE and its giving the expected result but in this leetcode compiler its failing my case. is there any issue"
                    },
                    {
                        "username": "Nitya100",
                        "content": "How you did this kind of gif?"
                    },
                    {
                        "username": "suman_saini",
                        "content": "thanks"
                    },
                    {
                        "username": "Alterra",
                        "content": "I wouldn\\'t work for number smaller than 0\\n"
                    },
                    {
                        "username": "ajitt7381",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "aman1908",
                        "content": "It\\'s working in local system same test cases. so why it\\'s showing error in complier."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@AlteriusOmega](/AlteriusOmega) so how we can solve it then ?"
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "[@blandprix](/blandprix) Bro.. There is even problem with compiling when i try to do this simple case:\\nif(nums1[0]>nums2[nums2Size-1])"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "Make sure you are not using the assignment operator like \"nums1 = ...\" or anything like that because in most programming languages that will just create a new local variable that happens to have the same name, but will not be a reference to the same nums1 input. From then on in your function any time you modify nums1, it will be your local nums1, and so the real nums1 will be unaffected. Can\\'t use the global keyword in Python either since its an argument, not an actual global variable, though it does reference a global variable."
                    },
                    {
                        "username": "Susmita_Patra",
                        "content": "[@blandprix](/blandprix) Same problem"
                    },
                    {
                        "username": "blandprix",
                        "content": "Old question, but for others with the same issue: something like `nums1 = sortedArray` will not work because the variable in the calling scope will still reference the original array. You\\'ll have to mutate the existing array instead of trying to change the reference.\\nSome more detail [here](https://leetcode.com/problems/merge-sorted-array/description/comments/1968717)."
                    },
                    {
                        "username": "dev_kbujak",
                        "content": "Same here, it\\'s annoying!"
                    },
                    {
                        "username": "MoonHalo8088",
                        "content": "Same problem with you(\\u2565\\uFE4F\\u2565)"
                    },
                    {
                        "username": "osmanbaskok",
                        "content": "Yes, the same. It\\'s annoying!"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "yes brother same problem here"
                    },
                    {
                        "username": "mlafortune1223",
                        "content": "When I run console.log(nums1.filter(num => num !== 0).concat(nums2).sort((a,b) => a - b)) it shows [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut then when I remove the console log and just run the functions on num1, it says I\\'m outputting[1,2,3,0,0,0]\\n\\nWhat?"
                    },
                    {
                        "username": "vinjenks",
                        "content": "You can\\'t reassign a param as a whole, but you can reassign the individual array values. Maybe that\\'s an easier way of understanding it."
                    },
                    {
                        "username": "ballanibalaji",
                        "content": "[@TheHood02](/TheHood02)  when you assign a new value to a parameter within a function, it doesn\\'t affect the original variable outside the function. that is the problem\\nIn that case update is recommended instead of reassignment\\n"
                    },
                    {
                        "username": "TheHood02",
                        "content": "When you do a filter, the function returns a new array. It does not mutate the array you applied the filter function on."
                    },
                    {
                        "username": "zuborev_michael",
                        "content": "You don\\'t have to store your values in any buffer if you go backwards"
                    },
                    {
                        "username": "Harshal0409",
                        "content": "This hint is the only one required!"
                    },
                    {
                        "username": "firuz97",
                        "content": "your comment gave me a good hint after that i solved the task in O(n) time"
                    },
                    {
                        "username": "superplane",
                        "content": "I found that for corner case\\nnums1 = [1], m = 1;\\nnums2 = [0], n = 1.\\nThe result should be [0,1], but Leetcode gives [1].\\nDoes Leetcode go wrong here?"
                    },
                    {
                        "username": "agatekartik",
                        "content": "you\\'ll need nums1 to be of size 2 i.e. nums1 = [1,0] initially to satisfy all constraints"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "According to the ques, nums1 is of length (m+n) where m is no of elements to be inserted from nums1 and rest n elements \\'0\\' s  which are to be replaced by nums2 elements. So if m=1, nums1 should be [1,0] in which last \\'0\\' is replaced by nums2 element "
                    },
                    {
                        "username": "prathore28647",
                        "content": "In the given corner case, nums1 contains a single element of value 1, and nums2 contains a single element of value 0. According to the problem statement, the arrays are expected to be merged in non-decreasing order, which means the resulting array should be [0,1], with 0 preceding 1.\\n\\nIf LeetCode is returning [1] instead of [0,1], this would suggest that the solution is not correctly handling the given input, or that there is a mistake in the test cases.\\n\\nIt may be worth checking the solution code for any edge cases or boundary conditions that may not have been handled correctly. Additionally, you may want to try submitting a bug report to LeetCode to bring the issue to their attention."
                    },
                    {
                        "username": "LeetCode_AbdulRehman",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) for that case according to the problem, nums1 should be nums1 = [1, 0], m=1;\\nin order to accommodate the n=1 element of nums2,\\nseems leetcode was right we were not ..."
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\n\nnums1 = [0], m = 0,\n nums2 = [1], n = 1"
                    },
                    {
                        "username": "sl8517",
                        "content": "Apperently nums1 should be [1,0] instead of [1]."
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Please read the question carefully, it is clearly written that \"To accommodate this, nums1 has a length of m + n\". So therefore if nums2 have 1 element in it then nums1 should have minimum 1 element in it.\n"
                    },
                    {
                        "username": "muralivicky",
                        "content": "its not wanting 0\\'s in its nums1. That is also a condition given by leetcode to be considered by the solvers buddy."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well size of nums 1 is always m+n so according to your case if nums1.size is 1 --> m+n = 1 --> n=0 , and in that case ans would be 1 only."
                    },
                    {
                        "username": "gokutruns8",
                        "content": "i think 0 represents null value"
                    },
                    {
                        "username": "t_guzma",
                        "content": "\"non-decreasing order\", so increasing order? :D"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "[@gurlakshpreetKaur](/gurlakshpreetKaur) It\\'s kind of a pedantic term. Almost anyone when you ask them if sorting an Amazon search by increasing price might also include two items with the same price next to each-other, they would say yes. Increasing order includes numbers that are the same. It\\'s just needlessly obtuse wording"
                    },
                    {
                        "username": "akanksha1996",
                        "content": "Non decreasing order is when the numbers may or may not increase but they never deccrease for eg 1 2 2 3 3 4 5 6 6."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Not necessarily. If it is 9,9,10,11 then the 9s are equal, therefore no increase was made, hence the non-decreasing."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Merge and sort\n\n  \n**Approach 2:** Three Pointers (Start From the Beginning)\n\n  \n**Approach 3:** Three Pointers (Start From the End)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/3re-K02xQ_g?t=59"
                    },
                    {
                        "username": "alik",
                        "content": "Can it be done without creating a new merged array, meaning sorting using only B and A?"
                    },
                    {
                        "username": "azuregcp",
                        "content": "10 year old comment. Funny.\\nPeople replying with solutions. Hilarious."
                    },
                    {
                        "username": "janis__",
                        "content": "Yes it is possible."
                    },
                    {
                        "username": "dip_018",
                        "content": "[@stanislav888](/stanislav888) try by using logic of insertion sort"
                    },
                    {
                        "username": "stanislav888",
                        "content": "Sure, dude! Just merge vectors from highest values to lowest into the tail of  nums1. I.e. replacing tail nulls with merged(high) values."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 and JavaScript solution\\nThe easiest way is iterate n times then use function to sort?\\nCan we find out a faster solution? Sure !\\n\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/)\\u2B50**\\n\\n**All solution was written by myself, so all have been tested.**\\n![image](https://assets.leetcode.com/users/images/1b85cd5f-8f55-4cce-8aab-bc51e740c66b_1654587254.4308908.jpeg)\\n\\nFor example, here is the Java submission detail.\\n\\n\\n**See more problems solutions : [Zyrastory - More LeetCode Solutions with Explanation](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.\\n\\n**Thanks**\\uD83E\\uDDE1"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "Did you buy the domain name, How did you blog here, I am intrigued, :)"
                    },
                    {
                        "username": "TheKarateKid",
                        "content": "I have tried copying the contents of my sorted array to nums1 using both `nums1 = sortedArray.clone()` and even `nums1 = sortedArray;`\\n\\nThe debugger shows that nums1 has the correct sorted values at the end of the function, but LeetCode\\'s case tester is still giving a \"Wrong Answer\" and showing the original value of nums1 before the copy.\\n\\nAnyone have any advice? Is this an issue with the LeetCode tester?\\n\\n**Update:** Using `System.arraycopy()` fixed the issue, but I think the other ways of copying should still be correct."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "Isn\\'t it because the question says in-place?"
                    }
                ]
            },
            {
                "id": 1567848,
                "content": [
                    {
                        "username": "BigMangos",
                        "content": "> https://leetcode.com/problems/merge-sorted-array/discuss/29503/Beautiful-Python-Solution\\n> \\n\\nI make a flash to understand better.\\n![88.gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n[gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n"
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "i think there is a bug in this . it is taking nums1 as Output not the Stdout. [@LeetCode](/LeetCode)  please fix this issue."
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "I am running this code in my IntelliJ IDE and its giving the expected result but in this leetcode compiler its failing my case. is there any issue"
                    },
                    {
                        "username": "Nitya100",
                        "content": "How you did this kind of gif?"
                    },
                    {
                        "username": "suman_saini",
                        "content": "thanks"
                    },
                    {
                        "username": "Alterra",
                        "content": "I wouldn\\'t work for number smaller than 0\\n"
                    },
                    {
                        "username": "ajitt7381",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "aman1908",
                        "content": "It\\'s working in local system same test cases. so why it\\'s showing error in complier."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@AlteriusOmega](/AlteriusOmega) so how we can solve it then ?"
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "[@blandprix](/blandprix) Bro.. There is even problem with compiling when i try to do this simple case:\\nif(nums1[0]>nums2[nums2Size-1])"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "Make sure you are not using the assignment operator like \"nums1 = ...\" or anything like that because in most programming languages that will just create a new local variable that happens to have the same name, but will not be a reference to the same nums1 input. From then on in your function any time you modify nums1, it will be your local nums1, and so the real nums1 will be unaffected. Can\\'t use the global keyword in Python either since its an argument, not an actual global variable, though it does reference a global variable."
                    },
                    {
                        "username": "Susmita_Patra",
                        "content": "[@blandprix](/blandprix) Same problem"
                    },
                    {
                        "username": "blandprix",
                        "content": "Old question, but for others with the same issue: something like `nums1 = sortedArray` will not work because the variable in the calling scope will still reference the original array. You\\'ll have to mutate the existing array instead of trying to change the reference.\\nSome more detail [here](https://leetcode.com/problems/merge-sorted-array/description/comments/1968717)."
                    },
                    {
                        "username": "dev_kbujak",
                        "content": "Same here, it\\'s annoying!"
                    },
                    {
                        "username": "MoonHalo8088",
                        "content": "Same problem with you(\\u2565\\uFE4F\\u2565)"
                    },
                    {
                        "username": "osmanbaskok",
                        "content": "Yes, the same. It\\'s annoying!"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "yes brother same problem here"
                    },
                    {
                        "username": "mlafortune1223",
                        "content": "When I run console.log(nums1.filter(num => num !== 0).concat(nums2).sort((a,b) => a - b)) it shows [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut then when I remove the console log and just run the functions on num1, it says I\\'m outputting[1,2,3,0,0,0]\\n\\nWhat?"
                    },
                    {
                        "username": "vinjenks",
                        "content": "You can\\'t reassign a param as a whole, but you can reassign the individual array values. Maybe that\\'s an easier way of understanding it."
                    },
                    {
                        "username": "ballanibalaji",
                        "content": "[@TheHood02](/TheHood02)  when you assign a new value to a parameter within a function, it doesn\\'t affect the original variable outside the function. that is the problem\\nIn that case update is recommended instead of reassignment\\n"
                    },
                    {
                        "username": "TheHood02",
                        "content": "When you do a filter, the function returns a new array. It does not mutate the array you applied the filter function on."
                    },
                    {
                        "username": "zuborev_michael",
                        "content": "You don\\'t have to store your values in any buffer if you go backwards"
                    },
                    {
                        "username": "Harshal0409",
                        "content": "This hint is the only one required!"
                    },
                    {
                        "username": "firuz97",
                        "content": "your comment gave me a good hint after that i solved the task in O(n) time"
                    },
                    {
                        "username": "superplane",
                        "content": "I found that for corner case\\nnums1 = [1], m = 1;\\nnums2 = [0], n = 1.\\nThe result should be [0,1], but Leetcode gives [1].\\nDoes Leetcode go wrong here?"
                    },
                    {
                        "username": "agatekartik",
                        "content": "you\\'ll need nums1 to be of size 2 i.e. nums1 = [1,0] initially to satisfy all constraints"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "According to the ques, nums1 is of length (m+n) where m is no of elements to be inserted from nums1 and rest n elements \\'0\\' s  which are to be replaced by nums2 elements. So if m=1, nums1 should be [1,0] in which last \\'0\\' is replaced by nums2 element "
                    },
                    {
                        "username": "prathore28647",
                        "content": "In the given corner case, nums1 contains a single element of value 1, and nums2 contains a single element of value 0. According to the problem statement, the arrays are expected to be merged in non-decreasing order, which means the resulting array should be [0,1], with 0 preceding 1.\\n\\nIf LeetCode is returning [1] instead of [0,1], this would suggest that the solution is not correctly handling the given input, or that there is a mistake in the test cases.\\n\\nIt may be worth checking the solution code for any edge cases or boundary conditions that may not have been handled correctly. Additionally, you may want to try submitting a bug report to LeetCode to bring the issue to their attention."
                    },
                    {
                        "username": "LeetCode_AbdulRehman",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) for that case according to the problem, nums1 should be nums1 = [1, 0], m=1;\\nin order to accommodate the n=1 element of nums2,\\nseems leetcode was right we were not ..."
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\n\nnums1 = [0], m = 0,\n nums2 = [1], n = 1"
                    },
                    {
                        "username": "sl8517",
                        "content": "Apperently nums1 should be [1,0] instead of [1]."
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Please read the question carefully, it is clearly written that \"To accommodate this, nums1 has a length of m + n\". So therefore if nums2 have 1 element in it then nums1 should have minimum 1 element in it.\n"
                    },
                    {
                        "username": "muralivicky",
                        "content": "its not wanting 0\\'s in its nums1. That is also a condition given by leetcode to be considered by the solvers buddy."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well size of nums 1 is always m+n so according to your case if nums1.size is 1 --> m+n = 1 --> n=0 , and in that case ans would be 1 only."
                    },
                    {
                        "username": "gokutruns8",
                        "content": "i think 0 represents null value"
                    },
                    {
                        "username": "t_guzma",
                        "content": "\"non-decreasing order\", so increasing order? :D"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "[@gurlakshpreetKaur](/gurlakshpreetKaur) It\\'s kind of a pedantic term. Almost anyone when you ask them if sorting an Amazon search by increasing price might also include two items with the same price next to each-other, they would say yes. Increasing order includes numbers that are the same. It\\'s just needlessly obtuse wording"
                    },
                    {
                        "username": "akanksha1996",
                        "content": "Non decreasing order is when the numbers may or may not increase but they never deccrease for eg 1 2 2 3 3 4 5 6 6."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Not necessarily. If it is 9,9,10,11 then the 9s are equal, therefore no increase was made, hence the non-decreasing."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Merge and sort\n\n  \n**Approach 2:** Three Pointers (Start From the Beginning)\n\n  \n**Approach 3:** Three Pointers (Start From the End)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/3re-K02xQ_g?t=59"
                    },
                    {
                        "username": "alik",
                        "content": "Can it be done without creating a new merged array, meaning sorting using only B and A?"
                    },
                    {
                        "username": "azuregcp",
                        "content": "10 year old comment. Funny.\\nPeople replying with solutions. Hilarious."
                    },
                    {
                        "username": "janis__",
                        "content": "Yes it is possible."
                    },
                    {
                        "username": "dip_018",
                        "content": "[@stanislav888](/stanislav888) try by using logic of insertion sort"
                    },
                    {
                        "username": "stanislav888",
                        "content": "Sure, dude! Just merge vectors from highest values to lowest into the tail of  nums1. I.e. replacing tail nulls with merged(high) values."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 and JavaScript solution\\nThe easiest way is iterate n times then use function to sort?\\nCan we find out a faster solution? Sure !\\n\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/)\\u2B50**\\n\\n**All solution was written by myself, so all have been tested.**\\n![image](https://assets.leetcode.com/users/images/1b85cd5f-8f55-4cce-8aab-bc51e740c66b_1654587254.4308908.jpeg)\\n\\nFor example, here is the Java submission detail.\\n\\n\\n**See more problems solutions : [Zyrastory - More LeetCode Solutions with Explanation](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.\\n\\n**Thanks**\\uD83E\\uDDE1"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "Did you buy the domain name, How did you blog here, I am intrigued, :)"
                    },
                    {
                        "username": "TheKarateKid",
                        "content": "I have tried copying the contents of my sorted array to nums1 using both `nums1 = sortedArray.clone()` and even `nums1 = sortedArray;`\\n\\nThe debugger shows that nums1 has the correct sorted values at the end of the function, but LeetCode\\'s case tester is still giving a \"Wrong Answer\" and showing the original value of nums1 before the copy.\\n\\nAnyone have any advice? Is this an issue with the LeetCode tester?\\n\\n**Update:** Using `System.arraycopy()` fixed the issue, but I think the other ways of copying should still be correct."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "Isn\\'t it because the question says in-place?"
                    }
                ]
            },
            {
                "id": 1566227,
                "content": [
                    {
                        "username": "BigMangos",
                        "content": "> https://leetcode.com/problems/merge-sorted-array/discuss/29503/Beautiful-Python-Solution\\n> \\n\\nI make a flash to understand better.\\n![88.gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n[gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n"
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "i think there is a bug in this . it is taking nums1 as Output not the Stdout. [@LeetCode](/LeetCode)  please fix this issue."
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "I am running this code in my IntelliJ IDE and its giving the expected result but in this leetcode compiler its failing my case. is there any issue"
                    },
                    {
                        "username": "Nitya100",
                        "content": "How you did this kind of gif?"
                    },
                    {
                        "username": "suman_saini",
                        "content": "thanks"
                    },
                    {
                        "username": "Alterra",
                        "content": "I wouldn\\'t work for number smaller than 0\\n"
                    },
                    {
                        "username": "ajitt7381",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "aman1908",
                        "content": "It\\'s working in local system same test cases. so why it\\'s showing error in complier."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@AlteriusOmega](/AlteriusOmega) so how we can solve it then ?"
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "[@blandprix](/blandprix) Bro.. There is even problem with compiling when i try to do this simple case:\\nif(nums1[0]>nums2[nums2Size-1])"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "Make sure you are not using the assignment operator like \"nums1 = ...\" or anything like that because in most programming languages that will just create a new local variable that happens to have the same name, but will not be a reference to the same nums1 input. From then on in your function any time you modify nums1, it will be your local nums1, and so the real nums1 will be unaffected. Can\\'t use the global keyword in Python either since its an argument, not an actual global variable, though it does reference a global variable."
                    },
                    {
                        "username": "Susmita_Patra",
                        "content": "[@blandprix](/blandprix) Same problem"
                    },
                    {
                        "username": "blandprix",
                        "content": "Old question, but for others with the same issue: something like `nums1 = sortedArray` will not work because the variable in the calling scope will still reference the original array. You\\'ll have to mutate the existing array instead of trying to change the reference.\\nSome more detail [here](https://leetcode.com/problems/merge-sorted-array/description/comments/1968717)."
                    },
                    {
                        "username": "dev_kbujak",
                        "content": "Same here, it\\'s annoying!"
                    },
                    {
                        "username": "MoonHalo8088",
                        "content": "Same problem with you(\\u2565\\uFE4F\\u2565)"
                    },
                    {
                        "username": "osmanbaskok",
                        "content": "Yes, the same. It\\'s annoying!"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "yes brother same problem here"
                    },
                    {
                        "username": "mlafortune1223",
                        "content": "When I run console.log(nums1.filter(num => num !== 0).concat(nums2).sort((a,b) => a - b)) it shows [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut then when I remove the console log and just run the functions on num1, it says I\\'m outputting[1,2,3,0,0,0]\\n\\nWhat?"
                    },
                    {
                        "username": "vinjenks",
                        "content": "You can\\'t reassign a param as a whole, but you can reassign the individual array values. Maybe that\\'s an easier way of understanding it."
                    },
                    {
                        "username": "ballanibalaji",
                        "content": "[@TheHood02](/TheHood02)  when you assign a new value to a parameter within a function, it doesn\\'t affect the original variable outside the function. that is the problem\\nIn that case update is recommended instead of reassignment\\n"
                    },
                    {
                        "username": "TheHood02",
                        "content": "When you do a filter, the function returns a new array. It does not mutate the array you applied the filter function on."
                    },
                    {
                        "username": "zuborev_michael",
                        "content": "You don\\'t have to store your values in any buffer if you go backwards"
                    },
                    {
                        "username": "Harshal0409",
                        "content": "This hint is the only one required!"
                    },
                    {
                        "username": "firuz97",
                        "content": "your comment gave me a good hint after that i solved the task in O(n) time"
                    },
                    {
                        "username": "superplane",
                        "content": "I found that for corner case\\nnums1 = [1], m = 1;\\nnums2 = [0], n = 1.\\nThe result should be [0,1], but Leetcode gives [1].\\nDoes Leetcode go wrong here?"
                    },
                    {
                        "username": "agatekartik",
                        "content": "you\\'ll need nums1 to be of size 2 i.e. nums1 = [1,0] initially to satisfy all constraints"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "According to the ques, nums1 is of length (m+n) where m is no of elements to be inserted from nums1 and rest n elements \\'0\\' s  which are to be replaced by nums2 elements. So if m=1, nums1 should be [1,0] in which last \\'0\\' is replaced by nums2 element "
                    },
                    {
                        "username": "prathore28647",
                        "content": "In the given corner case, nums1 contains a single element of value 1, and nums2 contains a single element of value 0. According to the problem statement, the arrays are expected to be merged in non-decreasing order, which means the resulting array should be [0,1], with 0 preceding 1.\\n\\nIf LeetCode is returning [1] instead of [0,1], this would suggest that the solution is not correctly handling the given input, or that there is a mistake in the test cases.\\n\\nIt may be worth checking the solution code for any edge cases or boundary conditions that may not have been handled correctly. Additionally, you may want to try submitting a bug report to LeetCode to bring the issue to their attention."
                    },
                    {
                        "username": "LeetCode_AbdulRehman",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) for that case according to the problem, nums1 should be nums1 = [1, 0], m=1;\\nin order to accommodate the n=1 element of nums2,\\nseems leetcode was right we were not ..."
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\n\nnums1 = [0], m = 0,\n nums2 = [1], n = 1"
                    },
                    {
                        "username": "sl8517",
                        "content": "Apperently nums1 should be [1,0] instead of [1]."
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Please read the question carefully, it is clearly written that \"To accommodate this, nums1 has a length of m + n\". So therefore if nums2 have 1 element in it then nums1 should have minimum 1 element in it.\n"
                    },
                    {
                        "username": "muralivicky",
                        "content": "its not wanting 0\\'s in its nums1. That is also a condition given by leetcode to be considered by the solvers buddy."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well size of nums 1 is always m+n so according to your case if nums1.size is 1 --> m+n = 1 --> n=0 , and in that case ans would be 1 only."
                    },
                    {
                        "username": "gokutruns8",
                        "content": "i think 0 represents null value"
                    },
                    {
                        "username": "t_guzma",
                        "content": "\"non-decreasing order\", so increasing order? :D"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "[@gurlakshpreetKaur](/gurlakshpreetKaur) It\\'s kind of a pedantic term. Almost anyone when you ask them if sorting an Amazon search by increasing price might also include two items with the same price next to each-other, they would say yes. Increasing order includes numbers that are the same. It\\'s just needlessly obtuse wording"
                    },
                    {
                        "username": "akanksha1996",
                        "content": "Non decreasing order is when the numbers may or may not increase but they never deccrease for eg 1 2 2 3 3 4 5 6 6."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Not necessarily. If it is 9,9,10,11 then the 9s are equal, therefore no increase was made, hence the non-decreasing."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Merge and sort\n\n  \n**Approach 2:** Three Pointers (Start From the Beginning)\n\n  \n**Approach 3:** Three Pointers (Start From the End)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/3re-K02xQ_g?t=59"
                    },
                    {
                        "username": "alik",
                        "content": "Can it be done without creating a new merged array, meaning sorting using only B and A?"
                    },
                    {
                        "username": "azuregcp",
                        "content": "10 year old comment. Funny.\\nPeople replying with solutions. Hilarious."
                    },
                    {
                        "username": "janis__",
                        "content": "Yes it is possible."
                    },
                    {
                        "username": "dip_018",
                        "content": "[@stanislav888](/stanislav888) try by using logic of insertion sort"
                    },
                    {
                        "username": "stanislav888",
                        "content": "Sure, dude! Just merge vectors from highest values to lowest into the tail of  nums1. I.e. replacing tail nulls with merged(high) values."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 and JavaScript solution\\nThe easiest way is iterate n times then use function to sort?\\nCan we find out a faster solution? Sure !\\n\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/)\\u2B50**\\n\\n**All solution was written by myself, so all have been tested.**\\n![image](https://assets.leetcode.com/users/images/1b85cd5f-8f55-4cce-8aab-bc51e740c66b_1654587254.4308908.jpeg)\\n\\nFor example, here is the Java submission detail.\\n\\n\\n**See more problems solutions : [Zyrastory - More LeetCode Solutions with Explanation](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.\\n\\n**Thanks**\\uD83E\\uDDE1"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "Did you buy the domain name, How did you blog here, I am intrigued, :)"
                    },
                    {
                        "username": "TheKarateKid",
                        "content": "I have tried copying the contents of my sorted array to nums1 using both `nums1 = sortedArray.clone()` and even `nums1 = sortedArray;`\\n\\nThe debugger shows that nums1 has the correct sorted values at the end of the function, but LeetCode\\'s case tester is still giving a \"Wrong Answer\" and showing the original value of nums1 before the copy.\\n\\nAnyone have any advice? Is this an issue with the LeetCode tester?\\n\\n**Update:** Using `System.arraycopy()` fixed the issue, but I think the other ways of copying should still be correct."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "Isn\\'t it because the question says in-place?"
                    }
                ]
            },
            {
                "id": 1573252,
                "content": [
                    {
                        "username": "BigMangos",
                        "content": "> https://leetcode.com/problems/merge-sorted-array/discuss/29503/Beautiful-Python-Solution\\n> \\n\\nI make a flash to understand better.\\n![88.gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n[gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n"
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "i think there is a bug in this . it is taking nums1 as Output not the Stdout. [@LeetCode](/LeetCode)  please fix this issue."
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "I am running this code in my IntelliJ IDE and its giving the expected result but in this leetcode compiler its failing my case. is there any issue"
                    },
                    {
                        "username": "Nitya100",
                        "content": "How you did this kind of gif?"
                    },
                    {
                        "username": "suman_saini",
                        "content": "thanks"
                    },
                    {
                        "username": "Alterra",
                        "content": "I wouldn\\'t work for number smaller than 0\\n"
                    },
                    {
                        "username": "ajitt7381",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "aman1908",
                        "content": "It\\'s working in local system same test cases. so why it\\'s showing error in complier."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@AlteriusOmega](/AlteriusOmega) so how we can solve it then ?"
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "[@blandprix](/blandprix) Bro.. There is even problem with compiling when i try to do this simple case:\\nif(nums1[0]>nums2[nums2Size-1])"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "Make sure you are not using the assignment operator like \"nums1 = ...\" or anything like that because in most programming languages that will just create a new local variable that happens to have the same name, but will not be a reference to the same nums1 input. From then on in your function any time you modify nums1, it will be your local nums1, and so the real nums1 will be unaffected. Can\\'t use the global keyword in Python either since its an argument, not an actual global variable, though it does reference a global variable."
                    },
                    {
                        "username": "Susmita_Patra",
                        "content": "[@blandprix](/blandprix) Same problem"
                    },
                    {
                        "username": "blandprix",
                        "content": "Old question, but for others with the same issue: something like `nums1 = sortedArray` will not work because the variable in the calling scope will still reference the original array. You\\'ll have to mutate the existing array instead of trying to change the reference.\\nSome more detail [here](https://leetcode.com/problems/merge-sorted-array/description/comments/1968717)."
                    },
                    {
                        "username": "dev_kbujak",
                        "content": "Same here, it\\'s annoying!"
                    },
                    {
                        "username": "MoonHalo8088",
                        "content": "Same problem with you(\\u2565\\uFE4F\\u2565)"
                    },
                    {
                        "username": "osmanbaskok",
                        "content": "Yes, the same. It\\'s annoying!"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "yes brother same problem here"
                    },
                    {
                        "username": "mlafortune1223",
                        "content": "When I run console.log(nums1.filter(num => num !== 0).concat(nums2).sort((a,b) => a - b)) it shows [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut then when I remove the console log and just run the functions on num1, it says I\\'m outputting[1,2,3,0,0,0]\\n\\nWhat?"
                    },
                    {
                        "username": "vinjenks",
                        "content": "You can\\'t reassign a param as a whole, but you can reassign the individual array values. Maybe that\\'s an easier way of understanding it."
                    },
                    {
                        "username": "ballanibalaji",
                        "content": "[@TheHood02](/TheHood02)  when you assign a new value to a parameter within a function, it doesn\\'t affect the original variable outside the function. that is the problem\\nIn that case update is recommended instead of reassignment\\n"
                    },
                    {
                        "username": "TheHood02",
                        "content": "When you do a filter, the function returns a new array. It does not mutate the array you applied the filter function on."
                    },
                    {
                        "username": "zuborev_michael",
                        "content": "You don\\'t have to store your values in any buffer if you go backwards"
                    },
                    {
                        "username": "Harshal0409",
                        "content": "This hint is the only one required!"
                    },
                    {
                        "username": "firuz97",
                        "content": "your comment gave me a good hint after that i solved the task in O(n) time"
                    },
                    {
                        "username": "superplane",
                        "content": "I found that for corner case\\nnums1 = [1], m = 1;\\nnums2 = [0], n = 1.\\nThe result should be [0,1], but Leetcode gives [1].\\nDoes Leetcode go wrong here?"
                    },
                    {
                        "username": "agatekartik",
                        "content": "you\\'ll need nums1 to be of size 2 i.e. nums1 = [1,0] initially to satisfy all constraints"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "According to the ques, nums1 is of length (m+n) where m is no of elements to be inserted from nums1 and rest n elements \\'0\\' s  which are to be replaced by nums2 elements. So if m=1, nums1 should be [1,0] in which last \\'0\\' is replaced by nums2 element "
                    },
                    {
                        "username": "prathore28647",
                        "content": "In the given corner case, nums1 contains a single element of value 1, and nums2 contains a single element of value 0. According to the problem statement, the arrays are expected to be merged in non-decreasing order, which means the resulting array should be [0,1], with 0 preceding 1.\\n\\nIf LeetCode is returning [1] instead of [0,1], this would suggest that the solution is not correctly handling the given input, or that there is a mistake in the test cases.\\n\\nIt may be worth checking the solution code for any edge cases or boundary conditions that may not have been handled correctly. Additionally, you may want to try submitting a bug report to LeetCode to bring the issue to their attention."
                    },
                    {
                        "username": "LeetCode_AbdulRehman",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) for that case according to the problem, nums1 should be nums1 = [1, 0], m=1;\\nin order to accommodate the n=1 element of nums2,\\nseems leetcode was right we were not ..."
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\n\nnums1 = [0], m = 0,\n nums2 = [1], n = 1"
                    },
                    {
                        "username": "sl8517",
                        "content": "Apperently nums1 should be [1,0] instead of [1]."
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Please read the question carefully, it is clearly written that \"To accommodate this, nums1 has a length of m + n\". So therefore if nums2 have 1 element in it then nums1 should have minimum 1 element in it.\n"
                    },
                    {
                        "username": "muralivicky",
                        "content": "its not wanting 0\\'s in its nums1. That is also a condition given by leetcode to be considered by the solvers buddy."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well size of nums 1 is always m+n so according to your case if nums1.size is 1 --> m+n = 1 --> n=0 , and in that case ans would be 1 only."
                    },
                    {
                        "username": "gokutruns8",
                        "content": "i think 0 represents null value"
                    },
                    {
                        "username": "t_guzma",
                        "content": "\"non-decreasing order\", so increasing order? :D"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "[@gurlakshpreetKaur](/gurlakshpreetKaur) It\\'s kind of a pedantic term. Almost anyone when you ask them if sorting an Amazon search by increasing price might also include two items with the same price next to each-other, they would say yes. Increasing order includes numbers that are the same. It\\'s just needlessly obtuse wording"
                    },
                    {
                        "username": "akanksha1996",
                        "content": "Non decreasing order is when the numbers may or may not increase but they never deccrease for eg 1 2 2 3 3 4 5 6 6."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Not necessarily. If it is 9,9,10,11 then the 9s are equal, therefore no increase was made, hence the non-decreasing."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Merge and sort\n\n  \n**Approach 2:** Three Pointers (Start From the Beginning)\n\n  \n**Approach 3:** Three Pointers (Start From the End)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/3re-K02xQ_g?t=59"
                    },
                    {
                        "username": "alik",
                        "content": "Can it be done without creating a new merged array, meaning sorting using only B and A?"
                    },
                    {
                        "username": "azuregcp",
                        "content": "10 year old comment. Funny.\\nPeople replying with solutions. Hilarious."
                    },
                    {
                        "username": "janis__",
                        "content": "Yes it is possible."
                    },
                    {
                        "username": "dip_018",
                        "content": "[@stanislav888](/stanislav888) try by using logic of insertion sort"
                    },
                    {
                        "username": "stanislav888",
                        "content": "Sure, dude! Just merge vectors from highest values to lowest into the tail of  nums1. I.e. replacing tail nulls with merged(high) values."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 and JavaScript solution\\nThe easiest way is iterate n times then use function to sort?\\nCan we find out a faster solution? Sure !\\n\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/)\\u2B50**\\n\\n**All solution was written by myself, so all have been tested.**\\n![image](https://assets.leetcode.com/users/images/1b85cd5f-8f55-4cce-8aab-bc51e740c66b_1654587254.4308908.jpeg)\\n\\nFor example, here is the Java submission detail.\\n\\n\\n**See more problems solutions : [Zyrastory - More LeetCode Solutions with Explanation](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.\\n\\n**Thanks**\\uD83E\\uDDE1"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "Did you buy the domain name, How did you blog here, I am intrigued, :)"
                    },
                    {
                        "username": "TheKarateKid",
                        "content": "I have tried copying the contents of my sorted array to nums1 using both `nums1 = sortedArray.clone()` and even `nums1 = sortedArray;`\\n\\nThe debugger shows that nums1 has the correct sorted values at the end of the function, but LeetCode\\'s case tester is still giving a \"Wrong Answer\" and showing the original value of nums1 before the copy.\\n\\nAnyone have any advice? Is this an issue with the LeetCode tester?\\n\\n**Update:** Using `System.arraycopy()` fixed the issue, but I think the other ways of copying should still be correct."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "Isn\\'t it because the question says in-place?"
                    }
                ]
            },
            {
                "id": 1572679,
                "content": [
                    {
                        "username": "BigMangos",
                        "content": "> https://leetcode.com/problems/merge-sorted-array/discuss/29503/Beautiful-Python-Solution\\n> \\n\\nI make a flash to understand better.\\n![88.gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n[gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n"
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "i think there is a bug in this . it is taking nums1 as Output not the Stdout. [@LeetCode](/LeetCode)  please fix this issue."
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "I am running this code in my IntelliJ IDE and its giving the expected result but in this leetcode compiler its failing my case. is there any issue"
                    },
                    {
                        "username": "Nitya100",
                        "content": "How you did this kind of gif?"
                    },
                    {
                        "username": "suman_saini",
                        "content": "thanks"
                    },
                    {
                        "username": "Alterra",
                        "content": "I wouldn\\'t work for number smaller than 0\\n"
                    },
                    {
                        "username": "ajitt7381",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "aman1908",
                        "content": "It\\'s working in local system same test cases. so why it\\'s showing error in complier."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@AlteriusOmega](/AlteriusOmega) so how we can solve it then ?"
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "[@blandprix](/blandprix) Bro.. There is even problem with compiling when i try to do this simple case:\\nif(nums1[0]>nums2[nums2Size-1])"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "Make sure you are not using the assignment operator like \"nums1 = ...\" or anything like that because in most programming languages that will just create a new local variable that happens to have the same name, but will not be a reference to the same nums1 input. From then on in your function any time you modify nums1, it will be your local nums1, and so the real nums1 will be unaffected. Can\\'t use the global keyword in Python either since its an argument, not an actual global variable, though it does reference a global variable."
                    },
                    {
                        "username": "Susmita_Patra",
                        "content": "[@blandprix](/blandprix) Same problem"
                    },
                    {
                        "username": "blandprix",
                        "content": "Old question, but for others with the same issue: something like `nums1 = sortedArray` will not work because the variable in the calling scope will still reference the original array. You\\'ll have to mutate the existing array instead of trying to change the reference.\\nSome more detail [here](https://leetcode.com/problems/merge-sorted-array/description/comments/1968717)."
                    },
                    {
                        "username": "dev_kbujak",
                        "content": "Same here, it\\'s annoying!"
                    },
                    {
                        "username": "MoonHalo8088",
                        "content": "Same problem with you(\\u2565\\uFE4F\\u2565)"
                    },
                    {
                        "username": "osmanbaskok",
                        "content": "Yes, the same. It\\'s annoying!"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "yes brother same problem here"
                    },
                    {
                        "username": "mlafortune1223",
                        "content": "When I run console.log(nums1.filter(num => num !== 0).concat(nums2).sort((a,b) => a - b)) it shows [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut then when I remove the console log and just run the functions on num1, it says I\\'m outputting[1,2,3,0,0,0]\\n\\nWhat?"
                    },
                    {
                        "username": "vinjenks",
                        "content": "You can\\'t reassign a param as a whole, but you can reassign the individual array values. Maybe that\\'s an easier way of understanding it."
                    },
                    {
                        "username": "ballanibalaji",
                        "content": "[@TheHood02](/TheHood02)  when you assign a new value to a parameter within a function, it doesn\\'t affect the original variable outside the function. that is the problem\\nIn that case update is recommended instead of reassignment\\n"
                    },
                    {
                        "username": "TheHood02",
                        "content": "When you do a filter, the function returns a new array. It does not mutate the array you applied the filter function on."
                    },
                    {
                        "username": "zuborev_michael",
                        "content": "You don\\'t have to store your values in any buffer if you go backwards"
                    },
                    {
                        "username": "Harshal0409",
                        "content": "This hint is the only one required!"
                    },
                    {
                        "username": "firuz97",
                        "content": "your comment gave me a good hint after that i solved the task in O(n) time"
                    },
                    {
                        "username": "superplane",
                        "content": "I found that for corner case\\nnums1 = [1], m = 1;\\nnums2 = [0], n = 1.\\nThe result should be [0,1], but Leetcode gives [1].\\nDoes Leetcode go wrong here?"
                    },
                    {
                        "username": "agatekartik",
                        "content": "you\\'ll need nums1 to be of size 2 i.e. nums1 = [1,0] initially to satisfy all constraints"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "According to the ques, nums1 is of length (m+n) where m is no of elements to be inserted from nums1 and rest n elements \\'0\\' s  which are to be replaced by nums2 elements. So if m=1, nums1 should be [1,0] in which last \\'0\\' is replaced by nums2 element "
                    },
                    {
                        "username": "prathore28647",
                        "content": "In the given corner case, nums1 contains a single element of value 1, and nums2 contains a single element of value 0. According to the problem statement, the arrays are expected to be merged in non-decreasing order, which means the resulting array should be [0,1], with 0 preceding 1.\\n\\nIf LeetCode is returning [1] instead of [0,1], this would suggest that the solution is not correctly handling the given input, or that there is a mistake in the test cases.\\n\\nIt may be worth checking the solution code for any edge cases or boundary conditions that may not have been handled correctly. Additionally, you may want to try submitting a bug report to LeetCode to bring the issue to their attention."
                    },
                    {
                        "username": "LeetCode_AbdulRehman",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) for that case according to the problem, nums1 should be nums1 = [1, 0], m=1;\\nin order to accommodate the n=1 element of nums2,\\nseems leetcode was right we were not ..."
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\n\nnums1 = [0], m = 0,\n nums2 = [1], n = 1"
                    },
                    {
                        "username": "sl8517",
                        "content": "Apperently nums1 should be [1,0] instead of [1]."
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Please read the question carefully, it is clearly written that \"To accommodate this, nums1 has a length of m + n\". So therefore if nums2 have 1 element in it then nums1 should have minimum 1 element in it.\n"
                    },
                    {
                        "username": "muralivicky",
                        "content": "its not wanting 0\\'s in its nums1. That is also a condition given by leetcode to be considered by the solvers buddy."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well size of nums 1 is always m+n so according to your case if nums1.size is 1 --> m+n = 1 --> n=0 , and in that case ans would be 1 only."
                    },
                    {
                        "username": "gokutruns8",
                        "content": "i think 0 represents null value"
                    },
                    {
                        "username": "t_guzma",
                        "content": "\"non-decreasing order\", so increasing order? :D"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "[@gurlakshpreetKaur](/gurlakshpreetKaur) It\\'s kind of a pedantic term. Almost anyone when you ask them if sorting an Amazon search by increasing price might also include two items with the same price next to each-other, they would say yes. Increasing order includes numbers that are the same. It\\'s just needlessly obtuse wording"
                    },
                    {
                        "username": "akanksha1996",
                        "content": "Non decreasing order is when the numbers may or may not increase but they never deccrease for eg 1 2 2 3 3 4 5 6 6."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Not necessarily. If it is 9,9,10,11 then the 9s are equal, therefore no increase was made, hence the non-decreasing."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Merge and sort\n\n  \n**Approach 2:** Three Pointers (Start From the Beginning)\n\n  \n**Approach 3:** Three Pointers (Start From the End)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/3re-K02xQ_g?t=59"
                    },
                    {
                        "username": "alik",
                        "content": "Can it be done without creating a new merged array, meaning sorting using only B and A?"
                    },
                    {
                        "username": "azuregcp",
                        "content": "10 year old comment. Funny.\\nPeople replying with solutions. Hilarious."
                    },
                    {
                        "username": "janis__",
                        "content": "Yes it is possible."
                    },
                    {
                        "username": "dip_018",
                        "content": "[@stanislav888](/stanislav888) try by using logic of insertion sort"
                    },
                    {
                        "username": "stanislav888",
                        "content": "Sure, dude! Just merge vectors from highest values to lowest into the tail of  nums1. I.e. replacing tail nulls with merged(high) values."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 and JavaScript solution\\nThe easiest way is iterate n times then use function to sort?\\nCan we find out a faster solution? Sure !\\n\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/)\\u2B50**\\n\\n**All solution was written by myself, so all have been tested.**\\n![image](https://assets.leetcode.com/users/images/1b85cd5f-8f55-4cce-8aab-bc51e740c66b_1654587254.4308908.jpeg)\\n\\nFor example, here is the Java submission detail.\\n\\n\\n**See more problems solutions : [Zyrastory - More LeetCode Solutions with Explanation](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.\\n\\n**Thanks**\\uD83E\\uDDE1"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "Did you buy the domain name, How did you blog here, I am intrigued, :)"
                    },
                    {
                        "username": "TheKarateKid",
                        "content": "I have tried copying the contents of my sorted array to nums1 using both `nums1 = sortedArray.clone()` and even `nums1 = sortedArray;`\\n\\nThe debugger shows that nums1 has the correct sorted values at the end of the function, but LeetCode\\'s case tester is still giving a \"Wrong Answer\" and showing the original value of nums1 before the copy.\\n\\nAnyone have any advice? Is this an issue with the LeetCode tester?\\n\\n**Update:** Using `System.arraycopy()` fixed the issue, but I think the other ways of copying should still be correct."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "Isn\\'t it because the question says in-place?"
                    }
                ]
            },
            {
                "id": 1778733,
                "content": [
                    {
                        "username": "BigMangos",
                        "content": "> https://leetcode.com/problems/merge-sorted-array/discuss/29503/Beautiful-Python-Solution\\n> \\n\\nI make a flash to understand better.\\n![88.gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n[gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n"
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "i think there is a bug in this . it is taking nums1 as Output not the Stdout. [@LeetCode](/LeetCode)  please fix this issue."
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "I am running this code in my IntelliJ IDE and its giving the expected result but in this leetcode compiler its failing my case. is there any issue"
                    },
                    {
                        "username": "Nitya100",
                        "content": "How you did this kind of gif?"
                    },
                    {
                        "username": "suman_saini",
                        "content": "thanks"
                    },
                    {
                        "username": "Alterra",
                        "content": "I wouldn\\'t work for number smaller than 0\\n"
                    },
                    {
                        "username": "ajitt7381",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "aman1908",
                        "content": "It\\'s working in local system same test cases. so why it\\'s showing error in complier."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@AlteriusOmega](/AlteriusOmega) so how we can solve it then ?"
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "[@blandprix](/blandprix) Bro.. There is even problem with compiling when i try to do this simple case:\\nif(nums1[0]>nums2[nums2Size-1])"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "Make sure you are not using the assignment operator like \"nums1 = ...\" or anything like that because in most programming languages that will just create a new local variable that happens to have the same name, but will not be a reference to the same nums1 input. From then on in your function any time you modify nums1, it will be your local nums1, and so the real nums1 will be unaffected. Can\\'t use the global keyword in Python either since its an argument, not an actual global variable, though it does reference a global variable."
                    },
                    {
                        "username": "Susmita_Patra",
                        "content": "[@blandprix](/blandprix) Same problem"
                    },
                    {
                        "username": "blandprix",
                        "content": "Old question, but for others with the same issue: something like `nums1 = sortedArray` will not work because the variable in the calling scope will still reference the original array. You\\'ll have to mutate the existing array instead of trying to change the reference.\\nSome more detail [here](https://leetcode.com/problems/merge-sorted-array/description/comments/1968717)."
                    },
                    {
                        "username": "dev_kbujak",
                        "content": "Same here, it\\'s annoying!"
                    },
                    {
                        "username": "MoonHalo8088",
                        "content": "Same problem with you(\\u2565\\uFE4F\\u2565)"
                    },
                    {
                        "username": "osmanbaskok",
                        "content": "Yes, the same. It\\'s annoying!"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "yes brother same problem here"
                    },
                    {
                        "username": "mlafortune1223",
                        "content": "When I run console.log(nums1.filter(num => num !== 0).concat(nums2).sort((a,b) => a - b)) it shows [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut then when I remove the console log and just run the functions on num1, it says I\\'m outputting[1,2,3,0,0,0]\\n\\nWhat?"
                    },
                    {
                        "username": "vinjenks",
                        "content": "You can\\'t reassign a param as a whole, but you can reassign the individual array values. Maybe that\\'s an easier way of understanding it."
                    },
                    {
                        "username": "ballanibalaji",
                        "content": "[@TheHood02](/TheHood02)  when you assign a new value to a parameter within a function, it doesn\\'t affect the original variable outside the function. that is the problem\\nIn that case update is recommended instead of reassignment\\n"
                    },
                    {
                        "username": "TheHood02",
                        "content": "When you do a filter, the function returns a new array. It does not mutate the array you applied the filter function on."
                    },
                    {
                        "username": "zuborev_michael",
                        "content": "You don\\'t have to store your values in any buffer if you go backwards"
                    },
                    {
                        "username": "Harshal0409",
                        "content": "This hint is the only one required!"
                    },
                    {
                        "username": "firuz97",
                        "content": "your comment gave me a good hint after that i solved the task in O(n) time"
                    },
                    {
                        "username": "superplane",
                        "content": "I found that for corner case\\nnums1 = [1], m = 1;\\nnums2 = [0], n = 1.\\nThe result should be [0,1], but Leetcode gives [1].\\nDoes Leetcode go wrong here?"
                    },
                    {
                        "username": "agatekartik",
                        "content": "you\\'ll need nums1 to be of size 2 i.e. nums1 = [1,0] initially to satisfy all constraints"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "According to the ques, nums1 is of length (m+n) where m is no of elements to be inserted from nums1 and rest n elements \\'0\\' s  which are to be replaced by nums2 elements. So if m=1, nums1 should be [1,0] in which last \\'0\\' is replaced by nums2 element "
                    },
                    {
                        "username": "prathore28647",
                        "content": "In the given corner case, nums1 contains a single element of value 1, and nums2 contains a single element of value 0. According to the problem statement, the arrays are expected to be merged in non-decreasing order, which means the resulting array should be [0,1], with 0 preceding 1.\\n\\nIf LeetCode is returning [1] instead of [0,1], this would suggest that the solution is not correctly handling the given input, or that there is a mistake in the test cases.\\n\\nIt may be worth checking the solution code for any edge cases or boundary conditions that may not have been handled correctly. Additionally, you may want to try submitting a bug report to LeetCode to bring the issue to their attention."
                    },
                    {
                        "username": "LeetCode_AbdulRehman",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) for that case according to the problem, nums1 should be nums1 = [1, 0], m=1;\\nin order to accommodate the n=1 element of nums2,\\nseems leetcode was right we were not ..."
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\n\nnums1 = [0], m = 0,\n nums2 = [1], n = 1"
                    },
                    {
                        "username": "sl8517",
                        "content": "Apperently nums1 should be [1,0] instead of [1]."
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Please read the question carefully, it is clearly written that \"To accommodate this, nums1 has a length of m + n\". So therefore if nums2 have 1 element in it then nums1 should have minimum 1 element in it.\n"
                    },
                    {
                        "username": "muralivicky",
                        "content": "its not wanting 0\\'s in its nums1. That is also a condition given by leetcode to be considered by the solvers buddy."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well size of nums 1 is always m+n so according to your case if nums1.size is 1 --> m+n = 1 --> n=0 , and in that case ans would be 1 only."
                    },
                    {
                        "username": "gokutruns8",
                        "content": "i think 0 represents null value"
                    },
                    {
                        "username": "t_guzma",
                        "content": "\"non-decreasing order\", so increasing order? :D"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "[@gurlakshpreetKaur](/gurlakshpreetKaur) It\\'s kind of a pedantic term. Almost anyone when you ask them if sorting an Amazon search by increasing price might also include two items with the same price next to each-other, they would say yes. Increasing order includes numbers that are the same. It\\'s just needlessly obtuse wording"
                    },
                    {
                        "username": "akanksha1996",
                        "content": "Non decreasing order is when the numbers may or may not increase but they never deccrease for eg 1 2 2 3 3 4 5 6 6."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Not necessarily. If it is 9,9,10,11 then the 9s are equal, therefore no increase was made, hence the non-decreasing."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Merge and sort\n\n  \n**Approach 2:** Three Pointers (Start From the Beginning)\n\n  \n**Approach 3:** Three Pointers (Start From the End)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/3re-K02xQ_g?t=59"
                    },
                    {
                        "username": "alik",
                        "content": "Can it be done without creating a new merged array, meaning sorting using only B and A?"
                    },
                    {
                        "username": "azuregcp",
                        "content": "10 year old comment. Funny.\\nPeople replying with solutions. Hilarious."
                    },
                    {
                        "username": "janis__",
                        "content": "Yes it is possible."
                    },
                    {
                        "username": "dip_018",
                        "content": "[@stanislav888](/stanislav888) try by using logic of insertion sort"
                    },
                    {
                        "username": "stanislav888",
                        "content": "Sure, dude! Just merge vectors from highest values to lowest into the tail of  nums1. I.e. replacing tail nulls with merged(high) values."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 and JavaScript solution\\nThe easiest way is iterate n times then use function to sort?\\nCan we find out a faster solution? Sure !\\n\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/)\\u2B50**\\n\\n**All solution was written by myself, so all have been tested.**\\n![image](https://assets.leetcode.com/users/images/1b85cd5f-8f55-4cce-8aab-bc51e740c66b_1654587254.4308908.jpeg)\\n\\nFor example, here is the Java submission detail.\\n\\n\\n**See more problems solutions : [Zyrastory - More LeetCode Solutions with Explanation](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.\\n\\n**Thanks**\\uD83E\\uDDE1"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "Did you buy the domain name, How did you blog here, I am intrigued, :)"
                    },
                    {
                        "username": "TheKarateKid",
                        "content": "I have tried copying the contents of my sorted array to nums1 using both `nums1 = sortedArray.clone()` and even `nums1 = sortedArray;`\\n\\nThe debugger shows that nums1 has the correct sorted values at the end of the function, but LeetCode\\'s case tester is still giving a \"Wrong Answer\" and showing the original value of nums1 before the copy.\\n\\nAnyone have any advice? Is this an issue with the LeetCode tester?\\n\\n**Update:** Using `System.arraycopy()` fixed the issue, but I think the other ways of copying should still be correct."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "Isn\\'t it because the question says in-place?"
                    }
                ]
            },
            {
                "id": 1768684,
                "content": [
                    {
                        "username": "BigMangos",
                        "content": "> https://leetcode.com/problems/merge-sorted-array/discuss/29503/Beautiful-Python-Solution\\n> \\n\\nI make a flash to understand better.\\n![88.gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n[gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n"
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "i think there is a bug in this . it is taking nums1 as Output not the Stdout. [@LeetCode](/LeetCode)  please fix this issue."
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "I am running this code in my IntelliJ IDE and its giving the expected result but in this leetcode compiler its failing my case. is there any issue"
                    },
                    {
                        "username": "Nitya100",
                        "content": "How you did this kind of gif?"
                    },
                    {
                        "username": "suman_saini",
                        "content": "thanks"
                    },
                    {
                        "username": "Alterra",
                        "content": "I wouldn\\'t work for number smaller than 0\\n"
                    },
                    {
                        "username": "ajitt7381",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "aman1908",
                        "content": "It\\'s working in local system same test cases. so why it\\'s showing error in complier."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@AlteriusOmega](/AlteriusOmega) so how we can solve it then ?"
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "[@blandprix](/blandprix) Bro.. There is even problem with compiling when i try to do this simple case:\\nif(nums1[0]>nums2[nums2Size-1])"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "Make sure you are not using the assignment operator like \"nums1 = ...\" or anything like that because in most programming languages that will just create a new local variable that happens to have the same name, but will not be a reference to the same nums1 input. From then on in your function any time you modify nums1, it will be your local nums1, and so the real nums1 will be unaffected. Can\\'t use the global keyword in Python either since its an argument, not an actual global variable, though it does reference a global variable."
                    },
                    {
                        "username": "Susmita_Patra",
                        "content": "[@blandprix](/blandprix) Same problem"
                    },
                    {
                        "username": "blandprix",
                        "content": "Old question, but for others with the same issue: something like `nums1 = sortedArray` will not work because the variable in the calling scope will still reference the original array. You\\'ll have to mutate the existing array instead of trying to change the reference.\\nSome more detail [here](https://leetcode.com/problems/merge-sorted-array/description/comments/1968717)."
                    },
                    {
                        "username": "dev_kbujak",
                        "content": "Same here, it\\'s annoying!"
                    },
                    {
                        "username": "MoonHalo8088",
                        "content": "Same problem with you(\\u2565\\uFE4F\\u2565)"
                    },
                    {
                        "username": "osmanbaskok",
                        "content": "Yes, the same. It\\'s annoying!"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "yes brother same problem here"
                    },
                    {
                        "username": "mlafortune1223",
                        "content": "When I run console.log(nums1.filter(num => num !== 0).concat(nums2).sort((a,b) => a - b)) it shows [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut then when I remove the console log and just run the functions on num1, it says I\\'m outputting[1,2,3,0,0,0]\\n\\nWhat?"
                    },
                    {
                        "username": "vinjenks",
                        "content": "You can\\'t reassign a param as a whole, but you can reassign the individual array values. Maybe that\\'s an easier way of understanding it."
                    },
                    {
                        "username": "ballanibalaji",
                        "content": "[@TheHood02](/TheHood02)  when you assign a new value to a parameter within a function, it doesn\\'t affect the original variable outside the function. that is the problem\\nIn that case update is recommended instead of reassignment\\n"
                    },
                    {
                        "username": "TheHood02",
                        "content": "When you do a filter, the function returns a new array. It does not mutate the array you applied the filter function on."
                    },
                    {
                        "username": "zuborev_michael",
                        "content": "You don\\'t have to store your values in any buffer if you go backwards"
                    },
                    {
                        "username": "Harshal0409",
                        "content": "This hint is the only one required!"
                    },
                    {
                        "username": "firuz97",
                        "content": "your comment gave me a good hint after that i solved the task in O(n) time"
                    },
                    {
                        "username": "superplane",
                        "content": "I found that for corner case\\nnums1 = [1], m = 1;\\nnums2 = [0], n = 1.\\nThe result should be [0,1], but Leetcode gives [1].\\nDoes Leetcode go wrong here?"
                    },
                    {
                        "username": "agatekartik",
                        "content": "you\\'ll need nums1 to be of size 2 i.e. nums1 = [1,0] initially to satisfy all constraints"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "According to the ques, nums1 is of length (m+n) where m is no of elements to be inserted from nums1 and rest n elements \\'0\\' s  which are to be replaced by nums2 elements. So if m=1, nums1 should be [1,0] in which last \\'0\\' is replaced by nums2 element "
                    },
                    {
                        "username": "prathore28647",
                        "content": "In the given corner case, nums1 contains a single element of value 1, and nums2 contains a single element of value 0. According to the problem statement, the arrays are expected to be merged in non-decreasing order, which means the resulting array should be [0,1], with 0 preceding 1.\\n\\nIf LeetCode is returning [1] instead of [0,1], this would suggest that the solution is not correctly handling the given input, or that there is a mistake in the test cases.\\n\\nIt may be worth checking the solution code for any edge cases or boundary conditions that may not have been handled correctly. Additionally, you may want to try submitting a bug report to LeetCode to bring the issue to their attention."
                    },
                    {
                        "username": "LeetCode_AbdulRehman",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) for that case according to the problem, nums1 should be nums1 = [1, 0], m=1;\\nin order to accommodate the n=1 element of nums2,\\nseems leetcode was right we were not ..."
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\n\nnums1 = [0], m = 0,\n nums2 = [1], n = 1"
                    },
                    {
                        "username": "sl8517",
                        "content": "Apperently nums1 should be [1,0] instead of [1]."
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Please read the question carefully, it is clearly written that \"To accommodate this, nums1 has a length of m + n\". So therefore if nums2 have 1 element in it then nums1 should have minimum 1 element in it.\n"
                    },
                    {
                        "username": "muralivicky",
                        "content": "its not wanting 0\\'s in its nums1. That is also a condition given by leetcode to be considered by the solvers buddy."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well size of nums 1 is always m+n so according to your case if nums1.size is 1 --> m+n = 1 --> n=0 , and in that case ans would be 1 only."
                    },
                    {
                        "username": "gokutruns8",
                        "content": "i think 0 represents null value"
                    },
                    {
                        "username": "t_guzma",
                        "content": "\"non-decreasing order\", so increasing order? :D"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "[@gurlakshpreetKaur](/gurlakshpreetKaur) It\\'s kind of a pedantic term. Almost anyone when you ask them if sorting an Amazon search by increasing price might also include two items with the same price next to each-other, they would say yes. Increasing order includes numbers that are the same. It\\'s just needlessly obtuse wording"
                    },
                    {
                        "username": "akanksha1996",
                        "content": "Non decreasing order is when the numbers may or may not increase but they never deccrease for eg 1 2 2 3 3 4 5 6 6."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Not necessarily. If it is 9,9,10,11 then the 9s are equal, therefore no increase was made, hence the non-decreasing."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Merge and sort\n\n  \n**Approach 2:** Three Pointers (Start From the Beginning)\n\n  \n**Approach 3:** Three Pointers (Start From the End)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/3re-K02xQ_g?t=59"
                    },
                    {
                        "username": "alik",
                        "content": "Can it be done without creating a new merged array, meaning sorting using only B and A?"
                    },
                    {
                        "username": "azuregcp",
                        "content": "10 year old comment. Funny.\\nPeople replying with solutions. Hilarious."
                    },
                    {
                        "username": "janis__",
                        "content": "Yes it is possible."
                    },
                    {
                        "username": "dip_018",
                        "content": "[@stanislav888](/stanislav888) try by using logic of insertion sort"
                    },
                    {
                        "username": "stanislav888",
                        "content": "Sure, dude! Just merge vectors from highest values to lowest into the tail of  nums1. I.e. replacing tail nulls with merged(high) values."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 and JavaScript solution\\nThe easiest way is iterate n times then use function to sort?\\nCan we find out a faster solution? Sure !\\n\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/)\\u2B50**\\n\\n**All solution was written by myself, so all have been tested.**\\n![image](https://assets.leetcode.com/users/images/1b85cd5f-8f55-4cce-8aab-bc51e740c66b_1654587254.4308908.jpeg)\\n\\nFor example, here is the Java submission detail.\\n\\n\\n**See more problems solutions : [Zyrastory - More LeetCode Solutions with Explanation](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.\\n\\n**Thanks**\\uD83E\\uDDE1"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "Did you buy the domain name, How did you blog here, I am intrigued, :)"
                    },
                    {
                        "username": "TheKarateKid",
                        "content": "I have tried copying the contents of my sorted array to nums1 using both `nums1 = sortedArray.clone()` and even `nums1 = sortedArray;`\\n\\nThe debugger shows that nums1 has the correct sorted values at the end of the function, but LeetCode\\'s case tester is still giving a \"Wrong Answer\" and showing the original value of nums1 before the copy.\\n\\nAnyone have any advice? Is this an issue with the LeetCode tester?\\n\\n**Update:** Using `System.arraycopy()` fixed the issue, but I think the other ways of copying should still be correct."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "Isn\\'t it because the question says in-place?"
                    }
                ]
            },
            {
                "id": 1573374,
                "content": [
                    {
                        "username": "BigMangos",
                        "content": "> https://leetcode.com/problems/merge-sorted-array/discuss/29503/Beautiful-Python-Solution\\n> \\n\\nI make a flash to understand better.\\n![88.gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n[gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n"
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "i think there is a bug in this . it is taking nums1 as Output not the Stdout. [@LeetCode](/LeetCode)  please fix this issue."
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "I am running this code in my IntelliJ IDE and its giving the expected result but in this leetcode compiler its failing my case. is there any issue"
                    },
                    {
                        "username": "Nitya100",
                        "content": "How you did this kind of gif?"
                    },
                    {
                        "username": "suman_saini",
                        "content": "thanks"
                    },
                    {
                        "username": "Alterra",
                        "content": "I wouldn\\'t work for number smaller than 0\\n"
                    },
                    {
                        "username": "ajitt7381",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "aman1908",
                        "content": "It\\'s working in local system same test cases. so why it\\'s showing error in complier."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@AlteriusOmega](/AlteriusOmega) so how we can solve it then ?"
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "[@blandprix](/blandprix) Bro.. There is even problem with compiling when i try to do this simple case:\\nif(nums1[0]>nums2[nums2Size-1])"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "Make sure you are not using the assignment operator like \"nums1 = ...\" or anything like that because in most programming languages that will just create a new local variable that happens to have the same name, but will not be a reference to the same nums1 input. From then on in your function any time you modify nums1, it will be your local nums1, and so the real nums1 will be unaffected. Can\\'t use the global keyword in Python either since its an argument, not an actual global variable, though it does reference a global variable."
                    },
                    {
                        "username": "Susmita_Patra",
                        "content": "[@blandprix](/blandprix) Same problem"
                    },
                    {
                        "username": "blandprix",
                        "content": "Old question, but for others with the same issue: something like `nums1 = sortedArray` will not work because the variable in the calling scope will still reference the original array. You\\'ll have to mutate the existing array instead of trying to change the reference.\\nSome more detail [here](https://leetcode.com/problems/merge-sorted-array/description/comments/1968717)."
                    },
                    {
                        "username": "dev_kbujak",
                        "content": "Same here, it\\'s annoying!"
                    },
                    {
                        "username": "MoonHalo8088",
                        "content": "Same problem with you(\\u2565\\uFE4F\\u2565)"
                    },
                    {
                        "username": "osmanbaskok",
                        "content": "Yes, the same. It\\'s annoying!"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "yes brother same problem here"
                    },
                    {
                        "username": "mlafortune1223",
                        "content": "When I run console.log(nums1.filter(num => num !== 0).concat(nums2).sort((a,b) => a - b)) it shows [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut then when I remove the console log and just run the functions on num1, it says I\\'m outputting[1,2,3,0,0,0]\\n\\nWhat?"
                    },
                    {
                        "username": "vinjenks",
                        "content": "You can\\'t reassign a param as a whole, but you can reassign the individual array values. Maybe that\\'s an easier way of understanding it."
                    },
                    {
                        "username": "ballanibalaji",
                        "content": "[@TheHood02](/TheHood02)  when you assign a new value to a parameter within a function, it doesn\\'t affect the original variable outside the function. that is the problem\\nIn that case update is recommended instead of reassignment\\n"
                    },
                    {
                        "username": "TheHood02",
                        "content": "When you do a filter, the function returns a new array. It does not mutate the array you applied the filter function on."
                    },
                    {
                        "username": "zuborev_michael",
                        "content": "You don\\'t have to store your values in any buffer if you go backwards"
                    },
                    {
                        "username": "Harshal0409",
                        "content": "This hint is the only one required!"
                    },
                    {
                        "username": "firuz97",
                        "content": "your comment gave me a good hint after that i solved the task in O(n) time"
                    },
                    {
                        "username": "superplane",
                        "content": "I found that for corner case\\nnums1 = [1], m = 1;\\nnums2 = [0], n = 1.\\nThe result should be [0,1], but Leetcode gives [1].\\nDoes Leetcode go wrong here?"
                    },
                    {
                        "username": "agatekartik",
                        "content": "you\\'ll need nums1 to be of size 2 i.e. nums1 = [1,0] initially to satisfy all constraints"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "According to the ques, nums1 is of length (m+n) where m is no of elements to be inserted from nums1 and rest n elements \\'0\\' s  which are to be replaced by nums2 elements. So if m=1, nums1 should be [1,0] in which last \\'0\\' is replaced by nums2 element "
                    },
                    {
                        "username": "prathore28647",
                        "content": "In the given corner case, nums1 contains a single element of value 1, and nums2 contains a single element of value 0. According to the problem statement, the arrays are expected to be merged in non-decreasing order, which means the resulting array should be [0,1], with 0 preceding 1.\\n\\nIf LeetCode is returning [1] instead of [0,1], this would suggest that the solution is not correctly handling the given input, or that there is a mistake in the test cases.\\n\\nIt may be worth checking the solution code for any edge cases or boundary conditions that may not have been handled correctly. Additionally, you may want to try submitting a bug report to LeetCode to bring the issue to their attention."
                    },
                    {
                        "username": "LeetCode_AbdulRehman",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) for that case according to the problem, nums1 should be nums1 = [1, 0], m=1;\\nin order to accommodate the n=1 element of nums2,\\nseems leetcode was right we were not ..."
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\n\nnums1 = [0], m = 0,\n nums2 = [1], n = 1"
                    },
                    {
                        "username": "sl8517",
                        "content": "Apperently nums1 should be [1,0] instead of [1]."
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Please read the question carefully, it is clearly written that \"To accommodate this, nums1 has a length of m + n\". So therefore if nums2 have 1 element in it then nums1 should have minimum 1 element in it.\n"
                    },
                    {
                        "username": "muralivicky",
                        "content": "its not wanting 0\\'s in its nums1. That is also a condition given by leetcode to be considered by the solvers buddy."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well size of nums 1 is always m+n so according to your case if nums1.size is 1 --> m+n = 1 --> n=0 , and in that case ans would be 1 only."
                    },
                    {
                        "username": "gokutruns8",
                        "content": "i think 0 represents null value"
                    },
                    {
                        "username": "t_guzma",
                        "content": "\"non-decreasing order\", so increasing order? :D"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "[@gurlakshpreetKaur](/gurlakshpreetKaur) It\\'s kind of a pedantic term. Almost anyone when you ask them if sorting an Amazon search by increasing price might also include two items with the same price next to each-other, they would say yes. Increasing order includes numbers that are the same. It\\'s just needlessly obtuse wording"
                    },
                    {
                        "username": "akanksha1996",
                        "content": "Non decreasing order is when the numbers may or may not increase but they never deccrease for eg 1 2 2 3 3 4 5 6 6."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Not necessarily. If it is 9,9,10,11 then the 9s are equal, therefore no increase was made, hence the non-decreasing."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Merge and sort\n\n  \n**Approach 2:** Three Pointers (Start From the Beginning)\n\n  \n**Approach 3:** Three Pointers (Start From the End)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/3re-K02xQ_g?t=59"
                    },
                    {
                        "username": "alik",
                        "content": "Can it be done without creating a new merged array, meaning sorting using only B and A?"
                    },
                    {
                        "username": "azuregcp",
                        "content": "10 year old comment. Funny.\\nPeople replying with solutions. Hilarious."
                    },
                    {
                        "username": "janis__",
                        "content": "Yes it is possible."
                    },
                    {
                        "username": "dip_018",
                        "content": "[@stanislav888](/stanislav888) try by using logic of insertion sort"
                    },
                    {
                        "username": "stanislav888",
                        "content": "Sure, dude! Just merge vectors from highest values to lowest into the tail of  nums1. I.e. replacing tail nulls with merged(high) values."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 and JavaScript solution\\nThe easiest way is iterate n times then use function to sort?\\nCan we find out a faster solution? Sure !\\n\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/)\\u2B50**\\n\\n**All solution was written by myself, so all have been tested.**\\n![image](https://assets.leetcode.com/users/images/1b85cd5f-8f55-4cce-8aab-bc51e740c66b_1654587254.4308908.jpeg)\\n\\nFor example, here is the Java submission detail.\\n\\n\\n**See more problems solutions : [Zyrastory - More LeetCode Solutions with Explanation](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.\\n\\n**Thanks**\\uD83E\\uDDE1"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "Did you buy the domain name, How did you blog here, I am intrigued, :)"
                    },
                    {
                        "username": "TheKarateKid",
                        "content": "I have tried copying the contents of my sorted array to nums1 using both `nums1 = sortedArray.clone()` and even `nums1 = sortedArray;`\\n\\nThe debugger shows that nums1 has the correct sorted values at the end of the function, but LeetCode\\'s case tester is still giving a \"Wrong Answer\" and showing the original value of nums1 before the copy.\\n\\nAnyone have any advice? Is this an issue with the LeetCode tester?\\n\\n**Update:** Using `System.arraycopy()` fixed the issue, but I think the other ways of copying should still be correct."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "Isn\\'t it because the question says in-place?"
                    }
                ]
            },
            {
                "id": 1565020,
                "content": [
                    {
                        "username": "BigMangos",
                        "content": "> https://leetcode.com/problems/merge-sorted-array/discuss/29503/Beautiful-Python-Solution\\n> \\n\\nI make a flash to understand better.\\n![88.gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n[gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n"
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "i think there is a bug in this . it is taking nums1 as Output not the Stdout. [@LeetCode](/LeetCode)  please fix this issue."
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "I am running this code in my IntelliJ IDE and its giving the expected result but in this leetcode compiler its failing my case. is there any issue"
                    },
                    {
                        "username": "Nitya100",
                        "content": "How you did this kind of gif?"
                    },
                    {
                        "username": "suman_saini",
                        "content": "thanks"
                    },
                    {
                        "username": "Alterra",
                        "content": "I wouldn\\'t work for number smaller than 0\\n"
                    },
                    {
                        "username": "ajitt7381",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "aman1908",
                        "content": "It\\'s working in local system same test cases. so why it\\'s showing error in complier."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@AlteriusOmega](/AlteriusOmega) so how we can solve it then ?"
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "[@blandprix](/blandprix) Bro.. There is even problem with compiling when i try to do this simple case:\\nif(nums1[0]>nums2[nums2Size-1])"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "Make sure you are not using the assignment operator like \"nums1 = ...\" or anything like that because in most programming languages that will just create a new local variable that happens to have the same name, but will not be a reference to the same nums1 input. From then on in your function any time you modify nums1, it will be your local nums1, and so the real nums1 will be unaffected. Can\\'t use the global keyword in Python either since its an argument, not an actual global variable, though it does reference a global variable."
                    },
                    {
                        "username": "Susmita_Patra",
                        "content": "[@blandprix](/blandprix) Same problem"
                    },
                    {
                        "username": "blandprix",
                        "content": "Old question, but for others with the same issue: something like `nums1 = sortedArray` will not work because the variable in the calling scope will still reference the original array. You\\'ll have to mutate the existing array instead of trying to change the reference.\\nSome more detail [here](https://leetcode.com/problems/merge-sorted-array/description/comments/1968717)."
                    },
                    {
                        "username": "dev_kbujak",
                        "content": "Same here, it\\'s annoying!"
                    },
                    {
                        "username": "MoonHalo8088",
                        "content": "Same problem with you(\\u2565\\uFE4F\\u2565)"
                    },
                    {
                        "username": "osmanbaskok",
                        "content": "Yes, the same. It\\'s annoying!"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "yes brother same problem here"
                    },
                    {
                        "username": "mlafortune1223",
                        "content": "When I run console.log(nums1.filter(num => num !== 0).concat(nums2).sort((a,b) => a - b)) it shows [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut then when I remove the console log and just run the functions on num1, it says I\\'m outputting[1,2,3,0,0,0]\\n\\nWhat?"
                    },
                    {
                        "username": "vinjenks",
                        "content": "You can\\'t reassign a param as a whole, but you can reassign the individual array values. Maybe that\\'s an easier way of understanding it."
                    },
                    {
                        "username": "ballanibalaji",
                        "content": "[@TheHood02](/TheHood02)  when you assign a new value to a parameter within a function, it doesn\\'t affect the original variable outside the function. that is the problem\\nIn that case update is recommended instead of reassignment\\n"
                    },
                    {
                        "username": "TheHood02",
                        "content": "When you do a filter, the function returns a new array. It does not mutate the array you applied the filter function on."
                    },
                    {
                        "username": "zuborev_michael",
                        "content": "You don\\'t have to store your values in any buffer if you go backwards"
                    },
                    {
                        "username": "Harshal0409",
                        "content": "This hint is the only one required!"
                    },
                    {
                        "username": "firuz97",
                        "content": "your comment gave me a good hint after that i solved the task in O(n) time"
                    },
                    {
                        "username": "superplane",
                        "content": "I found that for corner case\\nnums1 = [1], m = 1;\\nnums2 = [0], n = 1.\\nThe result should be [0,1], but Leetcode gives [1].\\nDoes Leetcode go wrong here?"
                    },
                    {
                        "username": "agatekartik",
                        "content": "you\\'ll need nums1 to be of size 2 i.e. nums1 = [1,0] initially to satisfy all constraints"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "According to the ques, nums1 is of length (m+n) where m is no of elements to be inserted from nums1 and rest n elements \\'0\\' s  which are to be replaced by nums2 elements. So if m=1, nums1 should be [1,0] in which last \\'0\\' is replaced by nums2 element "
                    },
                    {
                        "username": "prathore28647",
                        "content": "In the given corner case, nums1 contains a single element of value 1, and nums2 contains a single element of value 0. According to the problem statement, the arrays are expected to be merged in non-decreasing order, which means the resulting array should be [0,1], with 0 preceding 1.\\n\\nIf LeetCode is returning [1] instead of [0,1], this would suggest that the solution is not correctly handling the given input, or that there is a mistake in the test cases.\\n\\nIt may be worth checking the solution code for any edge cases or boundary conditions that may not have been handled correctly. Additionally, you may want to try submitting a bug report to LeetCode to bring the issue to their attention."
                    },
                    {
                        "username": "LeetCode_AbdulRehman",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) for that case according to the problem, nums1 should be nums1 = [1, 0], m=1;\\nin order to accommodate the n=1 element of nums2,\\nseems leetcode was right we were not ..."
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\n\nnums1 = [0], m = 0,\n nums2 = [1], n = 1"
                    },
                    {
                        "username": "sl8517",
                        "content": "Apperently nums1 should be [1,0] instead of [1]."
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Please read the question carefully, it is clearly written that \"To accommodate this, nums1 has a length of m + n\". So therefore if nums2 have 1 element in it then nums1 should have minimum 1 element in it.\n"
                    },
                    {
                        "username": "muralivicky",
                        "content": "its not wanting 0\\'s in its nums1. That is also a condition given by leetcode to be considered by the solvers buddy."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well size of nums 1 is always m+n so according to your case if nums1.size is 1 --> m+n = 1 --> n=0 , and in that case ans would be 1 only."
                    },
                    {
                        "username": "gokutruns8",
                        "content": "i think 0 represents null value"
                    },
                    {
                        "username": "t_guzma",
                        "content": "\"non-decreasing order\", so increasing order? :D"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "[@gurlakshpreetKaur](/gurlakshpreetKaur) It\\'s kind of a pedantic term. Almost anyone when you ask them if sorting an Amazon search by increasing price might also include two items with the same price next to each-other, they would say yes. Increasing order includes numbers that are the same. It\\'s just needlessly obtuse wording"
                    },
                    {
                        "username": "akanksha1996",
                        "content": "Non decreasing order is when the numbers may or may not increase but they never deccrease for eg 1 2 2 3 3 4 5 6 6."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Not necessarily. If it is 9,9,10,11 then the 9s are equal, therefore no increase was made, hence the non-decreasing."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Merge and sort\n\n  \n**Approach 2:** Three Pointers (Start From the Beginning)\n\n  \n**Approach 3:** Three Pointers (Start From the End)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/3re-K02xQ_g?t=59"
                    },
                    {
                        "username": "alik",
                        "content": "Can it be done without creating a new merged array, meaning sorting using only B and A?"
                    },
                    {
                        "username": "azuregcp",
                        "content": "10 year old comment. Funny.\\nPeople replying with solutions. Hilarious."
                    },
                    {
                        "username": "janis__",
                        "content": "Yes it is possible."
                    },
                    {
                        "username": "dip_018",
                        "content": "[@stanislav888](/stanislav888) try by using logic of insertion sort"
                    },
                    {
                        "username": "stanislav888",
                        "content": "Sure, dude! Just merge vectors from highest values to lowest into the tail of  nums1. I.e. replacing tail nulls with merged(high) values."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 and JavaScript solution\\nThe easiest way is iterate n times then use function to sort?\\nCan we find out a faster solution? Sure !\\n\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/)\\u2B50**\\n\\n**All solution was written by myself, so all have been tested.**\\n![image](https://assets.leetcode.com/users/images/1b85cd5f-8f55-4cce-8aab-bc51e740c66b_1654587254.4308908.jpeg)\\n\\nFor example, here is the Java submission detail.\\n\\n\\n**See more problems solutions : [Zyrastory - More LeetCode Solutions with Explanation](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.\\n\\n**Thanks**\\uD83E\\uDDE1"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "Did you buy the domain name, How did you blog here, I am intrigued, :)"
                    },
                    {
                        "username": "TheKarateKid",
                        "content": "I have tried copying the contents of my sorted array to nums1 using both `nums1 = sortedArray.clone()` and even `nums1 = sortedArray;`\\n\\nThe debugger shows that nums1 has the correct sorted values at the end of the function, but LeetCode\\'s case tester is still giving a \"Wrong Answer\" and showing the original value of nums1 before the copy.\\n\\nAnyone have any advice? Is this an issue with the LeetCode tester?\\n\\n**Update:** Using `System.arraycopy()` fixed the issue, but I think the other ways of copying should still be correct."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "Isn\\'t it because the question says in-place?"
                    }
                ]
            },
            {
                "id": 1894027,
                "content": [
                    {
                        "username": "BigMangos",
                        "content": "> https://leetcode.com/problems/merge-sorted-array/discuss/29503/Beautiful-Python-Solution\\n> \\n\\nI make a flash to understand better.\\n![88.gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n[gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n"
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "i think there is a bug in this . it is taking nums1 as Output not the Stdout. [@LeetCode](/LeetCode)  please fix this issue."
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "I am running this code in my IntelliJ IDE and its giving the expected result but in this leetcode compiler its failing my case. is there any issue"
                    },
                    {
                        "username": "Nitya100",
                        "content": "How you did this kind of gif?"
                    },
                    {
                        "username": "suman_saini",
                        "content": "thanks"
                    },
                    {
                        "username": "Alterra",
                        "content": "I wouldn\\'t work for number smaller than 0\\n"
                    },
                    {
                        "username": "ajitt7381",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "aman1908",
                        "content": "It\\'s working in local system same test cases. so why it\\'s showing error in complier."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@AlteriusOmega](/AlteriusOmega) so how we can solve it then ?"
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "[@blandprix](/blandprix) Bro.. There is even problem with compiling when i try to do this simple case:\\nif(nums1[0]>nums2[nums2Size-1])"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "Make sure you are not using the assignment operator like \"nums1 = ...\" or anything like that because in most programming languages that will just create a new local variable that happens to have the same name, but will not be a reference to the same nums1 input. From then on in your function any time you modify nums1, it will be your local nums1, and so the real nums1 will be unaffected. Can\\'t use the global keyword in Python either since its an argument, not an actual global variable, though it does reference a global variable."
                    },
                    {
                        "username": "Susmita_Patra",
                        "content": "[@blandprix](/blandprix) Same problem"
                    },
                    {
                        "username": "blandprix",
                        "content": "Old question, but for others with the same issue: something like `nums1 = sortedArray` will not work because the variable in the calling scope will still reference the original array. You\\'ll have to mutate the existing array instead of trying to change the reference.\\nSome more detail [here](https://leetcode.com/problems/merge-sorted-array/description/comments/1968717)."
                    },
                    {
                        "username": "dev_kbujak",
                        "content": "Same here, it\\'s annoying!"
                    },
                    {
                        "username": "MoonHalo8088",
                        "content": "Same problem with you(\\u2565\\uFE4F\\u2565)"
                    },
                    {
                        "username": "osmanbaskok",
                        "content": "Yes, the same. It\\'s annoying!"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "yes brother same problem here"
                    },
                    {
                        "username": "mlafortune1223",
                        "content": "When I run console.log(nums1.filter(num => num !== 0).concat(nums2).sort((a,b) => a - b)) it shows [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut then when I remove the console log and just run the functions on num1, it says I\\'m outputting[1,2,3,0,0,0]\\n\\nWhat?"
                    },
                    {
                        "username": "vinjenks",
                        "content": "You can\\'t reassign a param as a whole, but you can reassign the individual array values. Maybe that\\'s an easier way of understanding it."
                    },
                    {
                        "username": "ballanibalaji",
                        "content": "[@TheHood02](/TheHood02)  when you assign a new value to a parameter within a function, it doesn\\'t affect the original variable outside the function. that is the problem\\nIn that case update is recommended instead of reassignment\\n"
                    },
                    {
                        "username": "TheHood02",
                        "content": "When you do a filter, the function returns a new array. It does not mutate the array you applied the filter function on."
                    },
                    {
                        "username": "zuborev_michael",
                        "content": "You don\\'t have to store your values in any buffer if you go backwards"
                    },
                    {
                        "username": "Harshal0409",
                        "content": "This hint is the only one required!"
                    },
                    {
                        "username": "firuz97",
                        "content": "your comment gave me a good hint after that i solved the task in O(n) time"
                    },
                    {
                        "username": "superplane",
                        "content": "I found that for corner case\\nnums1 = [1], m = 1;\\nnums2 = [0], n = 1.\\nThe result should be [0,1], but Leetcode gives [1].\\nDoes Leetcode go wrong here?"
                    },
                    {
                        "username": "agatekartik",
                        "content": "you\\'ll need nums1 to be of size 2 i.e. nums1 = [1,0] initially to satisfy all constraints"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "According to the ques, nums1 is of length (m+n) where m is no of elements to be inserted from nums1 and rest n elements \\'0\\' s  which are to be replaced by nums2 elements. So if m=1, nums1 should be [1,0] in which last \\'0\\' is replaced by nums2 element "
                    },
                    {
                        "username": "prathore28647",
                        "content": "In the given corner case, nums1 contains a single element of value 1, and nums2 contains a single element of value 0. According to the problem statement, the arrays are expected to be merged in non-decreasing order, which means the resulting array should be [0,1], with 0 preceding 1.\\n\\nIf LeetCode is returning [1] instead of [0,1], this would suggest that the solution is not correctly handling the given input, or that there is a mistake in the test cases.\\n\\nIt may be worth checking the solution code for any edge cases or boundary conditions that may not have been handled correctly. Additionally, you may want to try submitting a bug report to LeetCode to bring the issue to their attention."
                    },
                    {
                        "username": "LeetCode_AbdulRehman",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) for that case according to the problem, nums1 should be nums1 = [1, 0], m=1;\\nin order to accommodate the n=1 element of nums2,\\nseems leetcode was right we were not ..."
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\n\nnums1 = [0], m = 0,\n nums2 = [1], n = 1"
                    },
                    {
                        "username": "sl8517",
                        "content": "Apperently nums1 should be [1,0] instead of [1]."
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Please read the question carefully, it is clearly written that \"To accommodate this, nums1 has a length of m + n\". So therefore if nums2 have 1 element in it then nums1 should have minimum 1 element in it.\n"
                    },
                    {
                        "username": "muralivicky",
                        "content": "its not wanting 0\\'s in its nums1. That is also a condition given by leetcode to be considered by the solvers buddy."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well size of nums 1 is always m+n so according to your case if nums1.size is 1 --> m+n = 1 --> n=0 , and in that case ans would be 1 only."
                    },
                    {
                        "username": "gokutruns8",
                        "content": "i think 0 represents null value"
                    },
                    {
                        "username": "t_guzma",
                        "content": "\"non-decreasing order\", so increasing order? :D"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "[@gurlakshpreetKaur](/gurlakshpreetKaur) It\\'s kind of a pedantic term. Almost anyone when you ask them if sorting an Amazon search by increasing price might also include two items with the same price next to each-other, they would say yes. Increasing order includes numbers that are the same. It\\'s just needlessly obtuse wording"
                    },
                    {
                        "username": "akanksha1996",
                        "content": "Non decreasing order is when the numbers may or may not increase but they never deccrease for eg 1 2 2 3 3 4 5 6 6."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Not necessarily. If it is 9,9,10,11 then the 9s are equal, therefore no increase was made, hence the non-decreasing."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Merge and sort\n\n  \n**Approach 2:** Three Pointers (Start From the Beginning)\n\n  \n**Approach 3:** Three Pointers (Start From the End)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/3re-K02xQ_g?t=59"
                    },
                    {
                        "username": "alik",
                        "content": "Can it be done without creating a new merged array, meaning sorting using only B and A?"
                    },
                    {
                        "username": "azuregcp",
                        "content": "10 year old comment. Funny.\\nPeople replying with solutions. Hilarious."
                    },
                    {
                        "username": "janis__",
                        "content": "Yes it is possible."
                    },
                    {
                        "username": "dip_018",
                        "content": "[@stanislav888](/stanislav888) try by using logic of insertion sort"
                    },
                    {
                        "username": "stanislav888",
                        "content": "Sure, dude! Just merge vectors from highest values to lowest into the tail of  nums1. I.e. replacing tail nulls with merged(high) values."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 and JavaScript solution\\nThe easiest way is iterate n times then use function to sort?\\nCan we find out a faster solution? Sure !\\n\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/)\\u2B50**\\n\\n**All solution was written by myself, so all have been tested.**\\n![image](https://assets.leetcode.com/users/images/1b85cd5f-8f55-4cce-8aab-bc51e740c66b_1654587254.4308908.jpeg)\\n\\nFor example, here is the Java submission detail.\\n\\n\\n**See more problems solutions : [Zyrastory - More LeetCode Solutions with Explanation](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.\\n\\n**Thanks**\\uD83E\\uDDE1"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "Did you buy the domain name, How did you blog here, I am intrigued, :)"
                    },
                    {
                        "username": "TheKarateKid",
                        "content": "I have tried copying the contents of my sorted array to nums1 using both `nums1 = sortedArray.clone()` and even `nums1 = sortedArray;`\\n\\nThe debugger shows that nums1 has the correct sorted values at the end of the function, but LeetCode\\'s case tester is still giving a \"Wrong Answer\" and showing the original value of nums1 before the copy.\\n\\nAnyone have any advice? Is this an issue with the LeetCode tester?\\n\\n**Update:** Using `System.arraycopy()` fixed the issue, but I think the other ways of copying should still be correct."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "Isn\\'t it because the question says in-place?"
                    }
                ]
            },
            {
                "id": 1565819,
                "content": [
                    {
                        "username": "BigMangos",
                        "content": "> https://leetcode.com/problems/merge-sorted-array/discuss/29503/Beautiful-Python-Solution\\n> \\n\\nI make a flash to understand better.\\n![88.gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n[gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n"
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "i think there is a bug in this . it is taking nums1 as Output not the Stdout. [@LeetCode](/LeetCode)  please fix this issue."
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "I am running this code in my IntelliJ IDE and its giving the expected result but in this leetcode compiler its failing my case. is there any issue"
                    },
                    {
                        "username": "Nitya100",
                        "content": "How you did this kind of gif?"
                    },
                    {
                        "username": "suman_saini",
                        "content": "thanks"
                    },
                    {
                        "username": "Alterra",
                        "content": "I wouldn\\'t work for number smaller than 0\\n"
                    },
                    {
                        "username": "ajitt7381",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "aman1908",
                        "content": "It\\'s working in local system same test cases. so why it\\'s showing error in complier."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@AlteriusOmega](/AlteriusOmega) so how we can solve it then ?"
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "[@blandprix](/blandprix) Bro.. There is even problem with compiling when i try to do this simple case:\\nif(nums1[0]>nums2[nums2Size-1])"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "Make sure you are not using the assignment operator like \"nums1 = ...\" or anything like that because in most programming languages that will just create a new local variable that happens to have the same name, but will not be a reference to the same nums1 input. From then on in your function any time you modify nums1, it will be your local nums1, and so the real nums1 will be unaffected. Can\\'t use the global keyword in Python either since its an argument, not an actual global variable, though it does reference a global variable."
                    },
                    {
                        "username": "Susmita_Patra",
                        "content": "[@blandprix](/blandprix) Same problem"
                    },
                    {
                        "username": "blandprix",
                        "content": "Old question, but for others with the same issue: something like `nums1 = sortedArray` will not work because the variable in the calling scope will still reference the original array. You\\'ll have to mutate the existing array instead of trying to change the reference.\\nSome more detail [here](https://leetcode.com/problems/merge-sorted-array/description/comments/1968717)."
                    },
                    {
                        "username": "dev_kbujak",
                        "content": "Same here, it\\'s annoying!"
                    },
                    {
                        "username": "MoonHalo8088",
                        "content": "Same problem with you(\\u2565\\uFE4F\\u2565)"
                    },
                    {
                        "username": "osmanbaskok",
                        "content": "Yes, the same. It\\'s annoying!"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "yes brother same problem here"
                    },
                    {
                        "username": "mlafortune1223",
                        "content": "When I run console.log(nums1.filter(num => num !== 0).concat(nums2).sort((a,b) => a - b)) it shows [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut then when I remove the console log and just run the functions on num1, it says I\\'m outputting[1,2,3,0,0,0]\\n\\nWhat?"
                    },
                    {
                        "username": "vinjenks",
                        "content": "You can\\'t reassign a param as a whole, but you can reassign the individual array values. Maybe that\\'s an easier way of understanding it."
                    },
                    {
                        "username": "ballanibalaji",
                        "content": "[@TheHood02](/TheHood02)  when you assign a new value to a parameter within a function, it doesn\\'t affect the original variable outside the function. that is the problem\\nIn that case update is recommended instead of reassignment\\n"
                    },
                    {
                        "username": "TheHood02",
                        "content": "When you do a filter, the function returns a new array. It does not mutate the array you applied the filter function on."
                    },
                    {
                        "username": "zuborev_michael",
                        "content": "You don\\'t have to store your values in any buffer if you go backwards"
                    },
                    {
                        "username": "Harshal0409",
                        "content": "This hint is the only one required!"
                    },
                    {
                        "username": "firuz97",
                        "content": "your comment gave me a good hint after that i solved the task in O(n) time"
                    },
                    {
                        "username": "superplane",
                        "content": "I found that for corner case\\nnums1 = [1], m = 1;\\nnums2 = [0], n = 1.\\nThe result should be [0,1], but Leetcode gives [1].\\nDoes Leetcode go wrong here?"
                    },
                    {
                        "username": "agatekartik",
                        "content": "you\\'ll need nums1 to be of size 2 i.e. nums1 = [1,0] initially to satisfy all constraints"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "According to the ques, nums1 is of length (m+n) where m is no of elements to be inserted from nums1 and rest n elements \\'0\\' s  which are to be replaced by nums2 elements. So if m=1, nums1 should be [1,0] in which last \\'0\\' is replaced by nums2 element "
                    },
                    {
                        "username": "prathore28647",
                        "content": "In the given corner case, nums1 contains a single element of value 1, and nums2 contains a single element of value 0. According to the problem statement, the arrays are expected to be merged in non-decreasing order, which means the resulting array should be [0,1], with 0 preceding 1.\\n\\nIf LeetCode is returning [1] instead of [0,1], this would suggest that the solution is not correctly handling the given input, or that there is a mistake in the test cases.\\n\\nIt may be worth checking the solution code for any edge cases or boundary conditions that may not have been handled correctly. Additionally, you may want to try submitting a bug report to LeetCode to bring the issue to their attention."
                    },
                    {
                        "username": "LeetCode_AbdulRehman",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) for that case according to the problem, nums1 should be nums1 = [1, 0], m=1;\\nin order to accommodate the n=1 element of nums2,\\nseems leetcode was right we were not ..."
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\n\nnums1 = [0], m = 0,\n nums2 = [1], n = 1"
                    },
                    {
                        "username": "sl8517",
                        "content": "Apperently nums1 should be [1,0] instead of [1]."
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Please read the question carefully, it is clearly written that \"To accommodate this, nums1 has a length of m + n\". So therefore if nums2 have 1 element in it then nums1 should have minimum 1 element in it.\n"
                    },
                    {
                        "username": "muralivicky",
                        "content": "its not wanting 0\\'s in its nums1. That is also a condition given by leetcode to be considered by the solvers buddy."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well size of nums 1 is always m+n so according to your case if nums1.size is 1 --> m+n = 1 --> n=0 , and in that case ans would be 1 only."
                    },
                    {
                        "username": "gokutruns8",
                        "content": "i think 0 represents null value"
                    },
                    {
                        "username": "t_guzma",
                        "content": "\"non-decreasing order\", so increasing order? :D"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "[@gurlakshpreetKaur](/gurlakshpreetKaur) It\\'s kind of a pedantic term. Almost anyone when you ask them if sorting an Amazon search by increasing price might also include two items with the same price next to each-other, they would say yes. Increasing order includes numbers that are the same. It\\'s just needlessly obtuse wording"
                    },
                    {
                        "username": "akanksha1996",
                        "content": "Non decreasing order is when the numbers may or may not increase but they never deccrease for eg 1 2 2 3 3 4 5 6 6."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Not necessarily. If it is 9,9,10,11 then the 9s are equal, therefore no increase was made, hence the non-decreasing."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Merge and sort\n\n  \n**Approach 2:** Three Pointers (Start From the Beginning)\n\n  \n**Approach 3:** Three Pointers (Start From the End)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/3re-K02xQ_g?t=59"
                    },
                    {
                        "username": "alik",
                        "content": "Can it be done without creating a new merged array, meaning sorting using only B and A?"
                    },
                    {
                        "username": "azuregcp",
                        "content": "10 year old comment. Funny.\\nPeople replying with solutions. Hilarious."
                    },
                    {
                        "username": "janis__",
                        "content": "Yes it is possible."
                    },
                    {
                        "username": "dip_018",
                        "content": "[@stanislav888](/stanislav888) try by using logic of insertion sort"
                    },
                    {
                        "username": "stanislav888",
                        "content": "Sure, dude! Just merge vectors from highest values to lowest into the tail of  nums1. I.e. replacing tail nulls with merged(high) values."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 and JavaScript solution\\nThe easiest way is iterate n times then use function to sort?\\nCan we find out a faster solution? Sure !\\n\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/)\\u2B50**\\n\\n**All solution was written by myself, so all have been tested.**\\n![image](https://assets.leetcode.com/users/images/1b85cd5f-8f55-4cce-8aab-bc51e740c66b_1654587254.4308908.jpeg)\\n\\nFor example, here is the Java submission detail.\\n\\n\\n**See more problems solutions : [Zyrastory - More LeetCode Solutions with Explanation](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.\\n\\n**Thanks**\\uD83E\\uDDE1"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "Did you buy the domain name, How did you blog here, I am intrigued, :)"
                    },
                    {
                        "username": "TheKarateKid",
                        "content": "I have tried copying the contents of my sorted array to nums1 using both `nums1 = sortedArray.clone()` and even `nums1 = sortedArray;`\\n\\nThe debugger shows that nums1 has the correct sorted values at the end of the function, but LeetCode\\'s case tester is still giving a \"Wrong Answer\" and showing the original value of nums1 before the copy.\\n\\nAnyone have any advice? Is this an issue with the LeetCode tester?\\n\\n**Update:** Using `System.arraycopy()` fixed the issue, but I think the other ways of copying should still be correct."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "Isn\\'t it because the question says in-place?"
                    }
                ]
            },
            {
                "id": 1567848,
                "content": [
                    {
                        "username": "BigMangos",
                        "content": "> https://leetcode.com/problems/merge-sorted-array/discuss/29503/Beautiful-Python-Solution\\n> \\n\\nI make a flash to understand better.\\n![88.gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n[gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n"
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "i think there is a bug in this . it is taking nums1 as Output not the Stdout. [@LeetCode](/LeetCode)  please fix this issue."
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "I am running this code in my IntelliJ IDE and its giving the expected result but in this leetcode compiler its failing my case. is there any issue"
                    },
                    {
                        "username": "Nitya100",
                        "content": "How you did this kind of gif?"
                    },
                    {
                        "username": "suman_saini",
                        "content": "thanks"
                    },
                    {
                        "username": "Alterra",
                        "content": "I wouldn\\'t work for number smaller than 0\\n"
                    },
                    {
                        "username": "ajitt7381",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "aman1908",
                        "content": "It\\'s working in local system same test cases. so why it\\'s showing error in complier."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@AlteriusOmega](/AlteriusOmega) so how we can solve it then ?"
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "[@blandprix](/blandprix) Bro.. There is even problem with compiling when i try to do this simple case:\\nif(nums1[0]>nums2[nums2Size-1])"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "Make sure you are not using the assignment operator like \"nums1 = ...\" or anything like that because in most programming languages that will just create a new local variable that happens to have the same name, but will not be a reference to the same nums1 input. From then on in your function any time you modify nums1, it will be your local nums1, and so the real nums1 will be unaffected. Can\\'t use the global keyword in Python either since its an argument, not an actual global variable, though it does reference a global variable."
                    },
                    {
                        "username": "Susmita_Patra",
                        "content": "[@blandprix](/blandprix) Same problem"
                    },
                    {
                        "username": "blandprix",
                        "content": "Old question, but for others with the same issue: something like `nums1 = sortedArray` will not work because the variable in the calling scope will still reference the original array. You\\'ll have to mutate the existing array instead of trying to change the reference.\\nSome more detail [here](https://leetcode.com/problems/merge-sorted-array/description/comments/1968717)."
                    },
                    {
                        "username": "dev_kbujak",
                        "content": "Same here, it\\'s annoying!"
                    },
                    {
                        "username": "MoonHalo8088",
                        "content": "Same problem with you(\\u2565\\uFE4F\\u2565)"
                    },
                    {
                        "username": "osmanbaskok",
                        "content": "Yes, the same. It\\'s annoying!"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "yes brother same problem here"
                    },
                    {
                        "username": "mlafortune1223",
                        "content": "When I run console.log(nums1.filter(num => num !== 0).concat(nums2).sort((a,b) => a - b)) it shows [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut then when I remove the console log and just run the functions on num1, it says I\\'m outputting[1,2,3,0,0,0]\\n\\nWhat?"
                    },
                    {
                        "username": "vinjenks",
                        "content": "You can\\'t reassign a param as a whole, but you can reassign the individual array values. Maybe that\\'s an easier way of understanding it."
                    },
                    {
                        "username": "ballanibalaji",
                        "content": "[@TheHood02](/TheHood02)  when you assign a new value to a parameter within a function, it doesn\\'t affect the original variable outside the function. that is the problem\\nIn that case update is recommended instead of reassignment\\n"
                    },
                    {
                        "username": "TheHood02",
                        "content": "When you do a filter, the function returns a new array. It does not mutate the array you applied the filter function on."
                    },
                    {
                        "username": "zuborev_michael",
                        "content": "You don\\'t have to store your values in any buffer if you go backwards"
                    },
                    {
                        "username": "Harshal0409",
                        "content": "This hint is the only one required!"
                    },
                    {
                        "username": "firuz97",
                        "content": "your comment gave me a good hint after that i solved the task in O(n) time"
                    },
                    {
                        "username": "superplane",
                        "content": "I found that for corner case\\nnums1 = [1], m = 1;\\nnums2 = [0], n = 1.\\nThe result should be [0,1], but Leetcode gives [1].\\nDoes Leetcode go wrong here?"
                    },
                    {
                        "username": "agatekartik",
                        "content": "you\\'ll need nums1 to be of size 2 i.e. nums1 = [1,0] initially to satisfy all constraints"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "According to the ques, nums1 is of length (m+n) where m is no of elements to be inserted from nums1 and rest n elements \\'0\\' s  which are to be replaced by nums2 elements. So if m=1, nums1 should be [1,0] in which last \\'0\\' is replaced by nums2 element "
                    },
                    {
                        "username": "prathore28647",
                        "content": "In the given corner case, nums1 contains a single element of value 1, and nums2 contains a single element of value 0. According to the problem statement, the arrays are expected to be merged in non-decreasing order, which means the resulting array should be [0,1], with 0 preceding 1.\\n\\nIf LeetCode is returning [1] instead of [0,1], this would suggest that the solution is not correctly handling the given input, or that there is a mistake in the test cases.\\n\\nIt may be worth checking the solution code for any edge cases or boundary conditions that may not have been handled correctly. Additionally, you may want to try submitting a bug report to LeetCode to bring the issue to their attention."
                    },
                    {
                        "username": "LeetCode_AbdulRehman",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) for that case according to the problem, nums1 should be nums1 = [1, 0], m=1;\\nin order to accommodate the n=1 element of nums2,\\nseems leetcode was right we were not ..."
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\n\nnums1 = [0], m = 0,\n nums2 = [1], n = 1"
                    },
                    {
                        "username": "sl8517",
                        "content": "Apperently nums1 should be [1,0] instead of [1]."
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Please read the question carefully, it is clearly written that \"To accommodate this, nums1 has a length of m + n\". So therefore if nums2 have 1 element in it then nums1 should have minimum 1 element in it.\n"
                    },
                    {
                        "username": "muralivicky",
                        "content": "its not wanting 0\\'s in its nums1. That is also a condition given by leetcode to be considered by the solvers buddy."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well size of nums 1 is always m+n so according to your case if nums1.size is 1 --> m+n = 1 --> n=0 , and in that case ans would be 1 only."
                    },
                    {
                        "username": "gokutruns8",
                        "content": "i think 0 represents null value"
                    },
                    {
                        "username": "t_guzma",
                        "content": "\"non-decreasing order\", so increasing order? :D"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "[@gurlakshpreetKaur](/gurlakshpreetKaur) It\\'s kind of a pedantic term. Almost anyone when you ask them if sorting an Amazon search by increasing price might also include two items with the same price next to each-other, they would say yes. Increasing order includes numbers that are the same. It\\'s just needlessly obtuse wording"
                    },
                    {
                        "username": "akanksha1996",
                        "content": "Non decreasing order is when the numbers may or may not increase but they never deccrease for eg 1 2 2 3 3 4 5 6 6."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Not necessarily. If it is 9,9,10,11 then the 9s are equal, therefore no increase was made, hence the non-decreasing."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Merge and sort\n\n  \n**Approach 2:** Three Pointers (Start From the Beginning)\n\n  \n**Approach 3:** Three Pointers (Start From the End)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/3re-K02xQ_g?t=59"
                    },
                    {
                        "username": "alik",
                        "content": "Can it be done without creating a new merged array, meaning sorting using only B and A?"
                    },
                    {
                        "username": "azuregcp",
                        "content": "10 year old comment. Funny.\\nPeople replying with solutions. Hilarious."
                    },
                    {
                        "username": "janis__",
                        "content": "Yes it is possible."
                    },
                    {
                        "username": "dip_018",
                        "content": "[@stanislav888](/stanislav888) try by using logic of insertion sort"
                    },
                    {
                        "username": "stanislav888",
                        "content": "Sure, dude! Just merge vectors from highest values to lowest into the tail of  nums1. I.e. replacing tail nulls with merged(high) values."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 and JavaScript solution\\nThe easiest way is iterate n times then use function to sort?\\nCan we find out a faster solution? Sure !\\n\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/)\\u2B50**\\n\\n**All solution was written by myself, so all have been tested.**\\n![image](https://assets.leetcode.com/users/images/1b85cd5f-8f55-4cce-8aab-bc51e740c66b_1654587254.4308908.jpeg)\\n\\nFor example, here is the Java submission detail.\\n\\n\\n**See more problems solutions : [Zyrastory - More LeetCode Solutions with Explanation](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.\\n\\n**Thanks**\\uD83E\\uDDE1"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "Did you buy the domain name, How did you blog here, I am intrigued, :)"
                    },
                    {
                        "username": "TheKarateKid",
                        "content": "I have tried copying the contents of my sorted array to nums1 using both `nums1 = sortedArray.clone()` and even `nums1 = sortedArray;`\\n\\nThe debugger shows that nums1 has the correct sorted values at the end of the function, but LeetCode\\'s case tester is still giving a \"Wrong Answer\" and showing the original value of nums1 before the copy.\\n\\nAnyone have any advice? Is this an issue with the LeetCode tester?\\n\\n**Update:** Using `System.arraycopy()` fixed the issue, but I think the other ways of copying should still be correct."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "Isn\\'t it because the question says in-place?"
                    }
                ]
            },
            {
                "id": 1566227,
                "content": [
                    {
                        "username": "BigMangos",
                        "content": "> https://leetcode.com/problems/merge-sorted-array/discuss/29503/Beautiful-Python-Solution\\n> \\n\\nI make a flash to understand better.\\n![88.gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n[gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n"
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "i think there is a bug in this . it is taking nums1 as Output not the Stdout. [@LeetCode](/LeetCode)  please fix this issue."
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "I am running this code in my IntelliJ IDE and its giving the expected result but in this leetcode compiler its failing my case. is there any issue"
                    },
                    {
                        "username": "Nitya100",
                        "content": "How you did this kind of gif?"
                    },
                    {
                        "username": "suman_saini",
                        "content": "thanks"
                    },
                    {
                        "username": "Alterra",
                        "content": "I wouldn\\'t work for number smaller than 0\\n"
                    },
                    {
                        "username": "ajitt7381",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "aman1908",
                        "content": "It\\'s working in local system same test cases. so why it\\'s showing error in complier."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@AlteriusOmega](/AlteriusOmega) so how we can solve it then ?"
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "[@blandprix](/blandprix) Bro.. There is even problem with compiling when i try to do this simple case:\\nif(nums1[0]>nums2[nums2Size-1])"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "Make sure you are not using the assignment operator like \"nums1 = ...\" or anything like that because in most programming languages that will just create a new local variable that happens to have the same name, but will not be a reference to the same nums1 input. From then on in your function any time you modify nums1, it will be your local nums1, and so the real nums1 will be unaffected. Can\\'t use the global keyword in Python either since its an argument, not an actual global variable, though it does reference a global variable."
                    },
                    {
                        "username": "Susmita_Patra",
                        "content": "[@blandprix](/blandprix) Same problem"
                    },
                    {
                        "username": "blandprix",
                        "content": "Old question, but for others with the same issue: something like `nums1 = sortedArray` will not work because the variable in the calling scope will still reference the original array. You\\'ll have to mutate the existing array instead of trying to change the reference.\\nSome more detail [here](https://leetcode.com/problems/merge-sorted-array/description/comments/1968717)."
                    },
                    {
                        "username": "dev_kbujak",
                        "content": "Same here, it\\'s annoying!"
                    },
                    {
                        "username": "MoonHalo8088",
                        "content": "Same problem with you(\\u2565\\uFE4F\\u2565)"
                    },
                    {
                        "username": "osmanbaskok",
                        "content": "Yes, the same. It\\'s annoying!"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "yes brother same problem here"
                    },
                    {
                        "username": "mlafortune1223",
                        "content": "When I run console.log(nums1.filter(num => num !== 0).concat(nums2).sort((a,b) => a - b)) it shows [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut then when I remove the console log and just run the functions on num1, it says I\\'m outputting[1,2,3,0,0,0]\\n\\nWhat?"
                    },
                    {
                        "username": "vinjenks",
                        "content": "You can\\'t reassign a param as a whole, but you can reassign the individual array values. Maybe that\\'s an easier way of understanding it."
                    },
                    {
                        "username": "ballanibalaji",
                        "content": "[@TheHood02](/TheHood02)  when you assign a new value to a parameter within a function, it doesn\\'t affect the original variable outside the function. that is the problem\\nIn that case update is recommended instead of reassignment\\n"
                    },
                    {
                        "username": "TheHood02",
                        "content": "When you do a filter, the function returns a new array. It does not mutate the array you applied the filter function on."
                    },
                    {
                        "username": "zuborev_michael",
                        "content": "You don\\'t have to store your values in any buffer if you go backwards"
                    },
                    {
                        "username": "Harshal0409",
                        "content": "This hint is the only one required!"
                    },
                    {
                        "username": "firuz97",
                        "content": "your comment gave me a good hint after that i solved the task in O(n) time"
                    },
                    {
                        "username": "superplane",
                        "content": "I found that for corner case\\nnums1 = [1], m = 1;\\nnums2 = [0], n = 1.\\nThe result should be [0,1], but Leetcode gives [1].\\nDoes Leetcode go wrong here?"
                    },
                    {
                        "username": "agatekartik",
                        "content": "you\\'ll need nums1 to be of size 2 i.e. nums1 = [1,0] initially to satisfy all constraints"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "According to the ques, nums1 is of length (m+n) where m is no of elements to be inserted from nums1 and rest n elements \\'0\\' s  which are to be replaced by nums2 elements. So if m=1, nums1 should be [1,0] in which last \\'0\\' is replaced by nums2 element "
                    },
                    {
                        "username": "prathore28647",
                        "content": "In the given corner case, nums1 contains a single element of value 1, and nums2 contains a single element of value 0. According to the problem statement, the arrays are expected to be merged in non-decreasing order, which means the resulting array should be [0,1], with 0 preceding 1.\\n\\nIf LeetCode is returning [1] instead of [0,1], this would suggest that the solution is not correctly handling the given input, or that there is a mistake in the test cases.\\n\\nIt may be worth checking the solution code for any edge cases or boundary conditions that may not have been handled correctly. Additionally, you may want to try submitting a bug report to LeetCode to bring the issue to their attention."
                    },
                    {
                        "username": "LeetCode_AbdulRehman",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) for that case according to the problem, nums1 should be nums1 = [1, 0], m=1;\\nin order to accommodate the n=1 element of nums2,\\nseems leetcode was right we were not ..."
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\n\nnums1 = [0], m = 0,\n nums2 = [1], n = 1"
                    },
                    {
                        "username": "sl8517",
                        "content": "Apperently nums1 should be [1,0] instead of [1]."
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Please read the question carefully, it is clearly written that \"To accommodate this, nums1 has a length of m + n\". So therefore if nums2 have 1 element in it then nums1 should have minimum 1 element in it.\n"
                    },
                    {
                        "username": "muralivicky",
                        "content": "its not wanting 0\\'s in its nums1. That is also a condition given by leetcode to be considered by the solvers buddy."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well size of nums 1 is always m+n so according to your case if nums1.size is 1 --> m+n = 1 --> n=0 , and in that case ans would be 1 only."
                    },
                    {
                        "username": "gokutruns8",
                        "content": "i think 0 represents null value"
                    },
                    {
                        "username": "t_guzma",
                        "content": "\"non-decreasing order\", so increasing order? :D"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "[@gurlakshpreetKaur](/gurlakshpreetKaur) It\\'s kind of a pedantic term. Almost anyone when you ask them if sorting an Amazon search by increasing price might also include two items with the same price next to each-other, they would say yes. Increasing order includes numbers that are the same. It\\'s just needlessly obtuse wording"
                    },
                    {
                        "username": "akanksha1996",
                        "content": "Non decreasing order is when the numbers may or may not increase but they never deccrease for eg 1 2 2 3 3 4 5 6 6."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Not necessarily. If it is 9,9,10,11 then the 9s are equal, therefore no increase was made, hence the non-decreasing."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Merge and sort\n\n  \n**Approach 2:** Three Pointers (Start From the Beginning)\n\n  \n**Approach 3:** Three Pointers (Start From the End)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/3re-K02xQ_g?t=59"
                    },
                    {
                        "username": "alik",
                        "content": "Can it be done without creating a new merged array, meaning sorting using only B and A?"
                    },
                    {
                        "username": "azuregcp",
                        "content": "10 year old comment. Funny.\\nPeople replying with solutions. Hilarious."
                    },
                    {
                        "username": "janis__",
                        "content": "Yes it is possible."
                    },
                    {
                        "username": "dip_018",
                        "content": "[@stanislav888](/stanislav888) try by using logic of insertion sort"
                    },
                    {
                        "username": "stanislav888",
                        "content": "Sure, dude! Just merge vectors from highest values to lowest into the tail of  nums1. I.e. replacing tail nulls with merged(high) values."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 and JavaScript solution\\nThe easiest way is iterate n times then use function to sort?\\nCan we find out a faster solution? Sure !\\n\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/)\\u2B50**\\n\\n**All solution was written by myself, so all have been tested.**\\n![image](https://assets.leetcode.com/users/images/1b85cd5f-8f55-4cce-8aab-bc51e740c66b_1654587254.4308908.jpeg)\\n\\nFor example, here is the Java submission detail.\\n\\n\\n**See more problems solutions : [Zyrastory - More LeetCode Solutions with Explanation](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.\\n\\n**Thanks**\\uD83E\\uDDE1"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "Did you buy the domain name, How did you blog here, I am intrigued, :)"
                    },
                    {
                        "username": "TheKarateKid",
                        "content": "I have tried copying the contents of my sorted array to nums1 using both `nums1 = sortedArray.clone()` and even `nums1 = sortedArray;`\\n\\nThe debugger shows that nums1 has the correct sorted values at the end of the function, but LeetCode\\'s case tester is still giving a \"Wrong Answer\" and showing the original value of nums1 before the copy.\\n\\nAnyone have any advice? Is this an issue with the LeetCode tester?\\n\\n**Update:** Using `System.arraycopy()` fixed the issue, but I think the other ways of copying should still be correct."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "Isn\\'t it because the question says in-place?"
                    }
                ]
            },
            {
                "id": 1573252,
                "content": [
                    {
                        "username": "BigMangos",
                        "content": "> https://leetcode.com/problems/merge-sorted-array/discuss/29503/Beautiful-Python-Solution\\n> \\n\\nI make a flash to understand better.\\n![88.gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n[gif](https://i.loli.net/2019/05/14/5cdac3209479073662.gif)\\n"
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "i think there is a bug in this . it is taking nums1 as Output not the Stdout. [@LeetCode](/LeetCode)  please fix this issue."
                    },
                    {
                        "username": "priyankaguptaofficial19",
                        "content": "I am running this code in my IntelliJ IDE and its giving the expected result but in this leetcode compiler its failing my case. is there any issue"
                    },
                    {
                        "username": "Nitya100",
                        "content": "How you did this kind of gif?"
                    },
                    {
                        "username": "suman_saini",
                        "content": "thanks"
                    },
                    {
                        "username": "Alterra",
                        "content": "I wouldn\\'t work for number smaller than 0\\n"
                    },
                    {
                        "username": "ajitt7381",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "aman1908",
                        "content": "It\\'s working in local system same test cases. so why it\\'s showing error in complier."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@AlteriusOmega](/AlteriusOmega) so how we can solve it then ?"
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "[@blandprix](/blandprix) Bro.. There is even problem with compiling when i try to do this simple case:\\nif(nums1[0]>nums2[nums2Size-1])"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "Make sure you are not using the assignment operator like \"nums1 = ...\" or anything like that because in most programming languages that will just create a new local variable that happens to have the same name, but will not be a reference to the same nums1 input. From then on in your function any time you modify nums1, it will be your local nums1, and so the real nums1 will be unaffected. Can\\'t use the global keyword in Python either since its an argument, not an actual global variable, though it does reference a global variable."
                    },
                    {
                        "username": "Susmita_Patra",
                        "content": "[@blandprix](/blandprix) Same problem"
                    },
                    {
                        "username": "blandprix",
                        "content": "Old question, but for others with the same issue: something like `nums1 = sortedArray` will not work because the variable in the calling scope will still reference the original array. You\\'ll have to mutate the existing array instead of trying to change the reference.\\nSome more detail [here](https://leetcode.com/problems/merge-sorted-array/description/comments/1968717)."
                    },
                    {
                        "username": "dev_kbujak",
                        "content": "Same here, it\\'s annoying!"
                    },
                    {
                        "username": "MoonHalo8088",
                        "content": "Same problem with you(\\u2565\\uFE4F\\u2565)"
                    },
                    {
                        "username": "osmanbaskok",
                        "content": "Yes, the same. It\\'s annoying!"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "yes brother same problem here"
                    },
                    {
                        "username": "mlafortune1223",
                        "content": "When I run console.log(nums1.filter(num => num !== 0).concat(nums2).sort((a,b) => a - b)) it shows [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut then when I remove the console log and just run the functions on num1, it says I\\'m outputting[1,2,3,0,0,0]\\n\\nWhat?"
                    },
                    {
                        "username": "vinjenks",
                        "content": "You can\\'t reassign a param as a whole, but you can reassign the individual array values. Maybe that\\'s an easier way of understanding it."
                    },
                    {
                        "username": "ballanibalaji",
                        "content": "[@TheHood02](/TheHood02)  when you assign a new value to a parameter within a function, it doesn\\'t affect the original variable outside the function. that is the problem\\nIn that case update is recommended instead of reassignment\\n"
                    },
                    {
                        "username": "TheHood02",
                        "content": "When you do a filter, the function returns a new array. It does not mutate the array you applied the filter function on."
                    },
                    {
                        "username": "zuborev_michael",
                        "content": "You don\\'t have to store your values in any buffer if you go backwards"
                    },
                    {
                        "username": "Harshal0409",
                        "content": "This hint is the only one required!"
                    },
                    {
                        "username": "firuz97",
                        "content": "your comment gave me a good hint after that i solved the task in O(n) time"
                    },
                    {
                        "username": "superplane",
                        "content": "I found that for corner case\\nnums1 = [1], m = 1;\\nnums2 = [0], n = 1.\\nThe result should be [0,1], but Leetcode gives [1].\\nDoes Leetcode go wrong here?"
                    },
                    {
                        "username": "agatekartik",
                        "content": "you\\'ll need nums1 to be of size 2 i.e. nums1 = [1,0] initially to satisfy all constraints"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "According to the ques, nums1 is of length (m+n) where m is no of elements to be inserted from nums1 and rest n elements \\'0\\' s  which are to be replaced by nums2 elements. So if m=1, nums1 should be [1,0] in which last \\'0\\' is replaced by nums2 element "
                    },
                    {
                        "username": "prathore28647",
                        "content": "In the given corner case, nums1 contains a single element of value 1, and nums2 contains a single element of value 0. According to the problem statement, the arrays are expected to be merged in non-decreasing order, which means the resulting array should be [0,1], with 0 preceding 1.\\n\\nIf LeetCode is returning [1] instead of [0,1], this would suggest that the solution is not correctly handling the given input, or that there is a mistake in the test cases.\\n\\nIt may be worth checking the solution code for any edge cases or boundary conditions that may not have been handled correctly. Additionally, you may want to try submitting a bug report to LeetCode to bring the issue to their attention."
                    },
                    {
                        "username": "LeetCode_AbdulRehman",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) for that case according to the problem, nums1 should be nums1 = [1, 0], m=1;\\nin order to accommodate the n=1 element of nums2,\\nseems leetcode was right we were not ..."
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\n\nnums1 = [0], m = 0,\n nums2 = [1], n = 1"
                    },
                    {
                        "username": "sl8517",
                        "content": "Apperently nums1 should be [1,0] instead of [1]."
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Please read the question carefully, it is clearly written that \"To accommodate this, nums1 has a length of m + n\". So therefore if nums2 have 1 element in it then nums1 should have minimum 1 element in it.\n"
                    },
                    {
                        "username": "muralivicky",
                        "content": "its not wanting 0\\'s in its nums1. That is also a condition given by leetcode to be considered by the solvers buddy."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well size of nums 1 is always m+n so according to your case if nums1.size is 1 --> m+n = 1 --> n=0 , and in that case ans would be 1 only."
                    },
                    {
                        "username": "gokutruns8",
                        "content": "i think 0 represents null value"
                    },
                    {
                        "username": "t_guzma",
                        "content": "\"non-decreasing order\", so increasing order? :D"
                    },
                    {
                        "username": "AlteriusOmega",
                        "content": "[@gurlakshpreetKaur](/gurlakshpreetKaur) It\\'s kind of a pedantic term. Almost anyone when you ask them if sorting an Amazon search by increasing price might also include two items with the same price next to each-other, they would say yes. Increasing order includes numbers that are the same. It\\'s just needlessly obtuse wording"
                    },
                    {
                        "username": "akanksha1996",
                        "content": "Non decreasing order is when the numbers may or may not increase but they never deccrease for eg 1 2 2 3 3 4 5 6 6."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Not necessarily. If it is 9,9,10,11 then the 9s are equal, therefore no increase was made, hence the non-decreasing."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Merge and sort\n\n  \n**Approach 2:** Three Pointers (Start From the Beginning)\n\n  \n**Approach 3:** Three Pointers (Start From the End)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/3re-K02xQ_g?t=59"
                    },
                    {
                        "username": "alik",
                        "content": "Can it be done without creating a new merged array, meaning sorting using only B and A?"
                    },
                    {
                        "username": "azuregcp",
                        "content": "10 year old comment. Funny.\\nPeople replying with solutions. Hilarious."
                    },
                    {
                        "username": "janis__",
                        "content": "Yes it is possible."
                    },
                    {
                        "username": "dip_018",
                        "content": "[@stanislav888](/stanislav888) try by using logic of insertion sort"
                    },
                    {
                        "username": "stanislav888",
                        "content": "Sure, dude! Just merge vectors from highest values to lowest into the tail of  nums1. I.e. replacing tail nulls with merged(high) values."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 and JavaScript solution\\nThe easiest way is iterate n times then use function to sort?\\nCan we find out a faster solution? Sure !\\n\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-88-merge-sorted-array-solution-and-explanation-en/)\\u2B50**\\n\\n**All solution was written by myself, so all have been tested.**\\n![image](https://assets.leetcode.com/users/images/1b85cd5f-8f55-4cce-8aab-bc51e740c66b_1654587254.4308908.jpeg)\\n\\nFor example, here is the Java submission detail.\\n\\n\\n**See more problems solutions : [Zyrastory - More LeetCode Solutions with Explanation](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.\\n\\n**Thanks**\\uD83E\\uDDE1"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "Did you buy the domain name, How did you blog here, I am intrigued, :)"
                    },
                    {
                        "username": "TheKarateKid",
                        "content": "I have tried copying the contents of my sorted array to nums1 using both `nums1 = sortedArray.clone()` and even `nums1 = sortedArray;`\\n\\nThe debugger shows that nums1 has the correct sorted values at the end of the function, but LeetCode\\'s case tester is still giving a \"Wrong Answer\" and showing the original value of nums1 before the copy.\\n\\nAnyone have any advice? Is this an issue with the LeetCode tester?\\n\\n**Update:** Using `System.arraycopy()` fixed the issue, but I think the other ways of copying should still be correct."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "Isn\\'t it because the question says in-place?"
                    }
                ]
            },
            {
                "id": 1567845,
                "content": [
                    {
                        "username": "leimao",
                        "content": "I tested my code and found an error:\\n\\nInput:\\n[0]\\n0\\n[1]\\n1\\nOutput:\\n[0,1]\\nExpected:\\n[1]\\n\\nIs the number of elements in [0] 1 instead of 0?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\\n\\nnums1 = [0], m = 0,\\nnums2 = [1], n = 1"
                    },
                    {
                        "username": "blandprix",
                        "content": "For those struggling with modifying nums1 (it's correct inside your function but the output is incorrect):\nIf you are trying to do something like `nums1 = sortedArray` in JavaScript, this will not modify nums1 (I think it creates a new reference _also named_ nums1)\n\nHowever, you are able to modify nums1 by\n* calling mutating functions on the array, e.g. `nums1.sort()`\n* modifying the elements of the array, e.g. `nums1[0] = sortedArray[0]`\n\nConsider that you can (and should!) declare arrays using the `const` keyword then add/modify/delete elements of the array.\n`const arr=[]; arr[0] = 1337; arr[1] = 31337 //this is fine`\n`const arr=[]; arr=[1337, 31337]; //Error: Assignment to constant variable.`\n\nYou can think of nums1 as a constant variable, since you are unable to change the reference of the variable in the calling scope.\n\nHope that helps!"
                    },
                    {
                        "username": "ryanmorrison7926",
                        "content": "This was so helpful! Thank you!"
                    },
                    {
                        "username": "iwctwbh",
                        "content": "def merge(nums1, m, nums2, n)\\n    nums1[m..m+n] = nums2\\n    nums1.sort!\\nend"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "why this code:\\ndef merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1 = nums1 + nums2\\n        nums1 = sorted(nums1)\\ndoes not work? it just doesnt make sense"
                    },
                    {
                        "username": "abs2389126",
                        "content": "Same solution in C++, getting faster than 100% result. \\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = 0; \\n        while(i<n)\\n        {\\n            nums1[m+i] = nums2[i];\\n            i++;\\n        }\\n\\n        sort(nums1.begin(), nums1.end());\\n    }\\n};\\n"
                    },
                    {
                        "username": "Anamaria_slay",
                        "content": "this was my first idea and it worked but I knew that this was not the solution that Leetcode had in mind, so I decided to use third array and do it like that, but I think that\\'s not what you\\'re supposed to do ether. "
                    },
                    {
                        "username": "kotokot",
                        "content": "O((n+m)*log(n+m)) complexity though"
                    },
                    {
                        "username": "vinjamury",
                        "content": "As per the description \"You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2\"\\nwhich means m >= n should be true.\\nBut Test case 57 is as below\\n[0]\\n0\\n[1]\\n1\\nwhere m < n. I think this is not correct. Any comments?"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Actually if u see clearly length of nums1 have enough space to store nums2 as well. whereas m is not length of nums1. If u try to print length of nums1 it will give value which is equal to m+n."
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I think it is incorrectly explained in the description.\\nHere, m is equal to n, and not less than n.\\nm & n are the number of elements in nums1 and nums2 respectively. (I believe)"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I've seen a few other short ones but they all still had some unnecessary stuff like `n>0` instead of just `n`. And many checked whether the next element comes from the second array, but it's slightly easier to check whether it comes from the first. Here's mine.\\n\\n    while (n) A[m+n-1] = m && A[m-1] > B[n-1] ? A[--m] : B[--n];\\n\\nAnd without the spaces:\\n\\n    while(n)A[m+n-1]=m&&A[m-1]>B[n-1]?A[--m]:B[--n];"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int last = m+n-1;\\n        int first = m-1;\\n        int second = n-1;\\n\\n\\n        while(first >=0 and second >= 0) {\\n\\n            if(nums1[first] > nums2[second]) {\\n                nums1[last] = nums1[first];\\n                first--;\\n                last--;\\n            }\\n            else {\\n                nums1[last] = nums2[second];\\n                second--;\\n                last--;\\n            }\\n        }\\n\\n        while(second >= 0) {\\n            nums1[last] = nums2[second];\\n            second--;\\n            last--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "omsky8",
                        "content": "[@invulnerability10000](/invulnerability10000) the third test case can be used for that loop where there are no elements in the array to be merged"
                    },
                    {
                        "username": "invulnerability10000",
                        "content": "What is the use of the last while loop? Can you give me a test case which puts it to any use?\\n"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "Can anyone tell me why so many people dislike this problem?"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "because its bugged"
                    },
                    {
                        "username": "justinmward",
                        "content": "This is far simpler without the trailing zeros in one of the inputs, and feels contrived and unnecessarily complicated. At least in python, storing data in this way is very much an antipattern."
                    },
                    {
                        "username": "elabraha",
                        "content": "I'm guessing that it's because the solution that beats out some solutions that are actually o(n + m) is an algorithm that sorts at the end. usually sorting the entire array of length n + m worst case is o((n+m)log(n+m)) complexity. It seems against intuition that that algorithm could beat a linear time algorithm that does not sort."
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "its simmple dont go for dislikes"
                    },
                    {
                        "username": "akjha",
                        "content": "nums1[0:m+n] = sorted(nums1[:m]+nums2[:n])"
                    },
                    {
                        "username": "calm27",
                        "content": "you know it would work at real interview"
                    },
                    {
                        "username": "dball1126",
                        "content": "Definitely a Leet Code problem, when you submit it won\\'t read the answer."
                    },
                    {
                        "username": "Aman2394",
                        "content": "nums1 = nums1[0:m]+nums2[0:n]\\nnums1.sort()"
                    },
                    {
                        "username": "harrisonseyounglee",
                        "content": "[@mishuo](/mishuo) i came up with the same solution but it doesnt work either....\\n"
                    },
                    {
                        "username": "perjorax",
                        "content": "[@mishuo](/mishuo) also i\\'m interested in the answer to why this doesn\\'t work"
                    },
                    {
                        "username": "mishuo",
                        "content": "I have the same answer, but it does not pass the test. Do you know the reason?"
                    }
                ]
            },
            {
                "id": 1968717,
                "content": [
                    {
                        "username": "leimao",
                        "content": "I tested my code and found an error:\\n\\nInput:\\n[0]\\n0\\n[1]\\n1\\nOutput:\\n[0,1]\\nExpected:\\n[1]\\n\\nIs the number of elements in [0] 1 instead of 0?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\\n\\nnums1 = [0], m = 0,\\nnums2 = [1], n = 1"
                    },
                    {
                        "username": "blandprix",
                        "content": "For those struggling with modifying nums1 (it's correct inside your function but the output is incorrect):\nIf you are trying to do something like `nums1 = sortedArray` in JavaScript, this will not modify nums1 (I think it creates a new reference _also named_ nums1)\n\nHowever, you are able to modify nums1 by\n* calling mutating functions on the array, e.g. `nums1.sort()`\n* modifying the elements of the array, e.g. `nums1[0] = sortedArray[0]`\n\nConsider that you can (and should!) declare arrays using the `const` keyword then add/modify/delete elements of the array.\n`const arr=[]; arr[0] = 1337; arr[1] = 31337 //this is fine`\n`const arr=[]; arr=[1337, 31337]; //Error: Assignment to constant variable.`\n\nYou can think of nums1 as a constant variable, since you are unable to change the reference of the variable in the calling scope.\n\nHope that helps!"
                    },
                    {
                        "username": "ryanmorrison7926",
                        "content": "This was so helpful! Thank you!"
                    },
                    {
                        "username": "iwctwbh",
                        "content": "def merge(nums1, m, nums2, n)\\n    nums1[m..m+n] = nums2\\n    nums1.sort!\\nend"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "why this code:\\ndef merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1 = nums1 + nums2\\n        nums1 = sorted(nums1)\\ndoes not work? it just doesnt make sense"
                    },
                    {
                        "username": "abs2389126",
                        "content": "Same solution in C++, getting faster than 100% result. \\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = 0; \\n        while(i<n)\\n        {\\n            nums1[m+i] = nums2[i];\\n            i++;\\n        }\\n\\n        sort(nums1.begin(), nums1.end());\\n    }\\n};\\n"
                    },
                    {
                        "username": "Anamaria_slay",
                        "content": "this was my first idea and it worked but I knew that this was not the solution that Leetcode had in mind, so I decided to use third array and do it like that, but I think that\\'s not what you\\'re supposed to do ether. "
                    },
                    {
                        "username": "kotokot",
                        "content": "O((n+m)*log(n+m)) complexity though"
                    },
                    {
                        "username": "vinjamury",
                        "content": "As per the description \"You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2\"\\nwhich means m >= n should be true.\\nBut Test case 57 is as below\\n[0]\\n0\\n[1]\\n1\\nwhere m < n. I think this is not correct. Any comments?"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Actually if u see clearly length of nums1 have enough space to store nums2 as well. whereas m is not length of nums1. If u try to print length of nums1 it will give value which is equal to m+n."
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I think it is incorrectly explained in the description.\\nHere, m is equal to n, and not less than n.\\nm & n are the number of elements in nums1 and nums2 respectively. (I believe)"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I've seen a few other short ones but they all still had some unnecessary stuff like `n>0` instead of just `n`. And many checked whether the next element comes from the second array, but it's slightly easier to check whether it comes from the first. Here's mine.\\n\\n    while (n) A[m+n-1] = m && A[m-1] > B[n-1] ? A[--m] : B[--n];\\n\\nAnd without the spaces:\\n\\n    while(n)A[m+n-1]=m&&A[m-1]>B[n-1]?A[--m]:B[--n];"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int last = m+n-1;\\n        int first = m-1;\\n        int second = n-1;\\n\\n\\n        while(first >=0 and second >= 0) {\\n\\n            if(nums1[first] > nums2[second]) {\\n                nums1[last] = nums1[first];\\n                first--;\\n                last--;\\n            }\\n            else {\\n                nums1[last] = nums2[second];\\n                second--;\\n                last--;\\n            }\\n        }\\n\\n        while(second >= 0) {\\n            nums1[last] = nums2[second];\\n            second--;\\n            last--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "omsky8",
                        "content": "[@invulnerability10000](/invulnerability10000) the third test case can be used for that loop where there are no elements in the array to be merged"
                    },
                    {
                        "username": "invulnerability10000",
                        "content": "What is the use of the last while loop? Can you give me a test case which puts it to any use?\\n"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "Can anyone tell me why so many people dislike this problem?"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "because its bugged"
                    },
                    {
                        "username": "justinmward",
                        "content": "This is far simpler without the trailing zeros in one of the inputs, and feels contrived and unnecessarily complicated. At least in python, storing data in this way is very much an antipattern."
                    },
                    {
                        "username": "elabraha",
                        "content": "I'm guessing that it's because the solution that beats out some solutions that are actually o(n + m) is an algorithm that sorts at the end. usually sorting the entire array of length n + m worst case is o((n+m)log(n+m)) complexity. It seems against intuition that that algorithm could beat a linear time algorithm that does not sort."
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "its simmple dont go for dislikes"
                    },
                    {
                        "username": "akjha",
                        "content": "nums1[0:m+n] = sorted(nums1[:m]+nums2[:n])"
                    },
                    {
                        "username": "calm27",
                        "content": "you know it would work at real interview"
                    },
                    {
                        "username": "dball1126",
                        "content": "Definitely a Leet Code problem, when you submit it won\\'t read the answer."
                    },
                    {
                        "username": "Aman2394",
                        "content": "nums1 = nums1[0:m]+nums2[0:n]\\nnums1.sort()"
                    },
                    {
                        "username": "harrisonseyounglee",
                        "content": "[@mishuo](/mishuo) i came up with the same solution but it doesnt work either....\\n"
                    },
                    {
                        "username": "perjorax",
                        "content": "[@mishuo](/mishuo) also i\\'m interested in the answer to why this doesn\\'t work"
                    },
                    {
                        "username": "mishuo",
                        "content": "I have the same answer, but it does not pass the test. Do you know the reason?"
                    }
                ]
            },
            {
                "id": 1567437,
                "content": [
                    {
                        "username": "leimao",
                        "content": "I tested my code and found an error:\\n\\nInput:\\n[0]\\n0\\n[1]\\n1\\nOutput:\\n[0,1]\\nExpected:\\n[1]\\n\\nIs the number of elements in [0] 1 instead of 0?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\\n\\nnums1 = [0], m = 0,\\nnums2 = [1], n = 1"
                    },
                    {
                        "username": "blandprix",
                        "content": "For those struggling with modifying nums1 (it's correct inside your function but the output is incorrect):\nIf you are trying to do something like `nums1 = sortedArray` in JavaScript, this will not modify nums1 (I think it creates a new reference _also named_ nums1)\n\nHowever, you are able to modify nums1 by\n* calling mutating functions on the array, e.g. `nums1.sort()`\n* modifying the elements of the array, e.g. `nums1[0] = sortedArray[0]`\n\nConsider that you can (and should!) declare arrays using the `const` keyword then add/modify/delete elements of the array.\n`const arr=[]; arr[0] = 1337; arr[1] = 31337 //this is fine`\n`const arr=[]; arr=[1337, 31337]; //Error: Assignment to constant variable.`\n\nYou can think of nums1 as a constant variable, since you are unable to change the reference of the variable in the calling scope.\n\nHope that helps!"
                    },
                    {
                        "username": "ryanmorrison7926",
                        "content": "This was so helpful! Thank you!"
                    },
                    {
                        "username": "iwctwbh",
                        "content": "def merge(nums1, m, nums2, n)\\n    nums1[m..m+n] = nums2\\n    nums1.sort!\\nend"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "why this code:\\ndef merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1 = nums1 + nums2\\n        nums1 = sorted(nums1)\\ndoes not work? it just doesnt make sense"
                    },
                    {
                        "username": "abs2389126",
                        "content": "Same solution in C++, getting faster than 100% result. \\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = 0; \\n        while(i<n)\\n        {\\n            nums1[m+i] = nums2[i];\\n            i++;\\n        }\\n\\n        sort(nums1.begin(), nums1.end());\\n    }\\n};\\n"
                    },
                    {
                        "username": "Anamaria_slay",
                        "content": "this was my first idea and it worked but I knew that this was not the solution that Leetcode had in mind, so I decided to use third array and do it like that, but I think that\\'s not what you\\'re supposed to do ether. "
                    },
                    {
                        "username": "kotokot",
                        "content": "O((n+m)*log(n+m)) complexity though"
                    },
                    {
                        "username": "vinjamury",
                        "content": "As per the description \"You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2\"\\nwhich means m >= n should be true.\\nBut Test case 57 is as below\\n[0]\\n0\\n[1]\\n1\\nwhere m < n. I think this is not correct. Any comments?"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Actually if u see clearly length of nums1 have enough space to store nums2 as well. whereas m is not length of nums1. If u try to print length of nums1 it will give value which is equal to m+n."
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I think it is incorrectly explained in the description.\\nHere, m is equal to n, and not less than n.\\nm & n are the number of elements in nums1 and nums2 respectively. (I believe)"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I've seen a few other short ones but they all still had some unnecessary stuff like `n>0` instead of just `n`. And many checked whether the next element comes from the second array, but it's slightly easier to check whether it comes from the first. Here's mine.\\n\\n    while (n) A[m+n-1] = m && A[m-1] > B[n-1] ? A[--m] : B[--n];\\n\\nAnd without the spaces:\\n\\n    while(n)A[m+n-1]=m&&A[m-1]>B[n-1]?A[--m]:B[--n];"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int last = m+n-1;\\n        int first = m-1;\\n        int second = n-1;\\n\\n\\n        while(first >=0 and second >= 0) {\\n\\n            if(nums1[first] > nums2[second]) {\\n                nums1[last] = nums1[first];\\n                first--;\\n                last--;\\n            }\\n            else {\\n                nums1[last] = nums2[second];\\n                second--;\\n                last--;\\n            }\\n        }\\n\\n        while(second >= 0) {\\n            nums1[last] = nums2[second];\\n            second--;\\n            last--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "omsky8",
                        "content": "[@invulnerability10000](/invulnerability10000) the third test case can be used for that loop where there are no elements in the array to be merged"
                    },
                    {
                        "username": "invulnerability10000",
                        "content": "What is the use of the last while loop? Can you give me a test case which puts it to any use?\\n"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "Can anyone tell me why so many people dislike this problem?"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "because its bugged"
                    },
                    {
                        "username": "justinmward",
                        "content": "This is far simpler without the trailing zeros in one of the inputs, and feels contrived and unnecessarily complicated. At least in python, storing data in this way is very much an antipattern."
                    },
                    {
                        "username": "elabraha",
                        "content": "I'm guessing that it's because the solution that beats out some solutions that are actually o(n + m) is an algorithm that sorts at the end. usually sorting the entire array of length n + m worst case is o((n+m)log(n+m)) complexity. It seems against intuition that that algorithm could beat a linear time algorithm that does not sort."
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "its simmple dont go for dislikes"
                    },
                    {
                        "username": "akjha",
                        "content": "nums1[0:m+n] = sorted(nums1[:m]+nums2[:n])"
                    },
                    {
                        "username": "calm27",
                        "content": "you know it would work at real interview"
                    },
                    {
                        "username": "dball1126",
                        "content": "Definitely a Leet Code problem, when you submit it won\\'t read the answer."
                    },
                    {
                        "username": "Aman2394",
                        "content": "nums1 = nums1[0:m]+nums2[0:n]\\nnums1.sort()"
                    },
                    {
                        "username": "harrisonseyounglee",
                        "content": "[@mishuo](/mishuo) i came up with the same solution but it doesnt work either....\\n"
                    },
                    {
                        "username": "perjorax",
                        "content": "[@mishuo](/mishuo) also i\\'m interested in the answer to why this doesn\\'t work"
                    },
                    {
                        "username": "mishuo",
                        "content": "I have the same answer, but it does not pass the test. Do you know the reason?"
                    }
                ]
            },
            {
                "id": 1568910,
                "content": [
                    {
                        "username": "leimao",
                        "content": "I tested my code and found an error:\\n\\nInput:\\n[0]\\n0\\n[1]\\n1\\nOutput:\\n[0,1]\\nExpected:\\n[1]\\n\\nIs the number of elements in [0] 1 instead of 0?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\\n\\nnums1 = [0], m = 0,\\nnums2 = [1], n = 1"
                    },
                    {
                        "username": "blandprix",
                        "content": "For those struggling with modifying nums1 (it's correct inside your function but the output is incorrect):\nIf you are trying to do something like `nums1 = sortedArray` in JavaScript, this will not modify nums1 (I think it creates a new reference _also named_ nums1)\n\nHowever, you are able to modify nums1 by\n* calling mutating functions on the array, e.g. `nums1.sort()`\n* modifying the elements of the array, e.g. `nums1[0] = sortedArray[0]`\n\nConsider that you can (and should!) declare arrays using the `const` keyword then add/modify/delete elements of the array.\n`const arr=[]; arr[0] = 1337; arr[1] = 31337 //this is fine`\n`const arr=[]; arr=[1337, 31337]; //Error: Assignment to constant variable.`\n\nYou can think of nums1 as a constant variable, since you are unable to change the reference of the variable in the calling scope.\n\nHope that helps!"
                    },
                    {
                        "username": "ryanmorrison7926",
                        "content": "This was so helpful! Thank you!"
                    },
                    {
                        "username": "iwctwbh",
                        "content": "def merge(nums1, m, nums2, n)\\n    nums1[m..m+n] = nums2\\n    nums1.sort!\\nend"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "why this code:\\ndef merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1 = nums1 + nums2\\n        nums1 = sorted(nums1)\\ndoes not work? it just doesnt make sense"
                    },
                    {
                        "username": "abs2389126",
                        "content": "Same solution in C++, getting faster than 100% result. \\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = 0; \\n        while(i<n)\\n        {\\n            nums1[m+i] = nums2[i];\\n            i++;\\n        }\\n\\n        sort(nums1.begin(), nums1.end());\\n    }\\n};\\n"
                    },
                    {
                        "username": "Anamaria_slay",
                        "content": "this was my first idea and it worked but I knew that this was not the solution that Leetcode had in mind, so I decided to use third array and do it like that, but I think that\\'s not what you\\'re supposed to do ether. "
                    },
                    {
                        "username": "kotokot",
                        "content": "O((n+m)*log(n+m)) complexity though"
                    },
                    {
                        "username": "vinjamury",
                        "content": "As per the description \"You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2\"\\nwhich means m >= n should be true.\\nBut Test case 57 is as below\\n[0]\\n0\\n[1]\\n1\\nwhere m < n. I think this is not correct. Any comments?"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Actually if u see clearly length of nums1 have enough space to store nums2 as well. whereas m is not length of nums1. If u try to print length of nums1 it will give value which is equal to m+n."
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I think it is incorrectly explained in the description.\\nHere, m is equal to n, and not less than n.\\nm & n are the number of elements in nums1 and nums2 respectively. (I believe)"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I've seen a few other short ones but they all still had some unnecessary stuff like `n>0` instead of just `n`. And many checked whether the next element comes from the second array, but it's slightly easier to check whether it comes from the first. Here's mine.\\n\\n    while (n) A[m+n-1] = m && A[m-1] > B[n-1] ? A[--m] : B[--n];\\n\\nAnd without the spaces:\\n\\n    while(n)A[m+n-1]=m&&A[m-1]>B[n-1]?A[--m]:B[--n];"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int last = m+n-1;\\n        int first = m-1;\\n        int second = n-1;\\n\\n\\n        while(first >=0 and second >= 0) {\\n\\n            if(nums1[first] > nums2[second]) {\\n                nums1[last] = nums1[first];\\n                first--;\\n                last--;\\n            }\\n            else {\\n                nums1[last] = nums2[second];\\n                second--;\\n                last--;\\n            }\\n        }\\n\\n        while(second >= 0) {\\n            nums1[last] = nums2[second];\\n            second--;\\n            last--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "omsky8",
                        "content": "[@invulnerability10000](/invulnerability10000) the third test case can be used for that loop where there are no elements in the array to be merged"
                    },
                    {
                        "username": "invulnerability10000",
                        "content": "What is the use of the last while loop? Can you give me a test case which puts it to any use?\\n"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "Can anyone tell me why so many people dislike this problem?"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "because its bugged"
                    },
                    {
                        "username": "justinmward",
                        "content": "This is far simpler without the trailing zeros in one of the inputs, and feels contrived and unnecessarily complicated. At least in python, storing data in this way is very much an antipattern."
                    },
                    {
                        "username": "elabraha",
                        "content": "I'm guessing that it's because the solution that beats out some solutions that are actually o(n + m) is an algorithm that sorts at the end. usually sorting the entire array of length n + m worst case is o((n+m)log(n+m)) complexity. It seems against intuition that that algorithm could beat a linear time algorithm that does not sort."
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "its simmple dont go for dislikes"
                    },
                    {
                        "username": "akjha",
                        "content": "nums1[0:m+n] = sorted(nums1[:m]+nums2[:n])"
                    },
                    {
                        "username": "calm27",
                        "content": "you know it would work at real interview"
                    },
                    {
                        "username": "dball1126",
                        "content": "Definitely a Leet Code problem, when you submit it won\\'t read the answer."
                    },
                    {
                        "username": "Aman2394",
                        "content": "nums1 = nums1[0:m]+nums2[0:n]\\nnums1.sort()"
                    },
                    {
                        "username": "harrisonseyounglee",
                        "content": "[@mishuo](/mishuo) i came up with the same solution but it doesnt work either....\\n"
                    },
                    {
                        "username": "perjorax",
                        "content": "[@mishuo](/mishuo) also i\\'m interested in the answer to why this doesn\\'t work"
                    },
                    {
                        "username": "mishuo",
                        "content": "I have the same answer, but it does not pass the test. Do you know the reason?"
                    }
                ]
            },
            {
                "id": 1565944,
                "content": [
                    {
                        "username": "leimao",
                        "content": "I tested my code and found an error:\\n\\nInput:\\n[0]\\n0\\n[1]\\n1\\nOutput:\\n[0,1]\\nExpected:\\n[1]\\n\\nIs the number of elements in [0] 1 instead of 0?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\\n\\nnums1 = [0], m = 0,\\nnums2 = [1], n = 1"
                    },
                    {
                        "username": "blandprix",
                        "content": "For those struggling with modifying nums1 (it's correct inside your function but the output is incorrect):\nIf you are trying to do something like `nums1 = sortedArray` in JavaScript, this will not modify nums1 (I think it creates a new reference _also named_ nums1)\n\nHowever, you are able to modify nums1 by\n* calling mutating functions on the array, e.g. `nums1.sort()`\n* modifying the elements of the array, e.g. `nums1[0] = sortedArray[0]`\n\nConsider that you can (and should!) declare arrays using the `const` keyword then add/modify/delete elements of the array.\n`const arr=[]; arr[0] = 1337; arr[1] = 31337 //this is fine`\n`const arr=[]; arr=[1337, 31337]; //Error: Assignment to constant variable.`\n\nYou can think of nums1 as a constant variable, since you are unable to change the reference of the variable in the calling scope.\n\nHope that helps!"
                    },
                    {
                        "username": "ryanmorrison7926",
                        "content": "This was so helpful! Thank you!"
                    },
                    {
                        "username": "iwctwbh",
                        "content": "def merge(nums1, m, nums2, n)\\n    nums1[m..m+n] = nums2\\n    nums1.sort!\\nend"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "why this code:\\ndef merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1 = nums1 + nums2\\n        nums1 = sorted(nums1)\\ndoes not work? it just doesnt make sense"
                    },
                    {
                        "username": "abs2389126",
                        "content": "Same solution in C++, getting faster than 100% result. \\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = 0; \\n        while(i<n)\\n        {\\n            nums1[m+i] = nums2[i];\\n            i++;\\n        }\\n\\n        sort(nums1.begin(), nums1.end());\\n    }\\n};\\n"
                    },
                    {
                        "username": "Anamaria_slay",
                        "content": "this was my first idea and it worked but I knew that this was not the solution that Leetcode had in mind, so I decided to use third array and do it like that, but I think that\\'s not what you\\'re supposed to do ether. "
                    },
                    {
                        "username": "kotokot",
                        "content": "O((n+m)*log(n+m)) complexity though"
                    },
                    {
                        "username": "vinjamury",
                        "content": "As per the description \"You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2\"\\nwhich means m >= n should be true.\\nBut Test case 57 is as below\\n[0]\\n0\\n[1]\\n1\\nwhere m < n. I think this is not correct. Any comments?"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Actually if u see clearly length of nums1 have enough space to store nums2 as well. whereas m is not length of nums1. If u try to print length of nums1 it will give value which is equal to m+n."
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I think it is incorrectly explained in the description.\\nHere, m is equal to n, and not less than n.\\nm & n are the number of elements in nums1 and nums2 respectively. (I believe)"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I've seen a few other short ones but they all still had some unnecessary stuff like `n>0` instead of just `n`. And many checked whether the next element comes from the second array, but it's slightly easier to check whether it comes from the first. Here's mine.\\n\\n    while (n) A[m+n-1] = m && A[m-1] > B[n-1] ? A[--m] : B[--n];\\n\\nAnd without the spaces:\\n\\n    while(n)A[m+n-1]=m&&A[m-1]>B[n-1]?A[--m]:B[--n];"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int last = m+n-1;\\n        int first = m-1;\\n        int second = n-1;\\n\\n\\n        while(first >=0 and second >= 0) {\\n\\n            if(nums1[first] > nums2[second]) {\\n                nums1[last] = nums1[first];\\n                first--;\\n                last--;\\n            }\\n            else {\\n                nums1[last] = nums2[second];\\n                second--;\\n                last--;\\n            }\\n        }\\n\\n        while(second >= 0) {\\n            nums1[last] = nums2[second];\\n            second--;\\n            last--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "omsky8",
                        "content": "[@invulnerability10000](/invulnerability10000) the third test case can be used for that loop where there are no elements in the array to be merged"
                    },
                    {
                        "username": "invulnerability10000",
                        "content": "What is the use of the last while loop? Can you give me a test case which puts it to any use?\\n"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "Can anyone tell me why so many people dislike this problem?"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "because its bugged"
                    },
                    {
                        "username": "justinmward",
                        "content": "This is far simpler without the trailing zeros in one of the inputs, and feels contrived and unnecessarily complicated. At least in python, storing data in this way is very much an antipattern."
                    },
                    {
                        "username": "elabraha",
                        "content": "I'm guessing that it's because the solution that beats out some solutions that are actually o(n + m) is an algorithm that sorts at the end. usually sorting the entire array of length n + m worst case is o((n+m)log(n+m)) complexity. It seems against intuition that that algorithm could beat a linear time algorithm that does not sort."
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "its simmple dont go for dislikes"
                    },
                    {
                        "username": "akjha",
                        "content": "nums1[0:m+n] = sorted(nums1[:m]+nums2[:n])"
                    },
                    {
                        "username": "calm27",
                        "content": "you know it would work at real interview"
                    },
                    {
                        "username": "dball1126",
                        "content": "Definitely a Leet Code problem, when you submit it won\\'t read the answer."
                    },
                    {
                        "username": "Aman2394",
                        "content": "nums1 = nums1[0:m]+nums2[0:n]\\nnums1.sort()"
                    },
                    {
                        "username": "harrisonseyounglee",
                        "content": "[@mishuo](/mishuo) i came up with the same solution but it doesnt work either....\\n"
                    },
                    {
                        "username": "perjorax",
                        "content": "[@mishuo](/mishuo) also i\\'m interested in the answer to why this doesn\\'t work"
                    },
                    {
                        "username": "mishuo",
                        "content": "I have the same answer, but it does not pass the test. Do you know the reason?"
                    }
                ]
            },
            {
                "id": 1677801,
                "content": [
                    {
                        "username": "leimao",
                        "content": "I tested my code and found an error:\\n\\nInput:\\n[0]\\n0\\n[1]\\n1\\nOutput:\\n[0,1]\\nExpected:\\n[1]\\n\\nIs the number of elements in [0] 1 instead of 0?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\\n\\nnums1 = [0], m = 0,\\nnums2 = [1], n = 1"
                    },
                    {
                        "username": "blandprix",
                        "content": "For those struggling with modifying nums1 (it's correct inside your function but the output is incorrect):\nIf you are trying to do something like `nums1 = sortedArray` in JavaScript, this will not modify nums1 (I think it creates a new reference _also named_ nums1)\n\nHowever, you are able to modify nums1 by\n* calling mutating functions on the array, e.g. `nums1.sort()`\n* modifying the elements of the array, e.g. `nums1[0] = sortedArray[0]`\n\nConsider that you can (and should!) declare arrays using the `const` keyword then add/modify/delete elements of the array.\n`const arr=[]; arr[0] = 1337; arr[1] = 31337 //this is fine`\n`const arr=[]; arr=[1337, 31337]; //Error: Assignment to constant variable.`\n\nYou can think of nums1 as a constant variable, since you are unable to change the reference of the variable in the calling scope.\n\nHope that helps!"
                    },
                    {
                        "username": "ryanmorrison7926",
                        "content": "This was so helpful! Thank you!"
                    },
                    {
                        "username": "iwctwbh",
                        "content": "def merge(nums1, m, nums2, n)\\n    nums1[m..m+n] = nums2\\n    nums1.sort!\\nend"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "why this code:\\ndef merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1 = nums1 + nums2\\n        nums1 = sorted(nums1)\\ndoes not work? it just doesnt make sense"
                    },
                    {
                        "username": "abs2389126",
                        "content": "Same solution in C++, getting faster than 100% result. \\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = 0; \\n        while(i<n)\\n        {\\n            nums1[m+i] = nums2[i];\\n            i++;\\n        }\\n\\n        sort(nums1.begin(), nums1.end());\\n    }\\n};\\n"
                    },
                    {
                        "username": "Anamaria_slay",
                        "content": "this was my first idea and it worked but I knew that this was not the solution that Leetcode had in mind, so I decided to use third array and do it like that, but I think that\\'s not what you\\'re supposed to do ether. "
                    },
                    {
                        "username": "kotokot",
                        "content": "O((n+m)*log(n+m)) complexity though"
                    },
                    {
                        "username": "vinjamury",
                        "content": "As per the description \"You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2\"\\nwhich means m >= n should be true.\\nBut Test case 57 is as below\\n[0]\\n0\\n[1]\\n1\\nwhere m < n. I think this is not correct. Any comments?"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Actually if u see clearly length of nums1 have enough space to store nums2 as well. whereas m is not length of nums1. If u try to print length of nums1 it will give value which is equal to m+n."
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I think it is incorrectly explained in the description.\\nHere, m is equal to n, and not less than n.\\nm & n are the number of elements in nums1 and nums2 respectively. (I believe)"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I've seen a few other short ones but they all still had some unnecessary stuff like `n>0` instead of just `n`. And many checked whether the next element comes from the second array, but it's slightly easier to check whether it comes from the first. Here's mine.\\n\\n    while (n) A[m+n-1] = m && A[m-1] > B[n-1] ? A[--m] : B[--n];\\n\\nAnd without the spaces:\\n\\n    while(n)A[m+n-1]=m&&A[m-1]>B[n-1]?A[--m]:B[--n];"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int last = m+n-1;\\n        int first = m-1;\\n        int second = n-1;\\n\\n\\n        while(first >=0 and second >= 0) {\\n\\n            if(nums1[first] > nums2[second]) {\\n                nums1[last] = nums1[first];\\n                first--;\\n                last--;\\n            }\\n            else {\\n                nums1[last] = nums2[second];\\n                second--;\\n                last--;\\n            }\\n        }\\n\\n        while(second >= 0) {\\n            nums1[last] = nums2[second];\\n            second--;\\n            last--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "omsky8",
                        "content": "[@invulnerability10000](/invulnerability10000) the third test case can be used for that loop where there are no elements in the array to be merged"
                    },
                    {
                        "username": "invulnerability10000",
                        "content": "What is the use of the last while loop? Can you give me a test case which puts it to any use?\\n"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "Can anyone tell me why so many people dislike this problem?"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "because its bugged"
                    },
                    {
                        "username": "justinmward",
                        "content": "This is far simpler without the trailing zeros in one of the inputs, and feels contrived and unnecessarily complicated. At least in python, storing data in this way is very much an antipattern."
                    },
                    {
                        "username": "elabraha",
                        "content": "I'm guessing that it's because the solution that beats out some solutions that are actually o(n + m) is an algorithm that sorts at the end. usually sorting the entire array of length n + m worst case is o((n+m)log(n+m)) complexity. It seems against intuition that that algorithm could beat a linear time algorithm that does not sort."
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "its simmple dont go for dislikes"
                    },
                    {
                        "username": "akjha",
                        "content": "nums1[0:m+n] = sorted(nums1[:m]+nums2[:n])"
                    },
                    {
                        "username": "calm27",
                        "content": "you know it would work at real interview"
                    },
                    {
                        "username": "dball1126",
                        "content": "Definitely a Leet Code problem, when you submit it won\\'t read the answer."
                    },
                    {
                        "username": "Aman2394",
                        "content": "nums1 = nums1[0:m]+nums2[0:n]\\nnums1.sort()"
                    },
                    {
                        "username": "harrisonseyounglee",
                        "content": "[@mishuo](/mishuo) i came up with the same solution but it doesnt work either....\\n"
                    },
                    {
                        "username": "perjorax",
                        "content": "[@mishuo](/mishuo) also i\\'m interested in the answer to why this doesn\\'t work"
                    },
                    {
                        "username": "mishuo",
                        "content": "I have the same answer, but it does not pass the test. Do you know the reason?"
                    }
                ]
            },
            {
                "id": 1569280,
                "content": [
                    {
                        "username": "leimao",
                        "content": "I tested my code and found an error:\\n\\nInput:\\n[0]\\n0\\n[1]\\n1\\nOutput:\\n[0,1]\\nExpected:\\n[1]\\n\\nIs the number of elements in [0] 1 instead of 0?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\\n\\nnums1 = [0], m = 0,\\nnums2 = [1], n = 1"
                    },
                    {
                        "username": "blandprix",
                        "content": "For those struggling with modifying nums1 (it's correct inside your function but the output is incorrect):\nIf you are trying to do something like `nums1 = sortedArray` in JavaScript, this will not modify nums1 (I think it creates a new reference _also named_ nums1)\n\nHowever, you are able to modify nums1 by\n* calling mutating functions on the array, e.g. `nums1.sort()`\n* modifying the elements of the array, e.g. `nums1[0] = sortedArray[0]`\n\nConsider that you can (and should!) declare arrays using the `const` keyword then add/modify/delete elements of the array.\n`const arr=[]; arr[0] = 1337; arr[1] = 31337 //this is fine`\n`const arr=[]; arr=[1337, 31337]; //Error: Assignment to constant variable.`\n\nYou can think of nums1 as a constant variable, since you are unable to change the reference of the variable in the calling scope.\n\nHope that helps!"
                    },
                    {
                        "username": "ryanmorrison7926",
                        "content": "This was so helpful! Thank you!"
                    },
                    {
                        "username": "iwctwbh",
                        "content": "def merge(nums1, m, nums2, n)\\n    nums1[m..m+n] = nums2\\n    nums1.sort!\\nend"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "why this code:\\ndef merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1 = nums1 + nums2\\n        nums1 = sorted(nums1)\\ndoes not work? it just doesnt make sense"
                    },
                    {
                        "username": "abs2389126",
                        "content": "Same solution in C++, getting faster than 100% result. \\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = 0; \\n        while(i<n)\\n        {\\n            nums1[m+i] = nums2[i];\\n            i++;\\n        }\\n\\n        sort(nums1.begin(), nums1.end());\\n    }\\n};\\n"
                    },
                    {
                        "username": "Anamaria_slay",
                        "content": "this was my first idea and it worked but I knew that this was not the solution that Leetcode had in mind, so I decided to use third array and do it like that, but I think that\\'s not what you\\'re supposed to do ether. "
                    },
                    {
                        "username": "kotokot",
                        "content": "O((n+m)*log(n+m)) complexity though"
                    },
                    {
                        "username": "vinjamury",
                        "content": "As per the description \"You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2\"\\nwhich means m >= n should be true.\\nBut Test case 57 is as below\\n[0]\\n0\\n[1]\\n1\\nwhere m < n. I think this is not correct. Any comments?"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Actually if u see clearly length of nums1 have enough space to store nums2 as well. whereas m is not length of nums1. If u try to print length of nums1 it will give value which is equal to m+n."
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I think it is incorrectly explained in the description.\\nHere, m is equal to n, and not less than n.\\nm & n are the number of elements in nums1 and nums2 respectively. (I believe)"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I've seen a few other short ones but they all still had some unnecessary stuff like `n>0` instead of just `n`. And many checked whether the next element comes from the second array, but it's slightly easier to check whether it comes from the first. Here's mine.\\n\\n    while (n) A[m+n-1] = m && A[m-1] > B[n-1] ? A[--m] : B[--n];\\n\\nAnd without the spaces:\\n\\n    while(n)A[m+n-1]=m&&A[m-1]>B[n-1]?A[--m]:B[--n];"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int last = m+n-1;\\n        int first = m-1;\\n        int second = n-1;\\n\\n\\n        while(first >=0 and second >= 0) {\\n\\n            if(nums1[first] > nums2[second]) {\\n                nums1[last] = nums1[first];\\n                first--;\\n                last--;\\n            }\\n            else {\\n                nums1[last] = nums2[second];\\n                second--;\\n                last--;\\n            }\\n        }\\n\\n        while(second >= 0) {\\n            nums1[last] = nums2[second];\\n            second--;\\n            last--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "omsky8",
                        "content": "[@invulnerability10000](/invulnerability10000) the third test case can be used for that loop where there are no elements in the array to be merged"
                    },
                    {
                        "username": "invulnerability10000",
                        "content": "What is the use of the last while loop? Can you give me a test case which puts it to any use?\\n"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "Can anyone tell me why so many people dislike this problem?"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "because its bugged"
                    },
                    {
                        "username": "justinmward",
                        "content": "This is far simpler without the trailing zeros in one of the inputs, and feels contrived and unnecessarily complicated. At least in python, storing data in this way is very much an antipattern."
                    },
                    {
                        "username": "elabraha",
                        "content": "I'm guessing that it's because the solution that beats out some solutions that are actually o(n + m) is an algorithm that sorts at the end. usually sorting the entire array of length n + m worst case is o((n+m)log(n+m)) complexity. It seems against intuition that that algorithm could beat a linear time algorithm that does not sort."
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "its simmple dont go for dislikes"
                    },
                    {
                        "username": "akjha",
                        "content": "nums1[0:m+n] = sorted(nums1[:m]+nums2[:n])"
                    },
                    {
                        "username": "calm27",
                        "content": "you know it would work at real interview"
                    },
                    {
                        "username": "dball1126",
                        "content": "Definitely a Leet Code problem, when you submit it won\\'t read the answer."
                    },
                    {
                        "username": "Aman2394",
                        "content": "nums1 = nums1[0:m]+nums2[0:n]\\nnums1.sort()"
                    },
                    {
                        "username": "harrisonseyounglee",
                        "content": "[@mishuo](/mishuo) i came up with the same solution but it doesnt work either....\\n"
                    },
                    {
                        "username": "perjorax",
                        "content": "[@mishuo](/mishuo) also i\\'m interested in the answer to why this doesn\\'t work"
                    },
                    {
                        "username": "mishuo",
                        "content": "I have the same answer, but it does not pass the test. Do you know the reason?"
                    }
                ]
            },
            {
                "id": 1568037,
                "content": [
                    {
                        "username": "leimao",
                        "content": "I tested my code and found an error:\\n\\nInput:\\n[0]\\n0\\n[1]\\n1\\nOutput:\\n[0,1]\\nExpected:\\n[1]\\n\\nIs the number of elements in [0] 1 instead of 0?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\\n\\nnums1 = [0], m = 0,\\nnums2 = [1], n = 1"
                    },
                    {
                        "username": "blandprix",
                        "content": "For those struggling with modifying nums1 (it's correct inside your function but the output is incorrect):\nIf you are trying to do something like `nums1 = sortedArray` in JavaScript, this will not modify nums1 (I think it creates a new reference _also named_ nums1)\n\nHowever, you are able to modify nums1 by\n* calling mutating functions on the array, e.g. `nums1.sort()`\n* modifying the elements of the array, e.g. `nums1[0] = sortedArray[0]`\n\nConsider that you can (and should!) declare arrays using the `const` keyword then add/modify/delete elements of the array.\n`const arr=[]; arr[0] = 1337; arr[1] = 31337 //this is fine`\n`const arr=[]; arr=[1337, 31337]; //Error: Assignment to constant variable.`\n\nYou can think of nums1 as a constant variable, since you are unable to change the reference of the variable in the calling scope.\n\nHope that helps!"
                    },
                    {
                        "username": "ryanmorrison7926",
                        "content": "This was so helpful! Thank you!"
                    },
                    {
                        "username": "iwctwbh",
                        "content": "def merge(nums1, m, nums2, n)\\n    nums1[m..m+n] = nums2\\n    nums1.sort!\\nend"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "why this code:\\ndef merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1 = nums1 + nums2\\n        nums1 = sorted(nums1)\\ndoes not work? it just doesnt make sense"
                    },
                    {
                        "username": "abs2389126",
                        "content": "Same solution in C++, getting faster than 100% result. \\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = 0; \\n        while(i<n)\\n        {\\n            nums1[m+i] = nums2[i];\\n            i++;\\n        }\\n\\n        sort(nums1.begin(), nums1.end());\\n    }\\n};\\n"
                    },
                    {
                        "username": "Anamaria_slay",
                        "content": "this was my first idea and it worked but I knew that this was not the solution that Leetcode had in mind, so I decided to use third array and do it like that, but I think that\\'s not what you\\'re supposed to do ether. "
                    },
                    {
                        "username": "kotokot",
                        "content": "O((n+m)*log(n+m)) complexity though"
                    },
                    {
                        "username": "vinjamury",
                        "content": "As per the description \"You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2\"\\nwhich means m >= n should be true.\\nBut Test case 57 is as below\\n[0]\\n0\\n[1]\\n1\\nwhere m < n. I think this is not correct. Any comments?"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Actually if u see clearly length of nums1 have enough space to store nums2 as well. whereas m is not length of nums1. If u try to print length of nums1 it will give value which is equal to m+n."
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I think it is incorrectly explained in the description.\\nHere, m is equal to n, and not less than n.\\nm & n are the number of elements in nums1 and nums2 respectively. (I believe)"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I've seen a few other short ones but they all still had some unnecessary stuff like `n>0` instead of just `n`. And many checked whether the next element comes from the second array, but it's slightly easier to check whether it comes from the first. Here's mine.\\n\\n    while (n) A[m+n-1] = m && A[m-1] > B[n-1] ? A[--m] : B[--n];\\n\\nAnd without the spaces:\\n\\n    while(n)A[m+n-1]=m&&A[m-1]>B[n-1]?A[--m]:B[--n];"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int last = m+n-1;\\n        int first = m-1;\\n        int second = n-1;\\n\\n\\n        while(first >=0 and second >= 0) {\\n\\n            if(nums1[first] > nums2[second]) {\\n                nums1[last] = nums1[first];\\n                first--;\\n                last--;\\n            }\\n            else {\\n                nums1[last] = nums2[second];\\n                second--;\\n                last--;\\n            }\\n        }\\n\\n        while(second >= 0) {\\n            nums1[last] = nums2[second];\\n            second--;\\n            last--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "omsky8",
                        "content": "[@invulnerability10000](/invulnerability10000) the third test case can be used for that loop where there are no elements in the array to be merged"
                    },
                    {
                        "username": "invulnerability10000",
                        "content": "What is the use of the last while loop? Can you give me a test case which puts it to any use?\\n"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "Can anyone tell me why so many people dislike this problem?"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "because its bugged"
                    },
                    {
                        "username": "justinmward",
                        "content": "This is far simpler without the trailing zeros in one of the inputs, and feels contrived and unnecessarily complicated. At least in python, storing data in this way is very much an antipattern."
                    },
                    {
                        "username": "elabraha",
                        "content": "I'm guessing that it's because the solution that beats out some solutions that are actually o(n + m) is an algorithm that sorts at the end. usually sorting the entire array of length n + m worst case is o((n+m)log(n+m)) complexity. It seems against intuition that that algorithm could beat a linear time algorithm that does not sort."
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "its simmple dont go for dislikes"
                    },
                    {
                        "username": "akjha",
                        "content": "nums1[0:m+n] = sorted(nums1[:m]+nums2[:n])"
                    },
                    {
                        "username": "calm27",
                        "content": "you know it would work at real interview"
                    },
                    {
                        "username": "dball1126",
                        "content": "Definitely a Leet Code problem, when you submit it won\\'t read the answer."
                    },
                    {
                        "username": "Aman2394",
                        "content": "nums1 = nums1[0:m]+nums2[0:n]\\nnums1.sort()"
                    },
                    {
                        "username": "harrisonseyounglee",
                        "content": "[@mishuo](/mishuo) i came up with the same solution but it doesnt work either....\\n"
                    },
                    {
                        "username": "perjorax",
                        "content": "[@mishuo](/mishuo) also i\\'m interested in the answer to why this doesn\\'t work"
                    },
                    {
                        "username": "mishuo",
                        "content": "I have the same answer, but it does not pass the test. Do you know the reason?"
                    }
                ]
            },
            {
                "id": 1573323,
                "content": [
                    {
                        "username": "leimao",
                        "content": "I tested my code and found an error:\\n\\nInput:\\n[0]\\n0\\n[1]\\n1\\nOutput:\\n[0,1]\\nExpected:\\n[1]\\n\\nIs the number of elements in [0] 1 instead of 0?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\\n\\nnums1 = [0], m = 0,\\nnums2 = [1], n = 1"
                    },
                    {
                        "username": "blandprix",
                        "content": "For those struggling with modifying nums1 (it's correct inside your function but the output is incorrect):\nIf you are trying to do something like `nums1 = sortedArray` in JavaScript, this will not modify nums1 (I think it creates a new reference _also named_ nums1)\n\nHowever, you are able to modify nums1 by\n* calling mutating functions on the array, e.g. `nums1.sort()`\n* modifying the elements of the array, e.g. `nums1[0] = sortedArray[0]`\n\nConsider that you can (and should!) declare arrays using the `const` keyword then add/modify/delete elements of the array.\n`const arr=[]; arr[0] = 1337; arr[1] = 31337 //this is fine`\n`const arr=[]; arr=[1337, 31337]; //Error: Assignment to constant variable.`\n\nYou can think of nums1 as a constant variable, since you are unable to change the reference of the variable in the calling scope.\n\nHope that helps!"
                    },
                    {
                        "username": "ryanmorrison7926",
                        "content": "This was so helpful! Thank you!"
                    },
                    {
                        "username": "iwctwbh",
                        "content": "def merge(nums1, m, nums2, n)\\n    nums1[m..m+n] = nums2\\n    nums1.sort!\\nend"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "why this code:\\ndef merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1 = nums1 + nums2\\n        nums1 = sorted(nums1)\\ndoes not work? it just doesnt make sense"
                    },
                    {
                        "username": "abs2389126",
                        "content": "Same solution in C++, getting faster than 100% result. \\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = 0; \\n        while(i<n)\\n        {\\n            nums1[m+i] = nums2[i];\\n            i++;\\n        }\\n\\n        sort(nums1.begin(), nums1.end());\\n    }\\n};\\n"
                    },
                    {
                        "username": "Anamaria_slay",
                        "content": "this was my first idea and it worked but I knew that this was not the solution that Leetcode had in mind, so I decided to use third array and do it like that, but I think that\\'s not what you\\'re supposed to do ether. "
                    },
                    {
                        "username": "kotokot",
                        "content": "O((n+m)*log(n+m)) complexity though"
                    },
                    {
                        "username": "vinjamury",
                        "content": "As per the description \"You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2\"\\nwhich means m >= n should be true.\\nBut Test case 57 is as below\\n[0]\\n0\\n[1]\\n1\\nwhere m < n. I think this is not correct. Any comments?"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Actually if u see clearly length of nums1 have enough space to store nums2 as well. whereas m is not length of nums1. If u try to print length of nums1 it will give value which is equal to m+n."
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I think it is incorrectly explained in the description.\\nHere, m is equal to n, and not less than n.\\nm & n are the number of elements in nums1 and nums2 respectively. (I believe)"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I've seen a few other short ones but they all still had some unnecessary stuff like `n>0` instead of just `n`. And many checked whether the next element comes from the second array, but it's slightly easier to check whether it comes from the first. Here's mine.\\n\\n    while (n) A[m+n-1] = m && A[m-1] > B[n-1] ? A[--m] : B[--n];\\n\\nAnd without the spaces:\\n\\n    while(n)A[m+n-1]=m&&A[m-1]>B[n-1]?A[--m]:B[--n];"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int last = m+n-1;\\n        int first = m-1;\\n        int second = n-1;\\n\\n\\n        while(first >=0 and second >= 0) {\\n\\n            if(nums1[first] > nums2[second]) {\\n                nums1[last] = nums1[first];\\n                first--;\\n                last--;\\n            }\\n            else {\\n                nums1[last] = nums2[second];\\n                second--;\\n                last--;\\n            }\\n        }\\n\\n        while(second >= 0) {\\n            nums1[last] = nums2[second];\\n            second--;\\n            last--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "omsky8",
                        "content": "[@invulnerability10000](/invulnerability10000) the third test case can be used for that loop where there are no elements in the array to be merged"
                    },
                    {
                        "username": "invulnerability10000",
                        "content": "What is the use of the last while loop? Can you give me a test case which puts it to any use?\\n"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "Can anyone tell me why so many people dislike this problem?"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "because its bugged"
                    },
                    {
                        "username": "justinmward",
                        "content": "This is far simpler without the trailing zeros in one of the inputs, and feels contrived and unnecessarily complicated. At least in python, storing data in this way is very much an antipattern."
                    },
                    {
                        "username": "elabraha",
                        "content": "I'm guessing that it's because the solution that beats out some solutions that are actually o(n + m) is an algorithm that sorts at the end. usually sorting the entire array of length n + m worst case is o((n+m)log(n+m)) complexity. It seems against intuition that that algorithm could beat a linear time algorithm that does not sort."
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "its simmple dont go for dislikes"
                    },
                    {
                        "username": "akjha",
                        "content": "nums1[0:m+n] = sorted(nums1[:m]+nums2[:n])"
                    },
                    {
                        "username": "calm27",
                        "content": "you know it would work at real interview"
                    },
                    {
                        "username": "dball1126",
                        "content": "Definitely a Leet Code problem, when you submit it won\\'t read the answer."
                    },
                    {
                        "username": "Aman2394",
                        "content": "nums1 = nums1[0:m]+nums2[0:n]\\nnums1.sort()"
                    },
                    {
                        "username": "harrisonseyounglee",
                        "content": "[@mishuo](/mishuo) i came up with the same solution but it doesnt work either....\\n"
                    },
                    {
                        "username": "perjorax",
                        "content": "[@mishuo](/mishuo) also i\\'m interested in the answer to why this doesn\\'t work"
                    },
                    {
                        "username": "mishuo",
                        "content": "I have the same answer, but it does not pass the test. Do you know the reason?"
                    }
                ]
            },
            {
                "id": 1574583,
                "content": [
                    {
                        "username": "leimao",
                        "content": "I tested my code and found an error:\\n\\nInput:\\n[0]\\n0\\n[1]\\n1\\nOutput:\\n[0,1]\\nExpected:\\n[1]\\n\\nIs the number of elements in [0] 1 instead of 0?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro apne num1=[0] dekh liya but m=0 nahi dekha bo bhi dekh lete 0 represents null array array ki length m=0 hai then usme koi element hi nahi hai empty array hai then final solution mai hum 0 include nahi kr skte okay bro\\n\\nnums1 = [0], m = 0,\\nnums2 = [1], n = 1"
                    },
                    {
                        "username": "blandprix",
                        "content": "For those struggling with modifying nums1 (it's correct inside your function but the output is incorrect):\nIf you are trying to do something like `nums1 = sortedArray` in JavaScript, this will not modify nums1 (I think it creates a new reference _also named_ nums1)\n\nHowever, you are able to modify nums1 by\n* calling mutating functions on the array, e.g. `nums1.sort()`\n* modifying the elements of the array, e.g. `nums1[0] = sortedArray[0]`\n\nConsider that you can (and should!) declare arrays using the `const` keyword then add/modify/delete elements of the array.\n`const arr=[]; arr[0] = 1337; arr[1] = 31337 //this is fine`\n`const arr=[]; arr=[1337, 31337]; //Error: Assignment to constant variable.`\n\nYou can think of nums1 as a constant variable, since you are unable to change the reference of the variable in the calling scope.\n\nHope that helps!"
                    },
                    {
                        "username": "ryanmorrison7926",
                        "content": "This was so helpful! Thank you!"
                    },
                    {
                        "username": "iwctwbh",
                        "content": "def merge(nums1, m, nums2, n)\\n    nums1[m..m+n] = nums2\\n    nums1.sort!\\nend"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "why this code:\\ndef merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1 = nums1 + nums2\\n        nums1 = sorted(nums1)\\ndoes not work? it just doesnt make sense"
                    },
                    {
                        "username": "abs2389126",
                        "content": "Same solution in C++, getting faster than 100% result. \\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = 0; \\n        while(i<n)\\n        {\\n            nums1[m+i] = nums2[i];\\n            i++;\\n        }\\n\\n        sort(nums1.begin(), nums1.end());\\n    }\\n};\\n"
                    },
                    {
                        "username": "Anamaria_slay",
                        "content": "this was my first idea and it worked but I knew that this was not the solution that Leetcode had in mind, so I decided to use third array and do it like that, but I think that\\'s not what you\\'re supposed to do ether. "
                    },
                    {
                        "username": "kotokot",
                        "content": "O((n+m)*log(n+m)) complexity though"
                    },
                    {
                        "username": "vinjamury",
                        "content": "As per the description \"You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2\"\\nwhich means m >= n should be true.\\nBut Test case 57 is as below\\n[0]\\n0\\n[1]\\n1\\nwhere m < n. I think this is not correct. Any comments?"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Actually if u see clearly length of nums1 have enough space to store nums2 as well. whereas m is not length of nums1. If u try to print length of nums1 it will give value which is equal to m+n."
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I think it is incorrectly explained in the description.\\nHere, m is equal to n, and not less than n.\\nm & n are the number of elements in nums1 and nums2 respectively. (I believe)"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I've seen a few other short ones but they all still had some unnecessary stuff like `n>0` instead of just `n`. And many checked whether the next element comes from the second array, but it's slightly easier to check whether it comes from the first. Here's mine.\\n\\n    while (n) A[m+n-1] = m && A[m-1] > B[n-1] ? A[--m] : B[--n];\\n\\nAnd without the spaces:\\n\\n    while(n)A[m+n-1]=m&&A[m-1]>B[n-1]?A[--m]:B[--n];"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int last = m+n-1;\\n        int first = m-1;\\n        int second = n-1;\\n\\n\\n        while(first >=0 and second >= 0) {\\n\\n            if(nums1[first] > nums2[second]) {\\n                nums1[last] = nums1[first];\\n                first--;\\n                last--;\\n            }\\n            else {\\n                nums1[last] = nums2[second];\\n                second--;\\n                last--;\\n            }\\n        }\\n\\n        while(second >= 0) {\\n            nums1[last] = nums2[second];\\n            second--;\\n            last--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "omsky8",
                        "content": "[@invulnerability10000](/invulnerability10000) the third test case can be used for that loop where there are no elements in the array to be merged"
                    },
                    {
                        "username": "invulnerability10000",
                        "content": "What is the use of the last while loop? Can you give me a test case which puts it to any use?\\n"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "Can anyone tell me why so many people dislike this problem?"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "because its bugged"
                    },
                    {
                        "username": "justinmward",
                        "content": "This is far simpler without the trailing zeros in one of the inputs, and feels contrived and unnecessarily complicated. At least in python, storing data in this way is very much an antipattern."
                    },
                    {
                        "username": "elabraha",
                        "content": "I'm guessing that it's because the solution that beats out some solutions that are actually o(n + m) is an algorithm that sorts at the end. usually sorting the entire array of length n + m worst case is o((n+m)log(n+m)) complexity. It seems against intuition that that algorithm could beat a linear time algorithm that does not sort."
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "its simmple dont go for dislikes"
                    },
                    {
                        "username": "akjha",
                        "content": "nums1[0:m+n] = sorted(nums1[:m]+nums2[:n])"
                    },
                    {
                        "username": "calm27",
                        "content": "you know it would work at real interview"
                    },
                    {
                        "username": "dball1126",
                        "content": "Definitely a Leet Code problem, when you submit it won\\'t read the answer."
                    },
                    {
                        "username": "Aman2394",
                        "content": "nums1 = nums1[0:m]+nums2[0:n]\\nnums1.sort()"
                    },
                    {
                        "username": "harrisonseyounglee",
                        "content": "[@mishuo](/mishuo) i came up with the same solution but it doesnt work either....\\n"
                    },
                    {
                        "username": "perjorax",
                        "content": "[@mishuo](/mishuo) also i\\'m interested in the answer to why this doesn\\'t work"
                    },
                    {
                        "username": "mishuo",
                        "content": "I have the same answer, but it does not pass the test. Do you know the reason?"
                    }
                ]
            },
            {
                "id": 2049694,
                "content": [
                    {
                        "username": "AlteriusOmega",
                        "content": "If you\\'re using Python and having the issue where Leetcode claims your output is identical to the input even if printing your nums1 shows the correct answer, remember that the assignment operator \"=\" does not modify variables in place. It will always create a new local variable. So if you do something like nums1 = nums1[m:] then now you are no longer working with the same nums1 that was input as an argument, but a totally new variable with a different reference"
                    },
                    {
                        "username": "Neethu_Raju",
                        "content": "Why is the following code resulting in [1,2,3,0,0,0]?\\npublic void Merge(int[] nums1, int m, int[] nums2, int n)\\n        {\\n            var sortedArr1 = nums1.OrderBy(x => x).Where(x => x != 0).ToArray();\\n            var sortedArr2 = nums2.OrderBy(x => x).Where(x => x != 0).ToArray();\\n\\n            if (sortedArr1.Length == m && sortedArr2.Length == n) \\n            {\\n                var mergedArray = new int[m + n];\\n                sortedArr1.CopyTo(mergedArray, 0);\\n                sortedArr2.CopyTo(mergedArray, m);\\n\\n                var res = mergedArray.OrderBy(x => x).ToArray();\\n            }\\n\\n        }"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "Ok, my real question is: the sneaky solution using three pointers seems pretty unintuitive. \\n\\nHas anyone ever come up with this on-the fly in a real, live, in-person interview? It seems unlikely to me. If so, I\\'d love to hear how you think about problems."
                    },
                    {
                        "username": "Upsite",
                        "content": "On the fly I probably would have said merge and sort however, After I would have said there is probably another solution that is much better. If you look at this solution you can tell there is a better solution than merge and sort. I was working on this three day's figuring out the three pointer solution. I got really close but, I gave up because after the third day I have to move on to other solutions. I think as long as you look at the answer and understand the solution it's fine to look at a solution and 'give up'. sorry for ranting on this reply section just ignore it please #copium."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Only if you have solved similar problems before and memorized the merge algorithm."
                    },
                    {
                        "username": "ShubhamAmande",
                        "content": "Is Something Wrong with this sum my code runs properly  on local machine as well as any online complier But when I try to run here it shows wrong output"
                    },
                    {
                        "username": "lauradouglas2002",
                        "content": "When I print my nums1 array to terminal, it matches the correct answer; however, I a failing all test cases. Not sure why?\n \nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        //array to array list\n        ArrayList<Integer> output = new ArrayList<Integer>();\n        for(int x = 0; x < m; x++){\n            output.add(nums1[x]);\n        }\n        for(int j = 0; j < n; j++){\n            output.add(nums2[j]);\n        }\n        //arraylist to array   \n        nums1 = output.stream().mapToInt(a -> a).toArray();\n        Arrays.sort(nums1);\n    }\n}"
                    },
                    {
                        "username": "jxofix",
                        "content": "I have the same problem...did you solve it?"
                    },
                    {
                        "username": "Tch4lla",
                        "content": "How about instead of non decreasing order, you just say ascending ? It makes the description more convoluted than it needs to be"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Both are not same. In non decreasing next value can be equal to previous one which is not ascending order. Hope this explains your confusion."
                    },
                    {
                        "username": "pawel-kam",
                        "content": "About the test case where `nums1 = [0,0,3,0,0,0,0,0,0]`. How is it \\'sorted in a non-decreasing order\\', as the question states???"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Zeros after 3 are trailing zeros where u need to add the values u r taking from nums2. Actual values that nums1 contain is [0, 0, 3], which is in non decreasing order. Hope this explains ur question."
                    },
                    {
                        "username": "mythilikarra",
                        "content": "I have the same question?????"
                    },
                    {
                        "username": "sanjayts",
                        "content": "I\\'m not really sure what\\'s going on here but this logically incorrect attempt at solving this problem is giving me weird results and fails with an index out of range error:\\n\\n```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        p1, p2 = m - 1, n - 1\\n        current = m + n - 1\\n        while current >= 0:\\n            print(f\\'START LOOP -- p1={p1}, p2={p2}, current={current}\\')\\n            if nums1[p1] < nums2[p2]:\\n                nums1[current] = nums2[p2]\\n                p2 = max(0, p2 - 1)\\n            else:\\n                nums1[current] = nums1[p1]\\n                p1 = max(0, p1 - 1)            \\n            current -= 1\\n            print(f\\'END LOOP -- p1={p1}, p2={p2}, current={current}\\')\\n```\\nwhich prints \\n```\\nSTART LOOP -- p1=2, p2=2, current=5\\nEND LOOP -- p1=2, p2=1, current=4\\nSTART LOOP -- p1=2, p2=1, current=4\\nEND LOOP -- p1=2, p2=0, current=3\\nSTART LOOP -- p1=2, p2=0, current=3\\nEND LOOP -- p1=1, p2=0, current=2\\nSTART LOOP -- p1=1, p2=0, current=2\\nEND LOOP -- p1=0, p2=0, current=1\\nSTART LOOP -- p1=0, p2=0, current=1\\nEND LOOP -- p1=0, p2=0, current=0\\nSTART LOOP -- p1=0, p2=0, current=0\\nEND LOOP -- p1=0, p2=0, current=-1\\nSTART LOOP -- p1=0, p2=-1, current=0\\n```\\n\\n**Notice how the `current` loop variable jumps from -1 back to 0?** What\\'s going on here? The same code works (producing an incorrect result) without failure when executed locally."
                    },
                    {
                        "username": "nvinogr",
                        "content": "Did you get to the bottom of it? I\\'m getting a similar issue in Java."
                    },
                    {
                        "username": "praveenchats",
                        "content": "        System.arraycopy(nums2,0,nums1,m,n);\\n        Arrays.sort(nums1);"
                    },
                    {
                        "username": "beginner_7",
                        "content": "The question if a good one for the easy question and description is good"
                    }
                ]
            },
            {
                "id": 1774718,
                "content": [
                    {
                        "username": "AlteriusOmega",
                        "content": "If you\\'re using Python and having the issue where Leetcode claims your output is identical to the input even if printing your nums1 shows the correct answer, remember that the assignment operator \"=\" does not modify variables in place. It will always create a new local variable. So if you do something like nums1 = nums1[m:] then now you are no longer working with the same nums1 that was input as an argument, but a totally new variable with a different reference"
                    },
                    {
                        "username": "Neethu_Raju",
                        "content": "Why is the following code resulting in [1,2,3,0,0,0]?\\npublic void Merge(int[] nums1, int m, int[] nums2, int n)\\n        {\\n            var sortedArr1 = nums1.OrderBy(x => x).Where(x => x != 0).ToArray();\\n            var sortedArr2 = nums2.OrderBy(x => x).Where(x => x != 0).ToArray();\\n\\n            if (sortedArr1.Length == m && sortedArr2.Length == n) \\n            {\\n                var mergedArray = new int[m + n];\\n                sortedArr1.CopyTo(mergedArray, 0);\\n                sortedArr2.CopyTo(mergedArray, m);\\n\\n                var res = mergedArray.OrderBy(x => x).ToArray();\\n            }\\n\\n        }"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "Ok, my real question is: the sneaky solution using three pointers seems pretty unintuitive. \\n\\nHas anyone ever come up with this on-the fly in a real, live, in-person interview? It seems unlikely to me. If so, I\\'d love to hear how you think about problems."
                    },
                    {
                        "username": "Upsite",
                        "content": "On the fly I probably would have said merge and sort however, After I would have said there is probably another solution that is much better. If you look at this solution you can tell there is a better solution than merge and sort. I was working on this three day's figuring out the three pointer solution. I got really close but, I gave up because after the third day I have to move on to other solutions. I think as long as you look at the answer and understand the solution it's fine to look at a solution and 'give up'. sorry for ranting on this reply section just ignore it please #copium."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Only if you have solved similar problems before and memorized the merge algorithm."
                    },
                    {
                        "username": "ShubhamAmande",
                        "content": "Is Something Wrong with this sum my code runs properly  on local machine as well as any online complier But when I try to run here it shows wrong output"
                    },
                    {
                        "username": "lauradouglas2002",
                        "content": "When I print my nums1 array to terminal, it matches the correct answer; however, I a failing all test cases. Not sure why?\n \nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        //array to array list\n        ArrayList<Integer> output = new ArrayList<Integer>();\n        for(int x = 0; x < m; x++){\n            output.add(nums1[x]);\n        }\n        for(int j = 0; j < n; j++){\n            output.add(nums2[j]);\n        }\n        //arraylist to array   \n        nums1 = output.stream().mapToInt(a -> a).toArray();\n        Arrays.sort(nums1);\n    }\n}"
                    },
                    {
                        "username": "jxofix",
                        "content": "I have the same problem...did you solve it?"
                    },
                    {
                        "username": "Tch4lla",
                        "content": "How about instead of non decreasing order, you just say ascending ? It makes the description more convoluted than it needs to be"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Both are not same. In non decreasing next value can be equal to previous one which is not ascending order. Hope this explains your confusion."
                    },
                    {
                        "username": "pawel-kam",
                        "content": "About the test case where `nums1 = [0,0,3,0,0,0,0,0,0]`. How is it \\'sorted in a non-decreasing order\\', as the question states???"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Zeros after 3 are trailing zeros where u need to add the values u r taking from nums2. Actual values that nums1 contain is [0, 0, 3], which is in non decreasing order. Hope this explains ur question."
                    },
                    {
                        "username": "mythilikarra",
                        "content": "I have the same question?????"
                    },
                    {
                        "username": "sanjayts",
                        "content": "I\\'m not really sure what\\'s going on here but this logically incorrect attempt at solving this problem is giving me weird results and fails with an index out of range error:\\n\\n```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        p1, p2 = m - 1, n - 1\\n        current = m + n - 1\\n        while current >= 0:\\n            print(f\\'START LOOP -- p1={p1}, p2={p2}, current={current}\\')\\n            if nums1[p1] < nums2[p2]:\\n                nums1[current] = nums2[p2]\\n                p2 = max(0, p2 - 1)\\n            else:\\n                nums1[current] = nums1[p1]\\n                p1 = max(0, p1 - 1)            \\n            current -= 1\\n            print(f\\'END LOOP -- p1={p1}, p2={p2}, current={current}\\')\\n```\\nwhich prints \\n```\\nSTART LOOP -- p1=2, p2=2, current=5\\nEND LOOP -- p1=2, p2=1, current=4\\nSTART LOOP -- p1=2, p2=1, current=4\\nEND LOOP -- p1=2, p2=0, current=3\\nSTART LOOP -- p1=2, p2=0, current=3\\nEND LOOP -- p1=1, p2=0, current=2\\nSTART LOOP -- p1=1, p2=0, current=2\\nEND LOOP -- p1=0, p2=0, current=1\\nSTART LOOP -- p1=0, p2=0, current=1\\nEND LOOP -- p1=0, p2=0, current=0\\nSTART LOOP -- p1=0, p2=0, current=0\\nEND LOOP -- p1=0, p2=0, current=-1\\nSTART LOOP -- p1=0, p2=-1, current=0\\n```\\n\\n**Notice how the `current` loop variable jumps from -1 back to 0?** What\\'s going on here? The same code works (producing an incorrect result) without failure when executed locally."
                    },
                    {
                        "username": "nvinogr",
                        "content": "Did you get to the bottom of it? I\\'m getting a similar issue in Java."
                    },
                    {
                        "username": "praveenchats",
                        "content": "        System.arraycopy(nums2,0,nums1,m,n);\\n        Arrays.sort(nums1);"
                    },
                    {
                        "username": "beginner_7",
                        "content": "The question if a good one for the easy question and description is good"
                    }
                ]
            },
            {
                "id": 1569643,
                "content": [
                    {
                        "username": "AlteriusOmega",
                        "content": "If you\\'re using Python and having the issue where Leetcode claims your output is identical to the input even if printing your nums1 shows the correct answer, remember that the assignment operator \"=\" does not modify variables in place. It will always create a new local variable. So if you do something like nums1 = nums1[m:] then now you are no longer working with the same nums1 that was input as an argument, but a totally new variable with a different reference"
                    },
                    {
                        "username": "Neethu_Raju",
                        "content": "Why is the following code resulting in [1,2,3,0,0,0]?\\npublic void Merge(int[] nums1, int m, int[] nums2, int n)\\n        {\\n            var sortedArr1 = nums1.OrderBy(x => x).Where(x => x != 0).ToArray();\\n            var sortedArr2 = nums2.OrderBy(x => x).Where(x => x != 0).ToArray();\\n\\n            if (sortedArr1.Length == m && sortedArr2.Length == n) \\n            {\\n                var mergedArray = new int[m + n];\\n                sortedArr1.CopyTo(mergedArray, 0);\\n                sortedArr2.CopyTo(mergedArray, m);\\n\\n                var res = mergedArray.OrderBy(x => x).ToArray();\\n            }\\n\\n        }"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "Ok, my real question is: the sneaky solution using three pointers seems pretty unintuitive. \\n\\nHas anyone ever come up with this on-the fly in a real, live, in-person interview? It seems unlikely to me. If so, I\\'d love to hear how you think about problems."
                    },
                    {
                        "username": "Upsite",
                        "content": "On the fly I probably would have said merge and sort however, After I would have said there is probably another solution that is much better. If you look at this solution you can tell there is a better solution than merge and sort. I was working on this three day's figuring out the three pointer solution. I got really close but, I gave up because after the third day I have to move on to other solutions. I think as long as you look at the answer and understand the solution it's fine to look at a solution and 'give up'. sorry for ranting on this reply section just ignore it please #copium."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Only if you have solved similar problems before and memorized the merge algorithm."
                    },
                    {
                        "username": "ShubhamAmande",
                        "content": "Is Something Wrong with this sum my code runs properly  on local machine as well as any online complier But when I try to run here it shows wrong output"
                    },
                    {
                        "username": "lauradouglas2002",
                        "content": "When I print my nums1 array to terminal, it matches the correct answer; however, I a failing all test cases. Not sure why?\n \nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        //array to array list\n        ArrayList<Integer> output = new ArrayList<Integer>();\n        for(int x = 0; x < m; x++){\n            output.add(nums1[x]);\n        }\n        for(int j = 0; j < n; j++){\n            output.add(nums2[j]);\n        }\n        //arraylist to array   \n        nums1 = output.stream().mapToInt(a -> a).toArray();\n        Arrays.sort(nums1);\n    }\n}"
                    },
                    {
                        "username": "jxofix",
                        "content": "I have the same problem...did you solve it?"
                    },
                    {
                        "username": "Tch4lla",
                        "content": "How about instead of non decreasing order, you just say ascending ? It makes the description more convoluted than it needs to be"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Both are not same. In non decreasing next value can be equal to previous one which is not ascending order. Hope this explains your confusion."
                    },
                    {
                        "username": "pawel-kam",
                        "content": "About the test case where `nums1 = [0,0,3,0,0,0,0,0,0]`. How is it \\'sorted in a non-decreasing order\\', as the question states???"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Zeros after 3 are trailing zeros where u need to add the values u r taking from nums2. Actual values that nums1 contain is [0, 0, 3], which is in non decreasing order. Hope this explains ur question."
                    },
                    {
                        "username": "mythilikarra",
                        "content": "I have the same question?????"
                    },
                    {
                        "username": "sanjayts",
                        "content": "I\\'m not really sure what\\'s going on here but this logically incorrect attempt at solving this problem is giving me weird results and fails with an index out of range error:\\n\\n```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        p1, p2 = m - 1, n - 1\\n        current = m + n - 1\\n        while current >= 0:\\n            print(f\\'START LOOP -- p1={p1}, p2={p2}, current={current}\\')\\n            if nums1[p1] < nums2[p2]:\\n                nums1[current] = nums2[p2]\\n                p2 = max(0, p2 - 1)\\n            else:\\n                nums1[current] = nums1[p1]\\n                p1 = max(0, p1 - 1)            \\n            current -= 1\\n            print(f\\'END LOOP -- p1={p1}, p2={p2}, current={current}\\')\\n```\\nwhich prints \\n```\\nSTART LOOP -- p1=2, p2=2, current=5\\nEND LOOP -- p1=2, p2=1, current=4\\nSTART LOOP -- p1=2, p2=1, current=4\\nEND LOOP -- p1=2, p2=0, current=3\\nSTART LOOP -- p1=2, p2=0, current=3\\nEND LOOP -- p1=1, p2=0, current=2\\nSTART LOOP -- p1=1, p2=0, current=2\\nEND LOOP -- p1=0, p2=0, current=1\\nSTART LOOP -- p1=0, p2=0, current=1\\nEND LOOP -- p1=0, p2=0, current=0\\nSTART LOOP -- p1=0, p2=0, current=0\\nEND LOOP -- p1=0, p2=0, current=-1\\nSTART LOOP -- p1=0, p2=-1, current=0\\n```\\n\\n**Notice how the `current` loop variable jumps from -1 back to 0?** What\\'s going on here? The same code works (producing an incorrect result) without failure when executed locally."
                    },
                    {
                        "username": "nvinogr",
                        "content": "Did you get to the bottom of it? I\\'m getting a similar issue in Java."
                    },
                    {
                        "username": "praveenchats",
                        "content": "        System.arraycopy(nums2,0,nums1,m,n);\\n        Arrays.sort(nums1);"
                    },
                    {
                        "username": "beginner_7",
                        "content": "The question if a good one for the easy question and description is good"
                    }
                ]
            },
            {
                "id": 1965182,
                "content": [
                    {
                        "username": "AlteriusOmega",
                        "content": "If you\\'re using Python and having the issue where Leetcode claims your output is identical to the input even if printing your nums1 shows the correct answer, remember that the assignment operator \"=\" does not modify variables in place. It will always create a new local variable. So if you do something like nums1 = nums1[m:] then now you are no longer working with the same nums1 that was input as an argument, but a totally new variable with a different reference"
                    },
                    {
                        "username": "Neethu_Raju",
                        "content": "Why is the following code resulting in [1,2,3,0,0,0]?\\npublic void Merge(int[] nums1, int m, int[] nums2, int n)\\n        {\\n            var sortedArr1 = nums1.OrderBy(x => x).Where(x => x != 0).ToArray();\\n            var sortedArr2 = nums2.OrderBy(x => x).Where(x => x != 0).ToArray();\\n\\n            if (sortedArr1.Length == m && sortedArr2.Length == n) \\n            {\\n                var mergedArray = new int[m + n];\\n                sortedArr1.CopyTo(mergedArray, 0);\\n                sortedArr2.CopyTo(mergedArray, m);\\n\\n                var res = mergedArray.OrderBy(x => x).ToArray();\\n            }\\n\\n        }"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "Ok, my real question is: the sneaky solution using three pointers seems pretty unintuitive. \\n\\nHas anyone ever come up with this on-the fly in a real, live, in-person interview? It seems unlikely to me. If so, I\\'d love to hear how you think about problems."
                    },
                    {
                        "username": "Upsite",
                        "content": "On the fly I probably would have said merge and sort however, After I would have said there is probably another solution that is much better. If you look at this solution you can tell there is a better solution than merge and sort. I was working on this three day's figuring out the three pointer solution. I got really close but, I gave up because after the third day I have to move on to other solutions. I think as long as you look at the answer and understand the solution it's fine to look at a solution and 'give up'. sorry for ranting on this reply section just ignore it please #copium."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Only if you have solved similar problems before and memorized the merge algorithm."
                    },
                    {
                        "username": "ShubhamAmande",
                        "content": "Is Something Wrong with this sum my code runs properly  on local machine as well as any online complier But when I try to run here it shows wrong output"
                    },
                    {
                        "username": "lauradouglas2002",
                        "content": "When I print my nums1 array to terminal, it matches the correct answer; however, I a failing all test cases. Not sure why?\n \nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        //array to array list\n        ArrayList<Integer> output = new ArrayList<Integer>();\n        for(int x = 0; x < m; x++){\n            output.add(nums1[x]);\n        }\n        for(int j = 0; j < n; j++){\n            output.add(nums2[j]);\n        }\n        //arraylist to array   \n        nums1 = output.stream().mapToInt(a -> a).toArray();\n        Arrays.sort(nums1);\n    }\n}"
                    },
                    {
                        "username": "jxofix",
                        "content": "I have the same problem...did you solve it?"
                    },
                    {
                        "username": "Tch4lla",
                        "content": "How about instead of non decreasing order, you just say ascending ? It makes the description more convoluted than it needs to be"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Both are not same. In non decreasing next value can be equal to previous one which is not ascending order. Hope this explains your confusion."
                    },
                    {
                        "username": "pawel-kam",
                        "content": "About the test case where `nums1 = [0,0,3,0,0,0,0,0,0]`. How is it \\'sorted in a non-decreasing order\\', as the question states???"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Zeros after 3 are trailing zeros where u need to add the values u r taking from nums2. Actual values that nums1 contain is [0, 0, 3], which is in non decreasing order. Hope this explains ur question."
                    },
                    {
                        "username": "mythilikarra",
                        "content": "I have the same question?????"
                    },
                    {
                        "username": "sanjayts",
                        "content": "I\\'m not really sure what\\'s going on here but this logically incorrect attempt at solving this problem is giving me weird results and fails with an index out of range error:\\n\\n```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        p1, p2 = m - 1, n - 1\\n        current = m + n - 1\\n        while current >= 0:\\n            print(f\\'START LOOP -- p1={p1}, p2={p2}, current={current}\\')\\n            if nums1[p1] < nums2[p2]:\\n                nums1[current] = nums2[p2]\\n                p2 = max(0, p2 - 1)\\n            else:\\n                nums1[current] = nums1[p1]\\n                p1 = max(0, p1 - 1)            \\n            current -= 1\\n            print(f\\'END LOOP -- p1={p1}, p2={p2}, current={current}\\')\\n```\\nwhich prints \\n```\\nSTART LOOP -- p1=2, p2=2, current=5\\nEND LOOP -- p1=2, p2=1, current=4\\nSTART LOOP -- p1=2, p2=1, current=4\\nEND LOOP -- p1=2, p2=0, current=3\\nSTART LOOP -- p1=2, p2=0, current=3\\nEND LOOP -- p1=1, p2=0, current=2\\nSTART LOOP -- p1=1, p2=0, current=2\\nEND LOOP -- p1=0, p2=0, current=1\\nSTART LOOP -- p1=0, p2=0, current=1\\nEND LOOP -- p1=0, p2=0, current=0\\nSTART LOOP -- p1=0, p2=0, current=0\\nEND LOOP -- p1=0, p2=0, current=-1\\nSTART LOOP -- p1=0, p2=-1, current=0\\n```\\n\\n**Notice how the `current` loop variable jumps from -1 back to 0?** What\\'s going on here? The same code works (producing an incorrect result) without failure when executed locally."
                    },
                    {
                        "username": "nvinogr",
                        "content": "Did you get to the bottom of it? I\\'m getting a similar issue in Java."
                    },
                    {
                        "username": "praveenchats",
                        "content": "        System.arraycopy(nums2,0,nums1,m,n);\\n        Arrays.sort(nums1);"
                    },
                    {
                        "username": "beginner_7",
                        "content": "The question if a good one for the easy question and description is good"
                    }
                ]
            },
            {
                "id": 1891512,
                "content": [
                    {
                        "username": "AlteriusOmega",
                        "content": "If you\\'re using Python and having the issue where Leetcode claims your output is identical to the input even if printing your nums1 shows the correct answer, remember that the assignment operator \"=\" does not modify variables in place. It will always create a new local variable. So if you do something like nums1 = nums1[m:] then now you are no longer working with the same nums1 that was input as an argument, but a totally new variable with a different reference"
                    },
                    {
                        "username": "Neethu_Raju",
                        "content": "Why is the following code resulting in [1,2,3,0,0,0]?\\npublic void Merge(int[] nums1, int m, int[] nums2, int n)\\n        {\\n            var sortedArr1 = nums1.OrderBy(x => x).Where(x => x != 0).ToArray();\\n            var sortedArr2 = nums2.OrderBy(x => x).Where(x => x != 0).ToArray();\\n\\n            if (sortedArr1.Length == m && sortedArr2.Length == n) \\n            {\\n                var mergedArray = new int[m + n];\\n                sortedArr1.CopyTo(mergedArray, 0);\\n                sortedArr2.CopyTo(mergedArray, m);\\n\\n                var res = mergedArray.OrderBy(x => x).ToArray();\\n            }\\n\\n        }"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "Ok, my real question is: the sneaky solution using three pointers seems pretty unintuitive. \\n\\nHas anyone ever come up with this on-the fly in a real, live, in-person interview? It seems unlikely to me. If so, I\\'d love to hear how you think about problems."
                    },
                    {
                        "username": "Upsite",
                        "content": "On the fly I probably would have said merge and sort however, After I would have said there is probably another solution that is much better. If you look at this solution you can tell there is a better solution than merge and sort. I was working on this three day's figuring out the three pointer solution. I got really close but, I gave up because after the third day I have to move on to other solutions. I think as long as you look at the answer and understand the solution it's fine to look at a solution and 'give up'. sorry for ranting on this reply section just ignore it please #copium."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Only if you have solved similar problems before and memorized the merge algorithm."
                    },
                    {
                        "username": "ShubhamAmande",
                        "content": "Is Something Wrong with this sum my code runs properly  on local machine as well as any online complier But when I try to run here it shows wrong output"
                    },
                    {
                        "username": "lauradouglas2002",
                        "content": "When I print my nums1 array to terminal, it matches the correct answer; however, I a failing all test cases. Not sure why?\n \nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        //array to array list\n        ArrayList<Integer> output = new ArrayList<Integer>();\n        for(int x = 0; x < m; x++){\n            output.add(nums1[x]);\n        }\n        for(int j = 0; j < n; j++){\n            output.add(nums2[j]);\n        }\n        //arraylist to array   \n        nums1 = output.stream().mapToInt(a -> a).toArray();\n        Arrays.sort(nums1);\n    }\n}"
                    },
                    {
                        "username": "jxofix",
                        "content": "I have the same problem...did you solve it?"
                    },
                    {
                        "username": "Tch4lla",
                        "content": "How about instead of non decreasing order, you just say ascending ? It makes the description more convoluted than it needs to be"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Both are not same. In non decreasing next value can be equal to previous one which is not ascending order. Hope this explains your confusion."
                    },
                    {
                        "username": "pawel-kam",
                        "content": "About the test case where `nums1 = [0,0,3,0,0,0,0,0,0]`. How is it \\'sorted in a non-decreasing order\\', as the question states???"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Zeros after 3 are trailing zeros where u need to add the values u r taking from nums2. Actual values that nums1 contain is [0, 0, 3], which is in non decreasing order. Hope this explains ur question."
                    },
                    {
                        "username": "mythilikarra",
                        "content": "I have the same question?????"
                    },
                    {
                        "username": "sanjayts",
                        "content": "I\\'m not really sure what\\'s going on here but this logically incorrect attempt at solving this problem is giving me weird results and fails with an index out of range error:\\n\\n```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        p1, p2 = m - 1, n - 1\\n        current = m + n - 1\\n        while current >= 0:\\n            print(f\\'START LOOP -- p1={p1}, p2={p2}, current={current}\\')\\n            if nums1[p1] < nums2[p2]:\\n                nums1[current] = nums2[p2]\\n                p2 = max(0, p2 - 1)\\n            else:\\n                nums1[current] = nums1[p1]\\n                p1 = max(0, p1 - 1)            \\n            current -= 1\\n            print(f\\'END LOOP -- p1={p1}, p2={p2}, current={current}\\')\\n```\\nwhich prints \\n```\\nSTART LOOP -- p1=2, p2=2, current=5\\nEND LOOP -- p1=2, p2=1, current=4\\nSTART LOOP -- p1=2, p2=1, current=4\\nEND LOOP -- p1=2, p2=0, current=3\\nSTART LOOP -- p1=2, p2=0, current=3\\nEND LOOP -- p1=1, p2=0, current=2\\nSTART LOOP -- p1=1, p2=0, current=2\\nEND LOOP -- p1=0, p2=0, current=1\\nSTART LOOP -- p1=0, p2=0, current=1\\nEND LOOP -- p1=0, p2=0, current=0\\nSTART LOOP -- p1=0, p2=0, current=0\\nEND LOOP -- p1=0, p2=0, current=-1\\nSTART LOOP -- p1=0, p2=-1, current=0\\n```\\n\\n**Notice how the `current` loop variable jumps from -1 back to 0?** What\\'s going on here? The same code works (producing an incorrect result) without failure when executed locally."
                    },
                    {
                        "username": "nvinogr",
                        "content": "Did you get to the bottom of it? I\\'m getting a similar issue in Java."
                    },
                    {
                        "username": "praveenchats",
                        "content": "        System.arraycopy(nums2,0,nums1,m,n);\\n        Arrays.sort(nums1);"
                    },
                    {
                        "username": "beginner_7",
                        "content": "The question if a good one for the easy question and description is good"
                    }
                ]
            },
            {
                "id": 1839978,
                "content": [
                    {
                        "username": "AlteriusOmega",
                        "content": "If you\\'re using Python and having the issue where Leetcode claims your output is identical to the input even if printing your nums1 shows the correct answer, remember that the assignment operator \"=\" does not modify variables in place. It will always create a new local variable. So if you do something like nums1 = nums1[m:] then now you are no longer working with the same nums1 that was input as an argument, but a totally new variable with a different reference"
                    },
                    {
                        "username": "Neethu_Raju",
                        "content": "Why is the following code resulting in [1,2,3,0,0,0]?\\npublic void Merge(int[] nums1, int m, int[] nums2, int n)\\n        {\\n            var sortedArr1 = nums1.OrderBy(x => x).Where(x => x != 0).ToArray();\\n            var sortedArr2 = nums2.OrderBy(x => x).Where(x => x != 0).ToArray();\\n\\n            if (sortedArr1.Length == m && sortedArr2.Length == n) \\n            {\\n                var mergedArray = new int[m + n];\\n                sortedArr1.CopyTo(mergedArray, 0);\\n                sortedArr2.CopyTo(mergedArray, m);\\n\\n                var res = mergedArray.OrderBy(x => x).ToArray();\\n            }\\n\\n        }"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "Ok, my real question is: the sneaky solution using three pointers seems pretty unintuitive. \\n\\nHas anyone ever come up with this on-the fly in a real, live, in-person interview? It seems unlikely to me. If so, I\\'d love to hear how you think about problems."
                    },
                    {
                        "username": "Upsite",
                        "content": "On the fly I probably would have said merge and sort however, After I would have said there is probably another solution that is much better. If you look at this solution you can tell there is a better solution than merge and sort. I was working on this three day's figuring out the three pointer solution. I got really close but, I gave up because after the third day I have to move on to other solutions. I think as long as you look at the answer and understand the solution it's fine to look at a solution and 'give up'. sorry for ranting on this reply section just ignore it please #copium."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Only if you have solved similar problems before and memorized the merge algorithm."
                    },
                    {
                        "username": "ShubhamAmande",
                        "content": "Is Something Wrong with this sum my code runs properly  on local machine as well as any online complier But when I try to run here it shows wrong output"
                    },
                    {
                        "username": "lauradouglas2002",
                        "content": "When I print my nums1 array to terminal, it matches the correct answer; however, I a failing all test cases. Not sure why?\n \nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        //array to array list\n        ArrayList<Integer> output = new ArrayList<Integer>();\n        for(int x = 0; x < m; x++){\n            output.add(nums1[x]);\n        }\n        for(int j = 0; j < n; j++){\n            output.add(nums2[j]);\n        }\n        //arraylist to array   \n        nums1 = output.stream().mapToInt(a -> a).toArray();\n        Arrays.sort(nums1);\n    }\n}"
                    },
                    {
                        "username": "jxofix",
                        "content": "I have the same problem...did you solve it?"
                    },
                    {
                        "username": "Tch4lla",
                        "content": "How about instead of non decreasing order, you just say ascending ? It makes the description more convoluted than it needs to be"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Both are not same. In non decreasing next value can be equal to previous one which is not ascending order. Hope this explains your confusion."
                    },
                    {
                        "username": "pawel-kam",
                        "content": "About the test case where `nums1 = [0,0,3,0,0,0,0,0,0]`. How is it \\'sorted in a non-decreasing order\\', as the question states???"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Zeros after 3 are trailing zeros where u need to add the values u r taking from nums2. Actual values that nums1 contain is [0, 0, 3], which is in non decreasing order. Hope this explains ur question."
                    },
                    {
                        "username": "mythilikarra",
                        "content": "I have the same question?????"
                    },
                    {
                        "username": "sanjayts",
                        "content": "I\\'m not really sure what\\'s going on here but this logically incorrect attempt at solving this problem is giving me weird results and fails with an index out of range error:\\n\\n```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        p1, p2 = m - 1, n - 1\\n        current = m + n - 1\\n        while current >= 0:\\n            print(f\\'START LOOP -- p1={p1}, p2={p2}, current={current}\\')\\n            if nums1[p1] < nums2[p2]:\\n                nums1[current] = nums2[p2]\\n                p2 = max(0, p2 - 1)\\n            else:\\n                nums1[current] = nums1[p1]\\n                p1 = max(0, p1 - 1)            \\n            current -= 1\\n            print(f\\'END LOOP -- p1={p1}, p2={p2}, current={current}\\')\\n```\\nwhich prints \\n```\\nSTART LOOP -- p1=2, p2=2, current=5\\nEND LOOP -- p1=2, p2=1, current=4\\nSTART LOOP -- p1=2, p2=1, current=4\\nEND LOOP -- p1=2, p2=0, current=3\\nSTART LOOP -- p1=2, p2=0, current=3\\nEND LOOP -- p1=1, p2=0, current=2\\nSTART LOOP -- p1=1, p2=0, current=2\\nEND LOOP -- p1=0, p2=0, current=1\\nSTART LOOP -- p1=0, p2=0, current=1\\nEND LOOP -- p1=0, p2=0, current=0\\nSTART LOOP -- p1=0, p2=0, current=0\\nEND LOOP -- p1=0, p2=0, current=-1\\nSTART LOOP -- p1=0, p2=-1, current=0\\n```\\n\\n**Notice how the `current` loop variable jumps from -1 back to 0?** What\\'s going on here? The same code works (producing an incorrect result) without failure when executed locally."
                    },
                    {
                        "username": "nvinogr",
                        "content": "Did you get to the bottom of it? I\\'m getting a similar issue in Java."
                    },
                    {
                        "username": "praveenchats",
                        "content": "        System.arraycopy(nums2,0,nums1,m,n);\\n        Arrays.sort(nums1);"
                    },
                    {
                        "username": "beginner_7",
                        "content": "The question if a good one for the easy question and description is good"
                    }
                ]
            },
            {
                "id": 1836580,
                "content": [
                    {
                        "username": "AlteriusOmega",
                        "content": "If you\\'re using Python and having the issue where Leetcode claims your output is identical to the input even if printing your nums1 shows the correct answer, remember that the assignment operator \"=\" does not modify variables in place. It will always create a new local variable. So if you do something like nums1 = nums1[m:] then now you are no longer working with the same nums1 that was input as an argument, but a totally new variable with a different reference"
                    },
                    {
                        "username": "Neethu_Raju",
                        "content": "Why is the following code resulting in [1,2,3,0,0,0]?\\npublic void Merge(int[] nums1, int m, int[] nums2, int n)\\n        {\\n            var sortedArr1 = nums1.OrderBy(x => x).Where(x => x != 0).ToArray();\\n            var sortedArr2 = nums2.OrderBy(x => x).Where(x => x != 0).ToArray();\\n\\n            if (sortedArr1.Length == m && sortedArr2.Length == n) \\n            {\\n                var mergedArray = new int[m + n];\\n                sortedArr1.CopyTo(mergedArray, 0);\\n                sortedArr2.CopyTo(mergedArray, m);\\n\\n                var res = mergedArray.OrderBy(x => x).ToArray();\\n            }\\n\\n        }"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "Ok, my real question is: the sneaky solution using three pointers seems pretty unintuitive. \\n\\nHas anyone ever come up with this on-the fly in a real, live, in-person interview? It seems unlikely to me. If so, I\\'d love to hear how you think about problems."
                    },
                    {
                        "username": "Upsite",
                        "content": "On the fly I probably would have said merge and sort however, After I would have said there is probably another solution that is much better. If you look at this solution you can tell there is a better solution than merge and sort. I was working on this three day's figuring out the three pointer solution. I got really close but, I gave up because after the third day I have to move on to other solutions. I think as long as you look at the answer and understand the solution it's fine to look at a solution and 'give up'. sorry for ranting on this reply section just ignore it please #copium."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Only if you have solved similar problems before and memorized the merge algorithm."
                    },
                    {
                        "username": "ShubhamAmande",
                        "content": "Is Something Wrong with this sum my code runs properly  on local machine as well as any online complier But when I try to run here it shows wrong output"
                    },
                    {
                        "username": "lauradouglas2002",
                        "content": "When I print my nums1 array to terminal, it matches the correct answer; however, I a failing all test cases. Not sure why?\n \nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        //array to array list\n        ArrayList<Integer> output = new ArrayList<Integer>();\n        for(int x = 0; x < m; x++){\n            output.add(nums1[x]);\n        }\n        for(int j = 0; j < n; j++){\n            output.add(nums2[j]);\n        }\n        //arraylist to array   \n        nums1 = output.stream().mapToInt(a -> a).toArray();\n        Arrays.sort(nums1);\n    }\n}"
                    },
                    {
                        "username": "jxofix",
                        "content": "I have the same problem...did you solve it?"
                    },
                    {
                        "username": "Tch4lla",
                        "content": "How about instead of non decreasing order, you just say ascending ? It makes the description more convoluted than it needs to be"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Both are not same. In non decreasing next value can be equal to previous one which is not ascending order. Hope this explains your confusion."
                    },
                    {
                        "username": "pawel-kam",
                        "content": "About the test case where `nums1 = [0,0,3,0,0,0,0,0,0]`. How is it \\'sorted in a non-decreasing order\\', as the question states???"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Zeros after 3 are trailing zeros where u need to add the values u r taking from nums2. Actual values that nums1 contain is [0, 0, 3], which is in non decreasing order. Hope this explains ur question."
                    },
                    {
                        "username": "mythilikarra",
                        "content": "I have the same question?????"
                    },
                    {
                        "username": "sanjayts",
                        "content": "I\\'m not really sure what\\'s going on here but this logically incorrect attempt at solving this problem is giving me weird results and fails with an index out of range error:\\n\\n```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        p1, p2 = m - 1, n - 1\\n        current = m + n - 1\\n        while current >= 0:\\n            print(f\\'START LOOP -- p1={p1}, p2={p2}, current={current}\\')\\n            if nums1[p1] < nums2[p2]:\\n                nums1[current] = nums2[p2]\\n                p2 = max(0, p2 - 1)\\n            else:\\n                nums1[current] = nums1[p1]\\n                p1 = max(0, p1 - 1)            \\n            current -= 1\\n            print(f\\'END LOOP -- p1={p1}, p2={p2}, current={current}\\')\\n```\\nwhich prints \\n```\\nSTART LOOP -- p1=2, p2=2, current=5\\nEND LOOP -- p1=2, p2=1, current=4\\nSTART LOOP -- p1=2, p2=1, current=4\\nEND LOOP -- p1=2, p2=0, current=3\\nSTART LOOP -- p1=2, p2=0, current=3\\nEND LOOP -- p1=1, p2=0, current=2\\nSTART LOOP -- p1=1, p2=0, current=2\\nEND LOOP -- p1=0, p2=0, current=1\\nSTART LOOP -- p1=0, p2=0, current=1\\nEND LOOP -- p1=0, p2=0, current=0\\nSTART LOOP -- p1=0, p2=0, current=0\\nEND LOOP -- p1=0, p2=0, current=-1\\nSTART LOOP -- p1=0, p2=-1, current=0\\n```\\n\\n**Notice how the `current` loop variable jumps from -1 back to 0?** What\\'s going on here? The same code works (producing an incorrect result) without failure when executed locally."
                    },
                    {
                        "username": "nvinogr",
                        "content": "Did you get to the bottom of it? I\\'m getting a similar issue in Java."
                    },
                    {
                        "username": "praveenchats",
                        "content": "        System.arraycopy(nums2,0,nums1,m,n);\\n        Arrays.sort(nums1);"
                    },
                    {
                        "username": "beginner_7",
                        "content": "The question if a good one for the easy question and description is good"
                    }
                ]
            },
            {
                "id": 1798615,
                "content": [
                    {
                        "username": "AlteriusOmega",
                        "content": "If you\\'re using Python and having the issue where Leetcode claims your output is identical to the input even if printing your nums1 shows the correct answer, remember that the assignment operator \"=\" does not modify variables in place. It will always create a new local variable. So if you do something like nums1 = nums1[m:] then now you are no longer working with the same nums1 that was input as an argument, but a totally new variable with a different reference"
                    },
                    {
                        "username": "Neethu_Raju",
                        "content": "Why is the following code resulting in [1,2,3,0,0,0]?\\npublic void Merge(int[] nums1, int m, int[] nums2, int n)\\n        {\\n            var sortedArr1 = nums1.OrderBy(x => x).Where(x => x != 0).ToArray();\\n            var sortedArr2 = nums2.OrderBy(x => x).Where(x => x != 0).ToArray();\\n\\n            if (sortedArr1.Length == m && sortedArr2.Length == n) \\n            {\\n                var mergedArray = new int[m + n];\\n                sortedArr1.CopyTo(mergedArray, 0);\\n                sortedArr2.CopyTo(mergedArray, m);\\n\\n                var res = mergedArray.OrderBy(x => x).ToArray();\\n            }\\n\\n        }"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "Ok, my real question is: the sneaky solution using three pointers seems pretty unintuitive. \\n\\nHas anyone ever come up with this on-the fly in a real, live, in-person interview? It seems unlikely to me. If so, I\\'d love to hear how you think about problems."
                    },
                    {
                        "username": "Upsite",
                        "content": "On the fly I probably would have said merge and sort however, After I would have said there is probably another solution that is much better. If you look at this solution you can tell there is a better solution than merge and sort. I was working on this three day's figuring out the three pointer solution. I got really close but, I gave up because after the third day I have to move on to other solutions. I think as long as you look at the answer and understand the solution it's fine to look at a solution and 'give up'. sorry for ranting on this reply section just ignore it please #copium."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Only if you have solved similar problems before and memorized the merge algorithm."
                    },
                    {
                        "username": "ShubhamAmande",
                        "content": "Is Something Wrong with this sum my code runs properly  on local machine as well as any online complier But when I try to run here it shows wrong output"
                    },
                    {
                        "username": "lauradouglas2002",
                        "content": "When I print my nums1 array to terminal, it matches the correct answer; however, I a failing all test cases. Not sure why?\n \nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        //array to array list\n        ArrayList<Integer> output = new ArrayList<Integer>();\n        for(int x = 0; x < m; x++){\n            output.add(nums1[x]);\n        }\n        for(int j = 0; j < n; j++){\n            output.add(nums2[j]);\n        }\n        //arraylist to array   \n        nums1 = output.stream().mapToInt(a -> a).toArray();\n        Arrays.sort(nums1);\n    }\n}"
                    },
                    {
                        "username": "jxofix",
                        "content": "I have the same problem...did you solve it?"
                    },
                    {
                        "username": "Tch4lla",
                        "content": "How about instead of non decreasing order, you just say ascending ? It makes the description more convoluted than it needs to be"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Both are not same. In non decreasing next value can be equal to previous one which is not ascending order. Hope this explains your confusion."
                    },
                    {
                        "username": "pawel-kam",
                        "content": "About the test case where `nums1 = [0,0,3,0,0,0,0,0,0]`. How is it \\'sorted in a non-decreasing order\\', as the question states???"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Zeros after 3 are trailing zeros where u need to add the values u r taking from nums2. Actual values that nums1 contain is [0, 0, 3], which is in non decreasing order. Hope this explains ur question."
                    },
                    {
                        "username": "mythilikarra",
                        "content": "I have the same question?????"
                    },
                    {
                        "username": "sanjayts",
                        "content": "I\\'m not really sure what\\'s going on here but this logically incorrect attempt at solving this problem is giving me weird results and fails with an index out of range error:\\n\\n```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        p1, p2 = m - 1, n - 1\\n        current = m + n - 1\\n        while current >= 0:\\n            print(f\\'START LOOP -- p1={p1}, p2={p2}, current={current}\\')\\n            if nums1[p1] < nums2[p2]:\\n                nums1[current] = nums2[p2]\\n                p2 = max(0, p2 - 1)\\n            else:\\n                nums1[current] = nums1[p1]\\n                p1 = max(0, p1 - 1)            \\n            current -= 1\\n            print(f\\'END LOOP -- p1={p1}, p2={p2}, current={current}\\')\\n```\\nwhich prints \\n```\\nSTART LOOP -- p1=2, p2=2, current=5\\nEND LOOP -- p1=2, p2=1, current=4\\nSTART LOOP -- p1=2, p2=1, current=4\\nEND LOOP -- p1=2, p2=0, current=3\\nSTART LOOP -- p1=2, p2=0, current=3\\nEND LOOP -- p1=1, p2=0, current=2\\nSTART LOOP -- p1=1, p2=0, current=2\\nEND LOOP -- p1=0, p2=0, current=1\\nSTART LOOP -- p1=0, p2=0, current=1\\nEND LOOP -- p1=0, p2=0, current=0\\nSTART LOOP -- p1=0, p2=0, current=0\\nEND LOOP -- p1=0, p2=0, current=-1\\nSTART LOOP -- p1=0, p2=-1, current=0\\n```\\n\\n**Notice how the `current` loop variable jumps from -1 back to 0?** What\\'s going on here? The same code works (producing an incorrect result) without failure when executed locally."
                    },
                    {
                        "username": "nvinogr",
                        "content": "Did you get to the bottom of it? I\\'m getting a similar issue in Java."
                    },
                    {
                        "username": "praveenchats",
                        "content": "        System.arraycopy(nums2,0,nums1,m,n);\\n        Arrays.sort(nums1);"
                    },
                    {
                        "username": "beginner_7",
                        "content": "The question if a good one for the easy question and description is good"
                    }
                ]
            },
            {
                "id": 1670585,
                "content": [
                    {
                        "username": "AlteriusOmega",
                        "content": "If you\\'re using Python and having the issue where Leetcode claims your output is identical to the input even if printing your nums1 shows the correct answer, remember that the assignment operator \"=\" does not modify variables in place. It will always create a new local variable. So if you do something like nums1 = nums1[m:] then now you are no longer working with the same nums1 that was input as an argument, but a totally new variable with a different reference"
                    },
                    {
                        "username": "Neethu_Raju",
                        "content": "Why is the following code resulting in [1,2,3,0,0,0]?\\npublic void Merge(int[] nums1, int m, int[] nums2, int n)\\n        {\\n            var sortedArr1 = nums1.OrderBy(x => x).Where(x => x != 0).ToArray();\\n            var sortedArr2 = nums2.OrderBy(x => x).Where(x => x != 0).ToArray();\\n\\n            if (sortedArr1.Length == m && sortedArr2.Length == n) \\n            {\\n                var mergedArray = new int[m + n];\\n                sortedArr1.CopyTo(mergedArray, 0);\\n                sortedArr2.CopyTo(mergedArray, m);\\n\\n                var res = mergedArray.OrderBy(x => x).ToArray();\\n            }\\n\\n        }"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "Ok, my real question is: the sneaky solution using three pointers seems pretty unintuitive. \\n\\nHas anyone ever come up with this on-the fly in a real, live, in-person interview? It seems unlikely to me. If so, I\\'d love to hear how you think about problems."
                    },
                    {
                        "username": "Upsite",
                        "content": "On the fly I probably would have said merge and sort however, After I would have said there is probably another solution that is much better. If you look at this solution you can tell there is a better solution than merge and sort. I was working on this three day's figuring out the three pointer solution. I got really close but, I gave up because after the third day I have to move on to other solutions. I think as long as you look at the answer and understand the solution it's fine to look at a solution and 'give up'. sorry for ranting on this reply section just ignore it please #copium."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Only if you have solved similar problems before and memorized the merge algorithm."
                    },
                    {
                        "username": "ShubhamAmande",
                        "content": "Is Something Wrong with this sum my code runs properly  on local machine as well as any online complier But when I try to run here it shows wrong output"
                    },
                    {
                        "username": "lauradouglas2002",
                        "content": "When I print my nums1 array to terminal, it matches the correct answer; however, I a failing all test cases. Not sure why?\n \nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        //array to array list\n        ArrayList<Integer> output = new ArrayList<Integer>();\n        for(int x = 0; x < m; x++){\n            output.add(nums1[x]);\n        }\n        for(int j = 0; j < n; j++){\n            output.add(nums2[j]);\n        }\n        //arraylist to array   \n        nums1 = output.stream().mapToInt(a -> a).toArray();\n        Arrays.sort(nums1);\n    }\n}"
                    },
                    {
                        "username": "jxofix",
                        "content": "I have the same problem...did you solve it?"
                    },
                    {
                        "username": "Tch4lla",
                        "content": "How about instead of non decreasing order, you just say ascending ? It makes the description more convoluted than it needs to be"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Both are not same. In non decreasing next value can be equal to previous one which is not ascending order. Hope this explains your confusion."
                    },
                    {
                        "username": "pawel-kam",
                        "content": "About the test case where `nums1 = [0,0,3,0,0,0,0,0,0]`. How is it \\'sorted in a non-decreasing order\\', as the question states???"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Zeros after 3 are trailing zeros where u need to add the values u r taking from nums2. Actual values that nums1 contain is [0, 0, 3], which is in non decreasing order. Hope this explains ur question."
                    },
                    {
                        "username": "mythilikarra",
                        "content": "I have the same question?????"
                    },
                    {
                        "username": "sanjayts",
                        "content": "I\\'m not really sure what\\'s going on here but this logically incorrect attempt at solving this problem is giving me weird results and fails with an index out of range error:\\n\\n```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        p1, p2 = m - 1, n - 1\\n        current = m + n - 1\\n        while current >= 0:\\n            print(f\\'START LOOP -- p1={p1}, p2={p2}, current={current}\\')\\n            if nums1[p1] < nums2[p2]:\\n                nums1[current] = nums2[p2]\\n                p2 = max(0, p2 - 1)\\n            else:\\n                nums1[current] = nums1[p1]\\n                p1 = max(0, p1 - 1)            \\n            current -= 1\\n            print(f\\'END LOOP -- p1={p1}, p2={p2}, current={current}\\')\\n```\\nwhich prints \\n```\\nSTART LOOP -- p1=2, p2=2, current=5\\nEND LOOP -- p1=2, p2=1, current=4\\nSTART LOOP -- p1=2, p2=1, current=4\\nEND LOOP -- p1=2, p2=0, current=3\\nSTART LOOP -- p1=2, p2=0, current=3\\nEND LOOP -- p1=1, p2=0, current=2\\nSTART LOOP -- p1=1, p2=0, current=2\\nEND LOOP -- p1=0, p2=0, current=1\\nSTART LOOP -- p1=0, p2=0, current=1\\nEND LOOP -- p1=0, p2=0, current=0\\nSTART LOOP -- p1=0, p2=0, current=0\\nEND LOOP -- p1=0, p2=0, current=-1\\nSTART LOOP -- p1=0, p2=-1, current=0\\n```\\n\\n**Notice how the `current` loop variable jumps from -1 back to 0?** What\\'s going on here? The same code works (producing an incorrect result) without failure when executed locally."
                    },
                    {
                        "username": "nvinogr",
                        "content": "Did you get to the bottom of it? I\\'m getting a similar issue in Java."
                    },
                    {
                        "username": "praveenchats",
                        "content": "        System.arraycopy(nums2,0,nums1,m,n);\\n        Arrays.sort(nums1);"
                    },
                    {
                        "username": "beginner_7",
                        "content": "The question if a good one for the easy question and description is good"
                    }
                ]
            },
            {
                "id": 1570021,
                "content": [
                    {
                        "username": "AlteriusOmega",
                        "content": "If you\\'re using Python and having the issue where Leetcode claims your output is identical to the input even if printing your nums1 shows the correct answer, remember that the assignment operator \"=\" does not modify variables in place. It will always create a new local variable. So if you do something like nums1 = nums1[m:] then now you are no longer working with the same nums1 that was input as an argument, but a totally new variable with a different reference"
                    },
                    {
                        "username": "Neethu_Raju",
                        "content": "Why is the following code resulting in [1,2,3,0,0,0]?\\npublic void Merge(int[] nums1, int m, int[] nums2, int n)\\n        {\\n            var sortedArr1 = nums1.OrderBy(x => x).Where(x => x != 0).ToArray();\\n            var sortedArr2 = nums2.OrderBy(x => x).Where(x => x != 0).ToArray();\\n\\n            if (sortedArr1.Length == m && sortedArr2.Length == n) \\n            {\\n                var mergedArray = new int[m + n];\\n                sortedArr1.CopyTo(mergedArray, 0);\\n                sortedArr2.CopyTo(mergedArray, m);\\n\\n                var res = mergedArray.OrderBy(x => x).ToArray();\\n            }\\n\\n        }"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "Ok, my real question is: the sneaky solution using three pointers seems pretty unintuitive. \\n\\nHas anyone ever come up with this on-the fly in a real, live, in-person interview? It seems unlikely to me. If so, I\\'d love to hear how you think about problems."
                    },
                    {
                        "username": "Upsite",
                        "content": "On the fly I probably would have said merge and sort however, After I would have said there is probably another solution that is much better. If you look at this solution you can tell there is a better solution than merge and sort. I was working on this three day's figuring out the three pointer solution. I got really close but, I gave up because after the third day I have to move on to other solutions. I think as long as you look at the answer and understand the solution it's fine to look at a solution and 'give up'. sorry for ranting on this reply section just ignore it please #copium."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Only if you have solved similar problems before and memorized the merge algorithm."
                    },
                    {
                        "username": "ShubhamAmande",
                        "content": "Is Something Wrong with this sum my code runs properly  on local machine as well as any online complier But when I try to run here it shows wrong output"
                    },
                    {
                        "username": "lauradouglas2002",
                        "content": "When I print my nums1 array to terminal, it matches the correct answer; however, I a failing all test cases. Not sure why?\n \nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        //array to array list\n        ArrayList<Integer> output = new ArrayList<Integer>();\n        for(int x = 0; x < m; x++){\n            output.add(nums1[x]);\n        }\n        for(int j = 0; j < n; j++){\n            output.add(nums2[j]);\n        }\n        //arraylist to array   \n        nums1 = output.stream().mapToInt(a -> a).toArray();\n        Arrays.sort(nums1);\n    }\n}"
                    },
                    {
                        "username": "jxofix",
                        "content": "I have the same problem...did you solve it?"
                    },
                    {
                        "username": "Tch4lla",
                        "content": "How about instead of non decreasing order, you just say ascending ? It makes the description more convoluted than it needs to be"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Both are not same. In non decreasing next value can be equal to previous one which is not ascending order. Hope this explains your confusion."
                    },
                    {
                        "username": "pawel-kam",
                        "content": "About the test case where `nums1 = [0,0,3,0,0,0,0,0,0]`. How is it \\'sorted in a non-decreasing order\\', as the question states???"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "Zeros after 3 are trailing zeros where u need to add the values u r taking from nums2. Actual values that nums1 contain is [0, 0, 3], which is in non decreasing order. Hope this explains ur question."
                    },
                    {
                        "username": "mythilikarra",
                        "content": "I have the same question?????"
                    },
                    {
                        "username": "sanjayts",
                        "content": "I\\'m not really sure what\\'s going on here but this logically incorrect attempt at solving this problem is giving me weird results and fails with an index out of range error:\\n\\n```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        p1, p2 = m - 1, n - 1\\n        current = m + n - 1\\n        while current >= 0:\\n            print(f\\'START LOOP -- p1={p1}, p2={p2}, current={current}\\')\\n            if nums1[p1] < nums2[p2]:\\n                nums1[current] = nums2[p2]\\n                p2 = max(0, p2 - 1)\\n            else:\\n                nums1[current] = nums1[p1]\\n                p1 = max(0, p1 - 1)            \\n            current -= 1\\n            print(f\\'END LOOP -- p1={p1}, p2={p2}, current={current}\\')\\n```\\nwhich prints \\n```\\nSTART LOOP -- p1=2, p2=2, current=5\\nEND LOOP -- p1=2, p2=1, current=4\\nSTART LOOP -- p1=2, p2=1, current=4\\nEND LOOP -- p1=2, p2=0, current=3\\nSTART LOOP -- p1=2, p2=0, current=3\\nEND LOOP -- p1=1, p2=0, current=2\\nSTART LOOP -- p1=1, p2=0, current=2\\nEND LOOP -- p1=0, p2=0, current=1\\nSTART LOOP -- p1=0, p2=0, current=1\\nEND LOOP -- p1=0, p2=0, current=0\\nSTART LOOP -- p1=0, p2=0, current=0\\nEND LOOP -- p1=0, p2=0, current=-1\\nSTART LOOP -- p1=0, p2=-1, current=0\\n```\\n\\n**Notice how the `current` loop variable jumps from -1 back to 0?** What\\'s going on here? The same code works (producing an incorrect result) without failure when executed locally."
                    },
                    {
                        "username": "nvinogr",
                        "content": "Did you get to the bottom of it? I\\'m getting a similar issue in Java."
                    },
                    {
                        "username": "praveenchats",
                        "content": "        System.arraycopy(nums2,0,nums1,m,n);\\n        Arrays.sort(nums1);"
                    },
                    {
                        "username": "beginner_7",
                        "content": "The question if a good one for the easy question and description is good"
                    }
                ]
            },
            {
                "id": 1572981,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Leetcode accepts the code suggested by approach 1 in the solution.  The expected answer is:\\n\\nInput:\\nnums1 = [1,2,3,0,0,0], m = 3\\nnums2 = [2,5,6],       n = 3\\nOutput: [1,2,2,3,5,6]\\n\\nBut its not consistent with a real python interpreter:\\n\\n$ python\\nPython 2.7.16 (default, Apr 12 2019, 15:32:40) \\n[GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.46.3)] on darwin\\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\\n>>> nums1 = [1,2,3,0,0,0]\\n>>> nums2 = [2,5,6]\\n>>> m=len(nums1)\\n>>> n=len(nums2)\\n>>> nums1[:] = sorted(nums1[:m] + nums2)\\n>>> nums1\\n[0, 0, 0, 1, 2, 2, 3, 5, 6]\\n>>> \\n\\n$ python3\\nPython 3.7.3 (default, Mar 27 2019, 09:23:15) \\n[Clang 10.0.1 (clang-1001.0.46.3)] on darwin\\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\\n>>> nums1 = [1,2,3,0,0,0]\\n>>> nums2 = [2,5,6]\\n>>> m=len(nums1)\\n>>> n=len(nums2)\\n>>> nums1[:] = sorted(nums1[:m] + nums2)\\n>>> nums1\\n[0, 0, 0, 1, 2, 2, 3, 5, 6]\\n>>> \\n"
                    },
                    {
                        "username": "consumeraffair",
                        "content": "Input:\\t[1,2,3], [2,5,6]\\nOutput:\\t[1,0,0,0,0,0]\\nExpected:\\t[1,2,2,3,5,6]\\n\\nMy code fails with this error.  However the guidelines explicitly state:\\n\\n**You may assume that A has enough space (size that is greater or equal to m + n) to hold additional elements from B.** The number of elements initialized in A and B are m and n respectively.\\n\\nIn this case I would have expected input to be something like:\\n\\nInput:\\t[1,2,3,null,null,null], [2,5,6]"
                    },
                    {
                        "username": "Pinster",
                        "content": "Please see my gitbook: https://algorithm.pingzhang.io/Sort/merge_two_sorted_array.html"
                    },
                    {
                        "username": "neildawg",
                        "content": "I couldn't understand the question.\\nFor example, the following input will return ArrayIndexOutOfBoundsException, what exactly should the size of nums1 should be?\\n\\n[1,3,5,7,9]\\n\\n5\\n\\n[2,4]\\n\\n2\\n\\nCan you give some examples what the input look like and the output?"
                    },
                    {
                        "username": "rwatso",
                        "content": "How is this an easy problem?"
                    },
                    {
                        "username": "gaurav_dubey_91",
                        "content": "My code runs in dartpad but gives error here. Can someone please help what I might be doing wrong?\\n\\nvoid merge(List<int> nums1, int m, List<int> nums2, int n) {\\n      var nums3 = List<int>.filled(nums1.length, 0);\\n  if(nums2.length != 0) {\\n    var i = 0, j = 0;\\n    for(var pos = 0; pos < nums1.length ; ++pos) {\\n      if(nums1[i] <= nums2[j] && nums1[i] != 0) {\\n        nums3[pos] = nums1[i];\\n        i++;\\n      } else {\\n        nums3[pos] = nums2[j];\\n        j++;\\n      }\\n    }\\n  \\n  nums1 = nums3;\\n  }\\n  }"
                    },
                    {
                        "username": "janis__",
                        "content": "Your Dart code uses the condition nums1[i] != 0 to check for valid elements, which is unreliable as 0 can be a valid element. Additionally, the assignment nums1 = nums3; only changes the local reference and doesn\\'t modify the original nums1 list; you should copy elements from nums3 back to nums1 instead."
                    },
                    {
                        "username": "nanzhuangdalao",
                        "content": "Honestly this is much harder than the best time to buy and sell stock IV for me..."
                    },
                    {
                        "username": "Andrew912",
                        "content": "Hi, why is this code not passing tests? \nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        nums1 = sorted(nums1[:m]+nums2)"
                    },
                    {
                        "username": "kaaaa765",
                        "content": "I don\\'t understand why when i print nums1 by the end of the function it prints out correct array as it should be but still the compiler shows me a wrong output that is not how my array looks like..."
                    },
                    {
                        "username": "krishkrishlclc",
                        "content": "Even after writing the correct solution code, the compiler gives error in passing testcases. But the same code runs without any error on online compiler."
                    },
                    {
                        "username": "vvk2299",
                        "content": "same thing happening with me"
                    }
                ]
            },
            {
                "id": 1571196,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Leetcode accepts the code suggested by approach 1 in the solution.  The expected answer is:\\n\\nInput:\\nnums1 = [1,2,3,0,0,0], m = 3\\nnums2 = [2,5,6],       n = 3\\nOutput: [1,2,2,3,5,6]\\n\\nBut its not consistent with a real python interpreter:\\n\\n$ python\\nPython 2.7.16 (default, Apr 12 2019, 15:32:40) \\n[GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.46.3)] on darwin\\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\\n>>> nums1 = [1,2,3,0,0,0]\\n>>> nums2 = [2,5,6]\\n>>> m=len(nums1)\\n>>> n=len(nums2)\\n>>> nums1[:] = sorted(nums1[:m] + nums2)\\n>>> nums1\\n[0, 0, 0, 1, 2, 2, 3, 5, 6]\\n>>> \\n\\n$ python3\\nPython 3.7.3 (default, Mar 27 2019, 09:23:15) \\n[Clang 10.0.1 (clang-1001.0.46.3)] on darwin\\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\\n>>> nums1 = [1,2,3,0,0,0]\\n>>> nums2 = [2,5,6]\\n>>> m=len(nums1)\\n>>> n=len(nums2)\\n>>> nums1[:] = sorted(nums1[:m] + nums2)\\n>>> nums1\\n[0, 0, 0, 1, 2, 2, 3, 5, 6]\\n>>> \\n"
                    },
                    {
                        "username": "consumeraffair",
                        "content": "Input:\\t[1,2,3], [2,5,6]\\nOutput:\\t[1,0,0,0,0,0]\\nExpected:\\t[1,2,2,3,5,6]\\n\\nMy code fails with this error.  However the guidelines explicitly state:\\n\\n**You may assume that A has enough space (size that is greater or equal to m + n) to hold additional elements from B.** The number of elements initialized in A and B are m and n respectively.\\n\\nIn this case I would have expected input to be something like:\\n\\nInput:\\t[1,2,3,null,null,null], [2,5,6]"
                    },
                    {
                        "username": "Pinster",
                        "content": "Please see my gitbook: https://algorithm.pingzhang.io/Sort/merge_two_sorted_array.html"
                    },
                    {
                        "username": "neildawg",
                        "content": "I couldn't understand the question.\\nFor example, the following input will return ArrayIndexOutOfBoundsException, what exactly should the size of nums1 should be?\\n\\n[1,3,5,7,9]\\n\\n5\\n\\n[2,4]\\n\\n2\\n\\nCan you give some examples what the input look like and the output?"
                    },
                    {
                        "username": "rwatso",
                        "content": "How is this an easy problem?"
                    },
                    {
                        "username": "gaurav_dubey_91",
                        "content": "My code runs in dartpad but gives error here. Can someone please help what I might be doing wrong?\\n\\nvoid merge(List<int> nums1, int m, List<int> nums2, int n) {\\n      var nums3 = List<int>.filled(nums1.length, 0);\\n  if(nums2.length != 0) {\\n    var i = 0, j = 0;\\n    for(var pos = 0; pos < nums1.length ; ++pos) {\\n      if(nums1[i] <= nums2[j] && nums1[i] != 0) {\\n        nums3[pos] = nums1[i];\\n        i++;\\n      } else {\\n        nums3[pos] = nums2[j];\\n        j++;\\n      }\\n    }\\n  \\n  nums1 = nums3;\\n  }\\n  }"
                    },
                    {
                        "username": "janis__",
                        "content": "Your Dart code uses the condition nums1[i] != 0 to check for valid elements, which is unreliable as 0 can be a valid element. Additionally, the assignment nums1 = nums3; only changes the local reference and doesn\\'t modify the original nums1 list; you should copy elements from nums3 back to nums1 instead."
                    },
                    {
                        "username": "nanzhuangdalao",
                        "content": "Honestly this is much harder than the best time to buy and sell stock IV for me..."
                    },
                    {
                        "username": "Andrew912",
                        "content": "Hi, why is this code not passing tests? \nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        nums1 = sorted(nums1[:m]+nums2)"
                    },
                    {
                        "username": "kaaaa765",
                        "content": "I don\\'t understand why when i print nums1 by the end of the function it prints out correct array as it should be but still the compiler shows me a wrong output that is not how my array looks like..."
                    },
                    {
                        "username": "krishkrishlclc",
                        "content": "Even after writing the correct solution code, the compiler gives error in passing testcases. But the same code runs without any error on online compiler."
                    },
                    {
                        "username": "vvk2299",
                        "content": "same thing happening with me"
                    }
                ]
            },
            {
                "id": 1567846,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Leetcode accepts the code suggested by approach 1 in the solution.  The expected answer is:\\n\\nInput:\\nnums1 = [1,2,3,0,0,0], m = 3\\nnums2 = [2,5,6],       n = 3\\nOutput: [1,2,2,3,5,6]\\n\\nBut its not consistent with a real python interpreter:\\n\\n$ python\\nPython 2.7.16 (default, Apr 12 2019, 15:32:40) \\n[GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.46.3)] on darwin\\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\\n>>> nums1 = [1,2,3,0,0,0]\\n>>> nums2 = [2,5,6]\\n>>> m=len(nums1)\\n>>> n=len(nums2)\\n>>> nums1[:] = sorted(nums1[:m] + nums2)\\n>>> nums1\\n[0, 0, 0, 1, 2, 2, 3, 5, 6]\\n>>> \\n\\n$ python3\\nPython 3.7.3 (default, Mar 27 2019, 09:23:15) \\n[Clang 10.0.1 (clang-1001.0.46.3)] on darwin\\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\\n>>> nums1 = [1,2,3,0,0,0]\\n>>> nums2 = [2,5,6]\\n>>> m=len(nums1)\\n>>> n=len(nums2)\\n>>> nums1[:] = sorted(nums1[:m] + nums2)\\n>>> nums1\\n[0, 0, 0, 1, 2, 2, 3, 5, 6]\\n>>> \\n"
                    },
                    {
                        "username": "consumeraffair",
                        "content": "Input:\\t[1,2,3], [2,5,6]\\nOutput:\\t[1,0,0,0,0,0]\\nExpected:\\t[1,2,2,3,5,6]\\n\\nMy code fails with this error.  However the guidelines explicitly state:\\n\\n**You may assume that A has enough space (size that is greater or equal to m + n) to hold additional elements from B.** The number of elements initialized in A and B are m and n respectively.\\n\\nIn this case I would have expected input to be something like:\\n\\nInput:\\t[1,2,3,null,null,null], [2,5,6]"
                    },
                    {
                        "username": "Pinster",
                        "content": "Please see my gitbook: https://algorithm.pingzhang.io/Sort/merge_two_sorted_array.html"
                    },
                    {
                        "username": "neildawg",
                        "content": "I couldn't understand the question.\\nFor example, the following input will return ArrayIndexOutOfBoundsException, what exactly should the size of nums1 should be?\\n\\n[1,3,5,7,9]\\n\\n5\\n\\n[2,4]\\n\\n2\\n\\nCan you give some examples what the input look like and the output?"
                    },
                    {
                        "username": "rwatso",
                        "content": "How is this an easy problem?"
                    },
                    {
                        "username": "gaurav_dubey_91",
                        "content": "My code runs in dartpad but gives error here. Can someone please help what I might be doing wrong?\\n\\nvoid merge(List<int> nums1, int m, List<int> nums2, int n) {\\n      var nums3 = List<int>.filled(nums1.length, 0);\\n  if(nums2.length != 0) {\\n    var i = 0, j = 0;\\n    for(var pos = 0; pos < nums1.length ; ++pos) {\\n      if(nums1[i] <= nums2[j] && nums1[i] != 0) {\\n        nums3[pos] = nums1[i];\\n        i++;\\n      } else {\\n        nums3[pos] = nums2[j];\\n        j++;\\n      }\\n    }\\n  \\n  nums1 = nums3;\\n  }\\n  }"
                    },
                    {
                        "username": "janis__",
                        "content": "Your Dart code uses the condition nums1[i] != 0 to check for valid elements, which is unreliable as 0 can be a valid element. Additionally, the assignment nums1 = nums3; only changes the local reference and doesn\\'t modify the original nums1 list; you should copy elements from nums3 back to nums1 instead."
                    },
                    {
                        "username": "nanzhuangdalao",
                        "content": "Honestly this is much harder than the best time to buy and sell stock IV for me..."
                    },
                    {
                        "username": "Andrew912",
                        "content": "Hi, why is this code not passing tests? \nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        nums1 = sorted(nums1[:m]+nums2)"
                    },
                    {
                        "username": "kaaaa765",
                        "content": "I don\\'t understand why when i print nums1 by the end of the function it prints out correct array as it should be but still the compiler shows me a wrong output that is not how my array looks like..."
                    },
                    {
                        "username": "krishkrishlclc",
                        "content": "Even after writing the correct solution code, the compiler gives error in passing testcases. But the same code runs without any error on online compiler."
                    },
                    {
                        "username": "vvk2299",
                        "content": "same thing happening with me"
                    }
                ]
            },
            {
                "id": 1567847,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Leetcode accepts the code suggested by approach 1 in the solution.  The expected answer is:\\n\\nInput:\\nnums1 = [1,2,3,0,0,0], m = 3\\nnums2 = [2,5,6],       n = 3\\nOutput: [1,2,2,3,5,6]\\n\\nBut its not consistent with a real python interpreter:\\n\\n$ python\\nPython 2.7.16 (default, Apr 12 2019, 15:32:40) \\n[GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.46.3)] on darwin\\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\\n>>> nums1 = [1,2,3,0,0,0]\\n>>> nums2 = [2,5,6]\\n>>> m=len(nums1)\\n>>> n=len(nums2)\\n>>> nums1[:] = sorted(nums1[:m] + nums2)\\n>>> nums1\\n[0, 0, 0, 1, 2, 2, 3, 5, 6]\\n>>> \\n\\n$ python3\\nPython 3.7.3 (default, Mar 27 2019, 09:23:15) \\n[Clang 10.0.1 (clang-1001.0.46.3)] on darwin\\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\\n>>> nums1 = [1,2,3,0,0,0]\\n>>> nums2 = [2,5,6]\\n>>> m=len(nums1)\\n>>> n=len(nums2)\\n>>> nums1[:] = sorted(nums1[:m] + nums2)\\n>>> nums1\\n[0, 0, 0, 1, 2, 2, 3, 5, 6]\\n>>> \\n"
                    },
                    {
                        "username": "consumeraffair",
                        "content": "Input:\\t[1,2,3], [2,5,6]\\nOutput:\\t[1,0,0,0,0,0]\\nExpected:\\t[1,2,2,3,5,6]\\n\\nMy code fails with this error.  However the guidelines explicitly state:\\n\\n**You may assume that A has enough space (size that is greater or equal to m + n) to hold additional elements from B.** The number of elements initialized in A and B are m and n respectively.\\n\\nIn this case I would have expected input to be something like:\\n\\nInput:\\t[1,2,3,null,null,null], [2,5,6]"
                    },
                    {
                        "username": "Pinster",
                        "content": "Please see my gitbook: https://algorithm.pingzhang.io/Sort/merge_two_sorted_array.html"
                    },
                    {
                        "username": "neildawg",
                        "content": "I couldn't understand the question.\\nFor example, the following input will return ArrayIndexOutOfBoundsException, what exactly should the size of nums1 should be?\\n\\n[1,3,5,7,9]\\n\\n5\\n\\n[2,4]\\n\\n2\\n\\nCan you give some examples what the input look like and the output?"
                    },
                    {
                        "username": "rwatso",
                        "content": "How is this an easy problem?"
                    },
                    {
                        "username": "gaurav_dubey_91",
                        "content": "My code runs in dartpad but gives error here. Can someone please help what I might be doing wrong?\\n\\nvoid merge(List<int> nums1, int m, List<int> nums2, int n) {\\n      var nums3 = List<int>.filled(nums1.length, 0);\\n  if(nums2.length != 0) {\\n    var i = 0, j = 0;\\n    for(var pos = 0; pos < nums1.length ; ++pos) {\\n      if(nums1[i] <= nums2[j] && nums1[i] != 0) {\\n        nums3[pos] = nums1[i];\\n        i++;\\n      } else {\\n        nums3[pos] = nums2[j];\\n        j++;\\n      }\\n    }\\n  \\n  nums1 = nums3;\\n  }\\n  }"
                    },
                    {
                        "username": "janis__",
                        "content": "Your Dart code uses the condition nums1[i] != 0 to check for valid elements, which is unreliable as 0 can be a valid element. Additionally, the assignment nums1 = nums3; only changes the local reference and doesn\\'t modify the original nums1 list; you should copy elements from nums3 back to nums1 instead."
                    },
                    {
                        "username": "nanzhuangdalao",
                        "content": "Honestly this is much harder than the best time to buy and sell stock IV for me..."
                    },
                    {
                        "username": "Andrew912",
                        "content": "Hi, why is this code not passing tests? \nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        nums1 = sorted(nums1[:m]+nums2)"
                    },
                    {
                        "username": "kaaaa765",
                        "content": "I don\\'t understand why when i print nums1 by the end of the function it prints out correct array as it should be but still the compiler shows me a wrong output that is not how my array looks like..."
                    },
                    {
                        "username": "krishkrishlclc",
                        "content": "Even after writing the correct solution code, the compiler gives error in passing testcases. But the same code runs without any error on online compiler."
                    },
                    {
                        "username": "vvk2299",
                        "content": "same thing happening with me"
                    }
                ]
            },
            {
                "id": 2051073,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Leetcode accepts the code suggested by approach 1 in the solution.  The expected answer is:\\n\\nInput:\\nnums1 = [1,2,3,0,0,0], m = 3\\nnums2 = [2,5,6],       n = 3\\nOutput: [1,2,2,3,5,6]\\n\\nBut its not consistent with a real python interpreter:\\n\\n$ python\\nPython 2.7.16 (default, Apr 12 2019, 15:32:40) \\n[GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.46.3)] on darwin\\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\\n>>> nums1 = [1,2,3,0,0,0]\\n>>> nums2 = [2,5,6]\\n>>> m=len(nums1)\\n>>> n=len(nums2)\\n>>> nums1[:] = sorted(nums1[:m] + nums2)\\n>>> nums1\\n[0, 0, 0, 1, 2, 2, 3, 5, 6]\\n>>> \\n\\n$ python3\\nPython 3.7.3 (default, Mar 27 2019, 09:23:15) \\n[Clang 10.0.1 (clang-1001.0.46.3)] on darwin\\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\\n>>> nums1 = [1,2,3,0,0,0]\\n>>> nums2 = [2,5,6]\\n>>> m=len(nums1)\\n>>> n=len(nums2)\\n>>> nums1[:] = sorted(nums1[:m] + nums2)\\n>>> nums1\\n[0, 0, 0, 1, 2, 2, 3, 5, 6]\\n>>> \\n"
                    },
                    {
                        "username": "consumeraffair",
                        "content": "Input:\\t[1,2,3], [2,5,6]\\nOutput:\\t[1,0,0,0,0,0]\\nExpected:\\t[1,2,2,3,5,6]\\n\\nMy code fails with this error.  However the guidelines explicitly state:\\n\\n**You may assume that A has enough space (size that is greater or equal to m + n) to hold additional elements from B.** The number of elements initialized in A and B are m and n respectively.\\n\\nIn this case I would have expected input to be something like:\\n\\nInput:\\t[1,2,3,null,null,null], [2,5,6]"
                    },
                    {
                        "username": "Pinster",
                        "content": "Please see my gitbook: https://algorithm.pingzhang.io/Sort/merge_two_sorted_array.html"
                    },
                    {
                        "username": "neildawg",
                        "content": "I couldn't understand the question.\\nFor example, the following input will return ArrayIndexOutOfBoundsException, what exactly should the size of nums1 should be?\\n\\n[1,3,5,7,9]\\n\\n5\\n\\n[2,4]\\n\\n2\\n\\nCan you give some examples what the input look like and the output?"
                    },
                    {
                        "username": "rwatso",
                        "content": "How is this an easy problem?"
                    },
                    {
                        "username": "gaurav_dubey_91",
                        "content": "My code runs in dartpad but gives error here. Can someone please help what I might be doing wrong?\\n\\nvoid merge(List<int> nums1, int m, List<int> nums2, int n) {\\n      var nums3 = List<int>.filled(nums1.length, 0);\\n  if(nums2.length != 0) {\\n    var i = 0, j = 0;\\n    for(var pos = 0; pos < nums1.length ; ++pos) {\\n      if(nums1[i] <= nums2[j] && nums1[i] != 0) {\\n        nums3[pos] = nums1[i];\\n        i++;\\n      } else {\\n        nums3[pos] = nums2[j];\\n        j++;\\n      }\\n    }\\n  \\n  nums1 = nums3;\\n  }\\n  }"
                    },
                    {
                        "username": "janis__",
                        "content": "Your Dart code uses the condition nums1[i] != 0 to check for valid elements, which is unreliable as 0 can be a valid element. Additionally, the assignment nums1 = nums3; only changes the local reference and doesn\\'t modify the original nums1 list; you should copy elements from nums3 back to nums1 instead."
                    },
                    {
                        "username": "nanzhuangdalao",
                        "content": "Honestly this is much harder than the best time to buy and sell stock IV for me..."
                    },
                    {
                        "username": "Andrew912",
                        "content": "Hi, why is this code not passing tests? \nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        nums1 = sorted(nums1[:m]+nums2)"
                    },
                    {
                        "username": "kaaaa765",
                        "content": "I don\\'t understand why when i print nums1 by the end of the function it prints out correct array as it should be but still the compiler shows me a wrong output that is not how my array looks like..."
                    },
                    {
                        "username": "krishkrishlclc",
                        "content": "Even after writing the correct solution code, the compiler gives error in passing testcases. But the same code runs without any error on online compiler."
                    },
                    {
                        "username": "vvk2299",
                        "content": "same thing happening with me"
                    }
                ]
            },
            {
                "id": 2041387,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Leetcode accepts the code suggested by approach 1 in the solution.  The expected answer is:\\n\\nInput:\\nnums1 = [1,2,3,0,0,0], m = 3\\nnums2 = [2,5,6],       n = 3\\nOutput: [1,2,2,3,5,6]\\n\\nBut its not consistent with a real python interpreter:\\n\\n$ python\\nPython 2.7.16 (default, Apr 12 2019, 15:32:40) \\n[GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.46.3)] on darwin\\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\\n>>> nums1 = [1,2,3,0,0,0]\\n>>> nums2 = [2,5,6]\\n>>> m=len(nums1)\\n>>> n=len(nums2)\\n>>> nums1[:] = sorted(nums1[:m] + nums2)\\n>>> nums1\\n[0, 0, 0, 1, 2, 2, 3, 5, 6]\\n>>> \\n\\n$ python3\\nPython 3.7.3 (default, Mar 27 2019, 09:23:15) \\n[Clang 10.0.1 (clang-1001.0.46.3)] on darwin\\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\\n>>> nums1 = [1,2,3,0,0,0]\\n>>> nums2 = [2,5,6]\\n>>> m=len(nums1)\\n>>> n=len(nums2)\\n>>> nums1[:] = sorted(nums1[:m] + nums2)\\n>>> nums1\\n[0, 0, 0, 1, 2, 2, 3, 5, 6]\\n>>> \\n"
                    },
                    {
                        "username": "consumeraffair",
                        "content": "Input:\\t[1,2,3], [2,5,6]\\nOutput:\\t[1,0,0,0,0,0]\\nExpected:\\t[1,2,2,3,5,6]\\n\\nMy code fails with this error.  However the guidelines explicitly state:\\n\\n**You may assume that A has enough space (size that is greater or equal to m + n) to hold additional elements from B.** The number of elements initialized in A and B are m and n respectively.\\n\\nIn this case I would have expected input to be something like:\\n\\nInput:\\t[1,2,3,null,null,null], [2,5,6]"
                    },
                    {
                        "username": "Pinster",
                        "content": "Please see my gitbook: https://algorithm.pingzhang.io/Sort/merge_two_sorted_array.html"
                    },
                    {
                        "username": "neildawg",
                        "content": "I couldn't understand the question.\\nFor example, the following input will return ArrayIndexOutOfBoundsException, what exactly should the size of nums1 should be?\\n\\n[1,3,5,7,9]\\n\\n5\\n\\n[2,4]\\n\\n2\\n\\nCan you give some examples what the input look like and the output?"
                    },
                    {
                        "username": "rwatso",
                        "content": "How is this an easy problem?"
                    },
                    {
                        "username": "gaurav_dubey_91",
                        "content": "My code runs in dartpad but gives error here. Can someone please help what I might be doing wrong?\\n\\nvoid merge(List<int> nums1, int m, List<int> nums2, int n) {\\n      var nums3 = List<int>.filled(nums1.length, 0);\\n  if(nums2.length != 0) {\\n    var i = 0, j = 0;\\n    for(var pos = 0; pos < nums1.length ; ++pos) {\\n      if(nums1[i] <= nums2[j] && nums1[i] != 0) {\\n        nums3[pos] = nums1[i];\\n        i++;\\n      } else {\\n        nums3[pos] = nums2[j];\\n        j++;\\n      }\\n    }\\n  \\n  nums1 = nums3;\\n  }\\n  }"
                    },
                    {
                        "username": "janis__",
                        "content": "Your Dart code uses the condition nums1[i] != 0 to check for valid elements, which is unreliable as 0 can be a valid element. Additionally, the assignment nums1 = nums3; only changes the local reference and doesn\\'t modify the original nums1 list; you should copy elements from nums3 back to nums1 instead."
                    },
                    {
                        "username": "nanzhuangdalao",
                        "content": "Honestly this is much harder than the best time to buy and sell stock IV for me..."
                    },
                    {
                        "username": "Andrew912",
                        "content": "Hi, why is this code not passing tests? \nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        nums1 = sorted(nums1[:m]+nums2)"
                    },
                    {
                        "username": "kaaaa765",
                        "content": "I don\\'t understand why when i print nums1 by the end of the function it prints out correct array as it should be but still the compiler shows me a wrong output that is not how my array looks like..."
                    },
                    {
                        "username": "krishkrishlclc",
                        "content": "Even after writing the correct solution code, the compiler gives error in passing testcases. But the same code runs without any error on online compiler."
                    },
                    {
                        "username": "vvk2299",
                        "content": "same thing happening with me"
                    }
                ]
            },
            {
                "id": 2029385,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Leetcode accepts the code suggested by approach 1 in the solution.  The expected answer is:\\n\\nInput:\\nnums1 = [1,2,3,0,0,0], m = 3\\nnums2 = [2,5,6],       n = 3\\nOutput: [1,2,2,3,5,6]\\n\\nBut its not consistent with a real python interpreter:\\n\\n$ python\\nPython 2.7.16 (default, Apr 12 2019, 15:32:40) \\n[GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.46.3)] on darwin\\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\\n>>> nums1 = [1,2,3,0,0,0]\\n>>> nums2 = [2,5,6]\\n>>> m=len(nums1)\\n>>> n=len(nums2)\\n>>> nums1[:] = sorted(nums1[:m] + nums2)\\n>>> nums1\\n[0, 0, 0, 1, 2, 2, 3, 5, 6]\\n>>> \\n\\n$ python3\\nPython 3.7.3 (default, Mar 27 2019, 09:23:15) \\n[Clang 10.0.1 (clang-1001.0.46.3)] on darwin\\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\\n>>> nums1 = [1,2,3,0,0,0]\\n>>> nums2 = [2,5,6]\\n>>> m=len(nums1)\\n>>> n=len(nums2)\\n>>> nums1[:] = sorted(nums1[:m] + nums2)\\n>>> nums1\\n[0, 0, 0, 1, 2, 2, 3, 5, 6]\\n>>> \\n"
                    },
                    {
                        "username": "consumeraffair",
                        "content": "Input:\\t[1,2,3], [2,5,6]\\nOutput:\\t[1,0,0,0,0,0]\\nExpected:\\t[1,2,2,3,5,6]\\n\\nMy code fails with this error.  However the guidelines explicitly state:\\n\\n**You may assume that A has enough space (size that is greater or equal to m + n) to hold additional elements from B.** The number of elements initialized in A and B are m and n respectively.\\n\\nIn this case I would have expected input to be something like:\\n\\nInput:\\t[1,2,3,null,null,null], [2,5,6]"
                    },
                    {
                        "username": "Pinster",
                        "content": "Please see my gitbook: https://algorithm.pingzhang.io/Sort/merge_two_sorted_array.html"
                    },
                    {
                        "username": "neildawg",
                        "content": "I couldn't understand the question.\\nFor example, the following input will return ArrayIndexOutOfBoundsException, what exactly should the size of nums1 should be?\\n\\n[1,3,5,7,9]\\n\\n5\\n\\n[2,4]\\n\\n2\\n\\nCan you give some examples what the input look like and the output?"
                    },
                    {
                        "username": "rwatso",
                        "content": "How is this an easy problem?"
                    },
                    {
                        "username": "gaurav_dubey_91",
                        "content": "My code runs in dartpad but gives error here. Can someone please help what I might be doing wrong?\\n\\nvoid merge(List<int> nums1, int m, List<int> nums2, int n) {\\n      var nums3 = List<int>.filled(nums1.length, 0);\\n  if(nums2.length != 0) {\\n    var i = 0, j = 0;\\n    for(var pos = 0; pos < nums1.length ; ++pos) {\\n      if(nums1[i] <= nums2[j] && nums1[i] != 0) {\\n        nums3[pos] = nums1[i];\\n        i++;\\n      } else {\\n        nums3[pos] = nums2[j];\\n        j++;\\n      }\\n    }\\n  \\n  nums1 = nums3;\\n  }\\n  }"
                    },
                    {
                        "username": "janis__",
                        "content": "Your Dart code uses the condition nums1[i] != 0 to check for valid elements, which is unreliable as 0 can be a valid element. Additionally, the assignment nums1 = nums3; only changes the local reference and doesn\\'t modify the original nums1 list; you should copy elements from nums3 back to nums1 instead."
                    },
                    {
                        "username": "nanzhuangdalao",
                        "content": "Honestly this is much harder than the best time to buy and sell stock IV for me..."
                    },
                    {
                        "username": "Andrew912",
                        "content": "Hi, why is this code not passing tests? \nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        nums1 = sorted(nums1[:m]+nums2)"
                    },
                    {
                        "username": "kaaaa765",
                        "content": "I don\\'t understand why when i print nums1 by the end of the function it prints out correct array as it should be but still the compiler shows me a wrong output that is not how my array looks like..."
                    },
                    {
                        "username": "krishkrishlclc",
                        "content": "Even after writing the correct solution code, the compiler gives error in passing testcases. But the same code runs without any error on online compiler."
                    },
                    {
                        "username": "vvk2299",
                        "content": "same thing happening with me"
                    }
                ]
            },
            {
                "id": 1967268,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Leetcode accepts the code suggested by approach 1 in the solution.  The expected answer is:\\n\\nInput:\\nnums1 = [1,2,3,0,0,0], m = 3\\nnums2 = [2,5,6],       n = 3\\nOutput: [1,2,2,3,5,6]\\n\\nBut its not consistent with a real python interpreter:\\n\\n$ python\\nPython 2.7.16 (default, Apr 12 2019, 15:32:40) \\n[GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.46.3)] on darwin\\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\\n>>> nums1 = [1,2,3,0,0,0]\\n>>> nums2 = [2,5,6]\\n>>> m=len(nums1)\\n>>> n=len(nums2)\\n>>> nums1[:] = sorted(nums1[:m] + nums2)\\n>>> nums1\\n[0, 0, 0, 1, 2, 2, 3, 5, 6]\\n>>> \\n\\n$ python3\\nPython 3.7.3 (default, Mar 27 2019, 09:23:15) \\n[Clang 10.0.1 (clang-1001.0.46.3)] on darwin\\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\\n>>> nums1 = [1,2,3,0,0,0]\\n>>> nums2 = [2,5,6]\\n>>> m=len(nums1)\\n>>> n=len(nums2)\\n>>> nums1[:] = sorted(nums1[:m] + nums2)\\n>>> nums1\\n[0, 0, 0, 1, 2, 2, 3, 5, 6]\\n>>> \\n"
                    },
                    {
                        "username": "consumeraffair",
                        "content": "Input:\\t[1,2,3], [2,5,6]\\nOutput:\\t[1,0,0,0,0,0]\\nExpected:\\t[1,2,2,3,5,6]\\n\\nMy code fails with this error.  However the guidelines explicitly state:\\n\\n**You may assume that A has enough space (size that is greater or equal to m + n) to hold additional elements from B.** The number of elements initialized in A and B are m and n respectively.\\n\\nIn this case I would have expected input to be something like:\\n\\nInput:\\t[1,2,3,null,null,null], [2,5,6]"
                    },
                    {
                        "username": "Pinster",
                        "content": "Please see my gitbook: https://algorithm.pingzhang.io/Sort/merge_two_sorted_array.html"
                    },
                    {
                        "username": "neildawg",
                        "content": "I couldn't understand the question.\\nFor example, the following input will return ArrayIndexOutOfBoundsException, what exactly should the size of nums1 should be?\\n\\n[1,3,5,7,9]\\n\\n5\\n\\n[2,4]\\n\\n2\\n\\nCan you give some examples what the input look like and the output?"
                    },
                    {
                        "username": "rwatso",
                        "content": "How is this an easy problem?"
                    },
                    {
                        "username": "gaurav_dubey_91",
                        "content": "My code runs in dartpad but gives error here. Can someone please help what I might be doing wrong?\\n\\nvoid merge(List<int> nums1, int m, List<int> nums2, int n) {\\n      var nums3 = List<int>.filled(nums1.length, 0);\\n  if(nums2.length != 0) {\\n    var i = 0, j = 0;\\n    for(var pos = 0; pos < nums1.length ; ++pos) {\\n      if(nums1[i] <= nums2[j] && nums1[i] != 0) {\\n        nums3[pos] = nums1[i];\\n        i++;\\n      } else {\\n        nums3[pos] = nums2[j];\\n        j++;\\n      }\\n    }\\n  \\n  nums1 = nums3;\\n  }\\n  }"
                    },
                    {
                        "username": "janis__",
                        "content": "Your Dart code uses the condition nums1[i] != 0 to check for valid elements, which is unreliable as 0 can be a valid element. Additionally, the assignment nums1 = nums3; only changes the local reference and doesn\\'t modify the original nums1 list; you should copy elements from nums3 back to nums1 instead."
                    },
                    {
                        "username": "nanzhuangdalao",
                        "content": "Honestly this is much harder than the best time to buy and sell stock IV for me..."
                    },
                    {
                        "username": "Andrew912",
                        "content": "Hi, why is this code not passing tests? \nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        nums1 = sorted(nums1[:m]+nums2)"
                    },
                    {
                        "username": "kaaaa765",
                        "content": "I don\\'t understand why when i print nums1 by the end of the function it prints out correct array as it should be but still the compiler shows me a wrong output that is not how my array looks like..."
                    },
                    {
                        "username": "krishkrishlclc",
                        "content": "Even after writing the correct solution code, the compiler gives error in passing testcases. But the same code runs without any error on online compiler."
                    },
                    {
                        "username": "vvk2299",
                        "content": "same thing happening with me"
                    }
                ]
            },
            {
                "id": 1959822,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Leetcode accepts the code suggested by approach 1 in the solution.  The expected answer is:\\n\\nInput:\\nnums1 = [1,2,3,0,0,0], m = 3\\nnums2 = [2,5,6],       n = 3\\nOutput: [1,2,2,3,5,6]\\n\\nBut its not consistent with a real python interpreter:\\n\\n$ python\\nPython 2.7.16 (default, Apr 12 2019, 15:32:40) \\n[GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.46.3)] on darwin\\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\\n>>> nums1 = [1,2,3,0,0,0]\\n>>> nums2 = [2,5,6]\\n>>> m=len(nums1)\\n>>> n=len(nums2)\\n>>> nums1[:] = sorted(nums1[:m] + nums2)\\n>>> nums1\\n[0, 0, 0, 1, 2, 2, 3, 5, 6]\\n>>> \\n\\n$ python3\\nPython 3.7.3 (default, Mar 27 2019, 09:23:15) \\n[Clang 10.0.1 (clang-1001.0.46.3)] on darwin\\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\\n>>> nums1 = [1,2,3,0,0,0]\\n>>> nums2 = [2,5,6]\\n>>> m=len(nums1)\\n>>> n=len(nums2)\\n>>> nums1[:] = sorted(nums1[:m] + nums2)\\n>>> nums1\\n[0, 0, 0, 1, 2, 2, 3, 5, 6]\\n>>> \\n"
                    },
                    {
                        "username": "consumeraffair",
                        "content": "Input:\\t[1,2,3], [2,5,6]\\nOutput:\\t[1,0,0,0,0,0]\\nExpected:\\t[1,2,2,3,5,6]\\n\\nMy code fails with this error.  However the guidelines explicitly state:\\n\\n**You may assume that A has enough space (size that is greater or equal to m + n) to hold additional elements from B.** The number of elements initialized in A and B are m and n respectively.\\n\\nIn this case I would have expected input to be something like:\\n\\nInput:\\t[1,2,3,null,null,null], [2,5,6]"
                    },
                    {
                        "username": "Pinster",
                        "content": "Please see my gitbook: https://algorithm.pingzhang.io/Sort/merge_two_sorted_array.html"
                    },
                    {
                        "username": "neildawg",
                        "content": "I couldn't understand the question.\\nFor example, the following input will return ArrayIndexOutOfBoundsException, what exactly should the size of nums1 should be?\\n\\n[1,3,5,7,9]\\n\\n5\\n\\n[2,4]\\n\\n2\\n\\nCan you give some examples what the input look like and the output?"
                    },
                    {
                        "username": "rwatso",
                        "content": "How is this an easy problem?"
                    },
                    {
                        "username": "gaurav_dubey_91",
                        "content": "My code runs in dartpad but gives error here. Can someone please help what I might be doing wrong?\\n\\nvoid merge(List<int> nums1, int m, List<int> nums2, int n) {\\n      var nums3 = List<int>.filled(nums1.length, 0);\\n  if(nums2.length != 0) {\\n    var i = 0, j = 0;\\n    for(var pos = 0; pos < nums1.length ; ++pos) {\\n      if(nums1[i] <= nums2[j] && nums1[i] != 0) {\\n        nums3[pos] = nums1[i];\\n        i++;\\n      } else {\\n        nums3[pos] = nums2[j];\\n        j++;\\n      }\\n    }\\n  \\n  nums1 = nums3;\\n  }\\n  }"
                    },
                    {
                        "username": "janis__",
                        "content": "Your Dart code uses the condition nums1[i] != 0 to check for valid elements, which is unreliable as 0 can be a valid element. Additionally, the assignment nums1 = nums3; only changes the local reference and doesn\\'t modify the original nums1 list; you should copy elements from nums3 back to nums1 instead."
                    },
                    {
                        "username": "nanzhuangdalao",
                        "content": "Honestly this is much harder than the best time to buy and sell stock IV for me..."
                    },
                    {
                        "username": "Andrew912",
                        "content": "Hi, why is this code not passing tests? \nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        nums1 = sorted(nums1[:m]+nums2)"
                    },
                    {
                        "username": "kaaaa765",
                        "content": "I don\\'t understand why when i print nums1 by the end of the function it prints out correct array as it should be but still the compiler shows me a wrong output that is not how my array looks like..."
                    },
                    {
                        "username": "krishkrishlclc",
                        "content": "Even after writing the correct solution code, the compiler gives error in passing testcases. But the same code runs without any error on online compiler."
                    },
                    {
                        "username": "vvk2299",
                        "content": "same thing happening with me"
                    }
                ]
            },
            {
                "id": 1958894,
                "content": [
                    {
                        "username": "moonlight16",
                        "content": "Leetcode accepts the code suggested by approach 1 in the solution.  The expected answer is:\\n\\nInput:\\nnums1 = [1,2,3,0,0,0], m = 3\\nnums2 = [2,5,6],       n = 3\\nOutput: [1,2,2,3,5,6]\\n\\nBut its not consistent with a real python interpreter:\\n\\n$ python\\nPython 2.7.16 (default, Apr 12 2019, 15:32:40) \\n[GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.46.3)] on darwin\\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\\n>>> nums1 = [1,2,3,0,0,0]\\n>>> nums2 = [2,5,6]\\n>>> m=len(nums1)\\n>>> n=len(nums2)\\n>>> nums1[:] = sorted(nums1[:m] + nums2)\\n>>> nums1\\n[0, 0, 0, 1, 2, 2, 3, 5, 6]\\n>>> \\n\\n$ python3\\nPython 3.7.3 (default, Mar 27 2019, 09:23:15) \\n[Clang 10.0.1 (clang-1001.0.46.3)] on darwin\\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\\n>>> nums1 = [1,2,3,0,0,0]\\n>>> nums2 = [2,5,6]\\n>>> m=len(nums1)\\n>>> n=len(nums2)\\n>>> nums1[:] = sorted(nums1[:m] + nums2)\\n>>> nums1\\n[0, 0, 0, 1, 2, 2, 3, 5, 6]\\n>>> \\n"
                    },
                    {
                        "username": "consumeraffair",
                        "content": "Input:\\t[1,2,3], [2,5,6]\\nOutput:\\t[1,0,0,0,0,0]\\nExpected:\\t[1,2,2,3,5,6]\\n\\nMy code fails with this error.  However the guidelines explicitly state:\\n\\n**You may assume that A has enough space (size that is greater or equal to m + n) to hold additional elements from B.** The number of elements initialized in A and B are m and n respectively.\\n\\nIn this case I would have expected input to be something like:\\n\\nInput:\\t[1,2,3,null,null,null], [2,5,6]"
                    },
                    {
                        "username": "Pinster",
                        "content": "Please see my gitbook: https://algorithm.pingzhang.io/Sort/merge_two_sorted_array.html"
                    },
                    {
                        "username": "neildawg",
                        "content": "I couldn't understand the question.\\nFor example, the following input will return ArrayIndexOutOfBoundsException, what exactly should the size of nums1 should be?\\n\\n[1,3,5,7,9]\\n\\n5\\n\\n[2,4]\\n\\n2\\n\\nCan you give some examples what the input look like and the output?"
                    },
                    {
                        "username": "rwatso",
                        "content": "How is this an easy problem?"
                    },
                    {
                        "username": "gaurav_dubey_91",
                        "content": "My code runs in dartpad but gives error here. Can someone please help what I might be doing wrong?\\n\\nvoid merge(List<int> nums1, int m, List<int> nums2, int n) {\\n      var nums3 = List<int>.filled(nums1.length, 0);\\n  if(nums2.length != 0) {\\n    var i = 0, j = 0;\\n    for(var pos = 0; pos < nums1.length ; ++pos) {\\n      if(nums1[i] <= nums2[j] && nums1[i] != 0) {\\n        nums3[pos] = nums1[i];\\n        i++;\\n      } else {\\n        nums3[pos] = nums2[j];\\n        j++;\\n      }\\n    }\\n  \\n  nums1 = nums3;\\n  }\\n  }"
                    },
                    {
                        "username": "janis__",
                        "content": "Your Dart code uses the condition nums1[i] != 0 to check for valid elements, which is unreliable as 0 can be a valid element. Additionally, the assignment nums1 = nums3; only changes the local reference and doesn\\'t modify the original nums1 list; you should copy elements from nums3 back to nums1 instead."
                    },
                    {
                        "username": "nanzhuangdalao",
                        "content": "Honestly this is much harder than the best time to buy and sell stock IV for me..."
                    },
                    {
                        "username": "Andrew912",
                        "content": "Hi, why is this code not passing tests? \nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        nums1 = sorted(nums1[:m]+nums2)"
                    },
                    {
                        "username": "kaaaa765",
                        "content": "I don\\'t understand why when i print nums1 by the end of the function it prints out correct array as it should be but still the compiler shows me a wrong output that is not how my array looks like..."
                    },
                    {
                        "username": "krishkrishlclc",
                        "content": "Even after writing the correct solution code, the compiler gives error in passing testcases. But the same code runs without any error on online compiler."
                    },
                    {
                        "username": "vvk2299",
                        "content": "same thing happening with me"
                    }
                ]
            },
            {
                "id": 1785439,
                "content": [
                    {
                        "username": "bhargav1811",
                        "content": "Only see if you have no idea to solve the problem  ---\n\nBasic way which comes to mind at first looking to the problem would be to set i and j pointer at beginning of nums1 and nums2.Then set another pointer as index as 0 which moves in nums1 always copying small values among nums1[i] and nums[j] and perform decrement in that small pointer values also.But the catch here is shift all elements of nums1 to right always as we copy nums2 values in nums1 so as to prevent override !! This results in somehow $ O(n^2) $ TC as iterating over the array takes O(n) and in worst case we always have to shift all the element to right [ TC -> O(n) for shifting ] as we iterate over all element.\n \nOnly see if you want to solve problem in $O(m+n)$ way - \nOther approach is to fill the array from back with biggest element first which prevents shifting of all nums1 element which helps to avoid O(n) time of shifting !!! So this gives us TC as $ O(m+n) $\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "Kanyisa",
                        "content": " could someone please help in why this code would throw and out of bounds exception:\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 6\\n at line 8, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n\\n\\n`class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int arrayLength = m + n; //total length of nums1 array       \\n        int newArrayCounter = 0; //used to count position in nums2 array\\n        \\n        for(int i = -1; i > -arrayLength; i--){                             \\n            if(nums1[i] == 0){                \\n                nums1[i] = nums2[newArrayCounter]; // assign nums2 value if nums1 array value = 0 \\n                newArrayCounter--;//increase nums2 counter to move to next value in nums2 array\\n            }           \\n            \\n        }\\n        Arrays.sort(nums1);            \\n    }\\n                  \\n}\\n`"
                    },
                    {
                        "username": "vgautam99",
                        "content": "In example 3\\n[0]\\n0\\n[1]\\n1\\n\\nthis code is returning [0] instead of [1]\\nif m == 0:\\n\\treturn nums2\\nif n == 0:\\n\\treturn nums1"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/t9SxiEYEU_w"
                    },
                    {
                        "username": "bossxomlut",
                        "content": "The test case of this problem is very crazy. i\\'m poor/ :("
                    },
                    {
                        "username": "boo-m",
                        "content": "Why is this question got lot of dislike?"
                    },
                    {
                        "username": "quan.zhang88",
                        "content": "I had a preliminary solution that fails for the input\\n[0]\\n0\\n[1]\\n1\\nBased on out of bounds exception when trying to get nums1's second element.\\n\\nHowever, the description says that we can assume nums1 has enough space for all elements in nums2, so why should there be a test case where that's not true?"
                    },
                    {
                        "username": "Enzhou",
                        "content": "the question states sorted arrays, what if first array is ascending and second one is descending?\\nThey still both sorted array, but the merge need to be changed."
                    },
                    {
                        "username": "stevenrugg",
                        "content": "# Merge Two Sorted Linked Lists\\n__________________________________________________________________________\\nThere are two common approaches to solve this problem. I have chosen to use the iterative approach vs. a recursive solution. \\n\\n\\nThe time complexity of the iterative solution is O(log n+m):  n,m = length of linked lists. \\n\\n"
                    },
                    {
                        "username": "Gurneet30",
                        "content": "\\'\\'\\'\\nnums1[m:m+n] = nums2\\nnums1.sort()\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    }
                ]
            },
            {
                "id": 1737298,
                "content": [
                    {
                        "username": "bhargav1811",
                        "content": "Only see if you have no idea to solve the problem  ---\n\nBasic way which comes to mind at first looking to the problem would be to set i and j pointer at beginning of nums1 and nums2.Then set another pointer as index as 0 which moves in nums1 always copying small values among nums1[i] and nums[j] and perform decrement in that small pointer values also.But the catch here is shift all elements of nums1 to right always as we copy nums2 values in nums1 so as to prevent override !! This results in somehow $ O(n^2) $ TC as iterating over the array takes O(n) and in worst case we always have to shift all the element to right [ TC -> O(n) for shifting ] as we iterate over all element.\n \nOnly see if you want to solve problem in $O(m+n)$ way - \nOther approach is to fill the array from back with biggest element first which prevents shifting of all nums1 element which helps to avoid O(n) time of shifting !!! So this gives us TC as $ O(m+n) $\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "Kanyisa",
                        "content": " could someone please help in why this code would throw and out of bounds exception:\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 6\\n at line 8, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n\\n\\n`class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int arrayLength = m + n; //total length of nums1 array       \\n        int newArrayCounter = 0; //used to count position in nums2 array\\n        \\n        for(int i = -1; i > -arrayLength; i--){                             \\n            if(nums1[i] == 0){                \\n                nums1[i] = nums2[newArrayCounter]; // assign nums2 value if nums1 array value = 0 \\n                newArrayCounter--;//increase nums2 counter to move to next value in nums2 array\\n            }           \\n            \\n        }\\n        Arrays.sort(nums1);            \\n    }\\n                  \\n}\\n`"
                    },
                    {
                        "username": "vgautam99",
                        "content": "In example 3\\n[0]\\n0\\n[1]\\n1\\n\\nthis code is returning [0] instead of [1]\\nif m == 0:\\n\\treturn nums2\\nif n == 0:\\n\\treturn nums1"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/t9SxiEYEU_w"
                    },
                    {
                        "username": "bossxomlut",
                        "content": "The test case of this problem is very crazy. i\\'m poor/ :("
                    },
                    {
                        "username": "boo-m",
                        "content": "Why is this question got lot of dislike?"
                    },
                    {
                        "username": "quan.zhang88",
                        "content": "I had a preliminary solution that fails for the input\\n[0]\\n0\\n[1]\\n1\\nBased on out of bounds exception when trying to get nums1's second element.\\n\\nHowever, the description says that we can assume nums1 has enough space for all elements in nums2, so why should there be a test case where that's not true?"
                    },
                    {
                        "username": "Enzhou",
                        "content": "the question states sorted arrays, what if first array is ascending and second one is descending?\\nThey still both sorted array, but the merge need to be changed."
                    },
                    {
                        "username": "stevenrugg",
                        "content": "# Merge Two Sorted Linked Lists\\n__________________________________________________________________________\\nThere are two common approaches to solve this problem. I have chosen to use the iterative approach vs. a recursive solution. \\n\\n\\nThe time complexity of the iterative solution is O(log n+m):  n,m = length of linked lists. \\n\\n"
                    },
                    {
                        "username": "Gurneet30",
                        "content": "\\'\\'\\'\\nnums1[m:m+n] = nums2\\nnums1.sort()\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    }
                ]
            },
            {
                "id": 1575765,
                "content": [
                    {
                        "username": "bhargav1811",
                        "content": "Only see if you have no idea to solve the problem  ---\n\nBasic way which comes to mind at first looking to the problem would be to set i and j pointer at beginning of nums1 and nums2.Then set another pointer as index as 0 which moves in nums1 always copying small values among nums1[i] and nums[j] and perform decrement in that small pointer values also.But the catch here is shift all elements of nums1 to right always as we copy nums2 values in nums1 so as to prevent override !! This results in somehow $ O(n^2) $ TC as iterating over the array takes O(n) and in worst case we always have to shift all the element to right [ TC -> O(n) for shifting ] as we iterate over all element.\n \nOnly see if you want to solve problem in $O(m+n)$ way - \nOther approach is to fill the array from back with biggest element first which prevents shifting of all nums1 element which helps to avoid O(n) time of shifting !!! So this gives us TC as $ O(m+n) $\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "Kanyisa",
                        "content": " could someone please help in why this code would throw and out of bounds exception:\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 6\\n at line 8, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n\\n\\n`class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int arrayLength = m + n; //total length of nums1 array       \\n        int newArrayCounter = 0; //used to count position in nums2 array\\n        \\n        for(int i = -1; i > -arrayLength; i--){                             \\n            if(nums1[i] == 0){                \\n                nums1[i] = nums2[newArrayCounter]; // assign nums2 value if nums1 array value = 0 \\n                newArrayCounter--;//increase nums2 counter to move to next value in nums2 array\\n            }           \\n            \\n        }\\n        Arrays.sort(nums1);            \\n    }\\n                  \\n}\\n`"
                    },
                    {
                        "username": "vgautam99",
                        "content": "In example 3\\n[0]\\n0\\n[1]\\n1\\n\\nthis code is returning [0] instead of [1]\\nif m == 0:\\n\\treturn nums2\\nif n == 0:\\n\\treturn nums1"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/t9SxiEYEU_w"
                    },
                    {
                        "username": "bossxomlut",
                        "content": "The test case of this problem is very crazy. i\\'m poor/ :("
                    },
                    {
                        "username": "boo-m",
                        "content": "Why is this question got lot of dislike?"
                    },
                    {
                        "username": "quan.zhang88",
                        "content": "I had a preliminary solution that fails for the input\\n[0]\\n0\\n[1]\\n1\\nBased on out of bounds exception when trying to get nums1's second element.\\n\\nHowever, the description says that we can assume nums1 has enough space for all elements in nums2, so why should there be a test case where that's not true?"
                    },
                    {
                        "username": "Enzhou",
                        "content": "the question states sorted arrays, what if first array is ascending and second one is descending?\\nThey still both sorted array, but the merge need to be changed."
                    },
                    {
                        "username": "stevenrugg",
                        "content": "# Merge Two Sorted Linked Lists\\n__________________________________________________________________________\\nThere are two common approaches to solve this problem. I have chosen to use the iterative approach vs. a recursive solution. \\n\\n\\nThe time complexity of the iterative solution is O(log n+m):  n,m = length of linked lists. \\n\\n"
                    },
                    {
                        "username": "Gurneet30",
                        "content": "\\'\\'\\'\\nnums1[m:m+n] = nums2\\nnums1.sort()\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    }
                ]
            },
            {
                "id": 1574837,
                "content": [
                    {
                        "username": "bhargav1811",
                        "content": "Only see if you have no idea to solve the problem  ---\n\nBasic way which comes to mind at first looking to the problem would be to set i and j pointer at beginning of nums1 and nums2.Then set another pointer as index as 0 which moves in nums1 always copying small values among nums1[i] and nums[j] and perform decrement in that small pointer values also.But the catch here is shift all elements of nums1 to right always as we copy nums2 values in nums1 so as to prevent override !! This results in somehow $ O(n^2) $ TC as iterating over the array takes O(n) and in worst case we always have to shift all the element to right [ TC -> O(n) for shifting ] as we iterate over all element.\n \nOnly see if you want to solve problem in $O(m+n)$ way - \nOther approach is to fill the array from back with biggest element first which prevents shifting of all nums1 element which helps to avoid O(n) time of shifting !!! So this gives us TC as $ O(m+n) $\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "Kanyisa",
                        "content": " could someone please help in why this code would throw and out of bounds exception:\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 6\\n at line 8, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n\\n\\n`class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int arrayLength = m + n; //total length of nums1 array       \\n        int newArrayCounter = 0; //used to count position in nums2 array\\n        \\n        for(int i = -1; i > -arrayLength; i--){                             \\n            if(nums1[i] == 0){                \\n                nums1[i] = nums2[newArrayCounter]; // assign nums2 value if nums1 array value = 0 \\n                newArrayCounter--;//increase nums2 counter to move to next value in nums2 array\\n            }           \\n            \\n        }\\n        Arrays.sort(nums1);            \\n    }\\n                  \\n}\\n`"
                    },
                    {
                        "username": "vgautam99",
                        "content": "In example 3\\n[0]\\n0\\n[1]\\n1\\n\\nthis code is returning [0] instead of [1]\\nif m == 0:\\n\\treturn nums2\\nif n == 0:\\n\\treturn nums1"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/t9SxiEYEU_w"
                    },
                    {
                        "username": "bossxomlut",
                        "content": "The test case of this problem is very crazy. i\\'m poor/ :("
                    },
                    {
                        "username": "boo-m",
                        "content": "Why is this question got lot of dislike?"
                    },
                    {
                        "username": "quan.zhang88",
                        "content": "I had a preliminary solution that fails for the input\\n[0]\\n0\\n[1]\\n1\\nBased on out of bounds exception when trying to get nums1's second element.\\n\\nHowever, the description says that we can assume nums1 has enough space for all elements in nums2, so why should there be a test case where that's not true?"
                    },
                    {
                        "username": "Enzhou",
                        "content": "the question states sorted arrays, what if first array is ascending and second one is descending?\\nThey still both sorted array, but the merge need to be changed."
                    },
                    {
                        "username": "stevenrugg",
                        "content": "# Merge Two Sorted Linked Lists\\n__________________________________________________________________________\\nThere are two common approaches to solve this problem. I have chosen to use the iterative approach vs. a recursive solution. \\n\\n\\nThe time complexity of the iterative solution is O(log n+m):  n,m = length of linked lists. \\n\\n"
                    },
                    {
                        "username": "Gurneet30",
                        "content": "\\'\\'\\'\\nnums1[m:m+n] = nums2\\nnums1.sort()\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    }
                ]
            },
            {
                "id": 1574499,
                "content": [
                    {
                        "username": "bhargav1811",
                        "content": "Only see if you have no idea to solve the problem  ---\n\nBasic way which comes to mind at first looking to the problem would be to set i and j pointer at beginning of nums1 and nums2.Then set another pointer as index as 0 which moves in nums1 always copying small values among nums1[i] and nums[j] and perform decrement in that small pointer values also.But the catch here is shift all elements of nums1 to right always as we copy nums2 values in nums1 so as to prevent override !! This results in somehow $ O(n^2) $ TC as iterating over the array takes O(n) and in worst case we always have to shift all the element to right [ TC -> O(n) for shifting ] as we iterate over all element.\n \nOnly see if you want to solve problem in $O(m+n)$ way - \nOther approach is to fill the array from back with biggest element first which prevents shifting of all nums1 element which helps to avoid O(n) time of shifting !!! So this gives us TC as $ O(m+n) $\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "Kanyisa",
                        "content": " could someone please help in why this code would throw and out of bounds exception:\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 6\\n at line 8, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n\\n\\n`class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int arrayLength = m + n; //total length of nums1 array       \\n        int newArrayCounter = 0; //used to count position in nums2 array\\n        \\n        for(int i = -1; i > -arrayLength; i--){                             \\n            if(nums1[i] == 0){                \\n                nums1[i] = nums2[newArrayCounter]; // assign nums2 value if nums1 array value = 0 \\n                newArrayCounter--;//increase nums2 counter to move to next value in nums2 array\\n            }           \\n            \\n        }\\n        Arrays.sort(nums1);            \\n    }\\n                  \\n}\\n`"
                    },
                    {
                        "username": "vgautam99",
                        "content": "In example 3\\n[0]\\n0\\n[1]\\n1\\n\\nthis code is returning [0] instead of [1]\\nif m == 0:\\n\\treturn nums2\\nif n == 0:\\n\\treturn nums1"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/t9SxiEYEU_w"
                    },
                    {
                        "username": "bossxomlut",
                        "content": "The test case of this problem is very crazy. i\\'m poor/ :("
                    },
                    {
                        "username": "boo-m",
                        "content": "Why is this question got lot of dislike?"
                    },
                    {
                        "username": "quan.zhang88",
                        "content": "I had a preliminary solution that fails for the input\\n[0]\\n0\\n[1]\\n1\\nBased on out of bounds exception when trying to get nums1's second element.\\n\\nHowever, the description says that we can assume nums1 has enough space for all elements in nums2, so why should there be a test case where that's not true?"
                    },
                    {
                        "username": "Enzhou",
                        "content": "the question states sorted arrays, what if first array is ascending and second one is descending?\\nThey still both sorted array, but the merge need to be changed."
                    },
                    {
                        "username": "stevenrugg",
                        "content": "# Merge Two Sorted Linked Lists\\n__________________________________________________________________________\\nThere are two common approaches to solve this problem. I have chosen to use the iterative approach vs. a recursive solution. \\n\\n\\nThe time complexity of the iterative solution is O(log n+m):  n,m = length of linked lists. \\n\\n"
                    },
                    {
                        "username": "Gurneet30",
                        "content": "\\'\\'\\'\\nnums1[m:m+n] = nums2\\nnums1.sort()\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    }
                ]
            },
            {
                "id": 1573011,
                "content": [
                    {
                        "username": "bhargav1811",
                        "content": "Only see if you have no idea to solve the problem  ---\n\nBasic way which comes to mind at first looking to the problem would be to set i and j pointer at beginning of nums1 and nums2.Then set another pointer as index as 0 which moves in nums1 always copying small values among nums1[i] and nums[j] and perform decrement in that small pointer values also.But the catch here is shift all elements of nums1 to right always as we copy nums2 values in nums1 so as to prevent override !! This results in somehow $ O(n^2) $ TC as iterating over the array takes O(n) and in worst case we always have to shift all the element to right [ TC -> O(n) for shifting ] as we iterate over all element.\n \nOnly see if you want to solve problem in $O(m+n)$ way - \nOther approach is to fill the array from back with biggest element first which prevents shifting of all nums1 element which helps to avoid O(n) time of shifting !!! So this gives us TC as $ O(m+n) $\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "Kanyisa",
                        "content": " could someone please help in why this code would throw and out of bounds exception:\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 6\\n at line 8, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n\\n\\n`class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int arrayLength = m + n; //total length of nums1 array       \\n        int newArrayCounter = 0; //used to count position in nums2 array\\n        \\n        for(int i = -1; i > -arrayLength; i--){                             \\n            if(nums1[i] == 0){                \\n                nums1[i] = nums2[newArrayCounter]; // assign nums2 value if nums1 array value = 0 \\n                newArrayCounter--;//increase nums2 counter to move to next value in nums2 array\\n            }           \\n            \\n        }\\n        Arrays.sort(nums1);            \\n    }\\n                  \\n}\\n`"
                    },
                    {
                        "username": "vgautam99",
                        "content": "In example 3\\n[0]\\n0\\n[1]\\n1\\n\\nthis code is returning [0] instead of [1]\\nif m == 0:\\n\\treturn nums2\\nif n == 0:\\n\\treturn nums1"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/t9SxiEYEU_w"
                    },
                    {
                        "username": "bossxomlut",
                        "content": "The test case of this problem is very crazy. i\\'m poor/ :("
                    },
                    {
                        "username": "boo-m",
                        "content": "Why is this question got lot of dislike?"
                    },
                    {
                        "username": "quan.zhang88",
                        "content": "I had a preliminary solution that fails for the input\\n[0]\\n0\\n[1]\\n1\\nBased on out of bounds exception when trying to get nums1's second element.\\n\\nHowever, the description says that we can assume nums1 has enough space for all elements in nums2, so why should there be a test case where that's not true?"
                    },
                    {
                        "username": "Enzhou",
                        "content": "the question states sorted arrays, what if first array is ascending and second one is descending?\\nThey still both sorted array, but the merge need to be changed."
                    },
                    {
                        "username": "stevenrugg",
                        "content": "# Merge Two Sorted Linked Lists\\n__________________________________________________________________________\\nThere are two common approaches to solve this problem. I have chosen to use the iterative approach vs. a recursive solution. \\n\\n\\nThe time complexity of the iterative solution is O(log n+m):  n,m = length of linked lists. \\n\\n"
                    },
                    {
                        "username": "Gurneet30",
                        "content": "\\'\\'\\'\\nnums1[m:m+n] = nums2\\nnums1.sort()\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    }
                ]
            },
            {
                "id": 1571193,
                "content": [
                    {
                        "username": "bhargav1811",
                        "content": "Only see if you have no idea to solve the problem  ---\n\nBasic way which comes to mind at first looking to the problem would be to set i and j pointer at beginning of nums1 and nums2.Then set another pointer as index as 0 which moves in nums1 always copying small values among nums1[i] and nums[j] and perform decrement in that small pointer values also.But the catch here is shift all elements of nums1 to right always as we copy nums2 values in nums1 so as to prevent override !! This results in somehow $ O(n^2) $ TC as iterating over the array takes O(n) and in worst case we always have to shift all the element to right [ TC -> O(n) for shifting ] as we iterate over all element.\n \nOnly see if you want to solve problem in $O(m+n)$ way - \nOther approach is to fill the array from back with biggest element first which prevents shifting of all nums1 element which helps to avoid O(n) time of shifting !!! So this gives us TC as $ O(m+n) $\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "Kanyisa",
                        "content": " could someone please help in why this code would throw and out of bounds exception:\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 6\\n at line 8, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n\\n\\n`class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int arrayLength = m + n; //total length of nums1 array       \\n        int newArrayCounter = 0; //used to count position in nums2 array\\n        \\n        for(int i = -1; i > -arrayLength; i--){                             \\n            if(nums1[i] == 0){                \\n                nums1[i] = nums2[newArrayCounter]; // assign nums2 value if nums1 array value = 0 \\n                newArrayCounter--;//increase nums2 counter to move to next value in nums2 array\\n            }           \\n            \\n        }\\n        Arrays.sort(nums1);            \\n    }\\n                  \\n}\\n`"
                    },
                    {
                        "username": "vgautam99",
                        "content": "In example 3\\n[0]\\n0\\n[1]\\n1\\n\\nthis code is returning [0] instead of [1]\\nif m == 0:\\n\\treturn nums2\\nif n == 0:\\n\\treturn nums1"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/t9SxiEYEU_w"
                    },
                    {
                        "username": "bossxomlut",
                        "content": "The test case of this problem is very crazy. i\\'m poor/ :("
                    },
                    {
                        "username": "boo-m",
                        "content": "Why is this question got lot of dislike?"
                    },
                    {
                        "username": "quan.zhang88",
                        "content": "I had a preliminary solution that fails for the input\\n[0]\\n0\\n[1]\\n1\\nBased on out of bounds exception when trying to get nums1's second element.\\n\\nHowever, the description says that we can assume nums1 has enough space for all elements in nums2, so why should there be a test case where that's not true?"
                    },
                    {
                        "username": "Enzhou",
                        "content": "the question states sorted arrays, what if first array is ascending and second one is descending?\\nThey still both sorted array, but the merge need to be changed."
                    },
                    {
                        "username": "stevenrugg",
                        "content": "# Merge Two Sorted Linked Lists\\n__________________________________________________________________________\\nThere are two common approaches to solve this problem. I have chosen to use the iterative approach vs. a recursive solution. \\n\\n\\nThe time complexity of the iterative solution is O(log n+m):  n,m = length of linked lists. \\n\\n"
                    },
                    {
                        "username": "Gurneet30",
                        "content": "\\'\\'\\'\\nnums1[m:m+n] = nums2\\nnums1.sort()\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    }
                ]
            },
            {
                "id": 1571195,
                "content": [
                    {
                        "username": "bhargav1811",
                        "content": "Only see if you have no idea to solve the problem  ---\n\nBasic way which comes to mind at first looking to the problem would be to set i and j pointer at beginning of nums1 and nums2.Then set another pointer as index as 0 which moves in nums1 always copying small values among nums1[i] and nums[j] and perform decrement in that small pointer values also.But the catch here is shift all elements of nums1 to right always as we copy nums2 values in nums1 so as to prevent override !! This results in somehow $ O(n^2) $ TC as iterating over the array takes O(n) and in worst case we always have to shift all the element to right [ TC -> O(n) for shifting ] as we iterate over all element.\n \nOnly see if you want to solve problem in $O(m+n)$ way - \nOther approach is to fill the array from back with biggest element first which prevents shifting of all nums1 element which helps to avoid O(n) time of shifting !!! So this gives us TC as $ O(m+n) $\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "Kanyisa",
                        "content": " could someone please help in why this code would throw and out of bounds exception:\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 6\\n at line 8, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n\\n\\n`class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int arrayLength = m + n; //total length of nums1 array       \\n        int newArrayCounter = 0; //used to count position in nums2 array\\n        \\n        for(int i = -1; i > -arrayLength; i--){                             \\n            if(nums1[i] == 0){                \\n                nums1[i] = nums2[newArrayCounter]; // assign nums2 value if nums1 array value = 0 \\n                newArrayCounter--;//increase nums2 counter to move to next value in nums2 array\\n            }           \\n            \\n        }\\n        Arrays.sort(nums1);            \\n    }\\n                  \\n}\\n`"
                    },
                    {
                        "username": "vgautam99",
                        "content": "In example 3\\n[0]\\n0\\n[1]\\n1\\n\\nthis code is returning [0] instead of [1]\\nif m == 0:\\n\\treturn nums2\\nif n == 0:\\n\\treturn nums1"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/t9SxiEYEU_w"
                    },
                    {
                        "username": "bossxomlut",
                        "content": "The test case of this problem is very crazy. i\\'m poor/ :("
                    },
                    {
                        "username": "boo-m",
                        "content": "Why is this question got lot of dislike?"
                    },
                    {
                        "username": "quan.zhang88",
                        "content": "I had a preliminary solution that fails for the input\\n[0]\\n0\\n[1]\\n1\\nBased on out of bounds exception when trying to get nums1's second element.\\n\\nHowever, the description says that we can assume nums1 has enough space for all elements in nums2, so why should there be a test case where that's not true?"
                    },
                    {
                        "username": "Enzhou",
                        "content": "the question states sorted arrays, what if first array is ascending and second one is descending?\\nThey still both sorted array, but the merge need to be changed."
                    },
                    {
                        "username": "stevenrugg",
                        "content": "# Merge Two Sorted Linked Lists\\n__________________________________________________________________________\\nThere are two common approaches to solve this problem. I have chosen to use the iterative approach vs. a recursive solution. \\n\\n\\nThe time complexity of the iterative solution is O(log n+m):  n,m = length of linked lists. \\n\\n"
                    },
                    {
                        "username": "Gurneet30",
                        "content": "\\'\\'\\'\\nnums1[m:m+n] = nums2\\nnums1.sort()\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    }
                ]
            },
            {
                "id": 1570749,
                "content": [
                    {
                        "username": "bhargav1811",
                        "content": "Only see if you have no idea to solve the problem  ---\n\nBasic way which comes to mind at first looking to the problem would be to set i and j pointer at beginning of nums1 and nums2.Then set another pointer as index as 0 which moves in nums1 always copying small values among nums1[i] and nums[j] and perform decrement in that small pointer values also.But the catch here is shift all elements of nums1 to right always as we copy nums2 values in nums1 so as to prevent override !! This results in somehow $ O(n^2) $ TC as iterating over the array takes O(n) and in worst case we always have to shift all the element to right [ TC -> O(n) for shifting ] as we iterate over all element.\n \nOnly see if you want to solve problem in $O(m+n)$ way - \nOther approach is to fill the array from back with biggest element first which prevents shifting of all nums1 element which helps to avoid O(n) time of shifting !!! So this gives us TC as $ O(m+n) $\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "Kanyisa",
                        "content": " could someone please help in why this code would throw and out of bounds exception:\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 6\\n at line 8, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n\\n\\n`class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int arrayLength = m + n; //total length of nums1 array       \\n        int newArrayCounter = 0; //used to count position in nums2 array\\n        \\n        for(int i = -1; i > -arrayLength; i--){                             \\n            if(nums1[i] == 0){                \\n                nums1[i] = nums2[newArrayCounter]; // assign nums2 value if nums1 array value = 0 \\n                newArrayCounter--;//increase nums2 counter to move to next value in nums2 array\\n            }           \\n            \\n        }\\n        Arrays.sort(nums1);            \\n    }\\n                  \\n}\\n`"
                    },
                    {
                        "username": "vgautam99",
                        "content": "In example 3\\n[0]\\n0\\n[1]\\n1\\n\\nthis code is returning [0] instead of [1]\\nif m == 0:\\n\\treturn nums2\\nif n == 0:\\n\\treturn nums1"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/t9SxiEYEU_w"
                    },
                    {
                        "username": "bossxomlut",
                        "content": "The test case of this problem is very crazy. i\\'m poor/ :("
                    },
                    {
                        "username": "boo-m",
                        "content": "Why is this question got lot of dislike?"
                    },
                    {
                        "username": "quan.zhang88",
                        "content": "I had a preliminary solution that fails for the input\\n[0]\\n0\\n[1]\\n1\\nBased on out of bounds exception when trying to get nums1's second element.\\n\\nHowever, the description says that we can assume nums1 has enough space for all elements in nums2, so why should there be a test case where that's not true?"
                    },
                    {
                        "username": "Enzhou",
                        "content": "the question states sorted arrays, what if first array is ascending and second one is descending?\\nThey still both sorted array, but the merge need to be changed."
                    },
                    {
                        "username": "stevenrugg",
                        "content": "# Merge Two Sorted Linked Lists\\n__________________________________________________________________________\\nThere are two common approaches to solve this problem. I have chosen to use the iterative approach vs. a recursive solution. \\n\\n\\nThe time complexity of the iterative solution is O(log n+m):  n,m = length of linked lists. \\n\\n"
                    },
                    {
                        "username": "Gurneet30",
                        "content": "\\'\\'\\'\\nnums1[m:m+n] = nums2\\nnums1.sort()\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    }
                ]
            },
            {
                "id": 1575103,
                "content": [
                    {
                        "username": "bhargav1811",
                        "content": "Only see if you have no idea to solve the problem  ---\n\nBasic way which comes to mind at first looking to the problem would be to set i and j pointer at beginning of nums1 and nums2.Then set another pointer as index as 0 which moves in nums1 always copying small values among nums1[i] and nums[j] and perform decrement in that small pointer values also.But the catch here is shift all elements of nums1 to right always as we copy nums2 values in nums1 so as to prevent override !! This results in somehow $ O(n^2) $ TC as iterating over the array takes O(n) and in worst case we always have to shift all the element to right [ TC -> O(n) for shifting ] as we iterate over all element.\n \nOnly see if you want to solve problem in $O(m+n)$ way - \nOther approach is to fill the array from back with biggest element first which prevents shifting of all nums1 element which helps to avoid O(n) time of shifting !!! So this gives us TC as $ O(m+n) $\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "Kanyisa",
                        "content": " could someone please help in why this code would throw and out of bounds exception:\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 6\\n at line 8, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n\\n\\n`class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int arrayLength = m + n; //total length of nums1 array       \\n        int newArrayCounter = 0; //used to count position in nums2 array\\n        \\n        for(int i = -1; i > -arrayLength; i--){                             \\n            if(nums1[i] == 0){                \\n                nums1[i] = nums2[newArrayCounter]; // assign nums2 value if nums1 array value = 0 \\n                newArrayCounter--;//increase nums2 counter to move to next value in nums2 array\\n            }           \\n            \\n        }\\n        Arrays.sort(nums1);            \\n    }\\n                  \\n}\\n`"
                    },
                    {
                        "username": "vgautam99",
                        "content": "In example 3\\n[0]\\n0\\n[1]\\n1\\n\\nthis code is returning [0] instead of [1]\\nif m == 0:\\n\\treturn nums2\\nif n == 0:\\n\\treturn nums1"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/t9SxiEYEU_w"
                    },
                    {
                        "username": "bossxomlut",
                        "content": "The test case of this problem is very crazy. i\\'m poor/ :("
                    },
                    {
                        "username": "boo-m",
                        "content": "Why is this question got lot of dislike?"
                    },
                    {
                        "username": "quan.zhang88",
                        "content": "I had a preliminary solution that fails for the input\\n[0]\\n0\\n[1]\\n1\\nBased on out of bounds exception when trying to get nums1's second element.\\n\\nHowever, the description says that we can assume nums1 has enough space for all elements in nums2, so why should there be a test case where that's not true?"
                    },
                    {
                        "username": "Enzhou",
                        "content": "the question states sorted arrays, what if first array is ascending and second one is descending?\\nThey still both sorted array, but the merge need to be changed."
                    },
                    {
                        "username": "stevenrugg",
                        "content": "# Merge Two Sorted Linked Lists\\n__________________________________________________________________________\\nThere are two common approaches to solve this problem. I have chosen to use the iterative approach vs. a recursive solution. \\n\\n\\nThe time complexity of the iterative solution is O(log n+m):  n,m = length of linked lists. \\n\\n"
                    },
                    {
                        "username": "Gurneet30",
                        "content": "\\'\\'\\'\\nnums1[m:m+n] = nums2\\nnums1.sort()\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    }
                ]
            },
            {
                "id": 1574232,
                "content": [
                    {
                        "username": "zhangjiayi1308",
                        "content": "del nums1[m:]\\n        for i in range(n):\\n             nums1.append(nums2[i])\\n        nums1.sort()"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    },
                    {
                        "username": "marcovisi",
                        "content": "Very simple solution\\n\\n        nums1[m:]=nums2\\n        nums1.sort()"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    },
                    {
                        "username": "hengameh",
                        "content": "Does any one know how we can implement   \\n*Min Heap Method* (Priority queue) or\\n*Tournament tree*  \\nfor **merging K sorted arrays**?\\n\\nHere is both solutions in C++, but I cannot convert it in Java.  \\n  \\nhttp://yourbitsandbytes.com/viewtopic.php?f=803&t=5662&p=8777#p8777   \\n  \\nI appreciate your help   \\nThanks"
                    },
                    {
                        "username": "vinjenks",
                        "content": "Good stuff! This one had some gotchas. My solution was fugly but it ran faster than 86% of others w/ JS."
                    },
                    {
                        "username": "not_turing",
                        "content": "My solution was accepted, but submission results are weird: 1. I got 0 ms runtime, beating 100% of other submitters. Something wrong with test cases or procedure? 2. Also, this is obviously done in place, how can memory consumed be different between different submitters? I was told I beat 14% of submitters with memory used 9.6 MB."
                    },
                    {
                        "username": "fireship_2004",
                        "content": "why do so many people ignore the follow-up part of the question? we\\'re supposed to do it in O(m+n) but most of the solution in the distribution chart are O(nlogn) because they use sort function."
                    },
                    {
                        "username": "rs1310",
                        "content": "A proper use of nums.resize( ); , nums.insert( );  &  nums.sort( ); .\\nShould be enough to solve this question for a beginner."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "why this code:\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1 = sorted(nums1 + nums2)\\n\\ndoes not work (nums1 = [1,2,3])? getting mad its so obvious it should work, and in VSCode works"
                    },
                    {
                        "username": "user4130zD",
                        "content": "*Merge nums1 and nums2 into a single array sorted in non-decreasing order.*  \\nThis problem worded poor for someone who\\'s a beginner such as myself. They should also explain first that you must specifically replace values inside the array."
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "This is so easy task, but this C compilator suck af. \\nThere is even problem to print nums1 or nums2 from 0 to numxSize-1"
                    }
                ]
            },
            {
                "id": 1571923,
                "content": [
                    {
                        "username": "zhangjiayi1308",
                        "content": "del nums1[m:]\\n        for i in range(n):\\n             nums1.append(nums2[i])\\n        nums1.sort()"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    },
                    {
                        "username": "marcovisi",
                        "content": "Very simple solution\\n\\n        nums1[m:]=nums2\\n        nums1.sort()"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    },
                    {
                        "username": "hengameh",
                        "content": "Does any one know how we can implement   \\n*Min Heap Method* (Priority queue) or\\n*Tournament tree*  \\nfor **merging K sorted arrays**?\\n\\nHere is both solutions in C++, but I cannot convert it in Java.  \\n  \\nhttp://yourbitsandbytes.com/viewtopic.php?f=803&t=5662&p=8777#p8777   \\n  \\nI appreciate your help   \\nThanks"
                    },
                    {
                        "username": "vinjenks",
                        "content": "Good stuff! This one had some gotchas. My solution was fugly but it ran faster than 86% of others w/ JS."
                    },
                    {
                        "username": "not_turing",
                        "content": "My solution was accepted, but submission results are weird: 1. I got 0 ms runtime, beating 100% of other submitters. Something wrong with test cases or procedure? 2. Also, this is obviously done in place, how can memory consumed be different between different submitters? I was told I beat 14% of submitters with memory used 9.6 MB."
                    },
                    {
                        "username": "fireship_2004",
                        "content": "why do so many people ignore the follow-up part of the question? we\\'re supposed to do it in O(m+n) but most of the solution in the distribution chart are O(nlogn) because they use sort function."
                    },
                    {
                        "username": "rs1310",
                        "content": "A proper use of nums.resize( ); , nums.insert( );  &  nums.sort( ); .\\nShould be enough to solve this question for a beginner."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "why this code:\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1 = sorted(nums1 + nums2)\\n\\ndoes not work (nums1 = [1,2,3])? getting mad its so obvious it should work, and in VSCode works"
                    },
                    {
                        "username": "user4130zD",
                        "content": "*Merge nums1 and nums2 into a single array sorted in non-decreasing order.*  \\nThis problem worded poor for someone who\\'s a beginner such as myself. They should also explain first that you must specifically replace values inside the array."
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "This is so easy task, but this C compilator suck af. \\nThere is even problem to print nums1 or nums2 from 0 to numxSize-1"
                    }
                ]
            },
            {
                "id": 1571194,
                "content": [
                    {
                        "username": "zhangjiayi1308",
                        "content": "del nums1[m:]\\n        for i in range(n):\\n             nums1.append(nums2[i])\\n        nums1.sort()"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    },
                    {
                        "username": "marcovisi",
                        "content": "Very simple solution\\n\\n        nums1[m:]=nums2\\n        nums1.sort()"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    },
                    {
                        "username": "hengameh",
                        "content": "Does any one know how we can implement   \\n*Min Heap Method* (Priority queue) or\\n*Tournament tree*  \\nfor **merging K sorted arrays**?\\n\\nHere is both solutions in C++, but I cannot convert it in Java.  \\n  \\nhttp://yourbitsandbytes.com/viewtopic.php?f=803&t=5662&p=8777#p8777   \\n  \\nI appreciate your help   \\nThanks"
                    },
                    {
                        "username": "vinjenks",
                        "content": "Good stuff! This one had some gotchas. My solution was fugly but it ran faster than 86% of others w/ JS."
                    },
                    {
                        "username": "not_turing",
                        "content": "My solution was accepted, but submission results are weird: 1. I got 0 ms runtime, beating 100% of other submitters. Something wrong with test cases or procedure? 2. Also, this is obviously done in place, how can memory consumed be different between different submitters? I was told I beat 14% of submitters with memory used 9.6 MB."
                    },
                    {
                        "username": "fireship_2004",
                        "content": "why do so many people ignore the follow-up part of the question? we\\'re supposed to do it in O(m+n) but most of the solution in the distribution chart are O(nlogn) because they use sort function."
                    },
                    {
                        "username": "rs1310",
                        "content": "A proper use of nums.resize( ); , nums.insert( );  &  nums.sort( ); .\\nShould be enough to solve this question for a beginner."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "why this code:\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1 = sorted(nums1 + nums2)\\n\\ndoes not work (nums1 = [1,2,3])? getting mad its so obvious it should work, and in VSCode works"
                    },
                    {
                        "username": "user4130zD",
                        "content": "*Merge nums1 and nums2 into a single array sorted in non-decreasing order.*  \\nThis problem worded poor for someone who\\'s a beginner such as myself. They should also explain first that you must specifically replace values inside the array."
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "This is so easy task, but this C compilator suck af. \\nThere is even problem to print nums1 or nums2 from 0 to numxSize-1"
                    }
                ]
            },
            {
                "id": 2077180,
                "content": [
                    {
                        "username": "zhangjiayi1308",
                        "content": "del nums1[m:]\\n        for i in range(n):\\n             nums1.append(nums2[i])\\n        nums1.sort()"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    },
                    {
                        "username": "marcovisi",
                        "content": "Very simple solution\\n\\n        nums1[m:]=nums2\\n        nums1.sort()"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    },
                    {
                        "username": "hengameh",
                        "content": "Does any one know how we can implement   \\n*Min Heap Method* (Priority queue) or\\n*Tournament tree*  \\nfor **merging K sorted arrays**?\\n\\nHere is both solutions in C++, but I cannot convert it in Java.  \\n  \\nhttp://yourbitsandbytes.com/viewtopic.php?f=803&t=5662&p=8777#p8777   \\n  \\nI appreciate your help   \\nThanks"
                    },
                    {
                        "username": "vinjenks",
                        "content": "Good stuff! This one had some gotchas. My solution was fugly but it ran faster than 86% of others w/ JS."
                    },
                    {
                        "username": "not_turing",
                        "content": "My solution was accepted, but submission results are weird: 1. I got 0 ms runtime, beating 100% of other submitters. Something wrong with test cases or procedure? 2. Also, this is obviously done in place, how can memory consumed be different between different submitters? I was told I beat 14% of submitters with memory used 9.6 MB."
                    },
                    {
                        "username": "fireship_2004",
                        "content": "why do so many people ignore the follow-up part of the question? we\\'re supposed to do it in O(m+n) but most of the solution in the distribution chart are O(nlogn) because they use sort function."
                    },
                    {
                        "username": "rs1310",
                        "content": "A proper use of nums.resize( ); , nums.insert( );  &  nums.sort( ); .\\nShould be enough to solve this question for a beginner."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "why this code:\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1 = sorted(nums1 + nums2)\\n\\ndoes not work (nums1 = [1,2,3])? getting mad its so obvious it should work, and in VSCode works"
                    },
                    {
                        "username": "user4130zD",
                        "content": "*Merge nums1 and nums2 into a single array sorted in non-decreasing order.*  \\nThis problem worded poor for someone who\\'s a beginner such as myself. They should also explain first that you must specifically replace values inside the array."
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "This is so easy task, but this C compilator suck af. \\nThere is even problem to print nums1 or nums2 from 0 to numxSize-1"
                    }
                ]
            },
            {
                "id": 2076128,
                "content": [
                    {
                        "username": "zhangjiayi1308",
                        "content": "del nums1[m:]\\n        for i in range(n):\\n             nums1.append(nums2[i])\\n        nums1.sort()"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    },
                    {
                        "username": "marcovisi",
                        "content": "Very simple solution\\n\\n        nums1[m:]=nums2\\n        nums1.sort()"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    },
                    {
                        "username": "hengameh",
                        "content": "Does any one know how we can implement   \\n*Min Heap Method* (Priority queue) or\\n*Tournament tree*  \\nfor **merging K sorted arrays**?\\n\\nHere is both solutions in C++, but I cannot convert it in Java.  \\n  \\nhttp://yourbitsandbytes.com/viewtopic.php?f=803&t=5662&p=8777#p8777   \\n  \\nI appreciate your help   \\nThanks"
                    },
                    {
                        "username": "vinjenks",
                        "content": "Good stuff! This one had some gotchas. My solution was fugly but it ran faster than 86% of others w/ JS."
                    },
                    {
                        "username": "not_turing",
                        "content": "My solution was accepted, but submission results are weird: 1. I got 0 ms runtime, beating 100% of other submitters. Something wrong with test cases or procedure? 2. Also, this is obviously done in place, how can memory consumed be different between different submitters? I was told I beat 14% of submitters with memory used 9.6 MB."
                    },
                    {
                        "username": "fireship_2004",
                        "content": "why do so many people ignore the follow-up part of the question? we\\'re supposed to do it in O(m+n) but most of the solution in the distribution chart are O(nlogn) because they use sort function."
                    },
                    {
                        "username": "rs1310",
                        "content": "A proper use of nums.resize( ); , nums.insert( );  &  nums.sort( ); .\\nShould be enough to solve this question for a beginner."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "why this code:\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1 = sorted(nums1 + nums2)\\n\\ndoes not work (nums1 = [1,2,3])? getting mad its so obvious it should work, and in VSCode works"
                    },
                    {
                        "username": "user4130zD",
                        "content": "*Merge nums1 and nums2 into a single array sorted in non-decreasing order.*  \\nThis problem worded poor for someone who\\'s a beginner such as myself. They should also explain first that you must specifically replace values inside the array."
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "This is so easy task, but this C compilator suck af. \\nThere is even problem to print nums1 or nums2 from 0 to numxSize-1"
                    }
                ]
            },
            {
                "id": 2072005,
                "content": [
                    {
                        "username": "zhangjiayi1308",
                        "content": "del nums1[m:]\\n        for i in range(n):\\n             nums1.append(nums2[i])\\n        nums1.sort()"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    },
                    {
                        "username": "marcovisi",
                        "content": "Very simple solution\\n\\n        nums1[m:]=nums2\\n        nums1.sort()"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    },
                    {
                        "username": "hengameh",
                        "content": "Does any one know how we can implement   \\n*Min Heap Method* (Priority queue) or\\n*Tournament tree*  \\nfor **merging K sorted arrays**?\\n\\nHere is both solutions in C++, but I cannot convert it in Java.  \\n  \\nhttp://yourbitsandbytes.com/viewtopic.php?f=803&t=5662&p=8777#p8777   \\n  \\nI appreciate your help   \\nThanks"
                    },
                    {
                        "username": "vinjenks",
                        "content": "Good stuff! This one had some gotchas. My solution was fugly but it ran faster than 86% of others w/ JS."
                    },
                    {
                        "username": "not_turing",
                        "content": "My solution was accepted, but submission results are weird: 1. I got 0 ms runtime, beating 100% of other submitters. Something wrong with test cases or procedure? 2. Also, this is obviously done in place, how can memory consumed be different between different submitters? I was told I beat 14% of submitters with memory used 9.6 MB."
                    },
                    {
                        "username": "fireship_2004",
                        "content": "why do so many people ignore the follow-up part of the question? we\\'re supposed to do it in O(m+n) but most of the solution in the distribution chart are O(nlogn) because they use sort function."
                    },
                    {
                        "username": "rs1310",
                        "content": "A proper use of nums.resize( ); , nums.insert( );  &  nums.sort( ); .\\nShould be enough to solve this question for a beginner."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "why this code:\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1 = sorted(nums1 + nums2)\\n\\ndoes not work (nums1 = [1,2,3])? getting mad its so obvious it should work, and in VSCode works"
                    },
                    {
                        "username": "user4130zD",
                        "content": "*Merge nums1 and nums2 into a single array sorted in non-decreasing order.*  \\nThis problem worded poor for someone who\\'s a beginner such as myself. They should also explain first that you must specifically replace values inside the array."
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "This is so easy task, but this C compilator suck af. \\nThere is even problem to print nums1 or nums2 from 0 to numxSize-1"
                    }
                ]
            },
            {
                "id": 2070533,
                "content": [
                    {
                        "username": "zhangjiayi1308",
                        "content": "del nums1[m:]\\n        for i in range(n):\\n             nums1.append(nums2[i])\\n        nums1.sort()"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    },
                    {
                        "username": "marcovisi",
                        "content": "Very simple solution\\n\\n        nums1[m:]=nums2\\n        nums1.sort()"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    },
                    {
                        "username": "hengameh",
                        "content": "Does any one know how we can implement   \\n*Min Heap Method* (Priority queue) or\\n*Tournament tree*  \\nfor **merging K sorted arrays**?\\n\\nHere is both solutions in C++, but I cannot convert it in Java.  \\n  \\nhttp://yourbitsandbytes.com/viewtopic.php?f=803&t=5662&p=8777#p8777   \\n  \\nI appreciate your help   \\nThanks"
                    },
                    {
                        "username": "vinjenks",
                        "content": "Good stuff! This one had some gotchas. My solution was fugly but it ran faster than 86% of others w/ JS."
                    },
                    {
                        "username": "not_turing",
                        "content": "My solution was accepted, but submission results are weird: 1. I got 0 ms runtime, beating 100% of other submitters. Something wrong with test cases or procedure? 2. Also, this is obviously done in place, how can memory consumed be different between different submitters? I was told I beat 14% of submitters with memory used 9.6 MB."
                    },
                    {
                        "username": "fireship_2004",
                        "content": "why do so many people ignore the follow-up part of the question? we\\'re supposed to do it in O(m+n) but most of the solution in the distribution chart are O(nlogn) because they use sort function."
                    },
                    {
                        "username": "rs1310",
                        "content": "A proper use of nums.resize( ); , nums.insert( );  &  nums.sort( ); .\\nShould be enough to solve this question for a beginner."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "why this code:\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1 = sorted(nums1 + nums2)\\n\\ndoes not work (nums1 = [1,2,3])? getting mad its so obvious it should work, and in VSCode works"
                    },
                    {
                        "username": "user4130zD",
                        "content": "*Merge nums1 and nums2 into a single array sorted in non-decreasing order.*  \\nThis problem worded poor for someone who\\'s a beginner such as myself. They should also explain first that you must specifically replace values inside the array."
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "This is so easy task, but this C compilator suck af. \\nThere is even problem to print nums1 or nums2 from 0 to numxSize-1"
                    }
                ]
            },
            {
                "id": 2068530,
                "content": [
                    {
                        "username": "zhangjiayi1308",
                        "content": "del nums1[m:]\\n        for i in range(n):\\n             nums1.append(nums2[i])\\n        nums1.sort()"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    },
                    {
                        "username": "marcovisi",
                        "content": "Very simple solution\\n\\n        nums1[m:]=nums2\\n        nums1.sort()"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    },
                    {
                        "username": "hengameh",
                        "content": "Does any one know how we can implement   \\n*Min Heap Method* (Priority queue) or\\n*Tournament tree*  \\nfor **merging K sorted arrays**?\\n\\nHere is both solutions in C++, but I cannot convert it in Java.  \\n  \\nhttp://yourbitsandbytes.com/viewtopic.php?f=803&t=5662&p=8777#p8777   \\n  \\nI appreciate your help   \\nThanks"
                    },
                    {
                        "username": "vinjenks",
                        "content": "Good stuff! This one had some gotchas. My solution was fugly but it ran faster than 86% of others w/ JS."
                    },
                    {
                        "username": "not_turing",
                        "content": "My solution was accepted, but submission results are weird: 1. I got 0 ms runtime, beating 100% of other submitters. Something wrong with test cases or procedure? 2. Also, this is obviously done in place, how can memory consumed be different between different submitters? I was told I beat 14% of submitters with memory used 9.6 MB."
                    },
                    {
                        "username": "fireship_2004",
                        "content": "why do so many people ignore the follow-up part of the question? we\\'re supposed to do it in O(m+n) but most of the solution in the distribution chart are O(nlogn) because they use sort function."
                    },
                    {
                        "username": "rs1310",
                        "content": "A proper use of nums.resize( ); , nums.insert( );  &  nums.sort( ); .\\nShould be enough to solve this question for a beginner."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "why this code:\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1 = sorted(nums1 + nums2)\\n\\ndoes not work (nums1 = [1,2,3])? getting mad its so obvious it should work, and in VSCode works"
                    },
                    {
                        "username": "user4130zD",
                        "content": "*Merge nums1 and nums2 into a single array sorted in non-decreasing order.*  \\nThis problem worded poor for someone who\\'s a beginner such as myself. They should also explain first that you must specifically replace values inside the array."
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "This is so easy task, but this C compilator suck af. \\nThere is even problem to print nums1 or nums2 from 0 to numxSize-1"
                    }
                ]
            },
            {
                "id": 2068438,
                "content": [
                    {
                        "username": "zhangjiayi1308",
                        "content": "del nums1[m:]\\n        for i in range(n):\\n             nums1.append(nums2[i])\\n        nums1.sort()"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    },
                    {
                        "username": "marcovisi",
                        "content": "Very simple solution\\n\\n        nums1[m:]=nums2\\n        nums1.sort()"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    },
                    {
                        "username": "hengameh",
                        "content": "Does any one know how we can implement   \\n*Min Heap Method* (Priority queue) or\\n*Tournament tree*  \\nfor **merging K sorted arrays**?\\n\\nHere is both solutions in C++, but I cannot convert it in Java.  \\n  \\nhttp://yourbitsandbytes.com/viewtopic.php?f=803&t=5662&p=8777#p8777   \\n  \\nI appreciate your help   \\nThanks"
                    },
                    {
                        "username": "vinjenks",
                        "content": "Good stuff! This one had some gotchas. My solution was fugly but it ran faster than 86% of others w/ JS."
                    },
                    {
                        "username": "not_turing",
                        "content": "My solution was accepted, but submission results are weird: 1. I got 0 ms runtime, beating 100% of other submitters. Something wrong with test cases or procedure? 2. Also, this is obviously done in place, how can memory consumed be different between different submitters? I was told I beat 14% of submitters with memory used 9.6 MB."
                    },
                    {
                        "username": "fireship_2004",
                        "content": "why do so many people ignore the follow-up part of the question? we\\'re supposed to do it in O(m+n) but most of the solution in the distribution chart are O(nlogn) because they use sort function."
                    },
                    {
                        "username": "rs1310",
                        "content": "A proper use of nums.resize( ); , nums.insert( );  &  nums.sort( ); .\\nShould be enough to solve this question for a beginner."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "why this code:\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1 = sorted(nums1 + nums2)\\n\\ndoes not work (nums1 = [1,2,3])? getting mad its so obvious it should work, and in VSCode works"
                    },
                    {
                        "username": "user4130zD",
                        "content": "*Merge nums1 and nums2 into a single array sorted in non-decreasing order.*  \\nThis problem worded poor for someone who\\'s a beginner such as myself. They should also explain first that you must specifically replace values inside the array."
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "This is so easy task, but this C compilator suck af. \\nThere is even problem to print nums1 or nums2 from 0 to numxSize-1"
                    }
                ]
            },
            {
                "id": 2067982,
                "content": [
                    {
                        "username": "zhangjiayi1308",
                        "content": "del nums1[m:]\\n        for i in range(n):\\n             nums1.append(nums2[i])\\n        nums1.sort()"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    },
                    {
                        "username": "marcovisi",
                        "content": "Very simple solution\\n\\n        nums1[m:]=nums2\\n        nums1.sort()"
                    },
                    {
                        "username": "Anik0071",
                        "content": "yes very easy but with O(nlogn) complexity. try to optimize it."
                    },
                    {
                        "username": "hengameh",
                        "content": "Does any one know how we can implement   \\n*Min Heap Method* (Priority queue) or\\n*Tournament tree*  \\nfor **merging K sorted arrays**?\\n\\nHere is both solutions in C++, but I cannot convert it in Java.  \\n  \\nhttp://yourbitsandbytes.com/viewtopic.php?f=803&t=5662&p=8777#p8777   \\n  \\nI appreciate your help   \\nThanks"
                    },
                    {
                        "username": "vinjenks",
                        "content": "Good stuff! This one had some gotchas. My solution was fugly but it ran faster than 86% of others w/ JS."
                    },
                    {
                        "username": "not_turing",
                        "content": "My solution was accepted, but submission results are weird: 1. I got 0 ms runtime, beating 100% of other submitters. Something wrong with test cases or procedure? 2. Also, this is obviously done in place, how can memory consumed be different between different submitters? I was told I beat 14% of submitters with memory used 9.6 MB."
                    },
                    {
                        "username": "fireship_2004",
                        "content": "why do so many people ignore the follow-up part of the question? we\\'re supposed to do it in O(m+n) but most of the solution in the distribution chart are O(nlogn) because they use sort function."
                    },
                    {
                        "username": "rs1310",
                        "content": "A proper use of nums.resize( ); , nums.insert( );  &  nums.sort( ); .\\nShould be enough to solve this question for a beginner."
                    },
                    {
                        "username": "6CRIPT",
                        "content": "why this code:\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1 = sorted(nums1 + nums2)\\n\\ndoes not work (nums1 = [1,2,3])? getting mad its so obvious it should work, and in VSCode works"
                    },
                    {
                        "username": "user4130zD",
                        "content": "*Merge nums1 and nums2 into a single array sorted in non-decreasing order.*  \\nThis problem worded poor for someone who\\'s a beginner such as myself. They should also explain first that you must specifically replace values inside the array."
                    },
                    {
                        "username": "jakubwysiecki",
                        "content": "This is so easy task, but this C compilator suck af. \\nThere is even problem to print nums1 or nums2 from 0 to numxSize-1"
                    }
                ]
            },
            {
                "id": 2067248,
                "content": [
                    {
                        "username": "prabjot007",
                        "content": "Are we allowed to create a new array .. because that\\'s how I did it?"
                    },
                    {
                        "username": "Sambender9",
                        "content": "My Solution is right but it says its wrong. This question has a bug. \\n\\nvar merge = function(nums1, m, nums2, n) {\\n    let totalArray = [];\\n    // NUMS1 = [1,2,3,0,0,0] m = 3\\n    if(m > 0) { // 3 > 0 true\\n        for(var i = 0; i < m; i++ ) { // totalArray[1,2,3 ]\\n            totalArray.push(nums1[i]);\\n        }\\n    }\\n    if(n > 0) { // nums2 =[2,5,6] n = 3\\n        for(var i = 0; i < n; i++ ) { // totalArray[1,2,3,2,5,6 ]\\n            totalArray.push(nums2[i]);\\n        }\\n    }\\n    return totalArray.sort();\\n};"
                    },
                    {
                        "username": "BlindSmile",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=0;i<n;i++){\\n            nums1[i+m]=nums2[i];\\n        }\\n        Arrays.sort(nums1);\\n    }                \\n}"
                    },
                    {
                        "username": "harrisonseyounglee",
                        "content": "Why does this this not accepted????\\n\\n `class Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        nums1 = (nums1[0:m] + nums2[0:n])\\n        nums1.sort()\\n        print(nums1)\\n\\nsolution = Solution()\\nsolution.merge([1,2,3,0,0,0], 3, [2,5,6], 3)`"
                    },
                    {
                        "username": "kritik-sah",
                        "content": " `var merge = function(nums1, m, nums2, n) {\\n    nums1 = [...nums1.splice(0,m), ...nums2.splice(0,n)].sort((a, b) => a - b);\\n    console.log(\"=====>\",nums1)\\n    return nums1\\n};`\\nconsole.log is printing correctly but i don\\'t understand all test is getting failed"
                    },
                    {
                        "username": "sudhanshusingh0501",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        \\n        nums1 = nums1[:m]\\n        print(nums1)\\n        nums2 = nums2[:n]\\n        print(nums2)\\n\\n        for ele in nums2:\\n            nums1.append(ele)\\n        print(nums1)\\n        nums1.sort()\\n\\n\\n        print(nums1)\\n\\n        What could be the issue with my solution??"
                    },
                    {
                        "username": "Yuvesh95",
                        "content": "Hi, \\ncan someone please explain why this is not working.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        L1=[]\\n        L2=[]\\n        for i in range(m):\\n            L1.append(nums1[i])\\n        nums1=L1\\n        for j in range(n):\\n            nums1.append(nums2[j])\\n        for k in range(len(nums1)):\\n            m=nums1[k]\\n            idx=k\\n            c=k\\n            for l in range(k,len(nums1)):\\n                if nums1[l]<m:\\n                    m=nums1[l]\\n                    idx=c\\n                c+=1\\n            tmp= nums1[k]\\n            nums1[k]=m\\n            nums1[idx]=tmp\\n         print(nums1)\\n\\n\\n\\n        "
                    },
                    {
                        "username": "ThereIsNoSpoonSSJ5",
                        "content": "SOS!!!  Can someone tell me why my code is bringing a wrong answer???\\nThis works perfectly on another terminal..\\n\\nfunction merge(nums1, m, nums2, n) {\\n    let merge = nums1.concat(nums2)\\nlet filtered = merge.filter(nums=>{\\n  return nums !== 0\\n})\\nlet sorted = filtered.sort((a, b)=>{\\n  return a - b\\n})\\nreturn sorted\\n};"
                    },
                    {
                        "username": "ak1405",
                        "content": "CAN ANYONE FIND ERROR IN THIS CODE\\n\\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        int k=0;\\n        while(i<m && j<n){\\n            if(nums1[i]<=nums2[j]){\\n                nums1[k]=nums1[i];\\n                i++;\\n                k++;\\n            \\n            }\\n            else{\\n                nums1[k]=nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n       \\n     cout<<i<<j<<k;\\n\\n    \\n        \\n        while(j<n){\\n            nums1[k]=nums2[j];\\n           j++;\\n           k++;\\n        }\\n       }\\n};"
                    },
                    {
                        "username": "DeepakPal07",
                        "content": "Can someone tell why this solution is not working\nnums1 = sorted(nums1[:m]+nums2)\nIt's not modifying the nums1 at all\n"
                    }
                ]
            },
            {
                "id": 2065170,
                "content": [
                    {
                        "username": "prabjot007",
                        "content": "Are we allowed to create a new array .. because that\\'s how I did it?"
                    },
                    {
                        "username": "Sambender9",
                        "content": "My Solution is right but it says its wrong. This question has a bug. \\n\\nvar merge = function(nums1, m, nums2, n) {\\n    let totalArray = [];\\n    // NUMS1 = [1,2,3,0,0,0] m = 3\\n    if(m > 0) { // 3 > 0 true\\n        for(var i = 0; i < m; i++ ) { // totalArray[1,2,3 ]\\n            totalArray.push(nums1[i]);\\n        }\\n    }\\n    if(n > 0) { // nums2 =[2,5,6] n = 3\\n        for(var i = 0; i < n; i++ ) { // totalArray[1,2,3,2,5,6 ]\\n            totalArray.push(nums2[i]);\\n        }\\n    }\\n    return totalArray.sort();\\n};"
                    },
                    {
                        "username": "BlindSmile",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=0;i<n;i++){\\n            nums1[i+m]=nums2[i];\\n        }\\n        Arrays.sort(nums1);\\n    }                \\n}"
                    },
                    {
                        "username": "harrisonseyounglee",
                        "content": "Why does this this not accepted????\\n\\n `class Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        nums1 = (nums1[0:m] + nums2[0:n])\\n        nums1.sort()\\n        print(nums1)\\n\\nsolution = Solution()\\nsolution.merge([1,2,3,0,0,0], 3, [2,5,6], 3)`"
                    },
                    {
                        "username": "kritik-sah",
                        "content": " `var merge = function(nums1, m, nums2, n) {\\n    nums1 = [...nums1.splice(0,m), ...nums2.splice(0,n)].sort((a, b) => a - b);\\n    console.log(\"=====>\",nums1)\\n    return nums1\\n};`\\nconsole.log is printing correctly but i don\\'t understand all test is getting failed"
                    },
                    {
                        "username": "sudhanshusingh0501",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        \\n        nums1 = nums1[:m]\\n        print(nums1)\\n        nums2 = nums2[:n]\\n        print(nums2)\\n\\n        for ele in nums2:\\n            nums1.append(ele)\\n        print(nums1)\\n        nums1.sort()\\n\\n\\n        print(nums1)\\n\\n        What could be the issue with my solution??"
                    },
                    {
                        "username": "Yuvesh95",
                        "content": "Hi, \\ncan someone please explain why this is not working.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        L1=[]\\n        L2=[]\\n        for i in range(m):\\n            L1.append(nums1[i])\\n        nums1=L1\\n        for j in range(n):\\n            nums1.append(nums2[j])\\n        for k in range(len(nums1)):\\n            m=nums1[k]\\n            idx=k\\n            c=k\\n            for l in range(k,len(nums1)):\\n                if nums1[l]<m:\\n                    m=nums1[l]\\n                    idx=c\\n                c+=1\\n            tmp= nums1[k]\\n            nums1[k]=m\\n            nums1[idx]=tmp\\n         print(nums1)\\n\\n\\n\\n        "
                    },
                    {
                        "username": "ThereIsNoSpoonSSJ5",
                        "content": "SOS!!!  Can someone tell me why my code is bringing a wrong answer???\\nThis works perfectly on another terminal..\\n\\nfunction merge(nums1, m, nums2, n) {\\n    let merge = nums1.concat(nums2)\\nlet filtered = merge.filter(nums=>{\\n  return nums !== 0\\n})\\nlet sorted = filtered.sort((a, b)=>{\\n  return a - b\\n})\\nreturn sorted\\n};"
                    },
                    {
                        "username": "ak1405",
                        "content": "CAN ANYONE FIND ERROR IN THIS CODE\\n\\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        int k=0;\\n        while(i<m && j<n){\\n            if(nums1[i]<=nums2[j]){\\n                nums1[k]=nums1[i];\\n                i++;\\n                k++;\\n            \\n            }\\n            else{\\n                nums1[k]=nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n       \\n     cout<<i<<j<<k;\\n\\n    \\n        \\n        while(j<n){\\n            nums1[k]=nums2[j];\\n           j++;\\n           k++;\\n        }\\n       }\\n};"
                    },
                    {
                        "username": "DeepakPal07",
                        "content": "Can someone tell why this solution is not working\nnums1 = sorted(nums1[:m]+nums2)\nIt's not modifying the nums1 at all\n"
                    }
                ]
            },
            {
                "id": 2064790,
                "content": [
                    {
                        "username": "prabjot007",
                        "content": "Are we allowed to create a new array .. because that\\'s how I did it?"
                    },
                    {
                        "username": "Sambender9",
                        "content": "My Solution is right but it says its wrong. This question has a bug. \\n\\nvar merge = function(nums1, m, nums2, n) {\\n    let totalArray = [];\\n    // NUMS1 = [1,2,3,0,0,0] m = 3\\n    if(m > 0) { // 3 > 0 true\\n        for(var i = 0; i < m; i++ ) { // totalArray[1,2,3 ]\\n            totalArray.push(nums1[i]);\\n        }\\n    }\\n    if(n > 0) { // nums2 =[2,5,6] n = 3\\n        for(var i = 0; i < n; i++ ) { // totalArray[1,2,3,2,5,6 ]\\n            totalArray.push(nums2[i]);\\n        }\\n    }\\n    return totalArray.sort();\\n};"
                    },
                    {
                        "username": "BlindSmile",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=0;i<n;i++){\\n            nums1[i+m]=nums2[i];\\n        }\\n        Arrays.sort(nums1);\\n    }                \\n}"
                    },
                    {
                        "username": "harrisonseyounglee",
                        "content": "Why does this this not accepted????\\n\\n `class Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        nums1 = (nums1[0:m] + nums2[0:n])\\n        nums1.sort()\\n        print(nums1)\\n\\nsolution = Solution()\\nsolution.merge([1,2,3,0,0,0], 3, [2,5,6], 3)`"
                    },
                    {
                        "username": "kritik-sah",
                        "content": " `var merge = function(nums1, m, nums2, n) {\\n    nums1 = [...nums1.splice(0,m), ...nums2.splice(0,n)].sort((a, b) => a - b);\\n    console.log(\"=====>\",nums1)\\n    return nums1\\n};`\\nconsole.log is printing correctly but i don\\'t understand all test is getting failed"
                    },
                    {
                        "username": "sudhanshusingh0501",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        \\n        nums1 = nums1[:m]\\n        print(nums1)\\n        nums2 = nums2[:n]\\n        print(nums2)\\n\\n        for ele in nums2:\\n            nums1.append(ele)\\n        print(nums1)\\n        nums1.sort()\\n\\n\\n        print(nums1)\\n\\n        What could be the issue with my solution??"
                    },
                    {
                        "username": "Yuvesh95",
                        "content": "Hi, \\ncan someone please explain why this is not working.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        L1=[]\\n        L2=[]\\n        for i in range(m):\\n            L1.append(nums1[i])\\n        nums1=L1\\n        for j in range(n):\\n            nums1.append(nums2[j])\\n        for k in range(len(nums1)):\\n            m=nums1[k]\\n            idx=k\\n            c=k\\n            for l in range(k,len(nums1)):\\n                if nums1[l]<m:\\n                    m=nums1[l]\\n                    idx=c\\n                c+=1\\n            tmp= nums1[k]\\n            nums1[k]=m\\n            nums1[idx]=tmp\\n         print(nums1)\\n\\n\\n\\n        "
                    },
                    {
                        "username": "ThereIsNoSpoonSSJ5",
                        "content": "SOS!!!  Can someone tell me why my code is bringing a wrong answer???\\nThis works perfectly on another terminal..\\n\\nfunction merge(nums1, m, nums2, n) {\\n    let merge = nums1.concat(nums2)\\nlet filtered = merge.filter(nums=>{\\n  return nums !== 0\\n})\\nlet sorted = filtered.sort((a, b)=>{\\n  return a - b\\n})\\nreturn sorted\\n};"
                    },
                    {
                        "username": "ak1405",
                        "content": "CAN ANYONE FIND ERROR IN THIS CODE\\n\\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        int k=0;\\n        while(i<m && j<n){\\n            if(nums1[i]<=nums2[j]){\\n                nums1[k]=nums1[i];\\n                i++;\\n                k++;\\n            \\n            }\\n            else{\\n                nums1[k]=nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n       \\n     cout<<i<<j<<k;\\n\\n    \\n        \\n        while(j<n){\\n            nums1[k]=nums2[j];\\n           j++;\\n           k++;\\n        }\\n       }\\n};"
                    },
                    {
                        "username": "DeepakPal07",
                        "content": "Can someone tell why this solution is not working\nnums1 = sorted(nums1[:m]+nums2)\nIt's not modifying the nums1 at all\n"
                    }
                ]
            },
            {
                "id": 2063692,
                "content": [
                    {
                        "username": "prabjot007",
                        "content": "Are we allowed to create a new array .. because that\\'s how I did it?"
                    },
                    {
                        "username": "Sambender9",
                        "content": "My Solution is right but it says its wrong. This question has a bug. \\n\\nvar merge = function(nums1, m, nums2, n) {\\n    let totalArray = [];\\n    // NUMS1 = [1,2,3,0,0,0] m = 3\\n    if(m > 0) { // 3 > 0 true\\n        for(var i = 0; i < m; i++ ) { // totalArray[1,2,3 ]\\n            totalArray.push(nums1[i]);\\n        }\\n    }\\n    if(n > 0) { // nums2 =[2,5,6] n = 3\\n        for(var i = 0; i < n; i++ ) { // totalArray[1,2,3,2,5,6 ]\\n            totalArray.push(nums2[i]);\\n        }\\n    }\\n    return totalArray.sort();\\n};"
                    },
                    {
                        "username": "BlindSmile",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=0;i<n;i++){\\n            nums1[i+m]=nums2[i];\\n        }\\n        Arrays.sort(nums1);\\n    }                \\n}"
                    },
                    {
                        "username": "harrisonseyounglee",
                        "content": "Why does this this not accepted????\\n\\n `class Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        nums1 = (nums1[0:m] + nums2[0:n])\\n        nums1.sort()\\n        print(nums1)\\n\\nsolution = Solution()\\nsolution.merge([1,2,3,0,0,0], 3, [2,5,6], 3)`"
                    },
                    {
                        "username": "kritik-sah",
                        "content": " `var merge = function(nums1, m, nums2, n) {\\n    nums1 = [...nums1.splice(0,m), ...nums2.splice(0,n)].sort((a, b) => a - b);\\n    console.log(\"=====>\",nums1)\\n    return nums1\\n};`\\nconsole.log is printing correctly but i don\\'t understand all test is getting failed"
                    },
                    {
                        "username": "sudhanshusingh0501",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        \\n        nums1 = nums1[:m]\\n        print(nums1)\\n        nums2 = nums2[:n]\\n        print(nums2)\\n\\n        for ele in nums2:\\n            nums1.append(ele)\\n        print(nums1)\\n        nums1.sort()\\n\\n\\n        print(nums1)\\n\\n        What could be the issue with my solution??"
                    },
                    {
                        "username": "Yuvesh95",
                        "content": "Hi, \\ncan someone please explain why this is not working.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        L1=[]\\n        L2=[]\\n        for i in range(m):\\n            L1.append(nums1[i])\\n        nums1=L1\\n        for j in range(n):\\n            nums1.append(nums2[j])\\n        for k in range(len(nums1)):\\n            m=nums1[k]\\n            idx=k\\n            c=k\\n            for l in range(k,len(nums1)):\\n                if nums1[l]<m:\\n                    m=nums1[l]\\n                    idx=c\\n                c+=1\\n            tmp= nums1[k]\\n            nums1[k]=m\\n            nums1[idx]=tmp\\n         print(nums1)\\n\\n\\n\\n        "
                    },
                    {
                        "username": "ThereIsNoSpoonSSJ5",
                        "content": "SOS!!!  Can someone tell me why my code is bringing a wrong answer???\\nThis works perfectly on another terminal..\\n\\nfunction merge(nums1, m, nums2, n) {\\n    let merge = nums1.concat(nums2)\\nlet filtered = merge.filter(nums=>{\\n  return nums !== 0\\n})\\nlet sorted = filtered.sort((a, b)=>{\\n  return a - b\\n})\\nreturn sorted\\n};"
                    },
                    {
                        "username": "ak1405",
                        "content": "CAN ANYONE FIND ERROR IN THIS CODE\\n\\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        int k=0;\\n        while(i<m && j<n){\\n            if(nums1[i]<=nums2[j]){\\n                nums1[k]=nums1[i];\\n                i++;\\n                k++;\\n            \\n            }\\n            else{\\n                nums1[k]=nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n       \\n     cout<<i<<j<<k;\\n\\n    \\n        \\n        while(j<n){\\n            nums1[k]=nums2[j];\\n           j++;\\n           k++;\\n        }\\n       }\\n};"
                    },
                    {
                        "username": "DeepakPal07",
                        "content": "Can someone tell why this solution is not working\nnums1 = sorted(nums1[:m]+nums2)\nIt's not modifying the nums1 at all\n"
                    }
                ]
            },
            {
                "id": 2060801,
                "content": [
                    {
                        "username": "prabjot007",
                        "content": "Are we allowed to create a new array .. because that\\'s how I did it?"
                    },
                    {
                        "username": "Sambender9",
                        "content": "My Solution is right but it says its wrong. This question has a bug. \\n\\nvar merge = function(nums1, m, nums2, n) {\\n    let totalArray = [];\\n    // NUMS1 = [1,2,3,0,0,0] m = 3\\n    if(m > 0) { // 3 > 0 true\\n        for(var i = 0; i < m; i++ ) { // totalArray[1,2,3 ]\\n            totalArray.push(nums1[i]);\\n        }\\n    }\\n    if(n > 0) { // nums2 =[2,5,6] n = 3\\n        for(var i = 0; i < n; i++ ) { // totalArray[1,2,3,2,5,6 ]\\n            totalArray.push(nums2[i]);\\n        }\\n    }\\n    return totalArray.sort();\\n};"
                    },
                    {
                        "username": "BlindSmile",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=0;i<n;i++){\\n            nums1[i+m]=nums2[i];\\n        }\\n        Arrays.sort(nums1);\\n    }                \\n}"
                    },
                    {
                        "username": "harrisonseyounglee",
                        "content": "Why does this this not accepted????\\n\\n `class Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        nums1 = (nums1[0:m] + nums2[0:n])\\n        nums1.sort()\\n        print(nums1)\\n\\nsolution = Solution()\\nsolution.merge([1,2,3,0,0,0], 3, [2,5,6], 3)`"
                    },
                    {
                        "username": "kritik-sah",
                        "content": " `var merge = function(nums1, m, nums2, n) {\\n    nums1 = [...nums1.splice(0,m), ...nums2.splice(0,n)].sort((a, b) => a - b);\\n    console.log(\"=====>\",nums1)\\n    return nums1\\n};`\\nconsole.log is printing correctly but i don\\'t understand all test is getting failed"
                    },
                    {
                        "username": "sudhanshusingh0501",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        \\n        nums1 = nums1[:m]\\n        print(nums1)\\n        nums2 = nums2[:n]\\n        print(nums2)\\n\\n        for ele in nums2:\\n            nums1.append(ele)\\n        print(nums1)\\n        nums1.sort()\\n\\n\\n        print(nums1)\\n\\n        What could be the issue with my solution??"
                    },
                    {
                        "username": "Yuvesh95",
                        "content": "Hi, \\ncan someone please explain why this is not working.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        L1=[]\\n        L2=[]\\n        for i in range(m):\\n            L1.append(nums1[i])\\n        nums1=L1\\n        for j in range(n):\\n            nums1.append(nums2[j])\\n        for k in range(len(nums1)):\\n            m=nums1[k]\\n            idx=k\\n            c=k\\n            for l in range(k,len(nums1)):\\n                if nums1[l]<m:\\n                    m=nums1[l]\\n                    idx=c\\n                c+=1\\n            tmp= nums1[k]\\n            nums1[k]=m\\n            nums1[idx]=tmp\\n         print(nums1)\\n\\n\\n\\n        "
                    },
                    {
                        "username": "ThereIsNoSpoonSSJ5",
                        "content": "SOS!!!  Can someone tell me why my code is bringing a wrong answer???\\nThis works perfectly on another terminal..\\n\\nfunction merge(nums1, m, nums2, n) {\\n    let merge = nums1.concat(nums2)\\nlet filtered = merge.filter(nums=>{\\n  return nums !== 0\\n})\\nlet sorted = filtered.sort((a, b)=>{\\n  return a - b\\n})\\nreturn sorted\\n};"
                    },
                    {
                        "username": "ak1405",
                        "content": "CAN ANYONE FIND ERROR IN THIS CODE\\n\\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        int k=0;\\n        while(i<m && j<n){\\n            if(nums1[i]<=nums2[j]){\\n                nums1[k]=nums1[i];\\n                i++;\\n                k++;\\n            \\n            }\\n            else{\\n                nums1[k]=nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n       \\n     cout<<i<<j<<k;\\n\\n    \\n        \\n        while(j<n){\\n            nums1[k]=nums2[j];\\n           j++;\\n           k++;\\n        }\\n       }\\n};"
                    },
                    {
                        "username": "DeepakPal07",
                        "content": "Can someone tell why this solution is not working\nnums1 = sorted(nums1[:m]+nums2)\nIt's not modifying the nums1 at all\n"
                    }
                ]
            },
            {
                "id": 2060079,
                "content": [
                    {
                        "username": "prabjot007",
                        "content": "Are we allowed to create a new array .. because that\\'s how I did it?"
                    },
                    {
                        "username": "Sambender9",
                        "content": "My Solution is right but it says its wrong. This question has a bug. \\n\\nvar merge = function(nums1, m, nums2, n) {\\n    let totalArray = [];\\n    // NUMS1 = [1,2,3,0,0,0] m = 3\\n    if(m > 0) { // 3 > 0 true\\n        for(var i = 0; i < m; i++ ) { // totalArray[1,2,3 ]\\n            totalArray.push(nums1[i]);\\n        }\\n    }\\n    if(n > 0) { // nums2 =[2,5,6] n = 3\\n        for(var i = 0; i < n; i++ ) { // totalArray[1,2,3,2,5,6 ]\\n            totalArray.push(nums2[i]);\\n        }\\n    }\\n    return totalArray.sort();\\n};"
                    },
                    {
                        "username": "BlindSmile",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=0;i<n;i++){\\n            nums1[i+m]=nums2[i];\\n        }\\n        Arrays.sort(nums1);\\n    }                \\n}"
                    },
                    {
                        "username": "harrisonseyounglee",
                        "content": "Why does this this not accepted????\\n\\n `class Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        nums1 = (nums1[0:m] + nums2[0:n])\\n        nums1.sort()\\n        print(nums1)\\n\\nsolution = Solution()\\nsolution.merge([1,2,3,0,0,0], 3, [2,5,6], 3)`"
                    },
                    {
                        "username": "kritik-sah",
                        "content": " `var merge = function(nums1, m, nums2, n) {\\n    nums1 = [...nums1.splice(0,m), ...nums2.splice(0,n)].sort((a, b) => a - b);\\n    console.log(\"=====>\",nums1)\\n    return nums1\\n};`\\nconsole.log is printing correctly but i don\\'t understand all test is getting failed"
                    },
                    {
                        "username": "sudhanshusingh0501",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        \\n        nums1 = nums1[:m]\\n        print(nums1)\\n        nums2 = nums2[:n]\\n        print(nums2)\\n\\n        for ele in nums2:\\n            nums1.append(ele)\\n        print(nums1)\\n        nums1.sort()\\n\\n\\n        print(nums1)\\n\\n        What could be the issue with my solution??"
                    },
                    {
                        "username": "Yuvesh95",
                        "content": "Hi, \\ncan someone please explain why this is not working.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        L1=[]\\n        L2=[]\\n        for i in range(m):\\n            L1.append(nums1[i])\\n        nums1=L1\\n        for j in range(n):\\n            nums1.append(nums2[j])\\n        for k in range(len(nums1)):\\n            m=nums1[k]\\n            idx=k\\n            c=k\\n            for l in range(k,len(nums1)):\\n                if nums1[l]<m:\\n                    m=nums1[l]\\n                    idx=c\\n                c+=1\\n            tmp= nums1[k]\\n            nums1[k]=m\\n            nums1[idx]=tmp\\n         print(nums1)\\n\\n\\n\\n        "
                    },
                    {
                        "username": "ThereIsNoSpoonSSJ5",
                        "content": "SOS!!!  Can someone tell me why my code is bringing a wrong answer???\\nThis works perfectly on another terminal..\\n\\nfunction merge(nums1, m, nums2, n) {\\n    let merge = nums1.concat(nums2)\\nlet filtered = merge.filter(nums=>{\\n  return nums !== 0\\n})\\nlet sorted = filtered.sort((a, b)=>{\\n  return a - b\\n})\\nreturn sorted\\n};"
                    },
                    {
                        "username": "ak1405",
                        "content": "CAN ANYONE FIND ERROR IN THIS CODE\\n\\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        int k=0;\\n        while(i<m && j<n){\\n            if(nums1[i]<=nums2[j]){\\n                nums1[k]=nums1[i];\\n                i++;\\n                k++;\\n            \\n            }\\n            else{\\n                nums1[k]=nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n       \\n     cout<<i<<j<<k;\\n\\n    \\n        \\n        while(j<n){\\n            nums1[k]=nums2[j];\\n           j++;\\n           k++;\\n        }\\n       }\\n};"
                    },
                    {
                        "username": "DeepakPal07",
                        "content": "Can someone tell why this solution is not working\nnums1 = sorted(nums1[:m]+nums2)\nIt's not modifying the nums1 at all\n"
                    }
                ]
            },
            {
                "id": 2058126,
                "content": [
                    {
                        "username": "prabjot007",
                        "content": "Are we allowed to create a new array .. because that\\'s how I did it?"
                    },
                    {
                        "username": "Sambender9",
                        "content": "My Solution is right but it says its wrong. This question has a bug. \\n\\nvar merge = function(nums1, m, nums2, n) {\\n    let totalArray = [];\\n    // NUMS1 = [1,2,3,0,0,0] m = 3\\n    if(m > 0) { // 3 > 0 true\\n        for(var i = 0; i < m; i++ ) { // totalArray[1,2,3 ]\\n            totalArray.push(nums1[i]);\\n        }\\n    }\\n    if(n > 0) { // nums2 =[2,5,6] n = 3\\n        for(var i = 0; i < n; i++ ) { // totalArray[1,2,3,2,5,6 ]\\n            totalArray.push(nums2[i]);\\n        }\\n    }\\n    return totalArray.sort();\\n};"
                    },
                    {
                        "username": "BlindSmile",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=0;i<n;i++){\\n            nums1[i+m]=nums2[i];\\n        }\\n        Arrays.sort(nums1);\\n    }                \\n}"
                    },
                    {
                        "username": "harrisonseyounglee",
                        "content": "Why does this this not accepted????\\n\\n `class Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        nums1 = (nums1[0:m] + nums2[0:n])\\n        nums1.sort()\\n        print(nums1)\\n\\nsolution = Solution()\\nsolution.merge([1,2,3,0,0,0], 3, [2,5,6], 3)`"
                    },
                    {
                        "username": "kritik-sah",
                        "content": " `var merge = function(nums1, m, nums2, n) {\\n    nums1 = [...nums1.splice(0,m), ...nums2.splice(0,n)].sort((a, b) => a - b);\\n    console.log(\"=====>\",nums1)\\n    return nums1\\n};`\\nconsole.log is printing correctly but i don\\'t understand all test is getting failed"
                    },
                    {
                        "username": "sudhanshusingh0501",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        \\n        nums1 = nums1[:m]\\n        print(nums1)\\n        nums2 = nums2[:n]\\n        print(nums2)\\n\\n        for ele in nums2:\\n            nums1.append(ele)\\n        print(nums1)\\n        nums1.sort()\\n\\n\\n        print(nums1)\\n\\n        What could be the issue with my solution??"
                    },
                    {
                        "username": "Yuvesh95",
                        "content": "Hi, \\ncan someone please explain why this is not working.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        L1=[]\\n        L2=[]\\n        for i in range(m):\\n            L1.append(nums1[i])\\n        nums1=L1\\n        for j in range(n):\\n            nums1.append(nums2[j])\\n        for k in range(len(nums1)):\\n            m=nums1[k]\\n            idx=k\\n            c=k\\n            for l in range(k,len(nums1)):\\n                if nums1[l]<m:\\n                    m=nums1[l]\\n                    idx=c\\n                c+=1\\n            tmp= nums1[k]\\n            nums1[k]=m\\n            nums1[idx]=tmp\\n         print(nums1)\\n\\n\\n\\n        "
                    },
                    {
                        "username": "ThereIsNoSpoonSSJ5",
                        "content": "SOS!!!  Can someone tell me why my code is bringing a wrong answer???\\nThis works perfectly on another terminal..\\n\\nfunction merge(nums1, m, nums2, n) {\\n    let merge = nums1.concat(nums2)\\nlet filtered = merge.filter(nums=>{\\n  return nums !== 0\\n})\\nlet sorted = filtered.sort((a, b)=>{\\n  return a - b\\n})\\nreturn sorted\\n};"
                    },
                    {
                        "username": "ak1405",
                        "content": "CAN ANYONE FIND ERROR IN THIS CODE\\n\\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        int k=0;\\n        while(i<m && j<n){\\n            if(nums1[i]<=nums2[j]){\\n                nums1[k]=nums1[i];\\n                i++;\\n                k++;\\n            \\n            }\\n            else{\\n                nums1[k]=nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n       \\n     cout<<i<<j<<k;\\n\\n    \\n        \\n        while(j<n){\\n            nums1[k]=nums2[j];\\n           j++;\\n           k++;\\n        }\\n       }\\n};"
                    },
                    {
                        "username": "DeepakPal07",
                        "content": "Can someone tell why this solution is not working\nnums1 = sorted(nums1[:m]+nums2)\nIt's not modifying the nums1 at all\n"
                    }
                ]
            },
            {
                "id": 2056778,
                "content": [
                    {
                        "username": "prabjot007",
                        "content": "Are we allowed to create a new array .. because that\\'s how I did it?"
                    },
                    {
                        "username": "Sambender9",
                        "content": "My Solution is right but it says its wrong. This question has a bug. \\n\\nvar merge = function(nums1, m, nums2, n) {\\n    let totalArray = [];\\n    // NUMS1 = [1,2,3,0,0,0] m = 3\\n    if(m > 0) { // 3 > 0 true\\n        for(var i = 0; i < m; i++ ) { // totalArray[1,2,3 ]\\n            totalArray.push(nums1[i]);\\n        }\\n    }\\n    if(n > 0) { // nums2 =[2,5,6] n = 3\\n        for(var i = 0; i < n; i++ ) { // totalArray[1,2,3,2,5,6 ]\\n            totalArray.push(nums2[i]);\\n        }\\n    }\\n    return totalArray.sort();\\n};"
                    },
                    {
                        "username": "BlindSmile",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=0;i<n;i++){\\n            nums1[i+m]=nums2[i];\\n        }\\n        Arrays.sort(nums1);\\n    }                \\n}"
                    },
                    {
                        "username": "harrisonseyounglee",
                        "content": "Why does this this not accepted????\\n\\n `class Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        nums1 = (nums1[0:m] + nums2[0:n])\\n        nums1.sort()\\n        print(nums1)\\n\\nsolution = Solution()\\nsolution.merge([1,2,3,0,0,0], 3, [2,5,6], 3)`"
                    },
                    {
                        "username": "kritik-sah",
                        "content": " `var merge = function(nums1, m, nums2, n) {\\n    nums1 = [...nums1.splice(0,m), ...nums2.splice(0,n)].sort((a, b) => a - b);\\n    console.log(\"=====>\",nums1)\\n    return nums1\\n};`\\nconsole.log is printing correctly but i don\\'t understand all test is getting failed"
                    },
                    {
                        "username": "sudhanshusingh0501",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        \\n        nums1 = nums1[:m]\\n        print(nums1)\\n        nums2 = nums2[:n]\\n        print(nums2)\\n\\n        for ele in nums2:\\n            nums1.append(ele)\\n        print(nums1)\\n        nums1.sort()\\n\\n\\n        print(nums1)\\n\\n        What could be the issue with my solution??"
                    },
                    {
                        "username": "Yuvesh95",
                        "content": "Hi, \\ncan someone please explain why this is not working.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        L1=[]\\n        L2=[]\\n        for i in range(m):\\n            L1.append(nums1[i])\\n        nums1=L1\\n        for j in range(n):\\n            nums1.append(nums2[j])\\n        for k in range(len(nums1)):\\n            m=nums1[k]\\n            idx=k\\n            c=k\\n            for l in range(k,len(nums1)):\\n                if nums1[l]<m:\\n                    m=nums1[l]\\n                    idx=c\\n                c+=1\\n            tmp= nums1[k]\\n            nums1[k]=m\\n            nums1[idx]=tmp\\n         print(nums1)\\n\\n\\n\\n        "
                    },
                    {
                        "username": "ThereIsNoSpoonSSJ5",
                        "content": "SOS!!!  Can someone tell me why my code is bringing a wrong answer???\\nThis works perfectly on another terminal..\\n\\nfunction merge(nums1, m, nums2, n) {\\n    let merge = nums1.concat(nums2)\\nlet filtered = merge.filter(nums=>{\\n  return nums !== 0\\n})\\nlet sorted = filtered.sort((a, b)=>{\\n  return a - b\\n})\\nreturn sorted\\n};"
                    },
                    {
                        "username": "ak1405",
                        "content": "CAN ANYONE FIND ERROR IN THIS CODE\\n\\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        int k=0;\\n        while(i<m && j<n){\\n            if(nums1[i]<=nums2[j]){\\n                nums1[k]=nums1[i];\\n                i++;\\n                k++;\\n            \\n            }\\n            else{\\n                nums1[k]=nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n       \\n     cout<<i<<j<<k;\\n\\n    \\n        \\n        while(j<n){\\n            nums1[k]=nums2[j];\\n           j++;\\n           k++;\\n        }\\n       }\\n};"
                    },
                    {
                        "username": "DeepakPal07",
                        "content": "Can someone tell why this solution is not working\nnums1 = sorted(nums1[:m]+nums2)\nIt's not modifying the nums1 at all\n"
                    }
                ]
            },
            {
                "id": 2056291,
                "content": [
                    {
                        "username": "prabjot007",
                        "content": "Are we allowed to create a new array .. because that\\'s how I did it?"
                    },
                    {
                        "username": "Sambender9",
                        "content": "My Solution is right but it says its wrong. This question has a bug. \\n\\nvar merge = function(nums1, m, nums2, n) {\\n    let totalArray = [];\\n    // NUMS1 = [1,2,3,0,0,0] m = 3\\n    if(m > 0) { // 3 > 0 true\\n        for(var i = 0; i < m; i++ ) { // totalArray[1,2,3 ]\\n            totalArray.push(nums1[i]);\\n        }\\n    }\\n    if(n > 0) { // nums2 =[2,5,6] n = 3\\n        for(var i = 0; i < n; i++ ) { // totalArray[1,2,3,2,5,6 ]\\n            totalArray.push(nums2[i]);\\n        }\\n    }\\n    return totalArray.sort();\\n};"
                    },
                    {
                        "username": "BlindSmile",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=0;i<n;i++){\\n            nums1[i+m]=nums2[i];\\n        }\\n        Arrays.sort(nums1);\\n    }                \\n}"
                    },
                    {
                        "username": "harrisonseyounglee",
                        "content": "Why does this this not accepted????\\n\\n `class Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        nums1 = (nums1[0:m] + nums2[0:n])\\n        nums1.sort()\\n        print(nums1)\\n\\nsolution = Solution()\\nsolution.merge([1,2,3,0,0,0], 3, [2,5,6], 3)`"
                    },
                    {
                        "username": "kritik-sah",
                        "content": " `var merge = function(nums1, m, nums2, n) {\\n    nums1 = [...nums1.splice(0,m), ...nums2.splice(0,n)].sort((a, b) => a - b);\\n    console.log(\"=====>\",nums1)\\n    return nums1\\n};`\\nconsole.log is printing correctly but i don\\'t understand all test is getting failed"
                    },
                    {
                        "username": "sudhanshusingh0501",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        \\n        nums1 = nums1[:m]\\n        print(nums1)\\n        nums2 = nums2[:n]\\n        print(nums2)\\n\\n        for ele in nums2:\\n            nums1.append(ele)\\n        print(nums1)\\n        nums1.sort()\\n\\n\\n        print(nums1)\\n\\n        What could be the issue with my solution??"
                    },
                    {
                        "username": "Yuvesh95",
                        "content": "Hi, \\ncan someone please explain why this is not working.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        L1=[]\\n        L2=[]\\n        for i in range(m):\\n            L1.append(nums1[i])\\n        nums1=L1\\n        for j in range(n):\\n            nums1.append(nums2[j])\\n        for k in range(len(nums1)):\\n            m=nums1[k]\\n            idx=k\\n            c=k\\n            for l in range(k,len(nums1)):\\n                if nums1[l]<m:\\n                    m=nums1[l]\\n                    idx=c\\n                c+=1\\n            tmp= nums1[k]\\n            nums1[k]=m\\n            nums1[idx]=tmp\\n         print(nums1)\\n\\n\\n\\n        "
                    },
                    {
                        "username": "ThereIsNoSpoonSSJ5",
                        "content": "SOS!!!  Can someone tell me why my code is bringing a wrong answer???\\nThis works perfectly on another terminal..\\n\\nfunction merge(nums1, m, nums2, n) {\\n    let merge = nums1.concat(nums2)\\nlet filtered = merge.filter(nums=>{\\n  return nums !== 0\\n})\\nlet sorted = filtered.sort((a, b)=>{\\n  return a - b\\n})\\nreturn sorted\\n};"
                    },
                    {
                        "username": "ak1405",
                        "content": "CAN ANYONE FIND ERROR IN THIS CODE\\n\\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        int k=0;\\n        while(i<m && j<n){\\n            if(nums1[i]<=nums2[j]){\\n                nums1[k]=nums1[i];\\n                i++;\\n                k++;\\n            \\n            }\\n            else{\\n                nums1[k]=nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n       \\n     cout<<i<<j<<k;\\n\\n    \\n        \\n        while(j<n){\\n            nums1[k]=nums2[j];\\n           j++;\\n           k++;\\n        }\\n       }\\n};"
                    },
                    {
                        "username": "DeepakPal07",
                        "content": "Can someone tell why this solution is not working\nnums1 = sorted(nums1[:m]+nums2)\nIt's not modifying the nums1 at all\n"
                    }
                ]
            },
            {
                "id": 2055815,
                "content": [
                    {
                        "username": "prabjot007",
                        "content": "Are we allowed to create a new array .. because that\\'s how I did it?"
                    },
                    {
                        "username": "Sambender9",
                        "content": "My Solution is right but it says its wrong. This question has a bug. \\n\\nvar merge = function(nums1, m, nums2, n) {\\n    let totalArray = [];\\n    // NUMS1 = [1,2,3,0,0,0] m = 3\\n    if(m > 0) { // 3 > 0 true\\n        for(var i = 0; i < m; i++ ) { // totalArray[1,2,3 ]\\n            totalArray.push(nums1[i]);\\n        }\\n    }\\n    if(n > 0) { // nums2 =[2,5,6] n = 3\\n        for(var i = 0; i < n; i++ ) { // totalArray[1,2,3,2,5,6 ]\\n            totalArray.push(nums2[i]);\\n        }\\n    }\\n    return totalArray.sort();\\n};"
                    },
                    {
                        "username": "BlindSmile",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=0;i<n;i++){\\n            nums1[i+m]=nums2[i];\\n        }\\n        Arrays.sort(nums1);\\n    }                \\n}"
                    },
                    {
                        "username": "harrisonseyounglee",
                        "content": "Why does this this not accepted????\\n\\n `class Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        nums1 = (nums1[0:m] + nums2[0:n])\\n        nums1.sort()\\n        print(nums1)\\n\\nsolution = Solution()\\nsolution.merge([1,2,3,0,0,0], 3, [2,5,6], 3)`"
                    },
                    {
                        "username": "kritik-sah",
                        "content": " `var merge = function(nums1, m, nums2, n) {\\n    nums1 = [...nums1.splice(0,m), ...nums2.splice(0,n)].sort((a, b) => a - b);\\n    console.log(\"=====>\",nums1)\\n    return nums1\\n};`\\nconsole.log is printing correctly but i don\\'t understand all test is getting failed"
                    },
                    {
                        "username": "sudhanshusingh0501",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        \\n        nums1 = nums1[:m]\\n        print(nums1)\\n        nums2 = nums2[:n]\\n        print(nums2)\\n\\n        for ele in nums2:\\n            nums1.append(ele)\\n        print(nums1)\\n        nums1.sort()\\n\\n\\n        print(nums1)\\n\\n        What could be the issue with my solution??"
                    },
                    {
                        "username": "Yuvesh95",
                        "content": "Hi, \\ncan someone please explain why this is not working.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        L1=[]\\n        L2=[]\\n        for i in range(m):\\n            L1.append(nums1[i])\\n        nums1=L1\\n        for j in range(n):\\n            nums1.append(nums2[j])\\n        for k in range(len(nums1)):\\n            m=nums1[k]\\n            idx=k\\n            c=k\\n            for l in range(k,len(nums1)):\\n                if nums1[l]<m:\\n                    m=nums1[l]\\n                    idx=c\\n                c+=1\\n            tmp= nums1[k]\\n            nums1[k]=m\\n            nums1[idx]=tmp\\n         print(nums1)\\n\\n\\n\\n        "
                    },
                    {
                        "username": "ThereIsNoSpoonSSJ5",
                        "content": "SOS!!!  Can someone tell me why my code is bringing a wrong answer???\\nThis works perfectly on another terminal..\\n\\nfunction merge(nums1, m, nums2, n) {\\n    let merge = nums1.concat(nums2)\\nlet filtered = merge.filter(nums=>{\\n  return nums !== 0\\n})\\nlet sorted = filtered.sort((a, b)=>{\\n  return a - b\\n})\\nreturn sorted\\n};"
                    },
                    {
                        "username": "ak1405",
                        "content": "CAN ANYONE FIND ERROR IN THIS CODE\\n\\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        int k=0;\\n        while(i<m && j<n){\\n            if(nums1[i]<=nums2[j]){\\n                nums1[k]=nums1[i];\\n                i++;\\n                k++;\\n            \\n            }\\n            else{\\n                nums1[k]=nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n       \\n     cout<<i<<j<<k;\\n\\n    \\n        \\n        while(j<n){\\n            nums1[k]=nums2[j];\\n           j++;\\n           k++;\\n        }\\n       }\\n};"
                    },
                    {
                        "username": "DeepakPal07",
                        "content": "Can someone tell why this solution is not working\nnums1 = sorted(nums1[:m]+nums2)\nIt's not modifying the nums1 at all\n"
                    }
                ]
            },
            {
                "id": 2055347,
                "content": [
                    {
                        "username": "cdcdcd",
                        "content": "Do they want 0 or not? It\\'s so strange, since the sample remove the 0 in the output, but one of the testcases require 0 in the output. \\nnums1 =\\n[-1,0,0,3,3,3,0,0,0]\\nnums2 =\\n[1,2,2]\\n\\nMY Output\\n[-1,1,2,2,3,3,3]\\n\\nTHEY Expected\\n[-1,0,0,1,2,2,3,3,3]"
                    },
                    {
                        "username": "ersurajaky",
                        "content": "My output is correct but showing Wrong Answer."
                    },
                    {
                        "username": "Trish75",
                        "content": "I am Taking extra space and travesing from start, in Cout it is showing correct result but after submitting code its giving TLE, Pls help me to find what is issue here \\nhere is my code \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       \\n        vector<int>v(n+m);\\n        int nn=0,mm=0;\\n        for(int i=0 ;i<n+m ;i++ ){\\n            \\n            if(nn==n){\\n                v[i]=nums2[mm];\\n                mm++;\\n               \\n            }\\n            else if(mm==m){\\n               v[i]=nums1[nn];\\n                nn++;\\n                \\n            }\\n           else if(nums1[nn]<nums2[mm] && nn<n){v[i]=nums1[nn];nn++;}\\n\\n            else if(nums1[nn]>nums2[mm] && mm<m){v[i]=nums2[mm];mm++;}\\n            else if(nums1[nn]==nums2[mm]  && nn<n){v[i]=nums1[nn];nn++;}\\n            else if(nums1[nn]==nums2[mm]  && mm<m){v[i]=nums2[mm];mm++;}\\n            cout<< nn <<endl;\\n            cout<<mm<<endl;\\n        }\\n        for(int i=0;i<v.size();i++)cout<<v[i];\\n         for(int i=0;i<n+m;i++)nums1[i]=v[i];\\n    }\\n   \\n};"
                    },
                    {
                        "username": "Trish75",
                        "content": "Why This code giving RunTime Error  `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       \\n        vector<int>v(n+m);\\n        int nn=0,mm=0;\\n        for(int i=0 ;i<n+m ;i++ ){\\n            \\n            if(nn==n){\\n                v[i]=nums2[mm];\\n                mm++;\\n               \\n            }\\n            else if(mm==m){\\n               v[i]=nums1[nn];\\n                nn++;\\n                \\n            }\\n           else if(nums1[nn]<nums2[mm] && nn<n){v[i]=nums1[nn];nn++;}\\n\\n            else if(nums1[nn]>nums2[mm] && mm<m){v[i]=nums2[mm];mm++;}\\n            else if(nums1[nn]==nums2[mm]  && nn<n){v[i]=nums1[nn];nn++;}\\n            else if(nums1[nn]==nums2[mm]  && mm<m){v[i]=nums2[mm];mm++;}\\n            cout<< nn <<endl;\\n            cout<<mm<<endl;\\n        }\\n        for(int i=0;i<v.size();i++)cout<<v[i];\\n         for(int i=0;i<n+m;i++)nums1[i]=v[i];\\n    }\\n   \\n};"
                    },
                    {
                        "username": "dorshroitman0803",
                        "content": "anyone came with idea in place solve? in time complexity O(n+m)?"
                    },
                    {
                        "username": "Parag_Thakur",
                        "content": "After running it shows [1,2,2,3,5,6] in Stdout but [1,2,2,0,0,0] in Output and test case gets failed.\\nWhy this difference in Stdout and Output??????"
                    },
                    {
                        "username": "laser55",
                        "content": "   class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       int i=m-1;\\n       int j=n-1;\\n       int k=nums1.length-1;\\n       while(i>= 0 && j>=0){                         -->initializing i\\n           if(nums1[i]>nums2[j]){\\n               nums1[k]=nums1[i];\\n               k--;\\n               i--;\\n           }\\n           else{\\n               nums1[k]=nums2[j];\\n               k--;\\n               j--;\\n           }\\n\\n       }\\n\\n    }\\n}\\nwhen i try to initialize (I) in the while loop instead of if loop testcase 3 is failed anyone help me out why its not working and thank you in advance"
                    },
                    {
                        "username": "rahulsoni3108",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        vector<int>v;\\n        while (i<m && j<n){\\n            if (nums1[i]>=nums2[j]){\\n              v.push_back(nums2[j]);\\n              j++;\\n            }\\n             else if (nums1[i]<nums2[j]){\\n              v.push_back(nums1[i]);\\n              i++;\\n              \\n            }\\n        }\\n        if (i<m){\\n            v.push_back(nums1[i]);\\n            i++;\\n        }\\n        else if (j<n){\\n             v.push_back(nums2[j]);\\n            j++;\\n        }\\n        for (int k=0;k<m+n;k++){\\n          nums1[k]=v[k];\\n        }\\n    }\\nwhat is wrong with this code?\\nwhy it is not giving the desired output?\\n"
                    },
                    {
                        "username": "KrisChill",
                        "content": "m and n crying in the corner..."
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\n        int i = m;\\n        int j = 0;\\n\\n        while(i < nums1.size() ){\\n            nums1[i++] = nums2[j++];\\n        }\\n        sort(nums1.begin(), nums1.end() );\\n    }\\n};"
                    },
                    {
                        "username": "sandipuncc",
                        "content": "[@georgezakharov](/georgezakharov) Correct , my question was, why my code was not working ? I didn\\'t ask the answer"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2050431,
                "content": [
                    {
                        "username": "cdcdcd",
                        "content": "Do they want 0 or not? It\\'s so strange, since the sample remove the 0 in the output, but one of the testcases require 0 in the output. \\nnums1 =\\n[-1,0,0,3,3,3,0,0,0]\\nnums2 =\\n[1,2,2]\\n\\nMY Output\\n[-1,1,2,2,3,3,3]\\n\\nTHEY Expected\\n[-1,0,0,1,2,2,3,3,3]"
                    },
                    {
                        "username": "ersurajaky",
                        "content": "My output is correct but showing Wrong Answer."
                    },
                    {
                        "username": "Trish75",
                        "content": "I am Taking extra space and travesing from start, in Cout it is showing correct result but after submitting code its giving TLE, Pls help me to find what is issue here \\nhere is my code \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       \\n        vector<int>v(n+m);\\n        int nn=0,mm=0;\\n        for(int i=0 ;i<n+m ;i++ ){\\n            \\n            if(nn==n){\\n                v[i]=nums2[mm];\\n                mm++;\\n               \\n            }\\n            else if(mm==m){\\n               v[i]=nums1[nn];\\n                nn++;\\n                \\n            }\\n           else if(nums1[nn]<nums2[mm] && nn<n){v[i]=nums1[nn];nn++;}\\n\\n            else if(nums1[nn]>nums2[mm] && mm<m){v[i]=nums2[mm];mm++;}\\n            else if(nums1[nn]==nums2[mm]  && nn<n){v[i]=nums1[nn];nn++;}\\n            else if(nums1[nn]==nums2[mm]  && mm<m){v[i]=nums2[mm];mm++;}\\n            cout<< nn <<endl;\\n            cout<<mm<<endl;\\n        }\\n        for(int i=0;i<v.size();i++)cout<<v[i];\\n         for(int i=0;i<n+m;i++)nums1[i]=v[i];\\n    }\\n   \\n};"
                    },
                    {
                        "username": "Trish75",
                        "content": "Why This code giving RunTime Error  `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       \\n        vector<int>v(n+m);\\n        int nn=0,mm=0;\\n        for(int i=0 ;i<n+m ;i++ ){\\n            \\n            if(nn==n){\\n                v[i]=nums2[mm];\\n                mm++;\\n               \\n            }\\n            else if(mm==m){\\n               v[i]=nums1[nn];\\n                nn++;\\n                \\n            }\\n           else if(nums1[nn]<nums2[mm] && nn<n){v[i]=nums1[nn];nn++;}\\n\\n            else if(nums1[nn]>nums2[mm] && mm<m){v[i]=nums2[mm];mm++;}\\n            else if(nums1[nn]==nums2[mm]  && nn<n){v[i]=nums1[nn];nn++;}\\n            else if(nums1[nn]==nums2[mm]  && mm<m){v[i]=nums2[mm];mm++;}\\n            cout<< nn <<endl;\\n            cout<<mm<<endl;\\n        }\\n        for(int i=0;i<v.size();i++)cout<<v[i];\\n         for(int i=0;i<n+m;i++)nums1[i]=v[i];\\n    }\\n   \\n};"
                    },
                    {
                        "username": "dorshroitman0803",
                        "content": "anyone came with idea in place solve? in time complexity O(n+m)?"
                    },
                    {
                        "username": "Parag_Thakur",
                        "content": "After running it shows [1,2,2,3,5,6] in Stdout but [1,2,2,0,0,0] in Output and test case gets failed.\\nWhy this difference in Stdout and Output??????"
                    },
                    {
                        "username": "laser55",
                        "content": "   class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       int i=m-1;\\n       int j=n-1;\\n       int k=nums1.length-1;\\n       while(i>= 0 && j>=0){                         -->initializing i\\n           if(nums1[i]>nums2[j]){\\n               nums1[k]=nums1[i];\\n               k--;\\n               i--;\\n           }\\n           else{\\n               nums1[k]=nums2[j];\\n               k--;\\n               j--;\\n           }\\n\\n       }\\n\\n    }\\n}\\nwhen i try to initialize (I) in the while loop instead of if loop testcase 3 is failed anyone help me out why its not working and thank you in advance"
                    },
                    {
                        "username": "rahulsoni3108",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        vector<int>v;\\n        while (i<m && j<n){\\n            if (nums1[i]>=nums2[j]){\\n              v.push_back(nums2[j]);\\n              j++;\\n            }\\n             else if (nums1[i]<nums2[j]){\\n              v.push_back(nums1[i]);\\n              i++;\\n              \\n            }\\n        }\\n        if (i<m){\\n            v.push_back(nums1[i]);\\n            i++;\\n        }\\n        else if (j<n){\\n             v.push_back(nums2[j]);\\n            j++;\\n        }\\n        for (int k=0;k<m+n;k++){\\n          nums1[k]=v[k];\\n        }\\n    }\\nwhat is wrong with this code?\\nwhy it is not giving the desired output?\\n"
                    },
                    {
                        "username": "KrisChill",
                        "content": "m and n crying in the corner..."
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\n        int i = m;\\n        int j = 0;\\n\\n        while(i < nums1.size() ){\\n            nums1[i++] = nums2[j++];\\n        }\\n        sort(nums1.begin(), nums1.end() );\\n    }\\n};"
                    },
                    {
                        "username": "sandipuncc",
                        "content": "[@georgezakharov](/georgezakharov) Correct , my question was, why my code was not working ? I didn\\'t ask the answer"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2048810,
                "content": [
                    {
                        "username": "cdcdcd",
                        "content": "Do they want 0 or not? It\\'s so strange, since the sample remove the 0 in the output, but one of the testcases require 0 in the output. \\nnums1 =\\n[-1,0,0,3,3,3,0,0,0]\\nnums2 =\\n[1,2,2]\\n\\nMY Output\\n[-1,1,2,2,3,3,3]\\n\\nTHEY Expected\\n[-1,0,0,1,2,2,3,3,3]"
                    },
                    {
                        "username": "ersurajaky",
                        "content": "My output is correct but showing Wrong Answer."
                    },
                    {
                        "username": "Trish75",
                        "content": "I am Taking extra space and travesing from start, in Cout it is showing correct result but after submitting code its giving TLE, Pls help me to find what is issue here \\nhere is my code \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       \\n        vector<int>v(n+m);\\n        int nn=0,mm=0;\\n        for(int i=0 ;i<n+m ;i++ ){\\n            \\n            if(nn==n){\\n                v[i]=nums2[mm];\\n                mm++;\\n               \\n            }\\n            else if(mm==m){\\n               v[i]=nums1[nn];\\n                nn++;\\n                \\n            }\\n           else if(nums1[nn]<nums2[mm] && nn<n){v[i]=nums1[nn];nn++;}\\n\\n            else if(nums1[nn]>nums2[mm] && mm<m){v[i]=nums2[mm];mm++;}\\n            else if(nums1[nn]==nums2[mm]  && nn<n){v[i]=nums1[nn];nn++;}\\n            else if(nums1[nn]==nums2[mm]  && mm<m){v[i]=nums2[mm];mm++;}\\n            cout<< nn <<endl;\\n            cout<<mm<<endl;\\n        }\\n        for(int i=0;i<v.size();i++)cout<<v[i];\\n         for(int i=0;i<n+m;i++)nums1[i]=v[i];\\n    }\\n   \\n};"
                    },
                    {
                        "username": "Trish75",
                        "content": "Why This code giving RunTime Error  `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       \\n        vector<int>v(n+m);\\n        int nn=0,mm=0;\\n        for(int i=0 ;i<n+m ;i++ ){\\n            \\n            if(nn==n){\\n                v[i]=nums2[mm];\\n                mm++;\\n               \\n            }\\n            else if(mm==m){\\n               v[i]=nums1[nn];\\n                nn++;\\n                \\n            }\\n           else if(nums1[nn]<nums2[mm] && nn<n){v[i]=nums1[nn];nn++;}\\n\\n            else if(nums1[nn]>nums2[mm] && mm<m){v[i]=nums2[mm];mm++;}\\n            else if(nums1[nn]==nums2[mm]  && nn<n){v[i]=nums1[nn];nn++;}\\n            else if(nums1[nn]==nums2[mm]  && mm<m){v[i]=nums2[mm];mm++;}\\n            cout<< nn <<endl;\\n            cout<<mm<<endl;\\n        }\\n        for(int i=0;i<v.size();i++)cout<<v[i];\\n         for(int i=0;i<n+m;i++)nums1[i]=v[i];\\n    }\\n   \\n};"
                    },
                    {
                        "username": "dorshroitman0803",
                        "content": "anyone came with idea in place solve? in time complexity O(n+m)?"
                    },
                    {
                        "username": "Parag_Thakur",
                        "content": "After running it shows [1,2,2,3,5,6] in Stdout but [1,2,2,0,0,0] in Output and test case gets failed.\\nWhy this difference in Stdout and Output??????"
                    },
                    {
                        "username": "laser55",
                        "content": "   class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       int i=m-1;\\n       int j=n-1;\\n       int k=nums1.length-1;\\n       while(i>= 0 && j>=0){                         -->initializing i\\n           if(nums1[i]>nums2[j]){\\n               nums1[k]=nums1[i];\\n               k--;\\n               i--;\\n           }\\n           else{\\n               nums1[k]=nums2[j];\\n               k--;\\n               j--;\\n           }\\n\\n       }\\n\\n    }\\n}\\nwhen i try to initialize (I) in the while loop instead of if loop testcase 3 is failed anyone help me out why its not working and thank you in advance"
                    },
                    {
                        "username": "rahulsoni3108",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        vector<int>v;\\n        while (i<m && j<n){\\n            if (nums1[i]>=nums2[j]){\\n              v.push_back(nums2[j]);\\n              j++;\\n            }\\n             else if (nums1[i]<nums2[j]){\\n              v.push_back(nums1[i]);\\n              i++;\\n              \\n            }\\n        }\\n        if (i<m){\\n            v.push_back(nums1[i]);\\n            i++;\\n        }\\n        else if (j<n){\\n             v.push_back(nums2[j]);\\n            j++;\\n        }\\n        for (int k=0;k<m+n;k++){\\n          nums1[k]=v[k];\\n        }\\n    }\\nwhat is wrong with this code?\\nwhy it is not giving the desired output?\\n"
                    },
                    {
                        "username": "KrisChill",
                        "content": "m and n crying in the corner..."
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\n        int i = m;\\n        int j = 0;\\n\\n        while(i < nums1.size() ){\\n            nums1[i++] = nums2[j++];\\n        }\\n        sort(nums1.begin(), nums1.end() );\\n    }\\n};"
                    },
                    {
                        "username": "sandipuncc",
                        "content": "[@georgezakharov](/georgezakharov) Correct , my question was, why my code was not working ? I didn\\'t ask the answer"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2048807,
                "content": [
                    {
                        "username": "cdcdcd",
                        "content": "Do they want 0 or not? It\\'s so strange, since the sample remove the 0 in the output, but one of the testcases require 0 in the output. \\nnums1 =\\n[-1,0,0,3,3,3,0,0,0]\\nnums2 =\\n[1,2,2]\\n\\nMY Output\\n[-1,1,2,2,3,3,3]\\n\\nTHEY Expected\\n[-1,0,0,1,2,2,3,3,3]"
                    },
                    {
                        "username": "ersurajaky",
                        "content": "My output is correct but showing Wrong Answer."
                    },
                    {
                        "username": "Trish75",
                        "content": "I am Taking extra space and travesing from start, in Cout it is showing correct result but after submitting code its giving TLE, Pls help me to find what is issue here \\nhere is my code \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       \\n        vector<int>v(n+m);\\n        int nn=0,mm=0;\\n        for(int i=0 ;i<n+m ;i++ ){\\n            \\n            if(nn==n){\\n                v[i]=nums2[mm];\\n                mm++;\\n               \\n            }\\n            else if(mm==m){\\n               v[i]=nums1[nn];\\n                nn++;\\n                \\n            }\\n           else if(nums1[nn]<nums2[mm] && nn<n){v[i]=nums1[nn];nn++;}\\n\\n            else if(nums1[nn]>nums2[mm] && mm<m){v[i]=nums2[mm];mm++;}\\n            else if(nums1[nn]==nums2[mm]  && nn<n){v[i]=nums1[nn];nn++;}\\n            else if(nums1[nn]==nums2[mm]  && mm<m){v[i]=nums2[mm];mm++;}\\n            cout<< nn <<endl;\\n            cout<<mm<<endl;\\n        }\\n        for(int i=0;i<v.size();i++)cout<<v[i];\\n         for(int i=0;i<n+m;i++)nums1[i]=v[i];\\n    }\\n   \\n};"
                    },
                    {
                        "username": "Trish75",
                        "content": "Why This code giving RunTime Error  `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       \\n        vector<int>v(n+m);\\n        int nn=0,mm=0;\\n        for(int i=0 ;i<n+m ;i++ ){\\n            \\n            if(nn==n){\\n                v[i]=nums2[mm];\\n                mm++;\\n               \\n            }\\n            else if(mm==m){\\n               v[i]=nums1[nn];\\n                nn++;\\n                \\n            }\\n           else if(nums1[nn]<nums2[mm] && nn<n){v[i]=nums1[nn];nn++;}\\n\\n            else if(nums1[nn]>nums2[mm] && mm<m){v[i]=nums2[mm];mm++;}\\n            else if(nums1[nn]==nums2[mm]  && nn<n){v[i]=nums1[nn];nn++;}\\n            else if(nums1[nn]==nums2[mm]  && mm<m){v[i]=nums2[mm];mm++;}\\n            cout<< nn <<endl;\\n            cout<<mm<<endl;\\n        }\\n        for(int i=0;i<v.size();i++)cout<<v[i];\\n         for(int i=0;i<n+m;i++)nums1[i]=v[i];\\n    }\\n   \\n};"
                    },
                    {
                        "username": "dorshroitman0803",
                        "content": "anyone came with idea in place solve? in time complexity O(n+m)?"
                    },
                    {
                        "username": "Parag_Thakur",
                        "content": "After running it shows [1,2,2,3,5,6] in Stdout but [1,2,2,0,0,0] in Output and test case gets failed.\\nWhy this difference in Stdout and Output??????"
                    },
                    {
                        "username": "laser55",
                        "content": "   class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       int i=m-1;\\n       int j=n-1;\\n       int k=nums1.length-1;\\n       while(i>= 0 && j>=0){                         -->initializing i\\n           if(nums1[i]>nums2[j]){\\n               nums1[k]=nums1[i];\\n               k--;\\n               i--;\\n           }\\n           else{\\n               nums1[k]=nums2[j];\\n               k--;\\n               j--;\\n           }\\n\\n       }\\n\\n    }\\n}\\nwhen i try to initialize (I) in the while loop instead of if loop testcase 3 is failed anyone help me out why its not working and thank you in advance"
                    },
                    {
                        "username": "rahulsoni3108",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        vector<int>v;\\n        while (i<m && j<n){\\n            if (nums1[i]>=nums2[j]){\\n              v.push_back(nums2[j]);\\n              j++;\\n            }\\n             else if (nums1[i]<nums2[j]){\\n              v.push_back(nums1[i]);\\n              i++;\\n              \\n            }\\n        }\\n        if (i<m){\\n            v.push_back(nums1[i]);\\n            i++;\\n        }\\n        else if (j<n){\\n             v.push_back(nums2[j]);\\n            j++;\\n        }\\n        for (int k=0;k<m+n;k++){\\n          nums1[k]=v[k];\\n        }\\n    }\\nwhat is wrong with this code?\\nwhy it is not giving the desired output?\\n"
                    },
                    {
                        "username": "KrisChill",
                        "content": "m and n crying in the corner..."
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\n        int i = m;\\n        int j = 0;\\n\\n        while(i < nums1.size() ){\\n            nums1[i++] = nums2[j++];\\n        }\\n        sort(nums1.begin(), nums1.end() );\\n    }\\n};"
                    },
                    {
                        "username": "sandipuncc",
                        "content": "[@georgezakharov](/georgezakharov) Correct , my question was, why my code was not working ? I didn\\'t ask the answer"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2045810,
                "content": [
                    {
                        "username": "cdcdcd",
                        "content": "Do they want 0 or not? It\\'s so strange, since the sample remove the 0 in the output, but one of the testcases require 0 in the output. \\nnums1 =\\n[-1,0,0,3,3,3,0,0,0]\\nnums2 =\\n[1,2,2]\\n\\nMY Output\\n[-1,1,2,2,3,3,3]\\n\\nTHEY Expected\\n[-1,0,0,1,2,2,3,3,3]"
                    },
                    {
                        "username": "ersurajaky",
                        "content": "My output is correct but showing Wrong Answer."
                    },
                    {
                        "username": "Trish75",
                        "content": "I am Taking extra space and travesing from start, in Cout it is showing correct result but after submitting code its giving TLE, Pls help me to find what is issue here \\nhere is my code \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       \\n        vector<int>v(n+m);\\n        int nn=0,mm=0;\\n        for(int i=0 ;i<n+m ;i++ ){\\n            \\n            if(nn==n){\\n                v[i]=nums2[mm];\\n                mm++;\\n               \\n            }\\n            else if(mm==m){\\n               v[i]=nums1[nn];\\n                nn++;\\n                \\n            }\\n           else if(nums1[nn]<nums2[mm] && nn<n){v[i]=nums1[nn];nn++;}\\n\\n            else if(nums1[nn]>nums2[mm] && mm<m){v[i]=nums2[mm];mm++;}\\n            else if(nums1[nn]==nums2[mm]  && nn<n){v[i]=nums1[nn];nn++;}\\n            else if(nums1[nn]==nums2[mm]  && mm<m){v[i]=nums2[mm];mm++;}\\n            cout<< nn <<endl;\\n            cout<<mm<<endl;\\n        }\\n        for(int i=0;i<v.size();i++)cout<<v[i];\\n         for(int i=0;i<n+m;i++)nums1[i]=v[i];\\n    }\\n   \\n};"
                    },
                    {
                        "username": "Trish75",
                        "content": "Why This code giving RunTime Error  `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       \\n        vector<int>v(n+m);\\n        int nn=0,mm=0;\\n        for(int i=0 ;i<n+m ;i++ ){\\n            \\n            if(nn==n){\\n                v[i]=nums2[mm];\\n                mm++;\\n               \\n            }\\n            else if(mm==m){\\n               v[i]=nums1[nn];\\n                nn++;\\n                \\n            }\\n           else if(nums1[nn]<nums2[mm] && nn<n){v[i]=nums1[nn];nn++;}\\n\\n            else if(nums1[nn]>nums2[mm] && mm<m){v[i]=nums2[mm];mm++;}\\n            else if(nums1[nn]==nums2[mm]  && nn<n){v[i]=nums1[nn];nn++;}\\n            else if(nums1[nn]==nums2[mm]  && mm<m){v[i]=nums2[mm];mm++;}\\n            cout<< nn <<endl;\\n            cout<<mm<<endl;\\n        }\\n        for(int i=0;i<v.size();i++)cout<<v[i];\\n         for(int i=0;i<n+m;i++)nums1[i]=v[i];\\n    }\\n   \\n};"
                    },
                    {
                        "username": "dorshroitman0803",
                        "content": "anyone came with idea in place solve? in time complexity O(n+m)?"
                    },
                    {
                        "username": "Parag_Thakur",
                        "content": "After running it shows [1,2,2,3,5,6] in Stdout but [1,2,2,0,0,0] in Output and test case gets failed.\\nWhy this difference in Stdout and Output??????"
                    },
                    {
                        "username": "laser55",
                        "content": "   class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       int i=m-1;\\n       int j=n-1;\\n       int k=nums1.length-1;\\n       while(i>= 0 && j>=0){                         -->initializing i\\n           if(nums1[i]>nums2[j]){\\n               nums1[k]=nums1[i];\\n               k--;\\n               i--;\\n           }\\n           else{\\n               nums1[k]=nums2[j];\\n               k--;\\n               j--;\\n           }\\n\\n       }\\n\\n    }\\n}\\nwhen i try to initialize (I) in the while loop instead of if loop testcase 3 is failed anyone help me out why its not working and thank you in advance"
                    },
                    {
                        "username": "rahulsoni3108",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        vector<int>v;\\n        while (i<m && j<n){\\n            if (nums1[i]>=nums2[j]){\\n              v.push_back(nums2[j]);\\n              j++;\\n            }\\n             else if (nums1[i]<nums2[j]){\\n              v.push_back(nums1[i]);\\n              i++;\\n              \\n            }\\n        }\\n        if (i<m){\\n            v.push_back(nums1[i]);\\n            i++;\\n        }\\n        else if (j<n){\\n             v.push_back(nums2[j]);\\n            j++;\\n        }\\n        for (int k=0;k<m+n;k++){\\n          nums1[k]=v[k];\\n        }\\n    }\\nwhat is wrong with this code?\\nwhy it is not giving the desired output?\\n"
                    },
                    {
                        "username": "KrisChill",
                        "content": "m and n crying in the corner..."
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\n        int i = m;\\n        int j = 0;\\n\\n        while(i < nums1.size() ){\\n            nums1[i++] = nums2[j++];\\n        }\\n        sort(nums1.begin(), nums1.end() );\\n    }\\n};"
                    },
                    {
                        "username": "sandipuncc",
                        "content": "[@georgezakharov](/georgezakharov) Correct , my question was, why my code was not working ? I didn\\'t ask the answer"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2045394,
                "content": [
                    {
                        "username": "cdcdcd",
                        "content": "Do they want 0 or not? It\\'s so strange, since the sample remove the 0 in the output, but one of the testcases require 0 in the output. \\nnums1 =\\n[-1,0,0,3,3,3,0,0,0]\\nnums2 =\\n[1,2,2]\\n\\nMY Output\\n[-1,1,2,2,3,3,3]\\n\\nTHEY Expected\\n[-1,0,0,1,2,2,3,3,3]"
                    },
                    {
                        "username": "ersurajaky",
                        "content": "My output is correct but showing Wrong Answer."
                    },
                    {
                        "username": "Trish75",
                        "content": "I am Taking extra space and travesing from start, in Cout it is showing correct result but after submitting code its giving TLE, Pls help me to find what is issue here \\nhere is my code \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       \\n        vector<int>v(n+m);\\n        int nn=0,mm=0;\\n        for(int i=0 ;i<n+m ;i++ ){\\n            \\n            if(nn==n){\\n                v[i]=nums2[mm];\\n                mm++;\\n               \\n            }\\n            else if(mm==m){\\n               v[i]=nums1[nn];\\n                nn++;\\n                \\n            }\\n           else if(nums1[nn]<nums2[mm] && nn<n){v[i]=nums1[nn];nn++;}\\n\\n            else if(nums1[nn]>nums2[mm] && mm<m){v[i]=nums2[mm];mm++;}\\n            else if(nums1[nn]==nums2[mm]  && nn<n){v[i]=nums1[nn];nn++;}\\n            else if(nums1[nn]==nums2[mm]  && mm<m){v[i]=nums2[mm];mm++;}\\n            cout<< nn <<endl;\\n            cout<<mm<<endl;\\n        }\\n        for(int i=0;i<v.size();i++)cout<<v[i];\\n         for(int i=0;i<n+m;i++)nums1[i]=v[i];\\n    }\\n   \\n};"
                    },
                    {
                        "username": "Trish75",
                        "content": "Why This code giving RunTime Error  `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       \\n        vector<int>v(n+m);\\n        int nn=0,mm=0;\\n        for(int i=0 ;i<n+m ;i++ ){\\n            \\n            if(nn==n){\\n                v[i]=nums2[mm];\\n                mm++;\\n               \\n            }\\n            else if(mm==m){\\n               v[i]=nums1[nn];\\n                nn++;\\n                \\n            }\\n           else if(nums1[nn]<nums2[mm] && nn<n){v[i]=nums1[nn];nn++;}\\n\\n            else if(nums1[nn]>nums2[mm] && mm<m){v[i]=nums2[mm];mm++;}\\n            else if(nums1[nn]==nums2[mm]  && nn<n){v[i]=nums1[nn];nn++;}\\n            else if(nums1[nn]==nums2[mm]  && mm<m){v[i]=nums2[mm];mm++;}\\n            cout<< nn <<endl;\\n            cout<<mm<<endl;\\n        }\\n        for(int i=0;i<v.size();i++)cout<<v[i];\\n         for(int i=0;i<n+m;i++)nums1[i]=v[i];\\n    }\\n   \\n};"
                    },
                    {
                        "username": "dorshroitman0803",
                        "content": "anyone came with idea in place solve? in time complexity O(n+m)?"
                    },
                    {
                        "username": "Parag_Thakur",
                        "content": "After running it shows [1,2,2,3,5,6] in Stdout but [1,2,2,0,0,0] in Output and test case gets failed.\\nWhy this difference in Stdout and Output??????"
                    },
                    {
                        "username": "laser55",
                        "content": "   class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       int i=m-1;\\n       int j=n-1;\\n       int k=nums1.length-1;\\n       while(i>= 0 && j>=0){                         -->initializing i\\n           if(nums1[i]>nums2[j]){\\n               nums1[k]=nums1[i];\\n               k--;\\n               i--;\\n           }\\n           else{\\n               nums1[k]=nums2[j];\\n               k--;\\n               j--;\\n           }\\n\\n       }\\n\\n    }\\n}\\nwhen i try to initialize (I) in the while loop instead of if loop testcase 3 is failed anyone help me out why its not working and thank you in advance"
                    },
                    {
                        "username": "rahulsoni3108",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        vector<int>v;\\n        while (i<m && j<n){\\n            if (nums1[i]>=nums2[j]){\\n              v.push_back(nums2[j]);\\n              j++;\\n            }\\n             else if (nums1[i]<nums2[j]){\\n              v.push_back(nums1[i]);\\n              i++;\\n              \\n            }\\n        }\\n        if (i<m){\\n            v.push_back(nums1[i]);\\n            i++;\\n        }\\n        else if (j<n){\\n             v.push_back(nums2[j]);\\n            j++;\\n        }\\n        for (int k=0;k<m+n;k++){\\n          nums1[k]=v[k];\\n        }\\n    }\\nwhat is wrong with this code?\\nwhy it is not giving the desired output?\\n"
                    },
                    {
                        "username": "KrisChill",
                        "content": "m and n crying in the corner..."
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\n        int i = m;\\n        int j = 0;\\n\\n        while(i < nums1.size() ){\\n            nums1[i++] = nums2[j++];\\n        }\\n        sort(nums1.begin(), nums1.end() );\\n    }\\n};"
                    },
                    {
                        "username": "sandipuncc",
                        "content": "[@georgezakharov](/georgezakharov) Correct , my question was, why my code was not working ? I didn\\'t ask the answer"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2043384,
                "content": [
                    {
                        "username": "cdcdcd",
                        "content": "Do they want 0 or not? It\\'s so strange, since the sample remove the 0 in the output, but one of the testcases require 0 in the output. \\nnums1 =\\n[-1,0,0,3,3,3,0,0,0]\\nnums2 =\\n[1,2,2]\\n\\nMY Output\\n[-1,1,2,2,3,3,3]\\n\\nTHEY Expected\\n[-1,0,0,1,2,2,3,3,3]"
                    },
                    {
                        "username": "ersurajaky",
                        "content": "My output is correct but showing Wrong Answer."
                    },
                    {
                        "username": "Trish75",
                        "content": "I am Taking extra space and travesing from start, in Cout it is showing correct result but after submitting code its giving TLE, Pls help me to find what is issue here \\nhere is my code \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       \\n        vector<int>v(n+m);\\n        int nn=0,mm=0;\\n        for(int i=0 ;i<n+m ;i++ ){\\n            \\n            if(nn==n){\\n                v[i]=nums2[mm];\\n                mm++;\\n               \\n            }\\n            else if(mm==m){\\n               v[i]=nums1[nn];\\n                nn++;\\n                \\n            }\\n           else if(nums1[nn]<nums2[mm] && nn<n){v[i]=nums1[nn];nn++;}\\n\\n            else if(nums1[nn]>nums2[mm] && mm<m){v[i]=nums2[mm];mm++;}\\n            else if(nums1[nn]==nums2[mm]  && nn<n){v[i]=nums1[nn];nn++;}\\n            else if(nums1[nn]==nums2[mm]  && mm<m){v[i]=nums2[mm];mm++;}\\n            cout<< nn <<endl;\\n            cout<<mm<<endl;\\n        }\\n        for(int i=0;i<v.size();i++)cout<<v[i];\\n         for(int i=0;i<n+m;i++)nums1[i]=v[i];\\n    }\\n   \\n};"
                    },
                    {
                        "username": "Trish75",
                        "content": "Why This code giving RunTime Error  `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       \\n        vector<int>v(n+m);\\n        int nn=0,mm=0;\\n        for(int i=0 ;i<n+m ;i++ ){\\n            \\n            if(nn==n){\\n                v[i]=nums2[mm];\\n                mm++;\\n               \\n            }\\n            else if(mm==m){\\n               v[i]=nums1[nn];\\n                nn++;\\n                \\n            }\\n           else if(nums1[nn]<nums2[mm] && nn<n){v[i]=nums1[nn];nn++;}\\n\\n            else if(nums1[nn]>nums2[mm] && mm<m){v[i]=nums2[mm];mm++;}\\n            else if(nums1[nn]==nums2[mm]  && nn<n){v[i]=nums1[nn];nn++;}\\n            else if(nums1[nn]==nums2[mm]  && mm<m){v[i]=nums2[mm];mm++;}\\n            cout<< nn <<endl;\\n            cout<<mm<<endl;\\n        }\\n        for(int i=0;i<v.size();i++)cout<<v[i];\\n         for(int i=0;i<n+m;i++)nums1[i]=v[i];\\n    }\\n   \\n};"
                    },
                    {
                        "username": "dorshroitman0803",
                        "content": "anyone came with idea in place solve? in time complexity O(n+m)?"
                    },
                    {
                        "username": "Parag_Thakur",
                        "content": "After running it shows [1,2,2,3,5,6] in Stdout but [1,2,2,0,0,0] in Output and test case gets failed.\\nWhy this difference in Stdout and Output??????"
                    },
                    {
                        "username": "laser55",
                        "content": "   class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       int i=m-1;\\n       int j=n-1;\\n       int k=nums1.length-1;\\n       while(i>= 0 && j>=0){                         -->initializing i\\n           if(nums1[i]>nums2[j]){\\n               nums1[k]=nums1[i];\\n               k--;\\n               i--;\\n           }\\n           else{\\n               nums1[k]=nums2[j];\\n               k--;\\n               j--;\\n           }\\n\\n       }\\n\\n    }\\n}\\nwhen i try to initialize (I) in the while loop instead of if loop testcase 3 is failed anyone help me out why its not working and thank you in advance"
                    },
                    {
                        "username": "rahulsoni3108",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        vector<int>v;\\n        while (i<m && j<n){\\n            if (nums1[i]>=nums2[j]){\\n              v.push_back(nums2[j]);\\n              j++;\\n            }\\n             else if (nums1[i]<nums2[j]){\\n              v.push_back(nums1[i]);\\n              i++;\\n              \\n            }\\n        }\\n        if (i<m){\\n            v.push_back(nums1[i]);\\n            i++;\\n        }\\n        else if (j<n){\\n             v.push_back(nums2[j]);\\n            j++;\\n        }\\n        for (int k=0;k<m+n;k++){\\n          nums1[k]=v[k];\\n        }\\n    }\\nwhat is wrong with this code?\\nwhy it is not giving the desired output?\\n"
                    },
                    {
                        "username": "KrisChill",
                        "content": "m and n crying in the corner..."
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\n        int i = m;\\n        int j = 0;\\n\\n        while(i < nums1.size() ){\\n            nums1[i++] = nums2[j++];\\n        }\\n        sort(nums1.begin(), nums1.end() );\\n    }\\n};"
                    },
                    {
                        "username": "sandipuncc",
                        "content": "[@georgezakharov](/georgezakharov) Correct , my question was, why my code was not working ? I didn\\'t ask the answer"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2043050,
                "content": [
                    {
                        "username": "cdcdcd",
                        "content": "Do they want 0 or not? It\\'s so strange, since the sample remove the 0 in the output, but one of the testcases require 0 in the output. \\nnums1 =\\n[-1,0,0,3,3,3,0,0,0]\\nnums2 =\\n[1,2,2]\\n\\nMY Output\\n[-1,1,2,2,3,3,3]\\n\\nTHEY Expected\\n[-1,0,0,1,2,2,3,3,3]"
                    },
                    {
                        "username": "ersurajaky",
                        "content": "My output is correct but showing Wrong Answer."
                    },
                    {
                        "username": "Trish75",
                        "content": "I am Taking extra space and travesing from start, in Cout it is showing correct result but after submitting code its giving TLE, Pls help me to find what is issue here \\nhere is my code \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       \\n        vector<int>v(n+m);\\n        int nn=0,mm=0;\\n        for(int i=0 ;i<n+m ;i++ ){\\n            \\n            if(nn==n){\\n                v[i]=nums2[mm];\\n                mm++;\\n               \\n            }\\n            else if(mm==m){\\n               v[i]=nums1[nn];\\n                nn++;\\n                \\n            }\\n           else if(nums1[nn]<nums2[mm] && nn<n){v[i]=nums1[nn];nn++;}\\n\\n            else if(nums1[nn]>nums2[mm] && mm<m){v[i]=nums2[mm];mm++;}\\n            else if(nums1[nn]==nums2[mm]  && nn<n){v[i]=nums1[nn];nn++;}\\n            else if(nums1[nn]==nums2[mm]  && mm<m){v[i]=nums2[mm];mm++;}\\n            cout<< nn <<endl;\\n            cout<<mm<<endl;\\n        }\\n        for(int i=0;i<v.size();i++)cout<<v[i];\\n         for(int i=0;i<n+m;i++)nums1[i]=v[i];\\n    }\\n   \\n};"
                    },
                    {
                        "username": "Trish75",
                        "content": "Why This code giving RunTime Error  `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       \\n        vector<int>v(n+m);\\n        int nn=0,mm=0;\\n        for(int i=0 ;i<n+m ;i++ ){\\n            \\n            if(nn==n){\\n                v[i]=nums2[mm];\\n                mm++;\\n               \\n            }\\n            else if(mm==m){\\n               v[i]=nums1[nn];\\n                nn++;\\n                \\n            }\\n           else if(nums1[nn]<nums2[mm] && nn<n){v[i]=nums1[nn];nn++;}\\n\\n            else if(nums1[nn]>nums2[mm] && mm<m){v[i]=nums2[mm];mm++;}\\n            else if(nums1[nn]==nums2[mm]  && nn<n){v[i]=nums1[nn];nn++;}\\n            else if(nums1[nn]==nums2[mm]  && mm<m){v[i]=nums2[mm];mm++;}\\n            cout<< nn <<endl;\\n            cout<<mm<<endl;\\n        }\\n        for(int i=0;i<v.size();i++)cout<<v[i];\\n         for(int i=0;i<n+m;i++)nums1[i]=v[i];\\n    }\\n   \\n};"
                    },
                    {
                        "username": "dorshroitman0803",
                        "content": "anyone came with idea in place solve? in time complexity O(n+m)?"
                    },
                    {
                        "username": "Parag_Thakur",
                        "content": "After running it shows [1,2,2,3,5,6] in Stdout but [1,2,2,0,0,0] in Output and test case gets failed.\\nWhy this difference in Stdout and Output??????"
                    },
                    {
                        "username": "laser55",
                        "content": "   class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       int i=m-1;\\n       int j=n-1;\\n       int k=nums1.length-1;\\n       while(i>= 0 && j>=0){                         -->initializing i\\n           if(nums1[i]>nums2[j]){\\n               nums1[k]=nums1[i];\\n               k--;\\n               i--;\\n           }\\n           else{\\n               nums1[k]=nums2[j];\\n               k--;\\n               j--;\\n           }\\n\\n       }\\n\\n    }\\n}\\nwhen i try to initialize (I) in the while loop instead of if loop testcase 3 is failed anyone help me out why its not working and thank you in advance"
                    },
                    {
                        "username": "rahulsoni3108",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        vector<int>v;\\n        while (i<m && j<n){\\n            if (nums1[i]>=nums2[j]){\\n              v.push_back(nums2[j]);\\n              j++;\\n            }\\n             else if (nums1[i]<nums2[j]){\\n              v.push_back(nums1[i]);\\n              i++;\\n              \\n            }\\n        }\\n        if (i<m){\\n            v.push_back(nums1[i]);\\n            i++;\\n        }\\n        else if (j<n){\\n             v.push_back(nums2[j]);\\n            j++;\\n        }\\n        for (int k=0;k<m+n;k++){\\n          nums1[k]=v[k];\\n        }\\n    }\\nwhat is wrong with this code?\\nwhy it is not giving the desired output?\\n"
                    },
                    {
                        "username": "KrisChill",
                        "content": "m and n crying in the corner..."
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\n        int i = m;\\n        int j = 0;\\n\\n        while(i < nums1.size() ){\\n            nums1[i++] = nums2[j++];\\n        }\\n        sort(nums1.begin(), nums1.end() );\\n    }\\n};"
                    },
                    {
                        "username": "sandipuncc",
                        "content": "[@georgezakharov](/georgezakharov) Correct , my question was, why my code was not working ? I didn\\'t ask the answer"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2036996,
                "content": [
                    {
                        "username": "cdcdcd",
                        "content": "Do they want 0 or not? It\\'s so strange, since the sample remove the 0 in the output, but one of the testcases require 0 in the output. \\nnums1 =\\n[-1,0,0,3,3,3,0,0,0]\\nnums2 =\\n[1,2,2]\\n\\nMY Output\\n[-1,1,2,2,3,3,3]\\n\\nTHEY Expected\\n[-1,0,0,1,2,2,3,3,3]"
                    },
                    {
                        "username": "ersurajaky",
                        "content": "My output is correct but showing Wrong Answer."
                    },
                    {
                        "username": "Trish75",
                        "content": "I am Taking extra space and travesing from start, in Cout it is showing correct result but after submitting code its giving TLE, Pls help me to find what is issue here \\nhere is my code \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       \\n        vector<int>v(n+m);\\n        int nn=0,mm=0;\\n        for(int i=0 ;i<n+m ;i++ ){\\n            \\n            if(nn==n){\\n                v[i]=nums2[mm];\\n                mm++;\\n               \\n            }\\n            else if(mm==m){\\n               v[i]=nums1[nn];\\n                nn++;\\n                \\n            }\\n           else if(nums1[nn]<nums2[mm] && nn<n){v[i]=nums1[nn];nn++;}\\n\\n            else if(nums1[nn]>nums2[mm] && mm<m){v[i]=nums2[mm];mm++;}\\n            else if(nums1[nn]==nums2[mm]  && nn<n){v[i]=nums1[nn];nn++;}\\n            else if(nums1[nn]==nums2[mm]  && mm<m){v[i]=nums2[mm];mm++;}\\n            cout<< nn <<endl;\\n            cout<<mm<<endl;\\n        }\\n        for(int i=0;i<v.size();i++)cout<<v[i];\\n         for(int i=0;i<n+m;i++)nums1[i]=v[i];\\n    }\\n   \\n};"
                    },
                    {
                        "username": "Trish75",
                        "content": "Why This code giving RunTime Error  `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       \\n        vector<int>v(n+m);\\n        int nn=0,mm=0;\\n        for(int i=0 ;i<n+m ;i++ ){\\n            \\n            if(nn==n){\\n                v[i]=nums2[mm];\\n                mm++;\\n               \\n            }\\n            else if(mm==m){\\n               v[i]=nums1[nn];\\n                nn++;\\n                \\n            }\\n           else if(nums1[nn]<nums2[mm] && nn<n){v[i]=nums1[nn];nn++;}\\n\\n            else if(nums1[nn]>nums2[mm] && mm<m){v[i]=nums2[mm];mm++;}\\n            else if(nums1[nn]==nums2[mm]  && nn<n){v[i]=nums1[nn];nn++;}\\n            else if(nums1[nn]==nums2[mm]  && mm<m){v[i]=nums2[mm];mm++;}\\n            cout<< nn <<endl;\\n            cout<<mm<<endl;\\n        }\\n        for(int i=0;i<v.size();i++)cout<<v[i];\\n         for(int i=0;i<n+m;i++)nums1[i]=v[i];\\n    }\\n   \\n};"
                    },
                    {
                        "username": "dorshroitman0803",
                        "content": "anyone came with idea in place solve? in time complexity O(n+m)?"
                    },
                    {
                        "username": "Parag_Thakur",
                        "content": "After running it shows [1,2,2,3,5,6] in Stdout but [1,2,2,0,0,0] in Output and test case gets failed.\\nWhy this difference in Stdout and Output??????"
                    },
                    {
                        "username": "laser55",
                        "content": "   class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       int i=m-1;\\n       int j=n-1;\\n       int k=nums1.length-1;\\n       while(i>= 0 && j>=0){                         -->initializing i\\n           if(nums1[i]>nums2[j]){\\n               nums1[k]=nums1[i];\\n               k--;\\n               i--;\\n           }\\n           else{\\n               nums1[k]=nums2[j];\\n               k--;\\n               j--;\\n           }\\n\\n       }\\n\\n    }\\n}\\nwhen i try to initialize (I) in the while loop instead of if loop testcase 3 is failed anyone help me out why its not working and thank you in advance"
                    },
                    {
                        "username": "rahulsoni3108",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        vector<int>v;\\n        while (i<m && j<n){\\n            if (nums1[i]>=nums2[j]){\\n              v.push_back(nums2[j]);\\n              j++;\\n            }\\n             else if (nums1[i]<nums2[j]){\\n              v.push_back(nums1[i]);\\n              i++;\\n              \\n            }\\n        }\\n        if (i<m){\\n            v.push_back(nums1[i]);\\n            i++;\\n        }\\n        else if (j<n){\\n             v.push_back(nums2[j]);\\n            j++;\\n        }\\n        for (int k=0;k<m+n;k++){\\n          nums1[k]=v[k];\\n        }\\n    }\\nwhat is wrong with this code?\\nwhy it is not giving the desired output?\\n"
                    },
                    {
                        "username": "KrisChill",
                        "content": "m and n crying in the corner..."
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\n        int i = m;\\n        int j = 0;\\n\\n        while(i < nums1.size() ){\\n            nums1[i++] = nums2[j++];\\n        }\\n        sort(nums1.begin(), nums1.end() );\\n    }\\n};"
                    },
                    {
                        "username": "sandipuncc",
                        "content": "[@georgezakharov](/georgezakharov) Correct , my question was, why my code was not working ? I didn\\'t ask the answer"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2027996,
                "content": [
                    {
                        "username": "cdcdcd",
                        "content": "Do they want 0 or not? It\\'s so strange, since the sample remove the 0 in the output, but one of the testcases require 0 in the output. \\nnums1 =\\n[-1,0,0,3,3,3,0,0,0]\\nnums2 =\\n[1,2,2]\\n\\nMY Output\\n[-1,1,2,2,3,3,3]\\n\\nTHEY Expected\\n[-1,0,0,1,2,2,3,3,3]"
                    },
                    {
                        "username": "ersurajaky",
                        "content": "My output is correct but showing Wrong Answer."
                    },
                    {
                        "username": "Trish75",
                        "content": "I am Taking extra space and travesing from start, in Cout it is showing correct result but after submitting code its giving TLE, Pls help me to find what is issue here \\nhere is my code \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       \\n        vector<int>v(n+m);\\n        int nn=0,mm=0;\\n        for(int i=0 ;i<n+m ;i++ ){\\n            \\n            if(nn==n){\\n                v[i]=nums2[mm];\\n                mm++;\\n               \\n            }\\n            else if(mm==m){\\n               v[i]=nums1[nn];\\n                nn++;\\n                \\n            }\\n           else if(nums1[nn]<nums2[mm] && nn<n){v[i]=nums1[nn];nn++;}\\n\\n            else if(nums1[nn]>nums2[mm] && mm<m){v[i]=nums2[mm];mm++;}\\n            else if(nums1[nn]==nums2[mm]  && nn<n){v[i]=nums1[nn];nn++;}\\n            else if(nums1[nn]==nums2[mm]  && mm<m){v[i]=nums2[mm];mm++;}\\n            cout<< nn <<endl;\\n            cout<<mm<<endl;\\n        }\\n        for(int i=0;i<v.size();i++)cout<<v[i];\\n         for(int i=0;i<n+m;i++)nums1[i]=v[i];\\n    }\\n   \\n};"
                    },
                    {
                        "username": "Trish75",
                        "content": "Why This code giving RunTime Error  `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n       \\n        vector<int>v(n+m);\\n        int nn=0,mm=0;\\n        for(int i=0 ;i<n+m ;i++ ){\\n            \\n            if(nn==n){\\n                v[i]=nums2[mm];\\n                mm++;\\n               \\n            }\\n            else if(mm==m){\\n               v[i]=nums1[nn];\\n                nn++;\\n                \\n            }\\n           else if(nums1[nn]<nums2[mm] && nn<n){v[i]=nums1[nn];nn++;}\\n\\n            else if(nums1[nn]>nums2[mm] && mm<m){v[i]=nums2[mm];mm++;}\\n            else if(nums1[nn]==nums2[mm]  && nn<n){v[i]=nums1[nn];nn++;}\\n            else if(nums1[nn]==nums2[mm]  && mm<m){v[i]=nums2[mm];mm++;}\\n            cout<< nn <<endl;\\n            cout<<mm<<endl;\\n        }\\n        for(int i=0;i<v.size();i++)cout<<v[i];\\n         for(int i=0;i<n+m;i++)nums1[i]=v[i];\\n    }\\n   \\n};"
                    },
                    {
                        "username": "dorshroitman0803",
                        "content": "anyone came with idea in place solve? in time complexity O(n+m)?"
                    },
                    {
                        "username": "Parag_Thakur",
                        "content": "After running it shows [1,2,2,3,5,6] in Stdout but [1,2,2,0,0,0] in Output and test case gets failed.\\nWhy this difference in Stdout and Output??????"
                    },
                    {
                        "username": "laser55",
                        "content": "   class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       int i=m-1;\\n       int j=n-1;\\n       int k=nums1.length-1;\\n       while(i>= 0 && j>=0){                         -->initializing i\\n           if(nums1[i]>nums2[j]){\\n               nums1[k]=nums1[i];\\n               k--;\\n               i--;\\n           }\\n           else{\\n               nums1[k]=nums2[j];\\n               k--;\\n               j--;\\n           }\\n\\n       }\\n\\n    }\\n}\\nwhen i try to initialize (I) in the while loop instead of if loop testcase 3 is failed anyone help me out why its not working and thank you in advance"
                    },
                    {
                        "username": "rahulsoni3108",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        vector<int>v;\\n        while (i<m && j<n){\\n            if (nums1[i]>=nums2[j]){\\n              v.push_back(nums2[j]);\\n              j++;\\n            }\\n             else if (nums1[i]<nums2[j]){\\n              v.push_back(nums1[i]);\\n              i++;\\n              \\n            }\\n        }\\n        if (i<m){\\n            v.push_back(nums1[i]);\\n            i++;\\n        }\\n        else if (j<n){\\n             v.push_back(nums2[j]);\\n            j++;\\n        }\\n        for (int k=0;k<m+n;k++){\\n          nums1[k]=v[k];\\n        }\\n    }\\nwhat is wrong with this code?\\nwhy it is not giving the desired output?\\n"
                    },
                    {
                        "username": "KrisChill",
                        "content": "m and n crying in the corner..."
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\n        int i = m;\\n        int j = 0;\\n\\n        while(i < nums1.size() ){\\n            nums1[i++] = nums2[j++];\\n        }\\n        sort(nums1.begin(), nums1.end() );\\n    }\\n};"
                    },
                    {
                        "username": "sandipuncc",
                        "content": "[@georgezakharov](/georgezakharov) Correct , my question was, why my code was not working ? I didn\\'t ask the answer"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2026558,
                "content": [
                    {
                        "username": "sandipuncc",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n\\n        \\n        for i in nums2:\\n            nums1.append(i)\\n\\n        nums1.sort()\\n        \\n        for j in nums1:\\n            if (j==0):\\n                nums1.remove(j)\\n\\n        return nums1\\n\\nThe first test case is not working"
                    },
                    {
                        "username": "SurajS23",
                        "content": "sort(nums1, nums1 + n);\\nwhy can\\'t I use sort function? It shows error: invalid operands to binary expression"
                    },
                    {
                        "username": "Nike-rgb",
                        "content": "I don\\'t know why this wouldn\\'t work:\\n\\n//javascript\\n/**\\n * @param {number[]} nums1\\n * @param {number} m\\n * @param {number[]} nums2\\n * @param {number} n\\n * @return {void} Do not return anything, modify nums1 in-place instead.\\n */\\nvar merge = function(nums1, m, nums2, n) {\\n    for(let i = m, k = 0; i < m+n; i++, k++) {\\n        nums1[i] = nums2[k]\\n    }\\n    nums1.sort();\\n};"
                    },
                    {
                        "username": "Supernova10",
                        "content": "in Example 1: nums1 = [1,2,3,0,0,0], m = 3. I don\\'t get it at the first place. why number of elements in nums1, m = 3?"
                    },
                    {
                        "username": "prarthitshah899",
                        "content": "Why below code of mine is not working? Anyone help?\n\n\n `nums1 = nums1 + nums2;\nnums1 = [i for i in nums1 if i != 0];\nnums1.sort();`"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t work because you\\'re appending nums2 to nums1, then removing zeros, which may remove valid zeros from the original lists, and then sorting; this doesn\\'t guarantee the correct merge of the two lists in the required manner."
                    },
                    {
                        "username": "MishRRa",
                        "content": "var merge = function (nums1, m, nums2, n) {\\n    nums1=nums1.slice(0,m)\\n   for(let i=0;i<n;i++){\\n       nums1.push(nums2[i])\\n   }\\n   nums1.map((value,index)=>{\\n   for(let i=0;i<nums1.length;i++ ){\\n       if(nums1[index]<nums1[i]&&index!==i){\\n           let j=nums1[index]\\n           nums1[index]=nums1[i]\\n           nums1[i]=j}}})\\n   return nums1\\n};\\nconsole.log(merge([1,2,3,0,0,0],3,[2,5,6],3))\\n\\nI have the above solution which is giving correct output in other compilers but on leatcode the test case is failing don\\'t know why"
                    },
                    {
                        "username": "ReadyRainFor",
                        "content": "why are we accommodating for the list length? it seems unlikely if we need to merge two lists like this, the first one would be perfectly ready to accept the second lists values by holding empty values, or zeroes, to replace"
                    },
                    {
                        "username": "rishabhjainfinal",
                        "content": "*i am trying some here*\\n `class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        if m:\\n            leIndex = 0\\n            for index, ar2e in enumerate(nums2):\\n                # print(\"range\", (leIndex, m+index))\\n                for i in range(leIndex, m+index):\\n                    # print(nums1[i],nums1[i] > ar2e, ar2e)\\n                    if nums1[i] > ar2e:\\n                        nums1.insert(i, ar2e)\\n                        nums1.pop()\\n                        leIndex = i+1\\n                        # print(nums1, ar2e, leIndex)\\n                        break\\n                else:\\n                    leIndex += 1\\n                    nums1[leIndex] = (ar2e)\\n        else:\\n            nums1= nums2\\n\\n        print(m,n,nums1,nums2)\\n`\\n\\nmy code is write but idk why it is giving me error "
                    },
                    {
                        "username": "sana479",
                        "content": "a good solution that won\\'t work on leetcode for some reason :) \\n\\n\\n`for x in nums2:\\n        nums1.append(x)\\n    y =list(filter(lambda x: x != 0,nums1))\\n    y.sort()\\n    print(y)\\n`\\n\\n"
                    },
                    {
                        "username": "voynow",
                        "content": "Is this a bug in the test?? Work in progress implementation:\\n\\n            class Solution(object):\\n                def merge(self, nums1, m, nums2, n):\\n                    p = 0\\n                    for i in range(len(nums1)):\\n                        print(i, p)\\n\\n                        if i >= m + p:\\n                            nums1[i] = nums2[p]\\n                            p += 1\\n\\n                        elif nums1[i] > nums2[p]:\\n                            temp = nums1[i:-1]\\n                            nums1[i] = nums2[p]\\n                            nums1[i+1:] = temp\\n                            p += 1\\n\\n\\nAnd here is the stdout:\\n(0, 0)\\n(1, 0)\\n(2, 0)\\n(3, 1)\\n(4, 1)\\n(5, 2)\\n(0, 0)\\n\\nWhith the following error:\\nIndexError: list index out of range\\n    elif nums1[i] > nums2[p]:\\nLine 19 in merge (Solution.py)\\n    ret = Solution().merge(param_1, param_2, param_3, param_4)\\nLine 58 in _driver (Solution.py)\\n    _driver()\\nLine 69 in <module> (Solution.py)\\nHow does this make sense? Where in my code are i and p being set to 0, 0?? This is weird... "
                    }
                ]
            },
            {
                "id": 2025956,
                "content": [
                    {
                        "username": "sandipuncc",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n\\n        \\n        for i in nums2:\\n            nums1.append(i)\\n\\n        nums1.sort()\\n        \\n        for j in nums1:\\n            if (j==0):\\n                nums1.remove(j)\\n\\n        return nums1\\n\\nThe first test case is not working"
                    },
                    {
                        "username": "SurajS23",
                        "content": "sort(nums1, nums1 + n);\\nwhy can\\'t I use sort function? It shows error: invalid operands to binary expression"
                    },
                    {
                        "username": "Nike-rgb",
                        "content": "I don\\'t know why this wouldn\\'t work:\\n\\n//javascript\\n/**\\n * @param {number[]} nums1\\n * @param {number} m\\n * @param {number[]} nums2\\n * @param {number} n\\n * @return {void} Do not return anything, modify nums1 in-place instead.\\n */\\nvar merge = function(nums1, m, nums2, n) {\\n    for(let i = m, k = 0; i < m+n; i++, k++) {\\n        nums1[i] = nums2[k]\\n    }\\n    nums1.sort();\\n};"
                    },
                    {
                        "username": "Supernova10",
                        "content": "in Example 1: nums1 = [1,2,3,0,0,0], m = 3. I don\\'t get it at the first place. why number of elements in nums1, m = 3?"
                    },
                    {
                        "username": "prarthitshah899",
                        "content": "Why below code of mine is not working? Anyone help?\n\n\n `nums1 = nums1 + nums2;\nnums1 = [i for i in nums1 if i != 0];\nnums1.sort();`"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t work because you\\'re appending nums2 to nums1, then removing zeros, which may remove valid zeros from the original lists, and then sorting; this doesn\\'t guarantee the correct merge of the two lists in the required manner."
                    },
                    {
                        "username": "MishRRa",
                        "content": "var merge = function (nums1, m, nums2, n) {\\n    nums1=nums1.slice(0,m)\\n   for(let i=0;i<n;i++){\\n       nums1.push(nums2[i])\\n   }\\n   nums1.map((value,index)=>{\\n   for(let i=0;i<nums1.length;i++ ){\\n       if(nums1[index]<nums1[i]&&index!==i){\\n           let j=nums1[index]\\n           nums1[index]=nums1[i]\\n           nums1[i]=j}}})\\n   return nums1\\n};\\nconsole.log(merge([1,2,3,0,0,0],3,[2,5,6],3))\\n\\nI have the above solution which is giving correct output in other compilers but on leatcode the test case is failing don\\'t know why"
                    },
                    {
                        "username": "ReadyRainFor",
                        "content": "why are we accommodating for the list length? it seems unlikely if we need to merge two lists like this, the first one would be perfectly ready to accept the second lists values by holding empty values, or zeroes, to replace"
                    },
                    {
                        "username": "rishabhjainfinal",
                        "content": "*i am trying some here*\\n `class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        if m:\\n            leIndex = 0\\n            for index, ar2e in enumerate(nums2):\\n                # print(\"range\", (leIndex, m+index))\\n                for i in range(leIndex, m+index):\\n                    # print(nums1[i],nums1[i] > ar2e, ar2e)\\n                    if nums1[i] > ar2e:\\n                        nums1.insert(i, ar2e)\\n                        nums1.pop()\\n                        leIndex = i+1\\n                        # print(nums1, ar2e, leIndex)\\n                        break\\n                else:\\n                    leIndex += 1\\n                    nums1[leIndex] = (ar2e)\\n        else:\\n            nums1= nums2\\n\\n        print(m,n,nums1,nums2)\\n`\\n\\nmy code is write but idk why it is giving me error "
                    },
                    {
                        "username": "sana479",
                        "content": "a good solution that won\\'t work on leetcode for some reason :) \\n\\n\\n`for x in nums2:\\n        nums1.append(x)\\n    y =list(filter(lambda x: x != 0,nums1))\\n    y.sort()\\n    print(y)\\n`\\n\\n"
                    },
                    {
                        "username": "voynow",
                        "content": "Is this a bug in the test?? Work in progress implementation:\\n\\n            class Solution(object):\\n                def merge(self, nums1, m, nums2, n):\\n                    p = 0\\n                    for i in range(len(nums1)):\\n                        print(i, p)\\n\\n                        if i >= m + p:\\n                            nums1[i] = nums2[p]\\n                            p += 1\\n\\n                        elif nums1[i] > nums2[p]:\\n                            temp = nums1[i:-1]\\n                            nums1[i] = nums2[p]\\n                            nums1[i+1:] = temp\\n                            p += 1\\n\\n\\nAnd here is the stdout:\\n(0, 0)\\n(1, 0)\\n(2, 0)\\n(3, 1)\\n(4, 1)\\n(5, 2)\\n(0, 0)\\n\\nWhith the following error:\\nIndexError: list index out of range\\n    elif nums1[i] > nums2[p]:\\nLine 19 in merge (Solution.py)\\n    ret = Solution().merge(param_1, param_2, param_3, param_4)\\nLine 58 in _driver (Solution.py)\\n    _driver()\\nLine 69 in <module> (Solution.py)\\nHow does this make sense? Where in my code are i and p being set to 0, 0?? This is weird... "
                    }
                ]
            },
            {
                "id": 2024914,
                "content": [
                    {
                        "username": "sandipuncc",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n\\n        \\n        for i in nums2:\\n            nums1.append(i)\\n\\n        nums1.sort()\\n        \\n        for j in nums1:\\n            if (j==0):\\n                nums1.remove(j)\\n\\n        return nums1\\n\\nThe first test case is not working"
                    },
                    {
                        "username": "SurajS23",
                        "content": "sort(nums1, nums1 + n);\\nwhy can\\'t I use sort function? It shows error: invalid operands to binary expression"
                    },
                    {
                        "username": "Nike-rgb",
                        "content": "I don\\'t know why this wouldn\\'t work:\\n\\n//javascript\\n/**\\n * @param {number[]} nums1\\n * @param {number} m\\n * @param {number[]} nums2\\n * @param {number} n\\n * @return {void} Do not return anything, modify nums1 in-place instead.\\n */\\nvar merge = function(nums1, m, nums2, n) {\\n    for(let i = m, k = 0; i < m+n; i++, k++) {\\n        nums1[i] = nums2[k]\\n    }\\n    nums1.sort();\\n};"
                    },
                    {
                        "username": "Supernova10",
                        "content": "in Example 1: nums1 = [1,2,3,0,0,0], m = 3. I don\\'t get it at the first place. why number of elements in nums1, m = 3?"
                    },
                    {
                        "username": "prarthitshah899",
                        "content": "Why below code of mine is not working? Anyone help?\n\n\n `nums1 = nums1 + nums2;\nnums1 = [i for i in nums1 if i != 0];\nnums1.sort();`"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t work because you\\'re appending nums2 to nums1, then removing zeros, which may remove valid zeros from the original lists, and then sorting; this doesn\\'t guarantee the correct merge of the two lists in the required manner."
                    },
                    {
                        "username": "MishRRa",
                        "content": "var merge = function (nums1, m, nums2, n) {\\n    nums1=nums1.slice(0,m)\\n   for(let i=0;i<n;i++){\\n       nums1.push(nums2[i])\\n   }\\n   nums1.map((value,index)=>{\\n   for(let i=0;i<nums1.length;i++ ){\\n       if(nums1[index]<nums1[i]&&index!==i){\\n           let j=nums1[index]\\n           nums1[index]=nums1[i]\\n           nums1[i]=j}}})\\n   return nums1\\n};\\nconsole.log(merge([1,2,3,0,0,0],3,[2,5,6],3))\\n\\nI have the above solution which is giving correct output in other compilers but on leatcode the test case is failing don\\'t know why"
                    },
                    {
                        "username": "ReadyRainFor",
                        "content": "why are we accommodating for the list length? it seems unlikely if we need to merge two lists like this, the first one would be perfectly ready to accept the second lists values by holding empty values, or zeroes, to replace"
                    },
                    {
                        "username": "rishabhjainfinal",
                        "content": "*i am trying some here*\\n `class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        if m:\\n            leIndex = 0\\n            for index, ar2e in enumerate(nums2):\\n                # print(\"range\", (leIndex, m+index))\\n                for i in range(leIndex, m+index):\\n                    # print(nums1[i],nums1[i] > ar2e, ar2e)\\n                    if nums1[i] > ar2e:\\n                        nums1.insert(i, ar2e)\\n                        nums1.pop()\\n                        leIndex = i+1\\n                        # print(nums1, ar2e, leIndex)\\n                        break\\n                else:\\n                    leIndex += 1\\n                    nums1[leIndex] = (ar2e)\\n        else:\\n            nums1= nums2\\n\\n        print(m,n,nums1,nums2)\\n`\\n\\nmy code is write but idk why it is giving me error "
                    },
                    {
                        "username": "sana479",
                        "content": "a good solution that won\\'t work on leetcode for some reason :) \\n\\n\\n`for x in nums2:\\n        nums1.append(x)\\n    y =list(filter(lambda x: x != 0,nums1))\\n    y.sort()\\n    print(y)\\n`\\n\\n"
                    },
                    {
                        "username": "voynow",
                        "content": "Is this a bug in the test?? Work in progress implementation:\\n\\n            class Solution(object):\\n                def merge(self, nums1, m, nums2, n):\\n                    p = 0\\n                    for i in range(len(nums1)):\\n                        print(i, p)\\n\\n                        if i >= m + p:\\n                            nums1[i] = nums2[p]\\n                            p += 1\\n\\n                        elif nums1[i] > nums2[p]:\\n                            temp = nums1[i:-1]\\n                            nums1[i] = nums2[p]\\n                            nums1[i+1:] = temp\\n                            p += 1\\n\\n\\nAnd here is the stdout:\\n(0, 0)\\n(1, 0)\\n(2, 0)\\n(3, 1)\\n(4, 1)\\n(5, 2)\\n(0, 0)\\n\\nWhith the following error:\\nIndexError: list index out of range\\n    elif nums1[i] > nums2[p]:\\nLine 19 in merge (Solution.py)\\n    ret = Solution().merge(param_1, param_2, param_3, param_4)\\nLine 58 in _driver (Solution.py)\\n    _driver()\\nLine 69 in <module> (Solution.py)\\nHow does this make sense? Where in my code are i and p being set to 0, 0?? This is weird... "
                    }
                ]
            },
            {
                "id": 2023504,
                "content": [
                    {
                        "username": "sandipuncc",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n\\n        \\n        for i in nums2:\\n            nums1.append(i)\\n\\n        nums1.sort()\\n        \\n        for j in nums1:\\n            if (j==0):\\n                nums1.remove(j)\\n\\n        return nums1\\n\\nThe first test case is not working"
                    },
                    {
                        "username": "SurajS23",
                        "content": "sort(nums1, nums1 + n);\\nwhy can\\'t I use sort function? It shows error: invalid operands to binary expression"
                    },
                    {
                        "username": "Nike-rgb",
                        "content": "I don\\'t know why this wouldn\\'t work:\\n\\n//javascript\\n/**\\n * @param {number[]} nums1\\n * @param {number} m\\n * @param {number[]} nums2\\n * @param {number} n\\n * @return {void} Do not return anything, modify nums1 in-place instead.\\n */\\nvar merge = function(nums1, m, nums2, n) {\\n    for(let i = m, k = 0; i < m+n; i++, k++) {\\n        nums1[i] = nums2[k]\\n    }\\n    nums1.sort();\\n};"
                    },
                    {
                        "username": "Supernova10",
                        "content": "in Example 1: nums1 = [1,2,3,0,0,0], m = 3. I don\\'t get it at the first place. why number of elements in nums1, m = 3?"
                    },
                    {
                        "username": "prarthitshah899",
                        "content": "Why below code of mine is not working? Anyone help?\n\n\n `nums1 = nums1 + nums2;\nnums1 = [i for i in nums1 if i != 0];\nnums1.sort();`"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t work because you\\'re appending nums2 to nums1, then removing zeros, which may remove valid zeros from the original lists, and then sorting; this doesn\\'t guarantee the correct merge of the two lists in the required manner."
                    },
                    {
                        "username": "MishRRa",
                        "content": "var merge = function (nums1, m, nums2, n) {\\n    nums1=nums1.slice(0,m)\\n   for(let i=0;i<n;i++){\\n       nums1.push(nums2[i])\\n   }\\n   nums1.map((value,index)=>{\\n   for(let i=0;i<nums1.length;i++ ){\\n       if(nums1[index]<nums1[i]&&index!==i){\\n           let j=nums1[index]\\n           nums1[index]=nums1[i]\\n           nums1[i]=j}}})\\n   return nums1\\n};\\nconsole.log(merge([1,2,3,0,0,0],3,[2,5,6],3))\\n\\nI have the above solution which is giving correct output in other compilers but on leatcode the test case is failing don\\'t know why"
                    },
                    {
                        "username": "ReadyRainFor",
                        "content": "why are we accommodating for the list length? it seems unlikely if we need to merge two lists like this, the first one would be perfectly ready to accept the second lists values by holding empty values, or zeroes, to replace"
                    },
                    {
                        "username": "rishabhjainfinal",
                        "content": "*i am trying some here*\\n `class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        if m:\\n            leIndex = 0\\n            for index, ar2e in enumerate(nums2):\\n                # print(\"range\", (leIndex, m+index))\\n                for i in range(leIndex, m+index):\\n                    # print(nums1[i],nums1[i] > ar2e, ar2e)\\n                    if nums1[i] > ar2e:\\n                        nums1.insert(i, ar2e)\\n                        nums1.pop()\\n                        leIndex = i+1\\n                        # print(nums1, ar2e, leIndex)\\n                        break\\n                else:\\n                    leIndex += 1\\n                    nums1[leIndex] = (ar2e)\\n        else:\\n            nums1= nums2\\n\\n        print(m,n,nums1,nums2)\\n`\\n\\nmy code is write but idk why it is giving me error "
                    },
                    {
                        "username": "sana479",
                        "content": "a good solution that won\\'t work on leetcode for some reason :) \\n\\n\\n`for x in nums2:\\n        nums1.append(x)\\n    y =list(filter(lambda x: x != 0,nums1))\\n    y.sort()\\n    print(y)\\n`\\n\\n"
                    },
                    {
                        "username": "voynow",
                        "content": "Is this a bug in the test?? Work in progress implementation:\\n\\n            class Solution(object):\\n                def merge(self, nums1, m, nums2, n):\\n                    p = 0\\n                    for i in range(len(nums1)):\\n                        print(i, p)\\n\\n                        if i >= m + p:\\n                            nums1[i] = nums2[p]\\n                            p += 1\\n\\n                        elif nums1[i] > nums2[p]:\\n                            temp = nums1[i:-1]\\n                            nums1[i] = nums2[p]\\n                            nums1[i+1:] = temp\\n                            p += 1\\n\\n\\nAnd here is the stdout:\\n(0, 0)\\n(1, 0)\\n(2, 0)\\n(3, 1)\\n(4, 1)\\n(5, 2)\\n(0, 0)\\n\\nWhith the following error:\\nIndexError: list index out of range\\n    elif nums1[i] > nums2[p]:\\nLine 19 in merge (Solution.py)\\n    ret = Solution().merge(param_1, param_2, param_3, param_4)\\nLine 58 in _driver (Solution.py)\\n    _driver()\\nLine 69 in <module> (Solution.py)\\nHow does this make sense? Where in my code are i and p being set to 0, 0?? This is weird... "
                    }
                ]
            },
            {
                "id": 2022746,
                "content": [
                    {
                        "username": "sandipuncc",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n\\n        \\n        for i in nums2:\\n            nums1.append(i)\\n\\n        nums1.sort()\\n        \\n        for j in nums1:\\n            if (j==0):\\n                nums1.remove(j)\\n\\n        return nums1\\n\\nThe first test case is not working"
                    },
                    {
                        "username": "SurajS23",
                        "content": "sort(nums1, nums1 + n);\\nwhy can\\'t I use sort function? It shows error: invalid operands to binary expression"
                    },
                    {
                        "username": "Nike-rgb",
                        "content": "I don\\'t know why this wouldn\\'t work:\\n\\n//javascript\\n/**\\n * @param {number[]} nums1\\n * @param {number} m\\n * @param {number[]} nums2\\n * @param {number} n\\n * @return {void} Do not return anything, modify nums1 in-place instead.\\n */\\nvar merge = function(nums1, m, nums2, n) {\\n    for(let i = m, k = 0; i < m+n; i++, k++) {\\n        nums1[i] = nums2[k]\\n    }\\n    nums1.sort();\\n};"
                    },
                    {
                        "username": "Supernova10",
                        "content": "in Example 1: nums1 = [1,2,3,0,0,0], m = 3. I don\\'t get it at the first place. why number of elements in nums1, m = 3?"
                    },
                    {
                        "username": "prarthitshah899",
                        "content": "Why below code of mine is not working? Anyone help?\n\n\n `nums1 = nums1 + nums2;\nnums1 = [i for i in nums1 if i != 0];\nnums1.sort();`"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t work because you\\'re appending nums2 to nums1, then removing zeros, which may remove valid zeros from the original lists, and then sorting; this doesn\\'t guarantee the correct merge of the two lists in the required manner."
                    },
                    {
                        "username": "MishRRa",
                        "content": "var merge = function (nums1, m, nums2, n) {\\n    nums1=nums1.slice(0,m)\\n   for(let i=0;i<n;i++){\\n       nums1.push(nums2[i])\\n   }\\n   nums1.map((value,index)=>{\\n   for(let i=0;i<nums1.length;i++ ){\\n       if(nums1[index]<nums1[i]&&index!==i){\\n           let j=nums1[index]\\n           nums1[index]=nums1[i]\\n           nums1[i]=j}}})\\n   return nums1\\n};\\nconsole.log(merge([1,2,3,0,0,0],3,[2,5,6],3))\\n\\nI have the above solution which is giving correct output in other compilers but on leatcode the test case is failing don\\'t know why"
                    },
                    {
                        "username": "ReadyRainFor",
                        "content": "why are we accommodating for the list length? it seems unlikely if we need to merge two lists like this, the first one would be perfectly ready to accept the second lists values by holding empty values, or zeroes, to replace"
                    },
                    {
                        "username": "rishabhjainfinal",
                        "content": "*i am trying some here*\\n `class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        if m:\\n            leIndex = 0\\n            for index, ar2e in enumerate(nums2):\\n                # print(\"range\", (leIndex, m+index))\\n                for i in range(leIndex, m+index):\\n                    # print(nums1[i],nums1[i] > ar2e, ar2e)\\n                    if nums1[i] > ar2e:\\n                        nums1.insert(i, ar2e)\\n                        nums1.pop()\\n                        leIndex = i+1\\n                        # print(nums1, ar2e, leIndex)\\n                        break\\n                else:\\n                    leIndex += 1\\n                    nums1[leIndex] = (ar2e)\\n        else:\\n            nums1= nums2\\n\\n        print(m,n,nums1,nums2)\\n`\\n\\nmy code is write but idk why it is giving me error "
                    },
                    {
                        "username": "sana479",
                        "content": "a good solution that won\\'t work on leetcode for some reason :) \\n\\n\\n`for x in nums2:\\n        nums1.append(x)\\n    y =list(filter(lambda x: x != 0,nums1))\\n    y.sort()\\n    print(y)\\n`\\n\\n"
                    },
                    {
                        "username": "voynow",
                        "content": "Is this a bug in the test?? Work in progress implementation:\\n\\n            class Solution(object):\\n                def merge(self, nums1, m, nums2, n):\\n                    p = 0\\n                    for i in range(len(nums1)):\\n                        print(i, p)\\n\\n                        if i >= m + p:\\n                            nums1[i] = nums2[p]\\n                            p += 1\\n\\n                        elif nums1[i] > nums2[p]:\\n                            temp = nums1[i:-1]\\n                            nums1[i] = nums2[p]\\n                            nums1[i+1:] = temp\\n                            p += 1\\n\\n\\nAnd here is the stdout:\\n(0, 0)\\n(1, 0)\\n(2, 0)\\n(3, 1)\\n(4, 1)\\n(5, 2)\\n(0, 0)\\n\\nWhith the following error:\\nIndexError: list index out of range\\n    elif nums1[i] > nums2[p]:\\nLine 19 in merge (Solution.py)\\n    ret = Solution().merge(param_1, param_2, param_3, param_4)\\nLine 58 in _driver (Solution.py)\\n    _driver()\\nLine 69 in <module> (Solution.py)\\nHow does this make sense? Where in my code are i and p being set to 0, 0?? This is weird... "
                    }
                ]
            },
            {
                "id": 2019673,
                "content": [
                    {
                        "username": "sandipuncc",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n\\n        \\n        for i in nums2:\\n            nums1.append(i)\\n\\n        nums1.sort()\\n        \\n        for j in nums1:\\n            if (j==0):\\n                nums1.remove(j)\\n\\n        return nums1\\n\\nThe first test case is not working"
                    },
                    {
                        "username": "SurajS23",
                        "content": "sort(nums1, nums1 + n);\\nwhy can\\'t I use sort function? It shows error: invalid operands to binary expression"
                    },
                    {
                        "username": "Nike-rgb",
                        "content": "I don\\'t know why this wouldn\\'t work:\\n\\n//javascript\\n/**\\n * @param {number[]} nums1\\n * @param {number} m\\n * @param {number[]} nums2\\n * @param {number} n\\n * @return {void} Do not return anything, modify nums1 in-place instead.\\n */\\nvar merge = function(nums1, m, nums2, n) {\\n    for(let i = m, k = 0; i < m+n; i++, k++) {\\n        nums1[i] = nums2[k]\\n    }\\n    nums1.sort();\\n};"
                    },
                    {
                        "username": "Supernova10",
                        "content": "in Example 1: nums1 = [1,2,3,0,0,0], m = 3. I don\\'t get it at the first place. why number of elements in nums1, m = 3?"
                    },
                    {
                        "username": "prarthitshah899",
                        "content": "Why below code of mine is not working? Anyone help?\n\n\n `nums1 = nums1 + nums2;\nnums1 = [i for i in nums1 if i != 0];\nnums1.sort();`"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t work because you\\'re appending nums2 to nums1, then removing zeros, which may remove valid zeros from the original lists, and then sorting; this doesn\\'t guarantee the correct merge of the two lists in the required manner."
                    },
                    {
                        "username": "MishRRa",
                        "content": "var merge = function (nums1, m, nums2, n) {\\n    nums1=nums1.slice(0,m)\\n   for(let i=0;i<n;i++){\\n       nums1.push(nums2[i])\\n   }\\n   nums1.map((value,index)=>{\\n   for(let i=0;i<nums1.length;i++ ){\\n       if(nums1[index]<nums1[i]&&index!==i){\\n           let j=nums1[index]\\n           nums1[index]=nums1[i]\\n           nums1[i]=j}}})\\n   return nums1\\n};\\nconsole.log(merge([1,2,3,0,0,0],3,[2,5,6],3))\\n\\nI have the above solution which is giving correct output in other compilers but on leatcode the test case is failing don\\'t know why"
                    },
                    {
                        "username": "ReadyRainFor",
                        "content": "why are we accommodating for the list length? it seems unlikely if we need to merge two lists like this, the first one would be perfectly ready to accept the second lists values by holding empty values, or zeroes, to replace"
                    },
                    {
                        "username": "rishabhjainfinal",
                        "content": "*i am trying some here*\\n `class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        if m:\\n            leIndex = 0\\n            for index, ar2e in enumerate(nums2):\\n                # print(\"range\", (leIndex, m+index))\\n                for i in range(leIndex, m+index):\\n                    # print(nums1[i],nums1[i] > ar2e, ar2e)\\n                    if nums1[i] > ar2e:\\n                        nums1.insert(i, ar2e)\\n                        nums1.pop()\\n                        leIndex = i+1\\n                        # print(nums1, ar2e, leIndex)\\n                        break\\n                else:\\n                    leIndex += 1\\n                    nums1[leIndex] = (ar2e)\\n        else:\\n            nums1= nums2\\n\\n        print(m,n,nums1,nums2)\\n`\\n\\nmy code is write but idk why it is giving me error "
                    },
                    {
                        "username": "sana479",
                        "content": "a good solution that won\\'t work on leetcode for some reason :) \\n\\n\\n`for x in nums2:\\n        nums1.append(x)\\n    y =list(filter(lambda x: x != 0,nums1))\\n    y.sort()\\n    print(y)\\n`\\n\\n"
                    },
                    {
                        "username": "voynow",
                        "content": "Is this a bug in the test?? Work in progress implementation:\\n\\n            class Solution(object):\\n                def merge(self, nums1, m, nums2, n):\\n                    p = 0\\n                    for i in range(len(nums1)):\\n                        print(i, p)\\n\\n                        if i >= m + p:\\n                            nums1[i] = nums2[p]\\n                            p += 1\\n\\n                        elif nums1[i] > nums2[p]:\\n                            temp = nums1[i:-1]\\n                            nums1[i] = nums2[p]\\n                            nums1[i+1:] = temp\\n                            p += 1\\n\\n\\nAnd here is the stdout:\\n(0, 0)\\n(1, 0)\\n(2, 0)\\n(3, 1)\\n(4, 1)\\n(5, 2)\\n(0, 0)\\n\\nWhith the following error:\\nIndexError: list index out of range\\n    elif nums1[i] > nums2[p]:\\nLine 19 in merge (Solution.py)\\n    ret = Solution().merge(param_1, param_2, param_3, param_4)\\nLine 58 in _driver (Solution.py)\\n    _driver()\\nLine 69 in <module> (Solution.py)\\nHow does this make sense? Where in my code are i and p being set to 0, 0?? This is weird... "
                    }
                ]
            },
            {
                "id": 2018592,
                "content": [
                    {
                        "username": "sandipuncc",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n\\n        \\n        for i in nums2:\\n            nums1.append(i)\\n\\n        nums1.sort()\\n        \\n        for j in nums1:\\n            if (j==0):\\n                nums1.remove(j)\\n\\n        return nums1\\n\\nThe first test case is not working"
                    },
                    {
                        "username": "SurajS23",
                        "content": "sort(nums1, nums1 + n);\\nwhy can\\'t I use sort function? It shows error: invalid operands to binary expression"
                    },
                    {
                        "username": "Nike-rgb",
                        "content": "I don\\'t know why this wouldn\\'t work:\\n\\n//javascript\\n/**\\n * @param {number[]} nums1\\n * @param {number} m\\n * @param {number[]} nums2\\n * @param {number} n\\n * @return {void} Do not return anything, modify nums1 in-place instead.\\n */\\nvar merge = function(nums1, m, nums2, n) {\\n    for(let i = m, k = 0; i < m+n; i++, k++) {\\n        nums1[i] = nums2[k]\\n    }\\n    nums1.sort();\\n};"
                    },
                    {
                        "username": "Supernova10",
                        "content": "in Example 1: nums1 = [1,2,3,0,0,0], m = 3. I don\\'t get it at the first place. why number of elements in nums1, m = 3?"
                    },
                    {
                        "username": "prarthitshah899",
                        "content": "Why below code of mine is not working? Anyone help?\n\n\n `nums1 = nums1 + nums2;\nnums1 = [i for i in nums1 if i != 0];\nnums1.sort();`"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t work because you\\'re appending nums2 to nums1, then removing zeros, which may remove valid zeros from the original lists, and then sorting; this doesn\\'t guarantee the correct merge of the two lists in the required manner."
                    },
                    {
                        "username": "MishRRa",
                        "content": "var merge = function (nums1, m, nums2, n) {\\n    nums1=nums1.slice(0,m)\\n   for(let i=0;i<n;i++){\\n       nums1.push(nums2[i])\\n   }\\n   nums1.map((value,index)=>{\\n   for(let i=0;i<nums1.length;i++ ){\\n       if(nums1[index]<nums1[i]&&index!==i){\\n           let j=nums1[index]\\n           nums1[index]=nums1[i]\\n           nums1[i]=j}}})\\n   return nums1\\n};\\nconsole.log(merge([1,2,3,0,0,0],3,[2,5,6],3))\\n\\nI have the above solution which is giving correct output in other compilers but on leatcode the test case is failing don\\'t know why"
                    },
                    {
                        "username": "ReadyRainFor",
                        "content": "why are we accommodating for the list length? it seems unlikely if we need to merge two lists like this, the first one would be perfectly ready to accept the second lists values by holding empty values, or zeroes, to replace"
                    },
                    {
                        "username": "rishabhjainfinal",
                        "content": "*i am trying some here*\\n `class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        if m:\\n            leIndex = 0\\n            for index, ar2e in enumerate(nums2):\\n                # print(\"range\", (leIndex, m+index))\\n                for i in range(leIndex, m+index):\\n                    # print(nums1[i],nums1[i] > ar2e, ar2e)\\n                    if nums1[i] > ar2e:\\n                        nums1.insert(i, ar2e)\\n                        nums1.pop()\\n                        leIndex = i+1\\n                        # print(nums1, ar2e, leIndex)\\n                        break\\n                else:\\n                    leIndex += 1\\n                    nums1[leIndex] = (ar2e)\\n        else:\\n            nums1= nums2\\n\\n        print(m,n,nums1,nums2)\\n`\\n\\nmy code is write but idk why it is giving me error "
                    },
                    {
                        "username": "sana479",
                        "content": "a good solution that won\\'t work on leetcode for some reason :) \\n\\n\\n`for x in nums2:\\n        nums1.append(x)\\n    y =list(filter(lambda x: x != 0,nums1))\\n    y.sort()\\n    print(y)\\n`\\n\\n"
                    },
                    {
                        "username": "voynow",
                        "content": "Is this a bug in the test?? Work in progress implementation:\\n\\n            class Solution(object):\\n                def merge(self, nums1, m, nums2, n):\\n                    p = 0\\n                    for i in range(len(nums1)):\\n                        print(i, p)\\n\\n                        if i >= m + p:\\n                            nums1[i] = nums2[p]\\n                            p += 1\\n\\n                        elif nums1[i] > nums2[p]:\\n                            temp = nums1[i:-1]\\n                            nums1[i] = nums2[p]\\n                            nums1[i+1:] = temp\\n                            p += 1\\n\\n\\nAnd here is the stdout:\\n(0, 0)\\n(1, 0)\\n(2, 0)\\n(3, 1)\\n(4, 1)\\n(5, 2)\\n(0, 0)\\n\\nWhith the following error:\\nIndexError: list index out of range\\n    elif nums1[i] > nums2[p]:\\nLine 19 in merge (Solution.py)\\n    ret = Solution().merge(param_1, param_2, param_3, param_4)\\nLine 58 in _driver (Solution.py)\\n    _driver()\\nLine 69 in <module> (Solution.py)\\nHow does this make sense? Where in my code are i and p being set to 0, 0?? This is weird... "
                    }
                ]
            },
            {
                "id": 2012707,
                "content": [
                    {
                        "username": "sandipuncc",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n\\n        \\n        for i in nums2:\\n            nums1.append(i)\\n\\n        nums1.sort()\\n        \\n        for j in nums1:\\n            if (j==0):\\n                nums1.remove(j)\\n\\n        return nums1\\n\\nThe first test case is not working"
                    },
                    {
                        "username": "SurajS23",
                        "content": "sort(nums1, nums1 + n);\\nwhy can\\'t I use sort function? It shows error: invalid operands to binary expression"
                    },
                    {
                        "username": "Nike-rgb",
                        "content": "I don\\'t know why this wouldn\\'t work:\\n\\n//javascript\\n/**\\n * @param {number[]} nums1\\n * @param {number} m\\n * @param {number[]} nums2\\n * @param {number} n\\n * @return {void} Do not return anything, modify nums1 in-place instead.\\n */\\nvar merge = function(nums1, m, nums2, n) {\\n    for(let i = m, k = 0; i < m+n; i++, k++) {\\n        nums1[i] = nums2[k]\\n    }\\n    nums1.sort();\\n};"
                    },
                    {
                        "username": "Supernova10",
                        "content": "in Example 1: nums1 = [1,2,3,0,0,0], m = 3. I don\\'t get it at the first place. why number of elements in nums1, m = 3?"
                    },
                    {
                        "username": "prarthitshah899",
                        "content": "Why below code of mine is not working? Anyone help?\n\n\n `nums1 = nums1 + nums2;\nnums1 = [i for i in nums1 if i != 0];\nnums1.sort();`"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t work because you\\'re appending nums2 to nums1, then removing zeros, which may remove valid zeros from the original lists, and then sorting; this doesn\\'t guarantee the correct merge of the two lists in the required manner."
                    },
                    {
                        "username": "MishRRa",
                        "content": "var merge = function (nums1, m, nums2, n) {\\n    nums1=nums1.slice(0,m)\\n   for(let i=0;i<n;i++){\\n       nums1.push(nums2[i])\\n   }\\n   nums1.map((value,index)=>{\\n   for(let i=0;i<nums1.length;i++ ){\\n       if(nums1[index]<nums1[i]&&index!==i){\\n           let j=nums1[index]\\n           nums1[index]=nums1[i]\\n           nums1[i]=j}}})\\n   return nums1\\n};\\nconsole.log(merge([1,2,3,0,0,0],3,[2,5,6],3))\\n\\nI have the above solution which is giving correct output in other compilers but on leatcode the test case is failing don\\'t know why"
                    },
                    {
                        "username": "ReadyRainFor",
                        "content": "why are we accommodating for the list length? it seems unlikely if we need to merge two lists like this, the first one would be perfectly ready to accept the second lists values by holding empty values, or zeroes, to replace"
                    },
                    {
                        "username": "rishabhjainfinal",
                        "content": "*i am trying some here*\\n `class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        if m:\\n            leIndex = 0\\n            for index, ar2e in enumerate(nums2):\\n                # print(\"range\", (leIndex, m+index))\\n                for i in range(leIndex, m+index):\\n                    # print(nums1[i],nums1[i] > ar2e, ar2e)\\n                    if nums1[i] > ar2e:\\n                        nums1.insert(i, ar2e)\\n                        nums1.pop()\\n                        leIndex = i+1\\n                        # print(nums1, ar2e, leIndex)\\n                        break\\n                else:\\n                    leIndex += 1\\n                    nums1[leIndex] = (ar2e)\\n        else:\\n            nums1= nums2\\n\\n        print(m,n,nums1,nums2)\\n`\\n\\nmy code is write but idk why it is giving me error "
                    },
                    {
                        "username": "sana479",
                        "content": "a good solution that won\\'t work on leetcode for some reason :) \\n\\n\\n`for x in nums2:\\n        nums1.append(x)\\n    y =list(filter(lambda x: x != 0,nums1))\\n    y.sort()\\n    print(y)\\n`\\n\\n"
                    },
                    {
                        "username": "voynow",
                        "content": "Is this a bug in the test?? Work in progress implementation:\\n\\n            class Solution(object):\\n                def merge(self, nums1, m, nums2, n):\\n                    p = 0\\n                    for i in range(len(nums1)):\\n                        print(i, p)\\n\\n                        if i >= m + p:\\n                            nums1[i] = nums2[p]\\n                            p += 1\\n\\n                        elif nums1[i] > nums2[p]:\\n                            temp = nums1[i:-1]\\n                            nums1[i] = nums2[p]\\n                            nums1[i+1:] = temp\\n                            p += 1\\n\\n\\nAnd here is the stdout:\\n(0, 0)\\n(1, 0)\\n(2, 0)\\n(3, 1)\\n(4, 1)\\n(5, 2)\\n(0, 0)\\n\\nWhith the following error:\\nIndexError: list index out of range\\n    elif nums1[i] > nums2[p]:\\nLine 19 in merge (Solution.py)\\n    ret = Solution().merge(param_1, param_2, param_3, param_4)\\nLine 58 in _driver (Solution.py)\\n    _driver()\\nLine 69 in <module> (Solution.py)\\nHow does this make sense? Where in my code are i and p being set to 0, 0?? This is weird... "
                    }
                ]
            },
            {
                "id": 2012529,
                "content": [
                    {
                        "username": "sandipuncc",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n\\n        \\n        for i in nums2:\\n            nums1.append(i)\\n\\n        nums1.sort()\\n        \\n        for j in nums1:\\n            if (j==0):\\n                nums1.remove(j)\\n\\n        return nums1\\n\\nThe first test case is not working"
                    },
                    {
                        "username": "SurajS23",
                        "content": "sort(nums1, nums1 + n);\\nwhy can\\'t I use sort function? It shows error: invalid operands to binary expression"
                    },
                    {
                        "username": "Nike-rgb",
                        "content": "I don\\'t know why this wouldn\\'t work:\\n\\n//javascript\\n/**\\n * @param {number[]} nums1\\n * @param {number} m\\n * @param {number[]} nums2\\n * @param {number} n\\n * @return {void} Do not return anything, modify nums1 in-place instead.\\n */\\nvar merge = function(nums1, m, nums2, n) {\\n    for(let i = m, k = 0; i < m+n; i++, k++) {\\n        nums1[i] = nums2[k]\\n    }\\n    nums1.sort();\\n};"
                    },
                    {
                        "username": "Supernova10",
                        "content": "in Example 1: nums1 = [1,2,3,0,0,0], m = 3. I don\\'t get it at the first place. why number of elements in nums1, m = 3?"
                    },
                    {
                        "username": "prarthitshah899",
                        "content": "Why below code of mine is not working? Anyone help?\n\n\n `nums1 = nums1 + nums2;\nnums1 = [i for i in nums1 if i != 0];\nnums1.sort();`"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t work because you\\'re appending nums2 to nums1, then removing zeros, which may remove valid zeros from the original lists, and then sorting; this doesn\\'t guarantee the correct merge of the two lists in the required manner."
                    },
                    {
                        "username": "MishRRa",
                        "content": "var merge = function (nums1, m, nums2, n) {\\n    nums1=nums1.slice(0,m)\\n   for(let i=0;i<n;i++){\\n       nums1.push(nums2[i])\\n   }\\n   nums1.map((value,index)=>{\\n   for(let i=0;i<nums1.length;i++ ){\\n       if(nums1[index]<nums1[i]&&index!==i){\\n           let j=nums1[index]\\n           nums1[index]=nums1[i]\\n           nums1[i]=j}}})\\n   return nums1\\n};\\nconsole.log(merge([1,2,3,0,0,0],3,[2,5,6],3))\\n\\nI have the above solution which is giving correct output in other compilers but on leatcode the test case is failing don\\'t know why"
                    },
                    {
                        "username": "ReadyRainFor",
                        "content": "why are we accommodating for the list length? it seems unlikely if we need to merge two lists like this, the first one would be perfectly ready to accept the second lists values by holding empty values, or zeroes, to replace"
                    },
                    {
                        "username": "rishabhjainfinal",
                        "content": "*i am trying some here*\\n `class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        if m:\\n            leIndex = 0\\n            for index, ar2e in enumerate(nums2):\\n                # print(\"range\", (leIndex, m+index))\\n                for i in range(leIndex, m+index):\\n                    # print(nums1[i],nums1[i] > ar2e, ar2e)\\n                    if nums1[i] > ar2e:\\n                        nums1.insert(i, ar2e)\\n                        nums1.pop()\\n                        leIndex = i+1\\n                        # print(nums1, ar2e, leIndex)\\n                        break\\n                else:\\n                    leIndex += 1\\n                    nums1[leIndex] = (ar2e)\\n        else:\\n            nums1= nums2\\n\\n        print(m,n,nums1,nums2)\\n`\\n\\nmy code is write but idk why it is giving me error "
                    },
                    {
                        "username": "sana479",
                        "content": "a good solution that won\\'t work on leetcode for some reason :) \\n\\n\\n`for x in nums2:\\n        nums1.append(x)\\n    y =list(filter(lambda x: x != 0,nums1))\\n    y.sort()\\n    print(y)\\n`\\n\\n"
                    },
                    {
                        "username": "voynow",
                        "content": "Is this a bug in the test?? Work in progress implementation:\\n\\n            class Solution(object):\\n                def merge(self, nums1, m, nums2, n):\\n                    p = 0\\n                    for i in range(len(nums1)):\\n                        print(i, p)\\n\\n                        if i >= m + p:\\n                            nums1[i] = nums2[p]\\n                            p += 1\\n\\n                        elif nums1[i] > nums2[p]:\\n                            temp = nums1[i:-1]\\n                            nums1[i] = nums2[p]\\n                            nums1[i+1:] = temp\\n                            p += 1\\n\\n\\nAnd here is the stdout:\\n(0, 0)\\n(1, 0)\\n(2, 0)\\n(3, 1)\\n(4, 1)\\n(5, 2)\\n(0, 0)\\n\\nWhith the following error:\\nIndexError: list index out of range\\n    elif nums1[i] > nums2[p]:\\nLine 19 in merge (Solution.py)\\n    ret = Solution().merge(param_1, param_2, param_3, param_4)\\nLine 58 in _driver (Solution.py)\\n    _driver()\\nLine 69 in <module> (Solution.py)\\nHow does this make sense? Where in my code are i and p being set to 0, 0?? This is weird... "
                    }
                ]
            },
            {
                "id": 2009838,
                "content": [
                    {
                        "username": "sandipuncc",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n\\n        \\n        for i in nums2:\\n            nums1.append(i)\\n\\n        nums1.sort()\\n        \\n        for j in nums1:\\n            if (j==0):\\n                nums1.remove(j)\\n\\n        return nums1\\n\\nThe first test case is not working"
                    },
                    {
                        "username": "SurajS23",
                        "content": "sort(nums1, nums1 + n);\\nwhy can\\'t I use sort function? It shows error: invalid operands to binary expression"
                    },
                    {
                        "username": "Nike-rgb",
                        "content": "I don\\'t know why this wouldn\\'t work:\\n\\n//javascript\\n/**\\n * @param {number[]} nums1\\n * @param {number} m\\n * @param {number[]} nums2\\n * @param {number} n\\n * @return {void} Do not return anything, modify nums1 in-place instead.\\n */\\nvar merge = function(nums1, m, nums2, n) {\\n    for(let i = m, k = 0; i < m+n; i++, k++) {\\n        nums1[i] = nums2[k]\\n    }\\n    nums1.sort();\\n};"
                    },
                    {
                        "username": "Supernova10",
                        "content": "in Example 1: nums1 = [1,2,3,0,0,0], m = 3. I don\\'t get it at the first place. why number of elements in nums1, m = 3?"
                    },
                    {
                        "username": "prarthitshah899",
                        "content": "Why below code of mine is not working? Anyone help?\n\n\n `nums1 = nums1 + nums2;\nnums1 = [i for i in nums1 if i != 0];\nnums1.sort();`"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t work because you\\'re appending nums2 to nums1, then removing zeros, which may remove valid zeros from the original lists, and then sorting; this doesn\\'t guarantee the correct merge of the two lists in the required manner."
                    },
                    {
                        "username": "MishRRa",
                        "content": "var merge = function (nums1, m, nums2, n) {\\n    nums1=nums1.slice(0,m)\\n   for(let i=0;i<n;i++){\\n       nums1.push(nums2[i])\\n   }\\n   nums1.map((value,index)=>{\\n   for(let i=0;i<nums1.length;i++ ){\\n       if(nums1[index]<nums1[i]&&index!==i){\\n           let j=nums1[index]\\n           nums1[index]=nums1[i]\\n           nums1[i]=j}}})\\n   return nums1\\n};\\nconsole.log(merge([1,2,3,0,0,0],3,[2,5,6],3))\\n\\nI have the above solution which is giving correct output in other compilers but on leatcode the test case is failing don\\'t know why"
                    },
                    {
                        "username": "ReadyRainFor",
                        "content": "why are we accommodating for the list length? it seems unlikely if we need to merge two lists like this, the first one would be perfectly ready to accept the second lists values by holding empty values, or zeroes, to replace"
                    },
                    {
                        "username": "rishabhjainfinal",
                        "content": "*i am trying some here*\\n `class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        if m:\\n            leIndex = 0\\n            for index, ar2e in enumerate(nums2):\\n                # print(\"range\", (leIndex, m+index))\\n                for i in range(leIndex, m+index):\\n                    # print(nums1[i],nums1[i] > ar2e, ar2e)\\n                    if nums1[i] > ar2e:\\n                        nums1.insert(i, ar2e)\\n                        nums1.pop()\\n                        leIndex = i+1\\n                        # print(nums1, ar2e, leIndex)\\n                        break\\n                else:\\n                    leIndex += 1\\n                    nums1[leIndex] = (ar2e)\\n        else:\\n            nums1= nums2\\n\\n        print(m,n,nums1,nums2)\\n`\\n\\nmy code is write but idk why it is giving me error "
                    },
                    {
                        "username": "sana479",
                        "content": "a good solution that won\\'t work on leetcode for some reason :) \\n\\n\\n`for x in nums2:\\n        nums1.append(x)\\n    y =list(filter(lambda x: x != 0,nums1))\\n    y.sort()\\n    print(y)\\n`\\n\\n"
                    },
                    {
                        "username": "voynow",
                        "content": "Is this a bug in the test?? Work in progress implementation:\\n\\n            class Solution(object):\\n                def merge(self, nums1, m, nums2, n):\\n                    p = 0\\n                    for i in range(len(nums1)):\\n                        print(i, p)\\n\\n                        if i >= m + p:\\n                            nums1[i] = nums2[p]\\n                            p += 1\\n\\n                        elif nums1[i] > nums2[p]:\\n                            temp = nums1[i:-1]\\n                            nums1[i] = nums2[p]\\n                            nums1[i+1:] = temp\\n                            p += 1\\n\\n\\nAnd here is the stdout:\\n(0, 0)\\n(1, 0)\\n(2, 0)\\n(3, 1)\\n(4, 1)\\n(5, 2)\\n(0, 0)\\n\\nWhith the following error:\\nIndexError: list index out of range\\n    elif nums1[i] > nums2[p]:\\nLine 19 in merge (Solution.py)\\n    ret = Solution().merge(param_1, param_2, param_3, param_4)\\nLine 58 in _driver (Solution.py)\\n    _driver()\\nLine 69 in <module> (Solution.py)\\nHow does this make sense? Where in my code are i and p being set to 0, 0?? This is weird... "
                    }
                ]
            },
            {
                "id": 2007233,
                "content": [
                    {
                        "username": "mlivingston",
                        "content": "why are these questions always worded in the worst english.... \"non-decreasing order\""
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "Why is this solution not working (it works in online compiler).\\n Test case:\\nnums1 = [1,2,3,0,0,0], m=3\\nnums2 = [2,5,6], n=3\\n`nums1.extend(nums2)\\nnums1.sort()\\nnums1 = [i for i in nums1 if i != 0]`\\n\\nIt shows output: [0,0,0,1,2,2,3,5,6]. \\nThe online compiler shows the expected output: [1,2,2,3,5,6]."
                    },
                    {
                        "username": "T_Lalith_kumar",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int temp[] = new int[m+n];\\n        for(int i=0;i<m+n;i++){\\n            if(i<m && nums1[i]!=0){\\n                temp[i]=nums1[i];\\n            }\\n            if((i==m || i>m) && nums2[i-m]!=0){\\n                temp[i]=nums2[i-m];\\n            }\\n        }\\n        System.out.println(Arrays.toString(Arrays.stream(temp).sorted().toArray()));\\n    }\\n}\\n\\n\\nwhy is this not working when I\\'m doing in IDE it is working fine"
                    },
                    {
                        "username": "singh-Rustam",
                        "content": "I misread this question and I think this is a common mistake most of us may repeat so read this carefully :\\n In the Question it says \"two integers m and n, representing the number of elements in nums1 and nums2 respectively.\"\\n\\nHere \"m\" represents no. of elements present in the nums1 array NOT the length of nums1 array that means if I declare an array of length \"5\" and do not assign value of any indexes, \"m\" will not be equal to \"5\" it will be equal to \"0\" since there\\'s no element in nums1.\\n\\nLater in the question, it stated that \"nums2 has a length of n\" . Means if we declare a nums2 array with length 5, \"n\" will be \"5\" regardless of the emptiness of the array.\\n\\nSo in the above mentioned case, the (m+n) will remain \"5\" which is equal to \"nums1.length\" as mentioned in the constraints, whereas the sum of lengths of both the arrays will be different.\\n\\nThe testcase: nums1 = {0,0,0,0,0} : m = 0; (nums1 is uninitialised)\\n                        nums2 = {1,2,3,4,5} : n =5;\\n\\nKeep this in your mind while building the logic. :)\\n\\n"
                    },
                    {
                        "username": "harishgokul",
                        "content": " int j=0;\n\n        if(m==0){\n            nums1=nums2;\n        }\n        else {\n            for (int i = m; i < m + n; i++) {\n                nums1[i] = nums2[j++];\n            }\n        }\n         Arrays.sort(nums1);\n\nexample 1,2 is correct but 3 output is 1 ,i run in my local editor works ,but in leetcode output is 0 \nif you know why reply,"
                    },
                    {
                        "username": "skyrood",
                        "content": "can you explain please how count([1,2,3,0,0,0]) can be 3?"
                    },
                    {
                        "username": "kankriyayash18",
                        "content": "Tell me the actual code You have written"
                    },
                    {
                        "username": "Davidjayan",
                        "content": "Modified array is showing result in console but not in output. Can anyone help?\n    nums1 = [...nums1.slice(0,m),...nums2.slice(0,n)].sort((a,b)=>a-b);\n    console.log(nums1) --->this one works but output showing wrong"
                    },
                    {
                        "username": "kankriyayash18",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        a=[]\\n        while m > 0 and n > 0:\\n            if nums1[m-1]>=nums2[n-1]:\\n                a.append(nums1[m-1])\\n                m -= 1\\n            else:\\n                a.append(nums2[n-1])\\n                n -= 1\\n        while m > 0:\\n            a.append(nums1[m - 1])\\n            m -= 1\\n        while n > 0:\\n            a.append(nums2[n - 1])\\n            n -= 1\\n        return a[::-1]\\n\\nwhy is this code wrong?"
                    },
                    {
                        "username": "Adhar_Sharma",
                        "content": "what is wrong with my question ?? Please help me...\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i=0 , j=0 , k=0;\\n        while(i<m && j<n){\\n            if(nums1[i]<=nums2[j]){\\n                nums1[k] = nums1[i];\\n                i++;\\n                k++;\\n            }\\n            else{\\n                nums1[k] = nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        while(i<m){\\n            nums1[k] = nums1[i];\\n                i++;\\n                k++;\\n        }\\n        while(j<n){\\n             nums1[k] = nums2[j];\\n                j++;\\n                k++;\\n        }\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "AhmedQasem4",
                        "content": "why this logic in javascript give me error in testCase 7 although it give me the expected result in vs code but in leetcode compiler it generate differ result??? \\n\\n if(m == 0)\\n        nums1 = nums2;\\n    \\n    else{\\n        for (let i = m; i < m + n; i++) {\\n        nums1[i] = nums2[i - n];\\n      }\\n    }\\n\\n  for (let i = 0; i < nums1.length; i++) {\\n    if (nums1[i] >= nums1[i + 1]) {\\n      let temp = nums1[i];\\n      nums1[i] = nums1[i + 1];\\n      nums1[i + 1] = temp;\\n    }\\n  }"
                    }
                ]
            },
            {
                "id": 2006536,
                "content": [
                    {
                        "username": "mlivingston",
                        "content": "why are these questions always worded in the worst english.... \"non-decreasing order\""
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "Why is this solution not working (it works in online compiler).\\n Test case:\\nnums1 = [1,2,3,0,0,0], m=3\\nnums2 = [2,5,6], n=3\\n`nums1.extend(nums2)\\nnums1.sort()\\nnums1 = [i for i in nums1 if i != 0]`\\n\\nIt shows output: [0,0,0,1,2,2,3,5,6]. \\nThe online compiler shows the expected output: [1,2,2,3,5,6]."
                    },
                    {
                        "username": "T_Lalith_kumar",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int temp[] = new int[m+n];\\n        for(int i=0;i<m+n;i++){\\n            if(i<m && nums1[i]!=0){\\n                temp[i]=nums1[i];\\n            }\\n            if((i==m || i>m) && nums2[i-m]!=0){\\n                temp[i]=nums2[i-m];\\n            }\\n        }\\n        System.out.println(Arrays.toString(Arrays.stream(temp).sorted().toArray()));\\n    }\\n}\\n\\n\\nwhy is this not working when I\\'m doing in IDE it is working fine"
                    },
                    {
                        "username": "singh-Rustam",
                        "content": "I misread this question and I think this is a common mistake most of us may repeat so read this carefully :\\n In the Question it says \"two integers m and n, representing the number of elements in nums1 and nums2 respectively.\"\\n\\nHere \"m\" represents no. of elements present in the nums1 array NOT the length of nums1 array that means if I declare an array of length \"5\" and do not assign value of any indexes, \"m\" will not be equal to \"5\" it will be equal to \"0\" since there\\'s no element in nums1.\\n\\nLater in the question, it stated that \"nums2 has a length of n\" . Means if we declare a nums2 array with length 5, \"n\" will be \"5\" regardless of the emptiness of the array.\\n\\nSo in the above mentioned case, the (m+n) will remain \"5\" which is equal to \"nums1.length\" as mentioned in the constraints, whereas the sum of lengths of both the arrays will be different.\\n\\nThe testcase: nums1 = {0,0,0,0,0} : m = 0; (nums1 is uninitialised)\\n                        nums2 = {1,2,3,4,5} : n =5;\\n\\nKeep this in your mind while building the logic. :)\\n\\n"
                    },
                    {
                        "username": "harishgokul",
                        "content": " int j=0;\n\n        if(m==0){\n            nums1=nums2;\n        }\n        else {\n            for (int i = m; i < m + n; i++) {\n                nums1[i] = nums2[j++];\n            }\n        }\n         Arrays.sort(nums1);\n\nexample 1,2 is correct but 3 output is 1 ,i run in my local editor works ,but in leetcode output is 0 \nif you know why reply,"
                    },
                    {
                        "username": "skyrood",
                        "content": "can you explain please how count([1,2,3,0,0,0]) can be 3?"
                    },
                    {
                        "username": "kankriyayash18",
                        "content": "Tell me the actual code You have written"
                    },
                    {
                        "username": "Davidjayan",
                        "content": "Modified array is showing result in console but not in output. Can anyone help?\n    nums1 = [...nums1.slice(0,m),...nums2.slice(0,n)].sort((a,b)=>a-b);\n    console.log(nums1) --->this one works but output showing wrong"
                    },
                    {
                        "username": "kankriyayash18",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        a=[]\\n        while m > 0 and n > 0:\\n            if nums1[m-1]>=nums2[n-1]:\\n                a.append(nums1[m-1])\\n                m -= 1\\n            else:\\n                a.append(nums2[n-1])\\n                n -= 1\\n        while m > 0:\\n            a.append(nums1[m - 1])\\n            m -= 1\\n        while n > 0:\\n            a.append(nums2[n - 1])\\n            n -= 1\\n        return a[::-1]\\n\\nwhy is this code wrong?"
                    },
                    {
                        "username": "Adhar_Sharma",
                        "content": "what is wrong with my question ?? Please help me...\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i=0 , j=0 , k=0;\\n        while(i<m && j<n){\\n            if(nums1[i]<=nums2[j]){\\n                nums1[k] = nums1[i];\\n                i++;\\n                k++;\\n            }\\n            else{\\n                nums1[k] = nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        while(i<m){\\n            nums1[k] = nums1[i];\\n                i++;\\n                k++;\\n        }\\n        while(j<n){\\n             nums1[k] = nums2[j];\\n                j++;\\n                k++;\\n        }\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "AhmedQasem4",
                        "content": "why this logic in javascript give me error in testCase 7 although it give me the expected result in vs code but in leetcode compiler it generate differ result??? \\n\\n if(m == 0)\\n        nums1 = nums2;\\n    \\n    else{\\n        for (let i = m; i < m + n; i++) {\\n        nums1[i] = nums2[i - n];\\n      }\\n    }\\n\\n  for (let i = 0; i < nums1.length; i++) {\\n    if (nums1[i] >= nums1[i + 1]) {\\n      let temp = nums1[i];\\n      nums1[i] = nums1[i + 1];\\n      nums1[i + 1] = temp;\\n    }\\n  }"
                    }
                ]
            },
            {
                "id": 2004632,
                "content": [
                    {
                        "username": "mlivingston",
                        "content": "why are these questions always worded in the worst english.... \"non-decreasing order\""
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "Why is this solution not working (it works in online compiler).\\n Test case:\\nnums1 = [1,2,3,0,0,0], m=3\\nnums2 = [2,5,6], n=3\\n`nums1.extend(nums2)\\nnums1.sort()\\nnums1 = [i for i in nums1 if i != 0]`\\n\\nIt shows output: [0,0,0,1,2,2,3,5,6]. \\nThe online compiler shows the expected output: [1,2,2,3,5,6]."
                    },
                    {
                        "username": "T_Lalith_kumar",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int temp[] = new int[m+n];\\n        for(int i=0;i<m+n;i++){\\n            if(i<m && nums1[i]!=0){\\n                temp[i]=nums1[i];\\n            }\\n            if((i==m || i>m) && nums2[i-m]!=0){\\n                temp[i]=nums2[i-m];\\n            }\\n        }\\n        System.out.println(Arrays.toString(Arrays.stream(temp).sorted().toArray()));\\n    }\\n}\\n\\n\\nwhy is this not working when I\\'m doing in IDE it is working fine"
                    },
                    {
                        "username": "singh-Rustam",
                        "content": "I misread this question and I think this is a common mistake most of us may repeat so read this carefully :\\n In the Question it says \"two integers m and n, representing the number of elements in nums1 and nums2 respectively.\"\\n\\nHere \"m\" represents no. of elements present in the nums1 array NOT the length of nums1 array that means if I declare an array of length \"5\" and do not assign value of any indexes, \"m\" will not be equal to \"5\" it will be equal to \"0\" since there\\'s no element in nums1.\\n\\nLater in the question, it stated that \"nums2 has a length of n\" . Means if we declare a nums2 array with length 5, \"n\" will be \"5\" regardless of the emptiness of the array.\\n\\nSo in the above mentioned case, the (m+n) will remain \"5\" which is equal to \"nums1.length\" as mentioned in the constraints, whereas the sum of lengths of both the arrays will be different.\\n\\nThe testcase: nums1 = {0,0,0,0,0} : m = 0; (nums1 is uninitialised)\\n                        nums2 = {1,2,3,4,5} : n =5;\\n\\nKeep this in your mind while building the logic. :)\\n\\n"
                    },
                    {
                        "username": "harishgokul",
                        "content": " int j=0;\n\n        if(m==0){\n            nums1=nums2;\n        }\n        else {\n            for (int i = m; i < m + n; i++) {\n                nums1[i] = nums2[j++];\n            }\n        }\n         Arrays.sort(nums1);\n\nexample 1,2 is correct but 3 output is 1 ,i run in my local editor works ,but in leetcode output is 0 \nif you know why reply,"
                    },
                    {
                        "username": "skyrood",
                        "content": "can you explain please how count([1,2,3,0,0,0]) can be 3?"
                    },
                    {
                        "username": "kankriyayash18",
                        "content": "Tell me the actual code You have written"
                    },
                    {
                        "username": "Davidjayan",
                        "content": "Modified array is showing result in console but not in output. Can anyone help?\n    nums1 = [...nums1.slice(0,m),...nums2.slice(0,n)].sort((a,b)=>a-b);\n    console.log(nums1) --->this one works but output showing wrong"
                    },
                    {
                        "username": "kankriyayash18",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        a=[]\\n        while m > 0 and n > 0:\\n            if nums1[m-1]>=nums2[n-1]:\\n                a.append(nums1[m-1])\\n                m -= 1\\n            else:\\n                a.append(nums2[n-1])\\n                n -= 1\\n        while m > 0:\\n            a.append(nums1[m - 1])\\n            m -= 1\\n        while n > 0:\\n            a.append(nums2[n - 1])\\n            n -= 1\\n        return a[::-1]\\n\\nwhy is this code wrong?"
                    },
                    {
                        "username": "Adhar_Sharma",
                        "content": "what is wrong with my question ?? Please help me...\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i=0 , j=0 , k=0;\\n        while(i<m && j<n){\\n            if(nums1[i]<=nums2[j]){\\n                nums1[k] = nums1[i];\\n                i++;\\n                k++;\\n            }\\n            else{\\n                nums1[k] = nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        while(i<m){\\n            nums1[k] = nums1[i];\\n                i++;\\n                k++;\\n        }\\n        while(j<n){\\n             nums1[k] = nums2[j];\\n                j++;\\n                k++;\\n        }\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "AhmedQasem4",
                        "content": "why this logic in javascript give me error in testCase 7 although it give me the expected result in vs code but in leetcode compiler it generate differ result??? \\n\\n if(m == 0)\\n        nums1 = nums2;\\n    \\n    else{\\n        for (let i = m; i < m + n; i++) {\\n        nums1[i] = nums2[i - n];\\n      }\\n    }\\n\\n  for (let i = 0; i < nums1.length; i++) {\\n    if (nums1[i] >= nums1[i + 1]) {\\n      let temp = nums1[i];\\n      nums1[i] = nums1[i + 1];\\n      nums1[i + 1] = temp;\\n    }\\n  }"
                    }
                ]
            },
            {
                "id": 2004301,
                "content": [
                    {
                        "username": "mlivingston",
                        "content": "why are these questions always worded in the worst english.... \"non-decreasing order\""
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "Why is this solution not working (it works in online compiler).\\n Test case:\\nnums1 = [1,2,3,0,0,0], m=3\\nnums2 = [2,5,6], n=3\\n`nums1.extend(nums2)\\nnums1.sort()\\nnums1 = [i for i in nums1 if i != 0]`\\n\\nIt shows output: [0,0,0,1,2,2,3,5,6]. \\nThe online compiler shows the expected output: [1,2,2,3,5,6]."
                    },
                    {
                        "username": "T_Lalith_kumar",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int temp[] = new int[m+n];\\n        for(int i=0;i<m+n;i++){\\n            if(i<m && nums1[i]!=0){\\n                temp[i]=nums1[i];\\n            }\\n            if((i==m || i>m) && nums2[i-m]!=0){\\n                temp[i]=nums2[i-m];\\n            }\\n        }\\n        System.out.println(Arrays.toString(Arrays.stream(temp).sorted().toArray()));\\n    }\\n}\\n\\n\\nwhy is this not working when I\\'m doing in IDE it is working fine"
                    },
                    {
                        "username": "singh-Rustam",
                        "content": "I misread this question and I think this is a common mistake most of us may repeat so read this carefully :\\n In the Question it says \"two integers m and n, representing the number of elements in nums1 and nums2 respectively.\"\\n\\nHere \"m\" represents no. of elements present in the nums1 array NOT the length of nums1 array that means if I declare an array of length \"5\" and do not assign value of any indexes, \"m\" will not be equal to \"5\" it will be equal to \"0\" since there\\'s no element in nums1.\\n\\nLater in the question, it stated that \"nums2 has a length of n\" . Means if we declare a nums2 array with length 5, \"n\" will be \"5\" regardless of the emptiness of the array.\\n\\nSo in the above mentioned case, the (m+n) will remain \"5\" which is equal to \"nums1.length\" as mentioned in the constraints, whereas the sum of lengths of both the arrays will be different.\\n\\nThe testcase: nums1 = {0,0,0,0,0} : m = 0; (nums1 is uninitialised)\\n                        nums2 = {1,2,3,4,5} : n =5;\\n\\nKeep this in your mind while building the logic. :)\\n\\n"
                    },
                    {
                        "username": "harishgokul",
                        "content": " int j=0;\n\n        if(m==0){\n            nums1=nums2;\n        }\n        else {\n            for (int i = m; i < m + n; i++) {\n                nums1[i] = nums2[j++];\n            }\n        }\n         Arrays.sort(nums1);\n\nexample 1,2 is correct but 3 output is 1 ,i run in my local editor works ,but in leetcode output is 0 \nif you know why reply,"
                    },
                    {
                        "username": "skyrood",
                        "content": "can you explain please how count([1,2,3,0,0,0]) can be 3?"
                    },
                    {
                        "username": "kankriyayash18",
                        "content": "Tell me the actual code You have written"
                    },
                    {
                        "username": "Davidjayan",
                        "content": "Modified array is showing result in console but not in output. Can anyone help?\n    nums1 = [...nums1.slice(0,m),...nums2.slice(0,n)].sort((a,b)=>a-b);\n    console.log(nums1) --->this one works but output showing wrong"
                    },
                    {
                        "username": "kankriyayash18",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        a=[]\\n        while m > 0 and n > 0:\\n            if nums1[m-1]>=nums2[n-1]:\\n                a.append(nums1[m-1])\\n                m -= 1\\n            else:\\n                a.append(nums2[n-1])\\n                n -= 1\\n        while m > 0:\\n            a.append(nums1[m - 1])\\n            m -= 1\\n        while n > 0:\\n            a.append(nums2[n - 1])\\n            n -= 1\\n        return a[::-1]\\n\\nwhy is this code wrong?"
                    },
                    {
                        "username": "Adhar_Sharma",
                        "content": "what is wrong with my question ?? Please help me...\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i=0 , j=0 , k=0;\\n        while(i<m && j<n){\\n            if(nums1[i]<=nums2[j]){\\n                nums1[k] = nums1[i];\\n                i++;\\n                k++;\\n            }\\n            else{\\n                nums1[k] = nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        while(i<m){\\n            nums1[k] = nums1[i];\\n                i++;\\n                k++;\\n        }\\n        while(j<n){\\n             nums1[k] = nums2[j];\\n                j++;\\n                k++;\\n        }\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "AhmedQasem4",
                        "content": "why this logic in javascript give me error in testCase 7 although it give me the expected result in vs code but in leetcode compiler it generate differ result??? \\n\\n if(m == 0)\\n        nums1 = nums2;\\n    \\n    else{\\n        for (let i = m; i < m + n; i++) {\\n        nums1[i] = nums2[i - n];\\n      }\\n    }\\n\\n  for (let i = 0; i < nums1.length; i++) {\\n    if (nums1[i] >= nums1[i + 1]) {\\n      let temp = nums1[i];\\n      nums1[i] = nums1[i + 1];\\n      nums1[i + 1] = temp;\\n    }\\n  }"
                    }
                ]
            },
            {
                "id": 2004149,
                "content": [
                    {
                        "username": "mlivingston",
                        "content": "why are these questions always worded in the worst english.... \"non-decreasing order\""
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "Why is this solution not working (it works in online compiler).\\n Test case:\\nnums1 = [1,2,3,0,0,0], m=3\\nnums2 = [2,5,6], n=3\\n`nums1.extend(nums2)\\nnums1.sort()\\nnums1 = [i for i in nums1 if i != 0]`\\n\\nIt shows output: [0,0,0,1,2,2,3,5,6]. \\nThe online compiler shows the expected output: [1,2,2,3,5,6]."
                    },
                    {
                        "username": "T_Lalith_kumar",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int temp[] = new int[m+n];\\n        for(int i=0;i<m+n;i++){\\n            if(i<m && nums1[i]!=0){\\n                temp[i]=nums1[i];\\n            }\\n            if((i==m || i>m) && nums2[i-m]!=0){\\n                temp[i]=nums2[i-m];\\n            }\\n        }\\n        System.out.println(Arrays.toString(Arrays.stream(temp).sorted().toArray()));\\n    }\\n}\\n\\n\\nwhy is this not working when I\\'m doing in IDE it is working fine"
                    },
                    {
                        "username": "singh-Rustam",
                        "content": "I misread this question and I think this is a common mistake most of us may repeat so read this carefully :\\n In the Question it says \"two integers m and n, representing the number of elements in nums1 and nums2 respectively.\"\\n\\nHere \"m\" represents no. of elements present in the nums1 array NOT the length of nums1 array that means if I declare an array of length \"5\" and do not assign value of any indexes, \"m\" will not be equal to \"5\" it will be equal to \"0\" since there\\'s no element in nums1.\\n\\nLater in the question, it stated that \"nums2 has a length of n\" . Means if we declare a nums2 array with length 5, \"n\" will be \"5\" regardless of the emptiness of the array.\\n\\nSo in the above mentioned case, the (m+n) will remain \"5\" which is equal to \"nums1.length\" as mentioned in the constraints, whereas the sum of lengths of both the arrays will be different.\\n\\nThe testcase: nums1 = {0,0,0,0,0} : m = 0; (nums1 is uninitialised)\\n                        nums2 = {1,2,3,4,5} : n =5;\\n\\nKeep this in your mind while building the logic. :)\\n\\n"
                    },
                    {
                        "username": "harishgokul",
                        "content": " int j=0;\n\n        if(m==0){\n            nums1=nums2;\n        }\n        else {\n            for (int i = m; i < m + n; i++) {\n                nums1[i] = nums2[j++];\n            }\n        }\n         Arrays.sort(nums1);\n\nexample 1,2 is correct but 3 output is 1 ,i run in my local editor works ,but in leetcode output is 0 \nif you know why reply,"
                    },
                    {
                        "username": "skyrood",
                        "content": "can you explain please how count([1,2,3,0,0,0]) can be 3?"
                    },
                    {
                        "username": "kankriyayash18",
                        "content": "Tell me the actual code You have written"
                    },
                    {
                        "username": "Davidjayan",
                        "content": "Modified array is showing result in console but not in output. Can anyone help?\n    nums1 = [...nums1.slice(0,m),...nums2.slice(0,n)].sort((a,b)=>a-b);\n    console.log(nums1) --->this one works but output showing wrong"
                    },
                    {
                        "username": "kankriyayash18",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        a=[]\\n        while m > 0 and n > 0:\\n            if nums1[m-1]>=nums2[n-1]:\\n                a.append(nums1[m-1])\\n                m -= 1\\n            else:\\n                a.append(nums2[n-1])\\n                n -= 1\\n        while m > 0:\\n            a.append(nums1[m - 1])\\n            m -= 1\\n        while n > 0:\\n            a.append(nums2[n - 1])\\n            n -= 1\\n        return a[::-1]\\n\\nwhy is this code wrong?"
                    },
                    {
                        "username": "Adhar_Sharma",
                        "content": "what is wrong with my question ?? Please help me...\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i=0 , j=0 , k=0;\\n        while(i<m && j<n){\\n            if(nums1[i]<=nums2[j]){\\n                nums1[k] = nums1[i];\\n                i++;\\n                k++;\\n            }\\n            else{\\n                nums1[k] = nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        while(i<m){\\n            nums1[k] = nums1[i];\\n                i++;\\n                k++;\\n        }\\n        while(j<n){\\n             nums1[k] = nums2[j];\\n                j++;\\n                k++;\\n        }\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "AhmedQasem4",
                        "content": "why this logic in javascript give me error in testCase 7 although it give me the expected result in vs code but in leetcode compiler it generate differ result??? \\n\\n if(m == 0)\\n        nums1 = nums2;\\n    \\n    else{\\n        for (let i = m; i < m + n; i++) {\\n        nums1[i] = nums2[i - n];\\n      }\\n    }\\n\\n  for (let i = 0; i < nums1.length; i++) {\\n    if (nums1[i] >= nums1[i + 1]) {\\n      let temp = nums1[i];\\n      nums1[i] = nums1[i + 1];\\n      nums1[i + 1] = temp;\\n    }\\n  }"
                    }
                ]
            },
            {
                "id": 2004041,
                "content": [
                    {
                        "username": "mlivingston",
                        "content": "why are these questions always worded in the worst english.... \"non-decreasing order\""
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "Why is this solution not working (it works in online compiler).\\n Test case:\\nnums1 = [1,2,3,0,0,0], m=3\\nnums2 = [2,5,6], n=3\\n`nums1.extend(nums2)\\nnums1.sort()\\nnums1 = [i for i in nums1 if i != 0]`\\n\\nIt shows output: [0,0,0,1,2,2,3,5,6]. \\nThe online compiler shows the expected output: [1,2,2,3,5,6]."
                    },
                    {
                        "username": "T_Lalith_kumar",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int temp[] = new int[m+n];\\n        for(int i=0;i<m+n;i++){\\n            if(i<m && nums1[i]!=0){\\n                temp[i]=nums1[i];\\n            }\\n            if((i==m || i>m) && nums2[i-m]!=0){\\n                temp[i]=nums2[i-m];\\n            }\\n        }\\n        System.out.println(Arrays.toString(Arrays.stream(temp).sorted().toArray()));\\n    }\\n}\\n\\n\\nwhy is this not working when I\\'m doing in IDE it is working fine"
                    },
                    {
                        "username": "singh-Rustam",
                        "content": "I misread this question and I think this is a common mistake most of us may repeat so read this carefully :\\n In the Question it says \"two integers m and n, representing the number of elements in nums1 and nums2 respectively.\"\\n\\nHere \"m\" represents no. of elements present in the nums1 array NOT the length of nums1 array that means if I declare an array of length \"5\" and do not assign value of any indexes, \"m\" will not be equal to \"5\" it will be equal to \"0\" since there\\'s no element in nums1.\\n\\nLater in the question, it stated that \"nums2 has a length of n\" . Means if we declare a nums2 array with length 5, \"n\" will be \"5\" regardless of the emptiness of the array.\\n\\nSo in the above mentioned case, the (m+n) will remain \"5\" which is equal to \"nums1.length\" as mentioned in the constraints, whereas the sum of lengths of both the arrays will be different.\\n\\nThe testcase: nums1 = {0,0,0,0,0} : m = 0; (nums1 is uninitialised)\\n                        nums2 = {1,2,3,4,5} : n =5;\\n\\nKeep this in your mind while building the logic. :)\\n\\n"
                    },
                    {
                        "username": "harishgokul",
                        "content": " int j=0;\n\n        if(m==0){\n            nums1=nums2;\n        }\n        else {\n            for (int i = m; i < m + n; i++) {\n                nums1[i] = nums2[j++];\n            }\n        }\n         Arrays.sort(nums1);\n\nexample 1,2 is correct but 3 output is 1 ,i run in my local editor works ,but in leetcode output is 0 \nif you know why reply,"
                    },
                    {
                        "username": "skyrood",
                        "content": "can you explain please how count([1,2,3,0,0,0]) can be 3?"
                    },
                    {
                        "username": "kankriyayash18",
                        "content": "Tell me the actual code You have written"
                    },
                    {
                        "username": "Davidjayan",
                        "content": "Modified array is showing result in console but not in output. Can anyone help?\n    nums1 = [...nums1.slice(0,m),...nums2.slice(0,n)].sort((a,b)=>a-b);\n    console.log(nums1) --->this one works but output showing wrong"
                    },
                    {
                        "username": "kankriyayash18",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        a=[]\\n        while m > 0 and n > 0:\\n            if nums1[m-1]>=nums2[n-1]:\\n                a.append(nums1[m-1])\\n                m -= 1\\n            else:\\n                a.append(nums2[n-1])\\n                n -= 1\\n        while m > 0:\\n            a.append(nums1[m - 1])\\n            m -= 1\\n        while n > 0:\\n            a.append(nums2[n - 1])\\n            n -= 1\\n        return a[::-1]\\n\\nwhy is this code wrong?"
                    },
                    {
                        "username": "Adhar_Sharma",
                        "content": "what is wrong with my question ?? Please help me...\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i=0 , j=0 , k=0;\\n        while(i<m && j<n){\\n            if(nums1[i]<=nums2[j]){\\n                nums1[k] = nums1[i];\\n                i++;\\n                k++;\\n            }\\n            else{\\n                nums1[k] = nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        while(i<m){\\n            nums1[k] = nums1[i];\\n                i++;\\n                k++;\\n        }\\n        while(j<n){\\n             nums1[k] = nums2[j];\\n                j++;\\n                k++;\\n        }\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "AhmedQasem4",
                        "content": "why this logic in javascript give me error in testCase 7 although it give me the expected result in vs code but in leetcode compiler it generate differ result??? \\n\\n if(m == 0)\\n        nums1 = nums2;\\n    \\n    else{\\n        for (let i = m; i < m + n; i++) {\\n        nums1[i] = nums2[i - n];\\n      }\\n    }\\n\\n  for (let i = 0; i < nums1.length; i++) {\\n    if (nums1[i] >= nums1[i + 1]) {\\n      let temp = nums1[i];\\n      nums1[i] = nums1[i + 1];\\n      nums1[i + 1] = temp;\\n    }\\n  }"
                    }
                ]
            },
            {
                "id": 2000883,
                "content": [
                    {
                        "username": "mlivingston",
                        "content": "why are these questions always worded in the worst english.... \"non-decreasing order\""
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "Why is this solution not working (it works in online compiler).\\n Test case:\\nnums1 = [1,2,3,0,0,0], m=3\\nnums2 = [2,5,6], n=3\\n`nums1.extend(nums2)\\nnums1.sort()\\nnums1 = [i for i in nums1 if i != 0]`\\n\\nIt shows output: [0,0,0,1,2,2,3,5,6]. \\nThe online compiler shows the expected output: [1,2,2,3,5,6]."
                    },
                    {
                        "username": "T_Lalith_kumar",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int temp[] = new int[m+n];\\n        for(int i=0;i<m+n;i++){\\n            if(i<m && nums1[i]!=0){\\n                temp[i]=nums1[i];\\n            }\\n            if((i==m || i>m) && nums2[i-m]!=0){\\n                temp[i]=nums2[i-m];\\n            }\\n        }\\n        System.out.println(Arrays.toString(Arrays.stream(temp).sorted().toArray()));\\n    }\\n}\\n\\n\\nwhy is this not working when I\\'m doing in IDE it is working fine"
                    },
                    {
                        "username": "singh-Rustam",
                        "content": "I misread this question and I think this is a common mistake most of us may repeat so read this carefully :\\n In the Question it says \"two integers m and n, representing the number of elements in nums1 and nums2 respectively.\"\\n\\nHere \"m\" represents no. of elements present in the nums1 array NOT the length of nums1 array that means if I declare an array of length \"5\" and do not assign value of any indexes, \"m\" will not be equal to \"5\" it will be equal to \"0\" since there\\'s no element in nums1.\\n\\nLater in the question, it stated that \"nums2 has a length of n\" . Means if we declare a nums2 array with length 5, \"n\" will be \"5\" regardless of the emptiness of the array.\\n\\nSo in the above mentioned case, the (m+n) will remain \"5\" which is equal to \"nums1.length\" as mentioned in the constraints, whereas the sum of lengths of both the arrays will be different.\\n\\nThe testcase: nums1 = {0,0,0,0,0} : m = 0; (nums1 is uninitialised)\\n                        nums2 = {1,2,3,4,5} : n =5;\\n\\nKeep this in your mind while building the logic. :)\\n\\n"
                    },
                    {
                        "username": "harishgokul",
                        "content": " int j=0;\n\n        if(m==0){\n            nums1=nums2;\n        }\n        else {\n            for (int i = m; i < m + n; i++) {\n                nums1[i] = nums2[j++];\n            }\n        }\n         Arrays.sort(nums1);\n\nexample 1,2 is correct but 3 output is 1 ,i run in my local editor works ,but in leetcode output is 0 \nif you know why reply,"
                    },
                    {
                        "username": "skyrood",
                        "content": "can you explain please how count([1,2,3,0,0,0]) can be 3?"
                    },
                    {
                        "username": "kankriyayash18",
                        "content": "Tell me the actual code You have written"
                    },
                    {
                        "username": "Davidjayan",
                        "content": "Modified array is showing result in console but not in output. Can anyone help?\n    nums1 = [...nums1.slice(0,m),...nums2.slice(0,n)].sort((a,b)=>a-b);\n    console.log(nums1) --->this one works but output showing wrong"
                    },
                    {
                        "username": "kankriyayash18",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        a=[]\\n        while m > 0 and n > 0:\\n            if nums1[m-1]>=nums2[n-1]:\\n                a.append(nums1[m-1])\\n                m -= 1\\n            else:\\n                a.append(nums2[n-1])\\n                n -= 1\\n        while m > 0:\\n            a.append(nums1[m - 1])\\n            m -= 1\\n        while n > 0:\\n            a.append(nums2[n - 1])\\n            n -= 1\\n        return a[::-1]\\n\\nwhy is this code wrong?"
                    },
                    {
                        "username": "Adhar_Sharma",
                        "content": "what is wrong with my question ?? Please help me...\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i=0 , j=0 , k=0;\\n        while(i<m && j<n){\\n            if(nums1[i]<=nums2[j]){\\n                nums1[k] = nums1[i];\\n                i++;\\n                k++;\\n            }\\n            else{\\n                nums1[k] = nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        while(i<m){\\n            nums1[k] = nums1[i];\\n                i++;\\n                k++;\\n        }\\n        while(j<n){\\n             nums1[k] = nums2[j];\\n                j++;\\n                k++;\\n        }\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "AhmedQasem4",
                        "content": "why this logic in javascript give me error in testCase 7 although it give me the expected result in vs code but in leetcode compiler it generate differ result??? \\n\\n if(m == 0)\\n        nums1 = nums2;\\n    \\n    else{\\n        for (let i = m; i < m + n; i++) {\\n        nums1[i] = nums2[i - n];\\n      }\\n    }\\n\\n  for (let i = 0; i < nums1.length; i++) {\\n    if (nums1[i] >= nums1[i + 1]) {\\n      let temp = nums1[i];\\n      nums1[i] = nums1[i + 1];\\n      nums1[i + 1] = temp;\\n    }\\n  }"
                    }
                ]
            },
            {
                "id": 2000775,
                "content": [
                    {
                        "username": "mlivingston",
                        "content": "why are these questions always worded in the worst english.... \"non-decreasing order\""
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "Why is this solution not working (it works in online compiler).\\n Test case:\\nnums1 = [1,2,3,0,0,0], m=3\\nnums2 = [2,5,6], n=3\\n`nums1.extend(nums2)\\nnums1.sort()\\nnums1 = [i for i in nums1 if i != 0]`\\n\\nIt shows output: [0,0,0,1,2,2,3,5,6]. \\nThe online compiler shows the expected output: [1,2,2,3,5,6]."
                    },
                    {
                        "username": "T_Lalith_kumar",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int temp[] = new int[m+n];\\n        for(int i=0;i<m+n;i++){\\n            if(i<m && nums1[i]!=0){\\n                temp[i]=nums1[i];\\n            }\\n            if((i==m || i>m) && nums2[i-m]!=0){\\n                temp[i]=nums2[i-m];\\n            }\\n        }\\n        System.out.println(Arrays.toString(Arrays.stream(temp).sorted().toArray()));\\n    }\\n}\\n\\n\\nwhy is this not working when I\\'m doing in IDE it is working fine"
                    },
                    {
                        "username": "singh-Rustam",
                        "content": "I misread this question and I think this is a common mistake most of us may repeat so read this carefully :\\n In the Question it says \"two integers m and n, representing the number of elements in nums1 and nums2 respectively.\"\\n\\nHere \"m\" represents no. of elements present in the nums1 array NOT the length of nums1 array that means if I declare an array of length \"5\" and do not assign value of any indexes, \"m\" will not be equal to \"5\" it will be equal to \"0\" since there\\'s no element in nums1.\\n\\nLater in the question, it stated that \"nums2 has a length of n\" . Means if we declare a nums2 array with length 5, \"n\" will be \"5\" regardless of the emptiness of the array.\\n\\nSo in the above mentioned case, the (m+n) will remain \"5\" which is equal to \"nums1.length\" as mentioned in the constraints, whereas the sum of lengths of both the arrays will be different.\\n\\nThe testcase: nums1 = {0,0,0,0,0} : m = 0; (nums1 is uninitialised)\\n                        nums2 = {1,2,3,4,5} : n =5;\\n\\nKeep this in your mind while building the logic. :)\\n\\n"
                    },
                    {
                        "username": "harishgokul",
                        "content": " int j=0;\n\n        if(m==0){\n            nums1=nums2;\n        }\n        else {\n            for (int i = m; i < m + n; i++) {\n                nums1[i] = nums2[j++];\n            }\n        }\n         Arrays.sort(nums1);\n\nexample 1,2 is correct but 3 output is 1 ,i run in my local editor works ,but in leetcode output is 0 \nif you know why reply,"
                    },
                    {
                        "username": "skyrood",
                        "content": "can you explain please how count([1,2,3,0,0,0]) can be 3?"
                    },
                    {
                        "username": "kankriyayash18",
                        "content": "Tell me the actual code You have written"
                    },
                    {
                        "username": "Davidjayan",
                        "content": "Modified array is showing result in console but not in output. Can anyone help?\n    nums1 = [...nums1.slice(0,m),...nums2.slice(0,n)].sort((a,b)=>a-b);\n    console.log(nums1) --->this one works but output showing wrong"
                    },
                    {
                        "username": "kankriyayash18",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        a=[]\\n        while m > 0 and n > 0:\\n            if nums1[m-1]>=nums2[n-1]:\\n                a.append(nums1[m-1])\\n                m -= 1\\n            else:\\n                a.append(nums2[n-1])\\n                n -= 1\\n        while m > 0:\\n            a.append(nums1[m - 1])\\n            m -= 1\\n        while n > 0:\\n            a.append(nums2[n - 1])\\n            n -= 1\\n        return a[::-1]\\n\\nwhy is this code wrong?"
                    },
                    {
                        "username": "Adhar_Sharma",
                        "content": "what is wrong with my question ?? Please help me...\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i=0 , j=0 , k=0;\\n        while(i<m && j<n){\\n            if(nums1[i]<=nums2[j]){\\n                nums1[k] = nums1[i];\\n                i++;\\n                k++;\\n            }\\n            else{\\n                nums1[k] = nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        while(i<m){\\n            nums1[k] = nums1[i];\\n                i++;\\n                k++;\\n        }\\n        while(j<n){\\n             nums1[k] = nums2[j];\\n                j++;\\n                k++;\\n        }\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "AhmedQasem4",
                        "content": "why this logic in javascript give me error in testCase 7 although it give me the expected result in vs code but in leetcode compiler it generate differ result??? \\n\\n if(m == 0)\\n        nums1 = nums2;\\n    \\n    else{\\n        for (let i = m; i < m + n; i++) {\\n        nums1[i] = nums2[i - n];\\n      }\\n    }\\n\\n  for (let i = 0; i < nums1.length; i++) {\\n    if (nums1[i] >= nums1[i + 1]) {\\n      let temp = nums1[i];\\n      nums1[i] = nums1[i + 1];\\n      nums1[i + 1] = temp;\\n    }\\n  }"
                    }
                ]
            },
            {
                "id": 1999979,
                "content": [
                    {
                        "username": "mlivingston",
                        "content": "why are these questions always worded in the worst english.... \"non-decreasing order\""
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "Why is this solution not working (it works in online compiler).\\n Test case:\\nnums1 = [1,2,3,0,0,0], m=3\\nnums2 = [2,5,6], n=3\\n`nums1.extend(nums2)\\nnums1.sort()\\nnums1 = [i for i in nums1 if i != 0]`\\n\\nIt shows output: [0,0,0,1,2,2,3,5,6]. \\nThe online compiler shows the expected output: [1,2,2,3,5,6]."
                    },
                    {
                        "username": "T_Lalith_kumar",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int temp[] = new int[m+n];\\n        for(int i=0;i<m+n;i++){\\n            if(i<m && nums1[i]!=0){\\n                temp[i]=nums1[i];\\n            }\\n            if((i==m || i>m) && nums2[i-m]!=0){\\n                temp[i]=nums2[i-m];\\n            }\\n        }\\n        System.out.println(Arrays.toString(Arrays.stream(temp).sorted().toArray()));\\n    }\\n}\\n\\n\\nwhy is this not working when I\\'m doing in IDE it is working fine"
                    },
                    {
                        "username": "singh-Rustam",
                        "content": "I misread this question and I think this is a common mistake most of us may repeat so read this carefully :\\n In the Question it says \"two integers m and n, representing the number of elements in nums1 and nums2 respectively.\"\\n\\nHere \"m\" represents no. of elements present in the nums1 array NOT the length of nums1 array that means if I declare an array of length \"5\" and do not assign value of any indexes, \"m\" will not be equal to \"5\" it will be equal to \"0\" since there\\'s no element in nums1.\\n\\nLater in the question, it stated that \"nums2 has a length of n\" . Means if we declare a nums2 array with length 5, \"n\" will be \"5\" regardless of the emptiness of the array.\\n\\nSo in the above mentioned case, the (m+n) will remain \"5\" which is equal to \"nums1.length\" as mentioned in the constraints, whereas the sum of lengths of both the arrays will be different.\\n\\nThe testcase: nums1 = {0,0,0,0,0} : m = 0; (nums1 is uninitialised)\\n                        nums2 = {1,2,3,4,5} : n =5;\\n\\nKeep this in your mind while building the logic. :)\\n\\n"
                    },
                    {
                        "username": "harishgokul",
                        "content": " int j=0;\n\n        if(m==0){\n            nums1=nums2;\n        }\n        else {\n            for (int i = m; i < m + n; i++) {\n                nums1[i] = nums2[j++];\n            }\n        }\n         Arrays.sort(nums1);\n\nexample 1,2 is correct but 3 output is 1 ,i run in my local editor works ,but in leetcode output is 0 \nif you know why reply,"
                    },
                    {
                        "username": "skyrood",
                        "content": "can you explain please how count([1,2,3,0,0,0]) can be 3?"
                    },
                    {
                        "username": "kankriyayash18",
                        "content": "Tell me the actual code You have written"
                    },
                    {
                        "username": "Davidjayan",
                        "content": "Modified array is showing result in console but not in output. Can anyone help?\n    nums1 = [...nums1.slice(0,m),...nums2.slice(0,n)].sort((a,b)=>a-b);\n    console.log(nums1) --->this one works but output showing wrong"
                    },
                    {
                        "username": "kankriyayash18",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        a=[]\\n        while m > 0 and n > 0:\\n            if nums1[m-1]>=nums2[n-1]:\\n                a.append(nums1[m-1])\\n                m -= 1\\n            else:\\n                a.append(nums2[n-1])\\n                n -= 1\\n        while m > 0:\\n            a.append(nums1[m - 1])\\n            m -= 1\\n        while n > 0:\\n            a.append(nums2[n - 1])\\n            n -= 1\\n        return a[::-1]\\n\\nwhy is this code wrong?"
                    },
                    {
                        "username": "Adhar_Sharma",
                        "content": "what is wrong with my question ?? Please help me...\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i=0 , j=0 , k=0;\\n        while(i<m && j<n){\\n            if(nums1[i]<=nums2[j]){\\n                nums1[k] = nums1[i];\\n                i++;\\n                k++;\\n            }\\n            else{\\n                nums1[k] = nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        while(i<m){\\n            nums1[k] = nums1[i];\\n                i++;\\n                k++;\\n        }\\n        while(j<n){\\n             nums1[k] = nums2[j];\\n                j++;\\n                k++;\\n        }\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "AhmedQasem4",
                        "content": "why this logic in javascript give me error in testCase 7 although it give me the expected result in vs code but in leetcode compiler it generate differ result??? \\n\\n if(m == 0)\\n        nums1 = nums2;\\n    \\n    else{\\n        for (let i = m; i < m + n; i++) {\\n        nums1[i] = nums2[i - n];\\n      }\\n    }\\n\\n  for (let i = 0; i < nums1.length; i++) {\\n    if (nums1[i] >= nums1[i + 1]) {\\n      let temp = nums1[i];\\n      nums1[i] = nums1[i + 1];\\n      nums1[i + 1] = temp;\\n    }\\n  }"
                    }
                ]
            },
            {
                "id": 1998437,
                "content": [
                    {
                        "username": "mlivingston",
                        "content": "why are these questions always worded in the worst english.... \"non-decreasing order\""
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "Why is this solution not working (it works in online compiler).\\n Test case:\\nnums1 = [1,2,3,0,0,0], m=3\\nnums2 = [2,5,6], n=3\\n`nums1.extend(nums2)\\nnums1.sort()\\nnums1 = [i for i in nums1 if i != 0]`\\n\\nIt shows output: [0,0,0,1,2,2,3,5,6]. \\nThe online compiler shows the expected output: [1,2,2,3,5,6]."
                    },
                    {
                        "username": "T_Lalith_kumar",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int temp[] = new int[m+n];\\n        for(int i=0;i<m+n;i++){\\n            if(i<m && nums1[i]!=0){\\n                temp[i]=nums1[i];\\n            }\\n            if((i==m || i>m) && nums2[i-m]!=0){\\n                temp[i]=nums2[i-m];\\n            }\\n        }\\n        System.out.println(Arrays.toString(Arrays.stream(temp).sorted().toArray()));\\n    }\\n}\\n\\n\\nwhy is this not working when I\\'m doing in IDE it is working fine"
                    },
                    {
                        "username": "singh-Rustam",
                        "content": "I misread this question and I think this is a common mistake most of us may repeat so read this carefully :\\n In the Question it says \"two integers m and n, representing the number of elements in nums1 and nums2 respectively.\"\\n\\nHere \"m\" represents no. of elements present in the nums1 array NOT the length of nums1 array that means if I declare an array of length \"5\" and do not assign value of any indexes, \"m\" will not be equal to \"5\" it will be equal to \"0\" since there\\'s no element in nums1.\\n\\nLater in the question, it stated that \"nums2 has a length of n\" . Means if we declare a nums2 array with length 5, \"n\" will be \"5\" regardless of the emptiness of the array.\\n\\nSo in the above mentioned case, the (m+n) will remain \"5\" which is equal to \"nums1.length\" as mentioned in the constraints, whereas the sum of lengths of both the arrays will be different.\\n\\nThe testcase: nums1 = {0,0,0,0,0} : m = 0; (nums1 is uninitialised)\\n                        nums2 = {1,2,3,4,5} : n =5;\\n\\nKeep this in your mind while building the logic. :)\\n\\n"
                    },
                    {
                        "username": "harishgokul",
                        "content": " int j=0;\n\n        if(m==0){\n            nums1=nums2;\n        }\n        else {\n            for (int i = m; i < m + n; i++) {\n                nums1[i] = nums2[j++];\n            }\n        }\n         Arrays.sort(nums1);\n\nexample 1,2 is correct but 3 output is 1 ,i run in my local editor works ,but in leetcode output is 0 \nif you know why reply,"
                    },
                    {
                        "username": "skyrood",
                        "content": "can you explain please how count([1,2,3,0,0,0]) can be 3?"
                    },
                    {
                        "username": "kankriyayash18",
                        "content": "Tell me the actual code You have written"
                    },
                    {
                        "username": "Davidjayan",
                        "content": "Modified array is showing result in console but not in output. Can anyone help?\n    nums1 = [...nums1.slice(0,m),...nums2.slice(0,n)].sort((a,b)=>a-b);\n    console.log(nums1) --->this one works but output showing wrong"
                    },
                    {
                        "username": "kankriyayash18",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        a=[]\\n        while m > 0 and n > 0:\\n            if nums1[m-1]>=nums2[n-1]:\\n                a.append(nums1[m-1])\\n                m -= 1\\n            else:\\n                a.append(nums2[n-1])\\n                n -= 1\\n        while m > 0:\\n            a.append(nums1[m - 1])\\n            m -= 1\\n        while n > 0:\\n            a.append(nums2[n - 1])\\n            n -= 1\\n        return a[::-1]\\n\\nwhy is this code wrong?"
                    },
                    {
                        "username": "Adhar_Sharma",
                        "content": "what is wrong with my question ?? Please help me...\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i=0 , j=0 , k=0;\\n        while(i<m && j<n){\\n            if(nums1[i]<=nums2[j]){\\n                nums1[k] = nums1[i];\\n                i++;\\n                k++;\\n            }\\n            else{\\n                nums1[k] = nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        while(i<m){\\n            nums1[k] = nums1[i];\\n                i++;\\n                k++;\\n        }\\n        while(j<n){\\n             nums1[k] = nums2[j];\\n                j++;\\n                k++;\\n        }\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "AhmedQasem4",
                        "content": "why this logic in javascript give me error in testCase 7 although it give me the expected result in vs code but in leetcode compiler it generate differ result??? \\n\\n if(m == 0)\\n        nums1 = nums2;\\n    \\n    else{\\n        for (let i = m; i < m + n; i++) {\\n        nums1[i] = nums2[i - n];\\n      }\\n    }\\n\\n  for (let i = 0; i < nums1.length; i++) {\\n    if (nums1[i] >= nums1[i + 1]) {\\n      let temp = nums1[i];\\n      nums1[i] = nums1[i + 1];\\n      nums1[i + 1] = temp;\\n    }\\n  }"
                    }
                ]
            },
            {
                "id": 1997579,
                "content": [
                    {
                        "username": "HarshitBansal122",
                        "content": "seems to be a error  while solving with python or python3 , my code is working well on other IDE\\'s\\nnums1=nums1[0:m]\\nnums1+=nums2[0:n]\\nnums1.sort()\\n        \\n"
                    },
                    {
                        "username": "yuriy25",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n      \\n      int count = 0, max = 0, inx = 0;\\n      int[] arrayMarraged = new int[m+n];\\n      \\n      if (m < n) max = n;\\n      else max = m;\\n\\n      while (count < max ){\\n        if(count < m)\\n          arrayMarraged[inx++] = nums1[count];\\n\\n        if(count < n) \\n          arrayMarraged[inx++] = nums2[count];\\n \\n        count++;\\n      }\\n       Arrays.sort(arrayMarraged);\\n      //nums1 = Arrays.copyOf(arrayMarraged, arrayMarraged.length); <- not correct because nums1 there is the new array object (doesn\\'t mutate )\\n\\n      for  (int i = 0; i < arrayMarraged.length; i++){\\n        nums1[i] = arrayMarraged[i];\\n      }\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yuriy25",
                        "content": "    public void merge(int[] nums1, int m, int[] nums2, int n) {\n      \n      int count = 0, max = 0, inx = 0;\n      int[] arrayMarraged = new int[m+n];\n      \n      if (m < n) max = n;\n      else max = m;\n\n      while (count < max ){\n        if(count < m)\n          arrayMarraged[inx++] = nums1[count];\n\n        if(count < n) \n          arrayMarraged[inx++] = nums2[count];\n \n        count++;\n      }\n       Arrays.sort(arrayMarraged);\n      nums1 = Arrays.copyOf(arrayMarraged, arrayMarraged.length);\n/*\n     for(int num : nums1){\nSystem.out.print(num + \" \"); result is 1 2 2 3 5 6\n}\n*/\n    }\n\nresult 1,2,2,3,5,6 but the leetcode reflects 1,2,3,0,0,0\nI print nums1 in the last line "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arodmcmxcix",
                        "content": "So when I do my STDOUT by printing nums1 it contains \\n[1, 2, 3, 0, 0, 0] original\\n[1, 2, 3] trim n\\'s\\n[1, 2, 3, 2, 5, 6] merge\\n[1, 2, 2, 3, 5, 6] final value of nums1\\nHowever the output says [1,2,3,0,0,0] any ideas? "
                    },
                    {
                        "username": "manishmicheal7",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    nums1.slice(0, m).concat(nums2.slice(0, n)).sort((a,b) => a - b);\\n};\\n\\ncan i know what did i do wrong here?"
                    },
                    {
                        "username": "Jashan_01",
                        "content": "When I run the below code, it gives a runtime error: addition of unsigned offset . Can somebody explain why this is happening .\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n    while(i<n){\\n        int j=m-1;\\n        if(nums1[j]>nums2[i]){\\n            \\n            while(j>=0 && nums2[i]<nums1[j] ){\\n                nums1[j+1]=nums1[j];\\n                j--;\\n            }\\n            nums1[j+1]=nums2[i];\\n            \\n        }\\n        else{\\n            nums1[j+1]=nums2[i];\\n        }\\n        i++;\\n        m++;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "na88git",
                        "content": "Why does my solution result in a Runtime Error. I compile the code in visual studio editor and it works\n\n`#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n\n        while (n)\n        {\n            if (nums2[n - 1] >= nums1[m - 1])\n            {\n                nums1[m + n - 1] = nums2[n - 1];\n                n--;\n            } \n            else \n            {\n                nums1[m + n - 1] = nums1[m - 1];\n                m--;\n            }\n        }\n        \n    }\n};\n\nint main()\n{\n    Solution so;\n\n    // Sol1\n    vector<int> nums1{1,2,3,5,0,0,0,0};\n    int m = 4;\n    vector<int> nums2{2,5,6,8};\n    int n = 4;\n\n    // Sol2\n    vector<int> nums11{1};\n    int m1 = 1;\n    vector<int> nums12{};\n    int n1 = 0;\n\n    // Sol3\n    vector<int> nums21{0};\n    int m2 = 0;\n    vector<int> nums22{1};\n    int n2 = 1;\n\n    so.merge(nums1, m, nums2, n);\n    so.merge(nums11, m1, nums12, n1);\n    so.merge(nums21, m2, nums22, n2);\n\n    cout << \"Sol1\" << endl;\n    for (int value : nums1)\n        cout << value << endl;\n        \n    cout << \"Sol2\" << endl;\n    for (int value : nums11)\n        cout << value << endl;\n\n    cout << \"Sol3\" << endl;\n    for (int value : nums21)\n        cout << value << endl;\n}`\n\n\n"
                    },
                    {
                        "username": "ajinkyabhalerao",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = 0, j = 0;\\n\\n        while(i+j < m+n) {\\n            if(nums1[i] <= nums2[j]) {\\n                i++;\\n            }\\n            else {\\n                nums1.insert(nums1.begin() + 1, nums2[j]);\\n                j++;\\n            }\\n        }\\n    }\\n};\\n\\nWhy does this throw an error? Someone please explain\\nruntime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)"
                    },
                    {
                        "username": "colinwinslow",
                        "content": "why can i index nums1 but not nums2? \\n\\nprint(nums2[0]) should print \\'2\\' but instead gives an IndexError... why?"
                    },
                    {
                        "username": "Bespalow",
                        "content": "\\u042F \\u0441\\u043E\\u0437\\u0434\\u0430\\u043B 2 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0430, \\u0432\\u044B\\u0432\\u0435\\u043B \\u0432 \\u043D\\u0438\\u0445 \\u043D\\u0443\\u0436\\u043D\\u044B\\u0435 \\u0447\\u0438\\u0441\\u043B\\u0430 \\u0438\\u0437 nums, nums2, \\u043E\\u0431\\u044C\\u0435\\u0434\\u0435\\u043D\\u0438\\u043B \\u0438\\u0445 \\u0438 \\u043E\\u0442\\u0441\\u043E\\u0440\\u0442\\u0438\\u0440\\u043E\\u0432\\u0430\\u043B \\u043E\\u043A\\u043E\\u043D\\u0447\\u0430\\u0442\\u0435\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432. \\u0413\\u0434\\u0435 \\u043E\\u0448\\u0438\\u0431\\u043A\\u0430?(c#)\\n\\n        int[] newArray = new int[nums1.Length];\\n\\n        int[] newArray2 = new int[nums2.Length];\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            newArray[i] = nums1[i];\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            newArray2[i] = nums2[i];\\n        }\\n\\n        int[] result = newArray.Concat(newArray2).ToArray();\\n\\n        int temp;\\n\\n        for (int i = 0; i < result.Length - 1; i++)\\n        {\\n            for (int j = i + 1; j < result.Length; j++)\\n            {\\n                if (result[i] > result[j])\\n                {\\n                    temp = result[i];\\n                    result[i] = result[j];\\n                    result[j] = temp;\\n                }\\n            }"
                    }
                ]
            },
            {
                "id": 1995052,
                "content": [
                    {
                        "username": "HarshitBansal122",
                        "content": "seems to be a error  while solving with python or python3 , my code is working well on other IDE\\'s\\nnums1=nums1[0:m]\\nnums1+=nums2[0:n]\\nnums1.sort()\\n        \\n"
                    },
                    {
                        "username": "yuriy25",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n      \\n      int count = 0, max = 0, inx = 0;\\n      int[] arrayMarraged = new int[m+n];\\n      \\n      if (m < n) max = n;\\n      else max = m;\\n\\n      while (count < max ){\\n        if(count < m)\\n          arrayMarraged[inx++] = nums1[count];\\n\\n        if(count < n) \\n          arrayMarraged[inx++] = nums2[count];\\n \\n        count++;\\n      }\\n       Arrays.sort(arrayMarraged);\\n      //nums1 = Arrays.copyOf(arrayMarraged, arrayMarraged.length); <- not correct because nums1 there is the new array object (doesn\\'t mutate )\\n\\n      for  (int i = 0; i < arrayMarraged.length; i++){\\n        nums1[i] = arrayMarraged[i];\\n      }\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yuriy25",
                        "content": "    public void merge(int[] nums1, int m, int[] nums2, int n) {\n      \n      int count = 0, max = 0, inx = 0;\n      int[] arrayMarraged = new int[m+n];\n      \n      if (m < n) max = n;\n      else max = m;\n\n      while (count < max ){\n        if(count < m)\n          arrayMarraged[inx++] = nums1[count];\n\n        if(count < n) \n          arrayMarraged[inx++] = nums2[count];\n \n        count++;\n      }\n       Arrays.sort(arrayMarraged);\n      nums1 = Arrays.copyOf(arrayMarraged, arrayMarraged.length);\n/*\n     for(int num : nums1){\nSystem.out.print(num + \" \"); result is 1 2 2 3 5 6\n}\n*/\n    }\n\nresult 1,2,2,3,5,6 but the leetcode reflects 1,2,3,0,0,0\nI print nums1 in the last line "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arodmcmxcix",
                        "content": "So when I do my STDOUT by printing nums1 it contains \\n[1, 2, 3, 0, 0, 0] original\\n[1, 2, 3] trim n\\'s\\n[1, 2, 3, 2, 5, 6] merge\\n[1, 2, 2, 3, 5, 6] final value of nums1\\nHowever the output says [1,2,3,0,0,0] any ideas? "
                    },
                    {
                        "username": "manishmicheal7",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    nums1.slice(0, m).concat(nums2.slice(0, n)).sort((a,b) => a - b);\\n};\\n\\ncan i know what did i do wrong here?"
                    },
                    {
                        "username": "Jashan_01",
                        "content": "When I run the below code, it gives a runtime error: addition of unsigned offset . Can somebody explain why this is happening .\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n    while(i<n){\\n        int j=m-1;\\n        if(nums1[j]>nums2[i]){\\n            \\n            while(j>=0 && nums2[i]<nums1[j] ){\\n                nums1[j+1]=nums1[j];\\n                j--;\\n            }\\n            nums1[j+1]=nums2[i];\\n            \\n        }\\n        else{\\n            nums1[j+1]=nums2[i];\\n        }\\n        i++;\\n        m++;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "na88git",
                        "content": "Why does my solution result in a Runtime Error. I compile the code in visual studio editor and it works\n\n`#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n\n        while (n)\n        {\n            if (nums2[n - 1] >= nums1[m - 1])\n            {\n                nums1[m + n - 1] = nums2[n - 1];\n                n--;\n            } \n            else \n            {\n                nums1[m + n - 1] = nums1[m - 1];\n                m--;\n            }\n        }\n        \n    }\n};\n\nint main()\n{\n    Solution so;\n\n    // Sol1\n    vector<int> nums1{1,2,3,5,0,0,0,0};\n    int m = 4;\n    vector<int> nums2{2,5,6,8};\n    int n = 4;\n\n    // Sol2\n    vector<int> nums11{1};\n    int m1 = 1;\n    vector<int> nums12{};\n    int n1 = 0;\n\n    // Sol3\n    vector<int> nums21{0};\n    int m2 = 0;\n    vector<int> nums22{1};\n    int n2 = 1;\n\n    so.merge(nums1, m, nums2, n);\n    so.merge(nums11, m1, nums12, n1);\n    so.merge(nums21, m2, nums22, n2);\n\n    cout << \"Sol1\" << endl;\n    for (int value : nums1)\n        cout << value << endl;\n        \n    cout << \"Sol2\" << endl;\n    for (int value : nums11)\n        cout << value << endl;\n\n    cout << \"Sol3\" << endl;\n    for (int value : nums21)\n        cout << value << endl;\n}`\n\n\n"
                    },
                    {
                        "username": "ajinkyabhalerao",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = 0, j = 0;\\n\\n        while(i+j < m+n) {\\n            if(nums1[i] <= nums2[j]) {\\n                i++;\\n            }\\n            else {\\n                nums1.insert(nums1.begin() + 1, nums2[j]);\\n                j++;\\n            }\\n        }\\n    }\\n};\\n\\nWhy does this throw an error? Someone please explain\\nruntime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)"
                    },
                    {
                        "username": "colinwinslow",
                        "content": "why can i index nums1 but not nums2? \\n\\nprint(nums2[0]) should print \\'2\\' but instead gives an IndexError... why?"
                    },
                    {
                        "username": "Bespalow",
                        "content": "\\u042F \\u0441\\u043E\\u0437\\u0434\\u0430\\u043B 2 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0430, \\u0432\\u044B\\u0432\\u0435\\u043B \\u0432 \\u043D\\u0438\\u0445 \\u043D\\u0443\\u0436\\u043D\\u044B\\u0435 \\u0447\\u0438\\u0441\\u043B\\u0430 \\u0438\\u0437 nums, nums2, \\u043E\\u0431\\u044C\\u0435\\u0434\\u0435\\u043D\\u0438\\u043B \\u0438\\u0445 \\u0438 \\u043E\\u0442\\u0441\\u043E\\u0440\\u0442\\u0438\\u0440\\u043E\\u0432\\u0430\\u043B \\u043E\\u043A\\u043E\\u043D\\u0447\\u0430\\u0442\\u0435\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432. \\u0413\\u0434\\u0435 \\u043E\\u0448\\u0438\\u0431\\u043A\\u0430?(c#)\\n\\n        int[] newArray = new int[nums1.Length];\\n\\n        int[] newArray2 = new int[nums2.Length];\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            newArray[i] = nums1[i];\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            newArray2[i] = nums2[i];\\n        }\\n\\n        int[] result = newArray.Concat(newArray2).ToArray();\\n\\n        int temp;\\n\\n        for (int i = 0; i < result.Length - 1; i++)\\n        {\\n            for (int j = i + 1; j < result.Length; j++)\\n            {\\n                if (result[i] > result[j])\\n                {\\n                    temp = result[i];\\n                    result[i] = result[j];\\n                    result[j] = temp;\\n                }\\n            }"
                    }
                ]
            },
            {
                "id": 1995047,
                "content": [
                    {
                        "username": "HarshitBansal122",
                        "content": "seems to be a error  while solving with python or python3 , my code is working well on other IDE\\'s\\nnums1=nums1[0:m]\\nnums1+=nums2[0:n]\\nnums1.sort()\\n        \\n"
                    },
                    {
                        "username": "yuriy25",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n      \\n      int count = 0, max = 0, inx = 0;\\n      int[] arrayMarraged = new int[m+n];\\n      \\n      if (m < n) max = n;\\n      else max = m;\\n\\n      while (count < max ){\\n        if(count < m)\\n          arrayMarraged[inx++] = nums1[count];\\n\\n        if(count < n) \\n          arrayMarraged[inx++] = nums2[count];\\n \\n        count++;\\n      }\\n       Arrays.sort(arrayMarraged);\\n      //nums1 = Arrays.copyOf(arrayMarraged, arrayMarraged.length); <- not correct because nums1 there is the new array object (doesn\\'t mutate )\\n\\n      for  (int i = 0; i < arrayMarraged.length; i++){\\n        nums1[i] = arrayMarraged[i];\\n      }\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yuriy25",
                        "content": "    public void merge(int[] nums1, int m, int[] nums2, int n) {\n      \n      int count = 0, max = 0, inx = 0;\n      int[] arrayMarraged = new int[m+n];\n      \n      if (m < n) max = n;\n      else max = m;\n\n      while (count < max ){\n        if(count < m)\n          arrayMarraged[inx++] = nums1[count];\n\n        if(count < n) \n          arrayMarraged[inx++] = nums2[count];\n \n        count++;\n      }\n       Arrays.sort(arrayMarraged);\n      nums1 = Arrays.copyOf(arrayMarraged, arrayMarraged.length);\n/*\n     for(int num : nums1){\nSystem.out.print(num + \" \"); result is 1 2 2 3 5 6\n}\n*/\n    }\n\nresult 1,2,2,3,5,6 but the leetcode reflects 1,2,3,0,0,0\nI print nums1 in the last line "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arodmcmxcix",
                        "content": "So when I do my STDOUT by printing nums1 it contains \\n[1, 2, 3, 0, 0, 0] original\\n[1, 2, 3] trim n\\'s\\n[1, 2, 3, 2, 5, 6] merge\\n[1, 2, 2, 3, 5, 6] final value of nums1\\nHowever the output says [1,2,3,0,0,0] any ideas? "
                    },
                    {
                        "username": "manishmicheal7",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    nums1.slice(0, m).concat(nums2.slice(0, n)).sort((a,b) => a - b);\\n};\\n\\ncan i know what did i do wrong here?"
                    },
                    {
                        "username": "Jashan_01",
                        "content": "When I run the below code, it gives a runtime error: addition of unsigned offset . Can somebody explain why this is happening .\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n    while(i<n){\\n        int j=m-1;\\n        if(nums1[j]>nums2[i]){\\n            \\n            while(j>=0 && nums2[i]<nums1[j] ){\\n                nums1[j+1]=nums1[j];\\n                j--;\\n            }\\n            nums1[j+1]=nums2[i];\\n            \\n        }\\n        else{\\n            nums1[j+1]=nums2[i];\\n        }\\n        i++;\\n        m++;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "na88git",
                        "content": "Why does my solution result in a Runtime Error. I compile the code in visual studio editor and it works\n\n`#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n\n        while (n)\n        {\n            if (nums2[n - 1] >= nums1[m - 1])\n            {\n                nums1[m + n - 1] = nums2[n - 1];\n                n--;\n            } \n            else \n            {\n                nums1[m + n - 1] = nums1[m - 1];\n                m--;\n            }\n        }\n        \n    }\n};\n\nint main()\n{\n    Solution so;\n\n    // Sol1\n    vector<int> nums1{1,2,3,5,0,0,0,0};\n    int m = 4;\n    vector<int> nums2{2,5,6,8};\n    int n = 4;\n\n    // Sol2\n    vector<int> nums11{1};\n    int m1 = 1;\n    vector<int> nums12{};\n    int n1 = 0;\n\n    // Sol3\n    vector<int> nums21{0};\n    int m2 = 0;\n    vector<int> nums22{1};\n    int n2 = 1;\n\n    so.merge(nums1, m, nums2, n);\n    so.merge(nums11, m1, nums12, n1);\n    so.merge(nums21, m2, nums22, n2);\n\n    cout << \"Sol1\" << endl;\n    for (int value : nums1)\n        cout << value << endl;\n        \n    cout << \"Sol2\" << endl;\n    for (int value : nums11)\n        cout << value << endl;\n\n    cout << \"Sol3\" << endl;\n    for (int value : nums21)\n        cout << value << endl;\n}`\n\n\n"
                    },
                    {
                        "username": "ajinkyabhalerao",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = 0, j = 0;\\n\\n        while(i+j < m+n) {\\n            if(nums1[i] <= nums2[j]) {\\n                i++;\\n            }\\n            else {\\n                nums1.insert(nums1.begin() + 1, nums2[j]);\\n                j++;\\n            }\\n        }\\n    }\\n};\\n\\nWhy does this throw an error? Someone please explain\\nruntime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)"
                    },
                    {
                        "username": "colinwinslow",
                        "content": "why can i index nums1 but not nums2? \\n\\nprint(nums2[0]) should print \\'2\\' but instead gives an IndexError... why?"
                    },
                    {
                        "username": "Bespalow",
                        "content": "\\u042F \\u0441\\u043E\\u0437\\u0434\\u0430\\u043B 2 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0430, \\u0432\\u044B\\u0432\\u0435\\u043B \\u0432 \\u043D\\u0438\\u0445 \\u043D\\u0443\\u0436\\u043D\\u044B\\u0435 \\u0447\\u0438\\u0441\\u043B\\u0430 \\u0438\\u0437 nums, nums2, \\u043E\\u0431\\u044C\\u0435\\u0434\\u0435\\u043D\\u0438\\u043B \\u0438\\u0445 \\u0438 \\u043E\\u0442\\u0441\\u043E\\u0440\\u0442\\u0438\\u0440\\u043E\\u0432\\u0430\\u043B \\u043E\\u043A\\u043E\\u043D\\u0447\\u0430\\u0442\\u0435\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432. \\u0413\\u0434\\u0435 \\u043E\\u0448\\u0438\\u0431\\u043A\\u0430?(c#)\\n\\n        int[] newArray = new int[nums1.Length];\\n\\n        int[] newArray2 = new int[nums2.Length];\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            newArray[i] = nums1[i];\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            newArray2[i] = nums2[i];\\n        }\\n\\n        int[] result = newArray.Concat(newArray2).ToArray();\\n\\n        int temp;\\n\\n        for (int i = 0; i < result.Length - 1; i++)\\n        {\\n            for (int j = i + 1; j < result.Length; j++)\\n            {\\n                if (result[i] > result[j])\\n                {\\n                    temp = result[i];\\n                    result[i] = result[j];\\n                    result[j] = temp;\\n                }\\n            }"
                    }
                ]
            },
            {
                "id": 1994713,
                "content": [
                    {
                        "username": "HarshitBansal122",
                        "content": "seems to be a error  while solving with python or python3 , my code is working well on other IDE\\'s\\nnums1=nums1[0:m]\\nnums1+=nums2[0:n]\\nnums1.sort()\\n        \\n"
                    },
                    {
                        "username": "yuriy25",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n      \\n      int count = 0, max = 0, inx = 0;\\n      int[] arrayMarraged = new int[m+n];\\n      \\n      if (m < n) max = n;\\n      else max = m;\\n\\n      while (count < max ){\\n        if(count < m)\\n          arrayMarraged[inx++] = nums1[count];\\n\\n        if(count < n) \\n          arrayMarraged[inx++] = nums2[count];\\n \\n        count++;\\n      }\\n       Arrays.sort(arrayMarraged);\\n      //nums1 = Arrays.copyOf(arrayMarraged, arrayMarraged.length); <- not correct because nums1 there is the new array object (doesn\\'t mutate )\\n\\n      for  (int i = 0; i < arrayMarraged.length; i++){\\n        nums1[i] = arrayMarraged[i];\\n      }\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yuriy25",
                        "content": "    public void merge(int[] nums1, int m, int[] nums2, int n) {\n      \n      int count = 0, max = 0, inx = 0;\n      int[] arrayMarraged = new int[m+n];\n      \n      if (m < n) max = n;\n      else max = m;\n\n      while (count < max ){\n        if(count < m)\n          arrayMarraged[inx++] = nums1[count];\n\n        if(count < n) \n          arrayMarraged[inx++] = nums2[count];\n \n        count++;\n      }\n       Arrays.sort(arrayMarraged);\n      nums1 = Arrays.copyOf(arrayMarraged, arrayMarraged.length);\n/*\n     for(int num : nums1){\nSystem.out.print(num + \" \"); result is 1 2 2 3 5 6\n}\n*/\n    }\n\nresult 1,2,2,3,5,6 but the leetcode reflects 1,2,3,0,0,0\nI print nums1 in the last line "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arodmcmxcix",
                        "content": "So when I do my STDOUT by printing nums1 it contains \\n[1, 2, 3, 0, 0, 0] original\\n[1, 2, 3] trim n\\'s\\n[1, 2, 3, 2, 5, 6] merge\\n[1, 2, 2, 3, 5, 6] final value of nums1\\nHowever the output says [1,2,3,0,0,0] any ideas? "
                    },
                    {
                        "username": "manishmicheal7",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    nums1.slice(0, m).concat(nums2.slice(0, n)).sort((a,b) => a - b);\\n};\\n\\ncan i know what did i do wrong here?"
                    },
                    {
                        "username": "Jashan_01",
                        "content": "When I run the below code, it gives a runtime error: addition of unsigned offset . Can somebody explain why this is happening .\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n    while(i<n){\\n        int j=m-1;\\n        if(nums1[j]>nums2[i]){\\n            \\n            while(j>=0 && nums2[i]<nums1[j] ){\\n                nums1[j+1]=nums1[j];\\n                j--;\\n            }\\n            nums1[j+1]=nums2[i];\\n            \\n        }\\n        else{\\n            nums1[j+1]=nums2[i];\\n        }\\n        i++;\\n        m++;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "na88git",
                        "content": "Why does my solution result in a Runtime Error. I compile the code in visual studio editor and it works\n\n`#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n\n        while (n)\n        {\n            if (nums2[n - 1] >= nums1[m - 1])\n            {\n                nums1[m + n - 1] = nums2[n - 1];\n                n--;\n            } \n            else \n            {\n                nums1[m + n - 1] = nums1[m - 1];\n                m--;\n            }\n        }\n        \n    }\n};\n\nint main()\n{\n    Solution so;\n\n    // Sol1\n    vector<int> nums1{1,2,3,5,0,0,0,0};\n    int m = 4;\n    vector<int> nums2{2,5,6,8};\n    int n = 4;\n\n    // Sol2\n    vector<int> nums11{1};\n    int m1 = 1;\n    vector<int> nums12{};\n    int n1 = 0;\n\n    // Sol3\n    vector<int> nums21{0};\n    int m2 = 0;\n    vector<int> nums22{1};\n    int n2 = 1;\n\n    so.merge(nums1, m, nums2, n);\n    so.merge(nums11, m1, nums12, n1);\n    so.merge(nums21, m2, nums22, n2);\n\n    cout << \"Sol1\" << endl;\n    for (int value : nums1)\n        cout << value << endl;\n        \n    cout << \"Sol2\" << endl;\n    for (int value : nums11)\n        cout << value << endl;\n\n    cout << \"Sol3\" << endl;\n    for (int value : nums21)\n        cout << value << endl;\n}`\n\n\n"
                    },
                    {
                        "username": "ajinkyabhalerao",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = 0, j = 0;\\n\\n        while(i+j < m+n) {\\n            if(nums1[i] <= nums2[j]) {\\n                i++;\\n            }\\n            else {\\n                nums1.insert(nums1.begin() + 1, nums2[j]);\\n                j++;\\n            }\\n        }\\n    }\\n};\\n\\nWhy does this throw an error? Someone please explain\\nruntime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)"
                    },
                    {
                        "username": "colinwinslow",
                        "content": "why can i index nums1 but not nums2? \\n\\nprint(nums2[0]) should print \\'2\\' but instead gives an IndexError... why?"
                    },
                    {
                        "username": "Bespalow",
                        "content": "\\u042F \\u0441\\u043E\\u0437\\u0434\\u0430\\u043B 2 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0430, \\u0432\\u044B\\u0432\\u0435\\u043B \\u0432 \\u043D\\u0438\\u0445 \\u043D\\u0443\\u0436\\u043D\\u044B\\u0435 \\u0447\\u0438\\u0441\\u043B\\u0430 \\u0438\\u0437 nums, nums2, \\u043E\\u0431\\u044C\\u0435\\u0434\\u0435\\u043D\\u0438\\u043B \\u0438\\u0445 \\u0438 \\u043E\\u0442\\u0441\\u043E\\u0440\\u0442\\u0438\\u0440\\u043E\\u0432\\u0430\\u043B \\u043E\\u043A\\u043E\\u043D\\u0447\\u0430\\u0442\\u0435\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432. \\u0413\\u0434\\u0435 \\u043E\\u0448\\u0438\\u0431\\u043A\\u0430?(c#)\\n\\n        int[] newArray = new int[nums1.Length];\\n\\n        int[] newArray2 = new int[nums2.Length];\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            newArray[i] = nums1[i];\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            newArray2[i] = nums2[i];\\n        }\\n\\n        int[] result = newArray.Concat(newArray2).ToArray();\\n\\n        int temp;\\n\\n        for (int i = 0; i < result.Length - 1; i++)\\n        {\\n            for (int j = i + 1; j < result.Length; j++)\\n            {\\n                if (result[i] > result[j])\\n                {\\n                    temp = result[i];\\n                    result[i] = result[j];\\n                    result[j] = temp;\\n                }\\n            }"
                    }
                ]
            },
            {
                "id": 1994220,
                "content": [
                    {
                        "username": "HarshitBansal122",
                        "content": "seems to be a error  while solving with python or python3 , my code is working well on other IDE\\'s\\nnums1=nums1[0:m]\\nnums1+=nums2[0:n]\\nnums1.sort()\\n        \\n"
                    },
                    {
                        "username": "yuriy25",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n      \\n      int count = 0, max = 0, inx = 0;\\n      int[] arrayMarraged = new int[m+n];\\n      \\n      if (m < n) max = n;\\n      else max = m;\\n\\n      while (count < max ){\\n        if(count < m)\\n          arrayMarraged[inx++] = nums1[count];\\n\\n        if(count < n) \\n          arrayMarraged[inx++] = nums2[count];\\n \\n        count++;\\n      }\\n       Arrays.sort(arrayMarraged);\\n      //nums1 = Arrays.copyOf(arrayMarraged, arrayMarraged.length); <- not correct because nums1 there is the new array object (doesn\\'t mutate )\\n\\n      for  (int i = 0; i < arrayMarraged.length; i++){\\n        nums1[i] = arrayMarraged[i];\\n      }\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yuriy25",
                        "content": "    public void merge(int[] nums1, int m, int[] nums2, int n) {\n      \n      int count = 0, max = 0, inx = 0;\n      int[] arrayMarraged = new int[m+n];\n      \n      if (m < n) max = n;\n      else max = m;\n\n      while (count < max ){\n        if(count < m)\n          arrayMarraged[inx++] = nums1[count];\n\n        if(count < n) \n          arrayMarraged[inx++] = nums2[count];\n \n        count++;\n      }\n       Arrays.sort(arrayMarraged);\n      nums1 = Arrays.copyOf(arrayMarraged, arrayMarraged.length);\n/*\n     for(int num : nums1){\nSystem.out.print(num + \" \"); result is 1 2 2 3 5 6\n}\n*/\n    }\n\nresult 1,2,2,3,5,6 but the leetcode reflects 1,2,3,0,0,0\nI print nums1 in the last line "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arodmcmxcix",
                        "content": "So when I do my STDOUT by printing nums1 it contains \\n[1, 2, 3, 0, 0, 0] original\\n[1, 2, 3] trim n\\'s\\n[1, 2, 3, 2, 5, 6] merge\\n[1, 2, 2, 3, 5, 6] final value of nums1\\nHowever the output says [1,2,3,0,0,0] any ideas? "
                    },
                    {
                        "username": "manishmicheal7",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    nums1.slice(0, m).concat(nums2.slice(0, n)).sort((a,b) => a - b);\\n};\\n\\ncan i know what did i do wrong here?"
                    },
                    {
                        "username": "Jashan_01",
                        "content": "When I run the below code, it gives a runtime error: addition of unsigned offset . Can somebody explain why this is happening .\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n    while(i<n){\\n        int j=m-1;\\n        if(nums1[j]>nums2[i]){\\n            \\n            while(j>=0 && nums2[i]<nums1[j] ){\\n                nums1[j+1]=nums1[j];\\n                j--;\\n            }\\n            nums1[j+1]=nums2[i];\\n            \\n        }\\n        else{\\n            nums1[j+1]=nums2[i];\\n        }\\n        i++;\\n        m++;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "na88git",
                        "content": "Why does my solution result in a Runtime Error. I compile the code in visual studio editor and it works\n\n`#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n\n        while (n)\n        {\n            if (nums2[n - 1] >= nums1[m - 1])\n            {\n                nums1[m + n - 1] = nums2[n - 1];\n                n--;\n            } \n            else \n            {\n                nums1[m + n - 1] = nums1[m - 1];\n                m--;\n            }\n        }\n        \n    }\n};\n\nint main()\n{\n    Solution so;\n\n    // Sol1\n    vector<int> nums1{1,2,3,5,0,0,0,0};\n    int m = 4;\n    vector<int> nums2{2,5,6,8};\n    int n = 4;\n\n    // Sol2\n    vector<int> nums11{1};\n    int m1 = 1;\n    vector<int> nums12{};\n    int n1 = 0;\n\n    // Sol3\n    vector<int> nums21{0};\n    int m2 = 0;\n    vector<int> nums22{1};\n    int n2 = 1;\n\n    so.merge(nums1, m, nums2, n);\n    so.merge(nums11, m1, nums12, n1);\n    so.merge(nums21, m2, nums22, n2);\n\n    cout << \"Sol1\" << endl;\n    for (int value : nums1)\n        cout << value << endl;\n        \n    cout << \"Sol2\" << endl;\n    for (int value : nums11)\n        cout << value << endl;\n\n    cout << \"Sol3\" << endl;\n    for (int value : nums21)\n        cout << value << endl;\n}`\n\n\n"
                    },
                    {
                        "username": "ajinkyabhalerao",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = 0, j = 0;\\n\\n        while(i+j < m+n) {\\n            if(nums1[i] <= nums2[j]) {\\n                i++;\\n            }\\n            else {\\n                nums1.insert(nums1.begin() + 1, nums2[j]);\\n                j++;\\n            }\\n        }\\n    }\\n};\\n\\nWhy does this throw an error? Someone please explain\\nruntime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)"
                    },
                    {
                        "username": "colinwinslow",
                        "content": "why can i index nums1 but not nums2? \\n\\nprint(nums2[0]) should print \\'2\\' but instead gives an IndexError... why?"
                    },
                    {
                        "username": "Bespalow",
                        "content": "\\u042F \\u0441\\u043E\\u0437\\u0434\\u0430\\u043B 2 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0430, \\u0432\\u044B\\u0432\\u0435\\u043B \\u0432 \\u043D\\u0438\\u0445 \\u043D\\u0443\\u0436\\u043D\\u044B\\u0435 \\u0447\\u0438\\u0441\\u043B\\u0430 \\u0438\\u0437 nums, nums2, \\u043E\\u0431\\u044C\\u0435\\u0434\\u0435\\u043D\\u0438\\u043B \\u0438\\u0445 \\u0438 \\u043E\\u0442\\u0441\\u043E\\u0440\\u0442\\u0438\\u0440\\u043E\\u0432\\u0430\\u043B \\u043E\\u043A\\u043E\\u043D\\u0447\\u0430\\u0442\\u0435\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432. \\u0413\\u0434\\u0435 \\u043E\\u0448\\u0438\\u0431\\u043A\\u0430?(c#)\\n\\n        int[] newArray = new int[nums1.Length];\\n\\n        int[] newArray2 = new int[nums2.Length];\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            newArray[i] = nums1[i];\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            newArray2[i] = nums2[i];\\n        }\\n\\n        int[] result = newArray.Concat(newArray2).ToArray();\\n\\n        int temp;\\n\\n        for (int i = 0; i < result.Length - 1; i++)\\n        {\\n            for (int j = i + 1; j < result.Length; j++)\\n            {\\n                if (result[i] > result[j])\\n                {\\n                    temp = result[i];\\n                    result[i] = result[j];\\n                    result[j] = temp;\\n                }\\n            }"
                    }
                ]
            },
            {
                "id": 1992937,
                "content": [
                    {
                        "username": "HarshitBansal122",
                        "content": "seems to be a error  while solving with python or python3 , my code is working well on other IDE\\'s\\nnums1=nums1[0:m]\\nnums1+=nums2[0:n]\\nnums1.sort()\\n        \\n"
                    },
                    {
                        "username": "yuriy25",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n      \\n      int count = 0, max = 0, inx = 0;\\n      int[] arrayMarraged = new int[m+n];\\n      \\n      if (m < n) max = n;\\n      else max = m;\\n\\n      while (count < max ){\\n        if(count < m)\\n          arrayMarraged[inx++] = nums1[count];\\n\\n        if(count < n) \\n          arrayMarraged[inx++] = nums2[count];\\n \\n        count++;\\n      }\\n       Arrays.sort(arrayMarraged);\\n      //nums1 = Arrays.copyOf(arrayMarraged, arrayMarraged.length); <- not correct because nums1 there is the new array object (doesn\\'t mutate )\\n\\n      for  (int i = 0; i < arrayMarraged.length; i++){\\n        nums1[i] = arrayMarraged[i];\\n      }\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yuriy25",
                        "content": "    public void merge(int[] nums1, int m, int[] nums2, int n) {\n      \n      int count = 0, max = 0, inx = 0;\n      int[] arrayMarraged = new int[m+n];\n      \n      if (m < n) max = n;\n      else max = m;\n\n      while (count < max ){\n        if(count < m)\n          arrayMarraged[inx++] = nums1[count];\n\n        if(count < n) \n          arrayMarraged[inx++] = nums2[count];\n \n        count++;\n      }\n       Arrays.sort(arrayMarraged);\n      nums1 = Arrays.copyOf(arrayMarraged, arrayMarraged.length);\n/*\n     for(int num : nums1){\nSystem.out.print(num + \" \"); result is 1 2 2 3 5 6\n}\n*/\n    }\n\nresult 1,2,2,3,5,6 but the leetcode reflects 1,2,3,0,0,0\nI print nums1 in the last line "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arodmcmxcix",
                        "content": "So when I do my STDOUT by printing nums1 it contains \\n[1, 2, 3, 0, 0, 0] original\\n[1, 2, 3] trim n\\'s\\n[1, 2, 3, 2, 5, 6] merge\\n[1, 2, 2, 3, 5, 6] final value of nums1\\nHowever the output says [1,2,3,0,0,0] any ideas? "
                    },
                    {
                        "username": "manishmicheal7",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    nums1.slice(0, m).concat(nums2.slice(0, n)).sort((a,b) => a - b);\\n};\\n\\ncan i know what did i do wrong here?"
                    },
                    {
                        "username": "Jashan_01",
                        "content": "When I run the below code, it gives a runtime error: addition of unsigned offset . Can somebody explain why this is happening .\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n    while(i<n){\\n        int j=m-1;\\n        if(nums1[j]>nums2[i]){\\n            \\n            while(j>=0 && nums2[i]<nums1[j] ){\\n                nums1[j+1]=nums1[j];\\n                j--;\\n            }\\n            nums1[j+1]=nums2[i];\\n            \\n        }\\n        else{\\n            nums1[j+1]=nums2[i];\\n        }\\n        i++;\\n        m++;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "na88git",
                        "content": "Why does my solution result in a Runtime Error. I compile the code in visual studio editor and it works\n\n`#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n\n        while (n)\n        {\n            if (nums2[n - 1] >= nums1[m - 1])\n            {\n                nums1[m + n - 1] = nums2[n - 1];\n                n--;\n            } \n            else \n            {\n                nums1[m + n - 1] = nums1[m - 1];\n                m--;\n            }\n        }\n        \n    }\n};\n\nint main()\n{\n    Solution so;\n\n    // Sol1\n    vector<int> nums1{1,2,3,5,0,0,0,0};\n    int m = 4;\n    vector<int> nums2{2,5,6,8};\n    int n = 4;\n\n    // Sol2\n    vector<int> nums11{1};\n    int m1 = 1;\n    vector<int> nums12{};\n    int n1 = 0;\n\n    // Sol3\n    vector<int> nums21{0};\n    int m2 = 0;\n    vector<int> nums22{1};\n    int n2 = 1;\n\n    so.merge(nums1, m, nums2, n);\n    so.merge(nums11, m1, nums12, n1);\n    so.merge(nums21, m2, nums22, n2);\n\n    cout << \"Sol1\" << endl;\n    for (int value : nums1)\n        cout << value << endl;\n        \n    cout << \"Sol2\" << endl;\n    for (int value : nums11)\n        cout << value << endl;\n\n    cout << \"Sol3\" << endl;\n    for (int value : nums21)\n        cout << value << endl;\n}`\n\n\n"
                    },
                    {
                        "username": "ajinkyabhalerao",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = 0, j = 0;\\n\\n        while(i+j < m+n) {\\n            if(nums1[i] <= nums2[j]) {\\n                i++;\\n            }\\n            else {\\n                nums1.insert(nums1.begin() + 1, nums2[j]);\\n                j++;\\n            }\\n        }\\n    }\\n};\\n\\nWhy does this throw an error? Someone please explain\\nruntime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)"
                    },
                    {
                        "username": "colinwinslow",
                        "content": "why can i index nums1 but not nums2? \\n\\nprint(nums2[0]) should print \\'2\\' but instead gives an IndexError... why?"
                    },
                    {
                        "username": "Bespalow",
                        "content": "\\u042F \\u0441\\u043E\\u0437\\u0434\\u0430\\u043B 2 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0430, \\u0432\\u044B\\u0432\\u0435\\u043B \\u0432 \\u043D\\u0438\\u0445 \\u043D\\u0443\\u0436\\u043D\\u044B\\u0435 \\u0447\\u0438\\u0441\\u043B\\u0430 \\u0438\\u0437 nums, nums2, \\u043E\\u0431\\u044C\\u0435\\u0434\\u0435\\u043D\\u0438\\u043B \\u0438\\u0445 \\u0438 \\u043E\\u0442\\u0441\\u043E\\u0440\\u0442\\u0438\\u0440\\u043E\\u0432\\u0430\\u043B \\u043E\\u043A\\u043E\\u043D\\u0447\\u0430\\u0442\\u0435\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432. \\u0413\\u0434\\u0435 \\u043E\\u0448\\u0438\\u0431\\u043A\\u0430?(c#)\\n\\n        int[] newArray = new int[nums1.Length];\\n\\n        int[] newArray2 = new int[nums2.Length];\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            newArray[i] = nums1[i];\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            newArray2[i] = nums2[i];\\n        }\\n\\n        int[] result = newArray.Concat(newArray2).ToArray();\\n\\n        int temp;\\n\\n        for (int i = 0; i < result.Length - 1; i++)\\n        {\\n            for (int j = i + 1; j < result.Length; j++)\\n            {\\n                if (result[i] > result[j])\\n                {\\n                    temp = result[i];\\n                    result[i] = result[j];\\n                    result[j] = temp;\\n                }\\n            }"
                    }
                ]
            },
            {
                "id": 1989819,
                "content": [
                    {
                        "username": "HarshitBansal122",
                        "content": "seems to be a error  while solving with python or python3 , my code is working well on other IDE\\'s\\nnums1=nums1[0:m]\\nnums1+=nums2[0:n]\\nnums1.sort()\\n        \\n"
                    },
                    {
                        "username": "yuriy25",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n      \\n      int count = 0, max = 0, inx = 0;\\n      int[] arrayMarraged = new int[m+n];\\n      \\n      if (m < n) max = n;\\n      else max = m;\\n\\n      while (count < max ){\\n        if(count < m)\\n          arrayMarraged[inx++] = nums1[count];\\n\\n        if(count < n) \\n          arrayMarraged[inx++] = nums2[count];\\n \\n        count++;\\n      }\\n       Arrays.sort(arrayMarraged);\\n      //nums1 = Arrays.copyOf(arrayMarraged, arrayMarraged.length); <- not correct because nums1 there is the new array object (doesn\\'t mutate )\\n\\n      for  (int i = 0; i < arrayMarraged.length; i++){\\n        nums1[i] = arrayMarraged[i];\\n      }\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yuriy25",
                        "content": "    public void merge(int[] nums1, int m, int[] nums2, int n) {\n      \n      int count = 0, max = 0, inx = 0;\n      int[] arrayMarraged = new int[m+n];\n      \n      if (m < n) max = n;\n      else max = m;\n\n      while (count < max ){\n        if(count < m)\n          arrayMarraged[inx++] = nums1[count];\n\n        if(count < n) \n          arrayMarraged[inx++] = nums2[count];\n \n        count++;\n      }\n       Arrays.sort(arrayMarraged);\n      nums1 = Arrays.copyOf(arrayMarraged, arrayMarraged.length);\n/*\n     for(int num : nums1){\nSystem.out.print(num + \" \"); result is 1 2 2 3 5 6\n}\n*/\n    }\n\nresult 1,2,2,3,5,6 but the leetcode reflects 1,2,3,0,0,0\nI print nums1 in the last line "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arodmcmxcix",
                        "content": "So when I do my STDOUT by printing nums1 it contains \\n[1, 2, 3, 0, 0, 0] original\\n[1, 2, 3] trim n\\'s\\n[1, 2, 3, 2, 5, 6] merge\\n[1, 2, 2, 3, 5, 6] final value of nums1\\nHowever the output says [1,2,3,0,0,0] any ideas? "
                    },
                    {
                        "username": "manishmicheal7",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    nums1.slice(0, m).concat(nums2.slice(0, n)).sort((a,b) => a - b);\\n};\\n\\ncan i know what did i do wrong here?"
                    },
                    {
                        "username": "Jashan_01",
                        "content": "When I run the below code, it gives a runtime error: addition of unsigned offset . Can somebody explain why this is happening .\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n    while(i<n){\\n        int j=m-1;\\n        if(nums1[j]>nums2[i]){\\n            \\n            while(j>=0 && nums2[i]<nums1[j] ){\\n                nums1[j+1]=nums1[j];\\n                j--;\\n            }\\n            nums1[j+1]=nums2[i];\\n            \\n        }\\n        else{\\n            nums1[j+1]=nums2[i];\\n        }\\n        i++;\\n        m++;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "na88git",
                        "content": "Why does my solution result in a Runtime Error. I compile the code in visual studio editor and it works\n\n`#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n\n        while (n)\n        {\n            if (nums2[n - 1] >= nums1[m - 1])\n            {\n                nums1[m + n - 1] = nums2[n - 1];\n                n--;\n            } \n            else \n            {\n                nums1[m + n - 1] = nums1[m - 1];\n                m--;\n            }\n        }\n        \n    }\n};\n\nint main()\n{\n    Solution so;\n\n    // Sol1\n    vector<int> nums1{1,2,3,5,0,0,0,0};\n    int m = 4;\n    vector<int> nums2{2,5,6,8};\n    int n = 4;\n\n    // Sol2\n    vector<int> nums11{1};\n    int m1 = 1;\n    vector<int> nums12{};\n    int n1 = 0;\n\n    // Sol3\n    vector<int> nums21{0};\n    int m2 = 0;\n    vector<int> nums22{1};\n    int n2 = 1;\n\n    so.merge(nums1, m, nums2, n);\n    so.merge(nums11, m1, nums12, n1);\n    so.merge(nums21, m2, nums22, n2);\n\n    cout << \"Sol1\" << endl;\n    for (int value : nums1)\n        cout << value << endl;\n        \n    cout << \"Sol2\" << endl;\n    for (int value : nums11)\n        cout << value << endl;\n\n    cout << \"Sol3\" << endl;\n    for (int value : nums21)\n        cout << value << endl;\n}`\n\n\n"
                    },
                    {
                        "username": "ajinkyabhalerao",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = 0, j = 0;\\n\\n        while(i+j < m+n) {\\n            if(nums1[i] <= nums2[j]) {\\n                i++;\\n            }\\n            else {\\n                nums1.insert(nums1.begin() + 1, nums2[j]);\\n                j++;\\n            }\\n        }\\n    }\\n};\\n\\nWhy does this throw an error? Someone please explain\\nruntime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)"
                    },
                    {
                        "username": "colinwinslow",
                        "content": "why can i index nums1 but not nums2? \\n\\nprint(nums2[0]) should print \\'2\\' but instead gives an IndexError... why?"
                    },
                    {
                        "username": "Bespalow",
                        "content": "\\u042F \\u0441\\u043E\\u0437\\u0434\\u0430\\u043B 2 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0430, \\u0432\\u044B\\u0432\\u0435\\u043B \\u0432 \\u043D\\u0438\\u0445 \\u043D\\u0443\\u0436\\u043D\\u044B\\u0435 \\u0447\\u0438\\u0441\\u043B\\u0430 \\u0438\\u0437 nums, nums2, \\u043E\\u0431\\u044C\\u0435\\u0434\\u0435\\u043D\\u0438\\u043B \\u0438\\u0445 \\u0438 \\u043E\\u0442\\u0441\\u043E\\u0440\\u0442\\u0438\\u0440\\u043E\\u0432\\u0430\\u043B \\u043E\\u043A\\u043E\\u043D\\u0447\\u0430\\u0442\\u0435\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432. \\u0413\\u0434\\u0435 \\u043E\\u0448\\u0438\\u0431\\u043A\\u0430?(c#)\\n\\n        int[] newArray = new int[nums1.Length];\\n\\n        int[] newArray2 = new int[nums2.Length];\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            newArray[i] = nums1[i];\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            newArray2[i] = nums2[i];\\n        }\\n\\n        int[] result = newArray.Concat(newArray2).ToArray();\\n\\n        int temp;\\n\\n        for (int i = 0; i < result.Length - 1; i++)\\n        {\\n            for (int j = i + 1; j < result.Length; j++)\\n            {\\n                if (result[i] > result[j])\\n                {\\n                    temp = result[i];\\n                    result[i] = result[j];\\n                    result[j] = temp;\\n                }\\n            }"
                    }
                ]
            },
            {
                "id": 1987160,
                "content": [
                    {
                        "username": "HarshitBansal122",
                        "content": "seems to be a error  while solving with python or python3 , my code is working well on other IDE\\'s\\nnums1=nums1[0:m]\\nnums1+=nums2[0:n]\\nnums1.sort()\\n        \\n"
                    },
                    {
                        "username": "yuriy25",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n      \\n      int count = 0, max = 0, inx = 0;\\n      int[] arrayMarraged = new int[m+n];\\n      \\n      if (m < n) max = n;\\n      else max = m;\\n\\n      while (count < max ){\\n        if(count < m)\\n          arrayMarraged[inx++] = nums1[count];\\n\\n        if(count < n) \\n          arrayMarraged[inx++] = nums2[count];\\n \\n        count++;\\n      }\\n       Arrays.sort(arrayMarraged);\\n      //nums1 = Arrays.copyOf(arrayMarraged, arrayMarraged.length); <- not correct because nums1 there is the new array object (doesn\\'t mutate )\\n\\n      for  (int i = 0; i < arrayMarraged.length; i++){\\n        nums1[i] = arrayMarraged[i];\\n      }\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yuriy25",
                        "content": "    public void merge(int[] nums1, int m, int[] nums2, int n) {\n      \n      int count = 0, max = 0, inx = 0;\n      int[] arrayMarraged = new int[m+n];\n      \n      if (m < n) max = n;\n      else max = m;\n\n      while (count < max ){\n        if(count < m)\n          arrayMarraged[inx++] = nums1[count];\n\n        if(count < n) \n          arrayMarraged[inx++] = nums2[count];\n \n        count++;\n      }\n       Arrays.sort(arrayMarraged);\n      nums1 = Arrays.copyOf(arrayMarraged, arrayMarraged.length);\n/*\n     for(int num : nums1){\nSystem.out.print(num + \" \"); result is 1 2 2 3 5 6\n}\n*/\n    }\n\nresult 1,2,2,3,5,6 but the leetcode reflects 1,2,3,0,0,0\nI print nums1 in the last line "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arodmcmxcix",
                        "content": "So when I do my STDOUT by printing nums1 it contains \\n[1, 2, 3, 0, 0, 0] original\\n[1, 2, 3] trim n\\'s\\n[1, 2, 3, 2, 5, 6] merge\\n[1, 2, 2, 3, 5, 6] final value of nums1\\nHowever the output says [1,2,3,0,0,0] any ideas? "
                    },
                    {
                        "username": "manishmicheal7",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    nums1.slice(0, m).concat(nums2.slice(0, n)).sort((a,b) => a - b);\\n};\\n\\ncan i know what did i do wrong here?"
                    },
                    {
                        "username": "Jashan_01",
                        "content": "When I run the below code, it gives a runtime error: addition of unsigned offset . Can somebody explain why this is happening .\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n    while(i<n){\\n        int j=m-1;\\n        if(nums1[j]>nums2[i]){\\n            \\n            while(j>=0 && nums2[i]<nums1[j] ){\\n                nums1[j+1]=nums1[j];\\n                j--;\\n            }\\n            nums1[j+1]=nums2[i];\\n            \\n        }\\n        else{\\n            nums1[j+1]=nums2[i];\\n        }\\n        i++;\\n        m++;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "na88git",
                        "content": "Why does my solution result in a Runtime Error. I compile the code in visual studio editor and it works\n\n`#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n\n        while (n)\n        {\n            if (nums2[n - 1] >= nums1[m - 1])\n            {\n                nums1[m + n - 1] = nums2[n - 1];\n                n--;\n            } \n            else \n            {\n                nums1[m + n - 1] = nums1[m - 1];\n                m--;\n            }\n        }\n        \n    }\n};\n\nint main()\n{\n    Solution so;\n\n    // Sol1\n    vector<int> nums1{1,2,3,5,0,0,0,0};\n    int m = 4;\n    vector<int> nums2{2,5,6,8};\n    int n = 4;\n\n    // Sol2\n    vector<int> nums11{1};\n    int m1 = 1;\n    vector<int> nums12{};\n    int n1 = 0;\n\n    // Sol3\n    vector<int> nums21{0};\n    int m2 = 0;\n    vector<int> nums22{1};\n    int n2 = 1;\n\n    so.merge(nums1, m, nums2, n);\n    so.merge(nums11, m1, nums12, n1);\n    so.merge(nums21, m2, nums22, n2);\n\n    cout << \"Sol1\" << endl;\n    for (int value : nums1)\n        cout << value << endl;\n        \n    cout << \"Sol2\" << endl;\n    for (int value : nums11)\n        cout << value << endl;\n\n    cout << \"Sol3\" << endl;\n    for (int value : nums21)\n        cout << value << endl;\n}`\n\n\n"
                    },
                    {
                        "username": "ajinkyabhalerao",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = 0, j = 0;\\n\\n        while(i+j < m+n) {\\n            if(nums1[i] <= nums2[j]) {\\n                i++;\\n            }\\n            else {\\n                nums1.insert(nums1.begin() + 1, nums2[j]);\\n                j++;\\n            }\\n        }\\n    }\\n};\\n\\nWhy does this throw an error? Someone please explain\\nruntime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)"
                    },
                    {
                        "username": "colinwinslow",
                        "content": "why can i index nums1 but not nums2? \\n\\nprint(nums2[0]) should print \\'2\\' but instead gives an IndexError... why?"
                    },
                    {
                        "username": "Bespalow",
                        "content": "\\u042F \\u0441\\u043E\\u0437\\u0434\\u0430\\u043B 2 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0430, \\u0432\\u044B\\u0432\\u0435\\u043B \\u0432 \\u043D\\u0438\\u0445 \\u043D\\u0443\\u0436\\u043D\\u044B\\u0435 \\u0447\\u0438\\u0441\\u043B\\u0430 \\u0438\\u0437 nums, nums2, \\u043E\\u0431\\u044C\\u0435\\u0434\\u0435\\u043D\\u0438\\u043B \\u0438\\u0445 \\u0438 \\u043E\\u0442\\u0441\\u043E\\u0440\\u0442\\u0438\\u0440\\u043E\\u0432\\u0430\\u043B \\u043E\\u043A\\u043E\\u043D\\u0447\\u0430\\u0442\\u0435\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432. \\u0413\\u0434\\u0435 \\u043E\\u0448\\u0438\\u0431\\u043A\\u0430?(c#)\\n\\n        int[] newArray = new int[nums1.Length];\\n\\n        int[] newArray2 = new int[nums2.Length];\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            newArray[i] = nums1[i];\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            newArray2[i] = nums2[i];\\n        }\\n\\n        int[] result = newArray.Concat(newArray2).ToArray();\\n\\n        int temp;\\n\\n        for (int i = 0; i < result.Length - 1; i++)\\n        {\\n            for (int j = i + 1; j < result.Length; j++)\\n            {\\n                if (result[i] > result[j])\\n                {\\n                    temp = result[i];\\n                    result[i] = result[j];\\n                    result[j] = temp;\\n                }\\n            }"
                    }
                ]
            },
            {
                "id": 1984769,
                "content": [
                    {
                        "username": "HarshitBansal122",
                        "content": "seems to be a error  while solving with python or python3 , my code is working well on other IDE\\'s\\nnums1=nums1[0:m]\\nnums1+=nums2[0:n]\\nnums1.sort()\\n        \\n"
                    },
                    {
                        "username": "yuriy25",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n      \\n      int count = 0, max = 0, inx = 0;\\n      int[] arrayMarraged = new int[m+n];\\n      \\n      if (m < n) max = n;\\n      else max = m;\\n\\n      while (count < max ){\\n        if(count < m)\\n          arrayMarraged[inx++] = nums1[count];\\n\\n        if(count < n) \\n          arrayMarraged[inx++] = nums2[count];\\n \\n        count++;\\n      }\\n       Arrays.sort(arrayMarraged);\\n      //nums1 = Arrays.copyOf(arrayMarraged, arrayMarraged.length); <- not correct because nums1 there is the new array object (doesn\\'t mutate )\\n\\n      for  (int i = 0; i < arrayMarraged.length; i++){\\n        nums1[i] = arrayMarraged[i];\\n      }\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yuriy25",
                        "content": "    public void merge(int[] nums1, int m, int[] nums2, int n) {\n      \n      int count = 0, max = 0, inx = 0;\n      int[] arrayMarraged = new int[m+n];\n      \n      if (m < n) max = n;\n      else max = m;\n\n      while (count < max ){\n        if(count < m)\n          arrayMarraged[inx++] = nums1[count];\n\n        if(count < n) \n          arrayMarraged[inx++] = nums2[count];\n \n        count++;\n      }\n       Arrays.sort(arrayMarraged);\n      nums1 = Arrays.copyOf(arrayMarraged, arrayMarraged.length);\n/*\n     for(int num : nums1){\nSystem.out.print(num + \" \"); result is 1 2 2 3 5 6\n}\n*/\n    }\n\nresult 1,2,2,3,5,6 but the leetcode reflects 1,2,3,0,0,0\nI print nums1 in the last line "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arodmcmxcix",
                        "content": "So when I do my STDOUT by printing nums1 it contains \\n[1, 2, 3, 0, 0, 0] original\\n[1, 2, 3] trim n\\'s\\n[1, 2, 3, 2, 5, 6] merge\\n[1, 2, 2, 3, 5, 6] final value of nums1\\nHowever the output says [1,2,3,0,0,0] any ideas? "
                    },
                    {
                        "username": "manishmicheal7",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    nums1.slice(0, m).concat(nums2.slice(0, n)).sort((a,b) => a - b);\\n};\\n\\ncan i know what did i do wrong here?"
                    },
                    {
                        "username": "Jashan_01",
                        "content": "When I run the below code, it gives a runtime error: addition of unsigned offset . Can somebody explain why this is happening .\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n    while(i<n){\\n        int j=m-1;\\n        if(nums1[j]>nums2[i]){\\n            \\n            while(j>=0 && nums2[i]<nums1[j] ){\\n                nums1[j+1]=nums1[j];\\n                j--;\\n            }\\n            nums1[j+1]=nums2[i];\\n            \\n        }\\n        else{\\n            nums1[j+1]=nums2[i];\\n        }\\n        i++;\\n        m++;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "na88git",
                        "content": "Why does my solution result in a Runtime Error. I compile the code in visual studio editor and it works\n\n`#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n\n        while (n)\n        {\n            if (nums2[n - 1] >= nums1[m - 1])\n            {\n                nums1[m + n - 1] = nums2[n - 1];\n                n--;\n            } \n            else \n            {\n                nums1[m + n - 1] = nums1[m - 1];\n                m--;\n            }\n        }\n        \n    }\n};\n\nint main()\n{\n    Solution so;\n\n    // Sol1\n    vector<int> nums1{1,2,3,5,0,0,0,0};\n    int m = 4;\n    vector<int> nums2{2,5,6,8};\n    int n = 4;\n\n    // Sol2\n    vector<int> nums11{1};\n    int m1 = 1;\n    vector<int> nums12{};\n    int n1 = 0;\n\n    // Sol3\n    vector<int> nums21{0};\n    int m2 = 0;\n    vector<int> nums22{1};\n    int n2 = 1;\n\n    so.merge(nums1, m, nums2, n);\n    so.merge(nums11, m1, nums12, n1);\n    so.merge(nums21, m2, nums22, n2);\n\n    cout << \"Sol1\" << endl;\n    for (int value : nums1)\n        cout << value << endl;\n        \n    cout << \"Sol2\" << endl;\n    for (int value : nums11)\n        cout << value << endl;\n\n    cout << \"Sol3\" << endl;\n    for (int value : nums21)\n        cout << value << endl;\n}`\n\n\n"
                    },
                    {
                        "username": "ajinkyabhalerao",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = 0, j = 0;\\n\\n        while(i+j < m+n) {\\n            if(nums1[i] <= nums2[j]) {\\n                i++;\\n            }\\n            else {\\n                nums1.insert(nums1.begin() + 1, nums2[j]);\\n                j++;\\n            }\\n        }\\n    }\\n};\\n\\nWhy does this throw an error? Someone please explain\\nruntime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)"
                    },
                    {
                        "username": "colinwinslow",
                        "content": "why can i index nums1 but not nums2? \\n\\nprint(nums2[0]) should print \\'2\\' but instead gives an IndexError... why?"
                    },
                    {
                        "username": "Bespalow",
                        "content": "\\u042F \\u0441\\u043E\\u0437\\u0434\\u0430\\u043B 2 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0430, \\u0432\\u044B\\u0432\\u0435\\u043B \\u0432 \\u043D\\u0438\\u0445 \\u043D\\u0443\\u0436\\u043D\\u044B\\u0435 \\u0447\\u0438\\u0441\\u043B\\u0430 \\u0438\\u0437 nums, nums2, \\u043E\\u0431\\u044C\\u0435\\u0434\\u0435\\u043D\\u0438\\u043B \\u0438\\u0445 \\u0438 \\u043E\\u0442\\u0441\\u043E\\u0440\\u0442\\u0438\\u0440\\u043E\\u0432\\u0430\\u043B \\u043E\\u043A\\u043E\\u043D\\u0447\\u0430\\u0442\\u0435\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432. \\u0413\\u0434\\u0435 \\u043E\\u0448\\u0438\\u0431\\u043A\\u0430?(c#)\\n\\n        int[] newArray = new int[nums1.Length];\\n\\n        int[] newArray2 = new int[nums2.Length];\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            newArray[i] = nums1[i];\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            newArray2[i] = nums2[i];\\n        }\\n\\n        int[] result = newArray.Concat(newArray2).ToArray();\\n\\n        int temp;\\n\\n        for (int i = 0; i < result.Length - 1; i++)\\n        {\\n            for (int j = i + 1; j < result.Length; j++)\\n            {\\n                if (result[i] > result[j])\\n                {\\n                    temp = result[i];\\n                    result[i] = result[j];\\n                    result[j] = temp;\\n                }\\n            }"
                    }
                ]
            },
            {
                "id": 1982759,
                "content": [
                    {
                        "username": "HarshitBansal122",
                        "content": "seems to be a error  while solving with python or python3 , my code is working well on other IDE\\'s\\nnums1=nums1[0:m]\\nnums1+=nums2[0:n]\\nnums1.sort()\\n        \\n"
                    },
                    {
                        "username": "yuriy25",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n      \\n      int count = 0, max = 0, inx = 0;\\n      int[] arrayMarraged = new int[m+n];\\n      \\n      if (m < n) max = n;\\n      else max = m;\\n\\n      while (count < max ){\\n        if(count < m)\\n          arrayMarraged[inx++] = nums1[count];\\n\\n        if(count < n) \\n          arrayMarraged[inx++] = nums2[count];\\n \\n        count++;\\n      }\\n       Arrays.sort(arrayMarraged);\\n      //nums1 = Arrays.copyOf(arrayMarraged, arrayMarraged.length); <- not correct because nums1 there is the new array object (doesn\\'t mutate )\\n\\n      for  (int i = 0; i < arrayMarraged.length; i++){\\n        nums1[i] = arrayMarraged[i];\\n      }\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yuriy25",
                        "content": "    public void merge(int[] nums1, int m, int[] nums2, int n) {\n      \n      int count = 0, max = 0, inx = 0;\n      int[] arrayMarraged = new int[m+n];\n      \n      if (m < n) max = n;\n      else max = m;\n\n      while (count < max ){\n        if(count < m)\n          arrayMarraged[inx++] = nums1[count];\n\n        if(count < n) \n          arrayMarraged[inx++] = nums2[count];\n \n        count++;\n      }\n       Arrays.sort(arrayMarraged);\n      nums1 = Arrays.copyOf(arrayMarraged, arrayMarraged.length);\n/*\n     for(int num : nums1){\nSystem.out.print(num + \" \"); result is 1 2 2 3 5 6\n}\n*/\n    }\n\nresult 1,2,2,3,5,6 but the leetcode reflects 1,2,3,0,0,0\nI print nums1 in the last line "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arodmcmxcix",
                        "content": "So when I do my STDOUT by printing nums1 it contains \\n[1, 2, 3, 0, 0, 0] original\\n[1, 2, 3] trim n\\'s\\n[1, 2, 3, 2, 5, 6] merge\\n[1, 2, 2, 3, 5, 6] final value of nums1\\nHowever the output says [1,2,3,0,0,0] any ideas? "
                    },
                    {
                        "username": "manishmicheal7",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    nums1.slice(0, m).concat(nums2.slice(0, n)).sort((a,b) => a - b);\\n};\\n\\ncan i know what did i do wrong here?"
                    },
                    {
                        "username": "Jashan_01",
                        "content": "When I run the below code, it gives a runtime error: addition of unsigned offset . Can somebody explain why this is happening .\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n    while(i<n){\\n        int j=m-1;\\n        if(nums1[j]>nums2[i]){\\n            \\n            while(j>=0 && nums2[i]<nums1[j] ){\\n                nums1[j+1]=nums1[j];\\n                j--;\\n            }\\n            nums1[j+1]=nums2[i];\\n            \\n        }\\n        else{\\n            nums1[j+1]=nums2[i];\\n        }\\n        i++;\\n        m++;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "na88git",
                        "content": "Why does my solution result in a Runtime Error. I compile the code in visual studio editor and it works\n\n`#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n\n        while (n)\n        {\n            if (nums2[n - 1] >= nums1[m - 1])\n            {\n                nums1[m + n - 1] = nums2[n - 1];\n                n--;\n            } \n            else \n            {\n                nums1[m + n - 1] = nums1[m - 1];\n                m--;\n            }\n        }\n        \n    }\n};\n\nint main()\n{\n    Solution so;\n\n    // Sol1\n    vector<int> nums1{1,2,3,5,0,0,0,0};\n    int m = 4;\n    vector<int> nums2{2,5,6,8};\n    int n = 4;\n\n    // Sol2\n    vector<int> nums11{1};\n    int m1 = 1;\n    vector<int> nums12{};\n    int n1 = 0;\n\n    // Sol3\n    vector<int> nums21{0};\n    int m2 = 0;\n    vector<int> nums22{1};\n    int n2 = 1;\n\n    so.merge(nums1, m, nums2, n);\n    so.merge(nums11, m1, nums12, n1);\n    so.merge(nums21, m2, nums22, n2);\n\n    cout << \"Sol1\" << endl;\n    for (int value : nums1)\n        cout << value << endl;\n        \n    cout << \"Sol2\" << endl;\n    for (int value : nums11)\n        cout << value << endl;\n\n    cout << \"Sol3\" << endl;\n    for (int value : nums21)\n        cout << value << endl;\n}`\n\n\n"
                    },
                    {
                        "username": "ajinkyabhalerao",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = 0, j = 0;\\n\\n        while(i+j < m+n) {\\n            if(nums1[i] <= nums2[j]) {\\n                i++;\\n            }\\n            else {\\n                nums1.insert(nums1.begin() + 1, nums2[j]);\\n                j++;\\n            }\\n        }\\n    }\\n};\\n\\nWhy does this throw an error? Someone please explain\\nruntime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)"
                    },
                    {
                        "username": "colinwinslow",
                        "content": "why can i index nums1 but not nums2? \\n\\nprint(nums2[0]) should print \\'2\\' but instead gives an IndexError... why?"
                    },
                    {
                        "username": "Bespalow",
                        "content": "\\u042F \\u0441\\u043E\\u0437\\u0434\\u0430\\u043B 2 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0430, \\u0432\\u044B\\u0432\\u0435\\u043B \\u0432 \\u043D\\u0438\\u0445 \\u043D\\u0443\\u0436\\u043D\\u044B\\u0435 \\u0447\\u0438\\u0441\\u043B\\u0430 \\u0438\\u0437 nums, nums2, \\u043E\\u0431\\u044C\\u0435\\u0434\\u0435\\u043D\\u0438\\u043B \\u0438\\u0445 \\u0438 \\u043E\\u0442\\u0441\\u043E\\u0440\\u0442\\u0438\\u0440\\u043E\\u0432\\u0430\\u043B \\u043E\\u043A\\u043E\\u043D\\u0447\\u0430\\u0442\\u0435\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432. \\u0413\\u0434\\u0435 \\u043E\\u0448\\u0438\\u0431\\u043A\\u0430?(c#)\\n\\n        int[] newArray = new int[nums1.Length];\\n\\n        int[] newArray2 = new int[nums2.Length];\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            newArray[i] = nums1[i];\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            newArray2[i] = nums2[i];\\n        }\\n\\n        int[] result = newArray.Concat(newArray2).ToArray();\\n\\n        int temp;\\n\\n        for (int i = 0; i < result.Length - 1; i++)\\n        {\\n            for (int j = i + 1; j < result.Length; j++)\\n            {\\n                if (result[i] > result[j])\\n                {\\n                    temp = result[i];\\n                    result[i] = result[j];\\n                    result[j] = temp;\\n                }\\n            }"
                    }
                ]
            },
            {
                "id": 1981783,
                "content": [
                    {
                        "username": "amansingh4958",
                        "content": "Cheat Code for this particular question with such constraints :\n```\n void merge(vector<int>& arr1, int n, vector<int>& arr2, int m) {\n        for (int i = 0; i < m; i++)\n            arr1[n + i] = arr2[i];\n        sort(arr1.begin(), arr1.end());\n }\n```\nBeats 100%\n**TC:** O(m) + O((m+n)log(m+n)) (i guess)\n**SC:** O(1)"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@georgezakharov](/georgezakharov) I\\'m really sorry if the above code hurt you because of having a tag \\'Tip\\'. Please forgive me.\\n\\n(I thought this code would seem funny to others)\\nAnyways, have a great day"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@amansingh4958](/amansingh4958) Then how it supposed to be a tip? :)"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@georgezakharov](/georgezakharov) Bro no one is gonna use such type of solution that\\'s why I posted it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you, but it is not a tip.\\nHave you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "Bhanu1146",
                        "content": "In java\\nI used System.out.println(nums2[0]);\\n\\njava.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0\\n  at line 5, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n      \\nbut same code work well on other compilers."
                    },
                    {
                        "username": "kumawatarun8989",
                        "content": "what the ques. ask to me im new to coding"
                    },
                    {
                        "username": "Obl1Que",
                        "content": " `nums1 = (nums1[:m] + nums2)`\\n `nums1.sort()`\\n `return nums1`\\n\\nWhy my code doesn\\'t works?"
                    },
                    {
                        "username": "arodmcmxcix",
                        "content": "Same issue on my end. I realize when we do nums1 + nums2 this creates a new pointer (a new list) which we reassign to nums1. We are supposed to do it in place. i.e. do not re assign nums1 to a new pointer. "
                    },
                    {
                        "username": "iammuqeetahmad",
                        "content": "`nums1 =[-10,-10,-9,-9,-9,-8,-8,-7,-7,-7,-6,-6,-6,-6,-6,-6,-6,-5,-5,-5,-4,-4,-4,-3,-3,-2,-2,-1,-1,0,1,1,1,2,2,2,3,3,3,4,5,5,6,6,6,6,7,7,7,7,8,9,9,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]`\\n\\n`m = 55`\\n\\n`nums2 = [-10,-10,-9,-9,-9,-9,-8,-8,-8,-8,-8,-7,-7,-7,-7,-7,-7,-7,-7,-6,-6,-6,-6,-5,-5,-5,-5,-5,-4,-4,-4,-4,-4,-3,-3,-3,-2,-2,-2,-2,-2,-2,-2,-1,-1,-1,0,0,0,0,0,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,4,4,4,4,4,4,4,5,5,5,5,5,5,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,9,9,9,9]`\\n\\n`n = 99`\\n\\n`Tip:` Don\\'t get confuse by m = 55 and n = 99 wheree the nums1 array looks bigger then nums2 array and m represents the number of values in nums1. As in nums1 the m represents only the starting m values rest are all the 0 which are for merging the nums2 in nums1.\\n\\n\\n`Question:` After merging nums2 in nums1 when i tried using the inbuilt function of javascript `sort()` \\n `nums1.sort();`\\nThis break on the above mentioned input I don\\'t understand why??  \\n\\n`Solution : ` The solution i come up with was  `nums1.sort((a, b) => a - b);` \\nThis sort function subtracts b from a, which determines the sorting order. If the result is negative, a is placed before b, if the result is positive, b is placed before a, and if the result is zero, the order remains unchanged."
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "if( nums1[p1] > nums2[p2]  && p1 >= 0 ) # statement first ( run time error )\\nif( p1 >= 0 && nums1[p1] > nums2[p2] ) # statement second ( accepted )\\n\\nWhat is the different between above statements  ?? \\n"
                    },
                    {
                        "username": "blandprix",
                        "content": "[@Dev_Engg](/Dev_Engg) ah, interesting. Glad you got to the bottom of it!"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "[@blandprix](/blandprix) \\nI got the ans, >>>  the main difference between the two statements lies in the order of evaluation. The second statement checks the validity of the index p1 first before attempting to access nums1[p1], making it safer and preventing potential runtime errors. The first statement, however, has the potential to cause a runtime error if p1 is not a valid index for nums1."
                    },
                    {
                        "username": "blandprix",
                        "content": "perhaps the second case passes because `p1 >= 0` is always false, so it is short-circuiting the evaluation of your condition, i.e., `nums1[p1] > nums2[p2]` is never evaluated."
                    },
                    {
                        "username": "Fyr1981",
                        "content": "My solution works on my computer, but it does not work on this site, although it is logically correct. the site just returns [1,2,2,0,0,0], is this a bad site or what?"
                    },
                    {
                        "username": "blandprix",
                        "content": "Check out my tip about mutating nums1 https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "your solution not evaluate for different test cases \\n"
                    },
                    {
                        "username": "user6335T",
                        "content": "Though any other compilers gave me the expected output, but when i ran my code using Leetcode compilers always gives me different output.\\nthe test case is nums1 = [0] and nums2 = [1] and expected output is [1], but in leetcode it always gives me [0]. WHY?\\n\\nhere is my code:\\nhttps://replit.com/@IyanTRICKSTER/Merge-two-sorted-array#index.js"
                    },
                    {
                        "username": "vaibhav83porwal",
                        "content": "When I am printing my result it is giving [1, 2, 2, 3, 5, 6] in Stdout. But in the Output it is showing [1,2,3,0,0,0]. Why is it so?"
                    },
                    {
                        "username": "blandprix",
                        "content": "Check out my tip about mutating nums1 https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    },
                    {
                        "username": "Suresh__11",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    let newArr=[]\\n    for (let index = 0; index < m; index++) {\\n        newArr.push(nums1[index])\\n        \\n    }\\n    for (let index = 0; index < n; index++) {\\n        newArr.push(nums2[index])\\n        \\n    }\\n    newArr.sort()\\n    nums1=newArr\\n    console.log(nums1)\\n    \\n};\\nmerge([1,2,3,0,0,0],4,[2,5,6],3)    Anyone can explain me why this doesn\\'t work? It\\'s giving the output as described in the question."
                    },
                    {
                        "username": "blandprix",
                        "content": "I had the same problem. Posted a tip about it: https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    }
                ]
            },
            {
                "id": 1981194,
                "content": [
                    {
                        "username": "amansingh4958",
                        "content": "Cheat Code for this particular question with such constraints :\n```\n void merge(vector<int>& arr1, int n, vector<int>& arr2, int m) {\n        for (int i = 0; i < m; i++)\n            arr1[n + i] = arr2[i];\n        sort(arr1.begin(), arr1.end());\n }\n```\nBeats 100%\n**TC:** O(m) + O((m+n)log(m+n)) (i guess)\n**SC:** O(1)"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@georgezakharov](/georgezakharov) I\\'m really sorry if the above code hurt you because of having a tag \\'Tip\\'. Please forgive me.\\n\\n(I thought this code would seem funny to others)\\nAnyways, have a great day"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@amansingh4958](/amansingh4958) Then how it supposed to be a tip? :)"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@georgezakharov](/georgezakharov) Bro no one is gonna use such type of solution that\\'s why I posted it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you, but it is not a tip.\\nHave you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "Bhanu1146",
                        "content": "In java\\nI used System.out.println(nums2[0]);\\n\\njava.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0\\n  at line 5, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n      \\nbut same code work well on other compilers."
                    },
                    {
                        "username": "kumawatarun8989",
                        "content": "what the ques. ask to me im new to coding"
                    },
                    {
                        "username": "Obl1Que",
                        "content": " `nums1 = (nums1[:m] + nums2)`\\n `nums1.sort()`\\n `return nums1`\\n\\nWhy my code doesn\\'t works?"
                    },
                    {
                        "username": "arodmcmxcix",
                        "content": "Same issue on my end. I realize when we do nums1 + nums2 this creates a new pointer (a new list) which we reassign to nums1. We are supposed to do it in place. i.e. do not re assign nums1 to a new pointer. "
                    },
                    {
                        "username": "iammuqeetahmad",
                        "content": "`nums1 =[-10,-10,-9,-9,-9,-8,-8,-7,-7,-7,-6,-6,-6,-6,-6,-6,-6,-5,-5,-5,-4,-4,-4,-3,-3,-2,-2,-1,-1,0,1,1,1,2,2,2,3,3,3,4,5,5,6,6,6,6,7,7,7,7,8,9,9,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]`\\n\\n`m = 55`\\n\\n`nums2 = [-10,-10,-9,-9,-9,-9,-8,-8,-8,-8,-8,-7,-7,-7,-7,-7,-7,-7,-7,-6,-6,-6,-6,-5,-5,-5,-5,-5,-4,-4,-4,-4,-4,-3,-3,-3,-2,-2,-2,-2,-2,-2,-2,-1,-1,-1,0,0,0,0,0,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,4,4,4,4,4,4,4,5,5,5,5,5,5,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,9,9,9,9]`\\n\\n`n = 99`\\n\\n`Tip:` Don\\'t get confuse by m = 55 and n = 99 wheree the nums1 array looks bigger then nums2 array and m represents the number of values in nums1. As in nums1 the m represents only the starting m values rest are all the 0 which are for merging the nums2 in nums1.\\n\\n\\n`Question:` After merging nums2 in nums1 when i tried using the inbuilt function of javascript `sort()` \\n `nums1.sort();`\\nThis break on the above mentioned input I don\\'t understand why??  \\n\\n`Solution : ` The solution i come up with was  `nums1.sort((a, b) => a - b);` \\nThis sort function subtracts b from a, which determines the sorting order. If the result is negative, a is placed before b, if the result is positive, b is placed before a, and if the result is zero, the order remains unchanged."
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "if( nums1[p1] > nums2[p2]  && p1 >= 0 ) # statement first ( run time error )\\nif( p1 >= 0 && nums1[p1] > nums2[p2] ) # statement second ( accepted )\\n\\nWhat is the different between above statements  ?? \\n"
                    },
                    {
                        "username": "blandprix",
                        "content": "[@Dev_Engg](/Dev_Engg) ah, interesting. Glad you got to the bottom of it!"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "[@blandprix](/blandprix) \\nI got the ans, >>>  the main difference between the two statements lies in the order of evaluation. The second statement checks the validity of the index p1 first before attempting to access nums1[p1], making it safer and preventing potential runtime errors. The first statement, however, has the potential to cause a runtime error if p1 is not a valid index for nums1."
                    },
                    {
                        "username": "blandprix",
                        "content": "perhaps the second case passes because `p1 >= 0` is always false, so it is short-circuiting the evaluation of your condition, i.e., `nums1[p1] > nums2[p2]` is never evaluated."
                    },
                    {
                        "username": "Fyr1981",
                        "content": "My solution works on my computer, but it does not work on this site, although it is logically correct. the site just returns [1,2,2,0,0,0], is this a bad site or what?"
                    },
                    {
                        "username": "blandprix",
                        "content": "Check out my tip about mutating nums1 https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "your solution not evaluate for different test cases \\n"
                    },
                    {
                        "username": "user6335T",
                        "content": "Though any other compilers gave me the expected output, but when i ran my code using Leetcode compilers always gives me different output.\\nthe test case is nums1 = [0] and nums2 = [1] and expected output is [1], but in leetcode it always gives me [0]. WHY?\\n\\nhere is my code:\\nhttps://replit.com/@IyanTRICKSTER/Merge-two-sorted-array#index.js"
                    },
                    {
                        "username": "vaibhav83porwal",
                        "content": "When I am printing my result it is giving [1, 2, 2, 3, 5, 6] in Stdout. But in the Output it is showing [1,2,3,0,0,0]. Why is it so?"
                    },
                    {
                        "username": "blandprix",
                        "content": "Check out my tip about mutating nums1 https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    },
                    {
                        "username": "Suresh__11",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    let newArr=[]\\n    for (let index = 0; index < m; index++) {\\n        newArr.push(nums1[index])\\n        \\n    }\\n    for (let index = 0; index < n; index++) {\\n        newArr.push(nums2[index])\\n        \\n    }\\n    newArr.sort()\\n    nums1=newArr\\n    console.log(nums1)\\n    \\n};\\nmerge([1,2,3,0,0,0],4,[2,5,6],3)    Anyone can explain me why this doesn\\'t work? It\\'s giving the output as described in the question."
                    },
                    {
                        "username": "blandprix",
                        "content": "I had the same problem. Posted a tip about it: https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    }
                ]
            },
            {
                "id": 1981040,
                "content": [
                    {
                        "username": "amansingh4958",
                        "content": "Cheat Code for this particular question with such constraints :\n```\n void merge(vector<int>& arr1, int n, vector<int>& arr2, int m) {\n        for (int i = 0; i < m; i++)\n            arr1[n + i] = arr2[i];\n        sort(arr1.begin(), arr1.end());\n }\n```\nBeats 100%\n**TC:** O(m) + O((m+n)log(m+n)) (i guess)\n**SC:** O(1)"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@georgezakharov](/georgezakharov) I\\'m really sorry if the above code hurt you because of having a tag \\'Tip\\'. Please forgive me.\\n\\n(I thought this code would seem funny to others)\\nAnyways, have a great day"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@amansingh4958](/amansingh4958) Then how it supposed to be a tip? :)"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@georgezakharov](/georgezakharov) Bro no one is gonna use such type of solution that\\'s why I posted it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you, but it is not a tip.\\nHave you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "Bhanu1146",
                        "content": "In java\\nI used System.out.println(nums2[0]);\\n\\njava.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0\\n  at line 5, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n      \\nbut same code work well on other compilers."
                    },
                    {
                        "username": "kumawatarun8989",
                        "content": "what the ques. ask to me im new to coding"
                    },
                    {
                        "username": "Obl1Que",
                        "content": " `nums1 = (nums1[:m] + nums2)`\\n `nums1.sort()`\\n `return nums1`\\n\\nWhy my code doesn\\'t works?"
                    },
                    {
                        "username": "arodmcmxcix",
                        "content": "Same issue on my end. I realize when we do nums1 + nums2 this creates a new pointer (a new list) which we reassign to nums1. We are supposed to do it in place. i.e. do not re assign nums1 to a new pointer. "
                    },
                    {
                        "username": "iammuqeetahmad",
                        "content": "`nums1 =[-10,-10,-9,-9,-9,-8,-8,-7,-7,-7,-6,-6,-6,-6,-6,-6,-6,-5,-5,-5,-4,-4,-4,-3,-3,-2,-2,-1,-1,0,1,1,1,2,2,2,3,3,3,4,5,5,6,6,6,6,7,7,7,7,8,9,9,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]`\\n\\n`m = 55`\\n\\n`nums2 = [-10,-10,-9,-9,-9,-9,-8,-8,-8,-8,-8,-7,-7,-7,-7,-7,-7,-7,-7,-6,-6,-6,-6,-5,-5,-5,-5,-5,-4,-4,-4,-4,-4,-3,-3,-3,-2,-2,-2,-2,-2,-2,-2,-1,-1,-1,0,0,0,0,0,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,4,4,4,4,4,4,4,5,5,5,5,5,5,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,9,9,9,9]`\\n\\n`n = 99`\\n\\n`Tip:` Don\\'t get confuse by m = 55 and n = 99 wheree the nums1 array looks bigger then nums2 array and m represents the number of values in nums1. As in nums1 the m represents only the starting m values rest are all the 0 which are for merging the nums2 in nums1.\\n\\n\\n`Question:` After merging nums2 in nums1 when i tried using the inbuilt function of javascript `sort()` \\n `nums1.sort();`\\nThis break on the above mentioned input I don\\'t understand why??  \\n\\n`Solution : ` The solution i come up with was  `nums1.sort((a, b) => a - b);` \\nThis sort function subtracts b from a, which determines the sorting order. If the result is negative, a is placed before b, if the result is positive, b is placed before a, and if the result is zero, the order remains unchanged."
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "if( nums1[p1] > nums2[p2]  && p1 >= 0 ) # statement first ( run time error )\\nif( p1 >= 0 && nums1[p1] > nums2[p2] ) # statement second ( accepted )\\n\\nWhat is the different between above statements  ?? \\n"
                    },
                    {
                        "username": "blandprix",
                        "content": "[@Dev_Engg](/Dev_Engg) ah, interesting. Glad you got to the bottom of it!"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "[@blandprix](/blandprix) \\nI got the ans, >>>  the main difference between the two statements lies in the order of evaluation. The second statement checks the validity of the index p1 first before attempting to access nums1[p1], making it safer and preventing potential runtime errors. The first statement, however, has the potential to cause a runtime error if p1 is not a valid index for nums1."
                    },
                    {
                        "username": "blandprix",
                        "content": "perhaps the second case passes because `p1 >= 0` is always false, so it is short-circuiting the evaluation of your condition, i.e., `nums1[p1] > nums2[p2]` is never evaluated."
                    },
                    {
                        "username": "Fyr1981",
                        "content": "My solution works on my computer, but it does not work on this site, although it is logically correct. the site just returns [1,2,2,0,0,0], is this a bad site or what?"
                    },
                    {
                        "username": "blandprix",
                        "content": "Check out my tip about mutating nums1 https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "your solution not evaluate for different test cases \\n"
                    },
                    {
                        "username": "user6335T",
                        "content": "Though any other compilers gave me the expected output, but when i ran my code using Leetcode compilers always gives me different output.\\nthe test case is nums1 = [0] and nums2 = [1] and expected output is [1], but in leetcode it always gives me [0]. WHY?\\n\\nhere is my code:\\nhttps://replit.com/@IyanTRICKSTER/Merge-two-sorted-array#index.js"
                    },
                    {
                        "username": "vaibhav83porwal",
                        "content": "When I am printing my result it is giving [1, 2, 2, 3, 5, 6] in Stdout. But in the Output it is showing [1,2,3,0,0,0]. Why is it so?"
                    },
                    {
                        "username": "blandprix",
                        "content": "Check out my tip about mutating nums1 https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    },
                    {
                        "username": "Suresh__11",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    let newArr=[]\\n    for (let index = 0; index < m; index++) {\\n        newArr.push(nums1[index])\\n        \\n    }\\n    for (let index = 0; index < n; index++) {\\n        newArr.push(nums2[index])\\n        \\n    }\\n    newArr.sort()\\n    nums1=newArr\\n    console.log(nums1)\\n    \\n};\\nmerge([1,2,3,0,0,0],4,[2,5,6],3)    Anyone can explain me why this doesn\\'t work? It\\'s giving the output as described in the question."
                    },
                    {
                        "username": "blandprix",
                        "content": "I had the same problem. Posted a tip about it: https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    }
                ]
            },
            {
                "id": 1980909,
                "content": [
                    {
                        "username": "amansingh4958",
                        "content": "Cheat Code for this particular question with such constraints :\n```\n void merge(vector<int>& arr1, int n, vector<int>& arr2, int m) {\n        for (int i = 0; i < m; i++)\n            arr1[n + i] = arr2[i];\n        sort(arr1.begin(), arr1.end());\n }\n```\nBeats 100%\n**TC:** O(m) + O((m+n)log(m+n)) (i guess)\n**SC:** O(1)"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@georgezakharov](/georgezakharov) I\\'m really sorry if the above code hurt you because of having a tag \\'Tip\\'. Please forgive me.\\n\\n(I thought this code would seem funny to others)\\nAnyways, have a great day"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@amansingh4958](/amansingh4958) Then how it supposed to be a tip? :)"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@georgezakharov](/georgezakharov) Bro no one is gonna use such type of solution that\\'s why I posted it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you, but it is not a tip.\\nHave you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "Bhanu1146",
                        "content": "In java\\nI used System.out.println(nums2[0]);\\n\\njava.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0\\n  at line 5, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n      \\nbut same code work well on other compilers."
                    },
                    {
                        "username": "kumawatarun8989",
                        "content": "what the ques. ask to me im new to coding"
                    },
                    {
                        "username": "Obl1Que",
                        "content": " `nums1 = (nums1[:m] + nums2)`\\n `nums1.sort()`\\n `return nums1`\\n\\nWhy my code doesn\\'t works?"
                    },
                    {
                        "username": "arodmcmxcix",
                        "content": "Same issue on my end. I realize when we do nums1 + nums2 this creates a new pointer (a new list) which we reassign to nums1. We are supposed to do it in place. i.e. do not re assign nums1 to a new pointer. "
                    },
                    {
                        "username": "iammuqeetahmad",
                        "content": "`nums1 =[-10,-10,-9,-9,-9,-8,-8,-7,-7,-7,-6,-6,-6,-6,-6,-6,-6,-5,-5,-5,-4,-4,-4,-3,-3,-2,-2,-1,-1,0,1,1,1,2,2,2,3,3,3,4,5,5,6,6,6,6,7,7,7,7,8,9,9,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]`\\n\\n`m = 55`\\n\\n`nums2 = [-10,-10,-9,-9,-9,-9,-8,-8,-8,-8,-8,-7,-7,-7,-7,-7,-7,-7,-7,-6,-6,-6,-6,-5,-5,-5,-5,-5,-4,-4,-4,-4,-4,-3,-3,-3,-2,-2,-2,-2,-2,-2,-2,-1,-1,-1,0,0,0,0,0,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,4,4,4,4,4,4,4,5,5,5,5,5,5,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,9,9,9,9]`\\n\\n`n = 99`\\n\\n`Tip:` Don\\'t get confuse by m = 55 and n = 99 wheree the nums1 array looks bigger then nums2 array and m represents the number of values in nums1. As in nums1 the m represents only the starting m values rest are all the 0 which are for merging the nums2 in nums1.\\n\\n\\n`Question:` After merging nums2 in nums1 when i tried using the inbuilt function of javascript `sort()` \\n `nums1.sort();`\\nThis break on the above mentioned input I don\\'t understand why??  \\n\\n`Solution : ` The solution i come up with was  `nums1.sort((a, b) => a - b);` \\nThis sort function subtracts b from a, which determines the sorting order. If the result is negative, a is placed before b, if the result is positive, b is placed before a, and if the result is zero, the order remains unchanged."
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "if( nums1[p1] > nums2[p2]  && p1 >= 0 ) # statement first ( run time error )\\nif( p1 >= 0 && nums1[p1] > nums2[p2] ) # statement second ( accepted )\\n\\nWhat is the different between above statements  ?? \\n"
                    },
                    {
                        "username": "blandprix",
                        "content": "[@Dev_Engg](/Dev_Engg) ah, interesting. Glad you got to the bottom of it!"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "[@blandprix](/blandprix) \\nI got the ans, >>>  the main difference between the two statements lies in the order of evaluation. The second statement checks the validity of the index p1 first before attempting to access nums1[p1], making it safer and preventing potential runtime errors. The first statement, however, has the potential to cause a runtime error if p1 is not a valid index for nums1."
                    },
                    {
                        "username": "blandprix",
                        "content": "perhaps the second case passes because `p1 >= 0` is always false, so it is short-circuiting the evaluation of your condition, i.e., `nums1[p1] > nums2[p2]` is never evaluated."
                    },
                    {
                        "username": "Fyr1981",
                        "content": "My solution works on my computer, but it does not work on this site, although it is logically correct. the site just returns [1,2,2,0,0,0], is this a bad site or what?"
                    },
                    {
                        "username": "blandprix",
                        "content": "Check out my tip about mutating nums1 https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "your solution not evaluate for different test cases \\n"
                    },
                    {
                        "username": "user6335T",
                        "content": "Though any other compilers gave me the expected output, but when i ran my code using Leetcode compilers always gives me different output.\\nthe test case is nums1 = [0] and nums2 = [1] and expected output is [1], but in leetcode it always gives me [0]. WHY?\\n\\nhere is my code:\\nhttps://replit.com/@IyanTRICKSTER/Merge-two-sorted-array#index.js"
                    },
                    {
                        "username": "vaibhav83porwal",
                        "content": "When I am printing my result it is giving [1, 2, 2, 3, 5, 6] in Stdout. But in the Output it is showing [1,2,3,0,0,0]. Why is it so?"
                    },
                    {
                        "username": "blandprix",
                        "content": "Check out my tip about mutating nums1 https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    },
                    {
                        "username": "Suresh__11",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    let newArr=[]\\n    for (let index = 0; index < m; index++) {\\n        newArr.push(nums1[index])\\n        \\n    }\\n    for (let index = 0; index < n; index++) {\\n        newArr.push(nums2[index])\\n        \\n    }\\n    newArr.sort()\\n    nums1=newArr\\n    console.log(nums1)\\n    \\n};\\nmerge([1,2,3,0,0,0],4,[2,5,6],3)    Anyone can explain me why this doesn\\'t work? It\\'s giving the output as described in the question."
                    },
                    {
                        "username": "blandprix",
                        "content": "I had the same problem. Posted a tip about it: https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    }
                ]
            },
            {
                "id": 1973414,
                "content": [
                    {
                        "username": "amansingh4958",
                        "content": "Cheat Code for this particular question with such constraints :\n```\n void merge(vector<int>& arr1, int n, vector<int>& arr2, int m) {\n        for (int i = 0; i < m; i++)\n            arr1[n + i] = arr2[i];\n        sort(arr1.begin(), arr1.end());\n }\n```\nBeats 100%\n**TC:** O(m) + O((m+n)log(m+n)) (i guess)\n**SC:** O(1)"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@georgezakharov](/georgezakharov) I\\'m really sorry if the above code hurt you because of having a tag \\'Tip\\'. Please forgive me.\\n\\n(I thought this code would seem funny to others)\\nAnyways, have a great day"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@amansingh4958](/amansingh4958) Then how it supposed to be a tip? :)"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@georgezakharov](/georgezakharov) Bro no one is gonna use such type of solution that\\'s why I posted it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you, but it is not a tip.\\nHave you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "Bhanu1146",
                        "content": "In java\\nI used System.out.println(nums2[0]);\\n\\njava.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0\\n  at line 5, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n      \\nbut same code work well on other compilers."
                    },
                    {
                        "username": "kumawatarun8989",
                        "content": "what the ques. ask to me im new to coding"
                    },
                    {
                        "username": "Obl1Que",
                        "content": " `nums1 = (nums1[:m] + nums2)`\\n `nums1.sort()`\\n `return nums1`\\n\\nWhy my code doesn\\'t works?"
                    },
                    {
                        "username": "arodmcmxcix",
                        "content": "Same issue on my end. I realize when we do nums1 + nums2 this creates a new pointer (a new list) which we reassign to nums1. We are supposed to do it in place. i.e. do not re assign nums1 to a new pointer. "
                    },
                    {
                        "username": "iammuqeetahmad",
                        "content": "`nums1 =[-10,-10,-9,-9,-9,-8,-8,-7,-7,-7,-6,-6,-6,-6,-6,-6,-6,-5,-5,-5,-4,-4,-4,-3,-3,-2,-2,-1,-1,0,1,1,1,2,2,2,3,3,3,4,5,5,6,6,6,6,7,7,7,7,8,9,9,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]`\\n\\n`m = 55`\\n\\n`nums2 = [-10,-10,-9,-9,-9,-9,-8,-8,-8,-8,-8,-7,-7,-7,-7,-7,-7,-7,-7,-6,-6,-6,-6,-5,-5,-5,-5,-5,-4,-4,-4,-4,-4,-3,-3,-3,-2,-2,-2,-2,-2,-2,-2,-1,-1,-1,0,0,0,0,0,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,4,4,4,4,4,4,4,5,5,5,5,5,5,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,9,9,9,9]`\\n\\n`n = 99`\\n\\n`Tip:` Don\\'t get confuse by m = 55 and n = 99 wheree the nums1 array looks bigger then nums2 array and m represents the number of values in nums1. As in nums1 the m represents only the starting m values rest are all the 0 which are for merging the nums2 in nums1.\\n\\n\\n`Question:` After merging nums2 in nums1 when i tried using the inbuilt function of javascript `sort()` \\n `nums1.sort();`\\nThis break on the above mentioned input I don\\'t understand why??  \\n\\n`Solution : ` The solution i come up with was  `nums1.sort((a, b) => a - b);` \\nThis sort function subtracts b from a, which determines the sorting order. If the result is negative, a is placed before b, if the result is positive, b is placed before a, and if the result is zero, the order remains unchanged."
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "if( nums1[p1] > nums2[p2]  && p1 >= 0 ) # statement first ( run time error )\\nif( p1 >= 0 && nums1[p1] > nums2[p2] ) # statement second ( accepted )\\n\\nWhat is the different between above statements  ?? \\n"
                    },
                    {
                        "username": "blandprix",
                        "content": "[@Dev_Engg](/Dev_Engg) ah, interesting. Glad you got to the bottom of it!"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "[@blandprix](/blandprix) \\nI got the ans, >>>  the main difference between the two statements lies in the order of evaluation. The second statement checks the validity of the index p1 first before attempting to access nums1[p1], making it safer and preventing potential runtime errors. The first statement, however, has the potential to cause a runtime error if p1 is not a valid index for nums1."
                    },
                    {
                        "username": "blandprix",
                        "content": "perhaps the second case passes because `p1 >= 0` is always false, so it is short-circuiting the evaluation of your condition, i.e., `nums1[p1] > nums2[p2]` is never evaluated."
                    },
                    {
                        "username": "Fyr1981",
                        "content": "My solution works on my computer, but it does not work on this site, although it is logically correct. the site just returns [1,2,2,0,0,0], is this a bad site or what?"
                    },
                    {
                        "username": "blandprix",
                        "content": "Check out my tip about mutating nums1 https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "your solution not evaluate for different test cases \\n"
                    },
                    {
                        "username": "user6335T",
                        "content": "Though any other compilers gave me the expected output, but when i ran my code using Leetcode compilers always gives me different output.\\nthe test case is nums1 = [0] and nums2 = [1] and expected output is [1], but in leetcode it always gives me [0]. WHY?\\n\\nhere is my code:\\nhttps://replit.com/@IyanTRICKSTER/Merge-two-sorted-array#index.js"
                    },
                    {
                        "username": "vaibhav83porwal",
                        "content": "When I am printing my result it is giving [1, 2, 2, 3, 5, 6] in Stdout. But in the Output it is showing [1,2,3,0,0,0]. Why is it so?"
                    },
                    {
                        "username": "blandprix",
                        "content": "Check out my tip about mutating nums1 https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    },
                    {
                        "username": "Suresh__11",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    let newArr=[]\\n    for (let index = 0; index < m; index++) {\\n        newArr.push(nums1[index])\\n        \\n    }\\n    for (let index = 0; index < n; index++) {\\n        newArr.push(nums2[index])\\n        \\n    }\\n    newArr.sort()\\n    nums1=newArr\\n    console.log(nums1)\\n    \\n};\\nmerge([1,2,3,0,0,0],4,[2,5,6],3)    Anyone can explain me why this doesn\\'t work? It\\'s giving the output as described in the question."
                    },
                    {
                        "username": "blandprix",
                        "content": "I had the same problem. Posted a tip about it: https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    }
                ]
            },
            {
                "id": 1972976,
                "content": [
                    {
                        "username": "amansingh4958",
                        "content": "Cheat Code for this particular question with such constraints :\n```\n void merge(vector<int>& arr1, int n, vector<int>& arr2, int m) {\n        for (int i = 0; i < m; i++)\n            arr1[n + i] = arr2[i];\n        sort(arr1.begin(), arr1.end());\n }\n```\nBeats 100%\n**TC:** O(m) + O((m+n)log(m+n)) (i guess)\n**SC:** O(1)"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@georgezakharov](/georgezakharov) I\\'m really sorry if the above code hurt you because of having a tag \\'Tip\\'. Please forgive me.\\n\\n(I thought this code would seem funny to others)\\nAnyways, have a great day"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@amansingh4958](/amansingh4958) Then how it supposed to be a tip? :)"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@georgezakharov](/georgezakharov) Bro no one is gonna use such type of solution that\\'s why I posted it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you, but it is not a tip.\\nHave you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "Bhanu1146",
                        "content": "In java\\nI used System.out.println(nums2[0]);\\n\\njava.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0\\n  at line 5, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n      \\nbut same code work well on other compilers."
                    },
                    {
                        "username": "kumawatarun8989",
                        "content": "what the ques. ask to me im new to coding"
                    },
                    {
                        "username": "Obl1Que",
                        "content": " `nums1 = (nums1[:m] + nums2)`\\n `nums1.sort()`\\n `return nums1`\\n\\nWhy my code doesn\\'t works?"
                    },
                    {
                        "username": "arodmcmxcix",
                        "content": "Same issue on my end. I realize when we do nums1 + nums2 this creates a new pointer (a new list) which we reassign to nums1. We are supposed to do it in place. i.e. do not re assign nums1 to a new pointer. "
                    },
                    {
                        "username": "iammuqeetahmad",
                        "content": "`nums1 =[-10,-10,-9,-9,-9,-8,-8,-7,-7,-7,-6,-6,-6,-6,-6,-6,-6,-5,-5,-5,-4,-4,-4,-3,-3,-2,-2,-1,-1,0,1,1,1,2,2,2,3,3,3,4,5,5,6,6,6,6,7,7,7,7,8,9,9,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]`\\n\\n`m = 55`\\n\\n`nums2 = [-10,-10,-9,-9,-9,-9,-8,-8,-8,-8,-8,-7,-7,-7,-7,-7,-7,-7,-7,-6,-6,-6,-6,-5,-5,-5,-5,-5,-4,-4,-4,-4,-4,-3,-3,-3,-2,-2,-2,-2,-2,-2,-2,-1,-1,-1,0,0,0,0,0,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,4,4,4,4,4,4,4,5,5,5,5,5,5,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,9,9,9,9]`\\n\\n`n = 99`\\n\\n`Tip:` Don\\'t get confuse by m = 55 and n = 99 wheree the nums1 array looks bigger then nums2 array and m represents the number of values in nums1. As in nums1 the m represents only the starting m values rest are all the 0 which are for merging the nums2 in nums1.\\n\\n\\n`Question:` After merging nums2 in nums1 when i tried using the inbuilt function of javascript `sort()` \\n `nums1.sort();`\\nThis break on the above mentioned input I don\\'t understand why??  \\n\\n`Solution : ` The solution i come up with was  `nums1.sort((a, b) => a - b);` \\nThis sort function subtracts b from a, which determines the sorting order. If the result is negative, a is placed before b, if the result is positive, b is placed before a, and if the result is zero, the order remains unchanged."
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "if( nums1[p1] > nums2[p2]  && p1 >= 0 ) # statement first ( run time error )\\nif( p1 >= 0 && nums1[p1] > nums2[p2] ) # statement second ( accepted )\\n\\nWhat is the different between above statements  ?? \\n"
                    },
                    {
                        "username": "blandprix",
                        "content": "[@Dev_Engg](/Dev_Engg) ah, interesting. Glad you got to the bottom of it!"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "[@blandprix](/blandprix) \\nI got the ans, >>>  the main difference between the two statements lies in the order of evaluation. The second statement checks the validity of the index p1 first before attempting to access nums1[p1], making it safer and preventing potential runtime errors. The first statement, however, has the potential to cause a runtime error if p1 is not a valid index for nums1."
                    },
                    {
                        "username": "blandprix",
                        "content": "perhaps the second case passes because `p1 >= 0` is always false, so it is short-circuiting the evaluation of your condition, i.e., `nums1[p1] > nums2[p2]` is never evaluated."
                    },
                    {
                        "username": "Fyr1981",
                        "content": "My solution works on my computer, but it does not work on this site, although it is logically correct. the site just returns [1,2,2,0,0,0], is this a bad site or what?"
                    },
                    {
                        "username": "blandprix",
                        "content": "Check out my tip about mutating nums1 https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "your solution not evaluate for different test cases \\n"
                    },
                    {
                        "username": "user6335T",
                        "content": "Though any other compilers gave me the expected output, but when i ran my code using Leetcode compilers always gives me different output.\\nthe test case is nums1 = [0] and nums2 = [1] and expected output is [1], but in leetcode it always gives me [0]. WHY?\\n\\nhere is my code:\\nhttps://replit.com/@IyanTRICKSTER/Merge-two-sorted-array#index.js"
                    },
                    {
                        "username": "vaibhav83porwal",
                        "content": "When I am printing my result it is giving [1, 2, 2, 3, 5, 6] in Stdout. But in the Output it is showing [1,2,3,0,0,0]. Why is it so?"
                    },
                    {
                        "username": "blandprix",
                        "content": "Check out my tip about mutating nums1 https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    },
                    {
                        "username": "Suresh__11",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    let newArr=[]\\n    for (let index = 0; index < m; index++) {\\n        newArr.push(nums1[index])\\n        \\n    }\\n    for (let index = 0; index < n; index++) {\\n        newArr.push(nums2[index])\\n        \\n    }\\n    newArr.sort()\\n    nums1=newArr\\n    console.log(nums1)\\n    \\n};\\nmerge([1,2,3,0,0,0],4,[2,5,6],3)    Anyone can explain me why this doesn\\'t work? It\\'s giving the output as described in the question."
                    },
                    {
                        "username": "blandprix",
                        "content": "I had the same problem. Posted a tip about it: https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    }
                ]
            },
            {
                "id": 1971463,
                "content": [
                    {
                        "username": "amansingh4958",
                        "content": "Cheat Code for this particular question with such constraints :\n```\n void merge(vector<int>& arr1, int n, vector<int>& arr2, int m) {\n        for (int i = 0; i < m; i++)\n            arr1[n + i] = arr2[i];\n        sort(arr1.begin(), arr1.end());\n }\n```\nBeats 100%\n**TC:** O(m) + O((m+n)log(m+n)) (i guess)\n**SC:** O(1)"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@georgezakharov](/georgezakharov) I\\'m really sorry if the above code hurt you because of having a tag \\'Tip\\'. Please forgive me.\\n\\n(I thought this code would seem funny to others)\\nAnyways, have a great day"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@amansingh4958](/amansingh4958) Then how it supposed to be a tip? :)"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@georgezakharov](/georgezakharov) Bro no one is gonna use such type of solution that\\'s why I posted it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you, but it is not a tip.\\nHave you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "Bhanu1146",
                        "content": "In java\\nI used System.out.println(nums2[0]);\\n\\njava.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0\\n  at line 5, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n      \\nbut same code work well on other compilers."
                    },
                    {
                        "username": "kumawatarun8989",
                        "content": "what the ques. ask to me im new to coding"
                    },
                    {
                        "username": "Obl1Que",
                        "content": " `nums1 = (nums1[:m] + nums2)`\\n `nums1.sort()`\\n `return nums1`\\n\\nWhy my code doesn\\'t works?"
                    },
                    {
                        "username": "arodmcmxcix",
                        "content": "Same issue on my end. I realize when we do nums1 + nums2 this creates a new pointer (a new list) which we reassign to nums1. We are supposed to do it in place. i.e. do not re assign nums1 to a new pointer. "
                    },
                    {
                        "username": "iammuqeetahmad",
                        "content": "`nums1 =[-10,-10,-9,-9,-9,-8,-8,-7,-7,-7,-6,-6,-6,-6,-6,-6,-6,-5,-5,-5,-4,-4,-4,-3,-3,-2,-2,-1,-1,0,1,1,1,2,2,2,3,3,3,4,5,5,6,6,6,6,7,7,7,7,8,9,9,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]`\\n\\n`m = 55`\\n\\n`nums2 = [-10,-10,-9,-9,-9,-9,-8,-8,-8,-8,-8,-7,-7,-7,-7,-7,-7,-7,-7,-6,-6,-6,-6,-5,-5,-5,-5,-5,-4,-4,-4,-4,-4,-3,-3,-3,-2,-2,-2,-2,-2,-2,-2,-1,-1,-1,0,0,0,0,0,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,4,4,4,4,4,4,4,5,5,5,5,5,5,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,9,9,9,9]`\\n\\n`n = 99`\\n\\n`Tip:` Don\\'t get confuse by m = 55 and n = 99 wheree the nums1 array looks bigger then nums2 array and m represents the number of values in nums1. As in nums1 the m represents only the starting m values rest are all the 0 which are for merging the nums2 in nums1.\\n\\n\\n`Question:` After merging nums2 in nums1 when i tried using the inbuilt function of javascript `sort()` \\n `nums1.sort();`\\nThis break on the above mentioned input I don\\'t understand why??  \\n\\n`Solution : ` The solution i come up with was  `nums1.sort((a, b) => a - b);` \\nThis sort function subtracts b from a, which determines the sorting order. If the result is negative, a is placed before b, if the result is positive, b is placed before a, and if the result is zero, the order remains unchanged."
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "if( nums1[p1] > nums2[p2]  && p1 >= 0 ) # statement first ( run time error )\\nif( p1 >= 0 && nums1[p1] > nums2[p2] ) # statement second ( accepted )\\n\\nWhat is the different between above statements  ?? \\n"
                    },
                    {
                        "username": "blandprix",
                        "content": "[@Dev_Engg](/Dev_Engg) ah, interesting. Glad you got to the bottom of it!"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "[@blandprix](/blandprix) \\nI got the ans, >>>  the main difference between the two statements lies in the order of evaluation. The second statement checks the validity of the index p1 first before attempting to access nums1[p1], making it safer and preventing potential runtime errors. The first statement, however, has the potential to cause a runtime error if p1 is not a valid index for nums1."
                    },
                    {
                        "username": "blandprix",
                        "content": "perhaps the second case passes because `p1 >= 0` is always false, so it is short-circuiting the evaluation of your condition, i.e., `nums1[p1] > nums2[p2]` is never evaluated."
                    },
                    {
                        "username": "Fyr1981",
                        "content": "My solution works on my computer, but it does not work on this site, although it is logically correct. the site just returns [1,2,2,0,0,0], is this a bad site or what?"
                    },
                    {
                        "username": "blandprix",
                        "content": "Check out my tip about mutating nums1 https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "your solution not evaluate for different test cases \\n"
                    },
                    {
                        "username": "user6335T",
                        "content": "Though any other compilers gave me the expected output, but when i ran my code using Leetcode compilers always gives me different output.\\nthe test case is nums1 = [0] and nums2 = [1] and expected output is [1], but in leetcode it always gives me [0]. WHY?\\n\\nhere is my code:\\nhttps://replit.com/@IyanTRICKSTER/Merge-two-sorted-array#index.js"
                    },
                    {
                        "username": "vaibhav83porwal",
                        "content": "When I am printing my result it is giving [1, 2, 2, 3, 5, 6] in Stdout. But in the Output it is showing [1,2,3,0,0,0]. Why is it so?"
                    },
                    {
                        "username": "blandprix",
                        "content": "Check out my tip about mutating nums1 https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    },
                    {
                        "username": "Suresh__11",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    let newArr=[]\\n    for (let index = 0; index < m; index++) {\\n        newArr.push(nums1[index])\\n        \\n    }\\n    for (let index = 0; index < n; index++) {\\n        newArr.push(nums2[index])\\n        \\n    }\\n    newArr.sort()\\n    nums1=newArr\\n    console.log(nums1)\\n    \\n};\\nmerge([1,2,3,0,0,0],4,[2,5,6],3)    Anyone can explain me why this doesn\\'t work? It\\'s giving the output as described in the question."
                    },
                    {
                        "username": "blandprix",
                        "content": "I had the same problem. Posted a tip about it: https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    }
                ]
            },
            {
                "id": 1971057,
                "content": [
                    {
                        "username": "amansingh4958",
                        "content": "Cheat Code for this particular question with such constraints :\n```\n void merge(vector<int>& arr1, int n, vector<int>& arr2, int m) {\n        for (int i = 0; i < m; i++)\n            arr1[n + i] = arr2[i];\n        sort(arr1.begin(), arr1.end());\n }\n```\nBeats 100%\n**TC:** O(m) + O((m+n)log(m+n)) (i guess)\n**SC:** O(1)"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@georgezakharov](/georgezakharov) I\\'m really sorry if the above code hurt you because of having a tag \\'Tip\\'. Please forgive me.\\n\\n(I thought this code would seem funny to others)\\nAnyways, have a great day"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@amansingh4958](/amansingh4958) Then how it supposed to be a tip? :)"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@georgezakharov](/georgezakharov) Bro no one is gonna use such type of solution that\\'s why I posted it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you, but it is not a tip.\\nHave you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "Bhanu1146",
                        "content": "In java\\nI used System.out.println(nums2[0]);\\n\\njava.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0\\n  at line 5, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n      \\nbut same code work well on other compilers."
                    },
                    {
                        "username": "kumawatarun8989",
                        "content": "what the ques. ask to me im new to coding"
                    },
                    {
                        "username": "Obl1Que",
                        "content": " `nums1 = (nums1[:m] + nums2)`\\n `nums1.sort()`\\n `return nums1`\\n\\nWhy my code doesn\\'t works?"
                    },
                    {
                        "username": "arodmcmxcix",
                        "content": "Same issue on my end. I realize when we do nums1 + nums2 this creates a new pointer (a new list) which we reassign to nums1. We are supposed to do it in place. i.e. do not re assign nums1 to a new pointer. "
                    },
                    {
                        "username": "iammuqeetahmad",
                        "content": "`nums1 =[-10,-10,-9,-9,-9,-8,-8,-7,-7,-7,-6,-6,-6,-6,-6,-6,-6,-5,-5,-5,-4,-4,-4,-3,-3,-2,-2,-1,-1,0,1,1,1,2,2,2,3,3,3,4,5,5,6,6,6,6,7,7,7,7,8,9,9,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]`\\n\\n`m = 55`\\n\\n`nums2 = [-10,-10,-9,-9,-9,-9,-8,-8,-8,-8,-8,-7,-7,-7,-7,-7,-7,-7,-7,-6,-6,-6,-6,-5,-5,-5,-5,-5,-4,-4,-4,-4,-4,-3,-3,-3,-2,-2,-2,-2,-2,-2,-2,-1,-1,-1,0,0,0,0,0,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,4,4,4,4,4,4,4,5,5,5,5,5,5,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,9,9,9,9]`\\n\\n`n = 99`\\n\\n`Tip:` Don\\'t get confuse by m = 55 and n = 99 wheree the nums1 array looks bigger then nums2 array and m represents the number of values in nums1. As in nums1 the m represents only the starting m values rest are all the 0 which are for merging the nums2 in nums1.\\n\\n\\n`Question:` After merging nums2 in nums1 when i tried using the inbuilt function of javascript `sort()` \\n `nums1.sort();`\\nThis break on the above mentioned input I don\\'t understand why??  \\n\\n`Solution : ` The solution i come up with was  `nums1.sort((a, b) => a - b);` \\nThis sort function subtracts b from a, which determines the sorting order. If the result is negative, a is placed before b, if the result is positive, b is placed before a, and if the result is zero, the order remains unchanged."
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "if( nums1[p1] > nums2[p2]  && p1 >= 0 ) # statement first ( run time error )\\nif( p1 >= 0 && nums1[p1] > nums2[p2] ) # statement second ( accepted )\\n\\nWhat is the different between above statements  ?? \\n"
                    },
                    {
                        "username": "blandprix",
                        "content": "[@Dev_Engg](/Dev_Engg) ah, interesting. Glad you got to the bottom of it!"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "[@blandprix](/blandprix) \\nI got the ans, >>>  the main difference between the two statements lies in the order of evaluation. The second statement checks the validity of the index p1 first before attempting to access nums1[p1], making it safer and preventing potential runtime errors. The first statement, however, has the potential to cause a runtime error if p1 is not a valid index for nums1."
                    },
                    {
                        "username": "blandprix",
                        "content": "perhaps the second case passes because `p1 >= 0` is always false, so it is short-circuiting the evaluation of your condition, i.e., `nums1[p1] > nums2[p2]` is never evaluated."
                    },
                    {
                        "username": "Fyr1981",
                        "content": "My solution works on my computer, but it does not work on this site, although it is logically correct. the site just returns [1,2,2,0,0,0], is this a bad site or what?"
                    },
                    {
                        "username": "blandprix",
                        "content": "Check out my tip about mutating nums1 https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "your solution not evaluate for different test cases \\n"
                    },
                    {
                        "username": "user6335T",
                        "content": "Though any other compilers gave me the expected output, but when i ran my code using Leetcode compilers always gives me different output.\\nthe test case is nums1 = [0] and nums2 = [1] and expected output is [1], but in leetcode it always gives me [0]. WHY?\\n\\nhere is my code:\\nhttps://replit.com/@IyanTRICKSTER/Merge-two-sorted-array#index.js"
                    },
                    {
                        "username": "vaibhav83porwal",
                        "content": "When I am printing my result it is giving [1, 2, 2, 3, 5, 6] in Stdout. But in the Output it is showing [1,2,3,0,0,0]. Why is it so?"
                    },
                    {
                        "username": "blandprix",
                        "content": "Check out my tip about mutating nums1 https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    },
                    {
                        "username": "Suresh__11",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    let newArr=[]\\n    for (let index = 0; index < m; index++) {\\n        newArr.push(nums1[index])\\n        \\n    }\\n    for (let index = 0; index < n; index++) {\\n        newArr.push(nums2[index])\\n        \\n    }\\n    newArr.sort()\\n    nums1=newArr\\n    console.log(nums1)\\n    \\n};\\nmerge([1,2,3,0,0,0],4,[2,5,6],3)    Anyone can explain me why this doesn\\'t work? It\\'s giving the output as described in the question."
                    },
                    {
                        "username": "blandprix",
                        "content": "I had the same problem. Posted a tip about it: https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    }
                ]
            },
            {
                "id": 1970406,
                "content": [
                    {
                        "username": "amansingh4958",
                        "content": "Cheat Code for this particular question with such constraints :\n```\n void merge(vector<int>& arr1, int n, vector<int>& arr2, int m) {\n        for (int i = 0; i < m; i++)\n            arr1[n + i] = arr2[i];\n        sort(arr1.begin(), arr1.end());\n }\n```\nBeats 100%\n**TC:** O(m) + O((m+n)log(m+n)) (i guess)\n**SC:** O(1)"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@georgezakharov](/georgezakharov) I\\'m really sorry if the above code hurt you because of having a tag \\'Tip\\'. Please forgive me.\\n\\n(I thought this code would seem funny to others)\\nAnyways, have a great day"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@amansingh4958](/amansingh4958) Then how it supposed to be a tip? :)"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@georgezakharov](/georgezakharov) Bro no one is gonna use such type of solution that\\'s why I posted it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you, but it is not a tip.\\nHave you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "Bhanu1146",
                        "content": "In java\\nI used System.out.println(nums2[0]);\\n\\njava.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0\\n  at line 5, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n      \\nbut same code work well on other compilers."
                    },
                    {
                        "username": "kumawatarun8989",
                        "content": "what the ques. ask to me im new to coding"
                    },
                    {
                        "username": "Obl1Que",
                        "content": " `nums1 = (nums1[:m] + nums2)`\\n `nums1.sort()`\\n `return nums1`\\n\\nWhy my code doesn\\'t works?"
                    },
                    {
                        "username": "arodmcmxcix",
                        "content": "Same issue on my end. I realize when we do nums1 + nums2 this creates a new pointer (a new list) which we reassign to nums1. We are supposed to do it in place. i.e. do not re assign nums1 to a new pointer. "
                    },
                    {
                        "username": "iammuqeetahmad",
                        "content": "`nums1 =[-10,-10,-9,-9,-9,-8,-8,-7,-7,-7,-6,-6,-6,-6,-6,-6,-6,-5,-5,-5,-4,-4,-4,-3,-3,-2,-2,-1,-1,0,1,1,1,2,2,2,3,3,3,4,5,5,6,6,6,6,7,7,7,7,8,9,9,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]`\\n\\n`m = 55`\\n\\n`nums2 = [-10,-10,-9,-9,-9,-9,-8,-8,-8,-8,-8,-7,-7,-7,-7,-7,-7,-7,-7,-6,-6,-6,-6,-5,-5,-5,-5,-5,-4,-4,-4,-4,-4,-3,-3,-3,-2,-2,-2,-2,-2,-2,-2,-1,-1,-1,0,0,0,0,0,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,4,4,4,4,4,4,4,5,5,5,5,5,5,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,9,9,9,9]`\\n\\n`n = 99`\\n\\n`Tip:` Don\\'t get confuse by m = 55 and n = 99 wheree the nums1 array looks bigger then nums2 array and m represents the number of values in nums1. As in nums1 the m represents only the starting m values rest are all the 0 which are for merging the nums2 in nums1.\\n\\n\\n`Question:` After merging nums2 in nums1 when i tried using the inbuilt function of javascript `sort()` \\n `nums1.sort();`\\nThis break on the above mentioned input I don\\'t understand why??  \\n\\n`Solution : ` The solution i come up with was  `nums1.sort((a, b) => a - b);` \\nThis sort function subtracts b from a, which determines the sorting order. If the result is negative, a is placed before b, if the result is positive, b is placed before a, and if the result is zero, the order remains unchanged."
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "if( nums1[p1] > nums2[p2]  && p1 >= 0 ) # statement first ( run time error )\\nif( p1 >= 0 && nums1[p1] > nums2[p2] ) # statement second ( accepted )\\n\\nWhat is the different between above statements  ?? \\n"
                    },
                    {
                        "username": "blandprix",
                        "content": "[@Dev_Engg](/Dev_Engg) ah, interesting. Glad you got to the bottom of it!"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "[@blandprix](/blandprix) \\nI got the ans, >>>  the main difference between the two statements lies in the order of evaluation. The second statement checks the validity of the index p1 first before attempting to access nums1[p1], making it safer and preventing potential runtime errors. The first statement, however, has the potential to cause a runtime error if p1 is not a valid index for nums1."
                    },
                    {
                        "username": "blandprix",
                        "content": "perhaps the second case passes because `p1 >= 0` is always false, so it is short-circuiting the evaluation of your condition, i.e., `nums1[p1] > nums2[p2]` is never evaluated."
                    },
                    {
                        "username": "Fyr1981",
                        "content": "My solution works on my computer, but it does not work on this site, although it is logically correct. the site just returns [1,2,2,0,0,0], is this a bad site or what?"
                    },
                    {
                        "username": "blandprix",
                        "content": "Check out my tip about mutating nums1 https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "your solution not evaluate for different test cases \\n"
                    },
                    {
                        "username": "user6335T",
                        "content": "Though any other compilers gave me the expected output, but when i ran my code using Leetcode compilers always gives me different output.\\nthe test case is nums1 = [0] and nums2 = [1] and expected output is [1], but in leetcode it always gives me [0]. WHY?\\n\\nhere is my code:\\nhttps://replit.com/@IyanTRICKSTER/Merge-two-sorted-array#index.js"
                    },
                    {
                        "username": "vaibhav83porwal",
                        "content": "When I am printing my result it is giving [1, 2, 2, 3, 5, 6] in Stdout. But in the Output it is showing [1,2,3,0,0,0]. Why is it so?"
                    },
                    {
                        "username": "blandprix",
                        "content": "Check out my tip about mutating nums1 https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    },
                    {
                        "username": "Suresh__11",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    let newArr=[]\\n    for (let index = 0; index < m; index++) {\\n        newArr.push(nums1[index])\\n        \\n    }\\n    for (let index = 0; index < n; index++) {\\n        newArr.push(nums2[index])\\n        \\n    }\\n    newArr.sort()\\n    nums1=newArr\\n    console.log(nums1)\\n    \\n};\\nmerge([1,2,3,0,0,0],4,[2,5,6],3)    Anyone can explain me why this doesn\\'t work? It\\'s giving the output as described in the question."
                    },
                    {
                        "username": "blandprix",
                        "content": "I had the same problem. Posted a tip about it: https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    }
                ]
            },
            {
                "id": 1969803,
                "content": [
                    {
                        "username": "amansingh4958",
                        "content": "Cheat Code for this particular question with such constraints :\n```\n void merge(vector<int>& arr1, int n, vector<int>& arr2, int m) {\n        for (int i = 0; i < m; i++)\n            arr1[n + i] = arr2[i];\n        sort(arr1.begin(), arr1.end());\n }\n```\nBeats 100%\n**TC:** O(m) + O((m+n)log(m+n)) (i guess)\n**SC:** O(1)"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@georgezakharov](/georgezakharov) I\\'m really sorry if the above code hurt you because of having a tag \\'Tip\\'. Please forgive me.\\n\\n(I thought this code would seem funny to others)\\nAnyways, have a great day"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@amansingh4958](/amansingh4958) Then how it supposed to be a tip? :)"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@georgezakharov](/georgezakharov) Bro no one is gonna use such type of solution that\\'s why I posted it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you, but it is not a tip.\\nHave you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "Bhanu1146",
                        "content": "In java\\nI used System.out.println(nums2[0]);\\n\\njava.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0\\n  at line 5, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n      \\nbut same code work well on other compilers."
                    },
                    {
                        "username": "kumawatarun8989",
                        "content": "what the ques. ask to me im new to coding"
                    },
                    {
                        "username": "Obl1Que",
                        "content": " `nums1 = (nums1[:m] + nums2)`\\n `nums1.sort()`\\n `return nums1`\\n\\nWhy my code doesn\\'t works?"
                    },
                    {
                        "username": "arodmcmxcix",
                        "content": "Same issue on my end. I realize when we do nums1 + nums2 this creates a new pointer (a new list) which we reassign to nums1. We are supposed to do it in place. i.e. do not re assign nums1 to a new pointer. "
                    },
                    {
                        "username": "iammuqeetahmad",
                        "content": "`nums1 =[-10,-10,-9,-9,-9,-8,-8,-7,-7,-7,-6,-6,-6,-6,-6,-6,-6,-5,-5,-5,-4,-4,-4,-3,-3,-2,-2,-1,-1,0,1,1,1,2,2,2,3,3,3,4,5,5,6,6,6,6,7,7,7,7,8,9,9,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]`\\n\\n`m = 55`\\n\\n`nums2 = [-10,-10,-9,-9,-9,-9,-8,-8,-8,-8,-8,-7,-7,-7,-7,-7,-7,-7,-7,-6,-6,-6,-6,-5,-5,-5,-5,-5,-4,-4,-4,-4,-4,-3,-3,-3,-2,-2,-2,-2,-2,-2,-2,-1,-1,-1,0,0,0,0,0,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,4,4,4,4,4,4,4,5,5,5,5,5,5,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,9,9,9,9]`\\n\\n`n = 99`\\n\\n`Tip:` Don\\'t get confuse by m = 55 and n = 99 wheree the nums1 array looks bigger then nums2 array and m represents the number of values in nums1. As in nums1 the m represents only the starting m values rest are all the 0 which are for merging the nums2 in nums1.\\n\\n\\n`Question:` After merging nums2 in nums1 when i tried using the inbuilt function of javascript `sort()` \\n `nums1.sort();`\\nThis break on the above mentioned input I don\\'t understand why??  \\n\\n`Solution : ` The solution i come up with was  `nums1.sort((a, b) => a - b);` \\nThis sort function subtracts b from a, which determines the sorting order. If the result is negative, a is placed before b, if the result is positive, b is placed before a, and if the result is zero, the order remains unchanged."
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "if( nums1[p1] > nums2[p2]  && p1 >= 0 ) # statement first ( run time error )\\nif( p1 >= 0 && nums1[p1] > nums2[p2] ) # statement second ( accepted )\\n\\nWhat is the different between above statements  ?? \\n"
                    },
                    {
                        "username": "blandprix",
                        "content": "[@Dev_Engg](/Dev_Engg) ah, interesting. Glad you got to the bottom of it!"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "[@blandprix](/blandprix) \\nI got the ans, >>>  the main difference between the two statements lies in the order of evaluation. The second statement checks the validity of the index p1 first before attempting to access nums1[p1], making it safer and preventing potential runtime errors. The first statement, however, has the potential to cause a runtime error if p1 is not a valid index for nums1."
                    },
                    {
                        "username": "blandprix",
                        "content": "perhaps the second case passes because `p1 >= 0` is always false, so it is short-circuiting the evaluation of your condition, i.e., `nums1[p1] > nums2[p2]` is never evaluated."
                    },
                    {
                        "username": "Fyr1981",
                        "content": "My solution works on my computer, but it does not work on this site, although it is logically correct. the site just returns [1,2,2,0,0,0], is this a bad site or what?"
                    },
                    {
                        "username": "blandprix",
                        "content": "Check out my tip about mutating nums1 https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "your solution not evaluate for different test cases \\n"
                    },
                    {
                        "username": "user6335T",
                        "content": "Though any other compilers gave me the expected output, but when i ran my code using Leetcode compilers always gives me different output.\\nthe test case is nums1 = [0] and nums2 = [1] and expected output is [1], but in leetcode it always gives me [0]. WHY?\\n\\nhere is my code:\\nhttps://replit.com/@IyanTRICKSTER/Merge-two-sorted-array#index.js"
                    },
                    {
                        "username": "vaibhav83porwal",
                        "content": "When I am printing my result it is giving [1, 2, 2, 3, 5, 6] in Stdout. But in the Output it is showing [1,2,3,0,0,0]. Why is it so?"
                    },
                    {
                        "username": "blandprix",
                        "content": "Check out my tip about mutating nums1 https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    },
                    {
                        "username": "Suresh__11",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    let newArr=[]\\n    for (let index = 0; index < m; index++) {\\n        newArr.push(nums1[index])\\n        \\n    }\\n    for (let index = 0; index < n; index++) {\\n        newArr.push(nums2[index])\\n        \\n    }\\n    newArr.sort()\\n    nums1=newArr\\n    console.log(nums1)\\n    \\n};\\nmerge([1,2,3,0,0,0],4,[2,5,6],3)    Anyone can explain me why this doesn\\'t work? It\\'s giving the output as described in the question."
                    },
                    {
                        "username": "blandprix",
                        "content": "I had the same problem. Posted a tip about it: https://leetcode.com/problems/merge-sorted-array/description/comments/1968717"
                    }
                ]
            },
            {
                "id": 1969717,
                "content": [
                    {
                        "username": "venkateshnalla",
                        "content": "import java.util.*;\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n     ArrayList<Integer> al=new ArrayList<>();\n    \n      for(int i:nums1){\n          if(i!=0){\n              al.add(i);\n          }\n      }\n      for(int i:nums2){\n          if(i!=0){\n              al.add(i);\n          }\n      }\n   \n    Collections.sort(al);\n      System.out.println(al);\n    }\n}\ni did this but its not printing correct output \n"
                    },
                    {
                        "username": "blandprix",
                        "content": "The instructions specify that you need to modify nums1 in place, so returning a new variable is no good. I\\'m not sure of the best way to achieve this in Java, but at least I think you can modify the elements of nums1 by index, e.g. `nums1[0] = 7`"
                    },
                    {
                        "username": "Ankit9604",
                        "content": "What is wrong with this solution can anyone tell me please \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int k=m+n;\\n        int j=0;\\n        int l=0;\\n        for(int i=m;i<k;i++){\\n            nums1[i]=nums2[j];\\n            if(nums2[j]<nums1[l]){\\n             swap(nums1[i],nums1[l]);\\n             l++;\\n            }\\n            j++;\\n        }\\n\\n    }\\n}; \\n\\n\\nOutput\\n[1,2,3,2,5,6]  ??????\\nExpected\\n[1,2,2,3,5,6]"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 i think many of you didn\\'t noticed that the nums1 and nums2 are sorted"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "Hmm, is said \"Merge nums1 and nums2 into a single array sorted in non-decreasing order.\""
                    },
                    {
                        "username": "Keshavagr_273",
                        "content": "\\nimport java.util.Arrays;\\n\\npublic Solution {\\n    public static void merge(int[] nums1, int m, int[] nums2, int n){\\n        int[] ar =new int[m+n];\\n        for(int i=0;i<m;i++){\\n            ar[i]=nums1[i];\\n        }\\n        for(int i=m;i<m+n;i++){\\n            ar[i]=nums2[i-m];\\n        }\\n        Arrays.sort(ar);\\n        System.out.print(Arrays.toString(ar));\\n    }\\n    public static void main(String[] args){\\n        int[] nums1 ={0};\\n        int[] nums2 ={1};\\n        merge(nums1,0,nums2,1);\\n    }\\n}\\nwhen I am running this code in my laptop compiler it is giving [1] as expected but leetcode give [0] and says \"Wrong answer\". What is the problem. Which is wrong ?"
                    },
                    {
                        "username": "Samyun",
                        "content": "what is wrong in this logic, all test cases getting passed but getting wrong answer while submitting, why ?\\n public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i=m-1;\\n        int j=n-1;\\n        int k=m+n-1;\\n        while(i>=0 && j>=0) {\\n            if(nums1[i]>nums2[j]){\\n                nums1[k]=nums1[i];\\n                i--;\\n            } else {\\n                 nums1[k]=nums2[j];\\n                 j--;\\n            }\\n            k--;\\n        }\\n        if(j>=0) {\\n            nums1[k]=nums2[j];\\n            j--;\\n            k--;\\n        }\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why cant we make another another array and fill the element as per our need and why doesnt that work?\\n"
                    },
                    {
                        "username": "linpinto",
                        "content": "i tried doing this in PyCharm and it worked for all test cases but it doesn\\'t work here. Can someone explain why? \\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        tn1 = (nums1[:m])\\n        tn2 = (nums2[:n])\\n        tn1.extend(tn2)\\n        nums1 = sorted(tn1)"
                    },
                    {
                        "username": "linpinto",
                        "content": "[@Q3dlaXpoaQ](/Q3dlaXpoaQ) Thank you so much for the explanation!"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "I think it because \"nums1=sorted(tn1)\" let nums1 points to tn1. However, nums1 was didn\\'t change. So you can :\\nnums1.clear() \\nfor i in range(len(tn1)):\\n            nums1.append(tn1[i])"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "#include <algorithm>\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        vector<int> templist;\n        for(int i=0;i<m;i++){\n            templist.push_back(nums1[i]);\n        }\n        for(int i=0;i<n;i++){\n            templist.push_back(nums2[i]);\n        }\n        sort(templist.begin(),templist.end());\n        nums1.clear();\n        for(int i=0;i<templist.size();i++){\n            nums1.push_back(templist[i]);\n        }\n    }\n};\n\nWe can use 'sort' to solve it"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\nBut have you seen rule number 1 in Discussion section?\nIt says \"Please don't post any solutions in this discussion.\""
                    },
                    {
                        "username": "user2305qR",
                        "content": "Is the loop a must for this question?  Why I failed using slice (T_T)"
                    },
                    {
                        "username": "FrigMort",
                        "content": "Ok, I have trouble.\\nIt\\'s all my solution\\n `int[] result = nums1[0..(m)].Concat(nums2[0..(n)]).ToArray();`\\n `Array.Sort(result);`\\n\\nOutPut :\\nStdout\\n1\\n2\\n2\\n3\\n5\\n6\\nOutput\\n[1,2,3,0,0,0]\\nExpected\\n[1,2,2,3,5,6]\\n\\nWhy?  Or using system.linq forbidden?\\n\\n          "
                    }
                ]
            },
            {
                "id": 1969072,
                "content": [
                    {
                        "username": "venkateshnalla",
                        "content": "import java.util.*;\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n     ArrayList<Integer> al=new ArrayList<>();\n    \n      for(int i:nums1){\n          if(i!=0){\n              al.add(i);\n          }\n      }\n      for(int i:nums2){\n          if(i!=0){\n              al.add(i);\n          }\n      }\n   \n    Collections.sort(al);\n      System.out.println(al);\n    }\n}\ni did this but its not printing correct output \n"
                    },
                    {
                        "username": "blandprix",
                        "content": "The instructions specify that you need to modify nums1 in place, so returning a new variable is no good. I\\'m not sure of the best way to achieve this in Java, but at least I think you can modify the elements of nums1 by index, e.g. `nums1[0] = 7`"
                    },
                    {
                        "username": "Ankit9604",
                        "content": "What is wrong with this solution can anyone tell me please \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int k=m+n;\\n        int j=0;\\n        int l=0;\\n        for(int i=m;i<k;i++){\\n            nums1[i]=nums2[j];\\n            if(nums2[j]<nums1[l]){\\n             swap(nums1[i],nums1[l]);\\n             l++;\\n            }\\n            j++;\\n        }\\n\\n    }\\n}; \\n\\n\\nOutput\\n[1,2,3,2,5,6]  ??????\\nExpected\\n[1,2,2,3,5,6]"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 i think many of you didn\\'t noticed that the nums1 and nums2 are sorted"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "Hmm, is said \"Merge nums1 and nums2 into a single array sorted in non-decreasing order.\""
                    },
                    {
                        "username": "Keshavagr_273",
                        "content": "\\nimport java.util.Arrays;\\n\\npublic Solution {\\n    public static void merge(int[] nums1, int m, int[] nums2, int n){\\n        int[] ar =new int[m+n];\\n        for(int i=0;i<m;i++){\\n            ar[i]=nums1[i];\\n        }\\n        for(int i=m;i<m+n;i++){\\n            ar[i]=nums2[i-m];\\n        }\\n        Arrays.sort(ar);\\n        System.out.print(Arrays.toString(ar));\\n    }\\n    public static void main(String[] args){\\n        int[] nums1 ={0};\\n        int[] nums2 ={1};\\n        merge(nums1,0,nums2,1);\\n    }\\n}\\nwhen I am running this code in my laptop compiler it is giving [1] as expected but leetcode give [0] and says \"Wrong answer\". What is the problem. Which is wrong ?"
                    },
                    {
                        "username": "Samyun",
                        "content": "what is wrong in this logic, all test cases getting passed but getting wrong answer while submitting, why ?\\n public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i=m-1;\\n        int j=n-1;\\n        int k=m+n-1;\\n        while(i>=0 && j>=0) {\\n            if(nums1[i]>nums2[j]){\\n                nums1[k]=nums1[i];\\n                i--;\\n            } else {\\n                 nums1[k]=nums2[j];\\n                 j--;\\n            }\\n            k--;\\n        }\\n        if(j>=0) {\\n            nums1[k]=nums2[j];\\n            j--;\\n            k--;\\n        }\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why cant we make another another array and fill the element as per our need and why doesnt that work?\\n"
                    },
                    {
                        "username": "linpinto",
                        "content": "i tried doing this in PyCharm and it worked for all test cases but it doesn\\'t work here. Can someone explain why? \\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        tn1 = (nums1[:m])\\n        tn2 = (nums2[:n])\\n        tn1.extend(tn2)\\n        nums1 = sorted(tn1)"
                    },
                    {
                        "username": "linpinto",
                        "content": "[@Q3dlaXpoaQ](/Q3dlaXpoaQ) Thank you so much for the explanation!"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "I think it because \"nums1=sorted(tn1)\" let nums1 points to tn1. However, nums1 was didn\\'t change. So you can :\\nnums1.clear() \\nfor i in range(len(tn1)):\\n            nums1.append(tn1[i])"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "#include <algorithm>\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        vector<int> templist;\n        for(int i=0;i<m;i++){\n            templist.push_back(nums1[i]);\n        }\n        for(int i=0;i<n;i++){\n            templist.push_back(nums2[i]);\n        }\n        sort(templist.begin(),templist.end());\n        nums1.clear();\n        for(int i=0;i<templist.size();i++){\n            nums1.push_back(templist[i]);\n        }\n    }\n};\n\nWe can use 'sort' to solve it"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\nBut have you seen rule number 1 in Discussion section?\nIt says \"Please don't post any solutions in this discussion.\""
                    },
                    {
                        "username": "user2305qR",
                        "content": "Is the loop a must for this question?  Why I failed using slice (T_T)"
                    },
                    {
                        "username": "FrigMort",
                        "content": "Ok, I have trouble.\\nIt\\'s all my solution\\n `int[] result = nums1[0..(m)].Concat(nums2[0..(n)]).ToArray();`\\n `Array.Sort(result);`\\n\\nOutPut :\\nStdout\\n1\\n2\\n2\\n3\\n5\\n6\\nOutput\\n[1,2,3,0,0,0]\\nExpected\\n[1,2,2,3,5,6]\\n\\nWhy?  Or using system.linq forbidden?\\n\\n          "
                    }
                ]
            },
            {
                "id": 1965718,
                "content": [
                    {
                        "username": "venkateshnalla",
                        "content": "import java.util.*;\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n     ArrayList<Integer> al=new ArrayList<>();\n    \n      for(int i:nums1){\n          if(i!=0){\n              al.add(i);\n          }\n      }\n      for(int i:nums2){\n          if(i!=0){\n              al.add(i);\n          }\n      }\n   \n    Collections.sort(al);\n      System.out.println(al);\n    }\n}\ni did this but its not printing correct output \n"
                    },
                    {
                        "username": "blandprix",
                        "content": "The instructions specify that you need to modify nums1 in place, so returning a new variable is no good. I\\'m not sure of the best way to achieve this in Java, but at least I think you can modify the elements of nums1 by index, e.g. `nums1[0] = 7`"
                    },
                    {
                        "username": "Ankit9604",
                        "content": "What is wrong with this solution can anyone tell me please \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int k=m+n;\\n        int j=0;\\n        int l=0;\\n        for(int i=m;i<k;i++){\\n            nums1[i]=nums2[j];\\n            if(nums2[j]<nums1[l]){\\n             swap(nums1[i],nums1[l]);\\n             l++;\\n            }\\n            j++;\\n        }\\n\\n    }\\n}; \\n\\n\\nOutput\\n[1,2,3,2,5,6]  ??????\\nExpected\\n[1,2,2,3,5,6]"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 i think many of you didn\\'t noticed that the nums1 and nums2 are sorted"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "Hmm, is said \"Merge nums1 and nums2 into a single array sorted in non-decreasing order.\""
                    },
                    {
                        "username": "Keshavagr_273",
                        "content": "\\nimport java.util.Arrays;\\n\\npublic Solution {\\n    public static void merge(int[] nums1, int m, int[] nums2, int n){\\n        int[] ar =new int[m+n];\\n        for(int i=0;i<m;i++){\\n            ar[i]=nums1[i];\\n        }\\n        for(int i=m;i<m+n;i++){\\n            ar[i]=nums2[i-m];\\n        }\\n        Arrays.sort(ar);\\n        System.out.print(Arrays.toString(ar));\\n    }\\n    public static void main(String[] args){\\n        int[] nums1 ={0};\\n        int[] nums2 ={1};\\n        merge(nums1,0,nums2,1);\\n    }\\n}\\nwhen I am running this code in my laptop compiler it is giving [1] as expected but leetcode give [0] and says \"Wrong answer\". What is the problem. Which is wrong ?"
                    },
                    {
                        "username": "Samyun",
                        "content": "what is wrong in this logic, all test cases getting passed but getting wrong answer while submitting, why ?\\n public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i=m-1;\\n        int j=n-1;\\n        int k=m+n-1;\\n        while(i>=0 && j>=0) {\\n            if(nums1[i]>nums2[j]){\\n                nums1[k]=nums1[i];\\n                i--;\\n            } else {\\n                 nums1[k]=nums2[j];\\n                 j--;\\n            }\\n            k--;\\n        }\\n        if(j>=0) {\\n            nums1[k]=nums2[j];\\n            j--;\\n            k--;\\n        }\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why cant we make another another array and fill the element as per our need and why doesnt that work?\\n"
                    },
                    {
                        "username": "linpinto",
                        "content": "i tried doing this in PyCharm and it worked for all test cases but it doesn\\'t work here. Can someone explain why? \\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        tn1 = (nums1[:m])\\n        tn2 = (nums2[:n])\\n        tn1.extend(tn2)\\n        nums1 = sorted(tn1)"
                    },
                    {
                        "username": "linpinto",
                        "content": "[@Q3dlaXpoaQ](/Q3dlaXpoaQ) Thank you so much for the explanation!"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "I think it because \"nums1=sorted(tn1)\" let nums1 points to tn1. However, nums1 was didn\\'t change. So you can :\\nnums1.clear() \\nfor i in range(len(tn1)):\\n            nums1.append(tn1[i])"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "#include <algorithm>\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        vector<int> templist;\n        for(int i=0;i<m;i++){\n            templist.push_back(nums1[i]);\n        }\n        for(int i=0;i<n;i++){\n            templist.push_back(nums2[i]);\n        }\n        sort(templist.begin(),templist.end());\n        nums1.clear();\n        for(int i=0;i<templist.size();i++){\n            nums1.push_back(templist[i]);\n        }\n    }\n};\n\nWe can use 'sort' to solve it"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\nBut have you seen rule number 1 in Discussion section?\nIt says \"Please don't post any solutions in this discussion.\""
                    },
                    {
                        "username": "user2305qR",
                        "content": "Is the loop a must for this question?  Why I failed using slice (T_T)"
                    },
                    {
                        "username": "FrigMort",
                        "content": "Ok, I have trouble.\\nIt\\'s all my solution\\n `int[] result = nums1[0..(m)].Concat(nums2[0..(n)]).ToArray();`\\n `Array.Sort(result);`\\n\\nOutPut :\\nStdout\\n1\\n2\\n2\\n3\\n5\\n6\\nOutput\\n[1,2,3,0,0,0]\\nExpected\\n[1,2,2,3,5,6]\\n\\nWhy?  Or using system.linq forbidden?\\n\\n          "
                    }
                ]
            },
            {
                "id": 1965405,
                "content": [
                    {
                        "username": "venkateshnalla",
                        "content": "import java.util.*;\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n     ArrayList<Integer> al=new ArrayList<>();\n    \n      for(int i:nums1){\n          if(i!=0){\n              al.add(i);\n          }\n      }\n      for(int i:nums2){\n          if(i!=0){\n              al.add(i);\n          }\n      }\n   \n    Collections.sort(al);\n      System.out.println(al);\n    }\n}\ni did this but its not printing correct output \n"
                    },
                    {
                        "username": "blandprix",
                        "content": "The instructions specify that you need to modify nums1 in place, so returning a new variable is no good. I\\'m not sure of the best way to achieve this in Java, but at least I think you can modify the elements of nums1 by index, e.g. `nums1[0] = 7`"
                    },
                    {
                        "username": "Ankit9604",
                        "content": "What is wrong with this solution can anyone tell me please \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int k=m+n;\\n        int j=0;\\n        int l=0;\\n        for(int i=m;i<k;i++){\\n            nums1[i]=nums2[j];\\n            if(nums2[j]<nums1[l]){\\n             swap(nums1[i],nums1[l]);\\n             l++;\\n            }\\n            j++;\\n        }\\n\\n    }\\n}; \\n\\n\\nOutput\\n[1,2,3,2,5,6]  ??????\\nExpected\\n[1,2,2,3,5,6]"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 i think many of you didn\\'t noticed that the nums1 and nums2 are sorted"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "Hmm, is said \"Merge nums1 and nums2 into a single array sorted in non-decreasing order.\""
                    },
                    {
                        "username": "Keshavagr_273",
                        "content": "\\nimport java.util.Arrays;\\n\\npublic Solution {\\n    public static void merge(int[] nums1, int m, int[] nums2, int n){\\n        int[] ar =new int[m+n];\\n        for(int i=0;i<m;i++){\\n            ar[i]=nums1[i];\\n        }\\n        for(int i=m;i<m+n;i++){\\n            ar[i]=nums2[i-m];\\n        }\\n        Arrays.sort(ar);\\n        System.out.print(Arrays.toString(ar));\\n    }\\n    public static void main(String[] args){\\n        int[] nums1 ={0};\\n        int[] nums2 ={1};\\n        merge(nums1,0,nums2,1);\\n    }\\n}\\nwhen I am running this code in my laptop compiler it is giving [1] as expected but leetcode give [0] and says \"Wrong answer\". What is the problem. Which is wrong ?"
                    },
                    {
                        "username": "Samyun",
                        "content": "what is wrong in this logic, all test cases getting passed but getting wrong answer while submitting, why ?\\n public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i=m-1;\\n        int j=n-1;\\n        int k=m+n-1;\\n        while(i>=0 && j>=0) {\\n            if(nums1[i]>nums2[j]){\\n                nums1[k]=nums1[i];\\n                i--;\\n            } else {\\n                 nums1[k]=nums2[j];\\n                 j--;\\n            }\\n            k--;\\n        }\\n        if(j>=0) {\\n            nums1[k]=nums2[j];\\n            j--;\\n            k--;\\n        }\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why cant we make another another array and fill the element as per our need and why doesnt that work?\\n"
                    },
                    {
                        "username": "linpinto",
                        "content": "i tried doing this in PyCharm and it worked for all test cases but it doesn\\'t work here. Can someone explain why? \\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        tn1 = (nums1[:m])\\n        tn2 = (nums2[:n])\\n        tn1.extend(tn2)\\n        nums1 = sorted(tn1)"
                    },
                    {
                        "username": "linpinto",
                        "content": "[@Q3dlaXpoaQ](/Q3dlaXpoaQ) Thank you so much for the explanation!"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "I think it because \"nums1=sorted(tn1)\" let nums1 points to tn1. However, nums1 was didn\\'t change. So you can :\\nnums1.clear() \\nfor i in range(len(tn1)):\\n            nums1.append(tn1[i])"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "#include <algorithm>\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        vector<int> templist;\n        for(int i=0;i<m;i++){\n            templist.push_back(nums1[i]);\n        }\n        for(int i=0;i<n;i++){\n            templist.push_back(nums2[i]);\n        }\n        sort(templist.begin(),templist.end());\n        nums1.clear();\n        for(int i=0;i<templist.size();i++){\n            nums1.push_back(templist[i]);\n        }\n    }\n};\n\nWe can use 'sort' to solve it"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\nBut have you seen rule number 1 in Discussion section?\nIt says \"Please don't post any solutions in this discussion.\""
                    },
                    {
                        "username": "user2305qR",
                        "content": "Is the loop a must for this question?  Why I failed using slice (T_T)"
                    },
                    {
                        "username": "FrigMort",
                        "content": "Ok, I have trouble.\\nIt\\'s all my solution\\n `int[] result = nums1[0..(m)].Concat(nums2[0..(n)]).ToArray();`\\n `Array.Sort(result);`\\n\\nOutPut :\\nStdout\\n1\\n2\\n2\\n3\\n5\\n6\\nOutput\\n[1,2,3,0,0,0]\\nExpected\\n[1,2,2,3,5,6]\\n\\nWhy?  Or using system.linq forbidden?\\n\\n          "
                    }
                ]
            },
            {
                "id": 1961683,
                "content": [
                    {
                        "username": "venkateshnalla",
                        "content": "import java.util.*;\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n     ArrayList<Integer> al=new ArrayList<>();\n    \n      for(int i:nums1){\n          if(i!=0){\n              al.add(i);\n          }\n      }\n      for(int i:nums2){\n          if(i!=0){\n              al.add(i);\n          }\n      }\n   \n    Collections.sort(al);\n      System.out.println(al);\n    }\n}\ni did this but its not printing correct output \n"
                    },
                    {
                        "username": "blandprix",
                        "content": "The instructions specify that you need to modify nums1 in place, so returning a new variable is no good. I\\'m not sure of the best way to achieve this in Java, but at least I think you can modify the elements of nums1 by index, e.g. `nums1[0] = 7`"
                    },
                    {
                        "username": "Ankit9604",
                        "content": "What is wrong with this solution can anyone tell me please \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int k=m+n;\\n        int j=0;\\n        int l=0;\\n        for(int i=m;i<k;i++){\\n            nums1[i]=nums2[j];\\n            if(nums2[j]<nums1[l]){\\n             swap(nums1[i],nums1[l]);\\n             l++;\\n            }\\n            j++;\\n        }\\n\\n    }\\n}; \\n\\n\\nOutput\\n[1,2,3,2,5,6]  ??????\\nExpected\\n[1,2,2,3,5,6]"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 i think many of you didn\\'t noticed that the nums1 and nums2 are sorted"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "Hmm, is said \"Merge nums1 and nums2 into a single array sorted in non-decreasing order.\""
                    },
                    {
                        "username": "Keshavagr_273",
                        "content": "\\nimport java.util.Arrays;\\n\\npublic Solution {\\n    public static void merge(int[] nums1, int m, int[] nums2, int n){\\n        int[] ar =new int[m+n];\\n        for(int i=0;i<m;i++){\\n            ar[i]=nums1[i];\\n        }\\n        for(int i=m;i<m+n;i++){\\n            ar[i]=nums2[i-m];\\n        }\\n        Arrays.sort(ar);\\n        System.out.print(Arrays.toString(ar));\\n    }\\n    public static void main(String[] args){\\n        int[] nums1 ={0};\\n        int[] nums2 ={1};\\n        merge(nums1,0,nums2,1);\\n    }\\n}\\nwhen I am running this code in my laptop compiler it is giving [1] as expected but leetcode give [0] and says \"Wrong answer\". What is the problem. Which is wrong ?"
                    },
                    {
                        "username": "Samyun",
                        "content": "what is wrong in this logic, all test cases getting passed but getting wrong answer while submitting, why ?\\n public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i=m-1;\\n        int j=n-1;\\n        int k=m+n-1;\\n        while(i>=0 && j>=0) {\\n            if(nums1[i]>nums2[j]){\\n                nums1[k]=nums1[i];\\n                i--;\\n            } else {\\n                 nums1[k]=nums2[j];\\n                 j--;\\n            }\\n            k--;\\n        }\\n        if(j>=0) {\\n            nums1[k]=nums2[j];\\n            j--;\\n            k--;\\n        }\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why cant we make another another array and fill the element as per our need and why doesnt that work?\\n"
                    },
                    {
                        "username": "linpinto",
                        "content": "i tried doing this in PyCharm and it worked for all test cases but it doesn\\'t work here. Can someone explain why? \\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        tn1 = (nums1[:m])\\n        tn2 = (nums2[:n])\\n        tn1.extend(tn2)\\n        nums1 = sorted(tn1)"
                    },
                    {
                        "username": "linpinto",
                        "content": "[@Q3dlaXpoaQ](/Q3dlaXpoaQ) Thank you so much for the explanation!"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "I think it because \"nums1=sorted(tn1)\" let nums1 points to tn1. However, nums1 was didn\\'t change. So you can :\\nnums1.clear() \\nfor i in range(len(tn1)):\\n            nums1.append(tn1[i])"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "#include <algorithm>\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        vector<int> templist;\n        for(int i=0;i<m;i++){\n            templist.push_back(nums1[i]);\n        }\n        for(int i=0;i<n;i++){\n            templist.push_back(nums2[i]);\n        }\n        sort(templist.begin(),templist.end());\n        nums1.clear();\n        for(int i=0;i<templist.size();i++){\n            nums1.push_back(templist[i]);\n        }\n    }\n};\n\nWe can use 'sort' to solve it"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\nBut have you seen rule number 1 in Discussion section?\nIt says \"Please don't post any solutions in this discussion.\""
                    },
                    {
                        "username": "user2305qR",
                        "content": "Is the loop a must for this question?  Why I failed using slice (T_T)"
                    },
                    {
                        "username": "FrigMort",
                        "content": "Ok, I have trouble.\\nIt\\'s all my solution\\n `int[] result = nums1[0..(m)].Concat(nums2[0..(n)]).ToArray();`\\n `Array.Sort(result);`\\n\\nOutPut :\\nStdout\\n1\\n2\\n2\\n3\\n5\\n6\\nOutput\\n[1,2,3,0,0,0]\\nExpected\\n[1,2,2,3,5,6]\\n\\nWhy?  Or using system.linq forbidden?\\n\\n          "
                    }
                ]
            },
            {
                "id": 1960954,
                "content": [
                    {
                        "username": "venkateshnalla",
                        "content": "import java.util.*;\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n     ArrayList<Integer> al=new ArrayList<>();\n    \n      for(int i:nums1){\n          if(i!=0){\n              al.add(i);\n          }\n      }\n      for(int i:nums2){\n          if(i!=0){\n              al.add(i);\n          }\n      }\n   \n    Collections.sort(al);\n      System.out.println(al);\n    }\n}\ni did this but its not printing correct output \n"
                    },
                    {
                        "username": "blandprix",
                        "content": "The instructions specify that you need to modify nums1 in place, so returning a new variable is no good. I\\'m not sure of the best way to achieve this in Java, but at least I think you can modify the elements of nums1 by index, e.g. `nums1[0] = 7`"
                    },
                    {
                        "username": "Ankit9604",
                        "content": "What is wrong with this solution can anyone tell me please \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int k=m+n;\\n        int j=0;\\n        int l=0;\\n        for(int i=m;i<k;i++){\\n            nums1[i]=nums2[j];\\n            if(nums2[j]<nums1[l]){\\n             swap(nums1[i],nums1[l]);\\n             l++;\\n            }\\n            j++;\\n        }\\n\\n    }\\n}; \\n\\n\\nOutput\\n[1,2,3,2,5,6]  ??????\\nExpected\\n[1,2,2,3,5,6]"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 i think many of you didn\\'t noticed that the nums1 and nums2 are sorted"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "Hmm, is said \"Merge nums1 and nums2 into a single array sorted in non-decreasing order.\""
                    },
                    {
                        "username": "Keshavagr_273",
                        "content": "\\nimport java.util.Arrays;\\n\\npublic Solution {\\n    public static void merge(int[] nums1, int m, int[] nums2, int n){\\n        int[] ar =new int[m+n];\\n        for(int i=0;i<m;i++){\\n            ar[i]=nums1[i];\\n        }\\n        for(int i=m;i<m+n;i++){\\n            ar[i]=nums2[i-m];\\n        }\\n        Arrays.sort(ar);\\n        System.out.print(Arrays.toString(ar));\\n    }\\n    public static void main(String[] args){\\n        int[] nums1 ={0};\\n        int[] nums2 ={1};\\n        merge(nums1,0,nums2,1);\\n    }\\n}\\nwhen I am running this code in my laptop compiler it is giving [1] as expected but leetcode give [0] and says \"Wrong answer\". What is the problem. Which is wrong ?"
                    },
                    {
                        "username": "Samyun",
                        "content": "what is wrong in this logic, all test cases getting passed but getting wrong answer while submitting, why ?\\n public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i=m-1;\\n        int j=n-1;\\n        int k=m+n-1;\\n        while(i>=0 && j>=0) {\\n            if(nums1[i]>nums2[j]){\\n                nums1[k]=nums1[i];\\n                i--;\\n            } else {\\n                 nums1[k]=nums2[j];\\n                 j--;\\n            }\\n            k--;\\n        }\\n        if(j>=0) {\\n            nums1[k]=nums2[j];\\n            j--;\\n            k--;\\n        }\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why cant we make another another array and fill the element as per our need and why doesnt that work?\\n"
                    },
                    {
                        "username": "linpinto",
                        "content": "i tried doing this in PyCharm and it worked for all test cases but it doesn\\'t work here. Can someone explain why? \\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        tn1 = (nums1[:m])\\n        tn2 = (nums2[:n])\\n        tn1.extend(tn2)\\n        nums1 = sorted(tn1)"
                    },
                    {
                        "username": "linpinto",
                        "content": "[@Q3dlaXpoaQ](/Q3dlaXpoaQ) Thank you so much for the explanation!"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "I think it because \"nums1=sorted(tn1)\" let nums1 points to tn1. However, nums1 was didn\\'t change. So you can :\\nnums1.clear() \\nfor i in range(len(tn1)):\\n            nums1.append(tn1[i])"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "#include <algorithm>\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        vector<int> templist;\n        for(int i=0;i<m;i++){\n            templist.push_back(nums1[i]);\n        }\n        for(int i=0;i<n;i++){\n            templist.push_back(nums2[i]);\n        }\n        sort(templist.begin(),templist.end());\n        nums1.clear();\n        for(int i=0;i<templist.size();i++){\n            nums1.push_back(templist[i]);\n        }\n    }\n};\n\nWe can use 'sort' to solve it"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\nBut have you seen rule number 1 in Discussion section?\nIt says \"Please don't post any solutions in this discussion.\""
                    },
                    {
                        "username": "user2305qR",
                        "content": "Is the loop a must for this question?  Why I failed using slice (T_T)"
                    },
                    {
                        "username": "FrigMort",
                        "content": "Ok, I have trouble.\\nIt\\'s all my solution\\n `int[] result = nums1[0..(m)].Concat(nums2[0..(n)]).ToArray();`\\n `Array.Sort(result);`\\n\\nOutPut :\\nStdout\\n1\\n2\\n2\\n3\\n5\\n6\\nOutput\\n[1,2,3,0,0,0]\\nExpected\\n[1,2,2,3,5,6]\\n\\nWhy?  Or using system.linq forbidden?\\n\\n          "
                    }
                ]
            },
            {
                "id": 1958772,
                "content": [
                    {
                        "username": "venkateshnalla",
                        "content": "import java.util.*;\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n     ArrayList<Integer> al=new ArrayList<>();\n    \n      for(int i:nums1){\n          if(i!=0){\n              al.add(i);\n          }\n      }\n      for(int i:nums2){\n          if(i!=0){\n              al.add(i);\n          }\n      }\n   \n    Collections.sort(al);\n      System.out.println(al);\n    }\n}\ni did this but its not printing correct output \n"
                    },
                    {
                        "username": "blandprix",
                        "content": "The instructions specify that you need to modify nums1 in place, so returning a new variable is no good. I\\'m not sure of the best way to achieve this in Java, but at least I think you can modify the elements of nums1 by index, e.g. `nums1[0] = 7`"
                    },
                    {
                        "username": "Ankit9604",
                        "content": "What is wrong with this solution can anyone tell me please \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int k=m+n;\\n        int j=0;\\n        int l=0;\\n        for(int i=m;i<k;i++){\\n            nums1[i]=nums2[j];\\n            if(nums2[j]<nums1[l]){\\n             swap(nums1[i],nums1[l]);\\n             l++;\\n            }\\n            j++;\\n        }\\n\\n    }\\n}; \\n\\n\\nOutput\\n[1,2,3,2,5,6]  ??????\\nExpected\\n[1,2,2,3,5,6]"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 i think many of you didn\\'t noticed that the nums1 and nums2 are sorted"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "Hmm, is said \"Merge nums1 and nums2 into a single array sorted in non-decreasing order.\""
                    },
                    {
                        "username": "Keshavagr_273",
                        "content": "\\nimport java.util.Arrays;\\n\\npublic Solution {\\n    public static void merge(int[] nums1, int m, int[] nums2, int n){\\n        int[] ar =new int[m+n];\\n        for(int i=0;i<m;i++){\\n            ar[i]=nums1[i];\\n        }\\n        for(int i=m;i<m+n;i++){\\n            ar[i]=nums2[i-m];\\n        }\\n        Arrays.sort(ar);\\n        System.out.print(Arrays.toString(ar));\\n    }\\n    public static void main(String[] args){\\n        int[] nums1 ={0};\\n        int[] nums2 ={1};\\n        merge(nums1,0,nums2,1);\\n    }\\n}\\nwhen I am running this code in my laptop compiler it is giving [1] as expected but leetcode give [0] and says \"Wrong answer\". What is the problem. Which is wrong ?"
                    },
                    {
                        "username": "Samyun",
                        "content": "what is wrong in this logic, all test cases getting passed but getting wrong answer while submitting, why ?\\n public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i=m-1;\\n        int j=n-1;\\n        int k=m+n-1;\\n        while(i>=0 && j>=0) {\\n            if(nums1[i]>nums2[j]){\\n                nums1[k]=nums1[i];\\n                i--;\\n            } else {\\n                 nums1[k]=nums2[j];\\n                 j--;\\n            }\\n            k--;\\n        }\\n        if(j>=0) {\\n            nums1[k]=nums2[j];\\n            j--;\\n            k--;\\n        }\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why cant we make another another array and fill the element as per our need and why doesnt that work?\\n"
                    },
                    {
                        "username": "linpinto",
                        "content": "i tried doing this in PyCharm and it worked for all test cases but it doesn\\'t work here. Can someone explain why? \\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        tn1 = (nums1[:m])\\n        tn2 = (nums2[:n])\\n        tn1.extend(tn2)\\n        nums1 = sorted(tn1)"
                    },
                    {
                        "username": "linpinto",
                        "content": "[@Q3dlaXpoaQ](/Q3dlaXpoaQ) Thank you so much for the explanation!"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "I think it because \"nums1=sorted(tn1)\" let nums1 points to tn1. However, nums1 was didn\\'t change. So you can :\\nnums1.clear() \\nfor i in range(len(tn1)):\\n            nums1.append(tn1[i])"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "#include <algorithm>\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        vector<int> templist;\n        for(int i=0;i<m;i++){\n            templist.push_back(nums1[i]);\n        }\n        for(int i=0;i<n;i++){\n            templist.push_back(nums2[i]);\n        }\n        sort(templist.begin(),templist.end());\n        nums1.clear();\n        for(int i=0;i<templist.size();i++){\n            nums1.push_back(templist[i]);\n        }\n    }\n};\n\nWe can use 'sort' to solve it"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\nBut have you seen rule number 1 in Discussion section?\nIt says \"Please don't post any solutions in this discussion.\""
                    },
                    {
                        "username": "user2305qR",
                        "content": "Is the loop a must for this question?  Why I failed using slice (T_T)"
                    },
                    {
                        "username": "FrigMort",
                        "content": "Ok, I have trouble.\\nIt\\'s all my solution\\n `int[] result = nums1[0..(m)].Concat(nums2[0..(n)]).ToArray();`\\n `Array.Sort(result);`\\n\\nOutPut :\\nStdout\\n1\\n2\\n2\\n3\\n5\\n6\\nOutput\\n[1,2,3,0,0,0]\\nExpected\\n[1,2,2,3,5,6]\\n\\nWhy?  Or using system.linq forbidden?\\n\\n          "
                    }
                ]
            },
            {
                "id": 1958554,
                "content": [
                    {
                        "username": "venkateshnalla",
                        "content": "import java.util.*;\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n     ArrayList<Integer> al=new ArrayList<>();\n    \n      for(int i:nums1){\n          if(i!=0){\n              al.add(i);\n          }\n      }\n      for(int i:nums2){\n          if(i!=0){\n              al.add(i);\n          }\n      }\n   \n    Collections.sort(al);\n      System.out.println(al);\n    }\n}\ni did this but its not printing correct output \n"
                    },
                    {
                        "username": "blandprix",
                        "content": "The instructions specify that you need to modify nums1 in place, so returning a new variable is no good. I\\'m not sure of the best way to achieve this in Java, but at least I think you can modify the elements of nums1 by index, e.g. `nums1[0] = 7`"
                    },
                    {
                        "username": "Ankit9604",
                        "content": "What is wrong with this solution can anyone tell me please \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int k=m+n;\\n        int j=0;\\n        int l=0;\\n        for(int i=m;i<k;i++){\\n            nums1[i]=nums2[j];\\n            if(nums2[j]<nums1[l]){\\n             swap(nums1[i],nums1[l]);\\n             l++;\\n            }\\n            j++;\\n        }\\n\\n    }\\n}; \\n\\n\\nOutput\\n[1,2,3,2,5,6]  ??????\\nExpected\\n[1,2,2,3,5,6]"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 i think many of you didn\\'t noticed that the nums1 and nums2 are sorted"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "Hmm, is said \"Merge nums1 and nums2 into a single array sorted in non-decreasing order.\""
                    },
                    {
                        "username": "Keshavagr_273",
                        "content": "\\nimport java.util.Arrays;\\n\\npublic Solution {\\n    public static void merge(int[] nums1, int m, int[] nums2, int n){\\n        int[] ar =new int[m+n];\\n        for(int i=0;i<m;i++){\\n            ar[i]=nums1[i];\\n        }\\n        for(int i=m;i<m+n;i++){\\n            ar[i]=nums2[i-m];\\n        }\\n        Arrays.sort(ar);\\n        System.out.print(Arrays.toString(ar));\\n    }\\n    public static void main(String[] args){\\n        int[] nums1 ={0};\\n        int[] nums2 ={1};\\n        merge(nums1,0,nums2,1);\\n    }\\n}\\nwhen I am running this code in my laptop compiler it is giving [1] as expected but leetcode give [0] and says \"Wrong answer\". What is the problem. Which is wrong ?"
                    },
                    {
                        "username": "Samyun",
                        "content": "what is wrong in this logic, all test cases getting passed but getting wrong answer while submitting, why ?\\n public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i=m-1;\\n        int j=n-1;\\n        int k=m+n-1;\\n        while(i>=0 && j>=0) {\\n            if(nums1[i]>nums2[j]){\\n                nums1[k]=nums1[i];\\n                i--;\\n            } else {\\n                 nums1[k]=nums2[j];\\n                 j--;\\n            }\\n            k--;\\n        }\\n        if(j>=0) {\\n            nums1[k]=nums2[j];\\n            j--;\\n            k--;\\n        }\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why cant we make another another array and fill the element as per our need and why doesnt that work?\\n"
                    },
                    {
                        "username": "linpinto",
                        "content": "i tried doing this in PyCharm and it worked for all test cases but it doesn\\'t work here. Can someone explain why? \\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        tn1 = (nums1[:m])\\n        tn2 = (nums2[:n])\\n        tn1.extend(tn2)\\n        nums1 = sorted(tn1)"
                    },
                    {
                        "username": "linpinto",
                        "content": "[@Q3dlaXpoaQ](/Q3dlaXpoaQ) Thank you so much for the explanation!"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "I think it because \"nums1=sorted(tn1)\" let nums1 points to tn1. However, nums1 was didn\\'t change. So you can :\\nnums1.clear() \\nfor i in range(len(tn1)):\\n            nums1.append(tn1[i])"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "#include <algorithm>\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        vector<int> templist;\n        for(int i=0;i<m;i++){\n            templist.push_back(nums1[i]);\n        }\n        for(int i=0;i<n;i++){\n            templist.push_back(nums2[i]);\n        }\n        sort(templist.begin(),templist.end());\n        nums1.clear();\n        for(int i=0;i<templist.size();i++){\n            nums1.push_back(templist[i]);\n        }\n    }\n};\n\nWe can use 'sort' to solve it"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\nBut have you seen rule number 1 in Discussion section?\nIt says \"Please don't post any solutions in this discussion.\""
                    },
                    {
                        "username": "user2305qR",
                        "content": "Is the loop a must for this question?  Why I failed using slice (T_T)"
                    },
                    {
                        "username": "FrigMort",
                        "content": "Ok, I have trouble.\\nIt\\'s all my solution\\n `int[] result = nums1[0..(m)].Concat(nums2[0..(n)]).ToArray();`\\n `Array.Sort(result);`\\n\\nOutPut :\\nStdout\\n1\\n2\\n2\\n3\\n5\\n6\\nOutput\\n[1,2,3,0,0,0]\\nExpected\\n[1,2,2,3,5,6]\\n\\nWhy?  Or using system.linq forbidden?\\n\\n          "
                    }
                ]
            },
            {
                "id": 1955969,
                "content": [
                    {
                        "username": "venkateshnalla",
                        "content": "import java.util.*;\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n     ArrayList<Integer> al=new ArrayList<>();\n    \n      for(int i:nums1){\n          if(i!=0){\n              al.add(i);\n          }\n      }\n      for(int i:nums2){\n          if(i!=0){\n              al.add(i);\n          }\n      }\n   \n    Collections.sort(al);\n      System.out.println(al);\n    }\n}\ni did this but its not printing correct output \n"
                    },
                    {
                        "username": "blandprix",
                        "content": "The instructions specify that you need to modify nums1 in place, so returning a new variable is no good. I\\'m not sure of the best way to achieve this in Java, but at least I think you can modify the elements of nums1 by index, e.g. `nums1[0] = 7`"
                    },
                    {
                        "username": "Ankit9604",
                        "content": "What is wrong with this solution can anyone tell me please \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int k=m+n;\\n        int j=0;\\n        int l=0;\\n        for(int i=m;i<k;i++){\\n            nums1[i]=nums2[j];\\n            if(nums2[j]<nums1[l]){\\n             swap(nums1[i],nums1[l]);\\n             l++;\\n            }\\n            j++;\\n        }\\n\\n    }\\n}; \\n\\n\\nOutput\\n[1,2,3,2,5,6]  ??????\\nExpected\\n[1,2,2,3,5,6]"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 i think many of you didn\\'t noticed that the nums1 and nums2 are sorted"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "Hmm, is said \"Merge nums1 and nums2 into a single array sorted in non-decreasing order.\""
                    },
                    {
                        "username": "Keshavagr_273",
                        "content": "\\nimport java.util.Arrays;\\n\\npublic Solution {\\n    public static void merge(int[] nums1, int m, int[] nums2, int n){\\n        int[] ar =new int[m+n];\\n        for(int i=0;i<m;i++){\\n            ar[i]=nums1[i];\\n        }\\n        for(int i=m;i<m+n;i++){\\n            ar[i]=nums2[i-m];\\n        }\\n        Arrays.sort(ar);\\n        System.out.print(Arrays.toString(ar));\\n    }\\n    public static void main(String[] args){\\n        int[] nums1 ={0};\\n        int[] nums2 ={1};\\n        merge(nums1,0,nums2,1);\\n    }\\n}\\nwhen I am running this code in my laptop compiler it is giving [1] as expected but leetcode give [0] and says \"Wrong answer\". What is the problem. Which is wrong ?"
                    },
                    {
                        "username": "Samyun",
                        "content": "what is wrong in this logic, all test cases getting passed but getting wrong answer while submitting, why ?\\n public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i=m-1;\\n        int j=n-1;\\n        int k=m+n-1;\\n        while(i>=0 && j>=0) {\\n            if(nums1[i]>nums2[j]){\\n                nums1[k]=nums1[i];\\n                i--;\\n            } else {\\n                 nums1[k]=nums2[j];\\n                 j--;\\n            }\\n            k--;\\n        }\\n        if(j>=0) {\\n            nums1[k]=nums2[j];\\n            j--;\\n            k--;\\n        }\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why cant we make another another array and fill the element as per our need and why doesnt that work?\\n"
                    },
                    {
                        "username": "linpinto",
                        "content": "i tried doing this in PyCharm and it worked for all test cases but it doesn\\'t work here. Can someone explain why? \\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        tn1 = (nums1[:m])\\n        tn2 = (nums2[:n])\\n        tn1.extend(tn2)\\n        nums1 = sorted(tn1)"
                    },
                    {
                        "username": "linpinto",
                        "content": "[@Q3dlaXpoaQ](/Q3dlaXpoaQ) Thank you so much for the explanation!"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "I think it because \"nums1=sorted(tn1)\" let nums1 points to tn1. However, nums1 was didn\\'t change. So you can :\\nnums1.clear() \\nfor i in range(len(tn1)):\\n            nums1.append(tn1[i])"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "#include <algorithm>\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        vector<int> templist;\n        for(int i=0;i<m;i++){\n            templist.push_back(nums1[i]);\n        }\n        for(int i=0;i<n;i++){\n            templist.push_back(nums2[i]);\n        }\n        sort(templist.begin(),templist.end());\n        nums1.clear();\n        for(int i=0;i<templist.size();i++){\n            nums1.push_back(templist[i]);\n        }\n    }\n};\n\nWe can use 'sort' to solve it"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\nBut have you seen rule number 1 in Discussion section?\nIt says \"Please don't post any solutions in this discussion.\""
                    },
                    {
                        "username": "user2305qR",
                        "content": "Is the loop a must for this question?  Why I failed using slice (T_T)"
                    },
                    {
                        "username": "FrigMort",
                        "content": "Ok, I have trouble.\\nIt\\'s all my solution\\n `int[] result = nums1[0..(m)].Concat(nums2[0..(n)]).ToArray();`\\n `Array.Sort(result);`\\n\\nOutPut :\\nStdout\\n1\\n2\\n2\\n3\\n5\\n6\\nOutput\\n[1,2,3,0,0,0]\\nExpected\\n[1,2,2,3,5,6]\\n\\nWhy?  Or using system.linq forbidden?\\n\\n          "
                    }
                ]
            },
            {
                "id": 1954047,
                "content": [
                    {
                        "username": "venkateshnalla",
                        "content": "import java.util.*;\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n     ArrayList<Integer> al=new ArrayList<>();\n    \n      for(int i:nums1){\n          if(i!=0){\n              al.add(i);\n          }\n      }\n      for(int i:nums2){\n          if(i!=0){\n              al.add(i);\n          }\n      }\n   \n    Collections.sort(al);\n      System.out.println(al);\n    }\n}\ni did this but its not printing correct output \n"
                    },
                    {
                        "username": "blandprix",
                        "content": "The instructions specify that you need to modify nums1 in place, so returning a new variable is no good. I\\'m not sure of the best way to achieve this in Java, but at least I think you can modify the elements of nums1 by index, e.g. `nums1[0] = 7`"
                    },
                    {
                        "username": "Ankit9604",
                        "content": "What is wrong with this solution can anyone tell me please \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int k=m+n;\\n        int j=0;\\n        int l=0;\\n        for(int i=m;i<k;i++){\\n            nums1[i]=nums2[j];\\n            if(nums2[j]<nums1[l]){\\n             swap(nums1[i],nums1[l]);\\n             l++;\\n            }\\n            j++;\\n        }\\n\\n    }\\n}; \\n\\n\\nOutput\\n[1,2,3,2,5,6]  ??????\\nExpected\\n[1,2,2,3,5,6]"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 i think many of you didn\\'t noticed that the nums1 and nums2 are sorted"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "Hmm, is said \"Merge nums1 and nums2 into a single array sorted in non-decreasing order.\""
                    },
                    {
                        "username": "Keshavagr_273",
                        "content": "\\nimport java.util.Arrays;\\n\\npublic Solution {\\n    public static void merge(int[] nums1, int m, int[] nums2, int n){\\n        int[] ar =new int[m+n];\\n        for(int i=0;i<m;i++){\\n            ar[i]=nums1[i];\\n        }\\n        for(int i=m;i<m+n;i++){\\n            ar[i]=nums2[i-m];\\n        }\\n        Arrays.sort(ar);\\n        System.out.print(Arrays.toString(ar));\\n    }\\n    public static void main(String[] args){\\n        int[] nums1 ={0};\\n        int[] nums2 ={1};\\n        merge(nums1,0,nums2,1);\\n    }\\n}\\nwhen I am running this code in my laptop compiler it is giving [1] as expected but leetcode give [0] and says \"Wrong answer\". What is the problem. Which is wrong ?"
                    },
                    {
                        "username": "Samyun",
                        "content": "what is wrong in this logic, all test cases getting passed but getting wrong answer while submitting, why ?\\n public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i=m-1;\\n        int j=n-1;\\n        int k=m+n-1;\\n        while(i>=0 && j>=0) {\\n            if(nums1[i]>nums2[j]){\\n                nums1[k]=nums1[i];\\n                i--;\\n            } else {\\n                 nums1[k]=nums2[j];\\n                 j--;\\n            }\\n            k--;\\n        }\\n        if(j>=0) {\\n            nums1[k]=nums2[j];\\n            j--;\\n            k--;\\n        }\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why cant we make another another array and fill the element as per our need and why doesnt that work?\\n"
                    },
                    {
                        "username": "linpinto",
                        "content": "i tried doing this in PyCharm and it worked for all test cases but it doesn\\'t work here. Can someone explain why? \\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        tn1 = (nums1[:m])\\n        tn2 = (nums2[:n])\\n        tn1.extend(tn2)\\n        nums1 = sorted(tn1)"
                    },
                    {
                        "username": "linpinto",
                        "content": "[@Q3dlaXpoaQ](/Q3dlaXpoaQ) Thank you so much for the explanation!"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "I think it because \"nums1=sorted(tn1)\" let nums1 points to tn1. However, nums1 was didn\\'t change. So you can :\\nnums1.clear() \\nfor i in range(len(tn1)):\\n            nums1.append(tn1[i])"
                    },
                    {
                        "username": "Q3dlaXpoaQ",
                        "content": "#include <algorithm>\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        vector<int> templist;\n        for(int i=0;i<m;i++){\n            templist.push_back(nums1[i]);\n        }\n        for(int i=0;i<n;i++){\n            templist.push_back(nums2[i]);\n        }\n        sort(templist.begin(),templist.end());\n        nums1.clear();\n        for(int i=0;i<templist.size();i++){\n            nums1.push_back(templist[i]);\n        }\n    }\n};\n\nWe can use 'sort' to solve it"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\nBut have you seen rule number 1 in Discussion section?\nIt says \"Please don't post any solutions in this discussion.\""
                    },
                    {
                        "username": "user2305qR",
                        "content": "Is the loop a must for this question?  Why I failed using slice (T_T)"
                    },
                    {
                        "username": "FrigMort",
                        "content": "Ok, I have trouble.\\nIt\\'s all my solution\\n `int[] result = nums1[0..(m)].Concat(nums2[0..(n)]).ToArray();`\\n `Array.Sort(result);`\\n\\nOutPut :\\nStdout\\n1\\n2\\n2\\n3\\n5\\n6\\nOutput\\n[1,2,3,0,0,0]\\nExpected\\n[1,2,2,3,5,6]\\n\\nWhy?  Or using system.linq forbidden?\\n\\n          "
                    }
                ]
            },
            {
                "id": 1953402,
                "content": [
                    {
                        "username": "Mehdavii",
                        "content": "I wrote completely correct solution but why is it not accepting it?\\nWhats wrong with:\\nnums1=nums1[:m]+nums2\\nnums1.sort()\\n"
                    },
                    {
                        "username": "abhishekgupta744",
                        "content": "Why my program is not getting passed\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int sum=n+m, temp=0;\\n        int[] nums3 = new int[sum];\\n        int k=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            if(nums1[i]!=0)\\n            {\\n                nums3[k]=nums1[i];\\n                k++;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums2[i]!=0)\\n            {\\n                nums3[k]=nums2[i];\\n                k++;\\n            }\\n        }\\n        for(int i=0;i<sum;i++)\\n        {\\n           for(int j=0;j<sum-i-1;j++)\\n           {\\n               if(nums3[j]>nums3[j+1])\\n               {\\n               temp=nums3[j];\\n               nums3[j]=nums3[j+1];\\n               nums3[j+1]=temp;\\n               }\\n           }\\n        }\\n        System.out.print(\"[\");\\n        for(int i=0;i<sum;i++)\\n        {\\n            System.out.print(nums3[i]);\\n            if(i!=sum-1)\\n            {\\n              System.out.print(\",\");  \\n            }\\n        }\\n        System.out.print(\"]\");\\n    }\\n}"
                    },
                    {
                        "username": "manuheralagi4",
                        "content": "class Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        z=len(nums1)-m\\n        x=len(nums2)-n\\n\\n        for i in range (z):\\n            nums1.pop()\\n        for i in range (x):\\n            nums2.pop()\\n        nums1=nums1+nums2\\n        nums1.sort()\\n        return nums1\\n\\n---------------------------------------------\\nwhen i am running in my system console it is giving the correct answer but not in leetcode terminal"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "whats wrong in this code bros??why third test case isnt successful??\\nint ptr1= m-1;\\n    int ptr2 = n-1;\\n    int ptr3 = nums1.length-1;int flag= 0;\\n    \\n    if(m==0&&n==0)\\n    return;\\n    else if(m==0&&n!=0)\\n    {   \\n        nums1= nums2;\\n        return;\\n    }\\n    else if(n==0)\\n    return;\\n    else\\n    {\\n        for(;ptr3>=0;--ptr3)\\n        {\\n            nums1[ptr3] = Math.max(nums1[ptr1],nums2[ptr2]);\\n            if(nums1[ptr1]>nums2[ptr2])\\n            --ptr1;\\n            else \\n            --ptr2;\\n            if(ptr2<0)\\n            break;\\n            if(ptr1<0)\\n            {\\n                flag= 1;\\n                --ptr3;\\n                break;\\n            }\\n        }\\n        if(flag==1)\\n        for(;ptr3>=0;--ptr3 )\\n        {\\n            nums1[ptr3]=nums2[ptr2];\\n            --ptr2;\\n        }\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "  public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int merge[]=new int[m+n];\\n        System.arraycopy(nums1,0,merge,0,m);\\n        System.arraycopy(nums2,0,merge,m,n);\\n        Arrays.sort(merge);\\n        System.out.println(Arrays.toString(merge));\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "knirmal499",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=0; i<nums2.length; i++)\\n            nums1[m++] = nums2[i];\\n        Arrays.sort(nums1);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mlahari2004",
                        "content": "My code is running in both vs code and online gdb. But in this compiler it\\'s showing a compile error:\\nLine 42: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\nint main(int argc, char *argv[]) {"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": "mine is java code"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int j=0;\\n        for(int i=0;i<m &&j<n;++i){\\n            if(nums1[i]==0){\\n                nums1[i] = nums2[j];    \\n                j++;\\n            }\\n        }\\n        //bubble sort\\n        for(int i=0;i<m-1;++i){\\n            if(nums1[i]>nums1[i+1]){\\n                int temp = nums1[i];\\n                nums1[i] = nums1[i+1];\\n                nums1[i+1] = temp;\\n            } \\n        }\\n\\n    }\\n}\\ni dont understand why the first for loop itself is not working,if anyone can find the problem,please help me"
                    },
                    {
                        "username": "SarKurd",
                        "content": "If you know Merge Sort then you can solve this easily.\\nbasically merge helper from Merge Sort."
                    },
                    {
                        "username": "akmuir",
                        "content": "When I print nums1 it shows me the correct output. However the output itself shows me something different from what is actually stored in my nums1, why is this?"
                    }
                ]
            },
            {
                "id": 1950888,
                "content": [
                    {
                        "username": "Mehdavii",
                        "content": "I wrote completely correct solution but why is it not accepting it?\\nWhats wrong with:\\nnums1=nums1[:m]+nums2\\nnums1.sort()\\n"
                    },
                    {
                        "username": "abhishekgupta744",
                        "content": "Why my program is not getting passed\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int sum=n+m, temp=0;\\n        int[] nums3 = new int[sum];\\n        int k=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            if(nums1[i]!=0)\\n            {\\n                nums3[k]=nums1[i];\\n                k++;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums2[i]!=0)\\n            {\\n                nums3[k]=nums2[i];\\n                k++;\\n            }\\n        }\\n        for(int i=0;i<sum;i++)\\n        {\\n           for(int j=0;j<sum-i-1;j++)\\n           {\\n               if(nums3[j]>nums3[j+1])\\n               {\\n               temp=nums3[j];\\n               nums3[j]=nums3[j+1];\\n               nums3[j+1]=temp;\\n               }\\n           }\\n        }\\n        System.out.print(\"[\");\\n        for(int i=0;i<sum;i++)\\n        {\\n            System.out.print(nums3[i]);\\n            if(i!=sum-1)\\n            {\\n              System.out.print(\",\");  \\n            }\\n        }\\n        System.out.print(\"]\");\\n    }\\n}"
                    },
                    {
                        "username": "manuheralagi4",
                        "content": "class Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        z=len(nums1)-m\\n        x=len(nums2)-n\\n\\n        for i in range (z):\\n            nums1.pop()\\n        for i in range (x):\\n            nums2.pop()\\n        nums1=nums1+nums2\\n        nums1.sort()\\n        return nums1\\n\\n---------------------------------------------\\nwhen i am running in my system console it is giving the correct answer but not in leetcode terminal"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "whats wrong in this code bros??why third test case isnt successful??\\nint ptr1= m-1;\\n    int ptr2 = n-1;\\n    int ptr3 = nums1.length-1;int flag= 0;\\n    \\n    if(m==0&&n==0)\\n    return;\\n    else if(m==0&&n!=0)\\n    {   \\n        nums1= nums2;\\n        return;\\n    }\\n    else if(n==0)\\n    return;\\n    else\\n    {\\n        for(;ptr3>=0;--ptr3)\\n        {\\n            nums1[ptr3] = Math.max(nums1[ptr1],nums2[ptr2]);\\n            if(nums1[ptr1]>nums2[ptr2])\\n            --ptr1;\\n            else \\n            --ptr2;\\n            if(ptr2<0)\\n            break;\\n            if(ptr1<0)\\n            {\\n                flag= 1;\\n                --ptr3;\\n                break;\\n            }\\n        }\\n        if(flag==1)\\n        for(;ptr3>=0;--ptr3 )\\n        {\\n            nums1[ptr3]=nums2[ptr2];\\n            --ptr2;\\n        }\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "  public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int merge[]=new int[m+n];\\n        System.arraycopy(nums1,0,merge,0,m);\\n        System.arraycopy(nums2,0,merge,m,n);\\n        Arrays.sort(merge);\\n        System.out.println(Arrays.toString(merge));\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "knirmal499",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=0; i<nums2.length; i++)\\n            nums1[m++] = nums2[i];\\n        Arrays.sort(nums1);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mlahari2004",
                        "content": "My code is running in both vs code and online gdb. But in this compiler it\\'s showing a compile error:\\nLine 42: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\nint main(int argc, char *argv[]) {"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": "mine is java code"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int j=0;\\n        for(int i=0;i<m &&j<n;++i){\\n            if(nums1[i]==0){\\n                nums1[i] = nums2[j];    \\n                j++;\\n            }\\n        }\\n        //bubble sort\\n        for(int i=0;i<m-1;++i){\\n            if(nums1[i]>nums1[i+1]){\\n                int temp = nums1[i];\\n                nums1[i] = nums1[i+1];\\n                nums1[i+1] = temp;\\n            } \\n        }\\n\\n    }\\n}\\ni dont understand why the first for loop itself is not working,if anyone can find the problem,please help me"
                    },
                    {
                        "username": "SarKurd",
                        "content": "If you know Merge Sort then you can solve this easily.\\nbasically merge helper from Merge Sort."
                    },
                    {
                        "username": "akmuir",
                        "content": "When I print nums1 it shows me the correct output. However the output itself shows me something different from what is actually stored in my nums1, why is this?"
                    }
                ]
            },
            {
                "id": 1949553,
                "content": [
                    {
                        "username": "Mehdavii",
                        "content": "I wrote completely correct solution but why is it not accepting it?\\nWhats wrong with:\\nnums1=nums1[:m]+nums2\\nnums1.sort()\\n"
                    },
                    {
                        "username": "abhishekgupta744",
                        "content": "Why my program is not getting passed\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int sum=n+m, temp=0;\\n        int[] nums3 = new int[sum];\\n        int k=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            if(nums1[i]!=0)\\n            {\\n                nums3[k]=nums1[i];\\n                k++;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums2[i]!=0)\\n            {\\n                nums3[k]=nums2[i];\\n                k++;\\n            }\\n        }\\n        for(int i=0;i<sum;i++)\\n        {\\n           for(int j=0;j<sum-i-1;j++)\\n           {\\n               if(nums3[j]>nums3[j+1])\\n               {\\n               temp=nums3[j];\\n               nums3[j]=nums3[j+1];\\n               nums3[j+1]=temp;\\n               }\\n           }\\n        }\\n        System.out.print(\"[\");\\n        for(int i=0;i<sum;i++)\\n        {\\n            System.out.print(nums3[i]);\\n            if(i!=sum-1)\\n            {\\n              System.out.print(\",\");  \\n            }\\n        }\\n        System.out.print(\"]\");\\n    }\\n}"
                    },
                    {
                        "username": "manuheralagi4",
                        "content": "class Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        z=len(nums1)-m\\n        x=len(nums2)-n\\n\\n        for i in range (z):\\n            nums1.pop()\\n        for i in range (x):\\n            nums2.pop()\\n        nums1=nums1+nums2\\n        nums1.sort()\\n        return nums1\\n\\n---------------------------------------------\\nwhen i am running in my system console it is giving the correct answer but not in leetcode terminal"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "whats wrong in this code bros??why third test case isnt successful??\\nint ptr1= m-1;\\n    int ptr2 = n-1;\\n    int ptr3 = nums1.length-1;int flag= 0;\\n    \\n    if(m==0&&n==0)\\n    return;\\n    else if(m==0&&n!=0)\\n    {   \\n        nums1= nums2;\\n        return;\\n    }\\n    else if(n==0)\\n    return;\\n    else\\n    {\\n        for(;ptr3>=0;--ptr3)\\n        {\\n            nums1[ptr3] = Math.max(nums1[ptr1],nums2[ptr2]);\\n            if(nums1[ptr1]>nums2[ptr2])\\n            --ptr1;\\n            else \\n            --ptr2;\\n            if(ptr2<0)\\n            break;\\n            if(ptr1<0)\\n            {\\n                flag= 1;\\n                --ptr3;\\n                break;\\n            }\\n        }\\n        if(flag==1)\\n        for(;ptr3>=0;--ptr3 )\\n        {\\n            nums1[ptr3]=nums2[ptr2];\\n            --ptr2;\\n        }\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "  public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int merge[]=new int[m+n];\\n        System.arraycopy(nums1,0,merge,0,m);\\n        System.arraycopy(nums2,0,merge,m,n);\\n        Arrays.sort(merge);\\n        System.out.println(Arrays.toString(merge));\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "knirmal499",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=0; i<nums2.length; i++)\\n            nums1[m++] = nums2[i];\\n        Arrays.sort(nums1);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mlahari2004",
                        "content": "My code is running in both vs code and online gdb. But in this compiler it\\'s showing a compile error:\\nLine 42: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\nint main(int argc, char *argv[]) {"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": "mine is java code"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int j=0;\\n        for(int i=0;i<m &&j<n;++i){\\n            if(nums1[i]==0){\\n                nums1[i] = nums2[j];    \\n                j++;\\n            }\\n        }\\n        //bubble sort\\n        for(int i=0;i<m-1;++i){\\n            if(nums1[i]>nums1[i+1]){\\n                int temp = nums1[i];\\n                nums1[i] = nums1[i+1];\\n                nums1[i+1] = temp;\\n            } \\n        }\\n\\n    }\\n}\\ni dont understand why the first for loop itself is not working,if anyone can find the problem,please help me"
                    },
                    {
                        "username": "SarKurd",
                        "content": "If you know Merge Sort then you can solve this easily.\\nbasically merge helper from Merge Sort."
                    },
                    {
                        "username": "akmuir",
                        "content": "When I print nums1 it shows me the correct output. However the output itself shows me something different from what is actually stored in my nums1, why is this?"
                    }
                ]
            },
            {
                "id": 1949542,
                "content": [
                    {
                        "username": "Mehdavii",
                        "content": "I wrote completely correct solution but why is it not accepting it?\\nWhats wrong with:\\nnums1=nums1[:m]+nums2\\nnums1.sort()\\n"
                    },
                    {
                        "username": "abhishekgupta744",
                        "content": "Why my program is not getting passed\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int sum=n+m, temp=0;\\n        int[] nums3 = new int[sum];\\n        int k=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            if(nums1[i]!=0)\\n            {\\n                nums3[k]=nums1[i];\\n                k++;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums2[i]!=0)\\n            {\\n                nums3[k]=nums2[i];\\n                k++;\\n            }\\n        }\\n        for(int i=0;i<sum;i++)\\n        {\\n           for(int j=0;j<sum-i-1;j++)\\n           {\\n               if(nums3[j]>nums3[j+1])\\n               {\\n               temp=nums3[j];\\n               nums3[j]=nums3[j+1];\\n               nums3[j+1]=temp;\\n               }\\n           }\\n        }\\n        System.out.print(\"[\");\\n        for(int i=0;i<sum;i++)\\n        {\\n            System.out.print(nums3[i]);\\n            if(i!=sum-1)\\n            {\\n              System.out.print(\",\");  \\n            }\\n        }\\n        System.out.print(\"]\");\\n    }\\n}"
                    },
                    {
                        "username": "manuheralagi4",
                        "content": "class Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        z=len(nums1)-m\\n        x=len(nums2)-n\\n\\n        for i in range (z):\\n            nums1.pop()\\n        for i in range (x):\\n            nums2.pop()\\n        nums1=nums1+nums2\\n        nums1.sort()\\n        return nums1\\n\\n---------------------------------------------\\nwhen i am running in my system console it is giving the correct answer but not in leetcode terminal"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "whats wrong in this code bros??why third test case isnt successful??\\nint ptr1= m-1;\\n    int ptr2 = n-1;\\n    int ptr3 = nums1.length-1;int flag= 0;\\n    \\n    if(m==0&&n==0)\\n    return;\\n    else if(m==0&&n!=0)\\n    {   \\n        nums1= nums2;\\n        return;\\n    }\\n    else if(n==0)\\n    return;\\n    else\\n    {\\n        for(;ptr3>=0;--ptr3)\\n        {\\n            nums1[ptr3] = Math.max(nums1[ptr1],nums2[ptr2]);\\n            if(nums1[ptr1]>nums2[ptr2])\\n            --ptr1;\\n            else \\n            --ptr2;\\n            if(ptr2<0)\\n            break;\\n            if(ptr1<0)\\n            {\\n                flag= 1;\\n                --ptr3;\\n                break;\\n            }\\n        }\\n        if(flag==1)\\n        for(;ptr3>=0;--ptr3 )\\n        {\\n            nums1[ptr3]=nums2[ptr2];\\n            --ptr2;\\n        }\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "  public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int merge[]=new int[m+n];\\n        System.arraycopy(nums1,0,merge,0,m);\\n        System.arraycopy(nums2,0,merge,m,n);\\n        Arrays.sort(merge);\\n        System.out.println(Arrays.toString(merge));\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "knirmal499",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=0; i<nums2.length; i++)\\n            nums1[m++] = nums2[i];\\n        Arrays.sort(nums1);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mlahari2004",
                        "content": "My code is running in both vs code and online gdb. But in this compiler it\\'s showing a compile error:\\nLine 42: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\nint main(int argc, char *argv[]) {"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": "mine is java code"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int j=0;\\n        for(int i=0;i<m &&j<n;++i){\\n            if(nums1[i]==0){\\n                nums1[i] = nums2[j];    \\n                j++;\\n            }\\n        }\\n        //bubble sort\\n        for(int i=0;i<m-1;++i){\\n            if(nums1[i]>nums1[i+1]){\\n                int temp = nums1[i];\\n                nums1[i] = nums1[i+1];\\n                nums1[i+1] = temp;\\n            } \\n        }\\n\\n    }\\n}\\ni dont understand why the first for loop itself is not working,if anyone can find the problem,please help me"
                    },
                    {
                        "username": "SarKurd",
                        "content": "If you know Merge Sort then you can solve this easily.\\nbasically merge helper from Merge Sort."
                    },
                    {
                        "username": "akmuir",
                        "content": "When I print nums1 it shows me the correct output. However the output itself shows me something different from what is actually stored in my nums1, why is this?"
                    }
                ]
            },
            {
                "id": 1948035,
                "content": [
                    {
                        "username": "Mehdavii",
                        "content": "I wrote completely correct solution but why is it not accepting it?\\nWhats wrong with:\\nnums1=nums1[:m]+nums2\\nnums1.sort()\\n"
                    },
                    {
                        "username": "abhishekgupta744",
                        "content": "Why my program is not getting passed\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int sum=n+m, temp=0;\\n        int[] nums3 = new int[sum];\\n        int k=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            if(nums1[i]!=0)\\n            {\\n                nums3[k]=nums1[i];\\n                k++;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums2[i]!=0)\\n            {\\n                nums3[k]=nums2[i];\\n                k++;\\n            }\\n        }\\n        for(int i=0;i<sum;i++)\\n        {\\n           for(int j=0;j<sum-i-1;j++)\\n           {\\n               if(nums3[j]>nums3[j+1])\\n               {\\n               temp=nums3[j];\\n               nums3[j]=nums3[j+1];\\n               nums3[j+1]=temp;\\n               }\\n           }\\n        }\\n        System.out.print(\"[\");\\n        for(int i=0;i<sum;i++)\\n        {\\n            System.out.print(nums3[i]);\\n            if(i!=sum-1)\\n            {\\n              System.out.print(\",\");  \\n            }\\n        }\\n        System.out.print(\"]\");\\n    }\\n}"
                    },
                    {
                        "username": "manuheralagi4",
                        "content": "class Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        z=len(nums1)-m\\n        x=len(nums2)-n\\n\\n        for i in range (z):\\n            nums1.pop()\\n        for i in range (x):\\n            nums2.pop()\\n        nums1=nums1+nums2\\n        nums1.sort()\\n        return nums1\\n\\n---------------------------------------------\\nwhen i am running in my system console it is giving the correct answer but not in leetcode terminal"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "whats wrong in this code bros??why third test case isnt successful??\\nint ptr1= m-1;\\n    int ptr2 = n-1;\\n    int ptr3 = nums1.length-1;int flag= 0;\\n    \\n    if(m==0&&n==0)\\n    return;\\n    else if(m==0&&n!=0)\\n    {   \\n        nums1= nums2;\\n        return;\\n    }\\n    else if(n==0)\\n    return;\\n    else\\n    {\\n        for(;ptr3>=0;--ptr3)\\n        {\\n            nums1[ptr3] = Math.max(nums1[ptr1],nums2[ptr2]);\\n            if(nums1[ptr1]>nums2[ptr2])\\n            --ptr1;\\n            else \\n            --ptr2;\\n            if(ptr2<0)\\n            break;\\n            if(ptr1<0)\\n            {\\n                flag= 1;\\n                --ptr3;\\n                break;\\n            }\\n        }\\n        if(flag==1)\\n        for(;ptr3>=0;--ptr3 )\\n        {\\n            nums1[ptr3]=nums2[ptr2];\\n            --ptr2;\\n        }\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "  public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int merge[]=new int[m+n];\\n        System.arraycopy(nums1,0,merge,0,m);\\n        System.arraycopy(nums2,0,merge,m,n);\\n        Arrays.sort(merge);\\n        System.out.println(Arrays.toString(merge));\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "knirmal499",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=0; i<nums2.length; i++)\\n            nums1[m++] = nums2[i];\\n        Arrays.sort(nums1);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mlahari2004",
                        "content": "My code is running in both vs code and online gdb. But in this compiler it\\'s showing a compile error:\\nLine 42: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\nint main(int argc, char *argv[]) {"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": "mine is java code"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int j=0;\\n        for(int i=0;i<m &&j<n;++i){\\n            if(nums1[i]==0){\\n                nums1[i] = nums2[j];    \\n                j++;\\n            }\\n        }\\n        //bubble sort\\n        for(int i=0;i<m-1;++i){\\n            if(nums1[i]>nums1[i+1]){\\n                int temp = nums1[i];\\n                nums1[i] = nums1[i+1];\\n                nums1[i+1] = temp;\\n            } \\n        }\\n\\n    }\\n}\\ni dont understand why the first for loop itself is not working,if anyone can find the problem,please help me"
                    },
                    {
                        "username": "SarKurd",
                        "content": "If you know Merge Sort then you can solve this easily.\\nbasically merge helper from Merge Sort."
                    },
                    {
                        "username": "akmuir",
                        "content": "When I print nums1 it shows me the correct output. However the output itself shows me something different from what is actually stored in my nums1, why is this?"
                    }
                ]
            },
            {
                "id": 1946970,
                "content": [
                    {
                        "username": "Mehdavii",
                        "content": "I wrote completely correct solution but why is it not accepting it?\\nWhats wrong with:\\nnums1=nums1[:m]+nums2\\nnums1.sort()\\n"
                    },
                    {
                        "username": "abhishekgupta744",
                        "content": "Why my program is not getting passed\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int sum=n+m, temp=0;\\n        int[] nums3 = new int[sum];\\n        int k=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            if(nums1[i]!=0)\\n            {\\n                nums3[k]=nums1[i];\\n                k++;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums2[i]!=0)\\n            {\\n                nums3[k]=nums2[i];\\n                k++;\\n            }\\n        }\\n        for(int i=0;i<sum;i++)\\n        {\\n           for(int j=0;j<sum-i-1;j++)\\n           {\\n               if(nums3[j]>nums3[j+1])\\n               {\\n               temp=nums3[j];\\n               nums3[j]=nums3[j+1];\\n               nums3[j+1]=temp;\\n               }\\n           }\\n        }\\n        System.out.print(\"[\");\\n        for(int i=0;i<sum;i++)\\n        {\\n            System.out.print(nums3[i]);\\n            if(i!=sum-1)\\n            {\\n              System.out.print(\",\");  \\n            }\\n        }\\n        System.out.print(\"]\");\\n    }\\n}"
                    },
                    {
                        "username": "manuheralagi4",
                        "content": "class Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        z=len(nums1)-m\\n        x=len(nums2)-n\\n\\n        for i in range (z):\\n            nums1.pop()\\n        for i in range (x):\\n            nums2.pop()\\n        nums1=nums1+nums2\\n        nums1.sort()\\n        return nums1\\n\\n---------------------------------------------\\nwhen i am running in my system console it is giving the correct answer but not in leetcode terminal"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "whats wrong in this code bros??why third test case isnt successful??\\nint ptr1= m-1;\\n    int ptr2 = n-1;\\n    int ptr3 = nums1.length-1;int flag= 0;\\n    \\n    if(m==0&&n==0)\\n    return;\\n    else if(m==0&&n!=0)\\n    {   \\n        nums1= nums2;\\n        return;\\n    }\\n    else if(n==0)\\n    return;\\n    else\\n    {\\n        for(;ptr3>=0;--ptr3)\\n        {\\n            nums1[ptr3] = Math.max(nums1[ptr1],nums2[ptr2]);\\n            if(nums1[ptr1]>nums2[ptr2])\\n            --ptr1;\\n            else \\n            --ptr2;\\n            if(ptr2<0)\\n            break;\\n            if(ptr1<0)\\n            {\\n                flag= 1;\\n                --ptr3;\\n                break;\\n            }\\n        }\\n        if(flag==1)\\n        for(;ptr3>=0;--ptr3 )\\n        {\\n            nums1[ptr3]=nums2[ptr2];\\n            --ptr2;\\n        }\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "  public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int merge[]=new int[m+n];\\n        System.arraycopy(nums1,0,merge,0,m);\\n        System.arraycopy(nums2,0,merge,m,n);\\n        Arrays.sort(merge);\\n        System.out.println(Arrays.toString(merge));\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "knirmal499",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=0; i<nums2.length; i++)\\n            nums1[m++] = nums2[i];\\n        Arrays.sort(nums1);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mlahari2004",
                        "content": "My code is running in both vs code and online gdb. But in this compiler it\\'s showing a compile error:\\nLine 42: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\nint main(int argc, char *argv[]) {"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": "mine is java code"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int j=0;\\n        for(int i=0;i<m &&j<n;++i){\\n            if(nums1[i]==0){\\n                nums1[i] = nums2[j];    \\n                j++;\\n            }\\n        }\\n        //bubble sort\\n        for(int i=0;i<m-1;++i){\\n            if(nums1[i]>nums1[i+1]){\\n                int temp = nums1[i];\\n                nums1[i] = nums1[i+1];\\n                nums1[i+1] = temp;\\n            } \\n        }\\n\\n    }\\n}\\ni dont understand why the first for loop itself is not working,if anyone can find the problem,please help me"
                    },
                    {
                        "username": "SarKurd",
                        "content": "If you know Merge Sort then you can solve this easily.\\nbasically merge helper from Merge Sort."
                    },
                    {
                        "username": "akmuir",
                        "content": "When I print nums1 it shows me the correct output. However the output itself shows me something different from what is actually stored in my nums1, why is this?"
                    }
                ]
            },
            {
                "id": 1946394,
                "content": [
                    {
                        "username": "Mehdavii",
                        "content": "I wrote completely correct solution but why is it not accepting it?\\nWhats wrong with:\\nnums1=nums1[:m]+nums2\\nnums1.sort()\\n"
                    },
                    {
                        "username": "abhishekgupta744",
                        "content": "Why my program is not getting passed\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int sum=n+m, temp=0;\\n        int[] nums3 = new int[sum];\\n        int k=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            if(nums1[i]!=0)\\n            {\\n                nums3[k]=nums1[i];\\n                k++;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums2[i]!=0)\\n            {\\n                nums3[k]=nums2[i];\\n                k++;\\n            }\\n        }\\n        for(int i=0;i<sum;i++)\\n        {\\n           for(int j=0;j<sum-i-1;j++)\\n           {\\n               if(nums3[j]>nums3[j+1])\\n               {\\n               temp=nums3[j];\\n               nums3[j]=nums3[j+1];\\n               nums3[j+1]=temp;\\n               }\\n           }\\n        }\\n        System.out.print(\"[\");\\n        for(int i=0;i<sum;i++)\\n        {\\n            System.out.print(nums3[i]);\\n            if(i!=sum-1)\\n            {\\n              System.out.print(\",\");  \\n            }\\n        }\\n        System.out.print(\"]\");\\n    }\\n}"
                    },
                    {
                        "username": "manuheralagi4",
                        "content": "class Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        z=len(nums1)-m\\n        x=len(nums2)-n\\n\\n        for i in range (z):\\n            nums1.pop()\\n        for i in range (x):\\n            nums2.pop()\\n        nums1=nums1+nums2\\n        nums1.sort()\\n        return nums1\\n\\n---------------------------------------------\\nwhen i am running in my system console it is giving the correct answer but not in leetcode terminal"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "whats wrong in this code bros??why third test case isnt successful??\\nint ptr1= m-1;\\n    int ptr2 = n-1;\\n    int ptr3 = nums1.length-1;int flag= 0;\\n    \\n    if(m==0&&n==0)\\n    return;\\n    else if(m==0&&n!=0)\\n    {   \\n        nums1= nums2;\\n        return;\\n    }\\n    else if(n==0)\\n    return;\\n    else\\n    {\\n        for(;ptr3>=0;--ptr3)\\n        {\\n            nums1[ptr3] = Math.max(nums1[ptr1],nums2[ptr2]);\\n            if(nums1[ptr1]>nums2[ptr2])\\n            --ptr1;\\n            else \\n            --ptr2;\\n            if(ptr2<0)\\n            break;\\n            if(ptr1<0)\\n            {\\n                flag= 1;\\n                --ptr3;\\n                break;\\n            }\\n        }\\n        if(flag==1)\\n        for(;ptr3>=0;--ptr3 )\\n        {\\n            nums1[ptr3]=nums2[ptr2];\\n            --ptr2;\\n        }\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "  public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int merge[]=new int[m+n];\\n        System.arraycopy(nums1,0,merge,0,m);\\n        System.arraycopy(nums2,0,merge,m,n);\\n        Arrays.sort(merge);\\n        System.out.println(Arrays.toString(merge));\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "knirmal499",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=0; i<nums2.length; i++)\\n            nums1[m++] = nums2[i];\\n        Arrays.sort(nums1);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mlahari2004",
                        "content": "My code is running in both vs code and online gdb. But in this compiler it\\'s showing a compile error:\\nLine 42: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\nint main(int argc, char *argv[]) {"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": "mine is java code"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int j=0;\\n        for(int i=0;i<m &&j<n;++i){\\n            if(nums1[i]==0){\\n                nums1[i] = nums2[j];    \\n                j++;\\n            }\\n        }\\n        //bubble sort\\n        for(int i=0;i<m-1;++i){\\n            if(nums1[i]>nums1[i+1]){\\n                int temp = nums1[i];\\n                nums1[i] = nums1[i+1];\\n                nums1[i+1] = temp;\\n            } \\n        }\\n\\n    }\\n}\\ni dont understand why the first for loop itself is not working,if anyone can find the problem,please help me"
                    },
                    {
                        "username": "SarKurd",
                        "content": "If you know Merge Sort then you can solve this easily.\\nbasically merge helper from Merge Sort."
                    },
                    {
                        "username": "akmuir",
                        "content": "When I print nums1 it shows me the correct output. However the output itself shows me something different from what is actually stored in my nums1, why is this?"
                    }
                ]
            },
            {
                "id": 1945734,
                "content": [
                    {
                        "username": "Mehdavii",
                        "content": "I wrote completely correct solution but why is it not accepting it?\\nWhats wrong with:\\nnums1=nums1[:m]+nums2\\nnums1.sort()\\n"
                    },
                    {
                        "username": "abhishekgupta744",
                        "content": "Why my program is not getting passed\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int sum=n+m, temp=0;\\n        int[] nums3 = new int[sum];\\n        int k=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            if(nums1[i]!=0)\\n            {\\n                nums3[k]=nums1[i];\\n                k++;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums2[i]!=0)\\n            {\\n                nums3[k]=nums2[i];\\n                k++;\\n            }\\n        }\\n        for(int i=0;i<sum;i++)\\n        {\\n           for(int j=0;j<sum-i-1;j++)\\n           {\\n               if(nums3[j]>nums3[j+1])\\n               {\\n               temp=nums3[j];\\n               nums3[j]=nums3[j+1];\\n               nums3[j+1]=temp;\\n               }\\n           }\\n        }\\n        System.out.print(\"[\");\\n        for(int i=0;i<sum;i++)\\n        {\\n            System.out.print(nums3[i]);\\n            if(i!=sum-1)\\n            {\\n              System.out.print(\",\");  \\n            }\\n        }\\n        System.out.print(\"]\");\\n    }\\n}"
                    },
                    {
                        "username": "manuheralagi4",
                        "content": "class Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        z=len(nums1)-m\\n        x=len(nums2)-n\\n\\n        for i in range (z):\\n            nums1.pop()\\n        for i in range (x):\\n            nums2.pop()\\n        nums1=nums1+nums2\\n        nums1.sort()\\n        return nums1\\n\\n---------------------------------------------\\nwhen i am running in my system console it is giving the correct answer but not in leetcode terminal"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "whats wrong in this code bros??why third test case isnt successful??\\nint ptr1= m-1;\\n    int ptr2 = n-1;\\n    int ptr3 = nums1.length-1;int flag= 0;\\n    \\n    if(m==0&&n==0)\\n    return;\\n    else if(m==0&&n!=0)\\n    {   \\n        nums1= nums2;\\n        return;\\n    }\\n    else if(n==0)\\n    return;\\n    else\\n    {\\n        for(;ptr3>=0;--ptr3)\\n        {\\n            nums1[ptr3] = Math.max(nums1[ptr1],nums2[ptr2]);\\n            if(nums1[ptr1]>nums2[ptr2])\\n            --ptr1;\\n            else \\n            --ptr2;\\n            if(ptr2<0)\\n            break;\\n            if(ptr1<0)\\n            {\\n                flag= 1;\\n                --ptr3;\\n                break;\\n            }\\n        }\\n        if(flag==1)\\n        for(;ptr3>=0;--ptr3 )\\n        {\\n            nums1[ptr3]=nums2[ptr2];\\n            --ptr2;\\n        }\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "  public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int merge[]=new int[m+n];\\n        System.arraycopy(nums1,0,merge,0,m);\\n        System.arraycopy(nums2,0,merge,m,n);\\n        Arrays.sort(merge);\\n        System.out.println(Arrays.toString(merge));\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "knirmal499",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=0; i<nums2.length; i++)\\n            nums1[m++] = nums2[i];\\n        Arrays.sort(nums1);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mlahari2004",
                        "content": "My code is running in both vs code and online gdb. But in this compiler it\\'s showing a compile error:\\nLine 42: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\nint main(int argc, char *argv[]) {"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": "mine is java code"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int j=0;\\n        for(int i=0;i<m &&j<n;++i){\\n            if(nums1[i]==0){\\n                nums1[i] = nums2[j];    \\n                j++;\\n            }\\n        }\\n        //bubble sort\\n        for(int i=0;i<m-1;++i){\\n            if(nums1[i]>nums1[i+1]){\\n                int temp = nums1[i];\\n                nums1[i] = nums1[i+1];\\n                nums1[i+1] = temp;\\n            } \\n        }\\n\\n    }\\n}\\ni dont understand why the first for loop itself is not working,if anyone can find the problem,please help me"
                    },
                    {
                        "username": "SarKurd",
                        "content": "If you know Merge Sort then you can solve this easily.\\nbasically merge helper from Merge Sort."
                    },
                    {
                        "username": "akmuir",
                        "content": "When I print nums1 it shows me the correct output. However the output itself shows me something different from what is actually stored in my nums1, why is this?"
                    }
                ]
            },
            {
                "id": 1945607,
                "content": [
                    {
                        "username": "Mehdavii",
                        "content": "I wrote completely correct solution but why is it not accepting it?\\nWhats wrong with:\\nnums1=nums1[:m]+nums2\\nnums1.sort()\\n"
                    },
                    {
                        "username": "abhishekgupta744",
                        "content": "Why my program is not getting passed\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int sum=n+m, temp=0;\\n        int[] nums3 = new int[sum];\\n        int k=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            if(nums1[i]!=0)\\n            {\\n                nums3[k]=nums1[i];\\n                k++;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums2[i]!=0)\\n            {\\n                nums3[k]=nums2[i];\\n                k++;\\n            }\\n        }\\n        for(int i=0;i<sum;i++)\\n        {\\n           for(int j=0;j<sum-i-1;j++)\\n           {\\n               if(nums3[j]>nums3[j+1])\\n               {\\n               temp=nums3[j];\\n               nums3[j]=nums3[j+1];\\n               nums3[j+1]=temp;\\n               }\\n           }\\n        }\\n        System.out.print(\"[\");\\n        for(int i=0;i<sum;i++)\\n        {\\n            System.out.print(nums3[i]);\\n            if(i!=sum-1)\\n            {\\n              System.out.print(\",\");  \\n            }\\n        }\\n        System.out.print(\"]\");\\n    }\\n}"
                    },
                    {
                        "username": "manuheralagi4",
                        "content": "class Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        z=len(nums1)-m\\n        x=len(nums2)-n\\n\\n        for i in range (z):\\n            nums1.pop()\\n        for i in range (x):\\n            nums2.pop()\\n        nums1=nums1+nums2\\n        nums1.sort()\\n        return nums1\\n\\n---------------------------------------------\\nwhen i am running in my system console it is giving the correct answer but not in leetcode terminal"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "whats wrong in this code bros??why third test case isnt successful??\\nint ptr1= m-1;\\n    int ptr2 = n-1;\\n    int ptr3 = nums1.length-1;int flag= 0;\\n    \\n    if(m==0&&n==0)\\n    return;\\n    else if(m==0&&n!=0)\\n    {   \\n        nums1= nums2;\\n        return;\\n    }\\n    else if(n==0)\\n    return;\\n    else\\n    {\\n        for(;ptr3>=0;--ptr3)\\n        {\\n            nums1[ptr3] = Math.max(nums1[ptr1],nums2[ptr2]);\\n            if(nums1[ptr1]>nums2[ptr2])\\n            --ptr1;\\n            else \\n            --ptr2;\\n            if(ptr2<0)\\n            break;\\n            if(ptr1<0)\\n            {\\n                flag= 1;\\n                --ptr3;\\n                break;\\n            }\\n        }\\n        if(flag==1)\\n        for(;ptr3>=0;--ptr3 )\\n        {\\n            nums1[ptr3]=nums2[ptr2];\\n            --ptr2;\\n        }\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "  public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int merge[]=new int[m+n];\\n        System.arraycopy(nums1,0,merge,0,m);\\n        System.arraycopy(nums2,0,merge,m,n);\\n        Arrays.sort(merge);\\n        System.out.println(Arrays.toString(merge));\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "knirmal499",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=0; i<nums2.length; i++)\\n            nums1[m++] = nums2[i];\\n        Arrays.sort(nums1);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mlahari2004",
                        "content": "My code is running in both vs code and online gdb. But in this compiler it\\'s showing a compile error:\\nLine 42: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\nint main(int argc, char *argv[]) {"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": "mine is java code"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int j=0;\\n        for(int i=0;i<m &&j<n;++i){\\n            if(nums1[i]==0){\\n                nums1[i] = nums2[j];    \\n                j++;\\n            }\\n        }\\n        //bubble sort\\n        for(int i=0;i<m-1;++i){\\n            if(nums1[i]>nums1[i+1]){\\n                int temp = nums1[i];\\n                nums1[i] = nums1[i+1];\\n                nums1[i+1] = temp;\\n            } \\n        }\\n\\n    }\\n}\\ni dont understand why the first for loop itself is not working,if anyone can find the problem,please help me"
                    },
                    {
                        "username": "SarKurd",
                        "content": "If you know Merge Sort then you can solve this easily.\\nbasically merge helper from Merge Sort."
                    },
                    {
                        "username": "akmuir",
                        "content": "When I print nums1 it shows me the correct output. However the output itself shows me something different from what is actually stored in my nums1, why is this?"
                    }
                ]
            },
            {
                "id": 1944218,
                "content": [
                    {
                        "username": "Mehdavii",
                        "content": "I wrote completely correct solution but why is it not accepting it?\\nWhats wrong with:\\nnums1=nums1[:m]+nums2\\nnums1.sort()\\n"
                    },
                    {
                        "username": "abhishekgupta744",
                        "content": "Why my program is not getting passed\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int sum=n+m, temp=0;\\n        int[] nums3 = new int[sum];\\n        int k=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            if(nums1[i]!=0)\\n            {\\n                nums3[k]=nums1[i];\\n                k++;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums2[i]!=0)\\n            {\\n                nums3[k]=nums2[i];\\n                k++;\\n            }\\n        }\\n        for(int i=0;i<sum;i++)\\n        {\\n           for(int j=0;j<sum-i-1;j++)\\n           {\\n               if(nums3[j]>nums3[j+1])\\n               {\\n               temp=nums3[j];\\n               nums3[j]=nums3[j+1];\\n               nums3[j+1]=temp;\\n               }\\n           }\\n        }\\n        System.out.print(\"[\");\\n        for(int i=0;i<sum;i++)\\n        {\\n            System.out.print(nums3[i]);\\n            if(i!=sum-1)\\n            {\\n              System.out.print(\",\");  \\n            }\\n        }\\n        System.out.print(\"]\");\\n    }\\n}"
                    },
                    {
                        "username": "manuheralagi4",
                        "content": "class Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        z=len(nums1)-m\\n        x=len(nums2)-n\\n\\n        for i in range (z):\\n            nums1.pop()\\n        for i in range (x):\\n            nums2.pop()\\n        nums1=nums1+nums2\\n        nums1.sort()\\n        return nums1\\n\\n---------------------------------------------\\nwhen i am running in my system console it is giving the correct answer but not in leetcode terminal"
                    },
                    {
                        "username": "rishabhkumarpanthri",
                        "content": "whats wrong in this code bros??why third test case isnt successful??\\nint ptr1= m-1;\\n    int ptr2 = n-1;\\n    int ptr3 = nums1.length-1;int flag= 0;\\n    \\n    if(m==0&&n==0)\\n    return;\\n    else if(m==0&&n!=0)\\n    {   \\n        nums1= nums2;\\n        return;\\n    }\\n    else if(n==0)\\n    return;\\n    else\\n    {\\n        for(;ptr3>=0;--ptr3)\\n        {\\n            nums1[ptr3] = Math.max(nums1[ptr1],nums2[ptr2]);\\n            if(nums1[ptr1]>nums2[ptr2])\\n            --ptr1;\\n            else \\n            --ptr2;\\n            if(ptr2<0)\\n            break;\\n            if(ptr1<0)\\n            {\\n                flag= 1;\\n                --ptr3;\\n                break;\\n            }\\n        }\\n        if(flag==1)\\n        for(;ptr3>=0;--ptr3 )\\n        {\\n            nums1[ptr3]=nums2[ptr2];\\n            --ptr2;\\n        }\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "  public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int merge[]=new int[m+n];\\n        System.arraycopy(nums1,0,merge,0,m);\\n        System.arraycopy(nums2,0,merge,m,n);\\n        Arrays.sort(merge);\\n        System.out.println(Arrays.toString(merge));\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "knirmal499",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=0; i<nums2.length; i++)\\n            nums1[m++] = nums2[i];\\n        Arrays.sort(nums1);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mlahari2004",
                        "content": "My code is running in both vs code and online gdb. But in this compiler it\\'s showing a compile error:\\nLine 42: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\nint main(int argc, char *argv[]) {"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": "mine is java code"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int j=0;\\n        for(int i=0;i<m &&j<n;++i){\\n            if(nums1[i]==0){\\n                nums1[i] = nums2[j];    \\n                j++;\\n            }\\n        }\\n        //bubble sort\\n        for(int i=0;i<m-1;++i){\\n            if(nums1[i]>nums1[i+1]){\\n                int temp = nums1[i];\\n                nums1[i] = nums1[i+1];\\n                nums1[i+1] = temp;\\n            } \\n        }\\n\\n    }\\n}\\ni dont understand why the first for loop itself is not working,if anyone can find the problem,please help me"
                    },
                    {
                        "username": "SarKurd",
                        "content": "If you know Merge Sort then you can solve this easily.\\nbasically merge helper from Merge Sort."
                    },
                    {
                        "username": "akmuir",
                        "content": "When I print nums1 it shows me the correct output. However the output itself shows me something different from what is actually stored in my nums1, why is this?"
                    }
                ]
            },
            {
                "id": 1937559,
                "content": [
                    {
                        "username": "lazim",
                        "content": "function merge(nums1, m, nums2, n) {\\n\\tlet filteredArray = nums1.filter(num => num !== 0);\\n    filteredArray = filteredArray.concat(nums2);\\n    return filteredArray.sort((a, b) => a - b);\\n};\\ncan anybody explain why this code failing because in my chrome developer tool when i execute this code am getting the correct array returned [1,2,2,3,5,6] but in leet its console its showing [1,2,3,0,0,0]"
                    },
                    {
                        "username": "Anik0071",
                        "content": "The final sorted array should not be returned by the function, but instead be stored inside the array nums1. carefully read the statement again, it says you have to return the merge sorted array in nums1, you shouldn't use any other list.\n\n[@lazim](/lazim)\nplease upvote if you find this helpful thanks."
                    },
                    {
                        "username": "GandhamJayanth",
                        "content": " def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        li = []\\n        for i in range(m):\\n            li.append(nums1[i])\\n        for i in range(n):\\n            li.append(nums2[i])\\n        return li\\nwhat\\'s wrong with this"
                    },
                    {
                        "username": "Anik0071",
                        "content": "The final sorted array should not be returned by the function, but instead be stored inside the array nums1.  carefully read the statement again, it says you have to return the merge sorted array in nums1, you shouldn't use any other list.\n\n[@G V S Jayanth](/GandhamJayanth)\nplease upvote if you find this helpfull thanks."
                    },
                    {
                        "username": "justkexit",
                        "content": "How come \"sorted in non-decreasing order\" when in the first test case 0 appears after 3?"
                    },
                    {
                        "username": "Anik0071",
                        "content": "nums1 = [1,2,3,0,0,0], m = 3\nyou have to take the number  3 index as m=3.  which is 1 2  3 and these are in non-decreasing(increasing) order."
                    },
                    {
                        "username": "proparitoshsingh",
                        "content": "Can\\'t they just write \"increasing\" instead of \" non-decreasing order\""
                    },
                    {
                        "username": "PaarthKhandelwal",
                        "content": "My code is giving the following runtime :-\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nCan anyone help?\\n\\nMy code is as follows:- \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int x = nums1.size()+nums2.size();\\n        long long int arr[x];\\n\\n        int i=0, j=0,k=0;\\n\\n        while(i<m && j<n){\\n            if(nums1[i]<nums2[j]){\\n                arr[k] = nums1[i];\\n                i++;\\n                k++;\\n            }\\n            else{\\n                arr[k] == nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        while(i<m && k<x){\\n            arr[k] = nums1[i];\\n            i++;\\n            k++;\\n        }\\n        while(j<n && k<x){\\n            arr[k] = nums2[j];\\n            j++;\\n            k++;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "santoshlipare",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int size = 0;\\n        int count = 0;\\n        if (m > 0 && n > 0) {\\n            size = m + n ; \\n        } else if (m > 0) {\\n            size = m;    \\n        } else {\\n            size = n;    \\n        } \\n        int [] result = new int[size];\\n        int i=0, j=0;\\n        for (int k=0;k<size;k++) {\\n            if (i < m && j < n) {\\n                if (nums1[i] < nums2[j]) {\\n                    result[k] = nums1[i];\\n                    i++;\\n                } else {\\n                    result[k] = nums2[j];\\n                    j++;\\n                } \\n            } else if (i < m){\\n               result[k] = nums1[i];\\n               i++;\\n            } else {\\n                result[k] = nums2[j];\\n                j++;\\n            } \\n        }      \\n        nums1 = new int[result.length];         \\n        nums1 = result;\\n    }\\n\\nWhat is wrong in this solution"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "function mergeArrays(nums1, m, nums2, n) {\n  return nums1.slice(0, m).concat(nums2.slice(0, n));\n}\n\n// example\nlet nums1 = [1, 2, 3, 0, 0, 0];\nlet m = 3;\nlet nums2 = [2, 5, 6];\nlet n = 3;\n\nlet mergedArray = mergeArrays(nums1, m, nums2, n);\nconsole.log(mergedArray);\nI wrote like this simple method "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are so smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ronokghosal",
                        "content": "Tried to do a o(m+n) solution and it very well works perfectly on my intellij IDE and on leetcode it gives time Exceeded for mergeSort : Can someone help doublecheclk where I am going wrong?\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\n\\n       int i = m + n-1 ; // end of nums1\\n\\t   int j = m-1;\\n\\t   int k = n-1;\\n\\n    outerloop:\\n\\t  while( ! (i < 0 )) {\\n\\t\\tif ( nums1.length == 0 && nums2.length == 0 ){\\n\\t\\t\\t    \\tbreak outerloop;\\n\\t\\t}\\n\\t\\telse if ( nums1.length == 0 && nums2.length != 0 )\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnums1 = nums2;\\n\\t\\t\\t\\t\\t\\t\\tbreak outerloop;\\n\\t\\t\\t\\t\\t}\\n\\t\\telse if ( nums2.length == 0 && nums2.length != 0 )\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tbreak outerloop;\\n\\t\\t}\\n        else if( nums2.length != 0  && nums2.length != 0 ) {\\n\\n\\t  \\tif (nums2[k] > nums1[j]) {\\n\\t  \\t\\tnums1[i] = nums2[k];\\n\\t\\t\\t    k--;\\n\\t\\t\\t    i--;\\n\\t\\t\\t    if(k<0) {\\n\\t\\t\\t\\t   break outerloop;\\n\\t\\t\\t    }\\n\\t    } else if (nums2[k] <  nums1[j])\\n\\t\\t    {\\n\\t\\t    nums1[i] = nums1[j];\\n\\n\\t\\t\\t nums1[j] = 0;\\n\\t\\t\\t    j--;\\n\\t            i--;\\n\\t            if (j < 0 ) {\\n\\t            \\tj = 0;\\n\\t            }\\n\\n\\t  } else if (nums2[k] == nums1[j]) {\\n\\t\\t    nums1[i] = nums1[j];\\n\\t\\t    nums1[j] = 0;\\n\\n            i--;\\n            j--;\\n\\t\\t    if (j < 0 ) {\\n\\t\\t\\t    j = 0;\\n\\t\\t    }\\n\\n\\t    }\\n\\t  }\\n\\t\\t}\\n\\t}\\n}"
                    },
                    {
                        "username": "atulsinghrajput21",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "memebelarusguy",
                        "content": "SOLUTION!!!\nconst merge = function(nums1, m, nums2, n) {\n    return [...nums1.slice(0,m),...nums2.slice(0,n)].sort()\n};\nMy solution won't work. At other online compilers it work's correctly."
                    }
                ]
            },
            {
                "id": 1937257,
                "content": [
                    {
                        "username": "lazim",
                        "content": "function merge(nums1, m, nums2, n) {\\n\\tlet filteredArray = nums1.filter(num => num !== 0);\\n    filteredArray = filteredArray.concat(nums2);\\n    return filteredArray.sort((a, b) => a - b);\\n};\\ncan anybody explain why this code failing because in my chrome developer tool when i execute this code am getting the correct array returned [1,2,2,3,5,6] but in leet its console its showing [1,2,3,0,0,0]"
                    },
                    {
                        "username": "Anik0071",
                        "content": "The final sorted array should not be returned by the function, but instead be stored inside the array nums1. carefully read the statement again, it says you have to return the merge sorted array in nums1, you shouldn't use any other list.\n\n[@lazim](/lazim)\nplease upvote if you find this helpful thanks."
                    },
                    {
                        "username": "GandhamJayanth",
                        "content": " def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        li = []\\n        for i in range(m):\\n            li.append(nums1[i])\\n        for i in range(n):\\n            li.append(nums2[i])\\n        return li\\nwhat\\'s wrong with this"
                    },
                    {
                        "username": "Anik0071",
                        "content": "The final sorted array should not be returned by the function, but instead be stored inside the array nums1.  carefully read the statement again, it says you have to return the merge sorted array in nums1, you shouldn't use any other list.\n\n[@G V S Jayanth](/GandhamJayanth)\nplease upvote if you find this helpfull thanks."
                    },
                    {
                        "username": "justkexit",
                        "content": "How come \"sorted in non-decreasing order\" when in the first test case 0 appears after 3?"
                    },
                    {
                        "username": "Anik0071",
                        "content": "nums1 = [1,2,3,0,0,0], m = 3\nyou have to take the number  3 index as m=3.  which is 1 2  3 and these are in non-decreasing(increasing) order."
                    },
                    {
                        "username": "proparitoshsingh",
                        "content": "Can\\'t they just write \"increasing\" instead of \" non-decreasing order\""
                    },
                    {
                        "username": "PaarthKhandelwal",
                        "content": "My code is giving the following runtime :-\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nCan anyone help?\\n\\nMy code is as follows:- \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int x = nums1.size()+nums2.size();\\n        long long int arr[x];\\n\\n        int i=0, j=0,k=0;\\n\\n        while(i<m && j<n){\\n            if(nums1[i]<nums2[j]){\\n                arr[k] = nums1[i];\\n                i++;\\n                k++;\\n            }\\n            else{\\n                arr[k] == nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        while(i<m && k<x){\\n            arr[k] = nums1[i];\\n            i++;\\n            k++;\\n        }\\n        while(j<n && k<x){\\n            arr[k] = nums2[j];\\n            j++;\\n            k++;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "santoshlipare",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int size = 0;\\n        int count = 0;\\n        if (m > 0 && n > 0) {\\n            size = m + n ; \\n        } else if (m > 0) {\\n            size = m;    \\n        } else {\\n            size = n;    \\n        } \\n        int [] result = new int[size];\\n        int i=0, j=0;\\n        for (int k=0;k<size;k++) {\\n            if (i < m && j < n) {\\n                if (nums1[i] < nums2[j]) {\\n                    result[k] = nums1[i];\\n                    i++;\\n                } else {\\n                    result[k] = nums2[j];\\n                    j++;\\n                } \\n            } else if (i < m){\\n               result[k] = nums1[i];\\n               i++;\\n            } else {\\n                result[k] = nums2[j];\\n                j++;\\n            } \\n        }      \\n        nums1 = new int[result.length];         \\n        nums1 = result;\\n    }\\n\\nWhat is wrong in this solution"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "function mergeArrays(nums1, m, nums2, n) {\n  return nums1.slice(0, m).concat(nums2.slice(0, n));\n}\n\n// example\nlet nums1 = [1, 2, 3, 0, 0, 0];\nlet m = 3;\nlet nums2 = [2, 5, 6];\nlet n = 3;\n\nlet mergedArray = mergeArrays(nums1, m, nums2, n);\nconsole.log(mergedArray);\nI wrote like this simple method "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are so smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ronokghosal",
                        "content": "Tried to do a o(m+n) solution and it very well works perfectly on my intellij IDE and on leetcode it gives time Exceeded for mergeSort : Can someone help doublecheclk where I am going wrong?\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\n\\n       int i = m + n-1 ; // end of nums1\\n\\t   int j = m-1;\\n\\t   int k = n-1;\\n\\n    outerloop:\\n\\t  while( ! (i < 0 )) {\\n\\t\\tif ( nums1.length == 0 && nums2.length == 0 ){\\n\\t\\t\\t    \\tbreak outerloop;\\n\\t\\t}\\n\\t\\telse if ( nums1.length == 0 && nums2.length != 0 )\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnums1 = nums2;\\n\\t\\t\\t\\t\\t\\t\\tbreak outerloop;\\n\\t\\t\\t\\t\\t}\\n\\t\\telse if ( nums2.length == 0 && nums2.length != 0 )\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tbreak outerloop;\\n\\t\\t}\\n        else if( nums2.length != 0  && nums2.length != 0 ) {\\n\\n\\t  \\tif (nums2[k] > nums1[j]) {\\n\\t  \\t\\tnums1[i] = nums2[k];\\n\\t\\t\\t    k--;\\n\\t\\t\\t    i--;\\n\\t\\t\\t    if(k<0) {\\n\\t\\t\\t\\t   break outerloop;\\n\\t\\t\\t    }\\n\\t    } else if (nums2[k] <  nums1[j])\\n\\t\\t    {\\n\\t\\t    nums1[i] = nums1[j];\\n\\n\\t\\t\\t nums1[j] = 0;\\n\\t\\t\\t    j--;\\n\\t            i--;\\n\\t            if (j < 0 ) {\\n\\t            \\tj = 0;\\n\\t            }\\n\\n\\t  } else if (nums2[k] == nums1[j]) {\\n\\t\\t    nums1[i] = nums1[j];\\n\\t\\t    nums1[j] = 0;\\n\\n            i--;\\n            j--;\\n\\t\\t    if (j < 0 ) {\\n\\t\\t\\t    j = 0;\\n\\t\\t    }\\n\\n\\t    }\\n\\t  }\\n\\t\\t}\\n\\t}\\n}"
                    },
                    {
                        "username": "atulsinghrajput21",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "memebelarusguy",
                        "content": "SOLUTION!!!\nconst merge = function(nums1, m, nums2, n) {\n    return [...nums1.slice(0,m),...nums2.slice(0,n)].sort()\n};\nMy solution won't work. At other online compilers it work's correctly."
                    }
                ]
            },
            {
                "id": 1933000,
                "content": [
                    {
                        "username": "lazim",
                        "content": "function merge(nums1, m, nums2, n) {\\n\\tlet filteredArray = nums1.filter(num => num !== 0);\\n    filteredArray = filteredArray.concat(nums2);\\n    return filteredArray.sort((a, b) => a - b);\\n};\\ncan anybody explain why this code failing because in my chrome developer tool when i execute this code am getting the correct array returned [1,2,2,3,5,6] but in leet its console its showing [1,2,3,0,0,0]"
                    },
                    {
                        "username": "Anik0071",
                        "content": "The final sorted array should not be returned by the function, but instead be stored inside the array nums1. carefully read the statement again, it says you have to return the merge sorted array in nums1, you shouldn't use any other list.\n\n[@lazim](/lazim)\nplease upvote if you find this helpful thanks."
                    },
                    {
                        "username": "GandhamJayanth",
                        "content": " def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        li = []\\n        for i in range(m):\\n            li.append(nums1[i])\\n        for i in range(n):\\n            li.append(nums2[i])\\n        return li\\nwhat\\'s wrong with this"
                    },
                    {
                        "username": "Anik0071",
                        "content": "The final sorted array should not be returned by the function, but instead be stored inside the array nums1.  carefully read the statement again, it says you have to return the merge sorted array in nums1, you shouldn't use any other list.\n\n[@G V S Jayanth](/GandhamJayanth)\nplease upvote if you find this helpfull thanks."
                    },
                    {
                        "username": "justkexit",
                        "content": "How come \"sorted in non-decreasing order\" when in the first test case 0 appears after 3?"
                    },
                    {
                        "username": "Anik0071",
                        "content": "nums1 = [1,2,3,0,0,0], m = 3\nyou have to take the number  3 index as m=3.  which is 1 2  3 and these are in non-decreasing(increasing) order."
                    },
                    {
                        "username": "proparitoshsingh",
                        "content": "Can\\'t they just write \"increasing\" instead of \" non-decreasing order\""
                    },
                    {
                        "username": "PaarthKhandelwal",
                        "content": "My code is giving the following runtime :-\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nCan anyone help?\\n\\nMy code is as follows:- \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int x = nums1.size()+nums2.size();\\n        long long int arr[x];\\n\\n        int i=0, j=0,k=0;\\n\\n        while(i<m && j<n){\\n            if(nums1[i]<nums2[j]){\\n                arr[k] = nums1[i];\\n                i++;\\n                k++;\\n            }\\n            else{\\n                arr[k] == nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        while(i<m && k<x){\\n            arr[k] = nums1[i];\\n            i++;\\n            k++;\\n        }\\n        while(j<n && k<x){\\n            arr[k] = nums2[j];\\n            j++;\\n            k++;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "santoshlipare",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int size = 0;\\n        int count = 0;\\n        if (m > 0 && n > 0) {\\n            size = m + n ; \\n        } else if (m > 0) {\\n            size = m;    \\n        } else {\\n            size = n;    \\n        } \\n        int [] result = new int[size];\\n        int i=0, j=0;\\n        for (int k=0;k<size;k++) {\\n            if (i < m && j < n) {\\n                if (nums1[i] < nums2[j]) {\\n                    result[k] = nums1[i];\\n                    i++;\\n                } else {\\n                    result[k] = nums2[j];\\n                    j++;\\n                } \\n            } else if (i < m){\\n               result[k] = nums1[i];\\n               i++;\\n            } else {\\n                result[k] = nums2[j];\\n                j++;\\n            } \\n        }      \\n        nums1 = new int[result.length];         \\n        nums1 = result;\\n    }\\n\\nWhat is wrong in this solution"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "function mergeArrays(nums1, m, nums2, n) {\n  return nums1.slice(0, m).concat(nums2.slice(0, n));\n}\n\n// example\nlet nums1 = [1, 2, 3, 0, 0, 0];\nlet m = 3;\nlet nums2 = [2, 5, 6];\nlet n = 3;\n\nlet mergedArray = mergeArrays(nums1, m, nums2, n);\nconsole.log(mergedArray);\nI wrote like this simple method "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are so smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ronokghosal",
                        "content": "Tried to do a o(m+n) solution and it very well works perfectly on my intellij IDE and on leetcode it gives time Exceeded for mergeSort : Can someone help doublecheclk where I am going wrong?\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\n\\n       int i = m + n-1 ; // end of nums1\\n\\t   int j = m-1;\\n\\t   int k = n-1;\\n\\n    outerloop:\\n\\t  while( ! (i < 0 )) {\\n\\t\\tif ( nums1.length == 0 && nums2.length == 0 ){\\n\\t\\t\\t    \\tbreak outerloop;\\n\\t\\t}\\n\\t\\telse if ( nums1.length == 0 && nums2.length != 0 )\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnums1 = nums2;\\n\\t\\t\\t\\t\\t\\t\\tbreak outerloop;\\n\\t\\t\\t\\t\\t}\\n\\t\\telse if ( nums2.length == 0 && nums2.length != 0 )\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tbreak outerloop;\\n\\t\\t}\\n        else if( nums2.length != 0  && nums2.length != 0 ) {\\n\\n\\t  \\tif (nums2[k] > nums1[j]) {\\n\\t  \\t\\tnums1[i] = nums2[k];\\n\\t\\t\\t    k--;\\n\\t\\t\\t    i--;\\n\\t\\t\\t    if(k<0) {\\n\\t\\t\\t\\t   break outerloop;\\n\\t\\t\\t    }\\n\\t    } else if (nums2[k] <  nums1[j])\\n\\t\\t    {\\n\\t\\t    nums1[i] = nums1[j];\\n\\n\\t\\t\\t nums1[j] = 0;\\n\\t\\t\\t    j--;\\n\\t            i--;\\n\\t            if (j < 0 ) {\\n\\t            \\tj = 0;\\n\\t            }\\n\\n\\t  } else if (nums2[k] == nums1[j]) {\\n\\t\\t    nums1[i] = nums1[j];\\n\\t\\t    nums1[j] = 0;\\n\\n            i--;\\n            j--;\\n\\t\\t    if (j < 0 ) {\\n\\t\\t\\t    j = 0;\\n\\t\\t    }\\n\\n\\t    }\\n\\t  }\\n\\t\\t}\\n\\t}\\n}"
                    },
                    {
                        "username": "atulsinghrajput21",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "memebelarusguy",
                        "content": "SOLUTION!!!\nconst merge = function(nums1, m, nums2, n) {\n    return [...nums1.slice(0,m),...nums2.slice(0,n)].sort()\n};\nMy solution won't work. At other online compilers it work's correctly."
                    }
                ]
            },
            {
                "id": 1932931,
                "content": [
                    {
                        "username": "lazim",
                        "content": "function merge(nums1, m, nums2, n) {\\n\\tlet filteredArray = nums1.filter(num => num !== 0);\\n    filteredArray = filteredArray.concat(nums2);\\n    return filteredArray.sort((a, b) => a - b);\\n};\\ncan anybody explain why this code failing because in my chrome developer tool when i execute this code am getting the correct array returned [1,2,2,3,5,6] but in leet its console its showing [1,2,3,0,0,0]"
                    },
                    {
                        "username": "Anik0071",
                        "content": "The final sorted array should not be returned by the function, but instead be stored inside the array nums1. carefully read the statement again, it says you have to return the merge sorted array in nums1, you shouldn't use any other list.\n\n[@lazim](/lazim)\nplease upvote if you find this helpful thanks."
                    },
                    {
                        "username": "GandhamJayanth",
                        "content": " def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        li = []\\n        for i in range(m):\\n            li.append(nums1[i])\\n        for i in range(n):\\n            li.append(nums2[i])\\n        return li\\nwhat\\'s wrong with this"
                    },
                    {
                        "username": "Anik0071",
                        "content": "The final sorted array should not be returned by the function, but instead be stored inside the array nums1.  carefully read the statement again, it says you have to return the merge sorted array in nums1, you shouldn't use any other list.\n\n[@G V S Jayanth](/GandhamJayanth)\nplease upvote if you find this helpfull thanks."
                    },
                    {
                        "username": "justkexit",
                        "content": "How come \"sorted in non-decreasing order\" when in the first test case 0 appears after 3?"
                    },
                    {
                        "username": "Anik0071",
                        "content": "nums1 = [1,2,3,0,0,0], m = 3\nyou have to take the number  3 index as m=3.  which is 1 2  3 and these are in non-decreasing(increasing) order."
                    },
                    {
                        "username": "proparitoshsingh",
                        "content": "Can\\'t they just write \"increasing\" instead of \" non-decreasing order\""
                    },
                    {
                        "username": "PaarthKhandelwal",
                        "content": "My code is giving the following runtime :-\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nCan anyone help?\\n\\nMy code is as follows:- \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int x = nums1.size()+nums2.size();\\n        long long int arr[x];\\n\\n        int i=0, j=0,k=0;\\n\\n        while(i<m && j<n){\\n            if(nums1[i]<nums2[j]){\\n                arr[k] = nums1[i];\\n                i++;\\n                k++;\\n            }\\n            else{\\n                arr[k] == nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        while(i<m && k<x){\\n            arr[k] = nums1[i];\\n            i++;\\n            k++;\\n        }\\n        while(j<n && k<x){\\n            arr[k] = nums2[j];\\n            j++;\\n            k++;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "santoshlipare",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int size = 0;\\n        int count = 0;\\n        if (m > 0 && n > 0) {\\n            size = m + n ; \\n        } else if (m > 0) {\\n            size = m;    \\n        } else {\\n            size = n;    \\n        } \\n        int [] result = new int[size];\\n        int i=0, j=0;\\n        for (int k=0;k<size;k++) {\\n            if (i < m && j < n) {\\n                if (nums1[i] < nums2[j]) {\\n                    result[k] = nums1[i];\\n                    i++;\\n                } else {\\n                    result[k] = nums2[j];\\n                    j++;\\n                } \\n            } else if (i < m){\\n               result[k] = nums1[i];\\n               i++;\\n            } else {\\n                result[k] = nums2[j];\\n                j++;\\n            } \\n        }      \\n        nums1 = new int[result.length];         \\n        nums1 = result;\\n    }\\n\\nWhat is wrong in this solution"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "function mergeArrays(nums1, m, nums2, n) {\n  return nums1.slice(0, m).concat(nums2.slice(0, n));\n}\n\n// example\nlet nums1 = [1, 2, 3, 0, 0, 0];\nlet m = 3;\nlet nums2 = [2, 5, 6];\nlet n = 3;\n\nlet mergedArray = mergeArrays(nums1, m, nums2, n);\nconsole.log(mergedArray);\nI wrote like this simple method "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are so smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ronokghosal",
                        "content": "Tried to do a o(m+n) solution and it very well works perfectly on my intellij IDE and on leetcode it gives time Exceeded for mergeSort : Can someone help doublecheclk where I am going wrong?\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\n\\n       int i = m + n-1 ; // end of nums1\\n\\t   int j = m-1;\\n\\t   int k = n-1;\\n\\n    outerloop:\\n\\t  while( ! (i < 0 )) {\\n\\t\\tif ( nums1.length == 0 && nums2.length == 0 ){\\n\\t\\t\\t    \\tbreak outerloop;\\n\\t\\t}\\n\\t\\telse if ( nums1.length == 0 && nums2.length != 0 )\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnums1 = nums2;\\n\\t\\t\\t\\t\\t\\t\\tbreak outerloop;\\n\\t\\t\\t\\t\\t}\\n\\t\\telse if ( nums2.length == 0 && nums2.length != 0 )\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tbreak outerloop;\\n\\t\\t}\\n        else if( nums2.length != 0  && nums2.length != 0 ) {\\n\\n\\t  \\tif (nums2[k] > nums1[j]) {\\n\\t  \\t\\tnums1[i] = nums2[k];\\n\\t\\t\\t    k--;\\n\\t\\t\\t    i--;\\n\\t\\t\\t    if(k<0) {\\n\\t\\t\\t\\t   break outerloop;\\n\\t\\t\\t    }\\n\\t    } else if (nums2[k] <  nums1[j])\\n\\t\\t    {\\n\\t\\t    nums1[i] = nums1[j];\\n\\n\\t\\t\\t nums1[j] = 0;\\n\\t\\t\\t    j--;\\n\\t            i--;\\n\\t            if (j < 0 ) {\\n\\t            \\tj = 0;\\n\\t            }\\n\\n\\t  } else if (nums2[k] == nums1[j]) {\\n\\t\\t    nums1[i] = nums1[j];\\n\\t\\t    nums1[j] = 0;\\n\\n            i--;\\n            j--;\\n\\t\\t    if (j < 0 ) {\\n\\t\\t\\t    j = 0;\\n\\t\\t    }\\n\\n\\t    }\\n\\t  }\\n\\t\\t}\\n\\t}\\n}"
                    },
                    {
                        "username": "atulsinghrajput21",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "memebelarusguy",
                        "content": "SOLUTION!!!\nconst merge = function(nums1, m, nums2, n) {\n    return [...nums1.slice(0,m),...nums2.slice(0,n)].sort()\n};\nMy solution won't work. At other online compilers it work's correctly."
                    }
                ]
            },
            {
                "id": 1930951,
                "content": [
                    {
                        "username": "lazim",
                        "content": "function merge(nums1, m, nums2, n) {\\n\\tlet filteredArray = nums1.filter(num => num !== 0);\\n    filteredArray = filteredArray.concat(nums2);\\n    return filteredArray.sort((a, b) => a - b);\\n};\\ncan anybody explain why this code failing because in my chrome developer tool when i execute this code am getting the correct array returned [1,2,2,3,5,6] but in leet its console its showing [1,2,3,0,0,0]"
                    },
                    {
                        "username": "Anik0071",
                        "content": "The final sorted array should not be returned by the function, but instead be stored inside the array nums1. carefully read the statement again, it says you have to return the merge sorted array in nums1, you shouldn't use any other list.\n\n[@lazim](/lazim)\nplease upvote if you find this helpful thanks."
                    },
                    {
                        "username": "GandhamJayanth",
                        "content": " def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        li = []\\n        for i in range(m):\\n            li.append(nums1[i])\\n        for i in range(n):\\n            li.append(nums2[i])\\n        return li\\nwhat\\'s wrong with this"
                    },
                    {
                        "username": "Anik0071",
                        "content": "The final sorted array should not be returned by the function, but instead be stored inside the array nums1.  carefully read the statement again, it says you have to return the merge sorted array in nums1, you shouldn't use any other list.\n\n[@G V S Jayanth](/GandhamJayanth)\nplease upvote if you find this helpfull thanks."
                    },
                    {
                        "username": "justkexit",
                        "content": "How come \"sorted in non-decreasing order\" when in the first test case 0 appears after 3?"
                    },
                    {
                        "username": "Anik0071",
                        "content": "nums1 = [1,2,3,0,0,0], m = 3\nyou have to take the number  3 index as m=3.  which is 1 2  3 and these are in non-decreasing(increasing) order."
                    },
                    {
                        "username": "proparitoshsingh",
                        "content": "Can\\'t they just write \"increasing\" instead of \" non-decreasing order\""
                    },
                    {
                        "username": "PaarthKhandelwal",
                        "content": "My code is giving the following runtime :-\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nCan anyone help?\\n\\nMy code is as follows:- \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int x = nums1.size()+nums2.size();\\n        long long int arr[x];\\n\\n        int i=0, j=0,k=0;\\n\\n        while(i<m && j<n){\\n            if(nums1[i]<nums2[j]){\\n                arr[k] = nums1[i];\\n                i++;\\n                k++;\\n            }\\n            else{\\n                arr[k] == nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        while(i<m && k<x){\\n            arr[k] = nums1[i];\\n            i++;\\n            k++;\\n        }\\n        while(j<n && k<x){\\n            arr[k] = nums2[j];\\n            j++;\\n            k++;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "santoshlipare",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int size = 0;\\n        int count = 0;\\n        if (m > 0 && n > 0) {\\n            size = m + n ; \\n        } else if (m > 0) {\\n            size = m;    \\n        } else {\\n            size = n;    \\n        } \\n        int [] result = new int[size];\\n        int i=0, j=0;\\n        for (int k=0;k<size;k++) {\\n            if (i < m && j < n) {\\n                if (nums1[i] < nums2[j]) {\\n                    result[k] = nums1[i];\\n                    i++;\\n                } else {\\n                    result[k] = nums2[j];\\n                    j++;\\n                } \\n            } else if (i < m){\\n               result[k] = nums1[i];\\n               i++;\\n            } else {\\n                result[k] = nums2[j];\\n                j++;\\n            } \\n        }      \\n        nums1 = new int[result.length];         \\n        nums1 = result;\\n    }\\n\\nWhat is wrong in this solution"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "function mergeArrays(nums1, m, nums2, n) {\n  return nums1.slice(0, m).concat(nums2.slice(0, n));\n}\n\n// example\nlet nums1 = [1, 2, 3, 0, 0, 0];\nlet m = 3;\nlet nums2 = [2, 5, 6];\nlet n = 3;\n\nlet mergedArray = mergeArrays(nums1, m, nums2, n);\nconsole.log(mergedArray);\nI wrote like this simple method "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are so smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ronokghosal",
                        "content": "Tried to do a o(m+n) solution and it very well works perfectly on my intellij IDE and on leetcode it gives time Exceeded for mergeSort : Can someone help doublecheclk where I am going wrong?\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\n\\n       int i = m + n-1 ; // end of nums1\\n\\t   int j = m-1;\\n\\t   int k = n-1;\\n\\n    outerloop:\\n\\t  while( ! (i < 0 )) {\\n\\t\\tif ( nums1.length == 0 && nums2.length == 0 ){\\n\\t\\t\\t    \\tbreak outerloop;\\n\\t\\t}\\n\\t\\telse if ( nums1.length == 0 && nums2.length != 0 )\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnums1 = nums2;\\n\\t\\t\\t\\t\\t\\t\\tbreak outerloop;\\n\\t\\t\\t\\t\\t}\\n\\t\\telse if ( nums2.length == 0 && nums2.length != 0 )\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tbreak outerloop;\\n\\t\\t}\\n        else if( nums2.length != 0  && nums2.length != 0 ) {\\n\\n\\t  \\tif (nums2[k] > nums1[j]) {\\n\\t  \\t\\tnums1[i] = nums2[k];\\n\\t\\t\\t    k--;\\n\\t\\t\\t    i--;\\n\\t\\t\\t    if(k<0) {\\n\\t\\t\\t\\t   break outerloop;\\n\\t\\t\\t    }\\n\\t    } else if (nums2[k] <  nums1[j])\\n\\t\\t    {\\n\\t\\t    nums1[i] = nums1[j];\\n\\n\\t\\t\\t nums1[j] = 0;\\n\\t\\t\\t    j--;\\n\\t            i--;\\n\\t            if (j < 0 ) {\\n\\t            \\tj = 0;\\n\\t            }\\n\\n\\t  } else if (nums2[k] == nums1[j]) {\\n\\t\\t    nums1[i] = nums1[j];\\n\\t\\t    nums1[j] = 0;\\n\\n            i--;\\n            j--;\\n\\t\\t    if (j < 0 ) {\\n\\t\\t\\t    j = 0;\\n\\t\\t    }\\n\\n\\t    }\\n\\t  }\\n\\t\\t}\\n\\t}\\n}"
                    },
                    {
                        "username": "atulsinghrajput21",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "memebelarusguy",
                        "content": "SOLUTION!!!\nconst merge = function(nums1, m, nums2, n) {\n    return [...nums1.slice(0,m),...nums2.slice(0,n)].sort()\n};\nMy solution won't work. At other online compilers it work's correctly."
                    }
                ]
            },
            {
                "id": 1929275,
                "content": [
                    {
                        "username": "lazim",
                        "content": "function merge(nums1, m, nums2, n) {\\n\\tlet filteredArray = nums1.filter(num => num !== 0);\\n    filteredArray = filteredArray.concat(nums2);\\n    return filteredArray.sort((a, b) => a - b);\\n};\\ncan anybody explain why this code failing because in my chrome developer tool when i execute this code am getting the correct array returned [1,2,2,3,5,6] but in leet its console its showing [1,2,3,0,0,0]"
                    },
                    {
                        "username": "Anik0071",
                        "content": "The final sorted array should not be returned by the function, but instead be stored inside the array nums1. carefully read the statement again, it says you have to return the merge sorted array in nums1, you shouldn't use any other list.\n\n[@lazim](/lazim)\nplease upvote if you find this helpful thanks."
                    },
                    {
                        "username": "GandhamJayanth",
                        "content": " def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        li = []\\n        for i in range(m):\\n            li.append(nums1[i])\\n        for i in range(n):\\n            li.append(nums2[i])\\n        return li\\nwhat\\'s wrong with this"
                    },
                    {
                        "username": "Anik0071",
                        "content": "The final sorted array should not be returned by the function, but instead be stored inside the array nums1.  carefully read the statement again, it says you have to return the merge sorted array in nums1, you shouldn't use any other list.\n\n[@G V S Jayanth](/GandhamJayanth)\nplease upvote if you find this helpfull thanks."
                    },
                    {
                        "username": "justkexit",
                        "content": "How come \"sorted in non-decreasing order\" when in the first test case 0 appears after 3?"
                    },
                    {
                        "username": "Anik0071",
                        "content": "nums1 = [1,2,3,0,0,0], m = 3\nyou have to take the number  3 index as m=3.  which is 1 2  3 and these are in non-decreasing(increasing) order."
                    },
                    {
                        "username": "proparitoshsingh",
                        "content": "Can\\'t they just write \"increasing\" instead of \" non-decreasing order\""
                    },
                    {
                        "username": "PaarthKhandelwal",
                        "content": "My code is giving the following runtime :-\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nCan anyone help?\\n\\nMy code is as follows:- \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int x = nums1.size()+nums2.size();\\n        long long int arr[x];\\n\\n        int i=0, j=0,k=0;\\n\\n        while(i<m && j<n){\\n            if(nums1[i]<nums2[j]){\\n                arr[k] = nums1[i];\\n                i++;\\n                k++;\\n            }\\n            else{\\n                arr[k] == nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        while(i<m && k<x){\\n            arr[k] = nums1[i];\\n            i++;\\n            k++;\\n        }\\n        while(j<n && k<x){\\n            arr[k] = nums2[j];\\n            j++;\\n            k++;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "santoshlipare",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int size = 0;\\n        int count = 0;\\n        if (m > 0 && n > 0) {\\n            size = m + n ; \\n        } else if (m > 0) {\\n            size = m;    \\n        } else {\\n            size = n;    \\n        } \\n        int [] result = new int[size];\\n        int i=0, j=0;\\n        for (int k=0;k<size;k++) {\\n            if (i < m && j < n) {\\n                if (nums1[i] < nums2[j]) {\\n                    result[k] = nums1[i];\\n                    i++;\\n                } else {\\n                    result[k] = nums2[j];\\n                    j++;\\n                } \\n            } else if (i < m){\\n               result[k] = nums1[i];\\n               i++;\\n            } else {\\n                result[k] = nums2[j];\\n                j++;\\n            } \\n        }      \\n        nums1 = new int[result.length];         \\n        nums1 = result;\\n    }\\n\\nWhat is wrong in this solution"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "function mergeArrays(nums1, m, nums2, n) {\n  return nums1.slice(0, m).concat(nums2.slice(0, n));\n}\n\n// example\nlet nums1 = [1, 2, 3, 0, 0, 0];\nlet m = 3;\nlet nums2 = [2, 5, 6];\nlet n = 3;\n\nlet mergedArray = mergeArrays(nums1, m, nums2, n);\nconsole.log(mergedArray);\nI wrote like this simple method "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are so smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ronokghosal",
                        "content": "Tried to do a o(m+n) solution and it very well works perfectly on my intellij IDE and on leetcode it gives time Exceeded for mergeSort : Can someone help doublecheclk where I am going wrong?\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\n\\n       int i = m + n-1 ; // end of nums1\\n\\t   int j = m-1;\\n\\t   int k = n-1;\\n\\n    outerloop:\\n\\t  while( ! (i < 0 )) {\\n\\t\\tif ( nums1.length == 0 && nums2.length == 0 ){\\n\\t\\t\\t    \\tbreak outerloop;\\n\\t\\t}\\n\\t\\telse if ( nums1.length == 0 && nums2.length != 0 )\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnums1 = nums2;\\n\\t\\t\\t\\t\\t\\t\\tbreak outerloop;\\n\\t\\t\\t\\t\\t}\\n\\t\\telse if ( nums2.length == 0 && nums2.length != 0 )\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tbreak outerloop;\\n\\t\\t}\\n        else if( nums2.length != 0  && nums2.length != 0 ) {\\n\\n\\t  \\tif (nums2[k] > nums1[j]) {\\n\\t  \\t\\tnums1[i] = nums2[k];\\n\\t\\t\\t    k--;\\n\\t\\t\\t    i--;\\n\\t\\t\\t    if(k<0) {\\n\\t\\t\\t\\t   break outerloop;\\n\\t\\t\\t    }\\n\\t    } else if (nums2[k] <  nums1[j])\\n\\t\\t    {\\n\\t\\t    nums1[i] = nums1[j];\\n\\n\\t\\t\\t nums1[j] = 0;\\n\\t\\t\\t    j--;\\n\\t            i--;\\n\\t            if (j < 0 ) {\\n\\t            \\tj = 0;\\n\\t            }\\n\\n\\t  } else if (nums2[k] == nums1[j]) {\\n\\t\\t    nums1[i] = nums1[j];\\n\\t\\t    nums1[j] = 0;\\n\\n            i--;\\n            j--;\\n\\t\\t    if (j < 0 ) {\\n\\t\\t\\t    j = 0;\\n\\t\\t    }\\n\\n\\t    }\\n\\t  }\\n\\t\\t}\\n\\t}\\n}"
                    },
                    {
                        "username": "atulsinghrajput21",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "memebelarusguy",
                        "content": "SOLUTION!!!\nconst merge = function(nums1, m, nums2, n) {\n    return [...nums1.slice(0,m),...nums2.slice(0,n)].sort()\n};\nMy solution won't work. At other online compilers it work's correctly."
                    }
                ]
            },
            {
                "id": 1927916,
                "content": [
                    {
                        "username": "lazim",
                        "content": "function merge(nums1, m, nums2, n) {\\n\\tlet filteredArray = nums1.filter(num => num !== 0);\\n    filteredArray = filteredArray.concat(nums2);\\n    return filteredArray.sort((a, b) => a - b);\\n};\\ncan anybody explain why this code failing because in my chrome developer tool when i execute this code am getting the correct array returned [1,2,2,3,5,6] but in leet its console its showing [1,2,3,0,0,0]"
                    },
                    {
                        "username": "Anik0071",
                        "content": "The final sorted array should not be returned by the function, but instead be stored inside the array nums1. carefully read the statement again, it says you have to return the merge sorted array in nums1, you shouldn't use any other list.\n\n[@lazim](/lazim)\nplease upvote if you find this helpful thanks."
                    },
                    {
                        "username": "GandhamJayanth",
                        "content": " def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        li = []\\n        for i in range(m):\\n            li.append(nums1[i])\\n        for i in range(n):\\n            li.append(nums2[i])\\n        return li\\nwhat\\'s wrong with this"
                    },
                    {
                        "username": "Anik0071",
                        "content": "The final sorted array should not be returned by the function, but instead be stored inside the array nums1.  carefully read the statement again, it says you have to return the merge sorted array in nums1, you shouldn't use any other list.\n\n[@G V S Jayanth](/GandhamJayanth)\nplease upvote if you find this helpfull thanks."
                    },
                    {
                        "username": "justkexit",
                        "content": "How come \"sorted in non-decreasing order\" when in the first test case 0 appears after 3?"
                    },
                    {
                        "username": "Anik0071",
                        "content": "nums1 = [1,2,3,0,0,0], m = 3\nyou have to take the number  3 index as m=3.  which is 1 2  3 and these are in non-decreasing(increasing) order."
                    },
                    {
                        "username": "proparitoshsingh",
                        "content": "Can\\'t they just write \"increasing\" instead of \" non-decreasing order\""
                    },
                    {
                        "username": "PaarthKhandelwal",
                        "content": "My code is giving the following runtime :-\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nCan anyone help?\\n\\nMy code is as follows:- \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int x = nums1.size()+nums2.size();\\n        long long int arr[x];\\n\\n        int i=0, j=0,k=0;\\n\\n        while(i<m && j<n){\\n            if(nums1[i]<nums2[j]){\\n                arr[k] = nums1[i];\\n                i++;\\n                k++;\\n            }\\n            else{\\n                arr[k] == nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        while(i<m && k<x){\\n            arr[k] = nums1[i];\\n            i++;\\n            k++;\\n        }\\n        while(j<n && k<x){\\n            arr[k] = nums2[j];\\n            j++;\\n            k++;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "santoshlipare",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int size = 0;\\n        int count = 0;\\n        if (m > 0 && n > 0) {\\n            size = m + n ; \\n        } else if (m > 0) {\\n            size = m;    \\n        } else {\\n            size = n;    \\n        } \\n        int [] result = new int[size];\\n        int i=0, j=0;\\n        for (int k=0;k<size;k++) {\\n            if (i < m && j < n) {\\n                if (nums1[i] < nums2[j]) {\\n                    result[k] = nums1[i];\\n                    i++;\\n                } else {\\n                    result[k] = nums2[j];\\n                    j++;\\n                } \\n            } else if (i < m){\\n               result[k] = nums1[i];\\n               i++;\\n            } else {\\n                result[k] = nums2[j];\\n                j++;\\n            } \\n        }      \\n        nums1 = new int[result.length];         \\n        nums1 = result;\\n    }\\n\\nWhat is wrong in this solution"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "function mergeArrays(nums1, m, nums2, n) {\n  return nums1.slice(0, m).concat(nums2.slice(0, n));\n}\n\n// example\nlet nums1 = [1, 2, 3, 0, 0, 0];\nlet m = 3;\nlet nums2 = [2, 5, 6];\nlet n = 3;\n\nlet mergedArray = mergeArrays(nums1, m, nums2, n);\nconsole.log(mergedArray);\nI wrote like this simple method "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are so smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ronokghosal",
                        "content": "Tried to do a o(m+n) solution and it very well works perfectly on my intellij IDE and on leetcode it gives time Exceeded for mergeSort : Can someone help doublecheclk where I am going wrong?\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\n\\n       int i = m + n-1 ; // end of nums1\\n\\t   int j = m-1;\\n\\t   int k = n-1;\\n\\n    outerloop:\\n\\t  while( ! (i < 0 )) {\\n\\t\\tif ( nums1.length == 0 && nums2.length == 0 ){\\n\\t\\t\\t    \\tbreak outerloop;\\n\\t\\t}\\n\\t\\telse if ( nums1.length == 0 && nums2.length != 0 )\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnums1 = nums2;\\n\\t\\t\\t\\t\\t\\t\\tbreak outerloop;\\n\\t\\t\\t\\t\\t}\\n\\t\\telse if ( nums2.length == 0 && nums2.length != 0 )\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tbreak outerloop;\\n\\t\\t}\\n        else if( nums2.length != 0  && nums2.length != 0 ) {\\n\\n\\t  \\tif (nums2[k] > nums1[j]) {\\n\\t  \\t\\tnums1[i] = nums2[k];\\n\\t\\t\\t    k--;\\n\\t\\t\\t    i--;\\n\\t\\t\\t    if(k<0) {\\n\\t\\t\\t\\t   break outerloop;\\n\\t\\t\\t    }\\n\\t    } else if (nums2[k] <  nums1[j])\\n\\t\\t    {\\n\\t\\t    nums1[i] = nums1[j];\\n\\n\\t\\t\\t nums1[j] = 0;\\n\\t\\t\\t    j--;\\n\\t            i--;\\n\\t            if (j < 0 ) {\\n\\t            \\tj = 0;\\n\\t            }\\n\\n\\t  } else if (nums2[k] == nums1[j]) {\\n\\t\\t    nums1[i] = nums1[j];\\n\\t\\t    nums1[j] = 0;\\n\\n            i--;\\n            j--;\\n\\t\\t    if (j < 0 ) {\\n\\t\\t\\t    j = 0;\\n\\t\\t    }\\n\\n\\t    }\\n\\t  }\\n\\t\\t}\\n\\t}\\n}"
                    },
                    {
                        "username": "atulsinghrajput21",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "memebelarusguy",
                        "content": "SOLUTION!!!\nconst merge = function(nums1, m, nums2, n) {\n    return [...nums1.slice(0,m),...nums2.slice(0,n)].sort()\n};\nMy solution won't work. At other online compilers it work's correctly."
                    }
                ]
            },
            {
                "id": 1927098,
                "content": [
                    {
                        "username": "lazim",
                        "content": "function merge(nums1, m, nums2, n) {\\n\\tlet filteredArray = nums1.filter(num => num !== 0);\\n    filteredArray = filteredArray.concat(nums2);\\n    return filteredArray.sort((a, b) => a - b);\\n};\\ncan anybody explain why this code failing because in my chrome developer tool when i execute this code am getting the correct array returned [1,2,2,3,5,6] but in leet its console its showing [1,2,3,0,0,0]"
                    },
                    {
                        "username": "Anik0071",
                        "content": "The final sorted array should not be returned by the function, but instead be stored inside the array nums1. carefully read the statement again, it says you have to return the merge sorted array in nums1, you shouldn't use any other list.\n\n[@lazim](/lazim)\nplease upvote if you find this helpful thanks."
                    },
                    {
                        "username": "GandhamJayanth",
                        "content": " def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        li = []\\n        for i in range(m):\\n            li.append(nums1[i])\\n        for i in range(n):\\n            li.append(nums2[i])\\n        return li\\nwhat\\'s wrong with this"
                    },
                    {
                        "username": "Anik0071",
                        "content": "The final sorted array should not be returned by the function, but instead be stored inside the array nums1.  carefully read the statement again, it says you have to return the merge sorted array in nums1, you shouldn't use any other list.\n\n[@G V S Jayanth](/GandhamJayanth)\nplease upvote if you find this helpfull thanks."
                    },
                    {
                        "username": "justkexit",
                        "content": "How come \"sorted in non-decreasing order\" when in the first test case 0 appears after 3?"
                    },
                    {
                        "username": "Anik0071",
                        "content": "nums1 = [1,2,3,0,0,0], m = 3\nyou have to take the number  3 index as m=3.  which is 1 2  3 and these are in non-decreasing(increasing) order."
                    },
                    {
                        "username": "proparitoshsingh",
                        "content": "Can\\'t they just write \"increasing\" instead of \" non-decreasing order\""
                    },
                    {
                        "username": "PaarthKhandelwal",
                        "content": "My code is giving the following runtime :-\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nCan anyone help?\\n\\nMy code is as follows:- \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int x = nums1.size()+nums2.size();\\n        long long int arr[x];\\n\\n        int i=0, j=0,k=0;\\n\\n        while(i<m && j<n){\\n            if(nums1[i]<nums2[j]){\\n                arr[k] = nums1[i];\\n                i++;\\n                k++;\\n            }\\n            else{\\n                arr[k] == nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        while(i<m && k<x){\\n            arr[k] = nums1[i];\\n            i++;\\n            k++;\\n        }\\n        while(j<n && k<x){\\n            arr[k] = nums2[j];\\n            j++;\\n            k++;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "santoshlipare",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int size = 0;\\n        int count = 0;\\n        if (m > 0 && n > 0) {\\n            size = m + n ; \\n        } else if (m > 0) {\\n            size = m;    \\n        } else {\\n            size = n;    \\n        } \\n        int [] result = new int[size];\\n        int i=0, j=0;\\n        for (int k=0;k<size;k++) {\\n            if (i < m && j < n) {\\n                if (nums1[i] < nums2[j]) {\\n                    result[k] = nums1[i];\\n                    i++;\\n                } else {\\n                    result[k] = nums2[j];\\n                    j++;\\n                } \\n            } else if (i < m){\\n               result[k] = nums1[i];\\n               i++;\\n            } else {\\n                result[k] = nums2[j];\\n                j++;\\n            } \\n        }      \\n        nums1 = new int[result.length];         \\n        nums1 = result;\\n    }\\n\\nWhat is wrong in this solution"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "function mergeArrays(nums1, m, nums2, n) {\n  return nums1.slice(0, m).concat(nums2.slice(0, n));\n}\n\n// example\nlet nums1 = [1, 2, 3, 0, 0, 0];\nlet m = 3;\nlet nums2 = [2, 5, 6];\nlet n = 3;\n\nlet mergedArray = mergeArrays(nums1, m, nums2, n);\nconsole.log(mergedArray);\nI wrote like this simple method "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are so smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ronokghosal",
                        "content": "Tried to do a o(m+n) solution and it very well works perfectly on my intellij IDE and on leetcode it gives time Exceeded for mergeSort : Can someone help doublecheclk where I am going wrong?\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\n\\n       int i = m + n-1 ; // end of nums1\\n\\t   int j = m-1;\\n\\t   int k = n-1;\\n\\n    outerloop:\\n\\t  while( ! (i < 0 )) {\\n\\t\\tif ( nums1.length == 0 && nums2.length == 0 ){\\n\\t\\t\\t    \\tbreak outerloop;\\n\\t\\t}\\n\\t\\telse if ( nums1.length == 0 && nums2.length != 0 )\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnums1 = nums2;\\n\\t\\t\\t\\t\\t\\t\\tbreak outerloop;\\n\\t\\t\\t\\t\\t}\\n\\t\\telse if ( nums2.length == 0 && nums2.length != 0 )\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tbreak outerloop;\\n\\t\\t}\\n        else if( nums2.length != 0  && nums2.length != 0 ) {\\n\\n\\t  \\tif (nums2[k] > nums1[j]) {\\n\\t  \\t\\tnums1[i] = nums2[k];\\n\\t\\t\\t    k--;\\n\\t\\t\\t    i--;\\n\\t\\t\\t    if(k<0) {\\n\\t\\t\\t\\t   break outerloop;\\n\\t\\t\\t    }\\n\\t    } else if (nums2[k] <  nums1[j])\\n\\t\\t    {\\n\\t\\t    nums1[i] = nums1[j];\\n\\n\\t\\t\\t nums1[j] = 0;\\n\\t\\t\\t    j--;\\n\\t            i--;\\n\\t            if (j < 0 ) {\\n\\t            \\tj = 0;\\n\\t            }\\n\\n\\t  } else if (nums2[k] == nums1[j]) {\\n\\t\\t    nums1[i] = nums1[j];\\n\\t\\t    nums1[j] = 0;\\n\\n            i--;\\n            j--;\\n\\t\\t    if (j < 0 ) {\\n\\t\\t\\t    j = 0;\\n\\t\\t    }\\n\\n\\t    }\\n\\t  }\\n\\t\\t}\\n\\t}\\n}"
                    },
                    {
                        "username": "atulsinghrajput21",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "memebelarusguy",
                        "content": "SOLUTION!!!\nconst merge = function(nums1, m, nums2, n) {\n    return [...nums1.slice(0,m),...nums2.slice(0,n)].sort()\n};\nMy solution won't work. At other online compilers it work's correctly."
                    }
                ]
            },
            {
                "id": 1924196,
                "content": [
                    {
                        "username": "lazim",
                        "content": "function merge(nums1, m, nums2, n) {\\n\\tlet filteredArray = nums1.filter(num => num !== 0);\\n    filteredArray = filteredArray.concat(nums2);\\n    return filteredArray.sort((a, b) => a - b);\\n};\\ncan anybody explain why this code failing because in my chrome developer tool when i execute this code am getting the correct array returned [1,2,2,3,5,6] but in leet its console its showing [1,2,3,0,0,0]"
                    },
                    {
                        "username": "Anik0071",
                        "content": "The final sorted array should not be returned by the function, but instead be stored inside the array nums1. carefully read the statement again, it says you have to return the merge sorted array in nums1, you shouldn't use any other list.\n\n[@lazim](/lazim)\nplease upvote if you find this helpful thanks."
                    },
                    {
                        "username": "GandhamJayanth",
                        "content": " def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        li = []\\n        for i in range(m):\\n            li.append(nums1[i])\\n        for i in range(n):\\n            li.append(nums2[i])\\n        return li\\nwhat\\'s wrong with this"
                    },
                    {
                        "username": "Anik0071",
                        "content": "The final sorted array should not be returned by the function, but instead be stored inside the array nums1.  carefully read the statement again, it says you have to return the merge sorted array in nums1, you shouldn't use any other list.\n\n[@G V S Jayanth](/GandhamJayanth)\nplease upvote if you find this helpfull thanks."
                    },
                    {
                        "username": "justkexit",
                        "content": "How come \"sorted in non-decreasing order\" when in the first test case 0 appears after 3?"
                    },
                    {
                        "username": "Anik0071",
                        "content": "nums1 = [1,2,3,0,0,0], m = 3\nyou have to take the number  3 index as m=3.  which is 1 2  3 and these are in non-decreasing(increasing) order."
                    },
                    {
                        "username": "proparitoshsingh",
                        "content": "Can\\'t they just write \"increasing\" instead of \" non-decreasing order\""
                    },
                    {
                        "username": "PaarthKhandelwal",
                        "content": "My code is giving the following runtime :-\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nCan anyone help?\\n\\nMy code is as follows:- \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int x = nums1.size()+nums2.size();\\n        long long int arr[x];\\n\\n        int i=0, j=0,k=0;\\n\\n        while(i<m && j<n){\\n            if(nums1[i]<nums2[j]){\\n                arr[k] = nums1[i];\\n                i++;\\n                k++;\\n            }\\n            else{\\n                arr[k] == nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        while(i<m && k<x){\\n            arr[k] = nums1[i];\\n            i++;\\n            k++;\\n        }\\n        while(j<n && k<x){\\n            arr[k] = nums2[j];\\n            j++;\\n            k++;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "santoshlipare",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int size = 0;\\n        int count = 0;\\n        if (m > 0 && n > 0) {\\n            size = m + n ; \\n        } else if (m > 0) {\\n            size = m;    \\n        } else {\\n            size = n;    \\n        } \\n        int [] result = new int[size];\\n        int i=0, j=0;\\n        for (int k=0;k<size;k++) {\\n            if (i < m && j < n) {\\n                if (nums1[i] < nums2[j]) {\\n                    result[k] = nums1[i];\\n                    i++;\\n                } else {\\n                    result[k] = nums2[j];\\n                    j++;\\n                } \\n            } else if (i < m){\\n               result[k] = nums1[i];\\n               i++;\\n            } else {\\n                result[k] = nums2[j];\\n                j++;\\n            } \\n        }      \\n        nums1 = new int[result.length];         \\n        nums1 = result;\\n    }\\n\\nWhat is wrong in this solution"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "function mergeArrays(nums1, m, nums2, n) {\n  return nums1.slice(0, m).concat(nums2.slice(0, n));\n}\n\n// example\nlet nums1 = [1, 2, 3, 0, 0, 0];\nlet m = 3;\nlet nums2 = [2, 5, 6];\nlet n = 3;\n\nlet mergedArray = mergeArrays(nums1, m, nums2, n);\nconsole.log(mergedArray);\nI wrote like this simple method "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are so smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ronokghosal",
                        "content": "Tried to do a o(m+n) solution and it very well works perfectly on my intellij IDE and on leetcode it gives time Exceeded for mergeSort : Can someone help doublecheclk where I am going wrong?\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\n\\n       int i = m + n-1 ; // end of nums1\\n\\t   int j = m-1;\\n\\t   int k = n-1;\\n\\n    outerloop:\\n\\t  while( ! (i < 0 )) {\\n\\t\\tif ( nums1.length == 0 && nums2.length == 0 ){\\n\\t\\t\\t    \\tbreak outerloop;\\n\\t\\t}\\n\\t\\telse if ( nums1.length == 0 && nums2.length != 0 )\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnums1 = nums2;\\n\\t\\t\\t\\t\\t\\t\\tbreak outerloop;\\n\\t\\t\\t\\t\\t}\\n\\t\\telse if ( nums2.length == 0 && nums2.length != 0 )\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tbreak outerloop;\\n\\t\\t}\\n        else if( nums2.length != 0  && nums2.length != 0 ) {\\n\\n\\t  \\tif (nums2[k] > nums1[j]) {\\n\\t  \\t\\tnums1[i] = nums2[k];\\n\\t\\t\\t    k--;\\n\\t\\t\\t    i--;\\n\\t\\t\\t    if(k<0) {\\n\\t\\t\\t\\t   break outerloop;\\n\\t\\t\\t    }\\n\\t    } else if (nums2[k] <  nums1[j])\\n\\t\\t    {\\n\\t\\t    nums1[i] = nums1[j];\\n\\n\\t\\t\\t nums1[j] = 0;\\n\\t\\t\\t    j--;\\n\\t            i--;\\n\\t            if (j < 0 ) {\\n\\t            \\tj = 0;\\n\\t            }\\n\\n\\t  } else if (nums2[k] == nums1[j]) {\\n\\t\\t    nums1[i] = nums1[j];\\n\\t\\t    nums1[j] = 0;\\n\\n            i--;\\n            j--;\\n\\t\\t    if (j < 0 ) {\\n\\t\\t\\t    j = 0;\\n\\t\\t    }\\n\\n\\t    }\\n\\t  }\\n\\t\\t}\\n\\t}\\n}"
                    },
                    {
                        "username": "atulsinghrajput21",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "memebelarusguy",
                        "content": "SOLUTION!!!\nconst merge = function(nums1, m, nums2, n) {\n    return [...nums1.slice(0,m),...nums2.slice(0,n)].sort()\n};\nMy solution won't work. At other online compilers it work's correctly."
                    }
                ]
            },
            {
                "id": 1923686,
                "content": [
                    {
                        "username": "lazim",
                        "content": "function merge(nums1, m, nums2, n) {\\n\\tlet filteredArray = nums1.filter(num => num !== 0);\\n    filteredArray = filteredArray.concat(nums2);\\n    return filteredArray.sort((a, b) => a - b);\\n};\\ncan anybody explain why this code failing because in my chrome developer tool when i execute this code am getting the correct array returned [1,2,2,3,5,6] but in leet its console its showing [1,2,3,0,0,0]"
                    },
                    {
                        "username": "Anik0071",
                        "content": "The final sorted array should not be returned by the function, but instead be stored inside the array nums1. carefully read the statement again, it says you have to return the merge sorted array in nums1, you shouldn't use any other list.\n\n[@lazim](/lazim)\nplease upvote if you find this helpful thanks."
                    },
                    {
                        "username": "GandhamJayanth",
                        "content": " def merge(self, nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        li = []\\n        for i in range(m):\\n            li.append(nums1[i])\\n        for i in range(n):\\n            li.append(nums2[i])\\n        return li\\nwhat\\'s wrong with this"
                    },
                    {
                        "username": "Anik0071",
                        "content": "The final sorted array should not be returned by the function, but instead be stored inside the array nums1.  carefully read the statement again, it says you have to return the merge sorted array in nums1, you shouldn't use any other list.\n\n[@G V S Jayanth](/GandhamJayanth)\nplease upvote if you find this helpfull thanks."
                    },
                    {
                        "username": "justkexit",
                        "content": "How come \"sorted in non-decreasing order\" when in the first test case 0 appears after 3?"
                    },
                    {
                        "username": "Anik0071",
                        "content": "nums1 = [1,2,3,0,0,0], m = 3\nyou have to take the number  3 index as m=3.  which is 1 2  3 and these are in non-decreasing(increasing) order."
                    },
                    {
                        "username": "proparitoshsingh",
                        "content": "Can\\'t they just write \"increasing\" instead of \" non-decreasing order\""
                    },
                    {
                        "username": "PaarthKhandelwal",
                        "content": "My code is giving the following runtime :-\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nCan anyone help?\\n\\nMy code is as follows:- \\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int x = nums1.size()+nums2.size();\\n        long long int arr[x];\\n\\n        int i=0, j=0,k=0;\\n\\n        while(i<m && j<n){\\n            if(nums1[i]<nums2[j]){\\n                arr[k] = nums1[i];\\n                i++;\\n                k++;\\n            }\\n            else{\\n                arr[k] == nums2[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        while(i<m && k<x){\\n            arr[k] = nums1[i];\\n            i++;\\n            k++;\\n        }\\n        while(j<n && k<x){\\n            arr[k] = nums2[j];\\n            j++;\\n            k++;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "santoshlipare",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int size = 0;\\n        int count = 0;\\n        if (m > 0 && n > 0) {\\n            size = m + n ; \\n        } else if (m > 0) {\\n            size = m;    \\n        } else {\\n            size = n;    \\n        } \\n        int [] result = new int[size];\\n        int i=0, j=0;\\n        for (int k=0;k<size;k++) {\\n            if (i < m && j < n) {\\n                if (nums1[i] < nums2[j]) {\\n                    result[k] = nums1[i];\\n                    i++;\\n                } else {\\n                    result[k] = nums2[j];\\n                    j++;\\n                } \\n            } else if (i < m){\\n               result[k] = nums1[i];\\n               i++;\\n            } else {\\n                result[k] = nums2[j];\\n                j++;\\n            } \\n        }      \\n        nums1 = new int[result.length];         \\n        nums1 = result;\\n    }\\n\\nWhat is wrong in this solution"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "function mergeArrays(nums1, m, nums2, n) {\n  return nums1.slice(0, m).concat(nums2.slice(0, n));\n}\n\n// example\nlet nums1 = [1, 2, 3, 0, 0, 0];\nlet m = 3;\nlet nums2 = [2, 5, 6];\nlet n = 3;\n\nlet mergedArray = mergeArrays(nums1, m, nums2, n);\nconsole.log(mergedArray);\nI wrote like this simple method "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are so smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ronokghosal",
                        "content": "Tried to do a o(m+n) solution and it very well works perfectly on my intellij IDE and on leetcode it gives time Exceeded for mergeSort : Can someone help doublecheclk where I am going wrong?\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\n\\n       int i = m + n-1 ; // end of nums1\\n\\t   int j = m-1;\\n\\t   int k = n-1;\\n\\n    outerloop:\\n\\t  while( ! (i < 0 )) {\\n\\t\\tif ( nums1.length == 0 && nums2.length == 0 ){\\n\\t\\t\\t    \\tbreak outerloop;\\n\\t\\t}\\n\\t\\telse if ( nums1.length == 0 && nums2.length != 0 )\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnums1 = nums2;\\n\\t\\t\\t\\t\\t\\t\\tbreak outerloop;\\n\\t\\t\\t\\t\\t}\\n\\t\\telse if ( nums2.length == 0 && nums2.length != 0 )\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tbreak outerloop;\\n\\t\\t}\\n        else if( nums2.length != 0  && nums2.length != 0 ) {\\n\\n\\t  \\tif (nums2[k] > nums1[j]) {\\n\\t  \\t\\tnums1[i] = nums2[k];\\n\\t\\t\\t    k--;\\n\\t\\t\\t    i--;\\n\\t\\t\\t    if(k<0) {\\n\\t\\t\\t\\t   break outerloop;\\n\\t\\t\\t    }\\n\\t    } else if (nums2[k] <  nums1[j])\\n\\t\\t    {\\n\\t\\t    nums1[i] = nums1[j];\\n\\n\\t\\t\\t nums1[j] = 0;\\n\\t\\t\\t    j--;\\n\\t            i--;\\n\\t            if (j < 0 ) {\\n\\t            \\tj = 0;\\n\\t            }\\n\\n\\t  } else if (nums2[k] == nums1[j]) {\\n\\t\\t    nums1[i] = nums1[j];\\n\\t\\t    nums1[j] = 0;\\n\\n            i--;\\n            j--;\\n\\t\\t    if (j < 0 ) {\\n\\t\\t\\t    j = 0;\\n\\t\\t    }\\n\\n\\t    }\\n\\t  }\\n\\t\\t}\\n\\t}\\n}"
                    },
                    {
                        "username": "atulsinghrajput21",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "memebelarusguy",
                        "content": "SOLUTION!!!\nconst merge = function(nums1, m, nums2, n) {\n    return [...nums1.slice(0,m),...nums2.slice(0,n)].sort()\n};\nMy solution won't work. At other online compilers it work's correctly."
                    }
                ]
            },
            {
                "id": 1923335,
                "content": [
                    {
                        "username": "iamironadicted",
                        "content": "function merge(nums1, m, nums2, n) {\\n      nums1 = [\\n    ...(m > 0 ? nums1.slice(0, m) : []),\\n    ...(n > 0 ? nums2.slice(0, n) : []),\\n  ].sort((a, b) => a - b);\\n  \\n  return nums1;\\n};\\n\\nfirst test case is not working properly \\ni think its because with the JS ES6 syntax, anyway it works locally"
                    },
                    {
                        "username": "sathibabu_gurrala",
                        "content": "please anyone explain what is wrong with this code\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        if m == 0 and n == 0:\\n            nums1 = []\\n        elif n == 0:\\n            nums1 = nums1\\n        elif m == 0:\\n            nums1 = nums2\\n        else:\\n            nums1 = nums1[:m] + nums2[:n]\\n            nums1.sort()"
                    },
                    {
                        "username": "jaychCS",
                        "content": "Can this question be done by if and elif to check whether m or n is 0, if yes, then nums1 will be nums2 or nums1. If m, n is not 0, then uses string concatenation to store as nums1, then use build-in sorted function to sort. I tried it works on local, but fails to pass tests on leetcode. I don\\'t understand why it didn\\'t work."
                    },
                    {
                        "username": "antarikshkalita",
                        "content": "even after modifying nums1 array in place, leetcode does not pick up the updated values. when i print I get the correct answer but leetcode just picks the input nums1 as the answer \\n`nums1 = nums1[:m] + nums2[:n]\\n        nums1.sort().`"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the problem with this code, i have tried to manipulate the nums1 list but it output the original list.\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = nums1[:m]\\n        m=m-1\\n        n=n-1\\n        while m >= 0 and n >= 0:\\n            if nums1[m] < nums2[n]:\\n                nums1.insert(m+1,nums2[n])\\n                n-=1\\n                m= m+1\\n            elif nums1[m] == nums2[n]:\\n                nums1.insert(m+1,nums2[n])\\n                n-=1\\n                m= m+1\\n            elif nums1[m] > nums2[n]:\\n                m-=1\\n            print(nums1)\\n\\n\\nprint shows the last iteration it is [1, 2, 2, 3, 5, 6]\\nbut on the output it shows [1,2,3,0,0,0]\\n"
                    },
                    {
                        "username": "joeyjoah",
                        "content": "The fact that zero is used both as a possible value within nums1 and as padding is pretty obnoxious"
                    },
                    {
                        "username": "CDWimmer",
                        "content": "I think this questions sucks for Python for the sheer fact that noone in their right mind would do this in Python. Trailing zeroes? Not just having a return value? Nonsense. "
                    },
                    {
                        "username": "gemmathew121",
                        "content": "What is wrong with my code?\\nTry it yourself, print the value of nums1 after the sorted assignment, the value exactly matches the required result, please help me out, thank you.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        nums1 = nums1[:m]\\n        nums2 = nums2[:n]\\n        nums1 = sorted(nums1+nums2)"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "Just look for all values of m and n . Also run your loop for the last 0\\'s only which are to be replaced by nums2 elements"
                    },
                    {
                        "username": "user6092nL",
                        "content": "I am getting this error. Anyone can explain this error.\nLine 1034: Char 9: runtime error: reference binding to null pointer of type 'int' (stl_vector.h)\n\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\n\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        vector<int> temp(m);\n    for(int i=0;i<m;i++){\n      temp[i]=nums1[i];\n    }\n    nums1.clear();\n    int i=0,j=0;\n    while(i<m || i<n){\n        if(temp[i]<=nums2[j]){\n           nums1.push_back(temp[i]);\n           i++;\n        }\n        else{\n            nums1.push_back(nums2[j]);\n            j++;\n        }\n\n    }\n    for(int k=i;k<m;k++){\n        nums1.push_back(temp[k]);\n    }\n    for(int k=j;k<m;k++){\n        nums1.push_back(nums2[k]);\n    }\n\n    }"
                    }
                ]
            },
            {
                "id": 1923126,
                "content": [
                    {
                        "username": "iamironadicted",
                        "content": "function merge(nums1, m, nums2, n) {\\n      nums1 = [\\n    ...(m > 0 ? nums1.slice(0, m) : []),\\n    ...(n > 0 ? nums2.slice(0, n) : []),\\n  ].sort((a, b) => a - b);\\n  \\n  return nums1;\\n};\\n\\nfirst test case is not working properly \\ni think its because with the JS ES6 syntax, anyway it works locally"
                    },
                    {
                        "username": "sathibabu_gurrala",
                        "content": "please anyone explain what is wrong with this code\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        if m == 0 and n == 0:\\n            nums1 = []\\n        elif n == 0:\\n            nums1 = nums1\\n        elif m == 0:\\n            nums1 = nums2\\n        else:\\n            nums1 = nums1[:m] + nums2[:n]\\n            nums1.sort()"
                    },
                    {
                        "username": "jaychCS",
                        "content": "Can this question be done by if and elif to check whether m or n is 0, if yes, then nums1 will be nums2 or nums1. If m, n is not 0, then uses string concatenation to store as nums1, then use build-in sorted function to sort. I tried it works on local, but fails to pass tests on leetcode. I don\\'t understand why it didn\\'t work."
                    },
                    {
                        "username": "antarikshkalita",
                        "content": "even after modifying nums1 array in place, leetcode does not pick up the updated values. when i print I get the correct answer but leetcode just picks the input nums1 as the answer \\n`nums1 = nums1[:m] + nums2[:n]\\n        nums1.sort().`"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the problem with this code, i have tried to manipulate the nums1 list but it output the original list.\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = nums1[:m]\\n        m=m-1\\n        n=n-1\\n        while m >= 0 and n >= 0:\\n            if nums1[m] < nums2[n]:\\n                nums1.insert(m+1,nums2[n])\\n                n-=1\\n                m= m+1\\n            elif nums1[m] == nums2[n]:\\n                nums1.insert(m+1,nums2[n])\\n                n-=1\\n                m= m+1\\n            elif nums1[m] > nums2[n]:\\n                m-=1\\n            print(nums1)\\n\\n\\nprint shows the last iteration it is [1, 2, 2, 3, 5, 6]\\nbut on the output it shows [1,2,3,0,0,0]\\n"
                    },
                    {
                        "username": "joeyjoah",
                        "content": "The fact that zero is used both as a possible value within nums1 and as padding is pretty obnoxious"
                    },
                    {
                        "username": "CDWimmer",
                        "content": "I think this questions sucks for Python for the sheer fact that noone in their right mind would do this in Python. Trailing zeroes? Not just having a return value? Nonsense. "
                    },
                    {
                        "username": "gemmathew121",
                        "content": "What is wrong with my code?\\nTry it yourself, print the value of nums1 after the sorted assignment, the value exactly matches the required result, please help me out, thank you.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        nums1 = nums1[:m]\\n        nums2 = nums2[:n]\\n        nums1 = sorted(nums1+nums2)"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "Just look for all values of m and n . Also run your loop for the last 0\\'s only which are to be replaced by nums2 elements"
                    },
                    {
                        "username": "user6092nL",
                        "content": "I am getting this error. Anyone can explain this error.\nLine 1034: Char 9: runtime error: reference binding to null pointer of type 'int' (stl_vector.h)\n\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\n\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        vector<int> temp(m);\n    for(int i=0;i<m;i++){\n      temp[i]=nums1[i];\n    }\n    nums1.clear();\n    int i=0,j=0;\n    while(i<m || i<n){\n        if(temp[i]<=nums2[j]){\n           nums1.push_back(temp[i]);\n           i++;\n        }\n        else{\n            nums1.push_back(nums2[j]);\n            j++;\n        }\n\n    }\n    for(int k=i;k<m;k++){\n        nums1.push_back(temp[k]);\n    }\n    for(int k=j;k<m;k++){\n        nums1.push_back(nums2[k]);\n    }\n\n    }"
                    }
                ]
            },
            {
                "id": 1922753,
                "content": [
                    {
                        "username": "iamironadicted",
                        "content": "function merge(nums1, m, nums2, n) {\\n      nums1 = [\\n    ...(m > 0 ? nums1.slice(0, m) : []),\\n    ...(n > 0 ? nums2.slice(0, n) : []),\\n  ].sort((a, b) => a - b);\\n  \\n  return nums1;\\n};\\n\\nfirst test case is not working properly \\ni think its because with the JS ES6 syntax, anyway it works locally"
                    },
                    {
                        "username": "sathibabu_gurrala",
                        "content": "please anyone explain what is wrong with this code\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        if m == 0 and n == 0:\\n            nums1 = []\\n        elif n == 0:\\n            nums1 = nums1\\n        elif m == 0:\\n            nums1 = nums2\\n        else:\\n            nums1 = nums1[:m] + nums2[:n]\\n            nums1.sort()"
                    },
                    {
                        "username": "jaychCS",
                        "content": "Can this question be done by if and elif to check whether m or n is 0, if yes, then nums1 will be nums2 or nums1. If m, n is not 0, then uses string concatenation to store as nums1, then use build-in sorted function to sort. I tried it works on local, but fails to pass tests on leetcode. I don\\'t understand why it didn\\'t work."
                    },
                    {
                        "username": "antarikshkalita",
                        "content": "even after modifying nums1 array in place, leetcode does not pick up the updated values. when i print I get the correct answer but leetcode just picks the input nums1 as the answer \\n`nums1 = nums1[:m] + nums2[:n]\\n        nums1.sort().`"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the problem with this code, i have tried to manipulate the nums1 list but it output the original list.\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = nums1[:m]\\n        m=m-1\\n        n=n-1\\n        while m >= 0 and n >= 0:\\n            if nums1[m] < nums2[n]:\\n                nums1.insert(m+1,nums2[n])\\n                n-=1\\n                m= m+1\\n            elif nums1[m] == nums2[n]:\\n                nums1.insert(m+1,nums2[n])\\n                n-=1\\n                m= m+1\\n            elif nums1[m] > nums2[n]:\\n                m-=1\\n            print(nums1)\\n\\n\\nprint shows the last iteration it is [1, 2, 2, 3, 5, 6]\\nbut on the output it shows [1,2,3,0,0,0]\\n"
                    },
                    {
                        "username": "joeyjoah",
                        "content": "The fact that zero is used both as a possible value within nums1 and as padding is pretty obnoxious"
                    },
                    {
                        "username": "CDWimmer",
                        "content": "I think this questions sucks for Python for the sheer fact that noone in their right mind would do this in Python. Trailing zeroes? Not just having a return value? Nonsense. "
                    },
                    {
                        "username": "gemmathew121",
                        "content": "What is wrong with my code?\\nTry it yourself, print the value of nums1 after the sorted assignment, the value exactly matches the required result, please help me out, thank you.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        nums1 = nums1[:m]\\n        nums2 = nums2[:n]\\n        nums1 = sorted(nums1+nums2)"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "Just look for all values of m and n . Also run your loop for the last 0\\'s only which are to be replaced by nums2 elements"
                    },
                    {
                        "username": "user6092nL",
                        "content": "I am getting this error. Anyone can explain this error.\nLine 1034: Char 9: runtime error: reference binding to null pointer of type 'int' (stl_vector.h)\n\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\n\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        vector<int> temp(m);\n    for(int i=0;i<m;i++){\n      temp[i]=nums1[i];\n    }\n    nums1.clear();\n    int i=0,j=0;\n    while(i<m || i<n){\n        if(temp[i]<=nums2[j]){\n           nums1.push_back(temp[i]);\n           i++;\n        }\n        else{\n            nums1.push_back(nums2[j]);\n            j++;\n        }\n\n    }\n    for(int k=i;k<m;k++){\n        nums1.push_back(temp[k]);\n    }\n    for(int k=j;k<m;k++){\n        nums1.push_back(nums2[k]);\n    }\n\n    }"
                    }
                ]
            },
            {
                "id": 1919901,
                "content": [
                    {
                        "username": "iamironadicted",
                        "content": "function merge(nums1, m, nums2, n) {\\n      nums1 = [\\n    ...(m > 0 ? nums1.slice(0, m) : []),\\n    ...(n > 0 ? nums2.slice(0, n) : []),\\n  ].sort((a, b) => a - b);\\n  \\n  return nums1;\\n};\\n\\nfirst test case is not working properly \\ni think its because with the JS ES6 syntax, anyway it works locally"
                    },
                    {
                        "username": "sathibabu_gurrala",
                        "content": "please anyone explain what is wrong with this code\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        if m == 0 and n == 0:\\n            nums1 = []\\n        elif n == 0:\\n            nums1 = nums1\\n        elif m == 0:\\n            nums1 = nums2\\n        else:\\n            nums1 = nums1[:m] + nums2[:n]\\n            nums1.sort()"
                    },
                    {
                        "username": "jaychCS",
                        "content": "Can this question be done by if and elif to check whether m or n is 0, if yes, then nums1 will be nums2 or nums1. If m, n is not 0, then uses string concatenation to store as nums1, then use build-in sorted function to sort. I tried it works on local, but fails to pass tests on leetcode. I don\\'t understand why it didn\\'t work."
                    },
                    {
                        "username": "antarikshkalita",
                        "content": "even after modifying nums1 array in place, leetcode does not pick up the updated values. when i print I get the correct answer but leetcode just picks the input nums1 as the answer \\n`nums1 = nums1[:m] + nums2[:n]\\n        nums1.sort().`"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the problem with this code, i have tried to manipulate the nums1 list but it output the original list.\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = nums1[:m]\\n        m=m-1\\n        n=n-1\\n        while m >= 0 and n >= 0:\\n            if nums1[m] < nums2[n]:\\n                nums1.insert(m+1,nums2[n])\\n                n-=1\\n                m= m+1\\n            elif nums1[m] == nums2[n]:\\n                nums1.insert(m+1,nums2[n])\\n                n-=1\\n                m= m+1\\n            elif nums1[m] > nums2[n]:\\n                m-=1\\n            print(nums1)\\n\\n\\nprint shows the last iteration it is [1, 2, 2, 3, 5, 6]\\nbut on the output it shows [1,2,3,0,0,0]\\n"
                    },
                    {
                        "username": "joeyjoah",
                        "content": "The fact that zero is used both as a possible value within nums1 and as padding is pretty obnoxious"
                    },
                    {
                        "username": "CDWimmer",
                        "content": "I think this questions sucks for Python for the sheer fact that noone in their right mind would do this in Python. Trailing zeroes? Not just having a return value? Nonsense. "
                    },
                    {
                        "username": "gemmathew121",
                        "content": "What is wrong with my code?\\nTry it yourself, print the value of nums1 after the sorted assignment, the value exactly matches the required result, please help me out, thank you.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        nums1 = nums1[:m]\\n        nums2 = nums2[:n]\\n        nums1 = sorted(nums1+nums2)"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "Just look for all values of m and n . Also run your loop for the last 0\\'s only which are to be replaced by nums2 elements"
                    },
                    {
                        "username": "user6092nL",
                        "content": "I am getting this error. Anyone can explain this error.\nLine 1034: Char 9: runtime error: reference binding to null pointer of type 'int' (stl_vector.h)\n\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\n\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        vector<int> temp(m);\n    for(int i=0;i<m;i++){\n      temp[i]=nums1[i];\n    }\n    nums1.clear();\n    int i=0,j=0;\n    while(i<m || i<n){\n        if(temp[i]<=nums2[j]){\n           nums1.push_back(temp[i]);\n           i++;\n        }\n        else{\n            nums1.push_back(nums2[j]);\n            j++;\n        }\n\n    }\n    for(int k=i;k<m;k++){\n        nums1.push_back(temp[k]);\n    }\n    for(int k=j;k<m;k++){\n        nums1.push_back(nums2[k]);\n    }\n\n    }"
                    }
                ]
            },
            {
                "id": 1918726,
                "content": [
                    {
                        "username": "iamironadicted",
                        "content": "function merge(nums1, m, nums2, n) {\\n      nums1 = [\\n    ...(m > 0 ? nums1.slice(0, m) : []),\\n    ...(n > 0 ? nums2.slice(0, n) : []),\\n  ].sort((a, b) => a - b);\\n  \\n  return nums1;\\n};\\n\\nfirst test case is not working properly \\ni think its because with the JS ES6 syntax, anyway it works locally"
                    },
                    {
                        "username": "sathibabu_gurrala",
                        "content": "please anyone explain what is wrong with this code\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        if m == 0 and n == 0:\\n            nums1 = []\\n        elif n == 0:\\n            nums1 = nums1\\n        elif m == 0:\\n            nums1 = nums2\\n        else:\\n            nums1 = nums1[:m] + nums2[:n]\\n            nums1.sort()"
                    },
                    {
                        "username": "jaychCS",
                        "content": "Can this question be done by if and elif to check whether m or n is 0, if yes, then nums1 will be nums2 or nums1. If m, n is not 0, then uses string concatenation to store as nums1, then use build-in sorted function to sort. I tried it works on local, but fails to pass tests on leetcode. I don\\'t understand why it didn\\'t work."
                    },
                    {
                        "username": "antarikshkalita",
                        "content": "even after modifying nums1 array in place, leetcode does not pick up the updated values. when i print I get the correct answer but leetcode just picks the input nums1 as the answer \\n`nums1 = nums1[:m] + nums2[:n]\\n        nums1.sort().`"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the problem with this code, i have tried to manipulate the nums1 list but it output the original list.\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = nums1[:m]\\n        m=m-1\\n        n=n-1\\n        while m >= 0 and n >= 0:\\n            if nums1[m] < nums2[n]:\\n                nums1.insert(m+1,nums2[n])\\n                n-=1\\n                m= m+1\\n            elif nums1[m] == nums2[n]:\\n                nums1.insert(m+1,nums2[n])\\n                n-=1\\n                m= m+1\\n            elif nums1[m] > nums2[n]:\\n                m-=1\\n            print(nums1)\\n\\n\\nprint shows the last iteration it is [1, 2, 2, 3, 5, 6]\\nbut on the output it shows [1,2,3,0,0,0]\\n"
                    },
                    {
                        "username": "joeyjoah",
                        "content": "The fact that zero is used both as a possible value within nums1 and as padding is pretty obnoxious"
                    },
                    {
                        "username": "CDWimmer",
                        "content": "I think this questions sucks for Python for the sheer fact that noone in their right mind would do this in Python. Trailing zeroes? Not just having a return value? Nonsense. "
                    },
                    {
                        "username": "gemmathew121",
                        "content": "What is wrong with my code?\\nTry it yourself, print the value of nums1 after the sorted assignment, the value exactly matches the required result, please help me out, thank you.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        nums1 = nums1[:m]\\n        nums2 = nums2[:n]\\n        nums1 = sorted(nums1+nums2)"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "Just look for all values of m and n . Also run your loop for the last 0\\'s only which are to be replaced by nums2 elements"
                    },
                    {
                        "username": "user6092nL",
                        "content": "I am getting this error. Anyone can explain this error.\nLine 1034: Char 9: runtime error: reference binding to null pointer of type 'int' (stl_vector.h)\n\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\n\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        vector<int> temp(m);\n    for(int i=0;i<m;i++){\n      temp[i]=nums1[i];\n    }\n    nums1.clear();\n    int i=0,j=0;\n    while(i<m || i<n){\n        if(temp[i]<=nums2[j]){\n           nums1.push_back(temp[i]);\n           i++;\n        }\n        else{\n            nums1.push_back(nums2[j]);\n            j++;\n        }\n\n    }\n    for(int k=i;k<m;k++){\n        nums1.push_back(temp[k]);\n    }\n    for(int k=j;k<m;k++){\n        nums1.push_back(nums2[k]);\n    }\n\n    }"
                    }
                ]
            },
            {
                "id": 1911152,
                "content": [
                    {
                        "username": "iamironadicted",
                        "content": "function merge(nums1, m, nums2, n) {\\n      nums1 = [\\n    ...(m > 0 ? nums1.slice(0, m) : []),\\n    ...(n > 0 ? nums2.slice(0, n) : []),\\n  ].sort((a, b) => a - b);\\n  \\n  return nums1;\\n};\\n\\nfirst test case is not working properly \\ni think its because with the JS ES6 syntax, anyway it works locally"
                    },
                    {
                        "username": "sathibabu_gurrala",
                        "content": "please anyone explain what is wrong with this code\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        if m == 0 and n == 0:\\n            nums1 = []\\n        elif n == 0:\\n            nums1 = nums1\\n        elif m == 0:\\n            nums1 = nums2\\n        else:\\n            nums1 = nums1[:m] + nums2[:n]\\n            nums1.sort()"
                    },
                    {
                        "username": "jaychCS",
                        "content": "Can this question be done by if and elif to check whether m or n is 0, if yes, then nums1 will be nums2 or nums1. If m, n is not 0, then uses string concatenation to store as nums1, then use build-in sorted function to sort. I tried it works on local, but fails to pass tests on leetcode. I don\\'t understand why it didn\\'t work."
                    },
                    {
                        "username": "antarikshkalita",
                        "content": "even after modifying nums1 array in place, leetcode does not pick up the updated values. when i print I get the correct answer but leetcode just picks the input nums1 as the answer \\n`nums1 = nums1[:m] + nums2[:n]\\n        nums1.sort().`"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the problem with this code, i have tried to manipulate the nums1 list but it output the original list.\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = nums1[:m]\\n        m=m-1\\n        n=n-1\\n        while m >= 0 and n >= 0:\\n            if nums1[m] < nums2[n]:\\n                nums1.insert(m+1,nums2[n])\\n                n-=1\\n                m= m+1\\n            elif nums1[m] == nums2[n]:\\n                nums1.insert(m+1,nums2[n])\\n                n-=1\\n                m= m+1\\n            elif nums1[m] > nums2[n]:\\n                m-=1\\n            print(nums1)\\n\\n\\nprint shows the last iteration it is [1, 2, 2, 3, 5, 6]\\nbut on the output it shows [1,2,3,0,0,0]\\n"
                    },
                    {
                        "username": "joeyjoah",
                        "content": "The fact that zero is used both as a possible value within nums1 and as padding is pretty obnoxious"
                    },
                    {
                        "username": "CDWimmer",
                        "content": "I think this questions sucks for Python for the sheer fact that noone in their right mind would do this in Python. Trailing zeroes? Not just having a return value? Nonsense. "
                    },
                    {
                        "username": "gemmathew121",
                        "content": "What is wrong with my code?\\nTry it yourself, print the value of nums1 after the sorted assignment, the value exactly matches the required result, please help me out, thank you.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        nums1 = nums1[:m]\\n        nums2 = nums2[:n]\\n        nums1 = sorted(nums1+nums2)"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "Just look for all values of m and n . Also run your loop for the last 0\\'s only which are to be replaced by nums2 elements"
                    },
                    {
                        "username": "user6092nL",
                        "content": "I am getting this error. Anyone can explain this error.\nLine 1034: Char 9: runtime error: reference binding to null pointer of type 'int' (stl_vector.h)\n\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\n\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        vector<int> temp(m);\n    for(int i=0;i<m;i++){\n      temp[i]=nums1[i];\n    }\n    nums1.clear();\n    int i=0,j=0;\n    while(i<m || i<n){\n        if(temp[i]<=nums2[j]){\n           nums1.push_back(temp[i]);\n           i++;\n        }\n        else{\n            nums1.push_back(nums2[j]);\n            j++;\n        }\n\n    }\n    for(int k=i;k<m;k++){\n        nums1.push_back(temp[k]);\n    }\n    for(int k=j;k<m;k++){\n        nums1.push_back(nums2[k]);\n    }\n\n    }"
                    }
                ]
            },
            {
                "id": 1910329,
                "content": [
                    {
                        "username": "iamironadicted",
                        "content": "function merge(nums1, m, nums2, n) {\\n      nums1 = [\\n    ...(m > 0 ? nums1.slice(0, m) : []),\\n    ...(n > 0 ? nums2.slice(0, n) : []),\\n  ].sort((a, b) => a - b);\\n  \\n  return nums1;\\n};\\n\\nfirst test case is not working properly \\ni think its because with the JS ES6 syntax, anyway it works locally"
                    },
                    {
                        "username": "sathibabu_gurrala",
                        "content": "please anyone explain what is wrong with this code\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        if m == 0 and n == 0:\\n            nums1 = []\\n        elif n == 0:\\n            nums1 = nums1\\n        elif m == 0:\\n            nums1 = nums2\\n        else:\\n            nums1 = nums1[:m] + nums2[:n]\\n            nums1.sort()"
                    },
                    {
                        "username": "jaychCS",
                        "content": "Can this question be done by if and elif to check whether m or n is 0, if yes, then nums1 will be nums2 or nums1. If m, n is not 0, then uses string concatenation to store as nums1, then use build-in sorted function to sort. I tried it works on local, but fails to pass tests on leetcode. I don\\'t understand why it didn\\'t work."
                    },
                    {
                        "username": "antarikshkalita",
                        "content": "even after modifying nums1 array in place, leetcode does not pick up the updated values. when i print I get the correct answer but leetcode just picks the input nums1 as the answer \\n`nums1 = nums1[:m] + nums2[:n]\\n        nums1.sort().`"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the problem with this code, i have tried to manipulate the nums1 list but it output the original list.\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = nums1[:m]\\n        m=m-1\\n        n=n-1\\n        while m >= 0 and n >= 0:\\n            if nums1[m] < nums2[n]:\\n                nums1.insert(m+1,nums2[n])\\n                n-=1\\n                m= m+1\\n            elif nums1[m] == nums2[n]:\\n                nums1.insert(m+1,nums2[n])\\n                n-=1\\n                m= m+1\\n            elif nums1[m] > nums2[n]:\\n                m-=1\\n            print(nums1)\\n\\n\\nprint shows the last iteration it is [1, 2, 2, 3, 5, 6]\\nbut on the output it shows [1,2,3,0,0,0]\\n"
                    },
                    {
                        "username": "joeyjoah",
                        "content": "The fact that zero is used both as a possible value within nums1 and as padding is pretty obnoxious"
                    },
                    {
                        "username": "CDWimmer",
                        "content": "I think this questions sucks for Python for the sheer fact that noone in their right mind would do this in Python. Trailing zeroes? Not just having a return value? Nonsense. "
                    },
                    {
                        "username": "gemmathew121",
                        "content": "What is wrong with my code?\\nTry it yourself, print the value of nums1 after the sorted assignment, the value exactly matches the required result, please help me out, thank you.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        nums1 = nums1[:m]\\n        nums2 = nums2[:n]\\n        nums1 = sorted(nums1+nums2)"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "Just look for all values of m and n . Also run your loop for the last 0\\'s only which are to be replaced by nums2 elements"
                    },
                    {
                        "username": "user6092nL",
                        "content": "I am getting this error. Anyone can explain this error.\nLine 1034: Char 9: runtime error: reference binding to null pointer of type 'int' (stl_vector.h)\n\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\n\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        vector<int> temp(m);\n    for(int i=0;i<m;i++){\n      temp[i]=nums1[i];\n    }\n    nums1.clear();\n    int i=0,j=0;\n    while(i<m || i<n){\n        if(temp[i]<=nums2[j]){\n           nums1.push_back(temp[i]);\n           i++;\n        }\n        else{\n            nums1.push_back(nums2[j]);\n            j++;\n        }\n\n    }\n    for(int k=i;k<m;k++){\n        nums1.push_back(temp[k]);\n    }\n    for(int k=j;k<m;k++){\n        nums1.push_back(nums2[k]);\n    }\n\n    }"
                    }
                ]
            },
            {
                "id": 1910091,
                "content": [
                    {
                        "username": "iamironadicted",
                        "content": "function merge(nums1, m, nums2, n) {\\n      nums1 = [\\n    ...(m > 0 ? nums1.slice(0, m) : []),\\n    ...(n > 0 ? nums2.slice(0, n) : []),\\n  ].sort((a, b) => a - b);\\n  \\n  return nums1;\\n};\\n\\nfirst test case is not working properly \\ni think its because with the JS ES6 syntax, anyway it works locally"
                    },
                    {
                        "username": "sathibabu_gurrala",
                        "content": "please anyone explain what is wrong with this code\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        if m == 0 and n == 0:\\n            nums1 = []\\n        elif n == 0:\\n            nums1 = nums1\\n        elif m == 0:\\n            nums1 = nums2\\n        else:\\n            nums1 = nums1[:m] + nums2[:n]\\n            nums1.sort()"
                    },
                    {
                        "username": "jaychCS",
                        "content": "Can this question be done by if and elif to check whether m or n is 0, if yes, then nums1 will be nums2 or nums1. If m, n is not 0, then uses string concatenation to store as nums1, then use build-in sorted function to sort. I tried it works on local, but fails to pass tests on leetcode. I don\\'t understand why it didn\\'t work."
                    },
                    {
                        "username": "antarikshkalita",
                        "content": "even after modifying nums1 array in place, leetcode does not pick up the updated values. when i print I get the correct answer but leetcode just picks the input nums1 as the answer \\n`nums1 = nums1[:m] + nums2[:n]\\n        nums1.sort().`"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the problem with this code, i have tried to manipulate the nums1 list but it output the original list.\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = nums1[:m]\\n        m=m-1\\n        n=n-1\\n        while m >= 0 and n >= 0:\\n            if nums1[m] < nums2[n]:\\n                nums1.insert(m+1,nums2[n])\\n                n-=1\\n                m= m+1\\n            elif nums1[m] == nums2[n]:\\n                nums1.insert(m+1,nums2[n])\\n                n-=1\\n                m= m+1\\n            elif nums1[m] > nums2[n]:\\n                m-=1\\n            print(nums1)\\n\\n\\nprint shows the last iteration it is [1, 2, 2, 3, 5, 6]\\nbut on the output it shows [1,2,3,0,0,0]\\n"
                    },
                    {
                        "username": "joeyjoah",
                        "content": "The fact that zero is used both as a possible value within nums1 and as padding is pretty obnoxious"
                    },
                    {
                        "username": "CDWimmer",
                        "content": "I think this questions sucks for Python for the sheer fact that noone in their right mind would do this in Python. Trailing zeroes? Not just having a return value? Nonsense. "
                    },
                    {
                        "username": "gemmathew121",
                        "content": "What is wrong with my code?\\nTry it yourself, print the value of nums1 after the sorted assignment, the value exactly matches the required result, please help me out, thank you.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        nums1 = nums1[:m]\\n        nums2 = nums2[:n]\\n        nums1 = sorted(nums1+nums2)"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "Just look for all values of m and n . Also run your loop for the last 0\\'s only which are to be replaced by nums2 elements"
                    },
                    {
                        "username": "user6092nL",
                        "content": "I am getting this error. Anyone can explain this error.\nLine 1034: Char 9: runtime error: reference binding to null pointer of type 'int' (stl_vector.h)\n\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\n\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        vector<int> temp(m);\n    for(int i=0;i<m;i++){\n      temp[i]=nums1[i];\n    }\n    nums1.clear();\n    int i=0,j=0;\n    while(i<m || i<n){\n        if(temp[i]<=nums2[j]){\n           nums1.push_back(temp[i]);\n           i++;\n        }\n        else{\n            nums1.push_back(nums2[j]);\n            j++;\n        }\n\n    }\n    for(int k=i;k<m;k++){\n        nums1.push_back(temp[k]);\n    }\n    for(int k=j;k<m;k++){\n        nums1.push_back(nums2[k]);\n    }\n\n    }"
                    }
                ]
            },
            {
                "id": 1901964,
                "content": [
                    {
                        "username": "iamironadicted",
                        "content": "function merge(nums1, m, nums2, n) {\\n      nums1 = [\\n    ...(m > 0 ? nums1.slice(0, m) : []),\\n    ...(n > 0 ? nums2.slice(0, n) : []),\\n  ].sort((a, b) => a - b);\\n  \\n  return nums1;\\n};\\n\\nfirst test case is not working properly \\ni think its because with the JS ES6 syntax, anyway it works locally"
                    },
                    {
                        "username": "sathibabu_gurrala",
                        "content": "please anyone explain what is wrong with this code\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        if m == 0 and n == 0:\\n            nums1 = []\\n        elif n == 0:\\n            nums1 = nums1\\n        elif m == 0:\\n            nums1 = nums2\\n        else:\\n            nums1 = nums1[:m] + nums2[:n]\\n            nums1.sort()"
                    },
                    {
                        "username": "jaychCS",
                        "content": "Can this question be done by if and elif to check whether m or n is 0, if yes, then nums1 will be nums2 or nums1. If m, n is not 0, then uses string concatenation to store as nums1, then use build-in sorted function to sort. I tried it works on local, but fails to pass tests on leetcode. I don\\'t understand why it didn\\'t work."
                    },
                    {
                        "username": "antarikshkalita",
                        "content": "even after modifying nums1 array in place, leetcode does not pick up the updated values. when i print I get the correct answer but leetcode just picks the input nums1 as the answer \\n`nums1 = nums1[:m] + nums2[:n]\\n        nums1.sort().`"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the problem with this code, i have tried to manipulate the nums1 list but it output the original list.\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = nums1[:m]\\n        m=m-1\\n        n=n-1\\n        while m >= 0 and n >= 0:\\n            if nums1[m] < nums2[n]:\\n                nums1.insert(m+1,nums2[n])\\n                n-=1\\n                m= m+1\\n            elif nums1[m] == nums2[n]:\\n                nums1.insert(m+1,nums2[n])\\n                n-=1\\n                m= m+1\\n            elif nums1[m] > nums2[n]:\\n                m-=1\\n            print(nums1)\\n\\n\\nprint shows the last iteration it is [1, 2, 2, 3, 5, 6]\\nbut on the output it shows [1,2,3,0,0,0]\\n"
                    },
                    {
                        "username": "joeyjoah",
                        "content": "The fact that zero is used both as a possible value within nums1 and as padding is pretty obnoxious"
                    },
                    {
                        "username": "CDWimmer",
                        "content": "I think this questions sucks for Python for the sheer fact that noone in their right mind would do this in Python. Trailing zeroes? Not just having a return value? Nonsense. "
                    },
                    {
                        "username": "gemmathew121",
                        "content": "What is wrong with my code?\\nTry it yourself, print the value of nums1 after the sorted assignment, the value exactly matches the required result, please help me out, thank you.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        nums1 = nums1[:m]\\n        nums2 = nums2[:n]\\n        nums1 = sorted(nums1+nums2)"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "Just look for all values of m and n . Also run your loop for the last 0\\'s only which are to be replaced by nums2 elements"
                    },
                    {
                        "username": "user6092nL",
                        "content": "I am getting this error. Anyone can explain this error.\nLine 1034: Char 9: runtime error: reference binding to null pointer of type 'int' (stl_vector.h)\n\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\n\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        vector<int> temp(m);\n    for(int i=0;i<m;i++){\n      temp[i]=nums1[i];\n    }\n    nums1.clear();\n    int i=0,j=0;\n    while(i<m || i<n){\n        if(temp[i]<=nums2[j]){\n           nums1.push_back(temp[i]);\n           i++;\n        }\n        else{\n            nums1.push_back(nums2[j]);\n            j++;\n        }\n\n    }\n    for(int k=i;k<m;k++){\n        nums1.push_back(temp[k]);\n    }\n    for(int k=j;k<m;k++){\n        nums1.push_back(nums2[k]);\n    }\n\n    }"
                    }
                ]
            },
            {
                "id": 1899103,
                "content": [
                    {
                        "username": "iamironadicted",
                        "content": "function merge(nums1, m, nums2, n) {\\n      nums1 = [\\n    ...(m > 0 ? nums1.slice(0, m) : []),\\n    ...(n > 0 ? nums2.slice(0, n) : []),\\n  ].sort((a, b) => a - b);\\n  \\n  return nums1;\\n};\\n\\nfirst test case is not working properly \\ni think its because with the JS ES6 syntax, anyway it works locally"
                    },
                    {
                        "username": "sathibabu_gurrala",
                        "content": "please anyone explain what is wrong with this code\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        if m == 0 and n == 0:\\n            nums1 = []\\n        elif n == 0:\\n            nums1 = nums1\\n        elif m == 0:\\n            nums1 = nums2\\n        else:\\n            nums1 = nums1[:m] + nums2[:n]\\n            nums1.sort()"
                    },
                    {
                        "username": "jaychCS",
                        "content": "Can this question be done by if and elif to check whether m or n is 0, if yes, then nums1 will be nums2 or nums1. If m, n is not 0, then uses string concatenation to store as nums1, then use build-in sorted function to sort. I tried it works on local, but fails to pass tests on leetcode. I don\\'t understand why it didn\\'t work."
                    },
                    {
                        "username": "antarikshkalita",
                        "content": "even after modifying nums1 array in place, leetcode does not pick up the updated values. when i print I get the correct answer but leetcode just picks the input nums1 as the answer \\n`nums1 = nums1[:m] + nums2[:n]\\n        nums1.sort().`"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the problem with this code, i have tried to manipulate the nums1 list but it output the original list.\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = nums1[:m]\\n        m=m-1\\n        n=n-1\\n        while m >= 0 and n >= 0:\\n            if nums1[m] < nums2[n]:\\n                nums1.insert(m+1,nums2[n])\\n                n-=1\\n                m= m+1\\n            elif nums1[m] == nums2[n]:\\n                nums1.insert(m+1,nums2[n])\\n                n-=1\\n                m= m+1\\n            elif nums1[m] > nums2[n]:\\n                m-=1\\n            print(nums1)\\n\\n\\nprint shows the last iteration it is [1, 2, 2, 3, 5, 6]\\nbut on the output it shows [1,2,3,0,0,0]\\n"
                    },
                    {
                        "username": "joeyjoah",
                        "content": "The fact that zero is used both as a possible value within nums1 and as padding is pretty obnoxious"
                    },
                    {
                        "username": "CDWimmer",
                        "content": "I think this questions sucks for Python for the sheer fact that noone in their right mind would do this in Python. Trailing zeroes? Not just having a return value? Nonsense. "
                    },
                    {
                        "username": "gemmathew121",
                        "content": "What is wrong with my code?\\nTry it yourself, print the value of nums1 after the sorted assignment, the value exactly matches the required result, please help me out, thank you.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        nums1 = nums1[:m]\\n        nums2 = nums2[:n]\\n        nums1 = sorted(nums1+nums2)"
                    },
                    {
                        "username": "shashank_3028",
                        "content": "Just look for all values of m and n . Also run your loop for the last 0\\'s only which are to be replaced by nums2 elements"
                    },
                    {
                        "username": "user6092nL",
                        "content": "I am getting this error. Anyone can explain this error.\nLine 1034: Char 9: runtime error: reference binding to null pointer of type 'int' (stl_vector.h)\n\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\n\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        vector<int> temp(m);\n    for(int i=0;i<m;i++){\n      temp[i]=nums1[i];\n    }\n    nums1.clear();\n    int i=0,j=0;\n    while(i<m || i<n){\n        if(temp[i]<=nums2[j]){\n           nums1.push_back(temp[i]);\n           i++;\n        }\n        else{\n            nums1.push_back(nums2[j]);\n            j++;\n        }\n\n    }\n    for(int k=i;k<m;k++){\n        nums1.push_back(temp[k]);\n    }\n    for(int k=j;k<m;k++){\n        nums1.push_back(nums2[k]);\n    }\n\n    }"
                    }
                ]
            },
            {
                "id": 1891643,
                "content": [
                    {
                        "username": "Tiago14",
                        "content": "why this only works in the console.log ?\n `\nvar merge = function(nums1, m, nums2, n) {\n     console.log([...Array.from({length: m}, (_,i) => nums1[i]), ...Array.from({length: n}, (_,i) => nums2[i])].sort((a,b) => a - b))\n     return [...Array.from({length: m}, (_,i) => nums1[i]), ...Array.from({length: n}, (_,i) => nums2[i])].sort((a,b) => a - b)\n     \n};\n`"
                    },
                    {
                        "username": "Tiago14",
                        "content": "what a shame, I do not have to return anything, the dumbest guy ever"
                    },
                    {
                        "username": "mythilikarra",
                        "content": "This question is rigged one of the test cases had nums1 = [0,0,3,0,0,0,0,0,0] but thats not sorted bruh"
                    },
                    {
                        "username": "Barry_Allen_14",
                        "content": "`def merge(nums1, m, nums2, n):\\n    nums1 = nums1[:m] + nums2[:n]\\n    nums1.sort()\\n\\na = [1, 2, 3, 0, 0, 0]\\nb = [2, 5, 6]\\nmerge(a, 3, b, 3)`\\n\\nAm i missing smth shouldn\\'t this simple code also run it works in pc but doesn\\'t work here."
                    },
                    {
                        "username": "CavalcanteLucas",
                        "content": "This site is clearly broken.\\n\\nI\\'m making\\n```\\nprint(nums1)\\n```\\nin the last line of the `merge` method, which prints\\n```\\n[1, 2, 2, 3, 5, 6]\\n```\\nin the stdout.\\n\\nHowever, the `Output` contains:\\n```\\n[1,2,3,0,0,0]\\n```\\n\\n"
                    },
                    {
                        "username": "santhoshkandhasamy98",
                        "content": "Hi , I am facing a issue,This is my code :\\n\\n        int i = n-1;\\n        int j = m-1; \\n        int k = i+j+1;\\n        if(i==0 && j==0)   k=0;\\n        while(j >= 0){\\n           // System.out.print(i+\"\"+j);\\n            if(i>=0 && nums1[i] > nums2[j])\\n            {\\n               nums1[k] = nums1[i];\\n               i--; k--; \\n            }else \\n            {\\n                nums1[k] = nums2[j];\\n                k--;j--;\\n            }\\n        }\\n\\nThe issue is even when j becomes -1 , still its getting inside while loop. Don\\'t know why. But the same code I tried in Eclipse its working perfectly. Can anyone help on this........ Pleaseeee"
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "is runtime depend on my pc specs ? or? cuz it is always different numbers "
                    },
                    {
                        "username": "Pavnesh-Silori",
                        "content": "all my testcases are passed tough getting runtime error, can anybody help\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0,j=0;\\n        while(i<n||j<m)\\n        {\\n            if(nums1[j]==0)\\n            {\\n                nums1[j]=nums2[i];\\n            i++;j++;\\n            }\\n            else{j++;}\\n        }\\n   \\n        \\n       \\n      sort(nums1.begin(),nums1.end());\\n        \\n    }\\n};\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9"
                    },
                    {
                        "username": "AureleWebDev",
                        "content": "Hi yall, \\n\\nWhy doesn\\'t this return me [ 1, 2, 2, 3, 5, 6 ] ?\\n\\n `\\nvar merge = function(nums1, m, nums2, n) {\\n\\n    if (!nums1 && !nums2) return [];\\n\\n    let firstNum = nums1.slice(0, m);\\n\\n    let secondNum = nums2.slice(0, n);\\n\\n    let result = firstNum.concat(secondNum).sort();\\n\\n    return result;\\n\\n};\\n`\\n\\nConsole.log(result) -> [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut Output:\\n\\n[1,2,3,0,0,0]"
                    },
                    {
                        "username": "AureleWebDev",
                        "content": "Never mind I just saw that we have to modify nums1 and not return anything... This is a little bit lame for sure"
                    },
                    {
                        "username": "lraseemela",
                        "content": "I tested my code in IntelliJ and it works without any issues, but when I test it here with the same inputs, it says my answer is incorrect, and it shows a different output from what I am getting using IntelliJ....what is the issue?\\n"
                    },
                    {
                        "username": "mohitsood5934",
                        "content": "My Code is running correct for mentioned test cases in other compilers, don\\'t know why in leet code it is giving wromg answer\\n\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1 = [...nums1.splice(0,m),...nums2.splice(0,n)];\\n    for (i = 0 ; i < nums1.length ; i++){\\n        if(nums1[i] > nums1[i+1]){\\n            let temp = nums1[i + 1];\\n            nums1[i+1] = nums1[i];\\n            nums1[i] = temp\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1889534,
                "content": [
                    {
                        "username": "Tiago14",
                        "content": "why this only works in the console.log ?\n `\nvar merge = function(nums1, m, nums2, n) {\n     console.log([...Array.from({length: m}, (_,i) => nums1[i]), ...Array.from({length: n}, (_,i) => nums2[i])].sort((a,b) => a - b))\n     return [...Array.from({length: m}, (_,i) => nums1[i]), ...Array.from({length: n}, (_,i) => nums2[i])].sort((a,b) => a - b)\n     \n};\n`"
                    },
                    {
                        "username": "Tiago14",
                        "content": "what a shame, I do not have to return anything, the dumbest guy ever"
                    },
                    {
                        "username": "mythilikarra",
                        "content": "This question is rigged one of the test cases had nums1 = [0,0,3,0,0,0,0,0,0] but thats not sorted bruh"
                    },
                    {
                        "username": "Barry_Allen_14",
                        "content": "`def merge(nums1, m, nums2, n):\\n    nums1 = nums1[:m] + nums2[:n]\\n    nums1.sort()\\n\\na = [1, 2, 3, 0, 0, 0]\\nb = [2, 5, 6]\\nmerge(a, 3, b, 3)`\\n\\nAm i missing smth shouldn\\'t this simple code also run it works in pc but doesn\\'t work here."
                    },
                    {
                        "username": "CavalcanteLucas",
                        "content": "This site is clearly broken.\\n\\nI\\'m making\\n```\\nprint(nums1)\\n```\\nin the last line of the `merge` method, which prints\\n```\\n[1, 2, 2, 3, 5, 6]\\n```\\nin the stdout.\\n\\nHowever, the `Output` contains:\\n```\\n[1,2,3,0,0,0]\\n```\\n\\n"
                    },
                    {
                        "username": "santhoshkandhasamy98",
                        "content": "Hi , I am facing a issue,This is my code :\\n\\n        int i = n-1;\\n        int j = m-1; \\n        int k = i+j+1;\\n        if(i==0 && j==0)   k=0;\\n        while(j >= 0){\\n           // System.out.print(i+\"\"+j);\\n            if(i>=0 && nums1[i] > nums2[j])\\n            {\\n               nums1[k] = nums1[i];\\n               i--; k--; \\n            }else \\n            {\\n                nums1[k] = nums2[j];\\n                k--;j--;\\n            }\\n        }\\n\\nThe issue is even when j becomes -1 , still its getting inside while loop. Don\\'t know why. But the same code I tried in Eclipse its working perfectly. Can anyone help on this........ Pleaseeee"
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "is runtime depend on my pc specs ? or? cuz it is always different numbers "
                    },
                    {
                        "username": "Pavnesh-Silori",
                        "content": "all my testcases are passed tough getting runtime error, can anybody help\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0,j=0;\\n        while(i<n||j<m)\\n        {\\n            if(nums1[j]==0)\\n            {\\n                nums1[j]=nums2[i];\\n            i++;j++;\\n            }\\n            else{j++;}\\n        }\\n   \\n        \\n       \\n      sort(nums1.begin(),nums1.end());\\n        \\n    }\\n};\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9"
                    },
                    {
                        "username": "AureleWebDev",
                        "content": "Hi yall, \\n\\nWhy doesn\\'t this return me [ 1, 2, 2, 3, 5, 6 ] ?\\n\\n `\\nvar merge = function(nums1, m, nums2, n) {\\n\\n    if (!nums1 && !nums2) return [];\\n\\n    let firstNum = nums1.slice(0, m);\\n\\n    let secondNum = nums2.slice(0, n);\\n\\n    let result = firstNum.concat(secondNum).sort();\\n\\n    return result;\\n\\n};\\n`\\n\\nConsole.log(result) -> [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut Output:\\n\\n[1,2,3,0,0,0]"
                    },
                    {
                        "username": "AureleWebDev",
                        "content": "Never mind I just saw that we have to modify nums1 and not return anything... This is a little bit lame for sure"
                    },
                    {
                        "username": "lraseemela",
                        "content": "I tested my code in IntelliJ and it works without any issues, but when I test it here with the same inputs, it says my answer is incorrect, and it shows a different output from what I am getting using IntelliJ....what is the issue?\\n"
                    },
                    {
                        "username": "mohitsood5934",
                        "content": "My Code is running correct for mentioned test cases in other compilers, don\\'t know why in leet code it is giving wromg answer\\n\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1 = [...nums1.splice(0,m),...nums2.splice(0,n)];\\n    for (i = 0 ; i < nums1.length ; i++){\\n        if(nums1[i] > nums1[i+1]){\\n            let temp = nums1[i + 1];\\n            nums1[i+1] = nums1[i];\\n            nums1[i] = temp\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1889117,
                "content": [
                    {
                        "username": "Tiago14",
                        "content": "why this only works in the console.log ?\n `\nvar merge = function(nums1, m, nums2, n) {\n     console.log([...Array.from({length: m}, (_,i) => nums1[i]), ...Array.from({length: n}, (_,i) => nums2[i])].sort((a,b) => a - b))\n     return [...Array.from({length: m}, (_,i) => nums1[i]), ...Array.from({length: n}, (_,i) => nums2[i])].sort((a,b) => a - b)\n     \n};\n`"
                    },
                    {
                        "username": "Tiago14",
                        "content": "what a shame, I do not have to return anything, the dumbest guy ever"
                    },
                    {
                        "username": "mythilikarra",
                        "content": "This question is rigged one of the test cases had nums1 = [0,0,3,0,0,0,0,0,0] but thats not sorted bruh"
                    },
                    {
                        "username": "Barry_Allen_14",
                        "content": "`def merge(nums1, m, nums2, n):\\n    nums1 = nums1[:m] + nums2[:n]\\n    nums1.sort()\\n\\na = [1, 2, 3, 0, 0, 0]\\nb = [2, 5, 6]\\nmerge(a, 3, b, 3)`\\n\\nAm i missing smth shouldn\\'t this simple code also run it works in pc but doesn\\'t work here."
                    },
                    {
                        "username": "CavalcanteLucas",
                        "content": "This site is clearly broken.\\n\\nI\\'m making\\n```\\nprint(nums1)\\n```\\nin the last line of the `merge` method, which prints\\n```\\n[1, 2, 2, 3, 5, 6]\\n```\\nin the stdout.\\n\\nHowever, the `Output` contains:\\n```\\n[1,2,3,0,0,0]\\n```\\n\\n"
                    },
                    {
                        "username": "santhoshkandhasamy98",
                        "content": "Hi , I am facing a issue,This is my code :\\n\\n        int i = n-1;\\n        int j = m-1; \\n        int k = i+j+1;\\n        if(i==0 && j==0)   k=0;\\n        while(j >= 0){\\n           // System.out.print(i+\"\"+j);\\n            if(i>=0 && nums1[i] > nums2[j])\\n            {\\n               nums1[k] = nums1[i];\\n               i--; k--; \\n            }else \\n            {\\n                nums1[k] = nums2[j];\\n                k--;j--;\\n            }\\n        }\\n\\nThe issue is even when j becomes -1 , still its getting inside while loop. Don\\'t know why. But the same code I tried in Eclipse its working perfectly. Can anyone help on this........ Pleaseeee"
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "is runtime depend on my pc specs ? or? cuz it is always different numbers "
                    },
                    {
                        "username": "Pavnesh-Silori",
                        "content": "all my testcases are passed tough getting runtime error, can anybody help\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0,j=0;\\n        while(i<n||j<m)\\n        {\\n            if(nums1[j]==0)\\n            {\\n                nums1[j]=nums2[i];\\n            i++;j++;\\n            }\\n            else{j++;}\\n        }\\n   \\n        \\n       \\n      sort(nums1.begin(),nums1.end());\\n        \\n    }\\n};\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9"
                    },
                    {
                        "username": "AureleWebDev",
                        "content": "Hi yall, \\n\\nWhy doesn\\'t this return me [ 1, 2, 2, 3, 5, 6 ] ?\\n\\n `\\nvar merge = function(nums1, m, nums2, n) {\\n\\n    if (!nums1 && !nums2) return [];\\n\\n    let firstNum = nums1.slice(0, m);\\n\\n    let secondNum = nums2.slice(0, n);\\n\\n    let result = firstNum.concat(secondNum).sort();\\n\\n    return result;\\n\\n};\\n`\\n\\nConsole.log(result) -> [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut Output:\\n\\n[1,2,3,0,0,0]"
                    },
                    {
                        "username": "AureleWebDev",
                        "content": "Never mind I just saw that we have to modify nums1 and not return anything... This is a little bit lame for sure"
                    },
                    {
                        "username": "lraseemela",
                        "content": "I tested my code in IntelliJ and it works without any issues, but when I test it here with the same inputs, it says my answer is incorrect, and it shows a different output from what I am getting using IntelliJ....what is the issue?\\n"
                    },
                    {
                        "username": "mohitsood5934",
                        "content": "My Code is running correct for mentioned test cases in other compilers, don\\'t know why in leet code it is giving wromg answer\\n\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1 = [...nums1.splice(0,m),...nums2.splice(0,n)];\\n    for (i = 0 ; i < nums1.length ; i++){\\n        if(nums1[i] > nums1[i+1]){\\n            let temp = nums1[i + 1];\\n            nums1[i+1] = nums1[i];\\n            nums1[i] = temp\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1887124,
                "content": [
                    {
                        "username": "Tiago14",
                        "content": "why this only works in the console.log ?\n `\nvar merge = function(nums1, m, nums2, n) {\n     console.log([...Array.from({length: m}, (_,i) => nums1[i]), ...Array.from({length: n}, (_,i) => nums2[i])].sort((a,b) => a - b))\n     return [...Array.from({length: m}, (_,i) => nums1[i]), ...Array.from({length: n}, (_,i) => nums2[i])].sort((a,b) => a - b)\n     \n};\n`"
                    },
                    {
                        "username": "Tiago14",
                        "content": "what a shame, I do not have to return anything, the dumbest guy ever"
                    },
                    {
                        "username": "mythilikarra",
                        "content": "This question is rigged one of the test cases had nums1 = [0,0,3,0,0,0,0,0,0] but thats not sorted bruh"
                    },
                    {
                        "username": "Barry_Allen_14",
                        "content": "`def merge(nums1, m, nums2, n):\\n    nums1 = nums1[:m] + nums2[:n]\\n    nums1.sort()\\n\\na = [1, 2, 3, 0, 0, 0]\\nb = [2, 5, 6]\\nmerge(a, 3, b, 3)`\\n\\nAm i missing smth shouldn\\'t this simple code also run it works in pc but doesn\\'t work here."
                    },
                    {
                        "username": "CavalcanteLucas",
                        "content": "This site is clearly broken.\\n\\nI\\'m making\\n```\\nprint(nums1)\\n```\\nin the last line of the `merge` method, which prints\\n```\\n[1, 2, 2, 3, 5, 6]\\n```\\nin the stdout.\\n\\nHowever, the `Output` contains:\\n```\\n[1,2,3,0,0,0]\\n```\\n\\n"
                    },
                    {
                        "username": "santhoshkandhasamy98",
                        "content": "Hi , I am facing a issue,This is my code :\\n\\n        int i = n-1;\\n        int j = m-1; \\n        int k = i+j+1;\\n        if(i==0 && j==0)   k=0;\\n        while(j >= 0){\\n           // System.out.print(i+\"\"+j);\\n            if(i>=0 && nums1[i] > nums2[j])\\n            {\\n               nums1[k] = nums1[i];\\n               i--; k--; \\n            }else \\n            {\\n                nums1[k] = nums2[j];\\n                k--;j--;\\n            }\\n        }\\n\\nThe issue is even when j becomes -1 , still its getting inside while loop. Don\\'t know why. But the same code I tried in Eclipse its working perfectly. Can anyone help on this........ Pleaseeee"
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "is runtime depend on my pc specs ? or? cuz it is always different numbers "
                    },
                    {
                        "username": "Pavnesh-Silori",
                        "content": "all my testcases are passed tough getting runtime error, can anybody help\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0,j=0;\\n        while(i<n||j<m)\\n        {\\n            if(nums1[j]==0)\\n            {\\n                nums1[j]=nums2[i];\\n            i++;j++;\\n            }\\n            else{j++;}\\n        }\\n   \\n        \\n       \\n      sort(nums1.begin(),nums1.end());\\n        \\n    }\\n};\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9"
                    },
                    {
                        "username": "AureleWebDev",
                        "content": "Hi yall, \\n\\nWhy doesn\\'t this return me [ 1, 2, 2, 3, 5, 6 ] ?\\n\\n `\\nvar merge = function(nums1, m, nums2, n) {\\n\\n    if (!nums1 && !nums2) return [];\\n\\n    let firstNum = nums1.slice(0, m);\\n\\n    let secondNum = nums2.slice(0, n);\\n\\n    let result = firstNum.concat(secondNum).sort();\\n\\n    return result;\\n\\n};\\n`\\n\\nConsole.log(result) -> [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut Output:\\n\\n[1,2,3,0,0,0]"
                    },
                    {
                        "username": "AureleWebDev",
                        "content": "Never mind I just saw that we have to modify nums1 and not return anything... This is a little bit lame for sure"
                    },
                    {
                        "username": "lraseemela",
                        "content": "I tested my code in IntelliJ and it works without any issues, but when I test it here with the same inputs, it says my answer is incorrect, and it shows a different output from what I am getting using IntelliJ....what is the issue?\\n"
                    },
                    {
                        "username": "mohitsood5934",
                        "content": "My Code is running correct for mentioned test cases in other compilers, don\\'t know why in leet code it is giving wromg answer\\n\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1 = [...nums1.splice(0,m),...nums2.splice(0,n)];\\n    for (i = 0 ; i < nums1.length ; i++){\\n        if(nums1[i] > nums1[i+1]){\\n            let temp = nums1[i + 1];\\n            nums1[i+1] = nums1[i];\\n            nums1[i] = temp\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1882757,
                "content": [
                    {
                        "username": "Tiago14",
                        "content": "why this only works in the console.log ?\n `\nvar merge = function(nums1, m, nums2, n) {\n     console.log([...Array.from({length: m}, (_,i) => nums1[i]), ...Array.from({length: n}, (_,i) => nums2[i])].sort((a,b) => a - b))\n     return [...Array.from({length: m}, (_,i) => nums1[i]), ...Array.from({length: n}, (_,i) => nums2[i])].sort((a,b) => a - b)\n     \n};\n`"
                    },
                    {
                        "username": "Tiago14",
                        "content": "what a shame, I do not have to return anything, the dumbest guy ever"
                    },
                    {
                        "username": "mythilikarra",
                        "content": "This question is rigged one of the test cases had nums1 = [0,0,3,0,0,0,0,0,0] but thats not sorted bruh"
                    },
                    {
                        "username": "Barry_Allen_14",
                        "content": "`def merge(nums1, m, nums2, n):\\n    nums1 = nums1[:m] + nums2[:n]\\n    nums1.sort()\\n\\na = [1, 2, 3, 0, 0, 0]\\nb = [2, 5, 6]\\nmerge(a, 3, b, 3)`\\n\\nAm i missing smth shouldn\\'t this simple code also run it works in pc but doesn\\'t work here."
                    },
                    {
                        "username": "CavalcanteLucas",
                        "content": "This site is clearly broken.\\n\\nI\\'m making\\n```\\nprint(nums1)\\n```\\nin the last line of the `merge` method, which prints\\n```\\n[1, 2, 2, 3, 5, 6]\\n```\\nin the stdout.\\n\\nHowever, the `Output` contains:\\n```\\n[1,2,3,0,0,0]\\n```\\n\\n"
                    },
                    {
                        "username": "santhoshkandhasamy98",
                        "content": "Hi , I am facing a issue,This is my code :\\n\\n        int i = n-1;\\n        int j = m-1; \\n        int k = i+j+1;\\n        if(i==0 && j==0)   k=0;\\n        while(j >= 0){\\n           // System.out.print(i+\"\"+j);\\n            if(i>=0 && nums1[i] > nums2[j])\\n            {\\n               nums1[k] = nums1[i];\\n               i--; k--; \\n            }else \\n            {\\n                nums1[k] = nums2[j];\\n                k--;j--;\\n            }\\n        }\\n\\nThe issue is even when j becomes -1 , still its getting inside while loop. Don\\'t know why. But the same code I tried in Eclipse its working perfectly. Can anyone help on this........ Pleaseeee"
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "is runtime depend on my pc specs ? or? cuz it is always different numbers "
                    },
                    {
                        "username": "Pavnesh-Silori",
                        "content": "all my testcases are passed tough getting runtime error, can anybody help\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0,j=0;\\n        while(i<n||j<m)\\n        {\\n            if(nums1[j]==0)\\n            {\\n                nums1[j]=nums2[i];\\n            i++;j++;\\n            }\\n            else{j++;}\\n        }\\n   \\n        \\n       \\n      sort(nums1.begin(),nums1.end());\\n        \\n    }\\n};\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9"
                    },
                    {
                        "username": "AureleWebDev",
                        "content": "Hi yall, \\n\\nWhy doesn\\'t this return me [ 1, 2, 2, 3, 5, 6 ] ?\\n\\n `\\nvar merge = function(nums1, m, nums2, n) {\\n\\n    if (!nums1 && !nums2) return [];\\n\\n    let firstNum = nums1.slice(0, m);\\n\\n    let secondNum = nums2.slice(0, n);\\n\\n    let result = firstNum.concat(secondNum).sort();\\n\\n    return result;\\n\\n};\\n`\\n\\nConsole.log(result) -> [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut Output:\\n\\n[1,2,3,0,0,0]"
                    },
                    {
                        "username": "AureleWebDev",
                        "content": "Never mind I just saw that we have to modify nums1 and not return anything... This is a little bit lame for sure"
                    },
                    {
                        "username": "lraseemela",
                        "content": "I tested my code in IntelliJ and it works without any issues, but when I test it here with the same inputs, it says my answer is incorrect, and it shows a different output from what I am getting using IntelliJ....what is the issue?\\n"
                    },
                    {
                        "username": "mohitsood5934",
                        "content": "My Code is running correct for mentioned test cases in other compilers, don\\'t know why in leet code it is giving wromg answer\\n\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1 = [...nums1.splice(0,m),...nums2.splice(0,n)];\\n    for (i = 0 ; i < nums1.length ; i++){\\n        if(nums1[i] > nums1[i+1]){\\n            let temp = nums1[i + 1];\\n            nums1[i+1] = nums1[i];\\n            nums1[i] = temp\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1876406,
                "content": [
                    {
                        "username": "Tiago14",
                        "content": "why this only works in the console.log ?\n `\nvar merge = function(nums1, m, nums2, n) {\n     console.log([...Array.from({length: m}, (_,i) => nums1[i]), ...Array.from({length: n}, (_,i) => nums2[i])].sort((a,b) => a - b))\n     return [...Array.from({length: m}, (_,i) => nums1[i]), ...Array.from({length: n}, (_,i) => nums2[i])].sort((a,b) => a - b)\n     \n};\n`"
                    },
                    {
                        "username": "Tiago14",
                        "content": "what a shame, I do not have to return anything, the dumbest guy ever"
                    },
                    {
                        "username": "mythilikarra",
                        "content": "This question is rigged one of the test cases had nums1 = [0,0,3,0,0,0,0,0,0] but thats not sorted bruh"
                    },
                    {
                        "username": "Barry_Allen_14",
                        "content": "`def merge(nums1, m, nums2, n):\\n    nums1 = nums1[:m] + nums2[:n]\\n    nums1.sort()\\n\\na = [1, 2, 3, 0, 0, 0]\\nb = [2, 5, 6]\\nmerge(a, 3, b, 3)`\\n\\nAm i missing smth shouldn\\'t this simple code also run it works in pc but doesn\\'t work here."
                    },
                    {
                        "username": "CavalcanteLucas",
                        "content": "This site is clearly broken.\\n\\nI\\'m making\\n```\\nprint(nums1)\\n```\\nin the last line of the `merge` method, which prints\\n```\\n[1, 2, 2, 3, 5, 6]\\n```\\nin the stdout.\\n\\nHowever, the `Output` contains:\\n```\\n[1,2,3,0,0,0]\\n```\\n\\n"
                    },
                    {
                        "username": "santhoshkandhasamy98",
                        "content": "Hi , I am facing a issue,This is my code :\\n\\n        int i = n-1;\\n        int j = m-1; \\n        int k = i+j+1;\\n        if(i==0 && j==0)   k=0;\\n        while(j >= 0){\\n           // System.out.print(i+\"\"+j);\\n            if(i>=0 && nums1[i] > nums2[j])\\n            {\\n               nums1[k] = nums1[i];\\n               i--; k--; \\n            }else \\n            {\\n                nums1[k] = nums2[j];\\n                k--;j--;\\n            }\\n        }\\n\\nThe issue is even when j becomes -1 , still its getting inside while loop. Don\\'t know why. But the same code I tried in Eclipse its working perfectly. Can anyone help on this........ Pleaseeee"
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "is runtime depend on my pc specs ? or? cuz it is always different numbers "
                    },
                    {
                        "username": "Pavnesh-Silori",
                        "content": "all my testcases are passed tough getting runtime error, can anybody help\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0,j=0;\\n        while(i<n||j<m)\\n        {\\n            if(nums1[j]==0)\\n            {\\n                nums1[j]=nums2[i];\\n            i++;j++;\\n            }\\n            else{j++;}\\n        }\\n   \\n        \\n       \\n      sort(nums1.begin(),nums1.end());\\n        \\n    }\\n};\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9"
                    },
                    {
                        "username": "AureleWebDev",
                        "content": "Hi yall, \\n\\nWhy doesn\\'t this return me [ 1, 2, 2, 3, 5, 6 ] ?\\n\\n `\\nvar merge = function(nums1, m, nums2, n) {\\n\\n    if (!nums1 && !nums2) return [];\\n\\n    let firstNum = nums1.slice(0, m);\\n\\n    let secondNum = nums2.slice(0, n);\\n\\n    let result = firstNum.concat(secondNum).sort();\\n\\n    return result;\\n\\n};\\n`\\n\\nConsole.log(result) -> [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut Output:\\n\\n[1,2,3,0,0,0]"
                    },
                    {
                        "username": "AureleWebDev",
                        "content": "Never mind I just saw that we have to modify nums1 and not return anything... This is a little bit lame for sure"
                    },
                    {
                        "username": "lraseemela",
                        "content": "I tested my code in IntelliJ and it works without any issues, but when I test it here with the same inputs, it says my answer is incorrect, and it shows a different output from what I am getting using IntelliJ....what is the issue?\\n"
                    },
                    {
                        "username": "mohitsood5934",
                        "content": "My Code is running correct for mentioned test cases in other compilers, don\\'t know why in leet code it is giving wromg answer\\n\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1 = [...nums1.splice(0,m),...nums2.splice(0,n)];\\n    for (i = 0 ; i < nums1.length ; i++){\\n        if(nums1[i] > nums1[i+1]){\\n            let temp = nums1[i + 1];\\n            nums1[i+1] = nums1[i];\\n            nums1[i] = temp\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1872569,
                "content": [
                    {
                        "username": "Tiago14",
                        "content": "why this only works in the console.log ?\n `\nvar merge = function(nums1, m, nums2, n) {\n     console.log([...Array.from({length: m}, (_,i) => nums1[i]), ...Array.from({length: n}, (_,i) => nums2[i])].sort((a,b) => a - b))\n     return [...Array.from({length: m}, (_,i) => nums1[i]), ...Array.from({length: n}, (_,i) => nums2[i])].sort((a,b) => a - b)\n     \n};\n`"
                    },
                    {
                        "username": "Tiago14",
                        "content": "what a shame, I do not have to return anything, the dumbest guy ever"
                    },
                    {
                        "username": "mythilikarra",
                        "content": "This question is rigged one of the test cases had nums1 = [0,0,3,0,0,0,0,0,0] but thats not sorted bruh"
                    },
                    {
                        "username": "Barry_Allen_14",
                        "content": "`def merge(nums1, m, nums2, n):\\n    nums1 = nums1[:m] + nums2[:n]\\n    nums1.sort()\\n\\na = [1, 2, 3, 0, 0, 0]\\nb = [2, 5, 6]\\nmerge(a, 3, b, 3)`\\n\\nAm i missing smth shouldn\\'t this simple code also run it works in pc but doesn\\'t work here."
                    },
                    {
                        "username": "CavalcanteLucas",
                        "content": "This site is clearly broken.\\n\\nI\\'m making\\n```\\nprint(nums1)\\n```\\nin the last line of the `merge` method, which prints\\n```\\n[1, 2, 2, 3, 5, 6]\\n```\\nin the stdout.\\n\\nHowever, the `Output` contains:\\n```\\n[1,2,3,0,0,0]\\n```\\n\\n"
                    },
                    {
                        "username": "santhoshkandhasamy98",
                        "content": "Hi , I am facing a issue,This is my code :\\n\\n        int i = n-1;\\n        int j = m-1; \\n        int k = i+j+1;\\n        if(i==0 && j==0)   k=0;\\n        while(j >= 0){\\n           // System.out.print(i+\"\"+j);\\n            if(i>=0 && nums1[i] > nums2[j])\\n            {\\n               nums1[k] = nums1[i];\\n               i--; k--; \\n            }else \\n            {\\n                nums1[k] = nums2[j];\\n                k--;j--;\\n            }\\n        }\\n\\nThe issue is even when j becomes -1 , still its getting inside while loop. Don\\'t know why. But the same code I tried in Eclipse its working perfectly. Can anyone help on this........ Pleaseeee"
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "is runtime depend on my pc specs ? or? cuz it is always different numbers "
                    },
                    {
                        "username": "Pavnesh-Silori",
                        "content": "all my testcases are passed tough getting runtime error, can anybody help\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0,j=0;\\n        while(i<n||j<m)\\n        {\\n            if(nums1[j]==0)\\n            {\\n                nums1[j]=nums2[i];\\n            i++;j++;\\n            }\\n            else{j++;}\\n        }\\n   \\n        \\n       \\n      sort(nums1.begin(),nums1.end());\\n        \\n    }\\n};\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9"
                    },
                    {
                        "username": "AureleWebDev",
                        "content": "Hi yall, \\n\\nWhy doesn\\'t this return me [ 1, 2, 2, 3, 5, 6 ] ?\\n\\n `\\nvar merge = function(nums1, m, nums2, n) {\\n\\n    if (!nums1 && !nums2) return [];\\n\\n    let firstNum = nums1.slice(0, m);\\n\\n    let secondNum = nums2.slice(0, n);\\n\\n    let result = firstNum.concat(secondNum).sort();\\n\\n    return result;\\n\\n};\\n`\\n\\nConsole.log(result) -> [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut Output:\\n\\n[1,2,3,0,0,0]"
                    },
                    {
                        "username": "AureleWebDev",
                        "content": "Never mind I just saw that we have to modify nums1 and not return anything... This is a little bit lame for sure"
                    },
                    {
                        "username": "lraseemela",
                        "content": "I tested my code in IntelliJ and it works without any issues, but when I test it here with the same inputs, it says my answer is incorrect, and it shows a different output from what I am getting using IntelliJ....what is the issue?\\n"
                    },
                    {
                        "username": "mohitsood5934",
                        "content": "My Code is running correct for mentioned test cases in other compilers, don\\'t know why in leet code it is giving wromg answer\\n\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1 = [...nums1.splice(0,m),...nums2.splice(0,n)];\\n    for (i = 0 ; i < nums1.length ; i++){\\n        if(nums1[i] > nums1[i+1]){\\n            let temp = nums1[i + 1];\\n            nums1[i+1] = nums1[i];\\n            nums1[i] = temp\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1872000,
                "content": [
                    {
                        "username": "Tiago14",
                        "content": "why this only works in the console.log ?\n `\nvar merge = function(nums1, m, nums2, n) {\n     console.log([...Array.from({length: m}, (_,i) => nums1[i]), ...Array.from({length: n}, (_,i) => nums2[i])].sort((a,b) => a - b))\n     return [...Array.from({length: m}, (_,i) => nums1[i]), ...Array.from({length: n}, (_,i) => nums2[i])].sort((a,b) => a - b)\n     \n};\n`"
                    },
                    {
                        "username": "Tiago14",
                        "content": "what a shame, I do not have to return anything, the dumbest guy ever"
                    },
                    {
                        "username": "mythilikarra",
                        "content": "This question is rigged one of the test cases had nums1 = [0,0,3,0,0,0,0,0,0] but thats not sorted bruh"
                    },
                    {
                        "username": "Barry_Allen_14",
                        "content": "`def merge(nums1, m, nums2, n):\\n    nums1 = nums1[:m] + nums2[:n]\\n    nums1.sort()\\n\\na = [1, 2, 3, 0, 0, 0]\\nb = [2, 5, 6]\\nmerge(a, 3, b, 3)`\\n\\nAm i missing smth shouldn\\'t this simple code also run it works in pc but doesn\\'t work here."
                    },
                    {
                        "username": "CavalcanteLucas",
                        "content": "This site is clearly broken.\\n\\nI\\'m making\\n```\\nprint(nums1)\\n```\\nin the last line of the `merge` method, which prints\\n```\\n[1, 2, 2, 3, 5, 6]\\n```\\nin the stdout.\\n\\nHowever, the `Output` contains:\\n```\\n[1,2,3,0,0,0]\\n```\\n\\n"
                    },
                    {
                        "username": "santhoshkandhasamy98",
                        "content": "Hi , I am facing a issue,This is my code :\\n\\n        int i = n-1;\\n        int j = m-1; \\n        int k = i+j+1;\\n        if(i==0 && j==0)   k=0;\\n        while(j >= 0){\\n           // System.out.print(i+\"\"+j);\\n            if(i>=0 && nums1[i] > nums2[j])\\n            {\\n               nums1[k] = nums1[i];\\n               i--; k--; \\n            }else \\n            {\\n                nums1[k] = nums2[j];\\n                k--;j--;\\n            }\\n        }\\n\\nThe issue is even when j becomes -1 , still its getting inside while loop. Don\\'t know why. But the same code I tried in Eclipse its working perfectly. Can anyone help on this........ Pleaseeee"
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "is runtime depend on my pc specs ? or? cuz it is always different numbers "
                    },
                    {
                        "username": "Pavnesh-Silori",
                        "content": "all my testcases are passed tough getting runtime error, can anybody help\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0,j=0;\\n        while(i<n||j<m)\\n        {\\n            if(nums1[j]==0)\\n            {\\n                nums1[j]=nums2[i];\\n            i++;j++;\\n            }\\n            else{j++;}\\n        }\\n   \\n        \\n       \\n      sort(nums1.begin(),nums1.end());\\n        \\n    }\\n};\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9"
                    },
                    {
                        "username": "AureleWebDev",
                        "content": "Hi yall, \\n\\nWhy doesn\\'t this return me [ 1, 2, 2, 3, 5, 6 ] ?\\n\\n `\\nvar merge = function(nums1, m, nums2, n) {\\n\\n    if (!nums1 && !nums2) return [];\\n\\n    let firstNum = nums1.slice(0, m);\\n\\n    let secondNum = nums2.slice(0, n);\\n\\n    let result = firstNum.concat(secondNum).sort();\\n\\n    return result;\\n\\n};\\n`\\n\\nConsole.log(result) -> [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut Output:\\n\\n[1,2,3,0,0,0]"
                    },
                    {
                        "username": "AureleWebDev",
                        "content": "Never mind I just saw that we have to modify nums1 and not return anything... This is a little bit lame for sure"
                    },
                    {
                        "username": "lraseemela",
                        "content": "I tested my code in IntelliJ and it works without any issues, but when I test it here with the same inputs, it says my answer is incorrect, and it shows a different output from what I am getting using IntelliJ....what is the issue?\\n"
                    },
                    {
                        "username": "mohitsood5934",
                        "content": "My Code is running correct for mentioned test cases in other compilers, don\\'t know why in leet code it is giving wromg answer\\n\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1 = [...nums1.splice(0,m),...nums2.splice(0,n)];\\n    for (i = 0 ; i < nums1.length ; i++){\\n        if(nums1[i] > nums1[i+1]){\\n            let temp = nums1[i + 1];\\n            nums1[i+1] = nums1[i];\\n            nums1[i] = temp\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1869628,
                "content": [
                    {
                        "username": "Tiago14",
                        "content": "why this only works in the console.log ?\n `\nvar merge = function(nums1, m, nums2, n) {\n     console.log([...Array.from({length: m}, (_,i) => nums1[i]), ...Array.from({length: n}, (_,i) => nums2[i])].sort((a,b) => a - b))\n     return [...Array.from({length: m}, (_,i) => nums1[i]), ...Array.from({length: n}, (_,i) => nums2[i])].sort((a,b) => a - b)\n     \n};\n`"
                    },
                    {
                        "username": "Tiago14",
                        "content": "what a shame, I do not have to return anything, the dumbest guy ever"
                    },
                    {
                        "username": "mythilikarra",
                        "content": "This question is rigged one of the test cases had nums1 = [0,0,3,0,0,0,0,0,0] but thats not sorted bruh"
                    },
                    {
                        "username": "Barry_Allen_14",
                        "content": "`def merge(nums1, m, nums2, n):\\n    nums1 = nums1[:m] + nums2[:n]\\n    nums1.sort()\\n\\na = [1, 2, 3, 0, 0, 0]\\nb = [2, 5, 6]\\nmerge(a, 3, b, 3)`\\n\\nAm i missing smth shouldn\\'t this simple code also run it works in pc but doesn\\'t work here."
                    },
                    {
                        "username": "CavalcanteLucas",
                        "content": "This site is clearly broken.\\n\\nI\\'m making\\n```\\nprint(nums1)\\n```\\nin the last line of the `merge` method, which prints\\n```\\n[1, 2, 2, 3, 5, 6]\\n```\\nin the stdout.\\n\\nHowever, the `Output` contains:\\n```\\n[1,2,3,0,0,0]\\n```\\n\\n"
                    },
                    {
                        "username": "santhoshkandhasamy98",
                        "content": "Hi , I am facing a issue,This is my code :\\n\\n        int i = n-1;\\n        int j = m-1; \\n        int k = i+j+1;\\n        if(i==0 && j==0)   k=0;\\n        while(j >= 0){\\n           // System.out.print(i+\"\"+j);\\n            if(i>=0 && nums1[i] > nums2[j])\\n            {\\n               nums1[k] = nums1[i];\\n               i--; k--; \\n            }else \\n            {\\n                nums1[k] = nums2[j];\\n                k--;j--;\\n            }\\n        }\\n\\nThe issue is even when j becomes -1 , still its getting inside while loop. Don\\'t know why. But the same code I tried in Eclipse its working perfectly. Can anyone help on this........ Pleaseeee"
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "is runtime depend on my pc specs ? or? cuz it is always different numbers "
                    },
                    {
                        "username": "Pavnesh-Silori",
                        "content": "all my testcases are passed tough getting runtime error, can anybody help\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0,j=0;\\n        while(i<n||j<m)\\n        {\\n            if(nums1[j]==0)\\n            {\\n                nums1[j]=nums2[i];\\n            i++;j++;\\n            }\\n            else{j++;}\\n        }\\n   \\n        \\n       \\n      sort(nums1.begin(),nums1.end());\\n        \\n    }\\n};\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9"
                    },
                    {
                        "username": "AureleWebDev",
                        "content": "Hi yall, \\n\\nWhy doesn\\'t this return me [ 1, 2, 2, 3, 5, 6 ] ?\\n\\n `\\nvar merge = function(nums1, m, nums2, n) {\\n\\n    if (!nums1 && !nums2) return [];\\n\\n    let firstNum = nums1.slice(0, m);\\n\\n    let secondNum = nums2.slice(0, n);\\n\\n    let result = firstNum.concat(secondNum).sort();\\n\\n    return result;\\n\\n};\\n`\\n\\nConsole.log(result) -> [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut Output:\\n\\n[1,2,3,0,0,0]"
                    },
                    {
                        "username": "AureleWebDev",
                        "content": "Never mind I just saw that we have to modify nums1 and not return anything... This is a little bit lame for sure"
                    },
                    {
                        "username": "lraseemela",
                        "content": "I tested my code in IntelliJ and it works without any issues, but when I test it here with the same inputs, it says my answer is incorrect, and it shows a different output from what I am getting using IntelliJ....what is the issue?\\n"
                    },
                    {
                        "username": "mohitsood5934",
                        "content": "My Code is running correct for mentioned test cases in other compilers, don\\'t know why in leet code it is giving wromg answer\\n\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1 = [...nums1.splice(0,m),...nums2.splice(0,n)];\\n    for (i = 0 ; i < nums1.length ; i++){\\n        if(nums1[i] > nums1[i+1]){\\n            let temp = nums1[i + 1];\\n            nums1[i+1] = nums1[i];\\n            nums1[i] = temp\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1866862,
                "content": [
                    {
                        "username": "Tiago14",
                        "content": "why this only works in the console.log ?\n `\nvar merge = function(nums1, m, nums2, n) {\n     console.log([...Array.from({length: m}, (_,i) => nums1[i]), ...Array.from({length: n}, (_,i) => nums2[i])].sort((a,b) => a - b))\n     return [...Array.from({length: m}, (_,i) => nums1[i]), ...Array.from({length: n}, (_,i) => nums2[i])].sort((a,b) => a - b)\n     \n};\n`"
                    },
                    {
                        "username": "Tiago14",
                        "content": "what a shame, I do not have to return anything, the dumbest guy ever"
                    },
                    {
                        "username": "mythilikarra",
                        "content": "This question is rigged one of the test cases had nums1 = [0,0,3,0,0,0,0,0,0] but thats not sorted bruh"
                    },
                    {
                        "username": "Barry_Allen_14",
                        "content": "`def merge(nums1, m, nums2, n):\\n    nums1 = nums1[:m] + nums2[:n]\\n    nums1.sort()\\n\\na = [1, 2, 3, 0, 0, 0]\\nb = [2, 5, 6]\\nmerge(a, 3, b, 3)`\\n\\nAm i missing smth shouldn\\'t this simple code also run it works in pc but doesn\\'t work here."
                    },
                    {
                        "username": "CavalcanteLucas",
                        "content": "This site is clearly broken.\\n\\nI\\'m making\\n```\\nprint(nums1)\\n```\\nin the last line of the `merge` method, which prints\\n```\\n[1, 2, 2, 3, 5, 6]\\n```\\nin the stdout.\\n\\nHowever, the `Output` contains:\\n```\\n[1,2,3,0,0,0]\\n```\\n\\n"
                    },
                    {
                        "username": "santhoshkandhasamy98",
                        "content": "Hi , I am facing a issue,This is my code :\\n\\n        int i = n-1;\\n        int j = m-1; \\n        int k = i+j+1;\\n        if(i==0 && j==0)   k=0;\\n        while(j >= 0){\\n           // System.out.print(i+\"\"+j);\\n            if(i>=0 && nums1[i] > nums2[j])\\n            {\\n               nums1[k] = nums1[i];\\n               i--; k--; \\n            }else \\n            {\\n                nums1[k] = nums2[j];\\n                k--;j--;\\n            }\\n        }\\n\\nThe issue is even when j becomes -1 , still its getting inside while loop. Don\\'t know why. But the same code I tried in Eclipse its working perfectly. Can anyone help on this........ Pleaseeee"
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "is runtime depend on my pc specs ? or? cuz it is always different numbers "
                    },
                    {
                        "username": "Pavnesh-Silori",
                        "content": "all my testcases are passed tough getting runtime error, can anybody help\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0,j=0;\\n        while(i<n||j<m)\\n        {\\n            if(nums1[j]==0)\\n            {\\n                nums1[j]=nums2[i];\\n            i++;j++;\\n            }\\n            else{j++;}\\n        }\\n   \\n        \\n       \\n      sort(nums1.begin(),nums1.end());\\n        \\n    }\\n};\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9"
                    },
                    {
                        "username": "AureleWebDev",
                        "content": "Hi yall, \\n\\nWhy doesn\\'t this return me [ 1, 2, 2, 3, 5, 6 ] ?\\n\\n `\\nvar merge = function(nums1, m, nums2, n) {\\n\\n    if (!nums1 && !nums2) return [];\\n\\n    let firstNum = nums1.slice(0, m);\\n\\n    let secondNum = nums2.slice(0, n);\\n\\n    let result = firstNum.concat(secondNum).sort();\\n\\n    return result;\\n\\n};\\n`\\n\\nConsole.log(result) -> [ 1, 2, 2, 3, 5, 6 ]\\n\\nBut Output:\\n\\n[1,2,3,0,0,0]"
                    },
                    {
                        "username": "AureleWebDev",
                        "content": "Never mind I just saw that we have to modify nums1 and not return anything... This is a little bit lame for sure"
                    },
                    {
                        "username": "lraseemela",
                        "content": "I tested my code in IntelliJ and it works without any issues, but when I test it here with the same inputs, it says my answer is incorrect, and it shows a different output from what I am getting using IntelliJ....what is the issue?\\n"
                    },
                    {
                        "username": "mohitsood5934",
                        "content": "My Code is running correct for mentioned test cases in other compilers, don\\'t know why in leet code it is giving wromg answer\\n\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1 = [...nums1.splice(0,m),...nums2.splice(0,n)];\\n    for (i = 0 ; i < nums1.length ; i++){\\n        if(nums1[i] > nums1[i+1]){\\n            let temp = nums1[i + 1];\\n            nums1[i+1] = nums1[i];\\n            nums1[i] = temp\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1856438,
                "content": [
                    {
                        "username": "jatayuwu",
                        "content": "\n        ```if m == 0:\n            nums1 = nums2\n        elif n == 0:\n            return\n        else:\n            for i in range(m):\n                nums1[i+n], nums1[i] = nums1[i], nums1[i+n]\n            ins_head = 0\n            j = 0\n            i = m\n\n            while i < (m+n) and j < n:\n                if nums1[i] <= nums2[j]:\n                    nums1[ins_head] = nums1[i]\n                    i += 1\n                    ins_head += 1\n                else:\n                    nums1[ins_head] = nums2[j]\n                    j += 1\n                    ins_head += 1\n            while i < (m+n):\n                nums1[ins_head] = nums1[i]\n                i += 1\n                ins_head += 1```\n\ncan someone explain to me why this doesn't work for the third default test case, i set nums1 to be equal to nums2 if m = 0 and the value of nums1 is correct in the std output yet the testcase fails for some reason"
                    },
                    {
                        "username": "startupveteran",
                        "content": "Is it cheating if you use built in methods like \".sort\"?"
                    },
                    {
                        "username": "rakesh74",
                        "content": "Scala doesn\\'t support call by reference, so this cant be implemented. The the result should be return value. "
                    },
                    {
                        "username": "BillyThyCoderOFEatrth",
                        "content": "Hi, is this question solvable using nested loops/2 pointer approach.?"
                    },
                    {
                        "username": "philiprbaumann",
                        "content": "Non-decreasing order... why not just increasing??"
                    },
                    {
                        "username": "prathore28647",
                        "content": "A much simpler explanation to the problem given by ChatGPT:\\n\\nImagine you have two piles of toys. One pile has some red toys and the other pile has some blue toys. Now, you want to put all the toys together in a big pile, but you want to make sure that the toys are still sorted by their colors.\\n\\nTo do this, you take one toy from the red pile and one toy from the blue pile and put them in the big pile. If the red toy is bigger than the blue toy, you put the red toy in the big pile first. If the blue toy is bigger than the red toy, you put the blue toy in the big pile first.\\n\\nYou keep doing this until you have put all the toys in the big pile. If there are still some toys left in the blue pile, you just put them in the big pile without comparing them to any red toys.\\n\\nThis is kind of like what the code is doing. It takes two arrays of numbers that are already sorted, and puts them together into one big array that is also sorted. It does this by comparing the last number in each array, and putting the bigger number in the big array first. It keeps doing this until all the numbers are in the big array."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Hii Guys!! Check out my blog for the solution of this problem:\\nhttps://dsafordummies.digitalpress.blog/easy-array-leetcode-series-1/\\n\\nYou can also find two more easy level questions to test your skills in this particular blog! Thank you for supporting:)"
                    },
                    {
                        "username": "shayanth",
                        "content": "i already answered the problem but it doesn\\'t change the nums1 in-place, but when nums1 is printed it is the correct answer\\n\\n `def merge(self,nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = set(nums1)\\n        nums1 = list(nums1)\\n        print(\"nusm1: \",nums1)\\n        nums1 = set(nums1)\\n        nums1 = list(nums1)\\n        print(\"nusm2: \",nums2)\\n\\n        if 0 in nums1:\\n            nums1.remove(0)\\n        if 0 in nums2:\\n            nums2.remove(0)\\n\\n        nums1 = sorted(nums1 + nums2)\\n        print(\"nusm1: \",nums1)`"
                    },
                    {
                        "username": "carl-egge",
                        "content": "Hej everybody,\\nI\\'ve been trying to solve this problem in python3, but I seem to have a weird error.\\nMy code looks like this:\\n```\\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        i = 0\\n        j = 0\\n        while ((i < m) or (j < n)):\\n            if nums1[i] >= nums2[j] or i > m:\\n                nums1 = nums1[:i] + [nums2[j]] + nums1[i:-1]\\n                j += 1\\n            i += 1\\n        return None\\n```\\nFor some reason, the while loop continues even if the condition should evaluate to False, and then the code troughs an \\'list index out of range\\' error for the if statement. \\n\\nCan someone explain this behaviour?\\n\\nThanks already!"
                    },
                    {
                        "username": "nvinogr",
                        "content": "Can anyone help me understand what\\'s going on and why p2 gets incremented from `-1` to `0`?:\\n```java\\nint p1 = n - 1;\\nint p2 = m - 1;\\nfor (int i = n + m - 1; i >= 0; i--) {\\n    System.out.printf(\"%d %d%n\", p1, p2);\\n    nums1[i] = p2 < 0 || p1 >= 0 && nums1[p1] >= nums2[p2] \\n        ? nums1[p1--] \\n        : nums2[p2--];\\n}\\n```\\nI get the following exception:\\n```\\njava.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0\\n  at line 9, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n```\\nAnd stdout is:\\n```\\n2 2\\n2 1\\n2 0\\n1 0\\n0 0\\n0 -1\\n-1 0\\n```"
                    }
                ]
            },
            {
                "id": 1852640,
                "content": [
                    {
                        "username": "jatayuwu",
                        "content": "\n        ```if m == 0:\n            nums1 = nums2\n        elif n == 0:\n            return\n        else:\n            for i in range(m):\n                nums1[i+n], nums1[i] = nums1[i], nums1[i+n]\n            ins_head = 0\n            j = 0\n            i = m\n\n            while i < (m+n) and j < n:\n                if nums1[i] <= nums2[j]:\n                    nums1[ins_head] = nums1[i]\n                    i += 1\n                    ins_head += 1\n                else:\n                    nums1[ins_head] = nums2[j]\n                    j += 1\n                    ins_head += 1\n            while i < (m+n):\n                nums1[ins_head] = nums1[i]\n                i += 1\n                ins_head += 1```\n\ncan someone explain to me why this doesn't work for the third default test case, i set nums1 to be equal to nums2 if m = 0 and the value of nums1 is correct in the std output yet the testcase fails for some reason"
                    },
                    {
                        "username": "startupveteran",
                        "content": "Is it cheating if you use built in methods like \".sort\"?"
                    },
                    {
                        "username": "rakesh74",
                        "content": "Scala doesn\\'t support call by reference, so this cant be implemented. The the result should be return value. "
                    },
                    {
                        "username": "BillyThyCoderOFEatrth",
                        "content": "Hi, is this question solvable using nested loops/2 pointer approach.?"
                    },
                    {
                        "username": "philiprbaumann",
                        "content": "Non-decreasing order... why not just increasing??"
                    },
                    {
                        "username": "prathore28647",
                        "content": "A much simpler explanation to the problem given by ChatGPT:\\n\\nImagine you have two piles of toys. One pile has some red toys and the other pile has some blue toys. Now, you want to put all the toys together in a big pile, but you want to make sure that the toys are still sorted by their colors.\\n\\nTo do this, you take one toy from the red pile and one toy from the blue pile and put them in the big pile. If the red toy is bigger than the blue toy, you put the red toy in the big pile first. If the blue toy is bigger than the red toy, you put the blue toy in the big pile first.\\n\\nYou keep doing this until you have put all the toys in the big pile. If there are still some toys left in the blue pile, you just put them in the big pile without comparing them to any red toys.\\n\\nThis is kind of like what the code is doing. It takes two arrays of numbers that are already sorted, and puts them together into one big array that is also sorted. It does this by comparing the last number in each array, and putting the bigger number in the big array first. It keeps doing this until all the numbers are in the big array."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Hii Guys!! Check out my blog for the solution of this problem:\\nhttps://dsafordummies.digitalpress.blog/easy-array-leetcode-series-1/\\n\\nYou can also find two more easy level questions to test your skills in this particular blog! Thank you for supporting:)"
                    },
                    {
                        "username": "shayanth",
                        "content": "i already answered the problem but it doesn\\'t change the nums1 in-place, but when nums1 is printed it is the correct answer\\n\\n `def merge(self,nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = set(nums1)\\n        nums1 = list(nums1)\\n        print(\"nusm1: \",nums1)\\n        nums1 = set(nums1)\\n        nums1 = list(nums1)\\n        print(\"nusm2: \",nums2)\\n\\n        if 0 in nums1:\\n            nums1.remove(0)\\n        if 0 in nums2:\\n            nums2.remove(0)\\n\\n        nums1 = sorted(nums1 + nums2)\\n        print(\"nusm1: \",nums1)`"
                    },
                    {
                        "username": "carl-egge",
                        "content": "Hej everybody,\\nI\\'ve been trying to solve this problem in python3, but I seem to have a weird error.\\nMy code looks like this:\\n```\\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        i = 0\\n        j = 0\\n        while ((i < m) or (j < n)):\\n            if nums1[i] >= nums2[j] or i > m:\\n                nums1 = nums1[:i] + [nums2[j]] + nums1[i:-1]\\n                j += 1\\n            i += 1\\n        return None\\n```\\nFor some reason, the while loop continues even if the condition should evaluate to False, and then the code troughs an \\'list index out of range\\' error for the if statement. \\n\\nCan someone explain this behaviour?\\n\\nThanks already!"
                    },
                    {
                        "username": "nvinogr",
                        "content": "Can anyone help me understand what\\'s going on and why p2 gets incremented from `-1` to `0`?:\\n```java\\nint p1 = n - 1;\\nint p2 = m - 1;\\nfor (int i = n + m - 1; i >= 0; i--) {\\n    System.out.printf(\"%d %d%n\", p1, p2);\\n    nums1[i] = p2 < 0 || p1 >= 0 && nums1[p1] >= nums2[p2] \\n        ? nums1[p1--] \\n        : nums2[p2--];\\n}\\n```\\nI get the following exception:\\n```\\njava.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0\\n  at line 9, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n```\\nAnd stdout is:\\n```\\n2 2\\n2 1\\n2 0\\n1 0\\n0 0\\n0 -1\\n-1 0\\n```"
                    }
                ]
            },
            {
                "id": 1847422,
                "content": [
                    {
                        "username": "jatayuwu",
                        "content": "\n        ```if m == 0:\n            nums1 = nums2\n        elif n == 0:\n            return\n        else:\n            for i in range(m):\n                nums1[i+n], nums1[i] = nums1[i], nums1[i+n]\n            ins_head = 0\n            j = 0\n            i = m\n\n            while i < (m+n) and j < n:\n                if nums1[i] <= nums2[j]:\n                    nums1[ins_head] = nums1[i]\n                    i += 1\n                    ins_head += 1\n                else:\n                    nums1[ins_head] = nums2[j]\n                    j += 1\n                    ins_head += 1\n            while i < (m+n):\n                nums1[ins_head] = nums1[i]\n                i += 1\n                ins_head += 1```\n\ncan someone explain to me why this doesn't work for the third default test case, i set nums1 to be equal to nums2 if m = 0 and the value of nums1 is correct in the std output yet the testcase fails for some reason"
                    },
                    {
                        "username": "startupveteran",
                        "content": "Is it cheating if you use built in methods like \".sort\"?"
                    },
                    {
                        "username": "rakesh74",
                        "content": "Scala doesn\\'t support call by reference, so this cant be implemented. The the result should be return value. "
                    },
                    {
                        "username": "BillyThyCoderOFEatrth",
                        "content": "Hi, is this question solvable using nested loops/2 pointer approach.?"
                    },
                    {
                        "username": "philiprbaumann",
                        "content": "Non-decreasing order... why not just increasing??"
                    },
                    {
                        "username": "prathore28647",
                        "content": "A much simpler explanation to the problem given by ChatGPT:\\n\\nImagine you have two piles of toys. One pile has some red toys and the other pile has some blue toys. Now, you want to put all the toys together in a big pile, but you want to make sure that the toys are still sorted by their colors.\\n\\nTo do this, you take one toy from the red pile and one toy from the blue pile and put them in the big pile. If the red toy is bigger than the blue toy, you put the red toy in the big pile first. If the blue toy is bigger than the red toy, you put the blue toy in the big pile first.\\n\\nYou keep doing this until you have put all the toys in the big pile. If there are still some toys left in the blue pile, you just put them in the big pile without comparing them to any red toys.\\n\\nThis is kind of like what the code is doing. It takes two arrays of numbers that are already sorted, and puts them together into one big array that is also sorted. It does this by comparing the last number in each array, and putting the bigger number in the big array first. It keeps doing this until all the numbers are in the big array."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Hii Guys!! Check out my blog for the solution of this problem:\\nhttps://dsafordummies.digitalpress.blog/easy-array-leetcode-series-1/\\n\\nYou can also find two more easy level questions to test your skills in this particular blog! Thank you for supporting:)"
                    },
                    {
                        "username": "shayanth",
                        "content": "i already answered the problem but it doesn\\'t change the nums1 in-place, but when nums1 is printed it is the correct answer\\n\\n `def merge(self,nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = set(nums1)\\n        nums1 = list(nums1)\\n        print(\"nusm1: \",nums1)\\n        nums1 = set(nums1)\\n        nums1 = list(nums1)\\n        print(\"nusm2: \",nums2)\\n\\n        if 0 in nums1:\\n            nums1.remove(0)\\n        if 0 in nums2:\\n            nums2.remove(0)\\n\\n        nums1 = sorted(nums1 + nums2)\\n        print(\"nusm1: \",nums1)`"
                    },
                    {
                        "username": "carl-egge",
                        "content": "Hej everybody,\\nI\\'ve been trying to solve this problem in python3, but I seem to have a weird error.\\nMy code looks like this:\\n```\\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        i = 0\\n        j = 0\\n        while ((i < m) or (j < n)):\\n            if nums1[i] >= nums2[j] or i > m:\\n                nums1 = nums1[:i] + [nums2[j]] + nums1[i:-1]\\n                j += 1\\n            i += 1\\n        return None\\n```\\nFor some reason, the while loop continues even if the condition should evaluate to False, and then the code troughs an \\'list index out of range\\' error for the if statement. \\n\\nCan someone explain this behaviour?\\n\\nThanks already!"
                    },
                    {
                        "username": "nvinogr",
                        "content": "Can anyone help me understand what\\'s going on and why p2 gets incremented from `-1` to `0`?:\\n```java\\nint p1 = n - 1;\\nint p2 = m - 1;\\nfor (int i = n + m - 1; i >= 0; i--) {\\n    System.out.printf(\"%d %d%n\", p1, p2);\\n    nums1[i] = p2 < 0 || p1 >= 0 && nums1[p1] >= nums2[p2] \\n        ? nums1[p1--] \\n        : nums2[p2--];\\n}\\n```\\nI get the following exception:\\n```\\njava.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0\\n  at line 9, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n```\\nAnd stdout is:\\n```\\n2 2\\n2 1\\n2 0\\n1 0\\n0 0\\n0 -1\\n-1 0\\n```"
                    }
                ]
            },
            {
                "id": 1845496,
                "content": [
                    {
                        "username": "jatayuwu",
                        "content": "\n        ```if m == 0:\n            nums1 = nums2\n        elif n == 0:\n            return\n        else:\n            for i in range(m):\n                nums1[i+n], nums1[i] = nums1[i], nums1[i+n]\n            ins_head = 0\n            j = 0\n            i = m\n\n            while i < (m+n) and j < n:\n                if nums1[i] <= nums2[j]:\n                    nums1[ins_head] = nums1[i]\n                    i += 1\n                    ins_head += 1\n                else:\n                    nums1[ins_head] = nums2[j]\n                    j += 1\n                    ins_head += 1\n            while i < (m+n):\n                nums1[ins_head] = nums1[i]\n                i += 1\n                ins_head += 1```\n\ncan someone explain to me why this doesn't work for the third default test case, i set nums1 to be equal to nums2 if m = 0 and the value of nums1 is correct in the std output yet the testcase fails for some reason"
                    },
                    {
                        "username": "startupveteran",
                        "content": "Is it cheating if you use built in methods like \".sort\"?"
                    },
                    {
                        "username": "rakesh74",
                        "content": "Scala doesn\\'t support call by reference, so this cant be implemented. The the result should be return value. "
                    },
                    {
                        "username": "BillyThyCoderOFEatrth",
                        "content": "Hi, is this question solvable using nested loops/2 pointer approach.?"
                    },
                    {
                        "username": "philiprbaumann",
                        "content": "Non-decreasing order... why not just increasing??"
                    },
                    {
                        "username": "prathore28647",
                        "content": "A much simpler explanation to the problem given by ChatGPT:\\n\\nImagine you have two piles of toys. One pile has some red toys and the other pile has some blue toys. Now, you want to put all the toys together in a big pile, but you want to make sure that the toys are still sorted by their colors.\\n\\nTo do this, you take one toy from the red pile and one toy from the blue pile and put them in the big pile. If the red toy is bigger than the blue toy, you put the red toy in the big pile first. If the blue toy is bigger than the red toy, you put the blue toy in the big pile first.\\n\\nYou keep doing this until you have put all the toys in the big pile. If there are still some toys left in the blue pile, you just put them in the big pile without comparing them to any red toys.\\n\\nThis is kind of like what the code is doing. It takes two arrays of numbers that are already sorted, and puts them together into one big array that is also sorted. It does this by comparing the last number in each array, and putting the bigger number in the big array first. It keeps doing this until all the numbers are in the big array."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Hii Guys!! Check out my blog for the solution of this problem:\\nhttps://dsafordummies.digitalpress.blog/easy-array-leetcode-series-1/\\n\\nYou can also find two more easy level questions to test your skills in this particular blog! Thank you for supporting:)"
                    },
                    {
                        "username": "shayanth",
                        "content": "i already answered the problem but it doesn\\'t change the nums1 in-place, but when nums1 is printed it is the correct answer\\n\\n `def merge(self,nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = set(nums1)\\n        nums1 = list(nums1)\\n        print(\"nusm1: \",nums1)\\n        nums1 = set(nums1)\\n        nums1 = list(nums1)\\n        print(\"nusm2: \",nums2)\\n\\n        if 0 in nums1:\\n            nums1.remove(0)\\n        if 0 in nums2:\\n            nums2.remove(0)\\n\\n        nums1 = sorted(nums1 + nums2)\\n        print(\"nusm1: \",nums1)`"
                    },
                    {
                        "username": "carl-egge",
                        "content": "Hej everybody,\\nI\\'ve been trying to solve this problem in python3, but I seem to have a weird error.\\nMy code looks like this:\\n```\\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        i = 0\\n        j = 0\\n        while ((i < m) or (j < n)):\\n            if nums1[i] >= nums2[j] or i > m:\\n                nums1 = nums1[:i] + [nums2[j]] + nums1[i:-1]\\n                j += 1\\n            i += 1\\n        return None\\n```\\nFor some reason, the while loop continues even if the condition should evaluate to False, and then the code troughs an \\'list index out of range\\' error for the if statement. \\n\\nCan someone explain this behaviour?\\n\\nThanks already!"
                    },
                    {
                        "username": "nvinogr",
                        "content": "Can anyone help me understand what\\'s going on and why p2 gets incremented from `-1` to `0`?:\\n```java\\nint p1 = n - 1;\\nint p2 = m - 1;\\nfor (int i = n + m - 1; i >= 0; i--) {\\n    System.out.printf(\"%d %d%n\", p1, p2);\\n    nums1[i] = p2 < 0 || p1 >= 0 && nums1[p1] >= nums2[p2] \\n        ? nums1[p1--] \\n        : nums2[p2--];\\n}\\n```\\nI get the following exception:\\n```\\njava.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0\\n  at line 9, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n```\\nAnd stdout is:\\n```\\n2 2\\n2 1\\n2 0\\n1 0\\n0 0\\n0 -1\\n-1 0\\n```"
                    }
                ]
            },
            {
                "id": 1844730,
                "content": [
                    {
                        "username": "jatayuwu",
                        "content": "\n        ```if m == 0:\n            nums1 = nums2\n        elif n == 0:\n            return\n        else:\n            for i in range(m):\n                nums1[i+n], nums1[i] = nums1[i], nums1[i+n]\n            ins_head = 0\n            j = 0\n            i = m\n\n            while i < (m+n) and j < n:\n                if nums1[i] <= nums2[j]:\n                    nums1[ins_head] = nums1[i]\n                    i += 1\n                    ins_head += 1\n                else:\n                    nums1[ins_head] = nums2[j]\n                    j += 1\n                    ins_head += 1\n            while i < (m+n):\n                nums1[ins_head] = nums1[i]\n                i += 1\n                ins_head += 1```\n\ncan someone explain to me why this doesn't work for the third default test case, i set nums1 to be equal to nums2 if m = 0 and the value of nums1 is correct in the std output yet the testcase fails for some reason"
                    },
                    {
                        "username": "startupveteran",
                        "content": "Is it cheating if you use built in methods like \".sort\"?"
                    },
                    {
                        "username": "rakesh74",
                        "content": "Scala doesn\\'t support call by reference, so this cant be implemented. The the result should be return value. "
                    },
                    {
                        "username": "BillyThyCoderOFEatrth",
                        "content": "Hi, is this question solvable using nested loops/2 pointer approach.?"
                    },
                    {
                        "username": "philiprbaumann",
                        "content": "Non-decreasing order... why not just increasing??"
                    },
                    {
                        "username": "prathore28647",
                        "content": "A much simpler explanation to the problem given by ChatGPT:\\n\\nImagine you have two piles of toys. One pile has some red toys and the other pile has some blue toys. Now, you want to put all the toys together in a big pile, but you want to make sure that the toys are still sorted by their colors.\\n\\nTo do this, you take one toy from the red pile and one toy from the blue pile and put them in the big pile. If the red toy is bigger than the blue toy, you put the red toy in the big pile first. If the blue toy is bigger than the red toy, you put the blue toy in the big pile first.\\n\\nYou keep doing this until you have put all the toys in the big pile. If there are still some toys left in the blue pile, you just put them in the big pile without comparing them to any red toys.\\n\\nThis is kind of like what the code is doing. It takes two arrays of numbers that are already sorted, and puts them together into one big array that is also sorted. It does this by comparing the last number in each array, and putting the bigger number in the big array first. It keeps doing this until all the numbers are in the big array."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Hii Guys!! Check out my blog for the solution of this problem:\\nhttps://dsafordummies.digitalpress.blog/easy-array-leetcode-series-1/\\n\\nYou can also find two more easy level questions to test your skills in this particular blog! Thank you for supporting:)"
                    },
                    {
                        "username": "shayanth",
                        "content": "i already answered the problem but it doesn\\'t change the nums1 in-place, but when nums1 is printed it is the correct answer\\n\\n `def merge(self,nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = set(nums1)\\n        nums1 = list(nums1)\\n        print(\"nusm1: \",nums1)\\n        nums1 = set(nums1)\\n        nums1 = list(nums1)\\n        print(\"nusm2: \",nums2)\\n\\n        if 0 in nums1:\\n            nums1.remove(0)\\n        if 0 in nums2:\\n            nums2.remove(0)\\n\\n        nums1 = sorted(nums1 + nums2)\\n        print(\"nusm1: \",nums1)`"
                    },
                    {
                        "username": "carl-egge",
                        "content": "Hej everybody,\\nI\\'ve been trying to solve this problem in python3, but I seem to have a weird error.\\nMy code looks like this:\\n```\\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        i = 0\\n        j = 0\\n        while ((i < m) or (j < n)):\\n            if nums1[i] >= nums2[j] or i > m:\\n                nums1 = nums1[:i] + [nums2[j]] + nums1[i:-1]\\n                j += 1\\n            i += 1\\n        return None\\n```\\nFor some reason, the while loop continues even if the condition should evaluate to False, and then the code troughs an \\'list index out of range\\' error for the if statement. \\n\\nCan someone explain this behaviour?\\n\\nThanks already!"
                    },
                    {
                        "username": "nvinogr",
                        "content": "Can anyone help me understand what\\'s going on and why p2 gets incremented from `-1` to `0`?:\\n```java\\nint p1 = n - 1;\\nint p2 = m - 1;\\nfor (int i = n + m - 1; i >= 0; i--) {\\n    System.out.printf(\"%d %d%n\", p1, p2);\\n    nums1[i] = p2 < 0 || p1 >= 0 && nums1[p1] >= nums2[p2] \\n        ? nums1[p1--] \\n        : nums2[p2--];\\n}\\n```\\nI get the following exception:\\n```\\njava.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0\\n  at line 9, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n```\\nAnd stdout is:\\n```\\n2 2\\n2 1\\n2 0\\n1 0\\n0 0\\n0 -1\\n-1 0\\n```"
                    }
                ]
            },
            {
                "id": 1843482,
                "content": [
                    {
                        "username": "jatayuwu",
                        "content": "\n        ```if m == 0:\n            nums1 = nums2\n        elif n == 0:\n            return\n        else:\n            for i in range(m):\n                nums1[i+n], nums1[i] = nums1[i], nums1[i+n]\n            ins_head = 0\n            j = 0\n            i = m\n\n            while i < (m+n) and j < n:\n                if nums1[i] <= nums2[j]:\n                    nums1[ins_head] = nums1[i]\n                    i += 1\n                    ins_head += 1\n                else:\n                    nums1[ins_head] = nums2[j]\n                    j += 1\n                    ins_head += 1\n            while i < (m+n):\n                nums1[ins_head] = nums1[i]\n                i += 1\n                ins_head += 1```\n\ncan someone explain to me why this doesn't work for the third default test case, i set nums1 to be equal to nums2 if m = 0 and the value of nums1 is correct in the std output yet the testcase fails for some reason"
                    },
                    {
                        "username": "startupveteran",
                        "content": "Is it cheating if you use built in methods like \".sort\"?"
                    },
                    {
                        "username": "rakesh74",
                        "content": "Scala doesn\\'t support call by reference, so this cant be implemented. The the result should be return value. "
                    },
                    {
                        "username": "BillyThyCoderOFEatrth",
                        "content": "Hi, is this question solvable using nested loops/2 pointer approach.?"
                    },
                    {
                        "username": "philiprbaumann",
                        "content": "Non-decreasing order... why not just increasing??"
                    },
                    {
                        "username": "prathore28647",
                        "content": "A much simpler explanation to the problem given by ChatGPT:\\n\\nImagine you have two piles of toys. One pile has some red toys and the other pile has some blue toys. Now, you want to put all the toys together in a big pile, but you want to make sure that the toys are still sorted by their colors.\\n\\nTo do this, you take one toy from the red pile and one toy from the blue pile and put them in the big pile. If the red toy is bigger than the blue toy, you put the red toy in the big pile first. If the blue toy is bigger than the red toy, you put the blue toy in the big pile first.\\n\\nYou keep doing this until you have put all the toys in the big pile. If there are still some toys left in the blue pile, you just put them in the big pile without comparing them to any red toys.\\n\\nThis is kind of like what the code is doing. It takes two arrays of numbers that are already sorted, and puts them together into one big array that is also sorted. It does this by comparing the last number in each array, and putting the bigger number in the big array first. It keeps doing this until all the numbers are in the big array."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Hii Guys!! Check out my blog for the solution of this problem:\\nhttps://dsafordummies.digitalpress.blog/easy-array-leetcode-series-1/\\n\\nYou can also find two more easy level questions to test your skills in this particular blog! Thank you for supporting:)"
                    },
                    {
                        "username": "shayanth",
                        "content": "i already answered the problem but it doesn\\'t change the nums1 in-place, but when nums1 is printed it is the correct answer\\n\\n `def merge(self,nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = set(nums1)\\n        nums1 = list(nums1)\\n        print(\"nusm1: \",nums1)\\n        nums1 = set(nums1)\\n        nums1 = list(nums1)\\n        print(\"nusm2: \",nums2)\\n\\n        if 0 in nums1:\\n            nums1.remove(0)\\n        if 0 in nums2:\\n            nums2.remove(0)\\n\\n        nums1 = sorted(nums1 + nums2)\\n        print(\"nusm1: \",nums1)`"
                    },
                    {
                        "username": "carl-egge",
                        "content": "Hej everybody,\\nI\\'ve been trying to solve this problem in python3, but I seem to have a weird error.\\nMy code looks like this:\\n```\\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        i = 0\\n        j = 0\\n        while ((i < m) or (j < n)):\\n            if nums1[i] >= nums2[j] or i > m:\\n                nums1 = nums1[:i] + [nums2[j]] + nums1[i:-1]\\n                j += 1\\n            i += 1\\n        return None\\n```\\nFor some reason, the while loop continues even if the condition should evaluate to False, and then the code troughs an \\'list index out of range\\' error for the if statement. \\n\\nCan someone explain this behaviour?\\n\\nThanks already!"
                    },
                    {
                        "username": "nvinogr",
                        "content": "Can anyone help me understand what\\'s going on and why p2 gets incremented from `-1` to `0`?:\\n```java\\nint p1 = n - 1;\\nint p2 = m - 1;\\nfor (int i = n + m - 1; i >= 0; i--) {\\n    System.out.printf(\"%d %d%n\", p1, p2);\\n    nums1[i] = p2 < 0 || p1 >= 0 && nums1[p1] >= nums2[p2] \\n        ? nums1[p1--] \\n        : nums2[p2--];\\n}\\n```\\nI get the following exception:\\n```\\njava.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0\\n  at line 9, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n```\\nAnd stdout is:\\n```\\n2 2\\n2 1\\n2 0\\n1 0\\n0 0\\n0 -1\\n-1 0\\n```"
                    }
                ]
            },
            {
                "id": 1843262,
                "content": [
                    {
                        "username": "jatayuwu",
                        "content": "\n        ```if m == 0:\n            nums1 = nums2\n        elif n == 0:\n            return\n        else:\n            for i in range(m):\n                nums1[i+n], nums1[i] = nums1[i], nums1[i+n]\n            ins_head = 0\n            j = 0\n            i = m\n\n            while i < (m+n) and j < n:\n                if nums1[i] <= nums2[j]:\n                    nums1[ins_head] = nums1[i]\n                    i += 1\n                    ins_head += 1\n                else:\n                    nums1[ins_head] = nums2[j]\n                    j += 1\n                    ins_head += 1\n            while i < (m+n):\n                nums1[ins_head] = nums1[i]\n                i += 1\n                ins_head += 1```\n\ncan someone explain to me why this doesn't work for the third default test case, i set nums1 to be equal to nums2 if m = 0 and the value of nums1 is correct in the std output yet the testcase fails for some reason"
                    },
                    {
                        "username": "startupveteran",
                        "content": "Is it cheating if you use built in methods like \".sort\"?"
                    },
                    {
                        "username": "rakesh74",
                        "content": "Scala doesn\\'t support call by reference, so this cant be implemented. The the result should be return value. "
                    },
                    {
                        "username": "BillyThyCoderOFEatrth",
                        "content": "Hi, is this question solvable using nested loops/2 pointer approach.?"
                    },
                    {
                        "username": "philiprbaumann",
                        "content": "Non-decreasing order... why not just increasing??"
                    },
                    {
                        "username": "prathore28647",
                        "content": "A much simpler explanation to the problem given by ChatGPT:\\n\\nImagine you have two piles of toys. One pile has some red toys and the other pile has some blue toys. Now, you want to put all the toys together in a big pile, but you want to make sure that the toys are still sorted by their colors.\\n\\nTo do this, you take one toy from the red pile and one toy from the blue pile and put them in the big pile. If the red toy is bigger than the blue toy, you put the red toy in the big pile first. If the blue toy is bigger than the red toy, you put the blue toy in the big pile first.\\n\\nYou keep doing this until you have put all the toys in the big pile. If there are still some toys left in the blue pile, you just put them in the big pile without comparing them to any red toys.\\n\\nThis is kind of like what the code is doing. It takes two arrays of numbers that are already sorted, and puts them together into one big array that is also sorted. It does this by comparing the last number in each array, and putting the bigger number in the big array first. It keeps doing this until all the numbers are in the big array."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Hii Guys!! Check out my blog for the solution of this problem:\\nhttps://dsafordummies.digitalpress.blog/easy-array-leetcode-series-1/\\n\\nYou can also find two more easy level questions to test your skills in this particular blog! Thank you for supporting:)"
                    },
                    {
                        "username": "shayanth",
                        "content": "i already answered the problem but it doesn\\'t change the nums1 in-place, but when nums1 is printed it is the correct answer\\n\\n `def merge(self,nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = set(nums1)\\n        nums1 = list(nums1)\\n        print(\"nusm1: \",nums1)\\n        nums1 = set(nums1)\\n        nums1 = list(nums1)\\n        print(\"nusm2: \",nums2)\\n\\n        if 0 in nums1:\\n            nums1.remove(0)\\n        if 0 in nums2:\\n            nums2.remove(0)\\n\\n        nums1 = sorted(nums1 + nums2)\\n        print(\"nusm1: \",nums1)`"
                    },
                    {
                        "username": "carl-egge",
                        "content": "Hej everybody,\\nI\\'ve been trying to solve this problem in python3, but I seem to have a weird error.\\nMy code looks like this:\\n```\\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        i = 0\\n        j = 0\\n        while ((i < m) or (j < n)):\\n            if nums1[i] >= nums2[j] or i > m:\\n                nums1 = nums1[:i] + [nums2[j]] + nums1[i:-1]\\n                j += 1\\n            i += 1\\n        return None\\n```\\nFor some reason, the while loop continues even if the condition should evaluate to False, and then the code troughs an \\'list index out of range\\' error for the if statement. \\n\\nCan someone explain this behaviour?\\n\\nThanks already!"
                    },
                    {
                        "username": "nvinogr",
                        "content": "Can anyone help me understand what\\'s going on and why p2 gets incremented from `-1` to `0`?:\\n```java\\nint p1 = n - 1;\\nint p2 = m - 1;\\nfor (int i = n + m - 1; i >= 0; i--) {\\n    System.out.printf(\"%d %d%n\", p1, p2);\\n    nums1[i] = p2 < 0 || p1 >= 0 && nums1[p1] >= nums2[p2] \\n        ? nums1[p1--] \\n        : nums2[p2--];\\n}\\n```\\nI get the following exception:\\n```\\njava.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0\\n  at line 9, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n```\\nAnd stdout is:\\n```\\n2 2\\n2 1\\n2 0\\n1 0\\n0 0\\n0 -1\\n-1 0\\n```"
                    }
                ]
            },
            {
                "id": 1834264,
                "content": [
                    {
                        "username": "jatayuwu",
                        "content": "\n        ```if m == 0:\n            nums1 = nums2\n        elif n == 0:\n            return\n        else:\n            for i in range(m):\n                nums1[i+n], nums1[i] = nums1[i], nums1[i+n]\n            ins_head = 0\n            j = 0\n            i = m\n\n            while i < (m+n) and j < n:\n                if nums1[i] <= nums2[j]:\n                    nums1[ins_head] = nums1[i]\n                    i += 1\n                    ins_head += 1\n                else:\n                    nums1[ins_head] = nums2[j]\n                    j += 1\n                    ins_head += 1\n            while i < (m+n):\n                nums1[ins_head] = nums1[i]\n                i += 1\n                ins_head += 1```\n\ncan someone explain to me why this doesn't work for the third default test case, i set nums1 to be equal to nums2 if m = 0 and the value of nums1 is correct in the std output yet the testcase fails for some reason"
                    },
                    {
                        "username": "startupveteran",
                        "content": "Is it cheating if you use built in methods like \".sort\"?"
                    },
                    {
                        "username": "rakesh74",
                        "content": "Scala doesn\\'t support call by reference, so this cant be implemented. The the result should be return value. "
                    },
                    {
                        "username": "BillyThyCoderOFEatrth",
                        "content": "Hi, is this question solvable using nested loops/2 pointer approach.?"
                    },
                    {
                        "username": "philiprbaumann",
                        "content": "Non-decreasing order... why not just increasing??"
                    },
                    {
                        "username": "prathore28647",
                        "content": "A much simpler explanation to the problem given by ChatGPT:\\n\\nImagine you have two piles of toys. One pile has some red toys and the other pile has some blue toys. Now, you want to put all the toys together in a big pile, but you want to make sure that the toys are still sorted by their colors.\\n\\nTo do this, you take one toy from the red pile and one toy from the blue pile and put them in the big pile. If the red toy is bigger than the blue toy, you put the red toy in the big pile first. If the blue toy is bigger than the red toy, you put the blue toy in the big pile first.\\n\\nYou keep doing this until you have put all the toys in the big pile. If there are still some toys left in the blue pile, you just put them in the big pile without comparing them to any red toys.\\n\\nThis is kind of like what the code is doing. It takes two arrays of numbers that are already sorted, and puts them together into one big array that is also sorted. It does this by comparing the last number in each array, and putting the bigger number in the big array first. It keeps doing this until all the numbers are in the big array."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Hii Guys!! Check out my blog for the solution of this problem:\\nhttps://dsafordummies.digitalpress.blog/easy-array-leetcode-series-1/\\n\\nYou can also find two more easy level questions to test your skills in this particular blog! Thank you for supporting:)"
                    },
                    {
                        "username": "shayanth",
                        "content": "i already answered the problem but it doesn\\'t change the nums1 in-place, but when nums1 is printed it is the correct answer\\n\\n `def merge(self,nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = set(nums1)\\n        nums1 = list(nums1)\\n        print(\"nusm1: \",nums1)\\n        nums1 = set(nums1)\\n        nums1 = list(nums1)\\n        print(\"nusm2: \",nums2)\\n\\n        if 0 in nums1:\\n            nums1.remove(0)\\n        if 0 in nums2:\\n            nums2.remove(0)\\n\\n        nums1 = sorted(nums1 + nums2)\\n        print(\"nusm1: \",nums1)`"
                    },
                    {
                        "username": "carl-egge",
                        "content": "Hej everybody,\\nI\\'ve been trying to solve this problem in python3, but I seem to have a weird error.\\nMy code looks like this:\\n```\\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        i = 0\\n        j = 0\\n        while ((i < m) or (j < n)):\\n            if nums1[i] >= nums2[j] or i > m:\\n                nums1 = nums1[:i] + [nums2[j]] + nums1[i:-1]\\n                j += 1\\n            i += 1\\n        return None\\n```\\nFor some reason, the while loop continues even if the condition should evaluate to False, and then the code troughs an \\'list index out of range\\' error for the if statement. \\n\\nCan someone explain this behaviour?\\n\\nThanks already!"
                    },
                    {
                        "username": "nvinogr",
                        "content": "Can anyone help me understand what\\'s going on and why p2 gets incremented from `-1` to `0`?:\\n```java\\nint p1 = n - 1;\\nint p2 = m - 1;\\nfor (int i = n + m - 1; i >= 0; i--) {\\n    System.out.printf(\"%d %d%n\", p1, p2);\\n    nums1[i] = p2 < 0 || p1 >= 0 && nums1[p1] >= nums2[p2] \\n        ? nums1[p1--] \\n        : nums2[p2--];\\n}\\n```\\nI get the following exception:\\n```\\njava.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0\\n  at line 9, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n```\\nAnd stdout is:\\n```\\n2 2\\n2 1\\n2 0\\n1 0\\n0 0\\n0 -1\\n-1 0\\n```"
                    }
                ]
            },
            {
                "id": 1833182,
                "content": [
                    {
                        "username": "jatayuwu",
                        "content": "\n        ```if m == 0:\n            nums1 = nums2\n        elif n == 0:\n            return\n        else:\n            for i in range(m):\n                nums1[i+n], nums1[i] = nums1[i], nums1[i+n]\n            ins_head = 0\n            j = 0\n            i = m\n\n            while i < (m+n) and j < n:\n                if nums1[i] <= nums2[j]:\n                    nums1[ins_head] = nums1[i]\n                    i += 1\n                    ins_head += 1\n                else:\n                    nums1[ins_head] = nums2[j]\n                    j += 1\n                    ins_head += 1\n            while i < (m+n):\n                nums1[ins_head] = nums1[i]\n                i += 1\n                ins_head += 1```\n\ncan someone explain to me why this doesn't work for the third default test case, i set nums1 to be equal to nums2 if m = 0 and the value of nums1 is correct in the std output yet the testcase fails for some reason"
                    },
                    {
                        "username": "startupveteran",
                        "content": "Is it cheating if you use built in methods like \".sort\"?"
                    },
                    {
                        "username": "rakesh74",
                        "content": "Scala doesn\\'t support call by reference, so this cant be implemented. The the result should be return value. "
                    },
                    {
                        "username": "BillyThyCoderOFEatrth",
                        "content": "Hi, is this question solvable using nested loops/2 pointer approach.?"
                    },
                    {
                        "username": "philiprbaumann",
                        "content": "Non-decreasing order... why not just increasing??"
                    },
                    {
                        "username": "prathore28647",
                        "content": "A much simpler explanation to the problem given by ChatGPT:\\n\\nImagine you have two piles of toys. One pile has some red toys and the other pile has some blue toys. Now, you want to put all the toys together in a big pile, but you want to make sure that the toys are still sorted by their colors.\\n\\nTo do this, you take one toy from the red pile and one toy from the blue pile and put them in the big pile. If the red toy is bigger than the blue toy, you put the red toy in the big pile first. If the blue toy is bigger than the red toy, you put the blue toy in the big pile first.\\n\\nYou keep doing this until you have put all the toys in the big pile. If there are still some toys left in the blue pile, you just put them in the big pile without comparing them to any red toys.\\n\\nThis is kind of like what the code is doing. It takes two arrays of numbers that are already sorted, and puts them together into one big array that is also sorted. It does this by comparing the last number in each array, and putting the bigger number in the big array first. It keeps doing this until all the numbers are in the big array."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Hii Guys!! Check out my blog for the solution of this problem:\\nhttps://dsafordummies.digitalpress.blog/easy-array-leetcode-series-1/\\n\\nYou can also find two more easy level questions to test your skills in this particular blog! Thank you for supporting:)"
                    },
                    {
                        "username": "shayanth",
                        "content": "i already answered the problem but it doesn\\'t change the nums1 in-place, but when nums1 is printed it is the correct answer\\n\\n `def merge(self,nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = set(nums1)\\n        nums1 = list(nums1)\\n        print(\"nusm1: \",nums1)\\n        nums1 = set(nums1)\\n        nums1 = list(nums1)\\n        print(\"nusm2: \",nums2)\\n\\n        if 0 in nums1:\\n            nums1.remove(0)\\n        if 0 in nums2:\\n            nums2.remove(0)\\n\\n        nums1 = sorted(nums1 + nums2)\\n        print(\"nusm1: \",nums1)`"
                    },
                    {
                        "username": "carl-egge",
                        "content": "Hej everybody,\\nI\\'ve been trying to solve this problem in python3, but I seem to have a weird error.\\nMy code looks like this:\\n```\\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        i = 0\\n        j = 0\\n        while ((i < m) or (j < n)):\\n            if nums1[i] >= nums2[j] or i > m:\\n                nums1 = nums1[:i] + [nums2[j]] + nums1[i:-1]\\n                j += 1\\n            i += 1\\n        return None\\n```\\nFor some reason, the while loop continues even if the condition should evaluate to False, and then the code troughs an \\'list index out of range\\' error for the if statement. \\n\\nCan someone explain this behaviour?\\n\\nThanks already!"
                    },
                    {
                        "username": "nvinogr",
                        "content": "Can anyone help me understand what\\'s going on and why p2 gets incremented from `-1` to `0`?:\\n```java\\nint p1 = n - 1;\\nint p2 = m - 1;\\nfor (int i = n + m - 1; i >= 0; i--) {\\n    System.out.printf(\"%d %d%n\", p1, p2);\\n    nums1[i] = p2 < 0 || p1 >= 0 && nums1[p1] >= nums2[p2] \\n        ? nums1[p1--] \\n        : nums2[p2--];\\n}\\n```\\nI get the following exception:\\n```\\njava.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0\\n  at line 9, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n```\\nAnd stdout is:\\n```\\n2 2\\n2 1\\n2 0\\n1 0\\n0 0\\n0 -1\\n-1 0\\n```"
                    }
                ]
            },
            {
                "id": 1826106,
                "content": [
                    {
                        "username": "jatayuwu",
                        "content": "\n        ```if m == 0:\n            nums1 = nums2\n        elif n == 0:\n            return\n        else:\n            for i in range(m):\n                nums1[i+n], nums1[i] = nums1[i], nums1[i+n]\n            ins_head = 0\n            j = 0\n            i = m\n\n            while i < (m+n) and j < n:\n                if nums1[i] <= nums2[j]:\n                    nums1[ins_head] = nums1[i]\n                    i += 1\n                    ins_head += 1\n                else:\n                    nums1[ins_head] = nums2[j]\n                    j += 1\n                    ins_head += 1\n            while i < (m+n):\n                nums1[ins_head] = nums1[i]\n                i += 1\n                ins_head += 1```\n\ncan someone explain to me why this doesn't work for the third default test case, i set nums1 to be equal to nums2 if m = 0 and the value of nums1 is correct in the std output yet the testcase fails for some reason"
                    },
                    {
                        "username": "startupveteran",
                        "content": "Is it cheating if you use built in methods like \".sort\"?"
                    },
                    {
                        "username": "rakesh74",
                        "content": "Scala doesn\\'t support call by reference, so this cant be implemented. The the result should be return value. "
                    },
                    {
                        "username": "BillyThyCoderOFEatrth",
                        "content": "Hi, is this question solvable using nested loops/2 pointer approach.?"
                    },
                    {
                        "username": "philiprbaumann",
                        "content": "Non-decreasing order... why not just increasing??"
                    },
                    {
                        "username": "prathore28647",
                        "content": "A much simpler explanation to the problem given by ChatGPT:\\n\\nImagine you have two piles of toys. One pile has some red toys and the other pile has some blue toys. Now, you want to put all the toys together in a big pile, but you want to make sure that the toys are still sorted by their colors.\\n\\nTo do this, you take one toy from the red pile and one toy from the blue pile and put them in the big pile. If the red toy is bigger than the blue toy, you put the red toy in the big pile first. If the blue toy is bigger than the red toy, you put the blue toy in the big pile first.\\n\\nYou keep doing this until you have put all the toys in the big pile. If there are still some toys left in the blue pile, you just put them in the big pile without comparing them to any red toys.\\n\\nThis is kind of like what the code is doing. It takes two arrays of numbers that are already sorted, and puts them together into one big array that is also sorted. It does this by comparing the last number in each array, and putting the bigger number in the big array first. It keeps doing this until all the numbers are in the big array."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Hii Guys!! Check out my blog for the solution of this problem:\\nhttps://dsafordummies.digitalpress.blog/easy-array-leetcode-series-1/\\n\\nYou can also find two more easy level questions to test your skills in this particular blog! Thank you for supporting:)"
                    },
                    {
                        "username": "shayanth",
                        "content": "i already answered the problem but it doesn\\'t change the nums1 in-place, but when nums1 is printed it is the correct answer\\n\\n `def merge(self,nums1, m, nums2, n):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = set(nums1)\\n        nums1 = list(nums1)\\n        print(\"nusm1: \",nums1)\\n        nums1 = set(nums1)\\n        nums1 = list(nums1)\\n        print(\"nusm2: \",nums2)\\n\\n        if 0 in nums1:\\n            nums1.remove(0)\\n        if 0 in nums2:\\n            nums2.remove(0)\\n\\n        nums1 = sorted(nums1 + nums2)\\n        print(\"nusm1: \",nums1)`"
                    },
                    {
                        "username": "carl-egge",
                        "content": "Hej everybody,\\nI\\'ve been trying to solve this problem in python3, but I seem to have a weird error.\\nMy code looks like this:\\n```\\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        i = 0\\n        j = 0\\n        while ((i < m) or (j < n)):\\n            if nums1[i] >= nums2[j] or i > m:\\n                nums1 = nums1[:i] + [nums2[j]] + nums1[i:-1]\\n                j += 1\\n            i += 1\\n        return None\\n```\\nFor some reason, the while loop continues even if the condition should evaluate to False, and then the code troughs an \\'list index out of range\\' error for the if statement. \\n\\nCan someone explain this behaviour?\\n\\nThanks already!"
                    },
                    {
                        "username": "nvinogr",
                        "content": "Can anyone help me understand what\\'s going on and why p2 gets incremented from `-1` to `0`?:\\n```java\\nint p1 = n - 1;\\nint p2 = m - 1;\\nfor (int i = n + m - 1; i >= 0; i--) {\\n    System.out.printf(\"%d %d%n\", p1, p2);\\n    nums1[i] = p2 < 0 || p1 >= 0 && nums1[p1] >= nums2[p2] \\n        ? nums1[p1--] \\n        : nums2[p2--];\\n}\\n```\\nI get the following exception:\\n```\\njava.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0\\n  at line 9, Solution.merge\\n  at line 54, __DriverSolution__.__helper__\\n  at line 93, __Driver__.main\\n```\\nAnd stdout is:\\n```\\n2 2\\n2 1\\n2 0\\n1 0\\n0 0\\n0 -1\\n-1 0\\n```"
                    }
                ]
            },
            {
                "id": 1822824,
                "content": [
                    {
                        "username": "goyalishika132",
                        "content": "\\nSOMEONE HELP TO RESOLVE THIS ERROR\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        vector<int> c;\\n\\n        while(i<m && j<n)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                c.push_back(nums2[j]);\\n                j++;\\n            }\\n            else\\n             {\\n                c.push_back(nums1[i]);\\n                i++;\\n            } \\n        }\\n        while(j<m)\\n        {\\n            c.push_back(nums2[j]);\\n                j++;\\n        }\\n\\n        while(i<n)\\n          {\\n                c.push_back(nums1[i]);\\n                i++;\\n         } \\n         copy(c.begin(), c.end(), back_inserter(nums1)); \\n    }"
                    },
                    {
                        "username": "clashyraj",
                        "content": "In the 2nd while loop it must be j<n and in 3rd while loop it must be i<m"
                    },
                    {
                        "username": "Charan0911",
                        "content": "        nums1=nums1[0:m]\\n        nums1=nums1+nums2\\n        nums1.sort()\\nWhy can\\'t this code be the solution?"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "Why this solution is showing RUNTIME ERROR?\\n\\nRuntime Error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n `your inline code...your inline code...`\\n class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {   \\n        int j = 0,i;\\n    for( i=0;i<m+n;i++)\\n    {  \\n         if(nums1[i] >= nums2[j] || i>=m)\\n        {\\n            nums1.insert(nums1.begin()+i,nums2[j++]) ;\\n            i++ ;\\n         }\\n    }\\n    }\\n};\\n\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "madhavsaisurya_",
                        "content": "Isnt the testcase invalid? m should be an int not an array right?"
                    },
                    {
                        "username": "sainath81061",
                        "content": "int k = m + n - 1;\n        int j = n - 1;\n        for(int i = m-1;i >= 0;)\n        {\n            if (j == -1)\n            {\n                break;\n            }\n            if (nums1[i] > nums2[j])\n            {\n                nums1[k] = nums1[i];\n                k--;i--;\n            }\n            else\n            {\n                nums1[k] = nums2[j];\n                k--;  j--;  \n            }\n\n        }\n         if(m == 0)\n         {\n            nums1[k] = nums2[j]; \n         }"
                    },
                    {
                        "username": "DaniilAbdulov",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    let arr = (nums1.slice(0,m).concat(nums2.slice(0,n))).sort( (a, b)=> a-b )\\n    return arr\\n};\\nWHY my code doesn\\'t work ? Tell me, please. Everything works fine in the console."
                    },
                    {
                        "username": "kanmear",
                        "content": "what a dumbass problem. whoever thought that adding leading zeroes AND also using zeroes as actual elements should not be writing any more problems."
                    },
                    {
                        "username": "dunionwagner",
                        "content": "Whats wrong with my code? It says that the output is [1,2,3] but when I printed what i returned, it returned the correct answer?\\n\\nSPOILER\\n\\n\\n\\n\\n\\n\\n\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        leng = len(nums1)\\n        leng = leng - 3\\n        j = -1\\n        for counter in range(leng):\\n            nums1.remove(nums1[j])\\n        nums3 = nums1 + nums2\\n        nums3.sort()\\n        print(nums3)\\n        return nums3\\n            "
                    },
                    {
                        "username": "nileshthakur329",
                        "content": "it\\'s basically based on merged sort algorithm, if you are not able to solve this then please try learning merged sort algo(divide and conquer) then try it."
                    },
                    {
                        "username": "user7465gB",
                        "content": "Can someone please tell me why this code works in my IDE, but doesn\\'t give the correct output here? I realize its probably not the fastest method, but it should work no? Sorry if there is something glaringly obvious that I have missed here. Thanks in advance.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        nums1=nums1+nums2\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1.sort(reverse=False)"
                    }
                ]
            },
            {
                "id": 1817747,
                "content": [
                    {
                        "username": "goyalishika132",
                        "content": "\\nSOMEONE HELP TO RESOLVE THIS ERROR\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        vector<int> c;\\n\\n        while(i<m && j<n)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                c.push_back(nums2[j]);\\n                j++;\\n            }\\n            else\\n             {\\n                c.push_back(nums1[i]);\\n                i++;\\n            } \\n        }\\n        while(j<m)\\n        {\\n            c.push_back(nums2[j]);\\n                j++;\\n        }\\n\\n        while(i<n)\\n          {\\n                c.push_back(nums1[i]);\\n                i++;\\n         } \\n         copy(c.begin(), c.end(), back_inserter(nums1)); \\n    }"
                    },
                    {
                        "username": "clashyraj",
                        "content": "In the 2nd while loop it must be j<n and in 3rd while loop it must be i<m"
                    },
                    {
                        "username": "Charan0911",
                        "content": "        nums1=nums1[0:m]\\n        nums1=nums1+nums2\\n        nums1.sort()\\nWhy can\\'t this code be the solution?"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "Why this solution is showing RUNTIME ERROR?\\n\\nRuntime Error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n `your inline code...your inline code...`\\n class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {   \\n        int j = 0,i;\\n    for( i=0;i<m+n;i++)\\n    {  \\n         if(nums1[i] >= nums2[j] || i>=m)\\n        {\\n            nums1.insert(nums1.begin()+i,nums2[j++]) ;\\n            i++ ;\\n         }\\n    }\\n    }\\n};\\n\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "madhavsaisurya_",
                        "content": "Isnt the testcase invalid? m should be an int not an array right?"
                    },
                    {
                        "username": "sainath81061",
                        "content": "int k = m + n - 1;\n        int j = n - 1;\n        for(int i = m-1;i >= 0;)\n        {\n            if (j == -1)\n            {\n                break;\n            }\n            if (nums1[i] > nums2[j])\n            {\n                nums1[k] = nums1[i];\n                k--;i--;\n            }\n            else\n            {\n                nums1[k] = nums2[j];\n                k--;  j--;  \n            }\n\n        }\n         if(m == 0)\n         {\n            nums1[k] = nums2[j]; \n         }"
                    },
                    {
                        "username": "DaniilAbdulov",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    let arr = (nums1.slice(0,m).concat(nums2.slice(0,n))).sort( (a, b)=> a-b )\\n    return arr\\n};\\nWHY my code doesn\\'t work ? Tell me, please. Everything works fine in the console."
                    },
                    {
                        "username": "kanmear",
                        "content": "what a dumbass problem. whoever thought that adding leading zeroes AND also using zeroes as actual elements should not be writing any more problems."
                    },
                    {
                        "username": "dunionwagner",
                        "content": "Whats wrong with my code? It says that the output is [1,2,3] but when I printed what i returned, it returned the correct answer?\\n\\nSPOILER\\n\\n\\n\\n\\n\\n\\n\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        leng = len(nums1)\\n        leng = leng - 3\\n        j = -1\\n        for counter in range(leng):\\n            nums1.remove(nums1[j])\\n        nums3 = nums1 + nums2\\n        nums3.sort()\\n        print(nums3)\\n        return nums3\\n            "
                    },
                    {
                        "username": "nileshthakur329",
                        "content": "it\\'s basically based on merged sort algorithm, if you are not able to solve this then please try learning merged sort algo(divide and conquer) then try it."
                    },
                    {
                        "username": "user7465gB",
                        "content": "Can someone please tell me why this code works in my IDE, but doesn\\'t give the correct output here? I realize its probably not the fastest method, but it should work no? Sorry if there is something glaringly obvious that I have missed here. Thanks in advance.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        nums1=nums1+nums2\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1.sort(reverse=False)"
                    }
                ]
            },
            {
                "id": 1817547,
                "content": [
                    {
                        "username": "goyalishika132",
                        "content": "\\nSOMEONE HELP TO RESOLVE THIS ERROR\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        vector<int> c;\\n\\n        while(i<m && j<n)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                c.push_back(nums2[j]);\\n                j++;\\n            }\\n            else\\n             {\\n                c.push_back(nums1[i]);\\n                i++;\\n            } \\n        }\\n        while(j<m)\\n        {\\n            c.push_back(nums2[j]);\\n                j++;\\n        }\\n\\n        while(i<n)\\n          {\\n                c.push_back(nums1[i]);\\n                i++;\\n         } \\n         copy(c.begin(), c.end(), back_inserter(nums1)); \\n    }"
                    },
                    {
                        "username": "clashyraj",
                        "content": "In the 2nd while loop it must be j<n and in 3rd while loop it must be i<m"
                    },
                    {
                        "username": "Charan0911",
                        "content": "        nums1=nums1[0:m]\\n        nums1=nums1+nums2\\n        nums1.sort()\\nWhy can\\'t this code be the solution?"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "Why this solution is showing RUNTIME ERROR?\\n\\nRuntime Error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n `your inline code...your inline code...`\\n class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {   \\n        int j = 0,i;\\n    for( i=0;i<m+n;i++)\\n    {  \\n         if(nums1[i] >= nums2[j] || i>=m)\\n        {\\n            nums1.insert(nums1.begin()+i,nums2[j++]) ;\\n            i++ ;\\n         }\\n    }\\n    }\\n};\\n\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "madhavsaisurya_",
                        "content": "Isnt the testcase invalid? m should be an int not an array right?"
                    },
                    {
                        "username": "sainath81061",
                        "content": "int k = m + n - 1;\n        int j = n - 1;\n        for(int i = m-1;i >= 0;)\n        {\n            if (j == -1)\n            {\n                break;\n            }\n            if (nums1[i] > nums2[j])\n            {\n                nums1[k] = nums1[i];\n                k--;i--;\n            }\n            else\n            {\n                nums1[k] = nums2[j];\n                k--;  j--;  \n            }\n\n        }\n         if(m == 0)\n         {\n            nums1[k] = nums2[j]; \n         }"
                    },
                    {
                        "username": "DaniilAbdulov",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    let arr = (nums1.slice(0,m).concat(nums2.slice(0,n))).sort( (a, b)=> a-b )\\n    return arr\\n};\\nWHY my code doesn\\'t work ? Tell me, please. Everything works fine in the console."
                    },
                    {
                        "username": "kanmear",
                        "content": "what a dumbass problem. whoever thought that adding leading zeroes AND also using zeroes as actual elements should not be writing any more problems."
                    },
                    {
                        "username": "dunionwagner",
                        "content": "Whats wrong with my code? It says that the output is [1,2,3] but when I printed what i returned, it returned the correct answer?\\n\\nSPOILER\\n\\n\\n\\n\\n\\n\\n\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        leng = len(nums1)\\n        leng = leng - 3\\n        j = -1\\n        for counter in range(leng):\\n            nums1.remove(nums1[j])\\n        nums3 = nums1 + nums2\\n        nums3.sort()\\n        print(nums3)\\n        return nums3\\n            "
                    },
                    {
                        "username": "nileshthakur329",
                        "content": "it\\'s basically based on merged sort algorithm, if you are not able to solve this then please try learning merged sort algo(divide and conquer) then try it."
                    },
                    {
                        "username": "user7465gB",
                        "content": "Can someone please tell me why this code works in my IDE, but doesn\\'t give the correct output here? I realize its probably not the fastest method, but it should work no? Sorry if there is something glaringly obvious that I have missed here. Thanks in advance.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        nums1=nums1+nums2\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1.sort(reverse=False)"
                    }
                ]
            },
            {
                "id": 1815670,
                "content": [
                    {
                        "username": "goyalishika132",
                        "content": "\\nSOMEONE HELP TO RESOLVE THIS ERROR\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        vector<int> c;\\n\\n        while(i<m && j<n)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                c.push_back(nums2[j]);\\n                j++;\\n            }\\n            else\\n             {\\n                c.push_back(nums1[i]);\\n                i++;\\n            } \\n        }\\n        while(j<m)\\n        {\\n            c.push_back(nums2[j]);\\n                j++;\\n        }\\n\\n        while(i<n)\\n          {\\n                c.push_back(nums1[i]);\\n                i++;\\n         } \\n         copy(c.begin(), c.end(), back_inserter(nums1)); \\n    }"
                    },
                    {
                        "username": "clashyraj",
                        "content": "In the 2nd while loop it must be j<n and in 3rd while loop it must be i<m"
                    },
                    {
                        "username": "Charan0911",
                        "content": "        nums1=nums1[0:m]\\n        nums1=nums1+nums2\\n        nums1.sort()\\nWhy can\\'t this code be the solution?"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "Why this solution is showing RUNTIME ERROR?\\n\\nRuntime Error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n `your inline code...your inline code...`\\n class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {   \\n        int j = 0,i;\\n    for( i=0;i<m+n;i++)\\n    {  \\n         if(nums1[i] >= nums2[j] || i>=m)\\n        {\\n            nums1.insert(nums1.begin()+i,nums2[j++]) ;\\n            i++ ;\\n         }\\n    }\\n    }\\n};\\n\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "madhavsaisurya_",
                        "content": "Isnt the testcase invalid? m should be an int not an array right?"
                    },
                    {
                        "username": "sainath81061",
                        "content": "int k = m + n - 1;\n        int j = n - 1;\n        for(int i = m-1;i >= 0;)\n        {\n            if (j == -1)\n            {\n                break;\n            }\n            if (nums1[i] > nums2[j])\n            {\n                nums1[k] = nums1[i];\n                k--;i--;\n            }\n            else\n            {\n                nums1[k] = nums2[j];\n                k--;  j--;  \n            }\n\n        }\n         if(m == 0)\n         {\n            nums1[k] = nums2[j]; \n         }"
                    },
                    {
                        "username": "DaniilAbdulov",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    let arr = (nums1.slice(0,m).concat(nums2.slice(0,n))).sort( (a, b)=> a-b )\\n    return arr\\n};\\nWHY my code doesn\\'t work ? Tell me, please. Everything works fine in the console."
                    },
                    {
                        "username": "kanmear",
                        "content": "what a dumbass problem. whoever thought that adding leading zeroes AND also using zeroes as actual elements should not be writing any more problems."
                    },
                    {
                        "username": "dunionwagner",
                        "content": "Whats wrong with my code? It says that the output is [1,2,3] but when I printed what i returned, it returned the correct answer?\\n\\nSPOILER\\n\\n\\n\\n\\n\\n\\n\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        leng = len(nums1)\\n        leng = leng - 3\\n        j = -1\\n        for counter in range(leng):\\n            nums1.remove(nums1[j])\\n        nums3 = nums1 + nums2\\n        nums3.sort()\\n        print(nums3)\\n        return nums3\\n            "
                    },
                    {
                        "username": "nileshthakur329",
                        "content": "it\\'s basically based on merged sort algorithm, if you are not able to solve this then please try learning merged sort algo(divide and conquer) then try it."
                    },
                    {
                        "username": "user7465gB",
                        "content": "Can someone please tell me why this code works in my IDE, but doesn\\'t give the correct output here? I realize its probably not the fastest method, but it should work no? Sorry if there is something glaringly obvious that I have missed here. Thanks in advance.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        nums1=nums1+nums2\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1.sort(reverse=False)"
                    }
                ]
            },
            {
                "id": 1814139,
                "content": [
                    {
                        "username": "goyalishika132",
                        "content": "\\nSOMEONE HELP TO RESOLVE THIS ERROR\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        vector<int> c;\\n\\n        while(i<m && j<n)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                c.push_back(nums2[j]);\\n                j++;\\n            }\\n            else\\n             {\\n                c.push_back(nums1[i]);\\n                i++;\\n            } \\n        }\\n        while(j<m)\\n        {\\n            c.push_back(nums2[j]);\\n                j++;\\n        }\\n\\n        while(i<n)\\n          {\\n                c.push_back(nums1[i]);\\n                i++;\\n         } \\n         copy(c.begin(), c.end(), back_inserter(nums1)); \\n    }"
                    },
                    {
                        "username": "clashyraj",
                        "content": "In the 2nd while loop it must be j<n and in 3rd while loop it must be i<m"
                    },
                    {
                        "username": "Charan0911",
                        "content": "        nums1=nums1[0:m]\\n        nums1=nums1+nums2\\n        nums1.sort()\\nWhy can\\'t this code be the solution?"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "Why this solution is showing RUNTIME ERROR?\\n\\nRuntime Error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n `your inline code...your inline code...`\\n class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {   \\n        int j = 0,i;\\n    for( i=0;i<m+n;i++)\\n    {  \\n         if(nums1[i] >= nums2[j] || i>=m)\\n        {\\n            nums1.insert(nums1.begin()+i,nums2[j++]) ;\\n            i++ ;\\n         }\\n    }\\n    }\\n};\\n\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "madhavsaisurya_",
                        "content": "Isnt the testcase invalid? m should be an int not an array right?"
                    },
                    {
                        "username": "sainath81061",
                        "content": "int k = m + n - 1;\n        int j = n - 1;\n        for(int i = m-1;i >= 0;)\n        {\n            if (j == -1)\n            {\n                break;\n            }\n            if (nums1[i] > nums2[j])\n            {\n                nums1[k] = nums1[i];\n                k--;i--;\n            }\n            else\n            {\n                nums1[k] = nums2[j];\n                k--;  j--;  \n            }\n\n        }\n         if(m == 0)\n         {\n            nums1[k] = nums2[j]; \n         }"
                    },
                    {
                        "username": "DaniilAbdulov",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    let arr = (nums1.slice(0,m).concat(nums2.slice(0,n))).sort( (a, b)=> a-b )\\n    return arr\\n};\\nWHY my code doesn\\'t work ? Tell me, please. Everything works fine in the console."
                    },
                    {
                        "username": "kanmear",
                        "content": "what a dumbass problem. whoever thought that adding leading zeroes AND also using zeroes as actual elements should not be writing any more problems."
                    },
                    {
                        "username": "dunionwagner",
                        "content": "Whats wrong with my code? It says that the output is [1,2,3] but when I printed what i returned, it returned the correct answer?\\n\\nSPOILER\\n\\n\\n\\n\\n\\n\\n\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        leng = len(nums1)\\n        leng = leng - 3\\n        j = -1\\n        for counter in range(leng):\\n            nums1.remove(nums1[j])\\n        nums3 = nums1 + nums2\\n        nums3.sort()\\n        print(nums3)\\n        return nums3\\n            "
                    },
                    {
                        "username": "nileshthakur329",
                        "content": "it\\'s basically based on merged sort algorithm, if you are not able to solve this then please try learning merged sort algo(divide and conquer) then try it."
                    },
                    {
                        "username": "user7465gB",
                        "content": "Can someone please tell me why this code works in my IDE, but doesn\\'t give the correct output here? I realize its probably not the fastest method, but it should work no? Sorry if there is something glaringly obvious that I have missed here. Thanks in advance.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        nums1=nums1+nums2\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1.sort(reverse=False)"
                    }
                ]
            },
            {
                "id": 1813064,
                "content": [
                    {
                        "username": "goyalishika132",
                        "content": "\\nSOMEONE HELP TO RESOLVE THIS ERROR\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        vector<int> c;\\n\\n        while(i<m && j<n)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                c.push_back(nums2[j]);\\n                j++;\\n            }\\n            else\\n             {\\n                c.push_back(nums1[i]);\\n                i++;\\n            } \\n        }\\n        while(j<m)\\n        {\\n            c.push_back(nums2[j]);\\n                j++;\\n        }\\n\\n        while(i<n)\\n          {\\n                c.push_back(nums1[i]);\\n                i++;\\n         } \\n         copy(c.begin(), c.end(), back_inserter(nums1)); \\n    }"
                    },
                    {
                        "username": "clashyraj",
                        "content": "In the 2nd while loop it must be j<n and in 3rd while loop it must be i<m"
                    },
                    {
                        "username": "Charan0911",
                        "content": "        nums1=nums1[0:m]\\n        nums1=nums1+nums2\\n        nums1.sort()\\nWhy can\\'t this code be the solution?"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "Why this solution is showing RUNTIME ERROR?\\n\\nRuntime Error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n `your inline code...your inline code...`\\n class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {   \\n        int j = 0,i;\\n    for( i=0;i<m+n;i++)\\n    {  \\n         if(nums1[i] >= nums2[j] || i>=m)\\n        {\\n            nums1.insert(nums1.begin()+i,nums2[j++]) ;\\n            i++ ;\\n         }\\n    }\\n    }\\n};\\n\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "madhavsaisurya_",
                        "content": "Isnt the testcase invalid? m should be an int not an array right?"
                    },
                    {
                        "username": "sainath81061",
                        "content": "int k = m + n - 1;\n        int j = n - 1;\n        for(int i = m-1;i >= 0;)\n        {\n            if (j == -1)\n            {\n                break;\n            }\n            if (nums1[i] > nums2[j])\n            {\n                nums1[k] = nums1[i];\n                k--;i--;\n            }\n            else\n            {\n                nums1[k] = nums2[j];\n                k--;  j--;  \n            }\n\n        }\n         if(m == 0)\n         {\n            nums1[k] = nums2[j]; \n         }"
                    },
                    {
                        "username": "DaniilAbdulov",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    let arr = (nums1.slice(0,m).concat(nums2.slice(0,n))).sort( (a, b)=> a-b )\\n    return arr\\n};\\nWHY my code doesn\\'t work ? Tell me, please. Everything works fine in the console."
                    },
                    {
                        "username": "kanmear",
                        "content": "what a dumbass problem. whoever thought that adding leading zeroes AND also using zeroes as actual elements should not be writing any more problems."
                    },
                    {
                        "username": "dunionwagner",
                        "content": "Whats wrong with my code? It says that the output is [1,2,3] but when I printed what i returned, it returned the correct answer?\\n\\nSPOILER\\n\\n\\n\\n\\n\\n\\n\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        leng = len(nums1)\\n        leng = leng - 3\\n        j = -1\\n        for counter in range(leng):\\n            nums1.remove(nums1[j])\\n        nums3 = nums1 + nums2\\n        nums3.sort()\\n        print(nums3)\\n        return nums3\\n            "
                    },
                    {
                        "username": "nileshthakur329",
                        "content": "it\\'s basically based on merged sort algorithm, if you are not able to solve this then please try learning merged sort algo(divide and conquer) then try it."
                    },
                    {
                        "username": "user7465gB",
                        "content": "Can someone please tell me why this code works in my IDE, but doesn\\'t give the correct output here? I realize its probably not the fastest method, but it should work no? Sorry if there is something glaringly obvious that I have missed here. Thanks in advance.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        nums1=nums1+nums2\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1.sort(reverse=False)"
                    }
                ]
            },
            {
                "id": 1812397,
                "content": [
                    {
                        "username": "goyalishika132",
                        "content": "\\nSOMEONE HELP TO RESOLVE THIS ERROR\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        vector<int> c;\\n\\n        while(i<m && j<n)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                c.push_back(nums2[j]);\\n                j++;\\n            }\\n            else\\n             {\\n                c.push_back(nums1[i]);\\n                i++;\\n            } \\n        }\\n        while(j<m)\\n        {\\n            c.push_back(nums2[j]);\\n                j++;\\n        }\\n\\n        while(i<n)\\n          {\\n                c.push_back(nums1[i]);\\n                i++;\\n         } \\n         copy(c.begin(), c.end(), back_inserter(nums1)); \\n    }"
                    },
                    {
                        "username": "clashyraj",
                        "content": "In the 2nd while loop it must be j<n and in 3rd while loop it must be i<m"
                    },
                    {
                        "username": "Charan0911",
                        "content": "        nums1=nums1[0:m]\\n        nums1=nums1+nums2\\n        nums1.sort()\\nWhy can\\'t this code be the solution?"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "Why this solution is showing RUNTIME ERROR?\\n\\nRuntime Error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n `your inline code...your inline code...`\\n class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {   \\n        int j = 0,i;\\n    for( i=0;i<m+n;i++)\\n    {  \\n         if(nums1[i] >= nums2[j] || i>=m)\\n        {\\n            nums1.insert(nums1.begin()+i,nums2[j++]) ;\\n            i++ ;\\n         }\\n    }\\n    }\\n};\\n\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "madhavsaisurya_",
                        "content": "Isnt the testcase invalid? m should be an int not an array right?"
                    },
                    {
                        "username": "sainath81061",
                        "content": "int k = m + n - 1;\n        int j = n - 1;\n        for(int i = m-1;i >= 0;)\n        {\n            if (j == -1)\n            {\n                break;\n            }\n            if (nums1[i] > nums2[j])\n            {\n                nums1[k] = nums1[i];\n                k--;i--;\n            }\n            else\n            {\n                nums1[k] = nums2[j];\n                k--;  j--;  \n            }\n\n        }\n         if(m == 0)\n         {\n            nums1[k] = nums2[j]; \n         }"
                    },
                    {
                        "username": "DaniilAbdulov",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    let arr = (nums1.slice(0,m).concat(nums2.slice(0,n))).sort( (a, b)=> a-b )\\n    return arr\\n};\\nWHY my code doesn\\'t work ? Tell me, please. Everything works fine in the console."
                    },
                    {
                        "username": "kanmear",
                        "content": "what a dumbass problem. whoever thought that adding leading zeroes AND also using zeroes as actual elements should not be writing any more problems."
                    },
                    {
                        "username": "dunionwagner",
                        "content": "Whats wrong with my code? It says that the output is [1,2,3] but when I printed what i returned, it returned the correct answer?\\n\\nSPOILER\\n\\n\\n\\n\\n\\n\\n\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        leng = len(nums1)\\n        leng = leng - 3\\n        j = -1\\n        for counter in range(leng):\\n            nums1.remove(nums1[j])\\n        nums3 = nums1 + nums2\\n        nums3.sort()\\n        print(nums3)\\n        return nums3\\n            "
                    },
                    {
                        "username": "nileshthakur329",
                        "content": "it\\'s basically based on merged sort algorithm, if you are not able to solve this then please try learning merged sort algo(divide and conquer) then try it."
                    },
                    {
                        "username": "user7465gB",
                        "content": "Can someone please tell me why this code works in my IDE, but doesn\\'t give the correct output here? I realize its probably not the fastest method, but it should work no? Sorry if there is something glaringly obvious that I have missed here. Thanks in advance.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        nums1=nums1+nums2\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1.sort(reverse=False)"
                    }
                ]
            },
            {
                "id": 1811332,
                "content": [
                    {
                        "username": "goyalishika132",
                        "content": "\\nSOMEONE HELP TO RESOLVE THIS ERROR\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        vector<int> c;\\n\\n        while(i<m && j<n)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                c.push_back(nums2[j]);\\n                j++;\\n            }\\n            else\\n             {\\n                c.push_back(nums1[i]);\\n                i++;\\n            } \\n        }\\n        while(j<m)\\n        {\\n            c.push_back(nums2[j]);\\n                j++;\\n        }\\n\\n        while(i<n)\\n          {\\n                c.push_back(nums1[i]);\\n                i++;\\n         } \\n         copy(c.begin(), c.end(), back_inserter(nums1)); \\n    }"
                    },
                    {
                        "username": "clashyraj",
                        "content": "In the 2nd while loop it must be j<n and in 3rd while loop it must be i<m"
                    },
                    {
                        "username": "Charan0911",
                        "content": "        nums1=nums1[0:m]\\n        nums1=nums1+nums2\\n        nums1.sort()\\nWhy can\\'t this code be the solution?"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "Why this solution is showing RUNTIME ERROR?\\n\\nRuntime Error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n `your inline code...your inline code...`\\n class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {   \\n        int j = 0,i;\\n    for( i=0;i<m+n;i++)\\n    {  \\n         if(nums1[i] >= nums2[j] || i>=m)\\n        {\\n            nums1.insert(nums1.begin()+i,nums2[j++]) ;\\n            i++ ;\\n         }\\n    }\\n    }\\n};\\n\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "madhavsaisurya_",
                        "content": "Isnt the testcase invalid? m should be an int not an array right?"
                    },
                    {
                        "username": "sainath81061",
                        "content": "int k = m + n - 1;\n        int j = n - 1;\n        for(int i = m-1;i >= 0;)\n        {\n            if (j == -1)\n            {\n                break;\n            }\n            if (nums1[i] > nums2[j])\n            {\n                nums1[k] = nums1[i];\n                k--;i--;\n            }\n            else\n            {\n                nums1[k] = nums2[j];\n                k--;  j--;  \n            }\n\n        }\n         if(m == 0)\n         {\n            nums1[k] = nums2[j]; \n         }"
                    },
                    {
                        "username": "DaniilAbdulov",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    let arr = (nums1.slice(0,m).concat(nums2.slice(0,n))).sort( (a, b)=> a-b )\\n    return arr\\n};\\nWHY my code doesn\\'t work ? Tell me, please. Everything works fine in the console."
                    },
                    {
                        "username": "kanmear",
                        "content": "what a dumbass problem. whoever thought that adding leading zeroes AND also using zeroes as actual elements should not be writing any more problems."
                    },
                    {
                        "username": "dunionwagner",
                        "content": "Whats wrong with my code? It says that the output is [1,2,3] but when I printed what i returned, it returned the correct answer?\\n\\nSPOILER\\n\\n\\n\\n\\n\\n\\n\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        leng = len(nums1)\\n        leng = leng - 3\\n        j = -1\\n        for counter in range(leng):\\n            nums1.remove(nums1[j])\\n        nums3 = nums1 + nums2\\n        nums3.sort()\\n        print(nums3)\\n        return nums3\\n            "
                    },
                    {
                        "username": "nileshthakur329",
                        "content": "it\\'s basically based on merged sort algorithm, if you are not able to solve this then please try learning merged sort algo(divide and conquer) then try it."
                    },
                    {
                        "username": "user7465gB",
                        "content": "Can someone please tell me why this code works in my IDE, but doesn\\'t give the correct output here? I realize its probably not the fastest method, but it should work no? Sorry if there is something glaringly obvious that I have missed here. Thanks in advance.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        nums1=nums1+nums2\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1.sort(reverse=False)"
                    }
                ]
            },
            {
                "id": 1809788,
                "content": [
                    {
                        "username": "goyalishika132",
                        "content": "\\nSOMEONE HELP TO RESOLVE THIS ERROR\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        vector<int> c;\\n\\n        while(i<m && j<n)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                c.push_back(nums2[j]);\\n                j++;\\n            }\\n            else\\n             {\\n                c.push_back(nums1[i]);\\n                i++;\\n            } \\n        }\\n        while(j<m)\\n        {\\n            c.push_back(nums2[j]);\\n                j++;\\n        }\\n\\n        while(i<n)\\n          {\\n                c.push_back(nums1[i]);\\n                i++;\\n         } \\n         copy(c.begin(), c.end(), back_inserter(nums1)); \\n    }"
                    },
                    {
                        "username": "clashyraj",
                        "content": "In the 2nd while loop it must be j<n and in 3rd while loop it must be i<m"
                    },
                    {
                        "username": "Charan0911",
                        "content": "        nums1=nums1[0:m]\\n        nums1=nums1+nums2\\n        nums1.sort()\\nWhy can\\'t this code be the solution?"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "Why this solution is showing RUNTIME ERROR?\\n\\nRuntime Error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n `your inline code...your inline code...`\\n class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {   \\n        int j = 0,i;\\n    for( i=0;i<m+n;i++)\\n    {  \\n         if(nums1[i] >= nums2[j] || i>=m)\\n        {\\n            nums1.insert(nums1.begin()+i,nums2[j++]) ;\\n            i++ ;\\n         }\\n    }\\n    }\\n};\\n\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "madhavsaisurya_",
                        "content": "Isnt the testcase invalid? m should be an int not an array right?"
                    },
                    {
                        "username": "sainath81061",
                        "content": "int k = m + n - 1;\n        int j = n - 1;\n        for(int i = m-1;i >= 0;)\n        {\n            if (j == -1)\n            {\n                break;\n            }\n            if (nums1[i] > nums2[j])\n            {\n                nums1[k] = nums1[i];\n                k--;i--;\n            }\n            else\n            {\n                nums1[k] = nums2[j];\n                k--;  j--;  \n            }\n\n        }\n         if(m == 0)\n         {\n            nums1[k] = nums2[j]; \n         }"
                    },
                    {
                        "username": "DaniilAbdulov",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    let arr = (nums1.slice(0,m).concat(nums2.slice(0,n))).sort( (a, b)=> a-b )\\n    return arr\\n};\\nWHY my code doesn\\'t work ? Tell me, please. Everything works fine in the console."
                    },
                    {
                        "username": "kanmear",
                        "content": "what a dumbass problem. whoever thought that adding leading zeroes AND also using zeroes as actual elements should not be writing any more problems."
                    },
                    {
                        "username": "dunionwagner",
                        "content": "Whats wrong with my code? It says that the output is [1,2,3] but when I printed what i returned, it returned the correct answer?\\n\\nSPOILER\\n\\n\\n\\n\\n\\n\\n\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        leng = len(nums1)\\n        leng = leng - 3\\n        j = -1\\n        for counter in range(leng):\\n            nums1.remove(nums1[j])\\n        nums3 = nums1 + nums2\\n        nums3.sort()\\n        print(nums3)\\n        return nums3\\n            "
                    },
                    {
                        "username": "nileshthakur329",
                        "content": "it\\'s basically based on merged sort algorithm, if you are not able to solve this then please try learning merged sort algo(divide and conquer) then try it."
                    },
                    {
                        "username": "user7465gB",
                        "content": "Can someone please tell me why this code works in my IDE, but doesn\\'t give the correct output here? I realize its probably not the fastest method, but it should work no? Sorry if there is something glaringly obvious that I have missed here. Thanks in advance.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        nums1=nums1+nums2\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1.sort(reverse=False)"
                    }
                ]
            },
            {
                "id": 1809073,
                "content": [
                    {
                        "username": "goyalishika132",
                        "content": "\\nSOMEONE HELP TO RESOLVE THIS ERROR\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n        int j=0;\\n        vector<int> c;\\n\\n        while(i<m && j<n)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                c.push_back(nums2[j]);\\n                j++;\\n            }\\n            else\\n             {\\n                c.push_back(nums1[i]);\\n                i++;\\n            } \\n        }\\n        while(j<m)\\n        {\\n            c.push_back(nums2[j]);\\n                j++;\\n        }\\n\\n        while(i<n)\\n          {\\n                c.push_back(nums1[i]);\\n                i++;\\n         } \\n         copy(c.begin(), c.end(), back_inserter(nums1)); \\n    }"
                    },
                    {
                        "username": "clashyraj",
                        "content": "In the 2nd while loop it must be j<n and in 3rd while loop it must be i<m"
                    },
                    {
                        "username": "Charan0911",
                        "content": "        nums1=nums1[0:m]\\n        nums1=nums1+nums2\\n        nums1.sort()\\nWhy can\\'t this code be the solution?"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "Why this solution is showing RUNTIME ERROR?\\n\\nRuntime Error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n `your inline code...your inline code...`\\n class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {   \\n        int j = 0,i;\\n    for( i=0;i<m+n;i++)\\n    {  \\n         if(nums1[i] >= nums2[j] || i>=m)\\n        {\\n            nums1.insert(nums1.begin()+i,nums2[j++]) ;\\n            i++ ;\\n         }\\n    }\\n    }\\n};\\n\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "madhavsaisurya_",
                        "content": "Isnt the testcase invalid? m should be an int not an array right?"
                    },
                    {
                        "username": "sainath81061",
                        "content": "int k = m + n - 1;\n        int j = n - 1;\n        for(int i = m-1;i >= 0;)\n        {\n            if (j == -1)\n            {\n                break;\n            }\n            if (nums1[i] > nums2[j])\n            {\n                nums1[k] = nums1[i];\n                k--;i--;\n            }\n            else\n            {\n                nums1[k] = nums2[j];\n                k--;  j--;  \n            }\n\n        }\n         if(m == 0)\n         {\n            nums1[k] = nums2[j]; \n         }"
                    },
                    {
                        "username": "DaniilAbdulov",
                        "content": "var merge = function(nums1, m, nums2, n) {\\n    let arr = (nums1.slice(0,m).concat(nums2.slice(0,n))).sort( (a, b)=> a-b )\\n    return arr\\n};\\nWHY my code doesn\\'t work ? Tell me, please. Everything works fine in the console."
                    },
                    {
                        "username": "kanmear",
                        "content": "what a dumbass problem. whoever thought that adding leading zeroes AND also using zeroes as actual elements should not be writing any more problems."
                    },
                    {
                        "username": "dunionwagner",
                        "content": "Whats wrong with my code? It says that the output is [1,2,3] but when I printed what i returned, it returned the correct answer?\\n\\nSPOILER\\n\\n\\n\\n\\n\\n\\n\\nclass Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        leng = len(nums1)\\n        leng = leng - 3\\n        j = -1\\n        for counter in range(leng):\\n            nums1.remove(nums1[j])\\n        nums3 = nums1 + nums2\\n        nums3.sort()\\n        print(nums3)\\n        return nums3\\n            "
                    },
                    {
                        "username": "nileshthakur329",
                        "content": "it\\'s basically based on merged sort algorithm, if you are not able to solve this then please try learning merged sort algo(divide and conquer) then try it."
                    },
                    {
                        "username": "user7465gB",
                        "content": "Can someone please tell me why this code works in my IDE, but doesn\\'t give the correct output here? I realize its probably not the fastest method, but it should work no? Sorry if there is something glaringly obvious that I have missed here. Thanks in advance.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        nums1=nums1+nums2\\n        while 0 in nums1:\\n            nums1.remove(0)\\n        nums1.sort(reverse=False)"
                    }
                ]
            },
            {
                "id": 1808618,
                "content": [
                    {
                        "username": "mikem1990",
                        "content": "Hi beginner here, \\n\\ncan someone explain to me why this is wrong: it works in spyder when i plug in the inputs but not here. Thanks.\\n\\n        if len(nums1) - m == 0:\\n            nums1 = nums1\\n        else:\\n            extra = len(nums1) - m\\n            nums1 = nums1[:len(nums1) - extra]\\n            \\n        if len(nums2) - n == 0:\\n            nums2 = nums2    \\n        else:\\n            extra2 = len(nums2) - m\\n            nums2 = nums2[:len(nums2) - extra2]\\n        \\n        nums1 = (sorted(nums1 + nums2))\\n\\n"
                    },
                    {
                        "username": "gillrajender420",
                        "content": "how to handle this case-- Input: nums1 = [0], m = 0, nums2 = [1], n = 1"
                    },
                    {
                        "username": "archit_24",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n     for(int i=0;i<n;i++){\\n       nums1[m++] = nums2[i];\\n                 }\\n    sort(nums1.begin(),nums1.end());\\n    }\\n};\\n   "
                    },
                    {
                        "username": "78shreyasupe",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int[] nums=new int[m+n];\\n       int i=0,j=0,k=1;\\n       while(i<m&&j<n){\\n            if(nums1[i]<nums2[j]){\\n           nums[k]=nums1[i];\\n           i++;\\n           k++;\\n\\n       } \\n       else {\\n           nums[k]=nums[j];\\n           j++;\\n           k++;\\n       }\\n       }\\n        while(j<=n){\\n           nums[k]=nums2[j];\\n           k++;\\n           j++;\\n       }\\n       while(i<=m){\\n           nums[k]=nums1[i];\\n           i++;\\n           k++;\\n\\n       }\\n       \\n      \\n    }\\n}\\n\\ncan anyone please tell me what is wrong with this code"
                    },
                    {
                        "username": "Kishan_Adesara",
                        "content": "C++ Solution\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        for(int i=0;i<n;i++){\\n            nums1.pop_back();\\n        }\\n        for(int i=0;i<n;i++){\\n           nums1.push_back(nums2[i]);\\n        }\\n        sort(nums1.begin(),nums1.end());\\n    }\\n};"
                    },
                    {
                        "username": "giansteve",
                        "content": "can somebody explain me why simply substituting nums1[m:] with nums2 and then sorting does not work? "
                    },
                    {
                        "username": "sverma67",
                        "content": "Why won\\'t this work? If it print nums1, it shows the right result, but the output has something else.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        \\n        copy1=nums1[:m]\\n        nums1=[0]*len(nums1)\\n        idx1,idx2=0,0\\n\\n        for i in range(len(nums1)):\\n            print(nums1)\\n            if idx1>=len(copy1):\\n                nums1[i:]=nums2[idx2:]\\n                print(nums1)\\n                break\\n            if idx2>=len(nums2):\\n                nums1[i:]=copy1[idx1:]\\n                break\\n            if copy1[idx1]<nums2[idx2]:\\n                nums1[i]=copy1[idx1]\\n                idx1+=1\\n            else:\\n                nums1[i]=nums2[idx2]\\n                idx2+=1\\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k = m+n;\\n        List l = new ArrayList();\\n        int num[] =  new int[k];\\n        for(int i=0;i<m;i++){\\n            num[i]=nums1[i];\\n        }\\n        for(int j=0;j<n;j++){\\n            num[m+j]=nums2[j];\\n        }\\n        int min=num[0];\\n\\n        for(int i=0;i<k;i++){\\n            for(int j=i;j<k;j++){\\n                if(num[i]>num[j]){\\n                min = num[j];\\n                num[j]= num[i];\\n                num[i]=min;\\n            }\\n            }\\n        }\\n        for(int i=0;i<k;i++){\\n            nums1[i]= num[i];\\n            System.out.print(num[i]);\\n        }\\n        nums1 = num;\\n       \\n    }\\n}"
                    },
                    {
                        "username": "hirak97",
                        "content": "[@LeetCode](/LeetCode) Why leetCode won\\'t accept this solution?\\n\\npublic void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] res = new int[m+n];\\n        int i=0;\\n        int j=0;\\n        int index = 0;\\n        while(index<m+n){\\n            if(i==m){\\n                res[index++] = nums2[j++];\\n                continue;\\n            }\\n            if(nums1[i]>nums2[j]){\\n                res[index++] = nums2[j++];\\n            }\\n            else{\\n                res[index++] = nums1[i++];\\n            }\\n        }\\n        nums1=res;\\n\\n    }"
                    },
                    {
                        "username": "sanket96",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=m-1,j=n-1;\\n        int ind=m+n-1;\\n        while(i>=0 && j>=0)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                nums1[ind]=nums1[i];\\n                i--;\\n            }\\n            else\\n            {\\n                nums1[ind]=nums2[j];\\n                j--;\\n            }\\n            ind--;\\n        }\\n        while(i>=0)\\n        {\\n            nums1[ind]=nums1[i];\\n            i--;\\n            ind--;\\n        }\\n        while(j>=0)\\n        {\\n            nums1[ind]=nums2[j];\\n            j--;\\n            ind--;\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1807874,
                "content": [
                    {
                        "username": "mikem1990",
                        "content": "Hi beginner here, \\n\\ncan someone explain to me why this is wrong: it works in spyder when i plug in the inputs but not here. Thanks.\\n\\n        if len(nums1) - m == 0:\\n            nums1 = nums1\\n        else:\\n            extra = len(nums1) - m\\n            nums1 = nums1[:len(nums1) - extra]\\n            \\n        if len(nums2) - n == 0:\\n            nums2 = nums2    \\n        else:\\n            extra2 = len(nums2) - m\\n            nums2 = nums2[:len(nums2) - extra2]\\n        \\n        nums1 = (sorted(nums1 + nums2))\\n\\n"
                    },
                    {
                        "username": "gillrajender420",
                        "content": "how to handle this case-- Input: nums1 = [0], m = 0, nums2 = [1], n = 1"
                    },
                    {
                        "username": "archit_24",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n     for(int i=0;i<n;i++){\\n       nums1[m++] = nums2[i];\\n                 }\\n    sort(nums1.begin(),nums1.end());\\n    }\\n};\\n   "
                    },
                    {
                        "username": "78shreyasupe",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int[] nums=new int[m+n];\\n       int i=0,j=0,k=1;\\n       while(i<m&&j<n){\\n            if(nums1[i]<nums2[j]){\\n           nums[k]=nums1[i];\\n           i++;\\n           k++;\\n\\n       } \\n       else {\\n           nums[k]=nums[j];\\n           j++;\\n           k++;\\n       }\\n       }\\n        while(j<=n){\\n           nums[k]=nums2[j];\\n           k++;\\n           j++;\\n       }\\n       while(i<=m){\\n           nums[k]=nums1[i];\\n           i++;\\n           k++;\\n\\n       }\\n       \\n      \\n    }\\n}\\n\\ncan anyone please tell me what is wrong with this code"
                    },
                    {
                        "username": "Kishan_Adesara",
                        "content": "C++ Solution\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        for(int i=0;i<n;i++){\\n            nums1.pop_back();\\n        }\\n        for(int i=0;i<n;i++){\\n           nums1.push_back(nums2[i]);\\n        }\\n        sort(nums1.begin(),nums1.end());\\n    }\\n};"
                    },
                    {
                        "username": "giansteve",
                        "content": "can somebody explain me why simply substituting nums1[m:] with nums2 and then sorting does not work? "
                    },
                    {
                        "username": "sverma67",
                        "content": "Why won\\'t this work? If it print nums1, it shows the right result, but the output has something else.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        \\n        copy1=nums1[:m]\\n        nums1=[0]*len(nums1)\\n        idx1,idx2=0,0\\n\\n        for i in range(len(nums1)):\\n            print(nums1)\\n            if idx1>=len(copy1):\\n                nums1[i:]=nums2[idx2:]\\n                print(nums1)\\n                break\\n            if idx2>=len(nums2):\\n                nums1[i:]=copy1[idx1:]\\n                break\\n            if copy1[idx1]<nums2[idx2]:\\n                nums1[i]=copy1[idx1]\\n                idx1+=1\\n            else:\\n                nums1[i]=nums2[idx2]\\n                idx2+=1\\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k = m+n;\\n        List l = new ArrayList();\\n        int num[] =  new int[k];\\n        for(int i=0;i<m;i++){\\n            num[i]=nums1[i];\\n        }\\n        for(int j=0;j<n;j++){\\n            num[m+j]=nums2[j];\\n        }\\n        int min=num[0];\\n\\n        for(int i=0;i<k;i++){\\n            for(int j=i;j<k;j++){\\n                if(num[i]>num[j]){\\n                min = num[j];\\n                num[j]= num[i];\\n                num[i]=min;\\n            }\\n            }\\n        }\\n        for(int i=0;i<k;i++){\\n            nums1[i]= num[i];\\n            System.out.print(num[i]);\\n        }\\n        nums1 = num;\\n       \\n    }\\n}"
                    },
                    {
                        "username": "hirak97",
                        "content": "[@LeetCode](/LeetCode) Why leetCode won\\'t accept this solution?\\n\\npublic void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] res = new int[m+n];\\n        int i=0;\\n        int j=0;\\n        int index = 0;\\n        while(index<m+n){\\n            if(i==m){\\n                res[index++] = nums2[j++];\\n                continue;\\n            }\\n            if(nums1[i]>nums2[j]){\\n                res[index++] = nums2[j++];\\n            }\\n            else{\\n                res[index++] = nums1[i++];\\n            }\\n        }\\n        nums1=res;\\n\\n    }"
                    },
                    {
                        "username": "sanket96",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=m-1,j=n-1;\\n        int ind=m+n-1;\\n        while(i>=0 && j>=0)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                nums1[ind]=nums1[i];\\n                i--;\\n            }\\n            else\\n            {\\n                nums1[ind]=nums2[j];\\n                j--;\\n            }\\n            ind--;\\n        }\\n        while(i>=0)\\n        {\\n            nums1[ind]=nums1[i];\\n            i--;\\n            ind--;\\n        }\\n        while(j>=0)\\n        {\\n            nums1[ind]=nums2[j];\\n            j--;\\n            ind--;\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1805995,
                "content": [
                    {
                        "username": "mikem1990",
                        "content": "Hi beginner here, \\n\\ncan someone explain to me why this is wrong: it works in spyder when i plug in the inputs but not here. Thanks.\\n\\n        if len(nums1) - m == 0:\\n            nums1 = nums1\\n        else:\\n            extra = len(nums1) - m\\n            nums1 = nums1[:len(nums1) - extra]\\n            \\n        if len(nums2) - n == 0:\\n            nums2 = nums2    \\n        else:\\n            extra2 = len(nums2) - m\\n            nums2 = nums2[:len(nums2) - extra2]\\n        \\n        nums1 = (sorted(nums1 + nums2))\\n\\n"
                    },
                    {
                        "username": "gillrajender420",
                        "content": "how to handle this case-- Input: nums1 = [0], m = 0, nums2 = [1], n = 1"
                    },
                    {
                        "username": "archit_24",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n     for(int i=0;i<n;i++){\\n       nums1[m++] = nums2[i];\\n                 }\\n    sort(nums1.begin(),nums1.end());\\n    }\\n};\\n   "
                    },
                    {
                        "username": "78shreyasupe",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int[] nums=new int[m+n];\\n       int i=0,j=0,k=1;\\n       while(i<m&&j<n){\\n            if(nums1[i]<nums2[j]){\\n           nums[k]=nums1[i];\\n           i++;\\n           k++;\\n\\n       } \\n       else {\\n           nums[k]=nums[j];\\n           j++;\\n           k++;\\n       }\\n       }\\n        while(j<=n){\\n           nums[k]=nums2[j];\\n           k++;\\n           j++;\\n       }\\n       while(i<=m){\\n           nums[k]=nums1[i];\\n           i++;\\n           k++;\\n\\n       }\\n       \\n      \\n    }\\n}\\n\\ncan anyone please tell me what is wrong with this code"
                    },
                    {
                        "username": "Kishan_Adesara",
                        "content": "C++ Solution\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        for(int i=0;i<n;i++){\\n            nums1.pop_back();\\n        }\\n        for(int i=0;i<n;i++){\\n           nums1.push_back(nums2[i]);\\n        }\\n        sort(nums1.begin(),nums1.end());\\n    }\\n};"
                    },
                    {
                        "username": "giansteve",
                        "content": "can somebody explain me why simply substituting nums1[m:] with nums2 and then sorting does not work? "
                    },
                    {
                        "username": "sverma67",
                        "content": "Why won\\'t this work? If it print nums1, it shows the right result, but the output has something else.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        \\n        copy1=nums1[:m]\\n        nums1=[0]*len(nums1)\\n        idx1,idx2=0,0\\n\\n        for i in range(len(nums1)):\\n            print(nums1)\\n            if idx1>=len(copy1):\\n                nums1[i:]=nums2[idx2:]\\n                print(nums1)\\n                break\\n            if idx2>=len(nums2):\\n                nums1[i:]=copy1[idx1:]\\n                break\\n            if copy1[idx1]<nums2[idx2]:\\n                nums1[i]=copy1[idx1]\\n                idx1+=1\\n            else:\\n                nums1[i]=nums2[idx2]\\n                idx2+=1\\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k = m+n;\\n        List l = new ArrayList();\\n        int num[] =  new int[k];\\n        for(int i=0;i<m;i++){\\n            num[i]=nums1[i];\\n        }\\n        for(int j=0;j<n;j++){\\n            num[m+j]=nums2[j];\\n        }\\n        int min=num[0];\\n\\n        for(int i=0;i<k;i++){\\n            for(int j=i;j<k;j++){\\n                if(num[i]>num[j]){\\n                min = num[j];\\n                num[j]= num[i];\\n                num[i]=min;\\n            }\\n            }\\n        }\\n        for(int i=0;i<k;i++){\\n            nums1[i]= num[i];\\n            System.out.print(num[i]);\\n        }\\n        nums1 = num;\\n       \\n    }\\n}"
                    },
                    {
                        "username": "hirak97",
                        "content": "[@LeetCode](/LeetCode) Why leetCode won\\'t accept this solution?\\n\\npublic void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] res = new int[m+n];\\n        int i=0;\\n        int j=0;\\n        int index = 0;\\n        while(index<m+n){\\n            if(i==m){\\n                res[index++] = nums2[j++];\\n                continue;\\n            }\\n            if(nums1[i]>nums2[j]){\\n                res[index++] = nums2[j++];\\n            }\\n            else{\\n                res[index++] = nums1[i++];\\n            }\\n        }\\n        nums1=res;\\n\\n    }"
                    },
                    {
                        "username": "sanket96",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=m-1,j=n-1;\\n        int ind=m+n-1;\\n        while(i>=0 && j>=0)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                nums1[ind]=nums1[i];\\n                i--;\\n            }\\n            else\\n            {\\n                nums1[ind]=nums2[j];\\n                j--;\\n            }\\n            ind--;\\n        }\\n        while(i>=0)\\n        {\\n            nums1[ind]=nums1[i];\\n            i--;\\n            ind--;\\n        }\\n        while(j>=0)\\n        {\\n            nums1[ind]=nums2[j];\\n            j--;\\n            ind--;\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1805107,
                "content": [
                    {
                        "username": "mikem1990",
                        "content": "Hi beginner here, \\n\\ncan someone explain to me why this is wrong: it works in spyder when i plug in the inputs but not here. Thanks.\\n\\n        if len(nums1) - m == 0:\\n            nums1 = nums1\\n        else:\\n            extra = len(nums1) - m\\n            nums1 = nums1[:len(nums1) - extra]\\n            \\n        if len(nums2) - n == 0:\\n            nums2 = nums2    \\n        else:\\n            extra2 = len(nums2) - m\\n            nums2 = nums2[:len(nums2) - extra2]\\n        \\n        nums1 = (sorted(nums1 + nums2))\\n\\n"
                    },
                    {
                        "username": "gillrajender420",
                        "content": "how to handle this case-- Input: nums1 = [0], m = 0, nums2 = [1], n = 1"
                    },
                    {
                        "username": "archit_24",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n     for(int i=0;i<n;i++){\\n       nums1[m++] = nums2[i];\\n                 }\\n    sort(nums1.begin(),nums1.end());\\n    }\\n};\\n   "
                    },
                    {
                        "username": "78shreyasupe",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int[] nums=new int[m+n];\\n       int i=0,j=0,k=1;\\n       while(i<m&&j<n){\\n            if(nums1[i]<nums2[j]){\\n           nums[k]=nums1[i];\\n           i++;\\n           k++;\\n\\n       } \\n       else {\\n           nums[k]=nums[j];\\n           j++;\\n           k++;\\n       }\\n       }\\n        while(j<=n){\\n           nums[k]=nums2[j];\\n           k++;\\n           j++;\\n       }\\n       while(i<=m){\\n           nums[k]=nums1[i];\\n           i++;\\n           k++;\\n\\n       }\\n       \\n      \\n    }\\n}\\n\\ncan anyone please tell me what is wrong with this code"
                    },
                    {
                        "username": "Kishan_Adesara",
                        "content": "C++ Solution\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        for(int i=0;i<n;i++){\\n            nums1.pop_back();\\n        }\\n        for(int i=0;i<n;i++){\\n           nums1.push_back(nums2[i]);\\n        }\\n        sort(nums1.begin(),nums1.end());\\n    }\\n};"
                    },
                    {
                        "username": "giansteve",
                        "content": "can somebody explain me why simply substituting nums1[m:] with nums2 and then sorting does not work? "
                    },
                    {
                        "username": "sverma67",
                        "content": "Why won\\'t this work? If it print nums1, it shows the right result, but the output has something else.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        \\n        copy1=nums1[:m]\\n        nums1=[0]*len(nums1)\\n        idx1,idx2=0,0\\n\\n        for i in range(len(nums1)):\\n            print(nums1)\\n            if idx1>=len(copy1):\\n                nums1[i:]=nums2[idx2:]\\n                print(nums1)\\n                break\\n            if idx2>=len(nums2):\\n                nums1[i:]=copy1[idx1:]\\n                break\\n            if copy1[idx1]<nums2[idx2]:\\n                nums1[i]=copy1[idx1]\\n                idx1+=1\\n            else:\\n                nums1[i]=nums2[idx2]\\n                idx2+=1\\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k = m+n;\\n        List l = new ArrayList();\\n        int num[] =  new int[k];\\n        for(int i=0;i<m;i++){\\n            num[i]=nums1[i];\\n        }\\n        for(int j=0;j<n;j++){\\n            num[m+j]=nums2[j];\\n        }\\n        int min=num[0];\\n\\n        for(int i=0;i<k;i++){\\n            for(int j=i;j<k;j++){\\n                if(num[i]>num[j]){\\n                min = num[j];\\n                num[j]= num[i];\\n                num[i]=min;\\n            }\\n            }\\n        }\\n        for(int i=0;i<k;i++){\\n            nums1[i]= num[i];\\n            System.out.print(num[i]);\\n        }\\n        nums1 = num;\\n       \\n    }\\n}"
                    },
                    {
                        "username": "hirak97",
                        "content": "[@LeetCode](/LeetCode) Why leetCode won\\'t accept this solution?\\n\\npublic void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] res = new int[m+n];\\n        int i=0;\\n        int j=0;\\n        int index = 0;\\n        while(index<m+n){\\n            if(i==m){\\n                res[index++] = nums2[j++];\\n                continue;\\n            }\\n            if(nums1[i]>nums2[j]){\\n                res[index++] = nums2[j++];\\n            }\\n            else{\\n                res[index++] = nums1[i++];\\n            }\\n        }\\n        nums1=res;\\n\\n    }"
                    },
                    {
                        "username": "sanket96",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=m-1,j=n-1;\\n        int ind=m+n-1;\\n        while(i>=0 && j>=0)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                nums1[ind]=nums1[i];\\n                i--;\\n            }\\n            else\\n            {\\n                nums1[ind]=nums2[j];\\n                j--;\\n            }\\n            ind--;\\n        }\\n        while(i>=0)\\n        {\\n            nums1[ind]=nums1[i];\\n            i--;\\n            ind--;\\n        }\\n        while(j>=0)\\n        {\\n            nums1[ind]=nums2[j];\\n            j--;\\n            ind--;\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1801910,
                "content": [
                    {
                        "username": "mikem1990",
                        "content": "Hi beginner here, \\n\\ncan someone explain to me why this is wrong: it works in spyder when i plug in the inputs but not here. Thanks.\\n\\n        if len(nums1) - m == 0:\\n            nums1 = nums1\\n        else:\\n            extra = len(nums1) - m\\n            nums1 = nums1[:len(nums1) - extra]\\n            \\n        if len(nums2) - n == 0:\\n            nums2 = nums2    \\n        else:\\n            extra2 = len(nums2) - m\\n            nums2 = nums2[:len(nums2) - extra2]\\n        \\n        nums1 = (sorted(nums1 + nums2))\\n\\n"
                    },
                    {
                        "username": "gillrajender420",
                        "content": "how to handle this case-- Input: nums1 = [0], m = 0, nums2 = [1], n = 1"
                    },
                    {
                        "username": "archit_24",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n     for(int i=0;i<n;i++){\\n       nums1[m++] = nums2[i];\\n                 }\\n    sort(nums1.begin(),nums1.end());\\n    }\\n};\\n   "
                    },
                    {
                        "username": "78shreyasupe",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int[] nums=new int[m+n];\\n       int i=0,j=0,k=1;\\n       while(i<m&&j<n){\\n            if(nums1[i]<nums2[j]){\\n           nums[k]=nums1[i];\\n           i++;\\n           k++;\\n\\n       } \\n       else {\\n           nums[k]=nums[j];\\n           j++;\\n           k++;\\n       }\\n       }\\n        while(j<=n){\\n           nums[k]=nums2[j];\\n           k++;\\n           j++;\\n       }\\n       while(i<=m){\\n           nums[k]=nums1[i];\\n           i++;\\n           k++;\\n\\n       }\\n       \\n      \\n    }\\n}\\n\\ncan anyone please tell me what is wrong with this code"
                    },
                    {
                        "username": "Kishan_Adesara",
                        "content": "C++ Solution\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        for(int i=0;i<n;i++){\\n            nums1.pop_back();\\n        }\\n        for(int i=0;i<n;i++){\\n           nums1.push_back(nums2[i]);\\n        }\\n        sort(nums1.begin(),nums1.end());\\n    }\\n};"
                    },
                    {
                        "username": "giansteve",
                        "content": "can somebody explain me why simply substituting nums1[m:] with nums2 and then sorting does not work? "
                    },
                    {
                        "username": "sverma67",
                        "content": "Why won\\'t this work? If it print nums1, it shows the right result, but the output has something else.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        \\n        copy1=nums1[:m]\\n        nums1=[0]*len(nums1)\\n        idx1,idx2=0,0\\n\\n        for i in range(len(nums1)):\\n            print(nums1)\\n            if idx1>=len(copy1):\\n                nums1[i:]=nums2[idx2:]\\n                print(nums1)\\n                break\\n            if idx2>=len(nums2):\\n                nums1[i:]=copy1[idx1:]\\n                break\\n            if copy1[idx1]<nums2[idx2]:\\n                nums1[i]=copy1[idx1]\\n                idx1+=1\\n            else:\\n                nums1[i]=nums2[idx2]\\n                idx2+=1\\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k = m+n;\\n        List l = new ArrayList();\\n        int num[] =  new int[k];\\n        for(int i=0;i<m;i++){\\n            num[i]=nums1[i];\\n        }\\n        for(int j=0;j<n;j++){\\n            num[m+j]=nums2[j];\\n        }\\n        int min=num[0];\\n\\n        for(int i=0;i<k;i++){\\n            for(int j=i;j<k;j++){\\n                if(num[i]>num[j]){\\n                min = num[j];\\n                num[j]= num[i];\\n                num[i]=min;\\n            }\\n            }\\n        }\\n        for(int i=0;i<k;i++){\\n            nums1[i]= num[i];\\n            System.out.print(num[i]);\\n        }\\n        nums1 = num;\\n       \\n    }\\n}"
                    },
                    {
                        "username": "hirak97",
                        "content": "[@LeetCode](/LeetCode) Why leetCode won\\'t accept this solution?\\n\\npublic void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] res = new int[m+n];\\n        int i=0;\\n        int j=0;\\n        int index = 0;\\n        while(index<m+n){\\n            if(i==m){\\n                res[index++] = nums2[j++];\\n                continue;\\n            }\\n            if(nums1[i]>nums2[j]){\\n                res[index++] = nums2[j++];\\n            }\\n            else{\\n                res[index++] = nums1[i++];\\n            }\\n        }\\n        nums1=res;\\n\\n    }"
                    },
                    {
                        "username": "sanket96",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=m-1,j=n-1;\\n        int ind=m+n-1;\\n        while(i>=0 && j>=0)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                nums1[ind]=nums1[i];\\n                i--;\\n            }\\n            else\\n            {\\n                nums1[ind]=nums2[j];\\n                j--;\\n            }\\n            ind--;\\n        }\\n        while(i>=0)\\n        {\\n            nums1[ind]=nums1[i];\\n            i--;\\n            ind--;\\n        }\\n        while(j>=0)\\n        {\\n            nums1[ind]=nums2[j];\\n            j--;\\n            ind--;\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1798182,
                "content": [
                    {
                        "username": "mikem1990",
                        "content": "Hi beginner here, \\n\\ncan someone explain to me why this is wrong: it works in spyder when i plug in the inputs but not here. Thanks.\\n\\n        if len(nums1) - m == 0:\\n            nums1 = nums1\\n        else:\\n            extra = len(nums1) - m\\n            nums1 = nums1[:len(nums1) - extra]\\n            \\n        if len(nums2) - n == 0:\\n            nums2 = nums2    \\n        else:\\n            extra2 = len(nums2) - m\\n            nums2 = nums2[:len(nums2) - extra2]\\n        \\n        nums1 = (sorted(nums1 + nums2))\\n\\n"
                    },
                    {
                        "username": "gillrajender420",
                        "content": "how to handle this case-- Input: nums1 = [0], m = 0, nums2 = [1], n = 1"
                    },
                    {
                        "username": "archit_24",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n     for(int i=0;i<n;i++){\\n       nums1[m++] = nums2[i];\\n                 }\\n    sort(nums1.begin(),nums1.end());\\n    }\\n};\\n   "
                    },
                    {
                        "username": "78shreyasupe",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int[] nums=new int[m+n];\\n       int i=0,j=0,k=1;\\n       while(i<m&&j<n){\\n            if(nums1[i]<nums2[j]){\\n           nums[k]=nums1[i];\\n           i++;\\n           k++;\\n\\n       } \\n       else {\\n           nums[k]=nums[j];\\n           j++;\\n           k++;\\n       }\\n       }\\n        while(j<=n){\\n           nums[k]=nums2[j];\\n           k++;\\n           j++;\\n       }\\n       while(i<=m){\\n           nums[k]=nums1[i];\\n           i++;\\n           k++;\\n\\n       }\\n       \\n      \\n    }\\n}\\n\\ncan anyone please tell me what is wrong with this code"
                    },
                    {
                        "username": "Kishan_Adesara",
                        "content": "C++ Solution\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        for(int i=0;i<n;i++){\\n            nums1.pop_back();\\n        }\\n        for(int i=0;i<n;i++){\\n           nums1.push_back(nums2[i]);\\n        }\\n        sort(nums1.begin(),nums1.end());\\n    }\\n};"
                    },
                    {
                        "username": "giansteve",
                        "content": "can somebody explain me why simply substituting nums1[m:] with nums2 and then sorting does not work? "
                    },
                    {
                        "username": "sverma67",
                        "content": "Why won\\'t this work? If it print nums1, it shows the right result, but the output has something else.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        \\n        copy1=nums1[:m]\\n        nums1=[0]*len(nums1)\\n        idx1,idx2=0,0\\n\\n        for i in range(len(nums1)):\\n            print(nums1)\\n            if idx1>=len(copy1):\\n                nums1[i:]=nums2[idx2:]\\n                print(nums1)\\n                break\\n            if idx2>=len(nums2):\\n                nums1[i:]=copy1[idx1:]\\n                break\\n            if copy1[idx1]<nums2[idx2]:\\n                nums1[i]=copy1[idx1]\\n                idx1+=1\\n            else:\\n                nums1[i]=nums2[idx2]\\n                idx2+=1\\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k = m+n;\\n        List l = new ArrayList();\\n        int num[] =  new int[k];\\n        for(int i=0;i<m;i++){\\n            num[i]=nums1[i];\\n        }\\n        for(int j=0;j<n;j++){\\n            num[m+j]=nums2[j];\\n        }\\n        int min=num[0];\\n\\n        for(int i=0;i<k;i++){\\n            for(int j=i;j<k;j++){\\n                if(num[i]>num[j]){\\n                min = num[j];\\n                num[j]= num[i];\\n                num[i]=min;\\n            }\\n            }\\n        }\\n        for(int i=0;i<k;i++){\\n            nums1[i]= num[i];\\n            System.out.print(num[i]);\\n        }\\n        nums1 = num;\\n       \\n    }\\n}"
                    },
                    {
                        "username": "hirak97",
                        "content": "[@LeetCode](/LeetCode) Why leetCode won\\'t accept this solution?\\n\\npublic void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] res = new int[m+n];\\n        int i=0;\\n        int j=0;\\n        int index = 0;\\n        while(index<m+n){\\n            if(i==m){\\n                res[index++] = nums2[j++];\\n                continue;\\n            }\\n            if(nums1[i]>nums2[j]){\\n                res[index++] = nums2[j++];\\n            }\\n            else{\\n                res[index++] = nums1[i++];\\n            }\\n        }\\n        nums1=res;\\n\\n    }"
                    },
                    {
                        "username": "sanket96",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=m-1,j=n-1;\\n        int ind=m+n-1;\\n        while(i>=0 && j>=0)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                nums1[ind]=nums1[i];\\n                i--;\\n            }\\n            else\\n            {\\n                nums1[ind]=nums2[j];\\n                j--;\\n            }\\n            ind--;\\n        }\\n        while(i>=0)\\n        {\\n            nums1[ind]=nums1[i];\\n            i--;\\n            ind--;\\n        }\\n        while(j>=0)\\n        {\\n            nums1[ind]=nums2[j];\\n            j--;\\n            ind--;\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1795307,
                "content": [
                    {
                        "username": "mikem1990",
                        "content": "Hi beginner here, \\n\\ncan someone explain to me why this is wrong: it works in spyder when i plug in the inputs but not here. Thanks.\\n\\n        if len(nums1) - m == 0:\\n            nums1 = nums1\\n        else:\\n            extra = len(nums1) - m\\n            nums1 = nums1[:len(nums1) - extra]\\n            \\n        if len(nums2) - n == 0:\\n            nums2 = nums2    \\n        else:\\n            extra2 = len(nums2) - m\\n            nums2 = nums2[:len(nums2) - extra2]\\n        \\n        nums1 = (sorted(nums1 + nums2))\\n\\n"
                    },
                    {
                        "username": "gillrajender420",
                        "content": "how to handle this case-- Input: nums1 = [0], m = 0, nums2 = [1], n = 1"
                    },
                    {
                        "username": "archit_24",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n     for(int i=0;i<n;i++){\\n       nums1[m++] = nums2[i];\\n                 }\\n    sort(nums1.begin(),nums1.end());\\n    }\\n};\\n   "
                    },
                    {
                        "username": "78shreyasupe",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int[] nums=new int[m+n];\\n       int i=0,j=0,k=1;\\n       while(i<m&&j<n){\\n            if(nums1[i]<nums2[j]){\\n           nums[k]=nums1[i];\\n           i++;\\n           k++;\\n\\n       } \\n       else {\\n           nums[k]=nums[j];\\n           j++;\\n           k++;\\n       }\\n       }\\n        while(j<=n){\\n           nums[k]=nums2[j];\\n           k++;\\n           j++;\\n       }\\n       while(i<=m){\\n           nums[k]=nums1[i];\\n           i++;\\n           k++;\\n\\n       }\\n       \\n      \\n    }\\n}\\n\\ncan anyone please tell me what is wrong with this code"
                    },
                    {
                        "username": "Kishan_Adesara",
                        "content": "C++ Solution\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        for(int i=0;i<n;i++){\\n            nums1.pop_back();\\n        }\\n        for(int i=0;i<n;i++){\\n           nums1.push_back(nums2[i]);\\n        }\\n        sort(nums1.begin(),nums1.end());\\n    }\\n};"
                    },
                    {
                        "username": "giansteve",
                        "content": "can somebody explain me why simply substituting nums1[m:] with nums2 and then sorting does not work? "
                    },
                    {
                        "username": "sverma67",
                        "content": "Why won\\'t this work? If it print nums1, it shows the right result, but the output has something else.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        \\n        copy1=nums1[:m]\\n        nums1=[0]*len(nums1)\\n        idx1,idx2=0,0\\n\\n        for i in range(len(nums1)):\\n            print(nums1)\\n            if idx1>=len(copy1):\\n                nums1[i:]=nums2[idx2:]\\n                print(nums1)\\n                break\\n            if idx2>=len(nums2):\\n                nums1[i:]=copy1[idx1:]\\n                break\\n            if copy1[idx1]<nums2[idx2]:\\n                nums1[i]=copy1[idx1]\\n                idx1+=1\\n            else:\\n                nums1[i]=nums2[idx2]\\n                idx2+=1\\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k = m+n;\\n        List l = new ArrayList();\\n        int num[] =  new int[k];\\n        for(int i=0;i<m;i++){\\n            num[i]=nums1[i];\\n        }\\n        for(int j=0;j<n;j++){\\n            num[m+j]=nums2[j];\\n        }\\n        int min=num[0];\\n\\n        for(int i=0;i<k;i++){\\n            for(int j=i;j<k;j++){\\n                if(num[i]>num[j]){\\n                min = num[j];\\n                num[j]= num[i];\\n                num[i]=min;\\n            }\\n            }\\n        }\\n        for(int i=0;i<k;i++){\\n            nums1[i]= num[i];\\n            System.out.print(num[i]);\\n        }\\n        nums1 = num;\\n       \\n    }\\n}"
                    },
                    {
                        "username": "hirak97",
                        "content": "[@LeetCode](/LeetCode) Why leetCode won\\'t accept this solution?\\n\\npublic void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] res = new int[m+n];\\n        int i=0;\\n        int j=0;\\n        int index = 0;\\n        while(index<m+n){\\n            if(i==m){\\n                res[index++] = nums2[j++];\\n                continue;\\n            }\\n            if(nums1[i]>nums2[j]){\\n                res[index++] = nums2[j++];\\n            }\\n            else{\\n                res[index++] = nums1[i++];\\n            }\\n        }\\n        nums1=res;\\n\\n    }"
                    },
                    {
                        "username": "sanket96",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=m-1,j=n-1;\\n        int ind=m+n-1;\\n        while(i>=0 && j>=0)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                nums1[ind]=nums1[i];\\n                i--;\\n            }\\n            else\\n            {\\n                nums1[ind]=nums2[j];\\n                j--;\\n            }\\n            ind--;\\n        }\\n        while(i>=0)\\n        {\\n            nums1[ind]=nums1[i];\\n            i--;\\n            ind--;\\n        }\\n        while(j>=0)\\n        {\\n            nums1[ind]=nums2[j];\\n            j--;\\n            ind--;\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1795005,
                "content": [
                    {
                        "username": "mikem1990",
                        "content": "Hi beginner here, \\n\\ncan someone explain to me why this is wrong: it works in spyder when i plug in the inputs but not here. Thanks.\\n\\n        if len(nums1) - m == 0:\\n            nums1 = nums1\\n        else:\\n            extra = len(nums1) - m\\n            nums1 = nums1[:len(nums1) - extra]\\n            \\n        if len(nums2) - n == 0:\\n            nums2 = nums2    \\n        else:\\n            extra2 = len(nums2) - m\\n            nums2 = nums2[:len(nums2) - extra2]\\n        \\n        nums1 = (sorted(nums1 + nums2))\\n\\n"
                    },
                    {
                        "username": "gillrajender420",
                        "content": "how to handle this case-- Input: nums1 = [0], m = 0, nums2 = [1], n = 1"
                    },
                    {
                        "username": "archit_24",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n     for(int i=0;i<n;i++){\\n       nums1[m++] = nums2[i];\\n                 }\\n    sort(nums1.begin(),nums1.end());\\n    }\\n};\\n   "
                    },
                    {
                        "username": "78shreyasupe",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int[] nums=new int[m+n];\\n       int i=0,j=0,k=1;\\n       while(i<m&&j<n){\\n            if(nums1[i]<nums2[j]){\\n           nums[k]=nums1[i];\\n           i++;\\n           k++;\\n\\n       } \\n       else {\\n           nums[k]=nums[j];\\n           j++;\\n           k++;\\n       }\\n       }\\n        while(j<=n){\\n           nums[k]=nums2[j];\\n           k++;\\n           j++;\\n       }\\n       while(i<=m){\\n           nums[k]=nums1[i];\\n           i++;\\n           k++;\\n\\n       }\\n       \\n      \\n    }\\n}\\n\\ncan anyone please tell me what is wrong with this code"
                    },
                    {
                        "username": "Kishan_Adesara",
                        "content": "C++ Solution\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        for(int i=0;i<n;i++){\\n            nums1.pop_back();\\n        }\\n        for(int i=0;i<n;i++){\\n           nums1.push_back(nums2[i]);\\n        }\\n        sort(nums1.begin(),nums1.end());\\n    }\\n};"
                    },
                    {
                        "username": "giansteve",
                        "content": "can somebody explain me why simply substituting nums1[m:] with nums2 and then sorting does not work? "
                    },
                    {
                        "username": "sverma67",
                        "content": "Why won\\'t this work? If it print nums1, it shows the right result, but the output has something else.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        \\n        copy1=nums1[:m]\\n        nums1=[0]*len(nums1)\\n        idx1,idx2=0,0\\n\\n        for i in range(len(nums1)):\\n            print(nums1)\\n            if idx1>=len(copy1):\\n                nums1[i:]=nums2[idx2:]\\n                print(nums1)\\n                break\\n            if idx2>=len(nums2):\\n                nums1[i:]=copy1[idx1:]\\n                break\\n            if copy1[idx1]<nums2[idx2]:\\n                nums1[i]=copy1[idx1]\\n                idx1+=1\\n            else:\\n                nums1[i]=nums2[idx2]\\n                idx2+=1\\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k = m+n;\\n        List l = new ArrayList();\\n        int num[] =  new int[k];\\n        for(int i=0;i<m;i++){\\n            num[i]=nums1[i];\\n        }\\n        for(int j=0;j<n;j++){\\n            num[m+j]=nums2[j];\\n        }\\n        int min=num[0];\\n\\n        for(int i=0;i<k;i++){\\n            for(int j=i;j<k;j++){\\n                if(num[i]>num[j]){\\n                min = num[j];\\n                num[j]= num[i];\\n                num[i]=min;\\n            }\\n            }\\n        }\\n        for(int i=0;i<k;i++){\\n            nums1[i]= num[i];\\n            System.out.print(num[i]);\\n        }\\n        nums1 = num;\\n       \\n    }\\n}"
                    },
                    {
                        "username": "hirak97",
                        "content": "[@LeetCode](/LeetCode) Why leetCode won\\'t accept this solution?\\n\\npublic void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] res = new int[m+n];\\n        int i=0;\\n        int j=0;\\n        int index = 0;\\n        while(index<m+n){\\n            if(i==m){\\n                res[index++] = nums2[j++];\\n                continue;\\n            }\\n            if(nums1[i]>nums2[j]){\\n                res[index++] = nums2[j++];\\n            }\\n            else{\\n                res[index++] = nums1[i++];\\n            }\\n        }\\n        nums1=res;\\n\\n    }"
                    },
                    {
                        "username": "sanket96",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=m-1,j=n-1;\\n        int ind=m+n-1;\\n        while(i>=0 && j>=0)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                nums1[ind]=nums1[i];\\n                i--;\\n            }\\n            else\\n            {\\n                nums1[ind]=nums2[j];\\n                j--;\\n            }\\n            ind--;\\n        }\\n        while(i>=0)\\n        {\\n            nums1[ind]=nums1[i];\\n            i--;\\n            ind--;\\n        }\\n        while(j>=0)\\n        {\\n            nums1[ind]=nums2[j];\\n            j--;\\n            ind--;\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1794166,
                "content": [
                    {
                        "username": "mikem1990",
                        "content": "Hi beginner here, \\n\\ncan someone explain to me why this is wrong: it works in spyder when i plug in the inputs but not here. Thanks.\\n\\n        if len(nums1) - m == 0:\\n            nums1 = nums1\\n        else:\\n            extra = len(nums1) - m\\n            nums1 = nums1[:len(nums1) - extra]\\n            \\n        if len(nums2) - n == 0:\\n            nums2 = nums2    \\n        else:\\n            extra2 = len(nums2) - m\\n            nums2 = nums2[:len(nums2) - extra2]\\n        \\n        nums1 = (sorted(nums1 + nums2))\\n\\n"
                    },
                    {
                        "username": "gillrajender420",
                        "content": "how to handle this case-- Input: nums1 = [0], m = 0, nums2 = [1], n = 1"
                    },
                    {
                        "username": "archit_24",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n     for(int i=0;i<n;i++){\\n       nums1[m++] = nums2[i];\\n                 }\\n    sort(nums1.begin(),nums1.end());\\n    }\\n};\\n   "
                    },
                    {
                        "username": "78shreyasupe",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int[] nums=new int[m+n];\\n       int i=0,j=0,k=1;\\n       while(i<m&&j<n){\\n            if(nums1[i]<nums2[j]){\\n           nums[k]=nums1[i];\\n           i++;\\n           k++;\\n\\n       } \\n       else {\\n           nums[k]=nums[j];\\n           j++;\\n           k++;\\n       }\\n       }\\n        while(j<=n){\\n           nums[k]=nums2[j];\\n           k++;\\n           j++;\\n       }\\n       while(i<=m){\\n           nums[k]=nums1[i];\\n           i++;\\n           k++;\\n\\n       }\\n       \\n      \\n    }\\n}\\n\\ncan anyone please tell me what is wrong with this code"
                    },
                    {
                        "username": "Kishan_Adesara",
                        "content": "C++ Solution\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        for(int i=0;i<n;i++){\\n            nums1.pop_back();\\n        }\\n        for(int i=0;i<n;i++){\\n           nums1.push_back(nums2[i]);\\n        }\\n        sort(nums1.begin(),nums1.end());\\n    }\\n};"
                    },
                    {
                        "username": "giansteve",
                        "content": "can somebody explain me why simply substituting nums1[m:] with nums2 and then sorting does not work? "
                    },
                    {
                        "username": "sverma67",
                        "content": "Why won\\'t this work? If it print nums1, it shows the right result, but the output has something else.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        \\n        copy1=nums1[:m]\\n        nums1=[0]*len(nums1)\\n        idx1,idx2=0,0\\n\\n        for i in range(len(nums1)):\\n            print(nums1)\\n            if idx1>=len(copy1):\\n                nums1[i:]=nums2[idx2:]\\n                print(nums1)\\n                break\\n            if idx2>=len(nums2):\\n                nums1[i:]=copy1[idx1:]\\n                break\\n            if copy1[idx1]<nums2[idx2]:\\n                nums1[i]=copy1[idx1]\\n                idx1+=1\\n            else:\\n                nums1[i]=nums2[idx2]\\n                idx2+=1\\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k = m+n;\\n        List l = new ArrayList();\\n        int num[] =  new int[k];\\n        for(int i=0;i<m;i++){\\n            num[i]=nums1[i];\\n        }\\n        for(int j=0;j<n;j++){\\n            num[m+j]=nums2[j];\\n        }\\n        int min=num[0];\\n\\n        for(int i=0;i<k;i++){\\n            for(int j=i;j<k;j++){\\n                if(num[i]>num[j]){\\n                min = num[j];\\n                num[j]= num[i];\\n                num[i]=min;\\n            }\\n            }\\n        }\\n        for(int i=0;i<k;i++){\\n            nums1[i]= num[i];\\n            System.out.print(num[i]);\\n        }\\n        nums1 = num;\\n       \\n    }\\n}"
                    },
                    {
                        "username": "hirak97",
                        "content": "[@LeetCode](/LeetCode) Why leetCode won\\'t accept this solution?\\n\\npublic void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] res = new int[m+n];\\n        int i=0;\\n        int j=0;\\n        int index = 0;\\n        while(index<m+n){\\n            if(i==m){\\n                res[index++] = nums2[j++];\\n                continue;\\n            }\\n            if(nums1[i]>nums2[j]){\\n                res[index++] = nums2[j++];\\n            }\\n            else{\\n                res[index++] = nums1[i++];\\n            }\\n        }\\n        nums1=res;\\n\\n    }"
                    },
                    {
                        "username": "sanket96",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=m-1,j=n-1;\\n        int ind=m+n-1;\\n        while(i>=0 && j>=0)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                nums1[ind]=nums1[i];\\n                i--;\\n            }\\n            else\\n            {\\n                nums1[ind]=nums2[j];\\n                j--;\\n            }\\n            ind--;\\n        }\\n        while(i>=0)\\n        {\\n            nums1[ind]=nums1[i];\\n            i--;\\n            ind--;\\n        }\\n        while(j>=0)\\n        {\\n            nums1[ind]=nums2[j];\\n            j--;\\n            ind--;\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1790724,
                "content": [
                    {
                        "username": "mikem1990",
                        "content": "Hi beginner here, \\n\\ncan someone explain to me why this is wrong: it works in spyder when i plug in the inputs but not here. Thanks.\\n\\n        if len(nums1) - m == 0:\\n            nums1 = nums1\\n        else:\\n            extra = len(nums1) - m\\n            nums1 = nums1[:len(nums1) - extra]\\n            \\n        if len(nums2) - n == 0:\\n            nums2 = nums2    \\n        else:\\n            extra2 = len(nums2) - m\\n            nums2 = nums2[:len(nums2) - extra2]\\n        \\n        nums1 = (sorted(nums1 + nums2))\\n\\n"
                    },
                    {
                        "username": "gillrajender420",
                        "content": "how to handle this case-- Input: nums1 = [0], m = 0, nums2 = [1], n = 1"
                    },
                    {
                        "username": "archit_24",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n     for(int i=0;i<n;i++){\\n       nums1[m++] = nums2[i];\\n                 }\\n    sort(nums1.begin(),nums1.end());\\n    }\\n};\\n   "
                    },
                    {
                        "username": "78shreyasupe",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int[] nums=new int[m+n];\\n       int i=0,j=0,k=1;\\n       while(i<m&&j<n){\\n            if(nums1[i]<nums2[j]){\\n           nums[k]=nums1[i];\\n           i++;\\n           k++;\\n\\n       } \\n       else {\\n           nums[k]=nums[j];\\n           j++;\\n           k++;\\n       }\\n       }\\n        while(j<=n){\\n           nums[k]=nums2[j];\\n           k++;\\n           j++;\\n       }\\n       while(i<=m){\\n           nums[k]=nums1[i];\\n           i++;\\n           k++;\\n\\n       }\\n       \\n      \\n    }\\n}\\n\\ncan anyone please tell me what is wrong with this code"
                    },
                    {
                        "username": "Kishan_Adesara",
                        "content": "C++ Solution\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        for(int i=0;i<n;i++){\\n            nums1.pop_back();\\n        }\\n        for(int i=0;i<n;i++){\\n           nums1.push_back(nums2[i]);\\n        }\\n        sort(nums1.begin(),nums1.end());\\n    }\\n};"
                    },
                    {
                        "username": "giansteve",
                        "content": "can somebody explain me why simply substituting nums1[m:] with nums2 and then sorting does not work? "
                    },
                    {
                        "username": "sverma67",
                        "content": "Why won\\'t this work? If it print nums1, it shows the right result, but the output has something else.\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        \\n        copy1=nums1[:m]\\n        nums1=[0]*len(nums1)\\n        idx1,idx2=0,0\\n\\n        for i in range(len(nums1)):\\n            print(nums1)\\n            if idx1>=len(copy1):\\n                nums1[i:]=nums2[idx2:]\\n                print(nums1)\\n                break\\n            if idx2>=len(nums2):\\n                nums1[i:]=copy1[idx1:]\\n                break\\n            if copy1[idx1]<nums2[idx2]:\\n                nums1[i]=copy1[idx1]\\n                idx1+=1\\n            else:\\n                nums1[i]=nums2[idx2]\\n                idx2+=1\\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k = m+n;\\n        List l = new ArrayList();\\n        int num[] =  new int[k];\\n        for(int i=0;i<m;i++){\\n            num[i]=nums1[i];\\n        }\\n        for(int j=0;j<n;j++){\\n            num[m+j]=nums2[j];\\n        }\\n        int min=num[0];\\n\\n        for(int i=0;i<k;i++){\\n            for(int j=i;j<k;j++){\\n                if(num[i]>num[j]){\\n                min = num[j];\\n                num[j]= num[i];\\n                num[i]=min;\\n            }\\n            }\\n        }\\n        for(int i=0;i<k;i++){\\n            nums1[i]= num[i];\\n            System.out.print(num[i]);\\n        }\\n        nums1 = num;\\n       \\n    }\\n}"
                    },
                    {
                        "username": "hirak97",
                        "content": "[@LeetCode](/LeetCode) Why leetCode won\\'t accept this solution?\\n\\npublic void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] res = new int[m+n];\\n        int i=0;\\n        int j=0;\\n        int index = 0;\\n        while(index<m+n){\\n            if(i==m){\\n                res[index++] = nums2[j++];\\n                continue;\\n            }\\n            if(nums1[i]>nums2[j]){\\n                res[index++] = nums2[j++];\\n            }\\n            else{\\n                res[index++] = nums1[i++];\\n            }\\n        }\\n        nums1=res;\\n\\n    }"
                    },
                    {
                        "username": "sanket96",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=m-1,j=n-1;\\n        int ind=m+n-1;\\n        while(i>=0 && j>=0)\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                nums1[ind]=nums1[i];\\n                i--;\\n            }\\n            else\\n            {\\n                nums1[ind]=nums2[j];\\n                j--;\\n            }\\n            ind--;\\n        }\\n        while(i>=0)\\n        {\\n            nums1[ind]=nums1[i];\\n            i--;\\n            ind--;\\n        }\\n        while(j>=0)\\n        {\\n            nums1[ind]=nums2[j];\\n            j--;\\n            ind--;\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1789307,
                "content": [
                    {
                        "username": "duisekovd",
                        "content": "My code fails on testcase `mergt([0], 0, [1], 1)` . Can someone explain why?\\n\\n```\\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        if m == 0:\\n            nums1 = nums2\\n\\n        while m > 0 and n > 0:\\n            if nums1[m - 1] >= nums2[n - 1]:\\n                nums1[n + m - 1] = nums1[m - 1]\\n                m -= 1\\n            else:\\n                nums1[n + m - 1] = nums2[n - 1]\\n                n -= 1\\n```"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "int i = 0;\\n        int j = 0;\\n        List<Integer> ans = new ArrayList<>();\\n        while(j<n && i<m-n ){\\n            if(nums1[i]<=nums2[j]){\\n                ans.add(nums1[i]);\\n                i++;\\n            }\\n            else{\\n                ans.add(nums2[j]);\\n                j++;\\n            }\\n        }\\n        while(i<m-n){\\n            ans.add(nums1[i]);\\n            i++;\\n        }\\n        while(j<n){\\n            ans.add(nums2[j]);\\n            j++;\\n        }\\n        for(int k= 0;k<m;k++){\\n            nums1[k]=ans.get(k);\\n        }\\n\\nWhy this giving me a wrong output ? "
                    },
                    {
                        "username": "jadibdev",
                        "content": "I\\'m failing testcase1 nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 ... my output is [1, 2, 2, 3, 5, 6] but leetcode says my output is [1,2,3,0,0,0] which is not correct, I even asked GPT and it generated the following \"It appears that the LeetCode test case is incorrect. Based on your output, it looks like your code is indeed working as intended, and you are getting the expected result of [1, 2, 2, 3, 5, 6]. I would suggest reaching out to LeetCode support to report this issue and see if it can be corrected\" ... am I missing something here or is the test case on LeetCode wrong?`var merge = function(nums1, m, nums2, n) {\\n    temp = nums1.slice(0, m);\\n    console.log(\\'nums1 from argument\\', nums1)\\n    for (let i = 0; i < nums2.length; i++) {\\n        let index = nums2[i] - 1;\\n        temp.splice(index, 0, nums2[i])\\n    }\\n    nums1 = temp\\n    console.log(nums1)\\n};`\" "
                    },
                    {
                        "username": "smit_02",
                        "content": "Can anyone tell me why this solution is not accepted \\n\\nclass Solution {\\n    fun merge(nums1: IntArray, m: Int, nums2: IntArray, n: Int): Unit {\\n        val arr = Array<Int>(m+n){0}\\n\\n        for(i in 0 until m){\\n            arr[i] = nums1[i]\\n        }\\n        for(j in 0 until n){\\n            arr[m+j] = nums2[j]\\n        }\\n        arr.sort()\\n    }\\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        \\n          \\n        int k=0;\\n        int l=0;\\n\\n        int[] arr = new int[nums1.length];\\n\\n        for(int i=0;i<nums1.length;i++){\\n            if (nums2.length == 0) {break;}\\n\\n            if(nums1[k] <= nums2[l]){\\n                if (nums1[k] == 0 && nums2.length > 0){\\n                    arr[i] = nums2[l];\\n                    l++;\\n                    continue;\\n                }\\n                arr[i] = nums1[k];\\n                k++;\\n            }else {\\n                if (nums2[l] == 0 && nums2.length > 0){\\n                    arr[i] = nums1[k];\\n                    k++;\\n                    continue;\\n                }\\n                arr[i] = nums2[l];\\n                l++;\\n            }\\n        }\\n\\n        for(int i=0;i<nums1.length;i++){\\n            nums1[i] = arr[i];\\n        }\\n\\n        for(int i=0;i<nums1.length;i++){\\n            System.out.print(nums1[i] + \" \");\\n        }\\n\\n            }\\n        }\\n\\n\\n\\n\\nMy Solution still case 2 is not satisfied"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@gautamsingh01591999](/gautamsingh01591999) i could do this but i thought it is too Convienent to do so i didnt use it -> Arrays.sort()"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int i=m;\\n        int j=0;\\n        while(i<nums1.length)\\n        {\\n            nums1[i]=nums2[j];\\n            i++;\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n    }"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "Because of First condition where you use break when nums2==0 it break the whole loop  and come to 2nd for loop."
                    },
                    {
                        "username": "Coder15091999",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int i=m;\\n        int j=0;\\n        while(i<nums1.length)\\n        {\\n            nums1[i]=nums2[j];\\n            i++;\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n    }"
                    },
                    {
                        "username": "vivekcoool21",
                        "content": "Hi, I am below runtime error on my code. Can anyone help what\\'s wrong in this?\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n`class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int i=0,j=0,tmp=0;\\n        \\n        while(i<nums1.size() && j<nums2.size()){\\n\\n            cout<<\"nums1[i]: \"<<nums1[i]<<\" nums2[j]: \"<<nums2[j]<<endl;\\n\\n            if(nums1[i]>nums2[j]){\\n\\n                tmp = nums1[i];\\n                nums1[i] = nums2[j];\\n                nums2[j] = tmp;\\n                j++;\\n            }\\n            else\\n                i++;\\n\\n            if(i == m)\\n                break;\\n\\n        }\\n\\n        for(j=0; i<nums1.size(); i++,j++){\\n\\n            nums1[i] = nums2[j];\\n        }\\n\\n        for(int t=0; t<nums1.size(); t++){\\n\\n            cout<<nums1[t]<<\" \";\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "sHaan27",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1, j = n - 1, k = m + n - 1;\\n\\n        for(; i >=0 && j >=0; k--){\\n            if(nums1[i] >= nums2[j]){\\n                nums1[k] = nums1[i--];\\n            } else {\\n                nums1[k] = nums2[j--];\\n            }\\n        }\\n\\n\\n        while(i >= 0) {\\n            nums1[k--] = nums1[i--];\\n        }\\n\\n        while(j >= 0) {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "nevil844",
                        "content": "As a python coder, I hate this approach. It can be done in lot easier way"
                    },
                    {
                        "username": "nix24",
                        "content": "why is it when I use the filter method and sort, it works in vscode but not on leetcode. I filter nums1 and 2 by m and n respectively. then i use a for loop to push nums2 to nums1. then I simply sort nums. But it leaves nums1 completely unchanged. "
                    }
                ]
            },
            {
                "id": 1788798,
                "content": [
                    {
                        "username": "duisekovd",
                        "content": "My code fails on testcase `mergt([0], 0, [1], 1)` . Can someone explain why?\\n\\n```\\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        if m == 0:\\n            nums1 = nums2\\n\\n        while m > 0 and n > 0:\\n            if nums1[m - 1] >= nums2[n - 1]:\\n                nums1[n + m - 1] = nums1[m - 1]\\n                m -= 1\\n            else:\\n                nums1[n + m - 1] = nums2[n - 1]\\n                n -= 1\\n```"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "int i = 0;\\n        int j = 0;\\n        List<Integer> ans = new ArrayList<>();\\n        while(j<n && i<m-n ){\\n            if(nums1[i]<=nums2[j]){\\n                ans.add(nums1[i]);\\n                i++;\\n            }\\n            else{\\n                ans.add(nums2[j]);\\n                j++;\\n            }\\n        }\\n        while(i<m-n){\\n            ans.add(nums1[i]);\\n            i++;\\n        }\\n        while(j<n){\\n            ans.add(nums2[j]);\\n            j++;\\n        }\\n        for(int k= 0;k<m;k++){\\n            nums1[k]=ans.get(k);\\n        }\\n\\nWhy this giving me a wrong output ? "
                    },
                    {
                        "username": "jadibdev",
                        "content": "I\\'m failing testcase1 nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 ... my output is [1, 2, 2, 3, 5, 6] but leetcode says my output is [1,2,3,0,0,0] which is not correct, I even asked GPT and it generated the following \"It appears that the LeetCode test case is incorrect. Based on your output, it looks like your code is indeed working as intended, and you are getting the expected result of [1, 2, 2, 3, 5, 6]. I would suggest reaching out to LeetCode support to report this issue and see if it can be corrected\" ... am I missing something here or is the test case on LeetCode wrong?`var merge = function(nums1, m, nums2, n) {\\n    temp = nums1.slice(0, m);\\n    console.log(\\'nums1 from argument\\', nums1)\\n    for (let i = 0; i < nums2.length; i++) {\\n        let index = nums2[i] - 1;\\n        temp.splice(index, 0, nums2[i])\\n    }\\n    nums1 = temp\\n    console.log(nums1)\\n};`\" "
                    },
                    {
                        "username": "smit_02",
                        "content": "Can anyone tell me why this solution is not accepted \\n\\nclass Solution {\\n    fun merge(nums1: IntArray, m: Int, nums2: IntArray, n: Int): Unit {\\n        val arr = Array<Int>(m+n){0}\\n\\n        for(i in 0 until m){\\n            arr[i] = nums1[i]\\n        }\\n        for(j in 0 until n){\\n            arr[m+j] = nums2[j]\\n        }\\n        arr.sort()\\n    }\\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        \\n          \\n        int k=0;\\n        int l=0;\\n\\n        int[] arr = new int[nums1.length];\\n\\n        for(int i=0;i<nums1.length;i++){\\n            if (nums2.length == 0) {break;}\\n\\n            if(nums1[k] <= nums2[l]){\\n                if (nums1[k] == 0 && nums2.length > 0){\\n                    arr[i] = nums2[l];\\n                    l++;\\n                    continue;\\n                }\\n                arr[i] = nums1[k];\\n                k++;\\n            }else {\\n                if (nums2[l] == 0 && nums2.length > 0){\\n                    arr[i] = nums1[k];\\n                    k++;\\n                    continue;\\n                }\\n                arr[i] = nums2[l];\\n                l++;\\n            }\\n        }\\n\\n        for(int i=0;i<nums1.length;i++){\\n            nums1[i] = arr[i];\\n        }\\n\\n        for(int i=0;i<nums1.length;i++){\\n            System.out.print(nums1[i] + \" \");\\n        }\\n\\n            }\\n        }\\n\\n\\n\\n\\nMy Solution still case 2 is not satisfied"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@gautamsingh01591999](/gautamsingh01591999) i could do this but i thought it is too Convienent to do so i didnt use it -> Arrays.sort()"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int i=m;\\n        int j=0;\\n        while(i<nums1.length)\\n        {\\n            nums1[i]=nums2[j];\\n            i++;\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n    }"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "Because of First condition where you use break when nums2==0 it break the whole loop  and come to 2nd for loop."
                    },
                    {
                        "username": "Coder15091999",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int i=m;\\n        int j=0;\\n        while(i<nums1.length)\\n        {\\n            nums1[i]=nums2[j];\\n            i++;\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n    }"
                    },
                    {
                        "username": "vivekcoool21",
                        "content": "Hi, I am below runtime error on my code. Can anyone help what\\'s wrong in this?\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n`class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int i=0,j=0,tmp=0;\\n        \\n        while(i<nums1.size() && j<nums2.size()){\\n\\n            cout<<\"nums1[i]: \"<<nums1[i]<<\" nums2[j]: \"<<nums2[j]<<endl;\\n\\n            if(nums1[i]>nums2[j]){\\n\\n                tmp = nums1[i];\\n                nums1[i] = nums2[j];\\n                nums2[j] = tmp;\\n                j++;\\n            }\\n            else\\n                i++;\\n\\n            if(i == m)\\n                break;\\n\\n        }\\n\\n        for(j=0; i<nums1.size(); i++,j++){\\n\\n            nums1[i] = nums2[j];\\n        }\\n\\n        for(int t=0; t<nums1.size(); t++){\\n\\n            cout<<nums1[t]<<\" \";\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "sHaan27",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1, j = n - 1, k = m + n - 1;\\n\\n        for(; i >=0 && j >=0; k--){\\n            if(nums1[i] >= nums2[j]){\\n                nums1[k] = nums1[i--];\\n            } else {\\n                nums1[k] = nums2[j--];\\n            }\\n        }\\n\\n\\n        while(i >= 0) {\\n            nums1[k--] = nums1[i--];\\n        }\\n\\n        while(j >= 0) {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "nevil844",
                        "content": "As a python coder, I hate this approach. It can be done in lot easier way"
                    },
                    {
                        "username": "nix24",
                        "content": "why is it when I use the filter method and sort, it works in vscode but not on leetcode. I filter nums1 and 2 by m and n respectively. then i use a for loop to push nums2 to nums1. then I simply sort nums. But it leaves nums1 completely unchanged. "
                    }
                ]
            },
            {
                "id": 1787036,
                "content": [
                    {
                        "username": "duisekovd",
                        "content": "My code fails on testcase `mergt([0], 0, [1], 1)` . Can someone explain why?\\n\\n```\\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        if m == 0:\\n            nums1 = nums2\\n\\n        while m > 0 and n > 0:\\n            if nums1[m - 1] >= nums2[n - 1]:\\n                nums1[n + m - 1] = nums1[m - 1]\\n                m -= 1\\n            else:\\n                nums1[n + m - 1] = nums2[n - 1]\\n                n -= 1\\n```"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "int i = 0;\\n        int j = 0;\\n        List<Integer> ans = new ArrayList<>();\\n        while(j<n && i<m-n ){\\n            if(nums1[i]<=nums2[j]){\\n                ans.add(nums1[i]);\\n                i++;\\n            }\\n            else{\\n                ans.add(nums2[j]);\\n                j++;\\n            }\\n        }\\n        while(i<m-n){\\n            ans.add(nums1[i]);\\n            i++;\\n        }\\n        while(j<n){\\n            ans.add(nums2[j]);\\n            j++;\\n        }\\n        for(int k= 0;k<m;k++){\\n            nums1[k]=ans.get(k);\\n        }\\n\\nWhy this giving me a wrong output ? "
                    },
                    {
                        "username": "jadibdev",
                        "content": "I\\'m failing testcase1 nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 ... my output is [1, 2, 2, 3, 5, 6] but leetcode says my output is [1,2,3,0,0,0] which is not correct, I even asked GPT and it generated the following \"It appears that the LeetCode test case is incorrect. Based on your output, it looks like your code is indeed working as intended, and you are getting the expected result of [1, 2, 2, 3, 5, 6]. I would suggest reaching out to LeetCode support to report this issue and see if it can be corrected\" ... am I missing something here or is the test case on LeetCode wrong?`var merge = function(nums1, m, nums2, n) {\\n    temp = nums1.slice(0, m);\\n    console.log(\\'nums1 from argument\\', nums1)\\n    for (let i = 0; i < nums2.length; i++) {\\n        let index = nums2[i] - 1;\\n        temp.splice(index, 0, nums2[i])\\n    }\\n    nums1 = temp\\n    console.log(nums1)\\n};`\" "
                    },
                    {
                        "username": "smit_02",
                        "content": "Can anyone tell me why this solution is not accepted \\n\\nclass Solution {\\n    fun merge(nums1: IntArray, m: Int, nums2: IntArray, n: Int): Unit {\\n        val arr = Array<Int>(m+n){0}\\n\\n        for(i in 0 until m){\\n            arr[i] = nums1[i]\\n        }\\n        for(j in 0 until n){\\n            arr[m+j] = nums2[j]\\n        }\\n        arr.sort()\\n    }\\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        \\n          \\n        int k=0;\\n        int l=0;\\n\\n        int[] arr = new int[nums1.length];\\n\\n        for(int i=0;i<nums1.length;i++){\\n            if (nums2.length == 0) {break;}\\n\\n            if(nums1[k] <= nums2[l]){\\n                if (nums1[k] == 0 && nums2.length > 0){\\n                    arr[i] = nums2[l];\\n                    l++;\\n                    continue;\\n                }\\n                arr[i] = nums1[k];\\n                k++;\\n            }else {\\n                if (nums2[l] == 0 && nums2.length > 0){\\n                    arr[i] = nums1[k];\\n                    k++;\\n                    continue;\\n                }\\n                arr[i] = nums2[l];\\n                l++;\\n            }\\n        }\\n\\n        for(int i=0;i<nums1.length;i++){\\n            nums1[i] = arr[i];\\n        }\\n\\n        for(int i=0;i<nums1.length;i++){\\n            System.out.print(nums1[i] + \" \");\\n        }\\n\\n            }\\n        }\\n\\n\\n\\n\\nMy Solution still case 2 is not satisfied"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@gautamsingh01591999](/gautamsingh01591999) i could do this but i thought it is too Convienent to do so i didnt use it -> Arrays.sort()"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int i=m;\\n        int j=0;\\n        while(i<nums1.length)\\n        {\\n            nums1[i]=nums2[j];\\n            i++;\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n    }"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "Because of First condition where you use break when nums2==0 it break the whole loop  and come to 2nd for loop."
                    },
                    {
                        "username": "Coder15091999",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int i=m;\\n        int j=0;\\n        while(i<nums1.length)\\n        {\\n            nums1[i]=nums2[j];\\n            i++;\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n    }"
                    },
                    {
                        "username": "vivekcoool21",
                        "content": "Hi, I am below runtime error on my code. Can anyone help what\\'s wrong in this?\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n`class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int i=0,j=0,tmp=0;\\n        \\n        while(i<nums1.size() && j<nums2.size()){\\n\\n            cout<<\"nums1[i]: \"<<nums1[i]<<\" nums2[j]: \"<<nums2[j]<<endl;\\n\\n            if(nums1[i]>nums2[j]){\\n\\n                tmp = nums1[i];\\n                nums1[i] = nums2[j];\\n                nums2[j] = tmp;\\n                j++;\\n            }\\n            else\\n                i++;\\n\\n            if(i == m)\\n                break;\\n\\n        }\\n\\n        for(j=0; i<nums1.size(); i++,j++){\\n\\n            nums1[i] = nums2[j];\\n        }\\n\\n        for(int t=0; t<nums1.size(); t++){\\n\\n            cout<<nums1[t]<<\" \";\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "sHaan27",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1, j = n - 1, k = m + n - 1;\\n\\n        for(; i >=0 && j >=0; k--){\\n            if(nums1[i] >= nums2[j]){\\n                nums1[k] = nums1[i--];\\n            } else {\\n                nums1[k] = nums2[j--];\\n            }\\n        }\\n\\n\\n        while(i >= 0) {\\n            nums1[k--] = nums1[i--];\\n        }\\n\\n        while(j >= 0) {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "nevil844",
                        "content": "As a python coder, I hate this approach. It can be done in lot easier way"
                    },
                    {
                        "username": "nix24",
                        "content": "why is it when I use the filter method and sort, it works in vscode but not on leetcode. I filter nums1 and 2 by m and n respectively. then i use a for loop to push nums2 to nums1. then I simply sort nums. But it leaves nums1 completely unchanged. "
                    }
                ]
            },
            {
                "id": 1786967,
                "content": [
                    {
                        "username": "duisekovd",
                        "content": "My code fails on testcase `mergt([0], 0, [1], 1)` . Can someone explain why?\\n\\n```\\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        if m == 0:\\n            nums1 = nums2\\n\\n        while m > 0 and n > 0:\\n            if nums1[m - 1] >= nums2[n - 1]:\\n                nums1[n + m - 1] = nums1[m - 1]\\n                m -= 1\\n            else:\\n                nums1[n + m - 1] = nums2[n - 1]\\n                n -= 1\\n```"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "int i = 0;\\n        int j = 0;\\n        List<Integer> ans = new ArrayList<>();\\n        while(j<n && i<m-n ){\\n            if(nums1[i]<=nums2[j]){\\n                ans.add(nums1[i]);\\n                i++;\\n            }\\n            else{\\n                ans.add(nums2[j]);\\n                j++;\\n            }\\n        }\\n        while(i<m-n){\\n            ans.add(nums1[i]);\\n            i++;\\n        }\\n        while(j<n){\\n            ans.add(nums2[j]);\\n            j++;\\n        }\\n        for(int k= 0;k<m;k++){\\n            nums1[k]=ans.get(k);\\n        }\\n\\nWhy this giving me a wrong output ? "
                    },
                    {
                        "username": "jadibdev",
                        "content": "I\\'m failing testcase1 nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 ... my output is [1, 2, 2, 3, 5, 6] but leetcode says my output is [1,2,3,0,0,0] which is not correct, I even asked GPT and it generated the following \"It appears that the LeetCode test case is incorrect. Based on your output, it looks like your code is indeed working as intended, and you are getting the expected result of [1, 2, 2, 3, 5, 6]. I would suggest reaching out to LeetCode support to report this issue and see if it can be corrected\" ... am I missing something here or is the test case on LeetCode wrong?`var merge = function(nums1, m, nums2, n) {\\n    temp = nums1.slice(0, m);\\n    console.log(\\'nums1 from argument\\', nums1)\\n    for (let i = 0; i < nums2.length; i++) {\\n        let index = nums2[i] - 1;\\n        temp.splice(index, 0, nums2[i])\\n    }\\n    nums1 = temp\\n    console.log(nums1)\\n};`\" "
                    },
                    {
                        "username": "smit_02",
                        "content": "Can anyone tell me why this solution is not accepted \\n\\nclass Solution {\\n    fun merge(nums1: IntArray, m: Int, nums2: IntArray, n: Int): Unit {\\n        val arr = Array<Int>(m+n){0}\\n\\n        for(i in 0 until m){\\n            arr[i] = nums1[i]\\n        }\\n        for(j in 0 until n){\\n            arr[m+j] = nums2[j]\\n        }\\n        arr.sort()\\n    }\\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        \\n          \\n        int k=0;\\n        int l=0;\\n\\n        int[] arr = new int[nums1.length];\\n\\n        for(int i=0;i<nums1.length;i++){\\n            if (nums2.length == 0) {break;}\\n\\n            if(nums1[k] <= nums2[l]){\\n                if (nums1[k] == 0 && nums2.length > 0){\\n                    arr[i] = nums2[l];\\n                    l++;\\n                    continue;\\n                }\\n                arr[i] = nums1[k];\\n                k++;\\n            }else {\\n                if (nums2[l] == 0 && nums2.length > 0){\\n                    arr[i] = nums1[k];\\n                    k++;\\n                    continue;\\n                }\\n                arr[i] = nums2[l];\\n                l++;\\n            }\\n        }\\n\\n        for(int i=0;i<nums1.length;i++){\\n            nums1[i] = arr[i];\\n        }\\n\\n        for(int i=0;i<nums1.length;i++){\\n            System.out.print(nums1[i] + \" \");\\n        }\\n\\n            }\\n        }\\n\\n\\n\\n\\nMy Solution still case 2 is not satisfied"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@gautamsingh01591999](/gautamsingh01591999) i could do this but i thought it is too Convienent to do so i didnt use it -> Arrays.sort()"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int i=m;\\n        int j=0;\\n        while(i<nums1.length)\\n        {\\n            nums1[i]=nums2[j];\\n            i++;\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n    }"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "Because of First condition where you use break when nums2==0 it break the whole loop  and come to 2nd for loop."
                    },
                    {
                        "username": "Coder15091999",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int i=m;\\n        int j=0;\\n        while(i<nums1.length)\\n        {\\n            nums1[i]=nums2[j];\\n            i++;\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n    }"
                    },
                    {
                        "username": "vivekcoool21",
                        "content": "Hi, I am below runtime error on my code. Can anyone help what\\'s wrong in this?\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n`class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int i=0,j=0,tmp=0;\\n        \\n        while(i<nums1.size() && j<nums2.size()){\\n\\n            cout<<\"nums1[i]: \"<<nums1[i]<<\" nums2[j]: \"<<nums2[j]<<endl;\\n\\n            if(nums1[i]>nums2[j]){\\n\\n                tmp = nums1[i];\\n                nums1[i] = nums2[j];\\n                nums2[j] = tmp;\\n                j++;\\n            }\\n            else\\n                i++;\\n\\n            if(i == m)\\n                break;\\n\\n        }\\n\\n        for(j=0; i<nums1.size(); i++,j++){\\n\\n            nums1[i] = nums2[j];\\n        }\\n\\n        for(int t=0; t<nums1.size(); t++){\\n\\n            cout<<nums1[t]<<\" \";\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "sHaan27",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1, j = n - 1, k = m + n - 1;\\n\\n        for(; i >=0 && j >=0; k--){\\n            if(nums1[i] >= nums2[j]){\\n                nums1[k] = nums1[i--];\\n            } else {\\n                nums1[k] = nums2[j--];\\n            }\\n        }\\n\\n\\n        while(i >= 0) {\\n            nums1[k--] = nums1[i--];\\n        }\\n\\n        while(j >= 0) {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "nevil844",
                        "content": "As a python coder, I hate this approach. It can be done in lot easier way"
                    },
                    {
                        "username": "nix24",
                        "content": "why is it when I use the filter method and sort, it works in vscode but not on leetcode. I filter nums1 and 2 by m and n respectively. then i use a for loop to push nums2 to nums1. then I simply sort nums. But it leaves nums1 completely unchanged. "
                    }
                ]
            },
            {
                "id": 1786333,
                "content": [
                    {
                        "username": "duisekovd",
                        "content": "My code fails on testcase `mergt([0], 0, [1], 1)` . Can someone explain why?\\n\\n```\\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        if m == 0:\\n            nums1 = nums2\\n\\n        while m > 0 and n > 0:\\n            if nums1[m - 1] >= nums2[n - 1]:\\n                nums1[n + m - 1] = nums1[m - 1]\\n                m -= 1\\n            else:\\n                nums1[n + m - 1] = nums2[n - 1]\\n                n -= 1\\n```"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "int i = 0;\\n        int j = 0;\\n        List<Integer> ans = new ArrayList<>();\\n        while(j<n && i<m-n ){\\n            if(nums1[i]<=nums2[j]){\\n                ans.add(nums1[i]);\\n                i++;\\n            }\\n            else{\\n                ans.add(nums2[j]);\\n                j++;\\n            }\\n        }\\n        while(i<m-n){\\n            ans.add(nums1[i]);\\n            i++;\\n        }\\n        while(j<n){\\n            ans.add(nums2[j]);\\n            j++;\\n        }\\n        for(int k= 0;k<m;k++){\\n            nums1[k]=ans.get(k);\\n        }\\n\\nWhy this giving me a wrong output ? "
                    },
                    {
                        "username": "jadibdev",
                        "content": "I\\'m failing testcase1 nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 ... my output is [1, 2, 2, 3, 5, 6] but leetcode says my output is [1,2,3,0,0,0] which is not correct, I even asked GPT and it generated the following \"It appears that the LeetCode test case is incorrect. Based on your output, it looks like your code is indeed working as intended, and you are getting the expected result of [1, 2, 2, 3, 5, 6]. I would suggest reaching out to LeetCode support to report this issue and see if it can be corrected\" ... am I missing something here or is the test case on LeetCode wrong?`var merge = function(nums1, m, nums2, n) {\\n    temp = nums1.slice(0, m);\\n    console.log(\\'nums1 from argument\\', nums1)\\n    for (let i = 0; i < nums2.length; i++) {\\n        let index = nums2[i] - 1;\\n        temp.splice(index, 0, nums2[i])\\n    }\\n    nums1 = temp\\n    console.log(nums1)\\n};`\" "
                    },
                    {
                        "username": "smit_02",
                        "content": "Can anyone tell me why this solution is not accepted \\n\\nclass Solution {\\n    fun merge(nums1: IntArray, m: Int, nums2: IntArray, n: Int): Unit {\\n        val arr = Array<Int>(m+n){0}\\n\\n        for(i in 0 until m){\\n            arr[i] = nums1[i]\\n        }\\n        for(j in 0 until n){\\n            arr[m+j] = nums2[j]\\n        }\\n        arr.sort()\\n    }\\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        \\n          \\n        int k=0;\\n        int l=0;\\n\\n        int[] arr = new int[nums1.length];\\n\\n        for(int i=0;i<nums1.length;i++){\\n            if (nums2.length == 0) {break;}\\n\\n            if(nums1[k] <= nums2[l]){\\n                if (nums1[k] == 0 && nums2.length > 0){\\n                    arr[i] = nums2[l];\\n                    l++;\\n                    continue;\\n                }\\n                arr[i] = nums1[k];\\n                k++;\\n            }else {\\n                if (nums2[l] == 0 && nums2.length > 0){\\n                    arr[i] = nums1[k];\\n                    k++;\\n                    continue;\\n                }\\n                arr[i] = nums2[l];\\n                l++;\\n            }\\n        }\\n\\n        for(int i=0;i<nums1.length;i++){\\n            nums1[i] = arr[i];\\n        }\\n\\n        for(int i=0;i<nums1.length;i++){\\n            System.out.print(nums1[i] + \" \");\\n        }\\n\\n            }\\n        }\\n\\n\\n\\n\\nMy Solution still case 2 is not satisfied"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@gautamsingh01591999](/gautamsingh01591999) i could do this but i thought it is too Convienent to do so i didnt use it -> Arrays.sort()"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int i=m;\\n        int j=0;\\n        while(i<nums1.length)\\n        {\\n            nums1[i]=nums2[j];\\n            i++;\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n    }"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "Because of First condition where you use break when nums2==0 it break the whole loop  and come to 2nd for loop."
                    },
                    {
                        "username": "Coder15091999",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int i=m;\\n        int j=0;\\n        while(i<nums1.length)\\n        {\\n            nums1[i]=nums2[j];\\n            i++;\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n    }"
                    },
                    {
                        "username": "vivekcoool21",
                        "content": "Hi, I am below runtime error on my code. Can anyone help what\\'s wrong in this?\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n`class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int i=0,j=0,tmp=0;\\n        \\n        while(i<nums1.size() && j<nums2.size()){\\n\\n            cout<<\"nums1[i]: \"<<nums1[i]<<\" nums2[j]: \"<<nums2[j]<<endl;\\n\\n            if(nums1[i]>nums2[j]){\\n\\n                tmp = nums1[i];\\n                nums1[i] = nums2[j];\\n                nums2[j] = tmp;\\n                j++;\\n            }\\n            else\\n                i++;\\n\\n            if(i == m)\\n                break;\\n\\n        }\\n\\n        for(j=0; i<nums1.size(); i++,j++){\\n\\n            nums1[i] = nums2[j];\\n        }\\n\\n        for(int t=0; t<nums1.size(); t++){\\n\\n            cout<<nums1[t]<<\" \";\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "sHaan27",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1, j = n - 1, k = m + n - 1;\\n\\n        for(; i >=0 && j >=0; k--){\\n            if(nums1[i] >= nums2[j]){\\n                nums1[k] = nums1[i--];\\n            } else {\\n                nums1[k] = nums2[j--];\\n            }\\n        }\\n\\n\\n        while(i >= 0) {\\n            nums1[k--] = nums1[i--];\\n        }\\n\\n        while(j >= 0) {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "nevil844",
                        "content": "As a python coder, I hate this approach. It can be done in lot easier way"
                    },
                    {
                        "username": "nix24",
                        "content": "why is it when I use the filter method and sort, it works in vscode but not on leetcode. I filter nums1 and 2 by m and n respectively. then i use a for loop to push nums2 to nums1. then I simply sort nums. But it leaves nums1 completely unchanged. "
                    }
                ]
            },
            {
                "id": 1785973,
                "content": [
                    {
                        "username": "duisekovd",
                        "content": "My code fails on testcase `mergt([0], 0, [1], 1)` . Can someone explain why?\\n\\n```\\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        if m == 0:\\n            nums1 = nums2\\n\\n        while m > 0 and n > 0:\\n            if nums1[m - 1] >= nums2[n - 1]:\\n                nums1[n + m - 1] = nums1[m - 1]\\n                m -= 1\\n            else:\\n                nums1[n + m - 1] = nums2[n - 1]\\n                n -= 1\\n```"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "int i = 0;\\n        int j = 0;\\n        List<Integer> ans = new ArrayList<>();\\n        while(j<n && i<m-n ){\\n            if(nums1[i]<=nums2[j]){\\n                ans.add(nums1[i]);\\n                i++;\\n            }\\n            else{\\n                ans.add(nums2[j]);\\n                j++;\\n            }\\n        }\\n        while(i<m-n){\\n            ans.add(nums1[i]);\\n            i++;\\n        }\\n        while(j<n){\\n            ans.add(nums2[j]);\\n            j++;\\n        }\\n        for(int k= 0;k<m;k++){\\n            nums1[k]=ans.get(k);\\n        }\\n\\nWhy this giving me a wrong output ? "
                    },
                    {
                        "username": "jadibdev",
                        "content": "I\\'m failing testcase1 nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 ... my output is [1, 2, 2, 3, 5, 6] but leetcode says my output is [1,2,3,0,0,0] which is not correct, I even asked GPT and it generated the following \"It appears that the LeetCode test case is incorrect. Based on your output, it looks like your code is indeed working as intended, and you are getting the expected result of [1, 2, 2, 3, 5, 6]. I would suggest reaching out to LeetCode support to report this issue and see if it can be corrected\" ... am I missing something here or is the test case on LeetCode wrong?`var merge = function(nums1, m, nums2, n) {\\n    temp = nums1.slice(0, m);\\n    console.log(\\'nums1 from argument\\', nums1)\\n    for (let i = 0; i < nums2.length; i++) {\\n        let index = nums2[i] - 1;\\n        temp.splice(index, 0, nums2[i])\\n    }\\n    nums1 = temp\\n    console.log(nums1)\\n};`\" "
                    },
                    {
                        "username": "smit_02",
                        "content": "Can anyone tell me why this solution is not accepted \\n\\nclass Solution {\\n    fun merge(nums1: IntArray, m: Int, nums2: IntArray, n: Int): Unit {\\n        val arr = Array<Int>(m+n){0}\\n\\n        for(i in 0 until m){\\n            arr[i] = nums1[i]\\n        }\\n        for(j in 0 until n){\\n            arr[m+j] = nums2[j]\\n        }\\n        arr.sort()\\n    }\\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        \\n          \\n        int k=0;\\n        int l=0;\\n\\n        int[] arr = new int[nums1.length];\\n\\n        for(int i=0;i<nums1.length;i++){\\n            if (nums2.length == 0) {break;}\\n\\n            if(nums1[k] <= nums2[l]){\\n                if (nums1[k] == 0 && nums2.length > 0){\\n                    arr[i] = nums2[l];\\n                    l++;\\n                    continue;\\n                }\\n                arr[i] = nums1[k];\\n                k++;\\n            }else {\\n                if (nums2[l] == 0 && nums2.length > 0){\\n                    arr[i] = nums1[k];\\n                    k++;\\n                    continue;\\n                }\\n                arr[i] = nums2[l];\\n                l++;\\n            }\\n        }\\n\\n        for(int i=0;i<nums1.length;i++){\\n            nums1[i] = arr[i];\\n        }\\n\\n        for(int i=0;i<nums1.length;i++){\\n            System.out.print(nums1[i] + \" \");\\n        }\\n\\n            }\\n        }\\n\\n\\n\\n\\nMy Solution still case 2 is not satisfied"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@gautamsingh01591999](/gautamsingh01591999) i could do this but i thought it is too Convienent to do so i didnt use it -> Arrays.sort()"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int i=m;\\n        int j=0;\\n        while(i<nums1.length)\\n        {\\n            nums1[i]=nums2[j];\\n            i++;\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n    }"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "Because of First condition where you use break when nums2==0 it break the whole loop  and come to 2nd for loop."
                    },
                    {
                        "username": "Coder15091999",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int i=m;\\n        int j=0;\\n        while(i<nums1.length)\\n        {\\n            nums1[i]=nums2[j];\\n            i++;\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n    }"
                    },
                    {
                        "username": "vivekcoool21",
                        "content": "Hi, I am below runtime error on my code. Can anyone help what\\'s wrong in this?\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n`class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int i=0,j=0,tmp=0;\\n        \\n        while(i<nums1.size() && j<nums2.size()){\\n\\n            cout<<\"nums1[i]: \"<<nums1[i]<<\" nums2[j]: \"<<nums2[j]<<endl;\\n\\n            if(nums1[i]>nums2[j]){\\n\\n                tmp = nums1[i];\\n                nums1[i] = nums2[j];\\n                nums2[j] = tmp;\\n                j++;\\n            }\\n            else\\n                i++;\\n\\n            if(i == m)\\n                break;\\n\\n        }\\n\\n        for(j=0; i<nums1.size(); i++,j++){\\n\\n            nums1[i] = nums2[j];\\n        }\\n\\n        for(int t=0; t<nums1.size(); t++){\\n\\n            cout<<nums1[t]<<\" \";\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "sHaan27",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1, j = n - 1, k = m + n - 1;\\n\\n        for(; i >=0 && j >=0; k--){\\n            if(nums1[i] >= nums2[j]){\\n                nums1[k] = nums1[i--];\\n            } else {\\n                nums1[k] = nums2[j--];\\n            }\\n        }\\n\\n\\n        while(i >= 0) {\\n            nums1[k--] = nums1[i--];\\n        }\\n\\n        while(j >= 0) {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "nevil844",
                        "content": "As a python coder, I hate this approach. It can be done in lot easier way"
                    },
                    {
                        "username": "nix24",
                        "content": "why is it when I use the filter method and sort, it works in vscode but not on leetcode. I filter nums1 and 2 by m and n respectively. then i use a for loop to push nums2 to nums1. then I simply sort nums. But it leaves nums1 completely unchanged. "
                    }
                ]
            },
            {
                "id": 1784731,
                "content": [
                    {
                        "username": "duisekovd",
                        "content": "My code fails on testcase `mergt([0], 0, [1], 1)` . Can someone explain why?\\n\\n```\\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        if m == 0:\\n            nums1 = nums2\\n\\n        while m > 0 and n > 0:\\n            if nums1[m - 1] >= nums2[n - 1]:\\n                nums1[n + m - 1] = nums1[m - 1]\\n                m -= 1\\n            else:\\n                nums1[n + m - 1] = nums2[n - 1]\\n                n -= 1\\n```"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "int i = 0;\\n        int j = 0;\\n        List<Integer> ans = new ArrayList<>();\\n        while(j<n && i<m-n ){\\n            if(nums1[i]<=nums2[j]){\\n                ans.add(nums1[i]);\\n                i++;\\n            }\\n            else{\\n                ans.add(nums2[j]);\\n                j++;\\n            }\\n        }\\n        while(i<m-n){\\n            ans.add(nums1[i]);\\n            i++;\\n        }\\n        while(j<n){\\n            ans.add(nums2[j]);\\n            j++;\\n        }\\n        for(int k= 0;k<m;k++){\\n            nums1[k]=ans.get(k);\\n        }\\n\\nWhy this giving me a wrong output ? "
                    },
                    {
                        "username": "jadibdev",
                        "content": "I\\'m failing testcase1 nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 ... my output is [1, 2, 2, 3, 5, 6] but leetcode says my output is [1,2,3,0,0,0] which is not correct, I even asked GPT and it generated the following \"It appears that the LeetCode test case is incorrect. Based on your output, it looks like your code is indeed working as intended, and you are getting the expected result of [1, 2, 2, 3, 5, 6]. I would suggest reaching out to LeetCode support to report this issue and see if it can be corrected\" ... am I missing something here or is the test case on LeetCode wrong?`var merge = function(nums1, m, nums2, n) {\\n    temp = nums1.slice(0, m);\\n    console.log(\\'nums1 from argument\\', nums1)\\n    for (let i = 0; i < nums2.length; i++) {\\n        let index = nums2[i] - 1;\\n        temp.splice(index, 0, nums2[i])\\n    }\\n    nums1 = temp\\n    console.log(nums1)\\n};`\" "
                    },
                    {
                        "username": "smit_02",
                        "content": "Can anyone tell me why this solution is not accepted \\n\\nclass Solution {\\n    fun merge(nums1: IntArray, m: Int, nums2: IntArray, n: Int): Unit {\\n        val arr = Array<Int>(m+n){0}\\n\\n        for(i in 0 until m){\\n            arr[i] = nums1[i]\\n        }\\n        for(j in 0 until n){\\n            arr[m+j] = nums2[j]\\n        }\\n        arr.sort()\\n    }\\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        \\n          \\n        int k=0;\\n        int l=0;\\n\\n        int[] arr = new int[nums1.length];\\n\\n        for(int i=0;i<nums1.length;i++){\\n            if (nums2.length == 0) {break;}\\n\\n            if(nums1[k] <= nums2[l]){\\n                if (nums1[k] == 0 && nums2.length > 0){\\n                    arr[i] = nums2[l];\\n                    l++;\\n                    continue;\\n                }\\n                arr[i] = nums1[k];\\n                k++;\\n            }else {\\n                if (nums2[l] == 0 && nums2.length > 0){\\n                    arr[i] = nums1[k];\\n                    k++;\\n                    continue;\\n                }\\n                arr[i] = nums2[l];\\n                l++;\\n            }\\n        }\\n\\n        for(int i=0;i<nums1.length;i++){\\n            nums1[i] = arr[i];\\n        }\\n\\n        for(int i=0;i<nums1.length;i++){\\n            System.out.print(nums1[i] + \" \");\\n        }\\n\\n            }\\n        }\\n\\n\\n\\n\\nMy Solution still case 2 is not satisfied"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@gautamsingh01591999](/gautamsingh01591999) i could do this but i thought it is too Convienent to do so i didnt use it -> Arrays.sort()"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int i=m;\\n        int j=0;\\n        while(i<nums1.length)\\n        {\\n            nums1[i]=nums2[j];\\n            i++;\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n    }"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "Because of First condition where you use break when nums2==0 it break the whole loop  and come to 2nd for loop."
                    },
                    {
                        "username": "Coder15091999",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int i=m;\\n        int j=0;\\n        while(i<nums1.length)\\n        {\\n            nums1[i]=nums2[j];\\n            i++;\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n    }"
                    },
                    {
                        "username": "vivekcoool21",
                        "content": "Hi, I am below runtime error on my code. Can anyone help what\\'s wrong in this?\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n`class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int i=0,j=0,tmp=0;\\n        \\n        while(i<nums1.size() && j<nums2.size()){\\n\\n            cout<<\"nums1[i]: \"<<nums1[i]<<\" nums2[j]: \"<<nums2[j]<<endl;\\n\\n            if(nums1[i]>nums2[j]){\\n\\n                tmp = nums1[i];\\n                nums1[i] = nums2[j];\\n                nums2[j] = tmp;\\n                j++;\\n            }\\n            else\\n                i++;\\n\\n            if(i == m)\\n                break;\\n\\n        }\\n\\n        for(j=0; i<nums1.size(); i++,j++){\\n\\n            nums1[i] = nums2[j];\\n        }\\n\\n        for(int t=0; t<nums1.size(); t++){\\n\\n            cout<<nums1[t]<<\" \";\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "sHaan27",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1, j = n - 1, k = m + n - 1;\\n\\n        for(; i >=0 && j >=0; k--){\\n            if(nums1[i] >= nums2[j]){\\n                nums1[k] = nums1[i--];\\n            } else {\\n                nums1[k] = nums2[j--];\\n            }\\n        }\\n\\n\\n        while(i >= 0) {\\n            nums1[k--] = nums1[i--];\\n        }\\n\\n        while(j >= 0) {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "nevil844",
                        "content": "As a python coder, I hate this approach. It can be done in lot easier way"
                    },
                    {
                        "username": "nix24",
                        "content": "why is it when I use the filter method and sort, it works in vscode but not on leetcode. I filter nums1 and 2 by m and n respectively. then i use a for loop to push nums2 to nums1. then I simply sort nums. But it leaves nums1 completely unchanged. "
                    }
                ]
            },
            {
                "id": 1784665,
                "content": [
                    {
                        "username": "duisekovd",
                        "content": "My code fails on testcase `mergt([0], 0, [1], 1)` . Can someone explain why?\\n\\n```\\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        if m == 0:\\n            nums1 = nums2\\n\\n        while m > 0 and n > 0:\\n            if nums1[m - 1] >= nums2[n - 1]:\\n                nums1[n + m - 1] = nums1[m - 1]\\n                m -= 1\\n            else:\\n                nums1[n + m - 1] = nums2[n - 1]\\n                n -= 1\\n```"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "int i = 0;\\n        int j = 0;\\n        List<Integer> ans = new ArrayList<>();\\n        while(j<n && i<m-n ){\\n            if(nums1[i]<=nums2[j]){\\n                ans.add(nums1[i]);\\n                i++;\\n            }\\n            else{\\n                ans.add(nums2[j]);\\n                j++;\\n            }\\n        }\\n        while(i<m-n){\\n            ans.add(nums1[i]);\\n            i++;\\n        }\\n        while(j<n){\\n            ans.add(nums2[j]);\\n            j++;\\n        }\\n        for(int k= 0;k<m;k++){\\n            nums1[k]=ans.get(k);\\n        }\\n\\nWhy this giving me a wrong output ? "
                    },
                    {
                        "username": "jadibdev",
                        "content": "I\\'m failing testcase1 nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 ... my output is [1, 2, 2, 3, 5, 6] but leetcode says my output is [1,2,3,0,0,0] which is not correct, I even asked GPT and it generated the following \"It appears that the LeetCode test case is incorrect. Based on your output, it looks like your code is indeed working as intended, and you are getting the expected result of [1, 2, 2, 3, 5, 6]. I would suggest reaching out to LeetCode support to report this issue and see if it can be corrected\" ... am I missing something here or is the test case on LeetCode wrong?`var merge = function(nums1, m, nums2, n) {\\n    temp = nums1.slice(0, m);\\n    console.log(\\'nums1 from argument\\', nums1)\\n    for (let i = 0; i < nums2.length; i++) {\\n        let index = nums2[i] - 1;\\n        temp.splice(index, 0, nums2[i])\\n    }\\n    nums1 = temp\\n    console.log(nums1)\\n};`\" "
                    },
                    {
                        "username": "smit_02",
                        "content": "Can anyone tell me why this solution is not accepted \\n\\nclass Solution {\\n    fun merge(nums1: IntArray, m: Int, nums2: IntArray, n: Int): Unit {\\n        val arr = Array<Int>(m+n){0}\\n\\n        for(i in 0 until m){\\n            arr[i] = nums1[i]\\n        }\\n        for(j in 0 until n){\\n            arr[m+j] = nums2[j]\\n        }\\n        arr.sort()\\n    }\\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        \\n          \\n        int k=0;\\n        int l=0;\\n\\n        int[] arr = new int[nums1.length];\\n\\n        for(int i=0;i<nums1.length;i++){\\n            if (nums2.length == 0) {break;}\\n\\n            if(nums1[k] <= nums2[l]){\\n                if (nums1[k] == 0 && nums2.length > 0){\\n                    arr[i] = nums2[l];\\n                    l++;\\n                    continue;\\n                }\\n                arr[i] = nums1[k];\\n                k++;\\n            }else {\\n                if (nums2[l] == 0 && nums2.length > 0){\\n                    arr[i] = nums1[k];\\n                    k++;\\n                    continue;\\n                }\\n                arr[i] = nums2[l];\\n                l++;\\n            }\\n        }\\n\\n        for(int i=0;i<nums1.length;i++){\\n            nums1[i] = arr[i];\\n        }\\n\\n        for(int i=0;i<nums1.length;i++){\\n            System.out.print(nums1[i] + \" \");\\n        }\\n\\n            }\\n        }\\n\\n\\n\\n\\nMy Solution still case 2 is not satisfied"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@gautamsingh01591999](/gautamsingh01591999) i could do this but i thought it is too Convienent to do so i didnt use it -> Arrays.sort()"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int i=m;\\n        int j=0;\\n        while(i<nums1.length)\\n        {\\n            nums1[i]=nums2[j];\\n            i++;\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n    }"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "Because of First condition where you use break when nums2==0 it break the whole loop  and come to 2nd for loop."
                    },
                    {
                        "username": "Coder15091999",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int i=m;\\n        int j=0;\\n        while(i<nums1.length)\\n        {\\n            nums1[i]=nums2[j];\\n            i++;\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n    }"
                    },
                    {
                        "username": "vivekcoool21",
                        "content": "Hi, I am below runtime error on my code. Can anyone help what\\'s wrong in this?\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n`class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int i=0,j=0,tmp=0;\\n        \\n        while(i<nums1.size() && j<nums2.size()){\\n\\n            cout<<\"nums1[i]: \"<<nums1[i]<<\" nums2[j]: \"<<nums2[j]<<endl;\\n\\n            if(nums1[i]>nums2[j]){\\n\\n                tmp = nums1[i];\\n                nums1[i] = nums2[j];\\n                nums2[j] = tmp;\\n                j++;\\n            }\\n            else\\n                i++;\\n\\n            if(i == m)\\n                break;\\n\\n        }\\n\\n        for(j=0; i<nums1.size(); i++,j++){\\n\\n            nums1[i] = nums2[j];\\n        }\\n\\n        for(int t=0; t<nums1.size(); t++){\\n\\n            cout<<nums1[t]<<\" \";\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "sHaan27",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1, j = n - 1, k = m + n - 1;\\n\\n        for(; i >=0 && j >=0; k--){\\n            if(nums1[i] >= nums2[j]){\\n                nums1[k] = nums1[i--];\\n            } else {\\n                nums1[k] = nums2[j--];\\n            }\\n        }\\n\\n\\n        while(i >= 0) {\\n            nums1[k--] = nums1[i--];\\n        }\\n\\n        while(j >= 0) {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "nevil844",
                        "content": "As a python coder, I hate this approach. It can be done in lot easier way"
                    },
                    {
                        "username": "nix24",
                        "content": "why is it when I use the filter method and sort, it works in vscode but not on leetcode. I filter nums1 and 2 by m and n respectively. then i use a for loop to push nums2 to nums1. then I simply sort nums. But it leaves nums1 completely unchanged. "
                    }
                ]
            },
            {
                "id": 1784226,
                "content": [
                    {
                        "username": "duisekovd",
                        "content": "My code fails on testcase `mergt([0], 0, [1], 1)` . Can someone explain why?\\n\\n```\\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        if m == 0:\\n            nums1 = nums2\\n\\n        while m > 0 and n > 0:\\n            if nums1[m - 1] >= nums2[n - 1]:\\n                nums1[n + m - 1] = nums1[m - 1]\\n                m -= 1\\n            else:\\n                nums1[n + m - 1] = nums2[n - 1]\\n                n -= 1\\n```"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "int i = 0;\\n        int j = 0;\\n        List<Integer> ans = new ArrayList<>();\\n        while(j<n && i<m-n ){\\n            if(nums1[i]<=nums2[j]){\\n                ans.add(nums1[i]);\\n                i++;\\n            }\\n            else{\\n                ans.add(nums2[j]);\\n                j++;\\n            }\\n        }\\n        while(i<m-n){\\n            ans.add(nums1[i]);\\n            i++;\\n        }\\n        while(j<n){\\n            ans.add(nums2[j]);\\n            j++;\\n        }\\n        for(int k= 0;k<m;k++){\\n            nums1[k]=ans.get(k);\\n        }\\n\\nWhy this giving me a wrong output ? "
                    },
                    {
                        "username": "jadibdev",
                        "content": "I\\'m failing testcase1 nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 ... my output is [1, 2, 2, 3, 5, 6] but leetcode says my output is [1,2,3,0,0,0] which is not correct, I even asked GPT and it generated the following \"It appears that the LeetCode test case is incorrect. Based on your output, it looks like your code is indeed working as intended, and you are getting the expected result of [1, 2, 2, 3, 5, 6]. I would suggest reaching out to LeetCode support to report this issue and see if it can be corrected\" ... am I missing something here or is the test case on LeetCode wrong?`var merge = function(nums1, m, nums2, n) {\\n    temp = nums1.slice(0, m);\\n    console.log(\\'nums1 from argument\\', nums1)\\n    for (let i = 0; i < nums2.length; i++) {\\n        let index = nums2[i] - 1;\\n        temp.splice(index, 0, nums2[i])\\n    }\\n    nums1 = temp\\n    console.log(nums1)\\n};`\" "
                    },
                    {
                        "username": "smit_02",
                        "content": "Can anyone tell me why this solution is not accepted \\n\\nclass Solution {\\n    fun merge(nums1: IntArray, m: Int, nums2: IntArray, n: Int): Unit {\\n        val arr = Array<Int>(m+n){0}\\n\\n        for(i in 0 until m){\\n            arr[i] = nums1[i]\\n        }\\n        for(j in 0 until n){\\n            arr[m+j] = nums2[j]\\n        }\\n        arr.sort()\\n    }\\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        \\n          \\n        int k=0;\\n        int l=0;\\n\\n        int[] arr = new int[nums1.length];\\n\\n        for(int i=0;i<nums1.length;i++){\\n            if (nums2.length == 0) {break;}\\n\\n            if(nums1[k] <= nums2[l]){\\n                if (nums1[k] == 0 && nums2.length > 0){\\n                    arr[i] = nums2[l];\\n                    l++;\\n                    continue;\\n                }\\n                arr[i] = nums1[k];\\n                k++;\\n            }else {\\n                if (nums2[l] == 0 && nums2.length > 0){\\n                    arr[i] = nums1[k];\\n                    k++;\\n                    continue;\\n                }\\n                arr[i] = nums2[l];\\n                l++;\\n            }\\n        }\\n\\n        for(int i=0;i<nums1.length;i++){\\n            nums1[i] = arr[i];\\n        }\\n\\n        for(int i=0;i<nums1.length;i++){\\n            System.out.print(nums1[i] + \" \");\\n        }\\n\\n            }\\n        }\\n\\n\\n\\n\\nMy Solution still case 2 is not satisfied"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@gautamsingh01591999](/gautamsingh01591999) i could do this but i thought it is too Convienent to do so i didnt use it -> Arrays.sort()"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int i=m;\\n        int j=0;\\n        while(i<nums1.length)\\n        {\\n            nums1[i]=nums2[j];\\n            i++;\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n    }"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "Because of First condition where you use break when nums2==0 it break the whole loop  and come to 2nd for loop."
                    },
                    {
                        "username": "Coder15091999",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int i=m;\\n        int j=0;\\n        while(i<nums1.length)\\n        {\\n            nums1[i]=nums2[j];\\n            i++;\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n    }"
                    },
                    {
                        "username": "vivekcoool21",
                        "content": "Hi, I am below runtime error on my code. Can anyone help what\\'s wrong in this?\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n`class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int i=0,j=0,tmp=0;\\n        \\n        while(i<nums1.size() && j<nums2.size()){\\n\\n            cout<<\"nums1[i]: \"<<nums1[i]<<\" nums2[j]: \"<<nums2[j]<<endl;\\n\\n            if(nums1[i]>nums2[j]){\\n\\n                tmp = nums1[i];\\n                nums1[i] = nums2[j];\\n                nums2[j] = tmp;\\n                j++;\\n            }\\n            else\\n                i++;\\n\\n            if(i == m)\\n                break;\\n\\n        }\\n\\n        for(j=0; i<nums1.size(); i++,j++){\\n\\n            nums1[i] = nums2[j];\\n        }\\n\\n        for(int t=0; t<nums1.size(); t++){\\n\\n            cout<<nums1[t]<<\" \";\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "sHaan27",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1, j = n - 1, k = m + n - 1;\\n\\n        for(; i >=0 && j >=0; k--){\\n            if(nums1[i] >= nums2[j]){\\n                nums1[k] = nums1[i--];\\n            } else {\\n                nums1[k] = nums2[j--];\\n            }\\n        }\\n\\n\\n        while(i >= 0) {\\n            nums1[k--] = nums1[i--];\\n        }\\n\\n        while(j >= 0) {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "nevil844",
                        "content": "As a python coder, I hate this approach. It can be done in lot easier way"
                    },
                    {
                        "username": "nix24",
                        "content": "why is it when I use the filter method and sort, it works in vscode but not on leetcode. I filter nums1 and 2 by m and n respectively. then i use a for loop to push nums2 to nums1. then I simply sort nums. But it leaves nums1 completely unchanged. "
                    }
                ]
            },
            {
                "id": 1782360,
                "content": [
                    {
                        "username": "duisekovd",
                        "content": "My code fails on testcase `mergt([0], 0, [1], 1)` . Can someone explain why?\\n\\n```\\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        if m == 0:\\n            nums1 = nums2\\n\\n        while m > 0 and n > 0:\\n            if nums1[m - 1] >= nums2[n - 1]:\\n                nums1[n + m - 1] = nums1[m - 1]\\n                m -= 1\\n            else:\\n                nums1[n + m - 1] = nums2[n - 1]\\n                n -= 1\\n```"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "int i = 0;\\n        int j = 0;\\n        List<Integer> ans = new ArrayList<>();\\n        while(j<n && i<m-n ){\\n            if(nums1[i]<=nums2[j]){\\n                ans.add(nums1[i]);\\n                i++;\\n            }\\n            else{\\n                ans.add(nums2[j]);\\n                j++;\\n            }\\n        }\\n        while(i<m-n){\\n            ans.add(nums1[i]);\\n            i++;\\n        }\\n        while(j<n){\\n            ans.add(nums2[j]);\\n            j++;\\n        }\\n        for(int k= 0;k<m;k++){\\n            nums1[k]=ans.get(k);\\n        }\\n\\nWhy this giving me a wrong output ? "
                    },
                    {
                        "username": "jadibdev",
                        "content": "I\\'m failing testcase1 nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 ... my output is [1, 2, 2, 3, 5, 6] but leetcode says my output is [1,2,3,0,0,0] which is not correct, I even asked GPT and it generated the following \"It appears that the LeetCode test case is incorrect. Based on your output, it looks like your code is indeed working as intended, and you are getting the expected result of [1, 2, 2, 3, 5, 6]. I would suggest reaching out to LeetCode support to report this issue and see if it can be corrected\" ... am I missing something here or is the test case on LeetCode wrong?`var merge = function(nums1, m, nums2, n) {\\n    temp = nums1.slice(0, m);\\n    console.log(\\'nums1 from argument\\', nums1)\\n    for (let i = 0; i < nums2.length; i++) {\\n        let index = nums2[i] - 1;\\n        temp.splice(index, 0, nums2[i])\\n    }\\n    nums1 = temp\\n    console.log(nums1)\\n};`\" "
                    },
                    {
                        "username": "smit_02",
                        "content": "Can anyone tell me why this solution is not accepted \\n\\nclass Solution {\\n    fun merge(nums1: IntArray, m: Int, nums2: IntArray, n: Int): Unit {\\n        val arr = Array<Int>(m+n){0}\\n\\n        for(i in 0 until m){\\n            arr[i] = nums1[i]\\n        }\\n        for(j in 0 until n){\\n            arr[m+j] = nums2[j]\\n        }\\n        arr.sort()\\n    }\\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        \\n          \\n        int k=0;\\n        int l=0;\\n\\n        int[] arr = new int[nums1.length];\\n\\n        for(int i=0;i<nums1.length;i++){\\n            if (nums2.length == 0) {break;}\\n\\n            if(nums1[k] <= nums2[l]){\\n                if (nums1[k] == 0 && nums2.length > 0){\\n                    arr[i] = nums2[l];\\n                    l++;\\n                    continue;\\n                }\\n                arr[i] = nums1[k];\\n                k++;\\n            }else {\\n                if (nums2[l] == 0 && nums2.length > 0){\\n                    arr[i] = nums1[k];\\n                    k++;\\n                    continue;\\n                }\\n                arr[i] = nums2[l];\\n                l++;\\n            }\\n        }\\n\\n        for(int i=0;i<nums1.length;i++){\\n            nums1[i] = arr[i];\\n        }\\n\\n        for(int i=0;i<nums1.length;i++){\\n            System.out.print(nums1[i] + \" \");\\n        }\\n\\n            }\\n        }\\n\\n\\n\\n\\nMy Solution still case 2 is not satisfied"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@gautamsingh01591999](/gautamsingh01591999) i could do this but i thought it is too Convienent to do so i didnt use it -> Arrays.sort()"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int i=m;\\n        int j=0;\\n        while(i<nums1.length)\\n        {\\n            nums1[i]=nums2[j];\\n            i++;\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n    }"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "Because of First condition where you use break when nums2==0 it break the whole loop  and come to 2nd for loop."
                    },
                    {
                        "username": "Coder15091999",
                        "content": "public void merge(int[] nums1, int m, int[] nums2, int n) {\\n       \\n       int i=m;\\n        int j=0;\\n        while(i<nums1.length)\\n        {\\n            nums1[i]=nums2[j];\\n            i++;\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n    }"
                    },
                    {
                        "username": "vivekcoool21",
                        "content": "Hi, I am below runtime error on my code. Can anyone help what\\'s wrong in this?\\n\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n`class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int i=0,j=0,tmp=0;\\n        \\n        while(i<nums1.size() && j<nums2.size()){\\n\\n            cout<<\"nums1[i]: \"<<nums1[i]<<\" nums2[j]: \"<<nums2[j]<<endl;\\n\\n            if(nums1[i]>nums2[j]){\\n\\n                tmp = nums1[i];\\n                nums1[i] = nums2[j];\\n                nums2[j] = tmp;\\n                j++;\\n            }\\n            else\\n                i++;\\n\\n            if(i == m)\\n                break;\\n\\n        }\\n\\n        for(j=0; i<nums1.size(); i++,j++){\\n\\n            nums1[i] = nums2[j];\\n        }\\n\\n        for(int t=0; t<nums1.size(); t++){\\n\\n            cout<<nums1[t]<<\" \";\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "sHaan27",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1, j = n - 1, k = m + n - 1;\\n\\n        for(; i >=0 && j >=0; k--){\\n            if(nums1[i] >= nums2[j]){\\n                nums1[k] = nums1[i--];\\n            } else {\\n                nums1[k] = nums2[j--];\\n            }\\n        }\\n\\n\\n        while(i >= 0) {\\n            nums1[k--] = nums1[i--];\\n        }\\n\\n        while(j >= 0) {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "nevil844",
                        "content": "As a python coder, I hate this approach. It can be done in lot easier way"
                    },
                    {
                        "username": "nix24",
                        "content": "why is it when I use the filter method and sort, it works in vscode but not on leetcode. I filter nums1 and 2 by m and n respectively. then i use a for loop to push nums2 to nums1. then I simply sort nums. But it leaves nums1 completely unchanged. "
                    }
                ]
            },
            {
                "id": 1782058,
                "content": [
                    {
                        "username": "lehung16082002",
                        "content": "Simple python:\\n\\n\\n\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n      i = m + n - 1\\n      s1 = m-1\\n      s2 = n-1\\n      while s1 >= 0 and s2 >= 0:\\n        if nums1[s1] > nums2[s2]:\\n          nums1[i] = nums1[s1]\\n          s1 -= 1\\n        else:\\n          nums1[i] = nums2[s2]\\n          s2 -= 1\\n        i -= 1\\n      if s2 >= 0:\\n        for i in range(s2+1):\\n          nums1[i] = nums2[i]"
                    },
                    {
                        "username": "Deval28",
                        "content": "How did we get the intuition to make the pointers point to the last index of each array?"
                    },
                    {
                        "username": "eslinger",
                        "content": "[Python3]\\nFor anyone who actually implemented the full sort using two pointers, don\\'t worry about the \"faster than x%\" part of the solution feedback. The fastest solutions technically pass but obviate the real point of the exercise by using the built-in `List.sort` method."
                    },
                    {
                        "username": "sivapothala",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        i=0\\n        j=0\\n        c=[0]*len(nums1)\\n        print(c)\\n        k=0 \\n        while(i<n and j<n):\\n            if nums1[i] < nums2[j]:\\n                c[k]=nums1[i]\\n                k+=1\\n                i+=1\\n            else:\\n                c[k]=nums2[j]\\n                k+=1\\n                j+=1\\n        vb=j\\n         \\n        while(i<n):\\n            c[k]=nums[i]\\n            i+=1\\n            k+=1\\n\\n        while(vb<n):\\n            c[k]=nums2[vb]\\n            k+=1\\n            vb+=1\\n        nums1[:]=c\\n\\nwhy this is not working .. ?\\nany one can plz help "
                    },
                    {
                        "username": "prominato500",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n            while(i<m) {\\n                if(nums1[i]>nums2[0]) {\\n                    swap(nums1[i], nums2[0]);\\n                    for(int j=0;j<n;j++) {\\n                        if(nums2[j]<nums2[j-1]) {\\n                            swap(nums2[j], nums2[j-1]);\\n                        }\\n                    }\\n                }\\n                i++;\\n            }\\n            for(int j=0; j<n; j++) {\\n                swap(nums1[m+j-1], nums2[j]);\\n            }\\n    }\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nWhere is the error? Please help me."
                    },
                    {
                        "username": "Sagarkumar09",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] arr=new int[n+m];\\n        int l=0;\\n        for(int i=0;i<m;i++){\\n            nums1[l]=nums1[i];\\n            l++;\\n        }\\n        for(int i=0;i<n;i++){\\n            nums1[l]=nums2[i];\\n            l++;\\n                   }\\n        Arrays.sort(nums1);\\n       \\n        for(int j=0;j<nums1.length;j++){\\n            System.out.print(nums1[j]+\" \");           \\n        }     \\n      \\n    }\\n}"
                    },
                    {
                        "username": "Ronak083",
                        "content": "easy solution with runtime 0ms in java \\n public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m-1;\\n        int j = n-1;\\n        int k = m+n-1;\\n        while(k>=0){\\n            if(i>=0 && j>=0){\\n                if(nums1[i]<nums2[j]){\\n                    nums1[k] = nums2[j];\\n                    k--;\\n                    j--;\\n                } else{\\n                    nums1[k] = nums1[i];\\n                    k--;\\n                    i--;\\n                }\\n            } else if(j>=0){\\n                nums1[k] = nums2[j];\\n                k--;\\n                j--;\\n            } else{\\n                break;\\n            }\\n        }\\n    }`"
                    },
                    {
                        "username": "msdhoni2489",
                        "content": "Easy Solution.\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        vector <int> ans;\\n        for(int i=0;i<m;i++)\\n        {\\n            ans.push_back(nums1[i]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums2[i]);\\n        }\\n\\n        sort(ans.begin(),ans.end());\\n        nums1=ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "wanna_be_coder",
                        "content": "\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int j =0;\\n        cout<<nums1[m+1]<<endl;\\n        for(int i = n; i<m+n;i++){\\n            nums1[i] = nums2[j];\\n            j++;\\n        }\\n        sort(nums1.begin(), nums1.end());\\n        }\\n        \\n    }\\n};\\n\\nwhy this is showing runtime error"
                    },
                    {
                        "username": "user7754yr",
                        "content": "I wrote a code and its totally working fine (checked on intellij with the same test case) but leetcode test case fails. I am not sure whether if I can share the code here or not but I do know my code is right. Can someone help with that "
                    }
                ]
            },
            {
                "id": 1782037,
                "content": [
                    {
                        "username": "lehung16082002",
                        "content": "Simple python:\\n\\n\\n\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n      i = m + n - 1\\n      s1 = m-1\\n      s2 = n-1\\n      while s1 >= 0 and s2 >= 0:\\n        if nums1[s1] > nums2[s2]:\\n          nums1[i] = nums1[s1]\\n          s1 -= 1\\n        else:\\n          nums1[i] = nums2[s2]\\n          s2 -= 1\\n        i -= 1\\n      if s2 >= 0:\\n        for i in range(s2+1):\\n          nums1[i] = nums2[i]"
                    },
                    {
                        "username": "Deval28",
                        "content": "How did we get the intuition to make the pointers point to the last index of each array?"
                    },
                    {
                        "username": "eslinger",
                        "content": "[Python3]\\nFor anyone who actually implemented the full sort using two pointers, don\\'t worry about the \"faster than x%\" part of the solution feedback. The fastest solutions technically pass but obviate the real point of the exercise by using the built-in `List.sort` method."
                    },
                    {
                        "username": "sivapothala",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        i=0\\n        j=0\\n        c=[0]*len(nums1)\\n        print(c)\\n        k=0 \\n        while(i<n and j<n):\\n            if nums1[i] < nums2[j]:\\n                c[k]=nums1[i]\\n                k+=1\\n                i+=1\\n            else:\\n                c[k]=nums2[j]\\n                k+=1\\n                j+=1\\n        vb=j\\n         \\n        while(i<n):\\n            c[k]=nums[i]\\n            i+=1\\n            k+=1\\n\\n        while(vb<n):\\n            c[k]=nums2[vb]\\n            k+=1\\n            vb+=1\\n        nums1[:]=c\\n\\nwhy this is not working .. ?\\nany one can plz help "
                    },
                    {
                        "username": "prominato500",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n            while(i<m) {\\n                if(nums1[i]>nums2[0]) {\\n                    swap(nums1[i], nums2[0]);\\n                    for(int j=0;j<n;j++) {\\n                        if(nums2[j]<nums2[j-1]) {\\n                            swap(nums2[j], nums2[j-1]);\\n                        }\\n                    }\\n                }\\n                i++;\\n            }\\n            for(int j=0; j<n; j++) {\\n                swap(nums1[m+j-1], nums2[j]);\\n            }\\n    }\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nWhere is the error? Please help me."
                    },
                    {
                        "username": "Sagarkumar09",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] arr=new int[n+m];\\n        int l=0;\\n        for(int i=0;i<m;i++){\\n            nums1[l]=nums1[i];\\n            l++;\\n        }\\n        for(int i=0;i<n;i++){\\n            nums1[l]=nums2[i];\\n            l++;\\n                   }\\n        Arrays.sort(nums1);\\n       \\n        for(int j=0;j<nums1.length;j++){\\n            System.out.print(nums1[j]+\" \");           \\n        }     \\n      \\n    }\\n}"
                    },
                    {
                        "username": "Ronak083",
                        "content": "easy solution with runtime 0ms in java \\n public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m-1;\\n        int j = n-1;\\n        int k = m+n-1;\\n        while(k>=0){\\n            if(i>=0 && j>=0){\\n                if(nums1[i]<nums2[j]){\\n                    nums1[k] = nums2[j];\\n                    k--;\\n                    j--;\\n                } else{\\n                    nums1[k] = nums1[i];\\n                    k--;\\n                    i--;\\n                }\\n            } else if(j>=0){\\n                nums1[k] = nums2[j];\\n                k--;\\n                j--;\\n            } else{\\n                break;\\n            }\\n        }\\n    }`"
                    },
                    {
                        "username": "msdhoni2489",
                        "content": "Easy Solution.\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        vector <int> ans;\\n        for(int i=0;i<m;i++)\\n        {\\n            ans.push_back(nums1[i]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums2[i]);\\n        }\\n\\n        sort(ans.begin(),ans.end());\\n        nums1=ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "wanna_be_coder",
                        "content": "\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int j =0;\\n        cout<<nums1[m+1]<<endl;\\n        for(int i = n; i<m+n;i++){\\n            nums1[i] = nums2[j];\\n            j++;\\n        }\\n        sort(nums1.begin(), nums1.end());\\n        }\\n        \\n    }\\n};\\n\\nwhy this is showing runtime error"
                    },
                    {
                        "username": "user7754yr",
                        "content": "I wrote a code and its totally working fine (checked on intellij with the same test case) but leetcode test case fails. I am not sure whether if I can share the code here or not but I do know my code is right. Can someone help with that "
                    }
                ]
            },
            {
                "id": 1774446,
                "content": [
                    {
                        "username": "lehung16082002",
                        "content": "Simple python:\\n\\n\\n\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n      i = m + n - 1\\n      s1 = m-1\\n      s2 = n-1\\n      while s1 >= 0 and s2 >= 0:\\n        if nums1[s1] > nums2[s2]:\\n          nums1[i] = nums1[s1]\\n          s1 -= 1\\n        else:\\n          nums1[i] = nums2[s2]\\n          s2 -= 1\\n        i -= 1\\n      if s2 >= 0:\\n        for i in range(s2+1):\\n          nums1[i] = nums2[i]"
                    },
                    {
                        "username": "Deval28",
                        "content": "How did we get the intuition to make the pointers point to the last index of each array?"
                    },
                    {
                        "username": "eslinger",
                        "content": "[Python3]\\nFor anyone who actually implemented the full sort using two pointers, don\\'t worry about the \"faster than x%\" part of the solution feedback. The fastest solutions technically pass but obviate the real point of the exercise by using the built-in `List.sort` method."
                    },
                    {
                        "username": "sivapothala",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        i=0\\n        j=0\\n        c=[0]*len(nums1)\\n        print(c)\\n        k=0 \\n        while(i<n and j<n):\\n            if nums1[i] < nums2[j]:\\n                c[k]=nums1[i]\\n                k+=1\\n                i+=1\\n            else:\\n                c[k]=nums2[j]\\n                k+=1\\n                j+=1\\n        vb=j\\n         \\n        while(i<n):\\n            c[k]=nums[i]\\n            i+=1\\n            k+=1\\n\\n        while(vb<n):\\n            c[k]=nums2[vb]\\n            k+=1\\n            vb+=1\\n        nums1[:]=c\\n\\nwhy this is not working .. ?\\nany one can plz help "
                    },
                    {
                        "username": "prominato500",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n            while(i<m) {\\n                if(nums1[i]>nums2[0]) {\\n                    swap(nums1[i], nums2[0]);\\n                    for(int j=0;j<n;j++) {\\n                        if(nums2[j]<nums2[j-1]) {\\n                            swap(nums2[j], nums2[j-1]);\\n                        }\\n                    }\\n                }\\n                i++;\\n            }\\n            for(int j=0; j<n; j++) {\\n                swap(nums1[m+j-1], nums2[j]);\\n            }\\n    }\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nWhere is the error? Please help me."
                    },
                    {
                        "username": "Sagarkumar09",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] arr=new int[n+m];\\n        int l=0;\\n        for(int i=0;i<m;i++){\\n            nums1[l]=nums1[i];\\n            l++;\\n        }\\n        for(int i=0;i<n;i++){\\n            nums1[l]=nums2[i];\\n            l++;\\n                   }\\n        Arrays.sort(nums1);\\n       \\n        for(int j=0;j<nums1.length;j++){\\n            System.out.print(nums1[j]+\" \");           \\n        }     \\n      \\n    }\\n}"
                    },
                    {
                        "username": "Ronak083",
                        "content": "easy solution with runtime 0ms in java \\n public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m-1;\\n        int j = n-1;\\n        int k = m+n-1;\\n        while(k>=0){\\n            if(i>=0 && j>=0){\\n                if(nums1[i]<nums2[j]){\\n                    nums1[k] = nums2[j];\\n                    k--;\\n                    j--;\\n                } else{\\n                    nums1[k] = nums1[i];\\n                    k--;\\n                    i--;\\n                }\\n            } else if(j>=0){\\n                nums1[k] = nums2[j];\\n                k--;\\n                j--;\\n            } else{\\n                break;\\n            }\\n        }\\n    }`"
                    },
                    {
                        "username": "msdhoni2489",
                        "content": "Easy Solution.\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        vector <int> ans;\\n        for(int i=0;i<m;i++)\\n        {\\n            ans.push_back(nums1[i]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums2[i]);\\n        }\\n\\n        sort(ans.begin(),ans.end());\\n        nums1=ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "wanna_be_coder",
                        "content": "\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int j =0;\\n        cout<<nums1[m+1]<<endl;\\n        for(int i = n; i<m+n;i++){\\n            nums1[i] = nums2[j];\\n            j++;\\n        }\\n        sort(nums1.begin(), nums1.end());\\n        }\\n        \\n    }\\n};\\n\\nwhy this is showing runtime error"
                    },
                    {
                        "username": "user7754yr",
                        "content": "I wrote a code and its totally working fine (checked on intellij with the same test case) but leetcode test case fails. I am not sure whether if I can share the code here or not but I do know my code is right. Can someone help with that "
                    }
                ]
            },
            {
                "id": 1771475,
                "content": [
                    {
                        "username": "lehung16082002",
                        "content": "Simple python:\\n\\n\\n\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n      i = m + n - 1\\n      s1 = m-1\\n      s2 = n-1\\n      while s1 >= 0 and s2 >= 0:\\n        if nums1[s1] > nums2[s2]:\\n          nums1[i] = nums1[s1]\\n          s1 -= 1\\n        else:\\n          nums1[i] = nums2[s2]\\n          s2 -= 1\\n        i -= 1\\n      if s2 >= 0:\\n        for i in range(s2+1):\\n          nums1[i] = nums2[i]"
                    },
                    {
                        "username": "Deval28",
                        "content": "How did we get the intuition to make the pointers point to the last index of each array?"
                    },
                    {
                        "username": "eslinger",
                        "content": "[Python3]\\nFor anyone who actually implemented the full sort using two pointers, don\\'t worry about the \"faster than x%\" part of the solution feedback. The fastest solutions technically pass but obviate the real point of the exercise by using the built-in `List.sort` method."
                    },
                    {
                        "username": "sivapothala",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        i=0\\n        j=0\\n        c=[0]*len(nums1)\\n        print(c)\\n        k=0 \\n        while(i<n and j<n):\\n            if nums1[i] < nums2[j]:\\n                c[k]=nums1[i]\\n                k+=1\\n                i+=1\\n            else:\\n                c[k]=nums2[j]\\n                k+=1\\n                j+=1\\n        vb=j\\n         \\n        while(i<n):\\n            c[k]=nums[i]\\n            i+=1\\n            k+=1\\n\\n        while(vb<n):\\n            c[k]=nums2[vb]\\n            k+=1\\n            vb+=1\\n        nums1[:]=c\\n\\nwhy this is not working .. ?\\nany one can plz help "
                    },
                    {
                        "username": "prominato500",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n            while(i<m) {\\n                if(nums1[i]>nums2[0]) {\\n                    swap(nums1[i], nums2[0]);\\n                    for(int j=0;j<n;j++) {\\n                        if(nums2[j]<nums2[j-1]) {\\n                            swap(nums2[j], nums2[j-1]);\\n                        }\\n                    }\\n                }\\n                i++;\\n            }\\n            for(int j=0; j<n; j++) {\\n                swap(nums1[m+j-1], nums2[j]);\\n            }\\n    }\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nWhere is the error? Please help me."
                    },
                    {
                        "username": "Sagarkumar09",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] arr=new int[n+m];\\n        int l=0;\\n        for(int i=0;i<m;i++){\\n            nums1[l]=nums1[i];\\n            l++;\\n        }\\n        for(int i=0;i<n;i++){\\n            nums1[l]=nums2[i];\\n            l++;\\n                   }\\n        Arrays.sort(nums1);\\n       \\n        for(int j=0;j<nums1.length;j++){\\n            System.out.print(nums1[j]+\" \");           \\n        }     \\n      \\n    }\\n}"
                    },
                    {
                        "username": "Ronak083",
                        "content": "easy solution with runtime 0ms in java \\n public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m-1;\\n        int j = n-1;\\n        int k = m+n-1;\\n        while(k>=0){\\n            if(i>=0 && j>=0){\\n                if(nums1[i]<nums2[j]){\\n                    nums1[k] = nums2[j];\\n                    k--;\\n                    j--;\\n                } else{\\n                    nums1[k] = nums1[i];\\n                    k--;\\n                    i--;\\n                }\\n            } else if(j>=0){\\n                nums1[k] = nums2[j];\\n                k--;\\n                j--;\\n            } else{\\n                break;\\n            }\\n        }\\n    }`"
                    },
                    {
                        "username": "msdhoni2489",
                        "content": "Easy Solution.\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        vector <int> ans;\\n        for(int i=0;i<m;i++)\\n        {\\n            ans.push_back(nums1[i]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums2[i]);\\n        }\\n\\n        sort(ans.begin(),ans.end());\\n        nums1=ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "wanna_be_coder",
                        "content": "\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int j =0;\\n        cout<<nums1[m+1]<<endl;\\n        for(int i = n; i<m+n;i++){\\n            nums1[i] = nums2[j];\\n            j++;\\n        }\\n        sort(nums1.begin(), nums1.end());\\n        }\\n        \\n    }\\n};\\n\\nwhy this is showing runtime error"
                    },
                    {
                        "username": "user7754yr",
                        "content": "I wrote a code and its totally working fine (checked on intellij with the same test case) but leetcode test case fails. I am not sure whether if I can share the code here or not but I do know my code is right. Can someone help with that "
                    }
                ]
            },
            {
                "id": 1767344,
                "content": [
                    {
                        "username": "lehung16082002",
                        "content": "Simple python:\\n\\n\\n\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n      i = m + n - 1\\n      s1 = m-1\\n      s2 = n-1\\n      while s1 >= 0 and s2 >= 0:\\n        if nums1[s1] > nums2[s2]:\\n          nums1[i] = nums1[s1]\\n          s1 -= 1\\n        else:\\n          nums1[i] = nums2[s2]\\n          s2 -= 1\\n        i -= 1\\n      if s2 >= 0:\\n        for i in range(s2+1):\\n          nums1[i] = nums2[i]"
                    },
                    {
                        "username": "Deval28",
                        "content": "How did we get the intuition to make the pointers point to the last index of each array?"
                    },
                    {
                        "username": "eslinger",
                        "content": "[Python3]\\nFor anyone who actually implemented the full sort using two pointers, don\\'t worry about the \"faster than x%\" part of the solution feedback. The fastest solutions technically pass but obviate the real point of the exercise by using the built-in `List.sort` method."
                    },
                    {
                        "username": "sivapothala",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        i=0\\n        j=0\\n        c=[0]*len(nums1)\\n        print(c)\\n        k=0 \\n        while(i<n and j<n):\\n            if nums1[i] < nums2[j]:\\n                c[k]=nums1[i]\\n                k+=1\\n                i+=1\\n            else:\\n                c[k]=nums2[j]\\n                k+=1\\n                j+=1\\n        vb=j\\n         \\n        while(i<n):\\n            c[k]=nums[i]\\n            i+=1\\n            k+=1\\n\\n        while(vb<n):\\n            c[k]=nums2[vb]\\n            k+=1\\n            vb+=1\\n        nums1[:]=c\\n\\nwhy this is not working .. ?\\nany one can plz help "
                    },
                    {
                        "username": "prominato500",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n            while(i<m) {\\n                if(nums1[i]>nums2[0]) {\\n                    swap(nums1[i], nums2[0]);\\n                    for(int j=0;j<n;j++) {\\n                        if(nums2[j]<nums2[j-1]) {\\n                            swap(nums2[j], nums2[j-1]);\\n                        }\\n                    }\\n                }\\n                i++;\\n            }\\n            for(int j=0; j<n; j++) {\\n                swap(nums1[m+j-1], nums2[j]);\\n            }\\n    }\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nWhere is the error? Please help me."
                    },
                    {
                        "username": "Sagarkumar09",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] arr=new int[n+m];\\n        int l=0;\\n        for(int i=0;i<m;i++){\\n            nums1[l]=nums1[i];\\n            l++;\\n        }\\n        for(int i=0;i<n;i++){\\n            nums1[l]=nums2[i];\\n            l++;\\n                   }\\n        Arrays.sort(nums1);\\n       \\n        for(int j=0;j<nums1.length;j++){\\n            System.out.print(nums1[j]+\" \");           \\n        }     \\n      \\n    }\\n}"
                    },
                    {
                        "username": "Ronak083",
                        "content": "easy solution with runtime 0ms in java \\n public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m-1;\\n        int j = n-1;\\n        int k = m+n-1;\\n        while(k>=0){\\n            if(i>=0 && j>=0){\\n                if(nums1[i]<nums2[j]){\\n                    nums1[k] = nums2[j];\\n                    k--;\\n                    j--;\\n                } else{\\n                    nums1[k] = nums1[i];\\n                    k--;\\n                    i--;\\n                }\\n            } else if(j>=0){\\n                nums1[k] = nums2[j];\\n                k--;\\n                j--;\\n            } else{\\n                break;\\n            }\\n        }\\n    }`"
                    },
                    {
                        "username": "msdhoni2489",
                        "content": "Easy Solution.\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        vector <int> ans;\\n        for(int i=0;i<m;i++)\\n        {\\n            ans.push_back(nums1[i]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums2[i]);\\n        }\\n\\n        sort(ans.begin(),ans.end());\\n        nums1=ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "wanna_be_coder",
                        "content": "\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int j =0;\\n        cout<<nums1[m+1]<<endl;\\n        for(int i = n; i<m+n;i++){\\n            nums1[i] = nums2[j];\\n            j++;\\n        }\\n        sort(nums1.begin(), nums1.end());\\n        }\\n        \\n    }\\n};\\n\\nwhy this is showing runtime error"
                    },
                    {
                        "username": "user7754yr",
                        "content": "I wrote a code and its totally working fine (checked on intellij with the same test case) but leetcode test case fails. I am not sure whether if I can share the code here or not but I do know my code is right. Can someone help with that "
                    }
                ]
            },
            {
                "id": 1766391,
                "content": [
                    {
                        "username": "lehung16082002",
                        "content": "Simple python:\\n\\n\\n\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n      i = m + n - 1\\n      s1 = m-1\\n      s2 = n-1\\n      while s1 >= 0 and s2 >= 0:\\n        if nums1[s1] > nums2[s2]:\\n          nums1[i] = nums1[s1]\\n          s1 -= 1\\n        else:\\n          nums1[i] = nums2[s2]\\n          s2 -= 1\\n        i -= 1\\n      if s2 >= 0:\\n        for i in range(s2+1):\\n          nums1[i] = nums2[i]"
                    },
                    {
                        "username": "Deval28",
                        "content": "How did we get the intuition to make the pointers point to the last index of each array?"
                    },
                    {
                        "username": "eslinger",
                        "content": "[Python3]\\nFor anyone who actually implemented the full sort using two pointers, don\\'t worry about the \"faster than x%\" part of the solution feedback. The fastest solutions technically pass but obviate the real point of the exercise by using the built-in `List.sort` method."
                    },
                    {
                        "username": "sivapothala",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        i=0\\n        j=0\\n        c=[0]*len(nums1)\\n        print(c)\\n        k=0 \\n        while(i<n and j<n):\\n            if nums1[i] < nums2[j]:\\n                c[k]=nums1[i]\\n                k+=1\\n                i+=1\\n            else:\\n                c[k]=nums2[j]\\n                k+=1\\n                j+=1\\n        vb=j\\n         \\n        while(i<n):\\n            c[k]=nums[i]\\n            i+=1\\n            k+=1\\n\\n        while(vb<n):\\n            c[k]=nums2[vb]\\n            k+=1\\n            vb+=1\\n        nums1[:]=c\\n\\nwhy this is not working .. ?\\nany one can plz help "
                    },
                    {
                        "username": "prominato500",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n            while(i<m) {\\n                if(nums1[i]>nums2[0]) {\\n                    swap(nums1[i], nums2[0]);\\n                    for(int j=0;j<n;j++) {\\n                        if(nums2[j]<nums2[j-1]) {\\n                            swap(nums2[j], nums2[j-1]);\\n                        }\\n                    }\\n                }\\n                i++;\\n            }\\n            for(int j=0; j<n; j++) {\\n                swap(nums1[m+j-1], nums2[j]);\\n            }\\n    }\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nWhere is the error? Please help me."
                    },
                    {
                        "username": "Sagarkumar09",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] arr=new int[n+m];\\n        int l=0;\\n        for(int i=0;i<m;i++){\\n            nums1[l]=nums1[i];\\n            l++;\\n        }\\n        for(int i=0;i<n;i++){\\n            nums1[l]=nums2[i];\\n            l++;\\n                   }\\n        Arrays.sort(nums1);\\n       \\n        for(int j=0;j<nums1.length;j++){\\n            System.out.print(nums1[j]+\" \");           \\n        }     \\n      \\n    }\\n}"
                    },
                    {
                        "username": "Ronak083",
                        "content": "easy solution with runtime 0ms in java \\n public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m-1;\\n        int j = n-1;\\n        int k = m+n-1;\\n        while(k>=0){\\n            if(i>=0 && j>=0){\\n                if(nums1[i]<nums2[j]){\\n                    nums1[k] = nums2[j];\\n                    k--;\\n                    j--;\\n                } else{\\n                    nums1[k] = nums1[i];\\n                    k--;\\n                    i--;\\n                }\\n            } else if(j>=0){\\n                nums1[k] = nums2[j];\\n                k--;\\n                j--;\\n            } else{\\n                break;\\n            }\\n        }\\n    }`"
                    },
                    {
                        "username": "msdhoni2489",
                        "content": "Easy Solution.\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        vector <int> ans;\\n        for(int i=0;i<m;i++)\\n        {\\n            ans.push_back(nums1[i]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums2[i]);\\n        }\\n\\n        sort(ans.begin(),ans.end());\\n        nums1=ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "wanna_be_coder",
                        "content": "\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int j =0;\\n        cout<<nums1[m+1]<<endl;\\n        for(int i = n; i<m+n;i++){\\n            nums1[i] = nums2[j];\\n            j++;\\n        }\\n        sort(nums1.begin(), nums1.end());\\n        }\\n        \\n    }\\n};\\n\\nwhy this is showing runtime error"
                    },
                    {
                        "username": "user7754yr",
                        "content": "I wrote a code and its totally working fine (checked on intellij with the same test case) but leetcode test case fails. I am not sure whether if I can share the code here or not but I do know my code is right. Can someone help with that "
                    }
                ]
            },
            {
                "id": 1763176,
                "content": [
                    {
                        "username": "lehung16082002",
                        "content": "Simple python:\\n\\n\\n\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n      i = m + n - 1\\n      s1 = m-1\\n      s2 = n-1\\n      while s1 >= 0 and s2 >= 0:\\n        if nums1[s1] > nums2[s2]:\\n          nums1[i] = nums1[s1]\\n          s1 -= 1\\n        else:\\n          nums1[i] = nums2[s2]\\n          s2 -= 1\\n        i -= 1\\n      if s2 >= 0:\\n        for i in range(s2+1):\\n          nums1[i] = nums2[i]"
                    },
                    {
                        "username": "Deval28",
                        "content": "How did we get the intuition to make the pointers point to the last index of each array?"
                    },
                    {
                        "username": "eslinger",
                        "content": "[Python3]\\nFor anyone who actually implemented the full sort using two pointers, don\\'t worry about the \"faster than x%\" part of the solution feedback. The fastest solutions technically pass but obviate the real point of the exercise by using the built-in `List.sort` method."
                    },
                    {
                        "username": "sivapothala",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        i=0\\n        j=0\\n        c=[0]*len(nums1)\\n        print(c)\\n        k=0 \\n        while(i<n and j<n):\\n            if nums1[i] < nums2[j]:\\n                c[k]=nums1[i]\\n                k+=1\\n                i+=1\\n            else:\\n                c[k]=nums2[j]\\n                k+=1\\n                j+=1\\n        vb=j\\n         \\n        while(i<n):\\n            c[k]=nums[i]\\n            i+=1\\n            k+=1\\n\\n        while(vb<n):\\n            c[k]=nums2[vb]\\n            k+=1\\n            vb+=1\\n        nums1[:]=c\\n\\nwhy this is not working .. ?\\nany one can plz help "
                    },
                    {
                        "username": "prominato500",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n            while(i<m) {\\n                if(nums1[i]>nums2[0]) {\\n                    swap(nums1[i], nums2[0]);\\n                    for(int j=0;j<n;j++) {\\n                        if(nums2[j]<nums2[j-1]) {\\n                            swap(nums2[j], nums2[j-1]);\\n                        }\\n                    }\\n                }\\n                i++;\\n            }\\n            for(int j=0; j<n; j++) {\\n                swap(nums1[m+j-1], nums2[j]);\\n            }\\n    }\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nWhere is the error? Please help me."
                    },
                    {
                        "username": "Sagarkumar09",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] arr=new int[n+m];\\n        int l=0;\\n        for(int i=0;i<m;i++){\\n            nums1[l]=nums1[i];\\n            l++;\\n        }\\n        for(int i=0;i<n;i++){\\n            nums1[l]=nums2[i];\\n            l++;\\n                   }\\n        Arrays.sort(nums1);\\n       \\n        for(int j=0;j<nums1.length;j++){\\n            System.out.print(nums1[j]+\" \");           \\n        }     \\n      \\n    }\\n}"
                    },
                    {
                        "username": "Ronak083",
                        "content": "easy solution with runtime 0ms in java \\n public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m-1;\\n        int j = n-1;\\n        int k = m+n-1;\\n        while(k>=0){\\n            if(i>=0 && j>=0){\\n                if(nums1[i]<nums2[j]){\\n                    nums1[k] = nums2[j];\\n                    k--;\\n                    j--;\\n                } else{\\n                    nums1[k] = nums1[i];\\n                    k--;\\n                    i--;\\n                }\\n            } else if(j>=0){\\n                nums1[k] = nums2[j];\\n                k--;\\n                j--;\\n            } else{\\n                break;\\n            }\\n        }\\n    }`"
                    },
                    {
                        "username": "msdhoni2489",
                        "content": "Easy Solution.\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        vector <int> ans;\\n        for(int i=0;i<m;i++)\\n        {\\n            ans.push_back(nums1[i]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums2[i]);\\n        }\\n\\n        sort(ans.begin(),ans.end());\\n        nums1=ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "wanna_be_coder",
                        "content": "\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int j =0;\\n        cout<<nums1[m+1]<<endl;\\n        for(int i = n; i<m+n;i++){\\n            nums1[i] = nums2[j];\\n            j++;\\n        }\\n        sort(nums1.begin(), nums1.end());\\n        }\\n        \\n    }\\n};\\n\\nwhy this is showing runtime error"
                    },
                    {
                        "username": "user7754yr",
                        "content": "I wrote a code and its totally working fine (checked on intellij with the same test case) but leetcode test case fails. I am not sure whether if I can share the code here or not but I do know my code is right. Can someone help with that "
                    }
                ]
            },
            {
                "id": 1763045,
                "content": [
                    {
                        "username": "lehung16082002",
                        "content": "Simple python:\\n\\n\\n\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n      i = m + n - 1\\n      s1 = m-1\\n      s2 = n-1\\n      while s1 >= 0 and s2 >= 0:\\n        if nums1[s1] > nums2[s2]:\\n          nums1[i] = nums1[s1]\\n          s1 -= 1\\n        else:\\n          nums1[i] = nums2[s2]\\n          s2 -= 1\\n        i -= 1\\n      if s2 >= 0:\\n        for i in range(s2+1):\\n          nums1[i] = nums2[i]"
                    },
                    {
                        "username": "Deval28",
                        "content": "How did we get the intuition to make the pointers point to the last index of each array?"
                    },
                    {
                        "username": "eslinger",
                        "content": "[Python3]\\nFor anyone who actually implemented the full sort using two pointers, don\\'t worry about the \"faster than x%\" part of the solution feedback. The fastest solutions technically pass but obviate the real point of the exercise by using the built-in `List.sort` method."
                    },
                    {
                        "username": "sivapothala",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        i=0\\n        j=0\\n        c=[0]*len(nums1)\\n        print(c)\\n        k=0 \\n        while(i<n and j<n):\\n            if nums1[i] < nums2[j]:\\n                c[k]=nums1[i]\\n                k+=1\\n                i+=1\\n            else:\\n                c[k]=nums2[j]\\n                k+=1\\n                j+=1\\n        vb=j\\n         \\n        while(i<n):\\n            c[k]=nums[i]\\n            i+=1\\n            k+=1\\n\\n        while(vb<n):\\n            c[k]=nums2[vb]\\n            k+=1\\n            vb+=1\\n        nums1[:]=c\\n\\nwhy this is not working .. ?\\nany one can plz help "
                    },
                    {
                        "username": "prominato500",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n            while(i<m) {\\n                if(nums1[i]>nums2[0]) {\\n                    swap(nums1[i], nums2[0]);\\n                    for(int j=0;j<n;j++) {\\n                        if(nums2[j]<nums2[j-1]) {\\n                            swap(nums2[j], nums2[j-1]);\\n                        }\\n                    }\\n                }\\n                i++;\\n            }\\n            for(int j=0; j<n; j++) {\\n                swap(nums1[m+j-1], nums2[j]);\\n            }\\n    }\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nWhere is the error? Please help me."
                    },
                    {
                        "username": "Sagarkumar09",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] arr=new int[n+m];\\n        int l=0;\\n        for(int i=0;i<m;i++){\\n            nums1[l]=nums1[i];\\n            l++;\\n        }\\n        for(int i=0;i<n;i++){\\n            nums1[l]=nums2[i];\\n            l++;\\n                   }\\n        Arrays.sort(nums1);\\n       \\n        for(int j=0;j<nums1.length;j++){\\n            System.out.print(nums1[j]+\" \");           \\n        }     \\n      \\n    }\\n}"
                    },
                    {
                        "username": "Ronak083",
                        "content": "easy solution with runtime 0ms in java \\n public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m-1;\\n        int j = n-1;\\n        int k = m+n-1;\\n        while(k>=0){\\n            if(i>=0 && j>=0){\\n                if(nums1[i]<nums2[j]){\\n                    nums1[k] = nums2[j];\\n                    k--;\\n                    j--;\\n                } else{\\n                    nums1[k] = nums1[i];\\n                    k--;\\n                    i--;\\n                }\\n            } else if(j>=0){\\n                nums1[k] = nums2[j];\\n                k--;\\n                j--;\\n            } else{\\n                break;\\n            }\\n        }\\n    }`"
                    },
                    {
                        "username": "msdhoni2489",
                        "content": "Easy Solution.\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        vector <int> ans;\\n        for(int i=0;i<m;i++)\\n        {\\n            ans.push_back(nums1[i]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums2[i]);\\n        }\\n\\n        sort(ans.begin(),ans.end());\\n        nums1=ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "wanna_be_coder",
                        "content": "\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int j =0;\\n        cout<<nums1[m+1]<<endl;\\n        for(int i = n; i<m+n;i++){\\n            nums1[i] = nums2[j];\\n            j++;\\n        }\\n        sort(nums1.begin(), nums1.end());\\n        }\\n        \\n    }\\n};\\n\\nwhy this is showing runtime error"
                    },
                    {
                        "username": "user7754yr",
                        "content": "I wrote a code and its totally working fine (checked on intellij with the same test case) but leetcode test case fails. I am not sure whether if I can share the code here or not but I do know my code is right. Can someone help with that "
                    }
                ]
            },
            {
                "id": 1760873,
                "content": [
                    {
                        "username": "lehung16082002",
                        "content": "Simple python:\\n\\n\\n\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n      i = m + n - 1\\n      s1 = m-1\\n      s2 = n-1\\n      while s1 >= 0 and s2 >= 0:\\n        if nums1[s1] > nums2[s2]:\\n          nums1[i] = nums1[s1]\\n          s1 -= 1\\n        else:\\n          nums1[i] = nums2[s2]\\n          s2 -= 1\\n        i -= 1\\n      if s2 >= 0:\\n        for i in range(s2+1):\\n          nums1[i] = nums2[i]"
                    },
                    {
                        "username": "Deval28",
                        "content": "How did we get the intuition to make the pointers point to the last index of each array?"
                    },
                    {
                        "username": "eslinger",
                        "content": "[Python3]\\nFor anyone who actually implemented the full sort using two pointers, don\\'t worry about the \"faster than x%\" part of the solution feedback. The fastest solutions technically pass but obviate the real point of the exercise by using the built-in `List.sort` method."
                    },
                    {
                        "username": "sivapothala",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        i=0\\n        j=0\\n        c=[0]*len(nums1)\\n        print(c)\\n        k=0 \\n        while(i<n and j<n):\\n            if nums1[i] < nums2[j]:\\n                c[k]=nums1[i]\\n                k+=1\\n                i+=1\\n            else:\\n                c[k]=nums2[j]\\n                k+=1\\n                j+=1\\n        vb=j\\n         \\n        while(i<n):\\n            c[k]=nums[i]\\n            i+=1\\n            k+=1\\n\\n        while(vb<n):\\n            c[k]=nums2[vb]\\n            k+=1\\n            vb+=1\\n        nums1[:]=c\\n\\nwhy this is not working .. ?\\nany one can plz help "
                    },
                    {
                        "username": "prominato500",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n            while(i<m) {\\n                if(nums1[i]>nums2[0]) {\\n                    swap(nums1[i], nums2[0]);\\n                    for(int j=0;j<n;j++) {\\n                        if(nums2[j]<nums2[j-1]) {\\n                            swap(nums2[j], nums2[j-1]);\\n                        }\\n                    }\\n                }\\n                i++;\\n            }\\n            for(int j=0; j<n; j++) {\\n                swap(nums1[m+j-1], nums2[j]);\\n            }\\n    }\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nWhere is the error? Please help me."
                    },
                    {
                        "username": "Sagarkumar09",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] arr=new int[n+m];\\n        int l=0;\\n        for(int i=0;i<m;i++){\\n            nums1[l]=nums1[i];\\n            l++;\\n        }\\n        for(int i=0;i<n;i++){\\n            nums1[l]=nums2[i];\\n            l++;\\n                   }\\n        Arrays.sort(nums1);\\n       \\n        for(int j=0;j<nums1.length;j++){\\n            System.out.print(nums1[j]+\" \");           \\n        }     \\n      \\n    }\\n}"
                    },
                    {
                        "username": "Ronak083",
                        "content": "easy solution with runtime 0ms in java \\n public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m-1;\\n        int j = n-1;\\n        int k = m+n-1;\\n        while(k>=0){\\n            if(i>=0 && j>=0){\\n                if(nums1[i]<nums2[j]){\\n                    nums1[k] = nums2[j];\\n                    k--;\\n                    j--;\\n                } else{\\n                    nums1[k] = nums1[i];\\n                    k--;\\n                    i--;\\n                }\\n            } else if(j>=0){\\n                nums1[k] = nums2[j];\\n                k--;\\n                j--;\\n            } else{\\n                break;\\n            }\\n        }\\n    }`"
                    },
                    {
                        "username": "msdhoni2489",
                        "content": "Easy Solution.\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        vector <int> ans;\\n        for(int i=0;i<m;i++)\\n        {\\n            ans.push_back(nums1[i]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums2[i]);\\n        }\\n\\n        sort(ans.begin(),ans.end());\\n        nums1=ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "wanna_be_coder",
                        "content": "\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int j =0;\\n        cout<<nums1[m+1]<<endl;\\n        for(int i = n; i<m+n;i++){\\n            nums1[i] = nums2[j];\\n            j++;\\n        }\\n        sort(nums1.begin(), nums1.end());\\n        }\\n        \\n    }\\n};\\n\\nwhy this is showing runtime error"
                    },
                    {
                        "username": "user7754yr",
                        "content": "I wrote a code and its totally working fine (checked on intellij with the same test case) but leetcode test case fails. I am not sure whether if I can share the code here or not but I do know my code is right. Can someone help with that "
                    }
                ]
            },
            {
                "id": 1757987,
                "content": [
                    {
                        "username": "lehung16082002",
                        "content": "Simple python:\\n\\n\\n\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n      i = m + n - 1\\n      s1 = m-1\\n      s2 = n-1\\n      while s1 >= 0 and s2 >= 0:\\n        if nums1[s1] > nums2[s2]:\\n          nums1[i] = nums1[s1]\\n          s1 -= 1\\n        else:\\n          nums1[i] = nums2[s2]\\n          s2 -= 1\\n        i -= 1\\n      if s2 >= 0:\\n        for i in range(s2+1):\\n          nums1[i] = nums2[i]"
                    },
                    {
                        "username": "Deval28",
                        "content": "How did we get the intuition to make the pointers point to the last index of each array?"
                    },
                    {
                        "username": "eslinger",
                        "content": "[Python3]\\nFor anyone who actually implemented the full sort using two pointers, don\\'t worry about the \"faster than x%\" part of the solution feedback. The fastest solutions technically pass but obviate the real point of the exercise by using the built-in `List.sort` method."
                    },
                    {
                        "username": "sivapothala",
                        "content": "class Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        i=0\\n        j=0\\n        c=[0]*len(nums1)\\n        print(c)\\n        k=0 \\n        while(i<n and j<n):\\n            if nums1[i] < nums2[j]:\\n                c[k]=nums1[i]\\n                k+=1\\n                i+=1\\n            else:\\n                c[k]=nums2[j]\\n                k+=1\\n                j+=1\\n        vb=j\\n         \\n        while(i<n):\\n            c[k]=nums[i]\\n            i+=1\\n            k+=1\\n\\n        while(vb<n):\\n            c[k]=nums2[vb]\\n            k+=1\\n            vb+=1\\n        nums1[:]=c\\n\\nwhy this is not working .. ?\\nany one can plz help "
                    },
                    {
                        "username": "prominato500",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=0;\\n            while(i<m) {\\n                if(nums1[i]>nums2[0]) {\\n                    swap(nums1[i], nums2[0]);\\n                    for(int j=0;j<n;j++) {\\n                        if(nums2[j]<nums2[j-1]) {\\n                            swap(nums2[j], nums2[j-1]);\\n                        }\\n                    }\\n                }\\n                i++;\\n            }\\n            for(int j=0; j<n; j++) {\\n                swap(nums1[m+j-1], nums2[j]);\\n            }\\n    }\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nWhere is the error? Please help me."
                    },
                    {
                        "username": "Sagarkumar09",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] arr=new int[n+m];\\n        int l=0;\\n        for(int i=0;i<m;i++){\\n            nums1[l]=nums1[i];\\n            l++;\\n        }\\n        for(int i=0;i<n;i++){\\n            nums1[l]=nums2[i];\\n            l++;\\n                   }\\n        Arrays.sort(nums1);\\n       \\n        for(int j=0;j<nums1.length;j++){\\n            System.out.print(nums1[j]+\" \");           \\n        }     \\n      \\n    }\\n}"
                    },
                    {
                        "username": "Ronak083",
                        "content": "easy solution with runtime 0ms in java \\n public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m-1;\\n        int j = n-1;\\n        int k = m+n-1;\\n        while(k>=0){\\n            if(i>=0 && j>=0){\\n                if(nums1[i]<nums2[j]){\\n                    nums1[k] = nums2[j];\\n                    k--;\\n                    j--;\\n                } else{\\n                    nums1[k] = nums1[i];\\n                    k--;\\n                    i--;\\n                }\\n            } else if(j>=0){\\n                nums1[k] = nums2[j];\\n                k--;\\n                j--;\\n            } else{\\n                break;\\n            }\\n        }\\n    }`"
                    },
                    {
                        "username": "msdhoni2489",
                        "content": "Easy Solution.\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        vector <int> ans;\\n        for(int i=0;i<m;i++)\\n        {\\n            ans.push_back(nums1[i]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums2[i]);\\n        }\\n\\n        sort(ans.begin(),ans.end());\\n        nums1=ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "wanna_be_coder",
                        "content": "\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        int j =0;\\n        cout<<nums1[m+1]<<endl;\\n        for(int i = n; i<m+n;i++){\\n            nums1[i] = nums2[j];\\n            j++;\\n        }\\n        sort(nums1.begin(), nums1.end());\\n        }\\n        \\n    }\\n};\\n\\nwhy this is showing runtime error"
                    },
                    {
                        "username": "user7754yr",
                        "content": "I wrote a code and its totally working fine (checked on intellij with the same test case) but leetcode test case fails. I am not sure whether if I can share the code here or not but I do know my code is right. Can someone help with that "
                    }
                ]
            },
            {
                "id": 1757088,
                "content": [
                    {
                        "username": "mrin2810",
                        "content": "Accepted, Easy Solution \n\nTraverse Through both the arrays always placing the smaller number in the destination array.\n\n`class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int i = -1;\n        int j = 0;\n        while (++i < m && j < n){\n            if (nums2[j] < nums1[i]){\n                int temp = nums1[i];\n                nums1[i] = nums2[j];\n                nums2[j] = temp;\n                Arrays.sort(nums2);\n            }\n        }\n        for (int num : nums2) {\n            nums1[i++] = num;\n        }\n    }\n}`"
                    },
                    {
                        "username": "sowvino",
                        "content": " `var merge = function(nums1, m, nums2, n) {\\n    let arr3=[0];\\n    let array1 = nums1.filter(x => !arr3.includes(x));\\n    let array2 =nums2.filter(x => !arr3.includes(x));\\n    let val = [...array1,...array2];\\n    return val.sort((a,b)=>a-b);\\n  \\n}; `\\n\\nWhy this solution is not working"
                    },
                    {
                        "username": "hegdeanirudh2003",
                        "content": "nums1[:] = sorted(nums1[:m]+nums2)\\nwhy to use [:] after nums1?\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "artiksingh145",
                        "content": "I did it only in 3 lines(JAVA used)\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k=m+n;\\n        for(int i=m; i<k; i++){\\n           nums1[i]=nums2[i-m];        \\n        }\\n        Arrays.sort(nums1);\\n\\n    }\\n}"
                    },
                    {
                        "username": "An-u-rag",
                        "content": "time complexity increases with sort()"
                    },
                    {
                        "username": "Saad03",
                        "content": "I don\\'t get error when I run in jupyter notyebook but I have trouble running code here...can someonw tell me what the problem is\\ndef merge(self, nums1, m, nums2, n):\\n        emp=[]\\n        for i in range(0,len(nums1)): #instead of n and m, I used len func\\n            if nums1[i]!=0:\\n                 emp.append(nums1[i])\\n        for j in range(0,len(nums2)):\\n             if nums2[j]!=0:\\n                emp.append(nums2[j])\\n        emp.sort()\\n        nums1=emp\\n        print(nums1)\\n"
                    },
                    {
                        "username": "pavandeore",
                        "content": "i have having an error \\ncan someone explain what is wrong with this code\\n\\n```\\n\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1.length = m \\n    nums2.length = n\\n    nums1 = nums1.concat(nums2).sort((a,b) => a-b )\\n};\\n\\n\\n```"
                    },
                    {
                        "username": "Yashw12",
                        "content": "    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n)\\n   {\\n       int x,y=0;\\n       int p= m + n;\\n        vector<int> w[p];\\n      for(int l=0;l<p;l++)\\n    { \\n        if(x<m && y<n)\\n        {\\n            if(nums1[x]<nums2[y])\\n            {\\n                w[l]= nums1[x];\\n                x++;\\n            }\\n            else\\n            {\\n                w[l]=nums2[y];\\n                y++;\\n            }\\n        }\\n        else if (x>m)\\n        {\\n            w[l]= nums2[y];\\n            y++;\\n        }\\n        else\\n        {\\n            w[l] = nums1[x];\\n            x++;\\n        }       \\n    }\\n        nums1=w;       \\n    }\\ni am getting compile error. Can anyone help me out?"
                    },
                    {
                        "username": "VivekReddy21",
                        "content": "class Solution {\\n\\n    public void swap(int a, int b, int[] nums){\\n        int temp=nums[a];\\n        nums[a]=nums[b];\\n        nums[b]=temp;\\n    }\\n\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\n        int j=0;\\n        for(int i=m;i<m+n;i++){\\n            nums1[i]=nums2[j++];\\n        }\\n\\n        int gap=(m+n)/2;\\n        while(gap!=0){\\n            for(int i=0;i<nums1.length;i=i+1){\\n                //we compare pairs at gap \\n                if(i+gap<nums1.length && nums1[i]>nums1[i+gap]){\\n                    swap(i,i+gap,nums1);\\n                }\\n            }\\n            gap=gap-1;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1756283,
                "content": [
                    {
                        "username": "mrin2810",
                        "content": "Accepted, Easy Solution \n\nTraverse Through both the arrays always placing the smaller number in the destination array.\n\n`class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int i = -1;\n        int j = 0;\n        while (++i < m && j < n){\n            if (nums2[j] < nums1[i]){\n                int temp = nums1[i];\n                nums1[i] = nums2[j];\n                nums2[j] = temp;\n                Arrays.sort(nums2);\n            }\n        }\n        for (int num : nums2) {\n            nums1[i++] = num;\n        }\n    }\n}`"
                    },
                    {
                        "username": "sowvino",
                        "content": " `var merge = function(nums1, m, nums2, n) {\\n    let arr3=[0];\\n    let array1 = nums1.filter(x => !arr3.includes(x));\\n    let array2 =nums2.filter(x => !arr3.includes(x));\\n    let val = [...array1,...array2];\\n    return val.sort((a,b)=>a-b);\\n  \\n}; `\\n\\nWhy this solution is not working"
                    },
                    {
                        "username": "hegdeanirudh2003",
                        "content": "nums1[:] = sorted(nums1[:m]+nums2)\\nwhy to use [:] after nums1?\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "artiksingh145",
                        "content": "I did it only in 3 lines(JAVA used)\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k=m+n;\\n        for(int i=m; i<k; i++){\\n           nums1[i]=nums2[i-m];        \\n        }\\n        Arrays.sort(nums1);\\n\\n    }\\n}"
                    },
                    {
                        "username": "An-u-rag",
                        "content": "time complexity increases with sort()"
                    },
                    {
                        "username": "Saad03",
                        "content": "I don\\'t get error when I run in jupyter notyebook but I have trouble running code here...can someonw tell me what the problem is\\ndef merge(self, nums1, m, nums2, n):\\n        emp=[]\\n        for i in range(0,len(nums1)): #instead of n and m, I used len func\\n            if nums1[i]!=0:\\n                 emp.append(nums1[i])\\n        for j in range(0,len(nums2)):\\n             if nums2[j]!=0:\\n                emp.append(nums2[j])\\n        emp.sort()\\n        nums1=emp\\n        print(nums1)\\n"
                    },
                    {
                        "username": "pavandeore",
                        "content": "i have having an error \\ncan someone explain what is wrong with this code\\n\\n```\\n\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1.length = m \\n    nums2.length = n\\n    nums1 = nums1.concat(nums2).sort((a,b) => a-b )\\n};\\n\\n\\n```"
                    },
                    {
                        "username": "Yashw12",
                        "content": "    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n)\\n   {\\n       int x,y=0;\\n       int p= m + n;\\n        vector<int> w[p];\\n      for(int l=0;l<p;l++)\\n    { \\n        if(x<m && y<n)\\n        {\\n            if(nums1[x]<nums2[y])\\n            {\\n                w[l]= nums1[x];\\n                x++;\\n            }\\n            else\\n            {\\n                w[l]=nums2[y];\\n                y++;\\n            }\\n        }\\n        else if (x>m)\\n        {\\n            w[l]= nums2[y];\\n            y++;\\n        }\\n        else\\n        {\\n            w[l] = nums1[x];\\n            x++;\\n        }       \\n    }\\n        nums1=w;       \\n    }\\ni am getting compile error. Can anyone help me out?"
                    },
                    {
                        "username": "VivekReddy21",
                        "content": "class Solution {\\n\\n    public void swap(int a, int b, int[] nums){\\n        int temp=nums[a];\\n        nums[a]=nums[b];\\n        nums[b]=temp;\\n    }\\n\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\n        int j=0;\\n        for(int i=m;i<m+n;i++){\\n            nums1[i]=nums2[j++];\\n        }\\n\\n        int gap=(m+n)/2;\\n        while(gap!=0){\\n            for(int i=0;i<nums1.length;i=i+1){\\n                //we compare pairs at gap \\n                if(i+gap<nums1.length && nums1[i]>nums1[i+gap]){\\n                    swap(i,i+gap,nums1);\\n                }\\n            }\\n            gap=gap-1;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1754391,
                "content": [
                    {
                        "username": "mrin2810",
                        "content": "Accepted, Easy Solution \n\nTraverse Through both the arrays always placing the smaller number in the destination array.\n\n`class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int i = -1;\n        int j = 0;\n        while (++i < m && j < n){\n            if (nums2[j] < nums1[i]){\n                int temp = nums1[i];\n                nums1[i] = nums2[j];\n                nums2[j] = temp;\n                Arrays.sort(nums2);\n            }\n        }\n        for (int num : nums2) {\n            nums1[i++] = num;\n        }\n    }\n}`"
                    },
                    {
                        "username": "sowvino",
                        "content": " `var merge = function(nums1, m, nums2, n) {\\n    let arr3=[0];\\n    let array1 = nums1.filter(x => !arr3.includes(x));\\n    let array2 =nums2.filter(x => !arr3.includes(x));\\n    let val = [...array1,...array2];\\n    return val.sort((a,b)=>a-b);\\n  \\n}; `\\n\\nWhy this solution is not working"
                    },
                    {
                        "username": "hegdeanirudh2003",
                        "content": "nums1[:] = sorted(nums1[:m]+nums2)\\nwhy to use [:] after nums1?\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "artiksingh145",
                        "content": "I did it only in 3 lines(JAVA used)\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k=m+n;\\n        for(int i=m; i<k; i++){\\n           nums1[i]=nums2[i-m];        \\n        }\\n        Arrays.sort(nums1);\\n\\n    }\\n}"
                    },
                    {
                        "username": "An-u-rag",
                        "content": "time complexity increases with sort()"
                    },
                    {
                        "username": "Saad03",
                        "content": "I don\\'t get error when I run in jupyter notyebook but I have trouble running code here...can someonw tell me what the problem is\\ndef merge(self, nums1, m, nums2, n):\\n        emp=[]\\n        for i in range(0,len(nums1)): #instead of n and m, I used len func\\n            if nums1[i]!=0:\\n                 emp.append(nums1[i])\\n        for j in range(0,len(nums2)):\\n             if nums2[j]!=0:\\n                emp.append(nums2[j])\\n        emp.sort()\\n        nums1=emp\\n        print(nums1)\\n"
                    },
                    {
                        "username": "pavandeore",
                        "content": "i have having an error \\ncan someone explain what is wrong with this code\\n\\n```\\n\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1.length = m \\n    nums2.length = n\\n    nums1 = nums1.concat(nums2).sort((a,b) => a-b )\\n};\\n\\n\\n```"
                    },
                    {
                        "username": "Yashw12",
                        "content": "    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n)\\n   {\\n       int x,y=0;\\n       int p= m + n;\\n        vector<int> w[p];\\n      for(int l=0;l<p;l++)\\n    { \\n        if(x<m && y<n)\\n        {\\n            if(nums1[x]<nums2[y])\\n            {\\n                w[l]= nums1[x];\\n                x++;\\n            }\\n            else\\n            {\\n                w[l]=nums2[y];\\n                y++;\\n            }\\n        }\\n        else if (x>m)\\n        {\\n            w[l]= nums2[y];\\n            y++;\\n        }\\n        else\\n        {\\n            w[l] = nums1[x];\\n            x++;\\n        }       \\n    }\\n        nums1=w;       \\n    }\\ni am getting compile error. Can anyone help me out?"
                    },
                    {
                        "username": "VivekReddy21",
                        "content": "class Solution {\\n\\n    public void swap(int a, int b, int[] nums){\\n        int temp=nums[a];\\n        nums[a]=nums[b];\\n        nums[b]=temp;\\n    }\\n\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\n        int j=0;\\n        for(int i=m;i<m+n;i++){\\n            nums1[i]=nums2[j++];\\n        }\\n\\n        int gap=(m+n)/2;\\n        while(gap!=0){\\n            for(int i=0;i<nums1.length;i=i+1){\\n                //we compare pairs at gap \\n                if(i+gap<nums1.length && nums1[i]>nums1[i+gap]){\\n                    swap(i,i+gap,nums1);\\n                }\\n            }\\n            gap=gap-1;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1754149,
                "content": [
                    {
                        "username": "mrin2810",
                        "content": "Accepted, Easy Solution \n\nTraverse Through both the arrays always placing the smaller number in the destination array.\n\n`class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int i = -1;\n        int j = 0;\n        while (++i < m && j < n){\n            if (nums2[j] < nums1[i]){\n                int temp = nums1[i];\n                nums1[i] = nums2[j];\n                nums2[j] = temp;\n                Arrays.sort(nums2);\n            }\n        }\n        for (int num : nums2) {\n            nums1[i++] = num;\n        }\n    }\n}`"
                    },
                    {
                        "username": "sowvino",
                        "content": " `var merge = function(nums1, m, nums2, n) {\\n    let arr3=[0];\\n    let array1 = nums1.filter(x => !arr3.includes(x));\\n    let array2 =nums2.filter(x => !arr3.includes(x));\\n    let val = [...array1,...array2];\\n    return val.sort((a,b)=>a-b);\\n  \\n}; `\\n\\nWhy this solution is not working"
                    },
                    {
                        "username": "hegdeanirudh2003",
                        "content": "nums1[:] = sorted(nums1[:m]+nums2)\\nwhy to use [:] after nums1?\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "artiksingh145",
                        "content": "I did it only in 3 lines(JAVA used)\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k=m+n;\\n        for(int i=m; i<k; i++){\\n           nums1[i]=nums2[i-m];        \\n        }\\n        Arrays.sort(nums1);\\n\\n    }\\n}"
                    },
                    {
                        "username": "An-u-rag",
                        "content": "time complexity increases with sort()"
                    },
                    {
                        "username": "Saad03",
                        "content": "I don\\'t get error when I run in jupyter notyebook but I have trouble running code here...can someonw tell me what the problem is\\ndef merge(self, nums1, m, nums2, n):\\n        emp=[]\\n        for i in range(0,len(nums1)): #instead of n and m, I used len func\\n            if nums1[i]!=0:\\n                 emp.append(nums1[i])\\n        for j in range(0,len(nums2)):\\n             if nums2[j]!=0:\\n                emp.append(nums2[j])\\n        emp.sort()\\n        nums1=emp\\n        print(nums1)\\n"
                    },
                    {
                        "username": "pavandeore",
                        "content": "i have having an error \\ncan someone explain what is wrong with this code\\n\\n```\\n\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1.length = m \\n    nums2.length = n\\n    nums1 = nums1.concat(nums2).sort((a,b) => a-b )\\n};\\n\\n\\n```"
                    },
                    {
                        "username": "Yashw12",
                        "content": "    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n)\\n   {\\n       int x,y=0;\\n       int p= m + n;\\n        vector<int> w[p];\\n      for(int l=0;l<p;l++)\\n    { \\n        if(x<m && y<n)\\n        {\\n            if(nums1[x]<nums2[y])\\n            {\\n                w[l]= nums1[x];\\n                x++;\\n            }\\n            else\\n            {\\n                w[l]=nums2[y];\\n                y++;\\n            }\\n        }\\n        else if (x>m)\\n        {\\n            w[l]= nums2[y];\\n            y++;\\n        }\\n        else\\n        {\\n            w[l] = nums1[x];\\n            x++;\\n        }       \\n    }\\n        nums1=w;       \\n    }\\ni am getting compile error. Can anyone help me out?"
                    },
                    {
                        "username": "VivekReddy21",
                        "content": "class Solution {\\n\\n    public void swap(int a, int b, int[] nums){\\n        int temp=nums[a];\\n        nums[a]=nums[b];\\n        nums[b]=temp;\\n    }\\n\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\n        int j=0;\\n        for(int i=m;i<m+n;i++){\\n            nums1[i]=nums2[j++];\\n        }\\n\\n        int gap=(m+n)/2;\\n        while(gap!=0){\\n            for(int i=0;i<nums1.length;i=i+1){\\n                //we compare pairs at gap \\n                if(i+gap<nums1.length && nums1[i]>nums1[i+gap]){\\n                    swap(i,i+gap,nums1);\\n                }\\n            }\\n            gap=gap-1;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1754103,
                "content": [
                    {
                        "username": "mrin2810",
                        "content": "Accepted, Easy Solution \n\nTraverse Through both the arrays always placing the smaller number in the destination array.\n\n`class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int i = -1;\n        int j = 0;\n        while (++i < m && j < n){\n            if (nums2[j] < nums1[i]){\n                int temp = nums1[i];\n                nums1[i] = nums2[j];\n                nums2[j] = temp;\n                Arrays.sort(nums2);\n            }\n        }\n        for (int num : nums2) {\n            nums1[i++] = num;\n        }\n    }\n}`"
                    },
                    {
                        "username": "sowvino",
                        "content": " `var merge = function(nums1, m, nums2, n) {\\n    let arr3=[0];\\n    let array1 = nums1.filter(x => !arr3.includes(x));\\n    let array2 =nums2.filter(x => !arr3.includes(x));\\n    let val = [...array1,...array2];\\n    return val.sort((a,b)=>a-b);\\n  \\n}; `\\n\\nWhy this solution is not working"
                    },
                    {
                        "username": "hegdeanirudh2003",
                        "content": "nums1[:] = sorted(nums1[:m]+nums2)\\nwhy to use [:] after nums1?\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "artiksingh145",
                        "content": "I did it only in 3 lines(JAVA used)\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k=m+n;\\n        for(int i=m; i<k; i++){\\n           nums1[i]=nums2[i-m];        \\n        }\\n        Arrays.sort(nums1);\\n\\n    }\\n}"
                    },
                    {
                        "username": "An-u-rag",
                        "content": "time complexity increases with sort()"
                    },
                    {
                        "username": "Saad03",
                        "content": "I don\\'t get error when I run in jupyter notyebook but I have trouble running code here...can someonw tell me what the problem is\\ndef merge(self, nums1, m, nums2, n):\\n        emp=[]\\n        for i in range(0,len(nums1)): #instead of n and m, I used len func\\n            if nums1[i]!=0:\\n                 emp.append(nums1[i])\\n        for j in range(0,len(nums2)):\\n             if nums2[j]!=0:\\n                emp.append(nums2[j])\\n        emp.sort()\\n        nums1=emp\\n        print(nums1)\\n"
                    },
                    {
                        "username": "pavandeore",
                        "content": "i have having an error \\ncan someone explain what is wrong with this code\\n\\n```\\n\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1.length = m \\n    nums2.length = n\\n    nums1 = nums1.concat(nums2).sort((a,b) => a-b )\\n};\\n\\n\\n```"
                    },
                    {
                        "username": "Yashw12",
                        "content": "    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n)\\n   {\\n       int x,y=0;\\n       int p= m + n;\\n        vector<int> w[p];\\n      for(int l=0;l<p;l++)\\n    { \\n        if(x<m && y<n)\\n        {\\n            if(nums1[x]<nums2[y])\\n            {\\n                w[l]= nums1[x];\\n                x++;\\n            }\\n            else\\n            {\\n                w[l]=nums2[y];\\n                y++;\\n            }\\n        }\\n        else if (x>m)\\n        {\\n            w[l]= nums2[y];\\n            y++;\\n        }\\n        else\\n        {\\n            w[l] = nums1[x];\\n            x++;\\n        }       \\n    }\\n        nums1=w;       \\n    }\\ni am getting compile error. Can anyone help me out?"
                    },
                    {
                        "username": "VivekReddy21",
                        "content": "class Solution {\\n\\n    public void swap(int a, int b, int[] nums){\\n        int temp=nums[a];\\n        nums[a]=nums[b];\\n        nums[b]=temp;\\n    }\\n\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\n        int j=0;\\n        for(int i=m;i<m+n;i++){\\n            nums1[i]=nums2[j++];\\n        }\\n\\n        int gap=(m+n)/2;\\n        while(gap!=0){\\n            for(int i=0;i<nums1.length;i=i+1){\\n                //we compare pairs at gap \\n                if(i+gap<nums1.length && nums1[i]>nums1[i+gap]){\\n                    swap(i,i+gap,nums1);\\n                }\\n            }\\n            gap=gap-1;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1749240,
                "content": [
                    {
                        "username": "mrin2810",
                        "content": "Accepted, Easy Solution \n\nTraverse Through both the arrays always placing the smaller number in the destination array.\n\n`class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int i = -1;\n        int j = 0;\n        while (++i < m && j < n){\n            if (nums2[j] < nums1[i]){\n                int temp = nums1[i];\n                nums1[i] = nums2[j];\n                nums2[j] = temp;\n                Arrays.sort(nums2);\n            }\n        }\n        for (int num : nums2) {\n            nums1[i++] = num;\n        }\n    }\n}`"
                    },
                    {
                        "username": "sowvino",
                        "content": " `var merge = function(nums1, m, nums2, n) {\\n    let arr3=[0];\\n    let array1 = nums1.filter(x => !arr3.includes(x));\\n    let array2 =nums2.filter(x => !arr3.includes(x));\\n    let val = [...array1,...array2];\\n    return val.sort((a,b)=>a-b);\\n  \\n}; `\\n\\nWhy this solution is not working"
                    },
                    {
                        "username": "hegdeanirudh2003",
                        "content": "nums1[:] = sorted(nums1[:m]+nums2)\\nwhy to use [:] after nums1?\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "artiksingh145",
                        "content": "I did it only in 3 lines(JAVA used)\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k=m+n;\\n        for(int i=m; i<k; i++){\\n           nums1[i]=nums2[i-m];        \\n        }\\n        Arrays.sort(nums1);\\n\\n    }\\n}"
                    },
                    {
                        "username": "An-u-rag",
                        "content": "time complexity increases with sort()"
                    },
                    {
                        "username": "Saad03",
                        "content": "I don\\'t get error when I run in jupyter notyebook but I have trouble running code here...can someonw tell me what the problem is\\ndef merge(self, nums1, m, nums2, n):\\n        emp=[]\\n        for i in range(0,len(nums1)): #instead of n and m, I used len func\\n            if nums1[i]!=0:\\n                 emp.append(nums1[i])\\n        for j in range(0,len(nums2)):\\n             if nums2[j]!=0:\\n                emp.append(nums2[j])\\n        emp.sort()\\n        nums1=emp\\n        print(nums1)\\n"
                    },
                    {
                        "username": "pavandeore",
                        "content": "i have having an error \\ncan someone explain what is wrong with this code\\n\\n```\\n\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1.length = m \\n    nums2.length = n\\n    nums1 = nums1.concat(nums2).sort((a,b) => a-b )\\n};\\n\\n\\n```"
                    },
                    {
                        "username": "Yashw12",
                        "content": "    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n)\\n   {\\n       int x,y=0;\\n       int p= m + n;\\n        vector<int> w[p];\\n      for(int l=0;l<p;l++)\\n    { \\n        if(x<m && y<n)\\n        {\\n            if(nums1[x]<nums2[y])\\n            {\\n                w[l]= nums1[x];\\n                x++;\\n            }\\n            else\\n            {\\n                w[l]=nums2[y];\\n                y++;\\n            }\\n        }\\n        else if (x>m)\\n        {\\n            w[l]= nums2[y];\\n            y++;\\n        }\\n        else\\n        {\\n            w[l] = nums1[x];\\n            x++;\\n        }       \\n    }\\n        nums1=w;       \\n    }\\ni am getting compile error. Can anyone help me out?"
                    },
                    {
                        "username": "VivekReddy21",
                        "content": "class Solution {\\n\\n    public void swap(int a, int b, int[] nums){\\n        int temp=nums[a];\\n        nums[a]=nums[b];\\n        nums[b]=temp;\\n    }\\n\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\n        int j=0;\\n        for(int i=m;i<m+n;i++){\\n            nums1[i]=nums2[j++];\\n        }\\n\\n        int gap=(m+n)/2;\\n        while(gap!=0){\\n            for(int i=0;i<nums1.length;i=i+1){\\n                //we compare pairs at gap \\n                if(i+gap<nums1.length && nums1[i]>nums1[i+gap]){\\n                    swap(i,i+gap,nums1);\\n                }\\n            }\\n            gap=gap-1;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1747912,
                "content": [
                    {
                        "username": "mrin2810",
                        "content": "Accepted, Easy Solution \n\nTraverse Through both the arrays always placing the smaller number in the destination array.\n\n`class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int i = -1;\n        int j = 0;\n        while (++i < m && j < n){\n            if (nums2[j] < nums1[i]){\n                int temp = nums1[i];\n                nums1[i] = nums2[j];\n                nums2[j] = temp;\n                Arrays.sort(nums2);\n            }\n        }\n        for (int num : nums2) {\n            nums1[i++] = num;\n        }\n    }\n}`"
                    },
                    {
                        "username": "sowvino",
                        "content": " `var merge = function(nums1, m, nums2, n) {\\n    let arr3=[0];\\n    let array1 = nums1.filter(x => !arr3.includes(x));\\n    let array2 =nums2.filter(x => !arr3.includes(x));\\n    let val = [...array1,...array2];\\n    return val.sort((a,b)=>a-b);\\n  \\n}; `\\n\\nWhy this solution is not working"
                    },
                    {
                        "username": "hegdeanirudh2003",
                        "content": "nums1[:] = sorted(nums1[:m]+nums2)\\nwhy to use [:] after nums1?\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "artiksingh145",
                        "content": "I did it only in 3 lines(JAVA used)\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k=m+n;\\n        for(int i=m; i<k; i++){\\n           nums1[i]=nums2[i-m];        \\n        }\\n        Arrays.sort(nums1);\\n\\n    }\\n}"
                    },
                    {
                        "username": "An-u-rag",
                        "content": "time complexity increases with sort()"
                    },
                    {
                        "username": "Saad03",
                        "content": "I don\\'t get error when I run in jupyter notyebook but I have trouble running code here...can someonw tell me what the problem is\\ndef merge(self, nums1, m, nums2, n):\\n        emp=[]\\n        for i in range(0,len(nums1)): #instead of n and m, I used len func\\n            if nums1[i]!=0:\\n                 emp.append(nums1[i])\\n        for j in range(0,len(nums2)):\\n             if nums2[j]!=0:\\n                emp.append(nums2[j])\\n        emp.sort()\\n        nums1=emp\\n        print(nums1)\\n"
                    },
                    {
                        "username": "pavandeore",
                        "content": "i have having an error \\ncan someone explain what is wrong with this code\\n\\n```\\n\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1.length = m \\n    nums2.length = n\\n    nums1 = nums1.concat(nums2).sort((a,b) => a-b )\\n};\\n\\n\\n```"
                    },
                    {
                        "username": "Yashw12",
                        "content": "    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n)\\n   {\\n       int x,y=0;\\n       int p= m + n;\\n        vector<int> w[p];\\n      for(int l=0;l<p;l++)\\n    { \\n        if(x<m && y<n)\\n        {\\n            if(nums1[x]<nums2[y])\\n            {\\n                w[l]= nums1[x];\\n                x++;\\n            }\\n            else\\n            {\\n                w[l]=nums2[y];\\n                y++;\\n            }\\n        }\\n        else if (x>m)\\n        {\\n            w[l]= nums2[y];\\n            y++;\\n        }\\n        else\\n        {\\n            w[l] = nums1[x];\\n            x++;\\n        }       \\n    }\\n        nums1=w;       \\n    }\\ni am getting compile error. Can anyone help me out?"
                    },
                    {
                        "username": "VivekReddy21",
                        "content": "class Solution {\\n\\n    public void swap(int a, int b, int[] nums){\\n        int temp=nums[a];\\n        nums[a]=nums[b];\\n        nums[b]=temp;\\n    }\\n\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\n        int j=0;\\n        for(int i=m;i<m+n;i++){\\n            nums1[i]=nums2[j++];\\n        }\\n\\n        int gap=(m+n)/2;\\n        while(gap!=0){\\n            for(int i=0;i<nums1.length;i=i+1){\\n                //we compare pairs at gap \\n                if(i+gap<nums1.length && nums1[i]>nums1[i+gap]){\\n                    swap(i,i+gap,nums1);\\n                }\\n            }\\n            gap=gap-1;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1745587,
                "content": [
                    {
                        "username": "mrin2810",
                        "content": "Accepted, Easy Solution \n\nTraverse Through both the arrays always placing the smaller number in the destination array.\n\n`class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int i = -1;\n        int j = 0;\n        while (++i < m && j < n){\n            if (nums2[j] < nums1[i]){\n                int temp = nums1[i];\n                nums1[i] = nums2[j];\n                nums2[j] = temp;\n                Arrays.sort(nums2);\n            }\n        }\n        for (int num : nums2) {\n            nums1[i++] = num;\n        }\n    }\n}`"
                    },
                    {
                        "username": "sowvino",
                        "content": " `var merge = function(nums1, m, nums2, n) {\\n    let arr3=[0];\\n    let array1 = nums1.filter(x => !arr3.includes(x));\\n    let array2 =nums2.filter(x => !arr3.includes(x));\\n    let val = [...array1,...array2];\\n    return val.sort((a,b)=>a-b);\\n  \\n}; `\\n\\nWhy this solution is not working"
                    },
                    {
                        "username": "hegdeanirudh2003",
                        "content": "nums1[:] = sorted(nums1[:m]+nums2)\\nwhy to use [:] after nums1?\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "artiksingh145",
                        "content": "I did it only in 3 lines(JAVA used)\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k=m+n;\\n        for(int i=m; i<k; i++){\\n           nums1[i]=nums2[i-m];        \\n        }\\n        Arrays.sort(nums1);\\n\\n    }\\n}"
                    },
                    {
                        "username": "An-u-rag",
                        "content": "time complexity increases with sort()"
                    },
                    {
                        "username": "Saad03",
                        "content": "I don\\'t get error when I run in jupyter notyebook but I have trouble running code here...can someonw tell me what the problem is\\ndef merge(self, nums1, m, nums2, n):\\n        emp=[]\\n        for i in range(0,len(nums1)): #instead of n and m, I used len func\\n            if nums1[i]!=0:\\n                 emp.append(nums1[i])\\n        for j in range(0,len(nums2)):\\n             if nums2[j]!=0:\\n                emp.append(nums2[j])\\n        emp.sort()\\n        nums1=emp\\n        print(nums1)\\n"
                    },
                    {
                        "username": "pavandeore",
                        "content": "i have having an error \\ncan someone explain what is wrong with this code\\n\\n```\\n\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1.length = m \\n    nums2.length = n\\n    nums1 = nums1.concat(nums2).sort((a,b) => a-b )\\n};\\n\\n\\n```"
                    },
                    {
                        "username": "Yashw12",
                        "content": "    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n)\\n   {\\n       int x,y=0;\\n       int p= m + n;\\n        vector<int> w[p];\\n      for(int l=0;l<p;l++)\\n    { \\n        if(x<m && y<n)\\n        {\\n            if(nums1[x]<nums2[y])\\n            {\\n                w[l]= nums1[x];\\n                x++;\\n            }\\n            else\\n            {\\n                w[l]=nums2[y];\\n                y++;\\n            }\\n        }\\n        else if (x>m)\\n        {\\n            w[l]= nums2[y];\\n            y++;\\n        }\\n        else\\n        {\\n            w[l] = nums1[x];\\n            x++;\\n        }       \\n    }\\n        nums1=w;       \\n    }\\ni am getting compile error. Can anyone help me out?"
                    },
                    {
                        "username": "VivekReddy21",
                        "content": "class Solution {\\n\\n    public void swap(int a, int b, int[] nums){\\n        int temp=nums[a];\\n        nums[a]=nums[b];\\n        nums[b]=temp;\\n    }\\n\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\n        int j=0;\\n        for(int i=m;i<m+n;i++){\\n            nums1[i]=nums2[j++];\\n        }\\n\\n        int gap=(m+n)/2;\\n        while(gap!=0){\\n            for(int i=0;i<nums1.length;i=i+1){\\n                //we compare pairs at gap \\n                if(i+gap<nums1.length && nums1[i]>nums1[i+gap]){\\n                    swap(i,i+gap,nums1);\\n                }\\n            }\\n            gap=gap-1;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1742632,
                "content": [
                    {
                        "username": "mrin2810",
                        "content": "Accepted, Easy Solution \n\nTraverse Through both the arrays always placing the smaller number in the destination array.\n\n`class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int i = -1;\n        int j = 0;\n        while (++i < m && j < n){\n            if (nums2[j] < nums1[i]){\n                int temp = nums1[i];\n                nums1[i] = nums2[j];\n                nums2[j] = temp;\n                Arrays.sort(nums2);\n            }\n        }\n        for (int num : nums2) {\n            nums1[i++] = num;\n        }\n    }\n}`"
                    },
                    {
                        "username": "sowvino",
                        "content": " `var merge = function(nums1, m, nums2, n) {\\n    let arr3=[0];\\n    let array1 = nums1.filter(x => !arr3.includes(x));\\n    let array2 =nums2.filter(x => !arr3.includes(x));\\n    let val = [...array1,...array2];\\n    return val.sort((a,b)=>a-b);\\n  \\n}; `\\n\\nWhy this solution is not working"
                    },
                    {
                        "username": "hegdeanirudh2003",
                        "content": "nums1[:] = sorted(nums1[:m]+nums2)\\nwhy to use [:] after nums1?\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "artiksingh145",
                        "content": "I did it only in 3 lines(JAVA used)\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k=m+n;\\n        for(int i=m; i<k; i++){\\n           nums1[i]=nums2[i-m];        \\n        }\\n        Arrays.sort(nums1);\\n\\n    }\\n}"
                    },
                    {
                        "username": "An-u-rag",
                        "content": "time complexity increases with sort()"
                    },
                    {
                        "username": "Saad03",
                        "content": "I don\\'t get error when I run in jupyter notyebook but I have trouble running code here...can someonw tell me what the problem is\\ndef merge(self, nums1, m, nums2, n):\\n        emp=[]\\n        for i in range(0,len(nums1)): #instead of n and m, I used len func\\n            if nums1[i]!=0:\\n                 emp.append(nums1[i])\\n        for j in range(0,len(nums2)):\\n             if nums2[j]!=0:\\n                emp.append(nums2[j])\\n        emp.sort()\\n        nums1=emp\\n        print(nums1)\\n"
                    },
                    {
                        "username": "pavandeore",
                        "content": "i have having an error \\ncan someone explain what is wrong with this code\\n\\n```\\n\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1.length = m \\n    nums2.length = n\\n    nums1 = nums1.concat(nums2).sort((a,b) => a-b )\\n};\\n\\n\\n```"
                    },
                    {
                        "username": "Yashw12",
                        "content": "    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n)\\n   {\\n       int x,y=0;\\n       int p= m + n;\\n        vector<int> w[p];\\n      for(int l=0;l<p;l++)\\n    { \\n        if(x<m && y<n)\\n        {\\n            if(nums1[x]<nums2[y])\\n            {\\n                w[l]= nums1[x];\\n                x++;\\n            }\\n            else\\n            {\\n                w[l]=nums2[y];\\n                y++;\\n            }\\n        }\\n        else if (x>m)\\n        {\\n            w[l]= nums2[y];\\n            y++;\\n        }\\n        else\\n        {\\n            w[l] = nums1[x];\\n            x++;\\n        }       \\n    }\\n        nums1=w;       \\n    }\\ni am getting compile error. Can anyone help me out?"
                    },
                    {
                        "username": "VivekReddy21",
                        "content": "class Solution {\\n\\n    public void swap(int a, int b, int[] nums){\\n        int temp=nums[a];\\n        nums[a]=nums[b];\\n        nums[b]=temp;\\n    }\\n\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\n        int j=0;\\n        for(int i=m;i<m+n;i++){\\n            nums1[i]=nums2[j++];\\n        }\\n\\n        int gap=(m+n)/2;\\n        while(gap!=0){\\n            for(int i=0;i<nums1.length;i=i+1){\\n                //we compare pairs at gap \\n                if(i+gap<nums1.length && nums1[i]>nums1[i+gap]){\\n                    swap(i,i+gap,nums1);\\n                }\\n            }\\n            gap=gap-1;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1739394,
                "content": [
                    {
                        "username": "mrin2810",
                        "content": "Accepted, Easy Solution \n\nTraverse Through both the arrays always placing the smaller number in the destination array.\n\n`class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int i = -1;\n        int j = 0;\n        while (++i < m && j < n){\n            if (nums2[j] < nums1[i]){\n                int temp = nums1[i];\n                nums1[i] = nums2[j];\n                nums2[j] = temp;\n                Arrays.sort(nums2);\n            }\n        }\n        for (int num : nums2) {\n            nums1[i++] = num;\n        }\n    }\n}`"
                    },
                    {
                        "username": "sowvino",
                        "content": " `var merge = function(nums1, m, nums2, n) {\\n    let arr3=[0];\\n    let array1 = nums1.filter(x => !arr3.includes(x));\\n    let array2 =nums2.filter(x => !arr3.includes(x));\\n    let val = [...array1,...array2];\\n    return val.sort((a,b)=>a-b);\\n  \\n}; `\\n\\nWhy this solution is not working"
                    },
                    {
                        "username": "hegdeanirudh2003",
                        "content": "nums1[:] = sorted(nums1[:m]+nums2)\\nwhy to use [:] after nums1?\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "artiksingh145",
                        "content": "I did it only in 3 lines(JAVA used)\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k=m+n;\\n        for(int i=m; i<k; i++){\\n           nums1[i]=nums2[i-m];        \\n        }\\n        Arrays.sort(nums1);\\n\\n    }\\n}"
                    },
                    {
                        "username": "An-u-rag",
                        "content": "time complexity increases with sort()"
                    },
                    {
                        "username": "Saad03",
                        "content": "I don\\'t get error when I run in jupyter notyebook but I have trouble running code here...can someonw tell me what the problem is\\ndef merge(self, nums1, m, nums2, n):\\n        emp=[]\\n        for i in range(0,len(nums1)): #instead of n and m, I used len func\\n            if nums1[i]!=0:\\n                 emp.append(nums1[i])\\n        for j in range(0,len(nums2)):\\n             if nums2[j]!=0:\\n                emp.append(nums2[j])\\n        emp.sort()\\n        nums1=emp\\n        print(nums1)\\n"
                    },
                    {
                        "username": "pavandeore",
                        "content": "i have having an error \\ncan someone explain what is wrong with this code\\n\\n```\\n\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1.length = m \\n    nums2.length = n\\n    nums1 = nums1.concat(nums2).sort((a,b) => a-b )\\n};\\n\\n\\n```"
                    },
                    {
                        "username": "Yashw12",
                        "content": "    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n)\\n   {\\n       int x,y=0;\\n       int p= m + n;\\n        vector<int> w[p];\\n      for(int l=0;l<p;l++)\\n    { \\n        if(x<m && y<n)\\n        {\\n            if(nums1[x]<nums2[y])\\n            {\\n                w[l]= nums1[x];\\n                x++;\\n            }\\n            else\\n            {\\n                w[l]=nums2[y];\\n                y++;\\n            }\\n        }\\n        else if (x>m)\\n        {\\n            w[l]= nums2[y];\\n            y++;\\n        }\\n        else\\n        {\\n            w[l] = nums1[x];\\n            x++;\\n        }       \\n    }\\n        nums1=w;       \\n    }\\ni am getting compile error. Can anyone help me out?"
                    },
                    {
                        "username": "VivekReddy21",
                        "content": "class Solution {\\n\\n    public void swap(int a, int b, int[] nums){\\n        int temp=nums[a];\\n        nums[a]=nums[b];\\n        nums[b]=temp;\\n    }\\n\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n\\n        int j=0;\\n        for(int i=m;i<m+n;i++){\\n            nums1[i]=nums2[j++];\\n        }\\n\\n        int gap=(m+n)/2;\\n        while(gap!=0){\\n            for(int i=0;i<nums1.length;i=i+1){\\n                //we compare pairs at gap \\n                if(i+gap<nums1.length && nums1[i]>nums1[i+gap]){\\n                    swap(i,i+gap,nums1);\\n                }\\n            }\\n            gap=gap-1;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1738421,
                "content": [
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        vector<int> v3;\\n        int i=0,j=0;\\n        while(i<m && j<n){\\n            if(nums1[i]>nums2[j])\\n            {\\n                v3.push_back(nums2[j]);\\n                j++;\\n            }\\n            else{\\n                v3.push_back(nums1[i]);\\n                i++;\\n            }\\n        }\\n        while(i<m){\\n            v3.push_back(nums1[i]);\\n            i++;\\n        }\\n        while(j<n){\\n            v3.push_back(nums2[j]);\\n            j++;\\n        }\\n        nums1=v3;\\n    }\\n};"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=m,j=0;i<(m+n);i++,j++){\\n\\n            nums1[i]=nums2[j];\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n        System.out.println(nums1);\\n    }\\n}\\n\\n\\nCan somebody tell the error in this"
                    },
                    {
                        "username": "naman_0002",
                        "content": "for(int i=0;i<m;i++){\\n      if(nums1[i]>nums2[0]){\\n           swap(nums1[i],nums2[0]);\\n      }\\n      sort(nums2.begin(),nums2.end());\\n}\\nint k=0;\\nfor(int j=m;j<m+n;j++){\\n     swap(nums1[j],nums2[k++]);\\n }\\n\\nvectors after all these operation store correct result but it is still giving error. Can someone tell me where is the error.\\nThanks in advance."
                    },
                    {
                        "username": "abhishekh3005",
                        "content": "nums1.resize(m);\\n        for(int i=0;i<n;i++) {\\n            nums1.push_back(nums2[i]);\\n        }\\n        sort(nums1.begin(), nums1.end());\\n\\nin this code automatically all 0 are being removed, can anyone tell how is it happening?\\n"
                    },
                    {
                        "username": "Anita-Liberatore",
                        "content": "My solution in java\\n\\n `class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k=0;\\n\\n            for(int i=0; i<m; i++) {\\n                nums1[k++] = nums1[i];\\n            }\\n\\n\\n\\n        for(int j=0; j<n; j++) {\\n                nums1[k++] = nums2[j];\\n        }\\n\\n\\n        Arrays.sort(nums1);\\n    }\\n}`"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {\\n        int ind = m ; \\n        int ind2 = 0 ;\\n        while(ind2 < n )\\n        {\\n            int tempInd = ind ;\\n            while(tempInd !=  0 && nums2[ind2] < nums1[tempInd-1])\\n            {\\n                nums1[tempInd] = nums1[tempInd-1] ;\\n                tempInd-- ;\\n            }\\n            nums1[tempInd] = nums2[ind2] ;\\n            ind2++ ;\\n            ind++ ;\\n        }\\n    }\\n};\\n// without using extra space really interesting!!!"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {\\n        int i =  0 , j = 0 ;\\n        vector<int>sorted ;\\n        while(i < m && j < n)\\n        {\\n            if(nums1[i] < nums2[j])\\n            {\\n                sorted.push_back(nums1[i]);\\n                i++ ;\\n            }\\n            else\\n            {\\n                sorted.push_back(nums2[j]); // using 3rd array as auxillary space \\n                j++ ;\\n            }\\n        }\\n        while(i < m )\\n        {\\n            sorted.push_back(nums1[i]);\\n            i++ ;\\n        }\\n        while(j < n)\\n        {\\n            sorted.push_back(nums2[j]);\\n            j++ ;\\n        }\\n        for(int i = 0 ; i < (m+n) ; i++)\\n        {\\n            nums1[i] = sorted[i];\\n        }   "
                    },
                    {
                        "username": "user9606rm",
                        "content": "Can anyone explain me why this code isnt working ?\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] arr=new int[m+n];\\n        System.arraycopy(nums1,0,arr,0,m);\\n         System.arraycopy(nums2,0,arr,m,n);\\n         Arrays.sort(arr);\\n         System.out.print(Arrays.toString(arr));\\n    }\\n}"
                    },
                    {
                        "username": "hbwhalewhalewhale",
                        "content": "using 0 as value for empty spaces in nums1 but also allowing 0 as normal value is super annoying..."
                    },
                    {
                        "username": "tonyschae",
                        "content": "Question of the code:: on the line num4(below if statement)\n\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n\n        if  nums1 == None or m==0:\n            nums1[:]=nums2  #why do I have a error if I change this line into\n                                         #\"nums1=nums2\"\n            return None\n\n        elif nums2 == None or n==0:\n            return None\n        else:\n            output=[]\n            nums1[:m+n]=sorted(nums1[:m]+nums2[:n])\n            return None\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\""
                    }
                ]
            },
            {
                "id": 1738187,
                "content": [
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        vector<int> v3;\\n        int i=0,j=0;\\n        while(i<m && j<n){\\n            if(nums1[i]>nums2[j])\\n            {\\n                v3.push_back(nums2[j]);\\n                j++;\\n            }\\n            else{\\n                v3.push_back(nums1[i]);\\n                i++;\\n            }\\n        }\\n        while(i<m){\\n            v3.push_back(nums1[i]);\\n            i++;\\n        }\\n        while(j<n){\\n            v3.push_back(nums2[j]);\\n            j++;\\n        }\\n        nums1=v3;\\n    }\\n};"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=m,j=0;i<(m+n);i++,j++){\\n\\n            nums1[i]=nums2[j];\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n        System.out.println(nums1);\\n    }\\n}\\n\\n\\nCan somebody tell the error in this"
                    },
                    {
                        "username": "naman_0002",
                        "content": "for(int i=0;i<m;i++){\\n      if(nums1[i]>nums2[0]){\\n           swap(nums1[i],nums2[0]);\\n      }\\n      sort(nums2.begin(),nums2.end());\\n}\\nint k=0;\\nfor(int j=m;j<m+n;j++){\\n     swap(nums1[j],nums2[k++]);\\n }\\n\\nvectors after all these operation store correct result but it is still giving error. Can someone tell me where is the error.\\nThanks in advance."
                    },
                    {
                        "username": "abhishekh3005",
                        "content": "nums1.resize(m);\\n        for(int i=0;i<n;i++) {\\n            nums1.push_back(nums2[i]);\\n        }\\n        sort(nums1.begin(), nums1.end());\\n\\nin this code automatically all 0 are being removed, can anyone tell how is it happening?\\n"
                    },
                    {
                        "username": "Anita-Liberatore",
                        "content": "My solution in java\\n\\n `class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k=0;\\n\\n            for(int i=0; i<m; i++) {\\n                nums1[k++] = nums1[i];\\n            }\\n\\n\\n\\n        for(int j=0; j<n; j++) {\\n                nums1[k++] = nums2[j];\\n        }\\n\\n\\n        Arrays.sort(nums1);\\n    }\\n}`"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {\\n        int ind = m ; \\n        int ind2 = 0 ;\\n        while(ind2 < n )\\n        {\\n            int tempInd = ind ;\\n            while(tempInd !=  0 && nums2[ind2] < nums1[tempInd-1])\\n            {\\n                nums1[tempInd] = nums1[tempInd-1] ;\\n                tempInd-- ;\\n            }\\n            nums1[tempInd] = nums2[ind2] ;\\n            ind2++ ;\\n            ind++ ;\\n        }\\n    }\\n};\\n// without using extra space really interesting!!!"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {\\n        int i =  0 , j = 0 ;\\n        vector<int>sorted ;\\n        while(i < m && j < n)\\n        {\\n            if(nums1[i] < nums2[j])\\n            {\\n                sorted.push_back(nums1[i]);\\n                i++ ;\\n            }\\n            else\\n            {\\n                sorted.push_back(nums2[j]); // using 3rd array as auxillary space \\n                j++ ;\\n            }\\n        }\\n        while(i < m )\\n        {\\n            sorted.push_back(nums1[i]);\\n            i++ ;\\n        }\\n        while(j < n)\\n        {\\n            sorted.push_back(nums2[j]);\\n            j++ ;\\n        }\\n        for(int i = 0 ; i < (m+n) ; i++)\\n        {\\n            nums1[i] = sorted[i];\\n        }   "
                    },
                    {
                        "username": "user9606rm",
                        "content": "Can anyone explain me why this code isnt working ?\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] arr=new int[m+n];\\n        System.arraycopy(nums1,0,arr,0,m);\\n         System.arraycopy(nums2,0,arr,m,n);\\n         Arrays.sort(arr);\\n         System.out.print(Arrays.toString(arr));\\n    }\\n}"
                    },
                    {
                        "username": "hbwhalewhalewhale",
                        "content": "using 0 as value for empty spaces in nums1 but also allowing 0 as normal value is super annoying..."
                    },
                    {
                        "username": "tonyschae",
                        "content": "Question of the code:: on the line num4(below if statement)\n\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n\n        if  nums1 == None or m==0:\n            nums1[:]=nums2  #why do I have a error if I change this line into\n                                         #\"nums1=nums2\"\n            return None\n\n        elif nums2 == None or n==0:\n            return None\n        else:\n            output=[]\n            nums1[:m+n]=sorted(nums1[:m]+nums2[:n])\n            return None\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\""
                    }
                ]
            },
            {
                "id": 1737738,
                "content": [
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        vector<int> v3;\\n        int i=0,j=0;\\n        while(i<m && j<n){\\n            if(nums1[i]>nums2[j])\\n            {\\n                v3.push_back(nums2[j]);\\n                j++;\\n            }\\n            else{\\n                v3.push_back(nums1[i]);\\n                i++;\\n            }\\n        }\\n        while(i<m){\\n            v3.push_back(nums1[i]);\\n            i++;\\n        }\\n        while(j<n){\\n            v3.push_back(nums2[j]);\\n            j++;\\n        }\\n        nums1=v3;\\n    }\\n};"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=m,j=0;i<(m+n);i++,j++){\\n\\n            nums1[i]=nums2[j];\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n        System.out.println(nums1);\\n    }\\n}\\n\\n\\nCan somebody tell the error in this"
                    },
                    {
                        "username": "naman_0002",
                        "content": "for(int i=0;i<m;i++){\\n      if(nums1[i]>nums2[0]){\\n           swap(nums1[i],nums2[0]);\\n      }\\n      sort(nums2.begin(),nums2.end());\\n}\\nint k=0;\\nfor(int j=m;j<m+n;j++){\\n     swap(nums1[j],nums2[k++]);\\n }\\n\\nvectors after all these operation store correct result but it is still giving error. Can someone tell me where is the error.\\nThanks in advance."
                    },
                    {
                        "username": "abhishekh3005",
                        "content": "nums1.resize(m);\\n        for(int i=0;i<n;i++) {\\n            nums1.push_back(nums2[i]);\\n        }\\n        sort(nums1.begin(), nums1.end());\\n\\nin this code automatically all 0 are being removed, can anyone tell how is it happening?\\n"
                    },
                    {
                        "username": "Anita-Liberatore",
                        "content": "My solution in java\\n\\n `class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k=0;\\n\\n            for(int i=0; i<m; i++) {\\n                nums1[k++] = nums1[i];\\n            }\\n\\n\\n\\n        for(int j=0; j<n; j++) {\\n                nums1[k++] = nums2[j];\\n        }\\n\\n\\n        Arrays.sort(nums1);\\n    }\\n}`"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {\\n        int ind = m ; \\n        int ind2 = 0 ;\\n        while(ind2 < n )\\n        {\\n            int tempInd = ind ;\\n            while(tempInd !=  0 && nums2[ind2] < nums1[tempInd-1])\\n            {\\n                nums1[tempInd] = nums1[tempInd-1] ;\\n                tempInd-- ;\\n            }\\n            nums1[tempInd] = nums2[ind2] ;\\n            ind2++ ;\\n            ind++ ;\\n        }\\n    }\\n};\\n// without using extra space really interesting!!!"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {\\n        int i =  0 , j = 0 ;\\n        vector<int>sorted ;\\n        while(i < m && j < n)\\n        {\\n            if(nums1[i] < nums2[j])\\n            {\\n                sorted.push_back(nums1[i]);\\n                i++ ;\\n            }\\n            else\\n            {\\n                sorted.push_back(nums2[j]); // using 3rd array as auxillary space \\n                j++ ;\\n            }\\n        }\\n        while(i < m )\\n        {\\n            sorted.push_back(nums1[i]);\\n            i++ ;\\n        }\\n        while(j < n)\\n        {\\n            sorted.push_back(nums2[j]);\\n            j++ ;\\n        }\\n        for(int i = 0 ; i < (m+n) ; i++)\\n        {\\n            nums1[i] = sorted[i];\\n        }   "
                    },
                    {
                        "username": "user9606rm",
                        "content": "Can anyone explain me why this code isnt working ?\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] arr=new int[m+n];\\n        System.arraycopy(nums1,0,arr,0,m);\\n         System.arraycopy(nums2,0,arr,m,n);\\n         Arrays.sort(arr);\\n         System.out.print(Arrays.toString(arr));\\n    }\\n}"
                    },
                    {
                        "username": "hbwhalewhalewhale",
                        "content": "using 0 as value for empty spaces in nums1 but also allowing 0 as normal value is super annoying..."
                    },
                    {
                        "username": "tonyschae",
                        "content": "Question of the code:: on the line num4(below if statement)\n\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n\n        if  nums1 == None or m==0:\n            nums1[:]=nums2  #why do I have a error if I change this line into\n                                         #\"nums1=nums2\"\n            return None\n\n        elif nums2 == None or n==0:\n            return None\n        else:\n            output=[]\n            nums1[:m+n]=sorted(nums1[:m]+nums2[:n])\n            return None\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\""
                    }
                ]
            },
            {
                "id": 1736443,
                "content": [
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        vector<int> v3;\\n        int i=0,j=0;\\n        while(i<m && j<n){\\n            if(nums1[i]>nums2[j])\\n            {\\n                v3.push_back(nums2[j]);\\n                j++;\\n            }\\n            else{\\n                v3.push_back(nums1[i]);\\n                i++;\\n            }\\n        }\\n        while(i<m){\\n            v3.push_back(nums1[i]);\\n            i++;\\n        }\\n        while(j<n){\\n            v3.push_back(nums2[j]);\\n            j++;\\n        }\\n        nums1=v3;\\n    }\\n};"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=m,j=0;i<(m+n);i++,j++){\\n\\n            nums1[i]=nums2[j];\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n        System.out.println(nums1);\\n    }\\n}\\n\\n\\nCan somebody tell the error in this"
                    },
                    {
                        "username": "naman_0002",
                        "content": "for(int i=0;i<m;i++){\\n      if(nums1[i]>nums2[0]){\\n           swap(nums1[i],nums2[0]);\\n      }\\n      sort(nums2.begin(),nums2.end());\\n}\\nint k=0;\\nfor(int j=m;j<m+n;j++){\\n     swap(nums1[j],nums2[k++]);\\n }\\n\\nvectors after all these operation store correct result but it is still giving error. Can someone tell me where is the error.\\nThanks in advance."
                    },
                    {
                        "username": "abhishekh3005",
                        "content": "nums1.resize(m);\\n        for(int i=0;i<n;i++) {\\n            nums1.push_back(nums2[i]);\\n        }\\n        sort(nums1.begin(), nums1.end());\\n\\nin this code automatically all 0 are being removed, can anyone tell how is it happening?\\n"
                    },
                    {
                        "username": "Anita-Liberatore",
                        "content": "My solution in java\\n\\n `class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k=0;\\n\\n            for(int i=0; i<m; i++) {\\n                nums1[k++] = nums1[i];\\n            }\\n\\n\\n\\n        for(int j=0; j<n; j++) {\\n                nums1[k++] = nums2[j];\\n        }\\n\\n\\n        Arrays.sort(nums1);\\n    }\\n}`"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {\\n        int ind = m ; \\n        int ind2 = 0 ;\\n        while(ind2 < n )\\n        {\\n            int tempInd = ind ;\\n            while(tempInd !=  0 && nums2[ind2] < nums1[tempInd-1])\\n            {\\n                nums1[tempInd] = nums1[tempInd-1] ;\\n                tempInd-- ;\\n            }\\n            nums1[tempInd] = nums2[ind2] ;\\n            ind2++ ;\\n            ind++ ;\\n        }\\n    }\\n};\\n// without using extra space really interesting!!!"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {\\n        int i =  0 , j = 0 ;\\n        vector<int>sorted ;\\n        while(i < m && j < n)\\n        {\\n            if(nums1[i] < nums2[j])\\n            {\\n                sorted.push_back(nums1[i]);\\n                i++ ;\\n            }\\n            else\\n            {\\n                sorted.push_back(nums2[j]); // using 3rd array as auxillary space \\n                j++ ;\\n            }\\n        }\\n        while(i < m )\\n        {\\n            sorted.push_back(nums1[i]);\\n            i++ ;\\n        }\\n        while(j < n)\\n        {\\n            sorted.push_back(nums2[j]);\\n            j++ ;\\n        }\\n        for(int i = 0 ; i < (m+n) ; i++)\\n        {\\n            nums1[i] = sorted[i];\\n        }   "
                    },
                    {
                        "username": "user9606rm",
                        "content": "Can anyone explain me why this code isnt working ?\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] arr=new int[m+n];\\n        System.arraycopy(nums1,0,arr,0,m);\\n         System.arraycopy(nums2,0,arr,m,n);\\n         Arrays.sort(arr);\\n         System.out.print(Arrays.toString(arr));\\n    }\\n}"
                    },
                    {
                        "username": "hbwhalewhalewhale",
                        "content": "using 0 as value for empty spaces in nums1 but also allowing 0 as normal value is super annoying..."
                    },
                    {
                        "username": "tonyschae",
                        "content": "Question of the code:: on the line num4(below if statement)\n\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n\n        if  nums1 == None or m==0:\n            nums1[:]=nums2  #why do I have a error if I change this line into\n                                         #\"nums1=nums2\"\n            return None\n\n        elif nums2 == None or n==0:\n            return None\n        else:\n            output=[]\n            nums1[:m+n]=sorted(nums1[:m]+nums2[:n])\n            return None\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\""
                    }
                ]
            },
            {
                "id": 1733511,
                "content": [
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        vector<int> v3;\\n        int i=0,j=0;\\n        while(i<m && j<n){\\n            if(nums1[i]>nums2[j])\\n            {\\n                v3.push_back(nums2[j]);\\n                j++;\\n            }\\n            else{\\n                v3.push_back(nums1[i]);\\n                i++;\\n            }\\n        }\\n        while(i<m){\\n            v3.push_back(nums1[i]);\\n            i++;\\n        }\\n        while(j<n){\\n            v3.push_back(nums2[j]);\\n            j++;\\n        }\\n        nums1=v3;\\n    }\\n};"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=m,j=0;i<(m+n);i++,j++){\\n\\n            nums1[i]=nums2[j];\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n        System.out.println(nums1);\\n    }\\n}\\n\\n\\nCan somebody tell the error in this"
                    },
                    {
                        "username": "naman_0002",
                        "content": "for(int i=0;i<m;i++){\\n      if(nums1[i]>nums2[0]){\\n           swap(nums1[i],nums2[0]);\\n      }\\n      sort(nums2.begin(),nums2.end());\\n}\\nint k=0;\\nfor(int j=m;j<m+n;j++){\\n     swap(nums1[j],nums2[k++]);\\n }\\n\\nvectors after all these operation store correct result but it is still giving error. Can someone tell me where is the error.\\nThanks in advance."
                    },
                    {
                        "username": "abhishekh3005",
                        "content": "nums1.resize(m);\\n        for(int i=0;i<n;i++) {\\n            nums1.push_back(nums2[i]);\\n        }\\n        sort(nums1.begin(), nums1.end());\\n\\nin this code automatically all 0 are being removed, can anyone tell how is it happening?\\n"
                    },
                    {
                        "username": "Anita-Liberatore",
                        "content": "My solution in java\\n\\n `class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k=0;\\n\\n            for(int i=0; i<m; i++) {\\n                nums1[k++] = nums1[i];\\n            }\\n\\n\\n\\n        for(int j=0; j<n; j++) {\\n                nums1[k++] = nums2[j];\\n        }\\n\\n\\n        Arrays.sort(nums1);\\n    }\\n}`"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {\\n        int ind = m ; \\n        int ind2 = 0 ;\\n        while(ind2 < n )\\n        {\\n            int tempInd = ind ;\\n            while(tempInd !=  0 && nums2[ind2] < nums1[tempInd-1])\\n            {\\n                nums1[tempInd] = nums1[tempInd-1] ;\\n                tempInd-- ;\\n            }\\n            nums1[tempInd] = nums2[ind2] ;\\n            ind2++ ;\\n            ind++ ;\\n        }\\n    }\\n};\\n// without using extra space really interesting!!!"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {\\n        int i =  0 , j = 0 ;\\n        vector<int>sorted ;\\n        while(i < m && j < n)\\n        {\\n            if(nums1[i] < nums2[j])\\n            {\\n                sorted.push_back(nums1[i]);\\n                i++ ;\\n            }\\n            else\\n            {\\n                sorted.push_back(nums2[j]); // using 3rd array as auxillary space \\n                j++ ;\\n            }\\n        }\\n        while(i < m )\\n        {\\n            sorted.push_back(nums1[i]);\\n            i++ ;\\n        }\\n        while(j < n)\\n        {\\n            sorted.push_back(nums2[j]);\\n            j++ ;\\n        }\\n        for(int i = 0 ; i < (m+n) ; i++)\\n        {\\n            nums1[i] = sorted[i];\\n        }   "
                    },
                    {
                        "username": "user9606rm",
                        "content": "Can anyone explain me why this code isnt working ?\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] arr=new int[m+n];\\n        System.arraycopy(nums1,0,arr,0,m);\\n         System.arraycopy(nums2,0,arr,m,n);\\n         Arrays.sort(arr);\\n         System.out.print(Arrays.toString(arr));\\n    }\\n}"
                    },
                    {
                        "username": "hbwhalewhalewhale",
                        "content": "using 0 as value for empty spaces in nums1 but also allowing 0 as normal value is super annoying..."
                    },
                    {
                        "username": "tonyschae",
                        "content": "Question of the code:: on the line num4(below if statement)\n\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n\n        if  nums1 == None or m==0:\n            nums1[:]=nums2  #why do I have a error if I change this line into\n                                         #\"nums1=nums2\"\n            return None\n\n        elif nums2 == None or n==0:\n            return None\n        else:\n            output=[]\n            nums1[:m+n]=sorted(nums1[:m]+nums2[:n])\n            return None\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\""
                    }
                ]
            },
            {
                "id": 1730473,
                "content": [
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        vector<int> v3;\\n        int i=0,j=0;\\n        while(i<m && j<n){\\n            if(nums1[i]>nums2[j])\\n            {\\n                v3.push_back(nums2[j]);\\n                j++;\\n            }\\n            else{\\n                v3.push_back(nums1[i]);\\n                i++;\\n            }\\n        }\\n        while(i<m){\\n            v3.push_back(nums1[i]);\\n            i++;\\n        }\\n        while(j<n){\\n            v3.push_back(nums2[j]);\\n            j++;\\n        }\\n        nums1=v3;\\n    }\\n};"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=m,j=0;i<(m+n);i++,j++){\\n\\n            nums1[i]=nums2[j];\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n        System.out.println(nums1);\\n    }\\n}\\n\\n\\nCan somebody tell the error in this"
                    },
                    {
                        "username": "naman_0002",
                        "content": "for(int i=0;i<m;i++){\\n      if(nums1[i]>nums2[0]){\\n           swap(nums1[i],nums2[0]);\\n      }\\n      sort(nums2.begin(),nums2.end());\\n}\\nint k=0;\\nfor(int j=m;j<m+n;j++){\\n     swap(nums1[j],nums2[k++]);\\n }\\n\\nvectors after all these operation store correct result but it is still giving error. Can someone tell me where is the error.\\nThanks in advance."
                    },
                    {
                        "username": "abhishekh3005",
                        "content": "nums1.resize(m);\\n        for(int i=0;i<n;i++) {\\n            nums1.push_back(nums2[i]);\\n        }\\n        sort(nums1.begin(), nums1.end());\\n\\nin this code automatically all 0 are being removed, can anyone tell how is it happening?\\n"
                    },
                    {
                        "username": "Anita-Liberatore",
                        "content": "My solution in java\\n\\n `class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k=0;\\n\\n            for(int i=0; i<m; i++) {\\n                nums1[k++] = nums1[i];\\n            }\\n\\n\\n\\n        for(int j=0; j<n; j++) {\\n                nums1[k++] = nums2[j];\\n        }\\n\\n\\n        Arrays.sort(nums1);\\n    }\\n}`"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {\\n        int ind = m ; \\n        int ind2 = 0 ;\\n        while(ind2 < n )\\n        {\\n            int tempInd = ind ;\\n            while(tempInd !=  0 && nums2[ind2] < nums1[tempInd-1])\\n            {\\n                nums1[tempInd] = nums1[tempInd-1] ;\\n                tempInd-- ;\\n            }\\n            nums1[tempInd] = nums2[ind2] ;\\n            ind2++ ;\\n            ind++ ;\\n        }\\n    }\\n};\\n// without using extra space really interesting!!!"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {\\n        int i =  0 , j = 0 ;\\n        vector<int>sorted ;\\n        while(i < m && j < n)\\n        {\\n            if(nums1[i] < nums2[j])\\n            {\\n                sorted.push_back(nums1[i]);\\n                i++ ;\\n            }\\n            else\\n            {\\n                sorted.push_back(nums2[j]); // using 3rd array as auxillary space \\n                j++ ;\\n            }\\n        }\\n        while(i < m )\\n        {\\n            sorted.push_back(nums1[i]);\\n            i++ ;\\n        }\\n        while(j < n)\\n        {\\n            sorted.push_back(nums2[j]);\\n            j++ ;\\n        }\\n        for(int i = 0 ; i < (m+n) ; i++)\\n        {\\n            nums1[i] = sorted[i];\\n        }   "
                    },
                    {
                        "username": "user9606rm",
                        "content": "Can anyone explain me why this code isnt working ?\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] arr=new int[m+n];\\n        System.arraycopy(nums1,0,arr,0,m);\\n         System.arraycopy(nums2,0,arr,m,n);\\n         Arrays.sort(arr);\\n         System.out.print(Arrays.toString(arr));\\n    }\\n}"
                    },
                    {
                        "username": "hbwhalewhalewhale",
                        "content": "using 0 as value for empty spaces in nums1 but also allowing 0 as normal value is super annoying..."
                    },
                    {
                        "username": "tonyschae",
                        "content": "Question of the code:: on the line num4(below if statement)\n\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n\n        if  nums1 == None or m==0:\n            nums1[:]=nums2  #why do I have a error if I change this line into\n                                         #\"nums1=nums2\"\n            return None\n\n        elif nums2 == None or n==0:\n            return None\n        else:\n            output=[]\n            nums1[:m+n]=sorted(nums1[:m]+nums2[:n])\n            return None\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\""
                    }
                ]
            },
            {
                "id": 1730421,
                "content": [
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        vector<int> v3;\\n        int i=0,j=0;\\n        while(i<m && j<n){\\n            if(nums1[i]>nums2[j])\\n            {\\n                v3.push_back(nums2[j]);\\n                j++;\\n            }\\n            else{\\n                v3.push_back(nums1[i]);\\n                i++;\\n            }\\n        }\\n        while(i<m){\\n            v3.push_back(nums1[i]);\\n            i++;\\n        }\\n        while(j<n){\\n            v3.push_back(nums2[j]);\\n            j++;\\n        }\\n        nums1=v3;\\n    }\\n};"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=m,j=0;i<(m+n);i++,j++){\\n\\n            nums1[i]=nums2[j];\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n        System.out.println(nums1);\\n    }\\n}\\n\\n\\nCan somebody tell the error in this"
                    },
                    {
                        "username": "naman_0002",
                        "content": "for(int i=0;i<m;i++){\\n      if(nums1[i]>nums2[0]){\\n           swap(nums1[i],nums2[0]);\\n      }\\n      sort(nums2.begin(),nums2.end());\\n}\\nint k=0;\\nfor(int j=m;j<m+n;j++){\\n     swap(nums1[j],nums2[k++]);\\n }\\n\\nvectors after all these operation store correct result but it is still giving error. Can someone tell me where is the error.\\nThanks in advance."
                    },
                    {
                        "username": "abhishekh3005",
                        "content": "nums1.resize(m);\\n        for(int i=0;i<n;i++) {\\n            nums1.push_back(nums2[i]);\\n        }\\n        sort(nums1.begin(), nums1.end());\\n\\nin this code automatically all 0 are being removed, can anyone tell how is it happening?\\n"
                    },
                    {
                        "username": "Anita-Liberatore",
                        "content": "My solution in java\\n\\n `class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k=0;\\n\\n            for(int i=0; i<m; i++) {\\n                nums1[k++] = nums1[i];\\n            }\\n\\n\\n\\n        for(int j=0; j<n; j++) {\\n                nums1[k++] = nums2[j];\\n        }\\n\\n\\n        Arrays.sort(nums1);\\n    }\\n}`"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {\\n        int ind = m ; \\n        int ind2 = 0 ;\\n        while(ind2 < n )\\n        {\\n            int tempInd = ind ;\\n            while(tempInd !=  0 && nums2[ind2] < nums1[tempInd-1])\\n            {\\n                nums1[tempInd] = nums1[tempInd-1] ;\\n                tempInd-- ;\\n            }\\n            nums1[tempInd] = nums2[ind2] ;\\n            ind2++ ;\\n            ind++ ;\\n        }\\n    }\\n};\\n// without using extra space really interesting!!!"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {\\n        int i =  0 , j = 0 ;\\n        vector<int>sorted ;\\n        while(i < m && j < n)\\n        {\\n            if(nums1[i] < nums2[j])\\n            {\\n                sorted.push_back(nums1[i]);\\n                i++ ;\\n            }\\n            else\\n            {\\n                sorted.push_back(nums2[j]); // using 3rd array as auxillary space \\n                j++ ;\\n            }\\n        }\\n        while(i < m )\\n        {\\n            sorted.push_back(nums1[i]);\\n            i++ ;\\n        }\\n        while(j < n)\\n        {\\n            sorted.push_back(nums2[j]);\\n            j++ ;\\n        }\\n        for(int i = 0 ; i < (m+n) ; i++)\\n        {\\n            nums1[i] = sorted[i];\\n        }   "
                    },
                    {
                        "username": "user9606rm",
                        "content": "Can anyone explain me why this code isnt working ?\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] arr=new int[m+n];\\n        System.arraycopy(nums1,0,arr,0,m);\\n         System.arraycopy(nums2,0,arr,m,n);\\n         Arrays.sort(arr);\\n         System.out.print(Arrays.toString(arr));\\n    }\\n}"
                    },
                    {
                        "username": "hbwhalewhalewhale",
                        "content": "using 0 as value for empty spaces in nums1 but also allowing 0 as normal value is super annoying..."
                    },
                    {
                        "username": "tonyschae",
                        "content": "Question of the code:: on the line num4(below if statement)\n\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n\n        if  nums1 == None or m==0:\n            nums1[:]=nums2  #why do I have a error if I change this line into\n                                         #\"nums1=nums2\"\n            return None\n\n        elif nums2 == None or n==0:\n            return None\n        else:\n            output=[]\n            nums1[:m+n]=sorted(nums1[:m]+nums2[:n])\n            return None\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\""
                    }
                ]
            },
            {
                "id": 1730142,
                "content": [
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        vector<int> v3;\\n        int i=0,j=0;\\n        while(i<m && j<n){\\n            if(nums1[i]>nums2[j])\\n            {\\n                v3.push_back(nums2[j]);\\n                j++;\\n            }\\n            else{\\n                v3.push_back(nums1[i]);\\n                i++;\\n            }\\n        }\\n        while(i<m){\\n            v3.push_back(nums1[i]);\\n            i++;\\n        }\\n        while(j<n){\\n            v3.push_back(nums2[j]);\\n            j++;\\n        }\\n        nums1=v3;\\n    }\\n};"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=m,j=0;i<(m+n);i++,j++){\\n\\n            nums1[i]=nums2[j];\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n        System.out.println(nums1);\\n    }\\n}\\n\\n\\nCan somebody tell the error in this"
                    },
                    {
                        "username": "naman_0002",
                        "content": "for(int i=0;i<m;i++){\\n      if(nums1[i]>nums2[0]){\\n           swap(nums1[i],nums2[0]);\\n      }\\n      sort(nums2.begin(),nums2.end());\\n}\\nint k=0;\\nfor(int j=m;j<m+n;j++){\\n     swap(nums1[j],nums2[k++]);\\n }\\n\\nvectors after all these operation store correct result but it is still giving error. Can someone tell me where is the error.\\nThanks in advance."
                    },
                    {
                        "username": "abhishekh3005",
                        "content": "nums1.resize(m);\\n        for(int i=0;i<n;i++) {\\n            nums1.push_back(nums2[i]);\\n        }\\n        sort(nums1.begin(), nums1.end());\\n\\nin this code automatically all 0 are being removed, can anyone tell how is it happening?\\n"
                    },
                    {
                        "username": "Anita-Liberatore",
                        "content": "My solution in java\\n\\n `class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k=0;\\n\\n            for(int i=0; i<m; i++) {\\n                nums1[k++] = nums1[i];\\n            }\\n\\n\\n\\n        for(int j=0; j<n; j++) {\\n                nums1[k++] = nums2[j];\\n        }\\n\\n\\n        Arrays.sort(nums1);\\n    }\\n}`"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {\\n        int ind = m ; \\n        int ind2 = 0 ;\\n        while(ind2 < n )\\n        {\\n            int tempInd = ind ;\\n            while(tempInd !=  0 && nums2[ind2] < nums1[tempInd-1])\\n            {\\n                nums1[tempInd] = nums1[tempInd-1] ;\\n                tempInd-- ;\\n            }\\n            nums1[tempInd] = nums2[ind2] ;\\n            ind2++ ;\\n            ind++ ;\\n        }\\n    }\\n};\\n// without using extra space really interesting!!!"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {\\n        int i =  0 , j = 0 ;\\n        vector<int>sorted ;\\n        while(i < m && j < n)\\n        {\\n            if(nums1[i] < nums2[j])\\n            {\\n                sorted.push_back(nums1[i]);\\n                i++ ;\\n            }\\n            else\\n            {\\n                sorted.push_back(nums2[j]); // using 3rd array as auxillary space \\n                j++ ;\\n            }\\n        }\\n        while(i < m )\\n        {\\n            sorted.push_back(nums1[i]);\\n            i++ ;\\n        }\\n        while(j < n)\\n        {\\n            sorted.push_back(nums2[j]);\\n            j++ ;\\n        }\\n        for(int i = 0 ; i < (m+n) ; i++)\\n        {\\n            nums1[i] = sorted[i];\\n        }   "
                    },
                    {
                        "username": "user9606rm",
                        "content": "Can anyone explain me why this code isnt working ?\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] arr=new int[m+n];\\n        System.arraycopy(nums1,0,arr,0,m);\\n         System.arraycopy(nums2,0,arr,m,n);\\n         Arrays.sort(arr);\\n         System.out.print(Arrays.toString(arr));\\n    }\\n}"
                    },
                    {
                        "username": "hbwhalewhalewhale",
                        "content": "using 0 as value for empty spaces in nums1 but also allowing 0 as normal value is super annoying..."
                    },
                    {
                        "username": "tonyschae",
                        "content": "Question of the code:: on the line num4(below if statement)\n\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n\n        if  nums1 == None or m==0:\n            nums1[:]=nums2  #why do I have a error if I change this line into\n                                         #\"nums1=nums2\"\n            return None\n\n        elif nums2 == None or n==0:\n            return None\n        else:\n            output=[]\n            nums1[:m+n]=sorted(nums1[:m]+nums2[:n])\n            return None\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\""
                    }
                ]
            },
            {
                "id": 1728521,
                "content": [
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        vector<int> v3;\\n        int i=0,j=0;\\n        while(i<m && j<n){\\n            if(nums1[i]>nums2[j])\\n            {\\n                v3.push_back(nums2[j]);\\n                j++;\\n            }\\n            else{\\n                v3.push_back(nums1[i]);\\n                i++;\\n            }\\n        }\\n        while(i<m){\\n            v3.push_back(nums1[i]);\\n            i++;\\n        }\\n        while(j<n){\\n            v3.push_back(nums2[j]);\\n            j++;\\n        }\\n        nums1=v3;\\n    }\\n};"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=m,j=0;i<(m+n);i++,j++){\\n\\n            nums1[i]=nums2[j];\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n        System.out.println(nums1);\\n    }\\n}\\n\\n\\nCan somebody tell the error in this"
                    },
                    {
                        "username": "naman_0002",
                        "content": "for(int i=0;i<m;i++){\\n      if(nums1[i]>nums2[0]){\\n           swap(nums1[i],nums2[0]);\\n      }\\n      sort(nums2.begin(),nums2.end());\\n}\\nint k=0;\\nfor(int j=m;j<m+n;j++){\\n     swap(nums1[j],nums2[k++]);\\n }\\n\\nvectors after all these operation store correct result but it is still giving error. Can someone tell me where is the error.\\nThanks in advance."
                    },
                    {
                        "username": "abhishekh3005",
                        "content": "nums1.resize(m);\\n        for(int i=0;i<n;i++) {\\n            nums1.push_back(nums2[i]);\\n        }\\n        sort(nums1.begin(), nums1.end());\\n\\nin this code automatically all 0 are being removed, can anyone tell how is it happening?\\n"
                    },
                    {
                        "username": "Anita-Liberatore",
                        "content": "My solution in java\\n\\n `class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k=0;\\n\\n            for(int i=0; i<m; i++) {\\n                nums1[k++] = nums1[i];\\n            }\\n\\n\\n\\n        for(int j=0; j<n; j++) {\\n                nums1[k++] = nums2[j];\\n        }\\n\\n\\n        Arrays.sort(nums1);\\n    }\\n}`"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {\\n        int ind = m ; \\n        int ind2 = 0 ;\\n        while(ind2 < n )\\n        {\\n            int tempInd = ind ;\\n            while(tempInd !=  0 && nums2[ind2] < nums1[tempInd-1])\\n            {\\n                nums1[tempInd] = nums1[tempInd-1] ;\\n                tempInd-- ;\\n            }\\n            nums1[tempInd] = nums2[ind2] ;\\n            ind2++ ;\\n            ind++ ;\\n        }\\n    }\\n};\\n// without using extra space really interesting!!!"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {\\n        int i =  0 , j = 0 ;\\n        vector<int>sorted ;\\n        while(i < m && j < n)\\n        {\\n            if(nums1[i] < nums2[j])\\n            {\\n                sorted.push_back(nums1[i]);\\n                i++ ;\\n            }\\n            else\\n            {\\n                sorted.push_back(nums2[j]); // using 3rd array as auxillary space \\n                j++ ;\\n            }\\n        }\\n        while(i < m )\\n        {\\n            sorted.push_back(nums1[i]);\\n            i++ ;\\n        }\\n        while(j < n)\\n        {\\n            sorted.push_back(nums2[j]);\\n            j++ ;\\n        }\\n        for(int i = 0 ; i < (m+n) ; i++)\\n        {\\n            nums1[i] = sorted[i];\\n        }   "
                    },
                    {
                        "username": "user9606rm",
                        "content": "Can anyone explain me why this code isnt working ?\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] arr=new int[m+n];\\n        System.arraycopy(nums1,0,arr,0,m);\\n         System.arraycopy(nums2,0,arr,m,n);\\n         Arrays.sort(arr);\\n         System.out.print(Arrays.toString(arr));\\n    }\\n}"
                    },
                    {
                        "username": "hbwhalewhalewhale",
                        "content": "using 0 as value for empty spaces in nums1 but also allowing 0 as normal value is super annoying..."
                    },
                    {
                        "username": "tonyschae",
                        "content": "Question of the code:: on the line num4(below if statement)\n\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n\n        if  nums1 == None or m==0:\n            nums1[:]=nums2  #why do I have a error if I change this line into\n                                         #\"nums1=nums2\"\n            return None\n\n        elif nums2 == None or n==0:\n            return None\n        else:\n            output=[]\n            nums1[:m+n]=sorted(nums1[:m]+nums2[:n])\n            return None\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\""
                    }
                ]
            },
            {
                "id": 1727106,
                "content": [
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        vector<int> v3;\\n        int i=0,j=0;\\n        while(i<m && j<n){\\n            if(nums1[i]>nums2[j])\\n            {\\n                v3.push_back(nums2[j]);\\n                j++;\\n            }\\n            else{\\n                v3.push_back(nums1[i]);\\n                i++;\\n            }\\n        }\\n        while(i<m){\\n            v3.push_back(nums1[i]);\\n            i++;\\n        }\\n        while(j<n){\\n            v3.push_back(nums2[j]);\\n            j++;\\n        }\\n        nums1=v3;\\n    }\\n};"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for(int i=m,j=0;i<(m+n);i++,j++){\\n\\n            nums1[i]=nums2[j];\\n            j++;\\n        }\\n        Arrays.sort(nums1);\\n        System.out.println(nums1);\\n    }\\n}\\n\\n\\nCan somebody tell the error in this"
                    },
                    {
                        "username": "naman_0002",
                        "content": "for(int i=0;i<m;i++){\\n      if(nums1[i]>nums2[0]){\\n           swap(nums1[i],nums2[0]);\\n      }\\n      sort(nums2.begin(),nums2.end());\\n}\\nint k=0;\\nfor(int j=m;j<m+n;j++){\\n     swap(nums1[j],nums2[k++]);\\n }\\n\\nvectors after all these operation store correct result but it is still giving error. Can someone tell me where is the error.\\nThanks in advance."
                    },
                    {
                        "username": "abhishekh3005",
                        "content": "nums1.resize(m);\\n        for(int i=0;i<n;i++) {\\n            nums1.push_back(nums2[i]);\\n        }\\n        sort(nums1.begin(), nums1.end());\\n\\nin this code automatically all 0 are being removed, can anyone tell how is it happening?\\n"
                    },
                    {
                        "username": "Anita-Liberatore",
                        "content": "My solution in java\\n\\n `class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int k=0;\\n\\n            for(int i=0; i<m; i++) {\\n                nums1[k++] = nums1[i];\\n            }\\n\\n\\n\\n        for(int j=0; j<n; j++) {\\n                nums1[k++] = nums2[j];\\n        }\\n\\n\\n        Arrays.sort(nums1);\\n    }\\n}`"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {\\n        int ind = m ; \\n        int ind2 = 0 ;\\n        while(ind2 < n )\\n        {\\n            int tempInd = ind ;\\n            while(tempInd !=  0 && nums2[ind2] < nums1[tempInd-1])\\n            {\\n                nums1[tempInd] = nums1[tempInd-1] ;\\n                tempInd-- ;\\n            }\\n            nums1[tempInd] = nums2[ind2] ;\\n            ind2++ ;\\n            ind++ ;\\n        }\\n    }\\n};\\n// without using extra space really interesting!!!"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \\n    {\\n        int i =  0 , j = 0 ;\\n        vector<int>sorted ;\\n        while(i < m && j < n)\\n        {\\n            if(nums1[i] < nums2[j])\\n            {\\n                sorted.push_back(nums1[i]);\\n                i++ ;\\n            }\\n            else\\n            {\\n                sorted.push_back(nums2[j]); // using 3rd array as auxillary space \\n                j++ ;\\n            }\\n        }\\n        while(i < m )\\n        {\\n            sorted.push_back(nums1[i]);\\n            i++ ;\\n        }\\n        while(j < n)\\n        {\\n            sorted.push_back(nums2[j]);\\n            j++ ;\\n        }\\n        for(int i = 0 ; i < (m+n) ; i++)\\n        {\\n            nums1[i] = sorted[i];\\n        }   "
                    },
                    {
                        "username": "user9606rm",
                        "content": "Can anyone explain me why this code isnt working ?\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int[] arr=new int[m+n];\\n        System.arraycopy(nums1,0,arr,0,m);\\n         System.arraycopy(nums2,0,arr,m,n);\\n         Arrays.sort(arr);\\n         System.out.print(Arrays.toString(arr));\\n    }\\n}"
                    },
                    {
                        "username": "hbwhalewhalewhale",
                        "content": "using 0 as value for empty spaces in nums1 but also allowing 0 as normal value is super annoying..."
                    },
                    {
                        "username": "tonyschae",
                        "content": "Question of the code:: on the line num4(below if statement)\n\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n\n        if  nums1 == None or m==0:\n            nums1[:]=nums2  #why do I have a error if I change this line into\n                                         #\"nums1=nums2\"\n            return None\n\n        elif nums2 == None or n==0:\n            return None\n        else:\n            output=[]\n            nums1[:m+n]=sorted(nums1[:m]+nums2[:n])\n            return None\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\""
                    }
                ]
            },
            {
                "id": 1722782,
                "content": [
                    {
                        "username": "thehacker4chan",
                        "content": "anyone know what is going on here? I am printing result and the output is showing the expected answer, but when I return the exact same result I am getting an incorrect output? \\n[my code](https://imgur.com/a/jfXGjhG)"
                    },
                    {
                        "username": "Rishabh_Sahu",
                        "content": "You don\\'t have to return the sorted array. You need to sort array1 in place with the elements of array2 inserted at the last positions storing 0 value .Append function will add elements after those 0 values and increase the size of nums1 beyond the limit of m elements as constrained by the question."
                    },
                    {
                        "username": "rudraVal",
                        "content": "In JS I wrote this code..\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1.push(...nums2);\\n    let sortNum = nums1.sort();\\n    sortNum.filter(e=>e!=0);\\n};\\n\\nIn other online editor and in VS Code, it working perfectly for all testcases but here it gives wrong output for Case 1 and Case 3.\\n\\nCan someone help me why it is happening or explain me what\\'s wrong in this."
                    },
                    {
                        "username": "jrinehuls",
                        "content": "catch (ArrayIndexOutOfBoundsException e)\\nbecause this one is total crap. "
                    },
                    {
                        "username": "xiangqyou",
                        "content": "Can anyone tell me why this typescript function doesn\\'t work?\\nfunction merge(nums1: number[], m: number, nums2: number[], n: number): void {\\n  nums1 = nums1.slice(0,m)\\n  nums1 = [...nums1, ...nums2].sort((a,b)=>(a-b))\\n};"
                    },
                    {
                        "username": "CoderBekamir",
                        "content": "pls help, why my code is wrong?\\n`class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        for(int j = 0; j < nums1.size(); j++)\\n        {\\n            if(nums1[j] == 0)\\n            {\\n                nums1.erase(nums1.begin() + j);\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums2[i] != 0) //check nums is 0\\n            {\\n                for(int bs = nums1.size() - 1; bs >= 0; bs--)\\n                {\\n                    if(nums2[i] >= nums1[bs])\\n                    {\\n                        if(nums2[i] >= nums1[bs - 1])\\n                        {\\n                            continue;\\n                        }\\n                        \\n                        else\\n                        {\\n                        nums1.insert(nums1.end() - bs, nums2[i]);\\n                        break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "Chuan21",
                        "content": "    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int maxIndex = nums1.length - 1;\\n        while (m > 0 || n > 0) {\\n            if (n == 0) {\\n                nums1[maxIndex--] = nums1[--m];\\n                continue;\\n            }\\n            if (m == 0) {\\n                nums1[maxIndex--] = nums2[--n];\\n                continue;\\n            }\\n            nums1[maxIndex--] = (nums1[m - 1] < nums2[n - 1]) ? nums2[--n] : nums1[--m];\\n        }\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/88_merge_sorted_array.cpp\\n\\nC++ SOLUTION \\nLEAVE A GITHUB REPOSITORY STAR IF IT HELPS YOU "
                    },
                    {
                        "username": "DVS08",
                        "content": "Why cant we just iterate from the back on both arrays and fill in the 0s with 2nd array\\'s values. Then using Arrays.sort(), sort it?"
                    },
                    {
                        "username": "shrutishastri_29",
                        "content": "Why my approach is wrong ??\\n\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = nums1[:m] \\n        nums = nums1 + nums2\\n        nums.sort()\\n        nums1 = nums"
                    },
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1;\\n    int j = n - 1;\\n    int k = (m + n - 1);\\n\\n    while (i >= 0 && j >= 0)\\n    {\\n\\n        if (nums1[i] > nums2[j])\\n        {\\n            nums1[k--] = nums1[i--];\\n        }\\n\\n        else\\n        {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n\\n    while (i >= 0)\\n    {\\n\\n        nums1[k--] = nums1[i--];\\n    }\\n\\n    while (j >= 0)\\n    {\\n\\n        nums1[k--] = nums2[j--];\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1722471,
                "content": [
                    {
                        "username": "thehacker4chan",
                        "content": "anyone know what is going on here? I am printing result and the output is showing the expected answer, but when I return the exact same result I am getting an incorrect output? \\n[my code](https://imgur.com/a/jfXGjhG)"
                    },
                    {
                        "username": "Rishabh_Sahu",
                        "content": "You don\\'t have to return the sorted array. You need to sort array1 in place with the elements of array2 inserted at the last positions storing 0 value .Append function will add elements after those 0 values and increase the size of nums1 beyond the limit of m elements as constrained by the question."
                    },
                    {
                        "username": "rudraVal",
                        "content": "In JS I wrote this code..\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1.push(...nums2);\\n    let sortNum = nums1.sort();\\n    sortNum.filter(e=>e!=0);\\n};\\n\\nIn other online editor and in VS Code, it working perfectly for all testcases but here it gives wrong output for Case 1 and Case 3.\\n\\nCan someone help me why it is happening or explain me what\\'s wrong in this."
                    },
                    {
                        "username": "jrinehuls",
                        "content": "catch (ArrayIndexOutOfBoundsException e)\\nbecause this one is total crap. "
                    },
                    {
                        "username": "xiangqyou",
                        "content": "Can anyone tell me why this typescript function doesn\\'t work?\\nfunction merge(nums1: number[], m: number, nums2: number[], n: number): void {\\n  nums1 = nums1.slice(0,m)\\n  nums1 = [...nums1, ...nums2].sort((a,b)=>(a-b))\\n};"
                    },
                    {
                        "username": "CoderBekamir",
                        "content": "pls help, why my code is wrong?\\n`class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        for(int j = 0; j < nums1.size(); j++)\\n        {\\n            if(nums1[j] == 0)\\n            {\\n                nums1.erase(nums1.begin() + j);\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums2[i] != 0) //check nums is 0\\n            {\\n                for(int bs = nums1.size() - 1; bs >= 0; bs--)\\n                {\\n                    if(nums2[i] >= nums1[bs])\\n                    {\\n                        if(nums2[i] >= nums1[bs - 1])\\n                        {\\n                            continue;\\n                        }\\n                        \\n                        else\\n                        {\\n                        nums1.insert(nums1.end() - bs, nums2[i]);\\n                        break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "Chuan21",
                        "content": "    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int maxIndex = nums1.length - 1;\\n        while (m > 0 || n > 0) {\\n            if (n == 0) {\\n                nums1[maxIndex--] = nums1[--m];\\n                continue;\\n            }\\n            if (m == 0) {\\n                nums1[maxIndex--] = nums2[--n];\\n                continue;\\n            }\\n            nums1[maxIndex--] = (nums1[m - 1] < nums2[n - 1]) ? nums2[--n] : nums1[--m];\\n        }\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/88_merge_sorted_array.cpp\\n\\nC++ SOLUTION \\nLEAVE A GITHUB REPOSITORY STAR IF IT HELPS YOU "
                    },
                    {
                        "username": "DVS08",
                        "content": "Why cant we just iterate from the back on both arrays and fill in the 0s with 2nd array\\'s values. Then using Arrays.sort(), sort it?"
                    },
                    {
                        "username": "shrutishastri_29",
                        "content": "Why my approach is wrong ??\\n\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = nums1[:m] \\n        nums = nums1 + nums2\\n        nums.sort()\\n        nums1 = nums"
                    },
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1;\\n    int j = n - 1;\\n    int k = (m + n - 1);\\n\\n    while (i >= 0 && j >= 0)\\n    {\\n\\n        if (nums1[i] > nums2[j])\\n        {\\n            nums1[k--] = nums1[i--];\\n        }\\n\\n        else\\n        {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n\\n    while (i >= 0)\\n    {\\n\\n        nums1[k--] = nums1[i--];\\n    }\\n\\n    while (j >= 0)\\n    {\\n\\n        nums1[k--] = nums2[j--];\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1717686,
                "content": [
                    {
                        "username": "thehacker4chan",
                        "content": "anyone know what is going on here? I am printing result and the output is showing the expected answer, but when I return the exact same result I am getting an incorrect output? \\n[my code](https://imgur.com/a/jfXGjhG)"
                    },
                    {
                        "username": "Rishabh_Sahu",
                        "content": "You don\\'t have to return the sorted array. You need to sort array1 in place with the elements of array2 inserted at the last positions storing 0 value .Append function will add elements after those 0 values and increase the size of nums1 beyond the limit of m elements as constrained by the question."
                    },
                    {
                        "username": "rudraVal",
                        "content": "In JS I wrote this code..\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1.push(...nums2);\\n    let sortNum = nums1.sort();\\n    sortNum.filter(e=>e!=0);\\n};\\n\\nIn other online editor and in VS Code, it working perfectly for all testcases but here it gives wrong output for Case 1 and Case 3.\\n\\nCan someone help me why it is happening or explain me what\\'s wrong in this."
                    },
                    {
                        "username": "jrinehuls",
                        "content": "catch (ArrayIndexOutOfBoundsException e)\\nbecause this one is total crap. "
                    },
                    {
                        "username": "xiangqyou",
                        "content": "Can anyone tell me why this typescript function doesn\\'t work?\\nfunction merge(nums1: number[], m: number, nums2: number[], n: number): void {\\n  nums1 = nums1.slice(0,m)\\n  nums1 = [...nums1, ...nums2].sort((a,b)=>(a-b))\\n};"
                    },
                    {
                        "username": "CoderBekamir",
                        "content": "pls help, why my code is wrong?\\n`class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        for(int j = 0; j < nums1.size(); j++)\\n        {\\n            if(nums1[j] == 0)\\n            {\\n                nums1.erase(nums1.begin() + j);\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums2[i] != 0) //check nums is 0\\n            {\\n                for(int bs = nums1.size() - 1; bs >= 0; bs--)\\n                {\\n                    if(nums2[i] >= nums1[bs])\\n                    {\\n                        if(nums2[i] >= nums1[bs - 1])\\n                        {\\n                            continue;\\n                        }\\n                        \\n                        else\\n                        {\\n                        nums1.insert(nums1.end() - bs, nums2[i]);\\n                        break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "Chuan21",
                        "content": "    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int maxIndex = nums1.length - 1;\\n        while (m > 0 || n > 0) {\\n            if (n == 0) {\\n                nums1[maxIndex--] = nums1[--m];\\n                continue;\\n            }\\n            if (m == 0) {\\n                nums1[maxIndex--] = nums2[--n];\\n                continue;\\n            }\\n            nums1[maxIndex--] = (nums1[m - 1] < nums2[n - 1]) ? nums2[--n] : nums1[--m];\\n        }\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/88_merge_sorted_array.cpp\\n\\nC++ SOLUTION \\nLEAVE A GITHUB REPOSITORY STAR IF IT HELPS YOU "
                    },
                    {
                        "username": "DVS08",
                        "content": "Why cant we just iterate from the back on both arrays and fill in the 0s with 2nd array\\'s values. Then using Arrays.sort(), sort it?"
                    },
                    {
                        "username": "shrutishastri_29",
                        "content": "Why my approach is wrong ??\\n\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = nums1[:m] \\n        nums = nums1 + nums2\\n        nums.sort()\\n        nums1 = nums"
                    },
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1;\\n    int j = n - 1;\\n    int k = (m + n - 1);\\n\\n    while (i >= 0 && j >= 0)\\n    {\\n\\n        if (nums1[i] > nums2[j])\\n        {\\n            nums1[k--] = nums1[i--];\\n        }\\n\\n        else\\n        {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n\\n    while (i >= 0)\\n    {\\n\\n        nums1[k--] = nums1[i--];\\n    }\\n\\n    while (j >= 0)\\n    {\\n\\n        nums1[k--] = nums2[j--];\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1717643,
                "content": [
                    {
                        "username": "thehacker4chan",
                        "content": "anyone know what is going on here? I am printing result and the output is showing the expected answer, but when I return the exact same result I am getting an incorrect output? \\n[my code](https://imgur.com/a/jfXGjhG)"
                    },
                    {
                        "username": "Rishabh_Sahu",
                        "content": "You don\\'t have to return the sorted array. You need to sort array1 in place with the elements of array2 inserted at the last positions storing 0 value .Append function will add elements after those 0 values and increase the size of nums1 beyond the limit of m elements as constrained by the question."
                    },
                    {
                        "username": "rudraVal",
                        "content": "In JS I wrote this code..\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1.push(...nums2);\\n    let sortNum = nums1.sort();\\n    sortNum.filter(e=>e!=0);\\n};\\n\\nIn other online editor and in VS Code, it working perfectly for all testcases but here it gives wrong output for Case 1 and Case 3.\\n\\nCan someone help me why it is happening or explain me what\\'s wrong in this."
                    },
                    {
                        "username": "jrinehuls",
                        "content": "catch (ArrayIndexOutOfBoundsException e)\\nbecause this one is total crap. "
                    },
                    {
                        "username": "xiangqyou",
                        "content": "Can anyone tell me why this typescript function doesn\\'t work?\\nfunction merge(nums1: number[], m: number, nums2: number[], n: number): void {\\n  nums1 = nums1.slice(0,m)\\n  nums1 = [...nums1, ...nums2].sort((a,b)=>(a-b))\\n};"
                    },
                    {
                        "username": "CoderBekamir",
                        "content": "pls help, why my code is wrong?\\n`class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        for(int j = 0; j < nums1.size(); j++)\\n        {\\n            if(nums1[j] == 0)\\n            {\\n                nums1.erase(nums1.begin() + j);\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums2[i] != 0) //check nums is 0\\n            {\\n                for(int bs = nums1.size() - 1; bs >= 0; bs--)\\n                {\\n                    if(nums2[i] >= nums1[bs])\\n                    {\\n                        if(nums2[i] >= nums1[bs - 1])\\n                        {\\n                            continue;\\n                        }\\n                        \\n                        else\\n                        {\\n                        nums1.insert(nums1.end() - bs, nums2[i]);\\n                        break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "Chuan21",
                        "content": "    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int maxIndex = nums1.length - 1;\\n        while (m > 0 || n > 0) {\\n            if (n == 0) {\\n                nums1[maxIndex--] = nums1[--m];\\n                continue;\\n            }\\n            if (m == 0) {\\n                nums1[maxIndex--] = nums2[--n];\\n                continue;\\n            }\\n            nums1[maxIndex--] = (nums1[m - 1] < nums2[n - 1]) ? nums2[--n] : nums1[--m];\\n        }\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/88_merge_sorted_array.cpp\\n\\nC++ SOLUTION \\nLEAVE A GITHUB REPOSITORY STAR IF IT HELPS YOU "
                    },
                    {
                        "username": "DVS08",
                        "content": "Why cant we just iterate from the back on both arrays and fill in the 0s with 2nd array\\'s values. Then using Arrays.sort(), sort it?"
                    },
                    {
                        "username": "shrutishastri_29",
                        "content": "Why my approach is wrong ??\\n\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = nums1[:m] \\n        nums = nums1 + nums2\\n        nums.sort()\\n        nums1 = nums"
                    },
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1;\\n    int j = n - 1;\\n    int k = (m + n - 1);\\n\\n    while (i >= 0 && j >= 0)\\n    {\\n\\n        if (nums1[i] > nums2[j])\\n        {\\n            nums1[k--] = nums1[i--];\\n        }\\n\\n        else\\n        {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n\\n    while (i >= 0)\\n    {\\n\\n        nums1[k--] = nums1[i--];\\n    }\\n\\n    while (j >= 0)\\n    {\\n\\n        nums1[k--] = nums2[j--];\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1717453,
                "content": [
                    {
                        "username": "thehacker4chan",
                        "content": "anyone know what is going on here? I am printing result and the output is showing the expected answer, but when I return the exact same result I am getting an incorrect output? \\n[my code](https://imgur.com/a/jfXGjhG)"
                    },
                    {
                        "username": "Rishabh_Sahu",
                        "content": "You don\\'t have to return the sorted array. You need to sort array1 in place with the elements of array2 inserted at the last positions storing 0 value .Append function will add elements after those 0 values and increase the size of nums1 beyond the limit of m elements as constrained by the question."
                    },
                    {
                        "username": "rudraVal",
                        "content": "In JS I wrote this code..\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1.push(...nums2);\\n    let sortNum = nums1.sort();\\n    sortNum.filter(e=>e!=0);\\n};\\n\\nIn other online editor and in VS Code, it working perfectly for all testcases but here it gives wrong output for Case 1 and Case 3.\\n\\nCan someone help me why it is happening or explain me what\\'s wrong in this."
                    },
                    {
                        "username": "jrinehuls",
                        "content": "catch (ArrayIndexOutOfBoundsException e)\\nbecause this one is total crap. "
                    },
                    {
                        "username": "xiangqyou",
                        "content": "Can anyone tell me why this typescript function doesn\\'t work?\\nfunction merge(nums1: number[], m: number, nums2: number[], n: number): void {\\n  nums1 = nums1.slice(0,m)\\n  nums1 = [...nums1, ...nums2].sort((a,b)=>(a-b))\\n};"
                    },
                    {
                        "username": "CoderBekamir",
                        "content": "pls help, why my code is wrong?\\n`class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        for(int j = 0; j < nums1.size(); j++)\\n        {\\n            if(nums1[j] == 0)\\n            {\\n                nums1.erase(nums1.begin() + j);\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums2[i] != 0) //check nums is 0\\n            {\\n                for(int bs = nums1.size() - 1; bs >= 0; bs--)\\n                {\\n                    if(nums2[i] >= nums1[bs])\\n                    {\\n                        if(nums2[i] >= nums1[bs - 1])\\n                        {\\n                            continue;\\n                        }\\n                        \\n                        else\\n                        {\\n                        nums1.insert(nums1.end() - bs, nums2[i]);\\n                        break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "Chuan21",
                        "content": "    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int maxIndex = nums1.length - 1;\\n        while (m > 0 || n > 0) {\\n            if (n == 0) {\\n                nums1[maxIndex--] = nums1[--m];\\n                continue;\\n            }\\n            if (m == 0) {\\n                nums1[maxIndex--] = nums2[--n];\\n                continue;\\n            }\\n            nums1[maxIndex--] = (nums1[m - 1] < nums2[n - 1]) ? nums2[--n] : nums1[--m];\\n        }\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/88_merge_sorted_array.cpp\\n\\nC++ SOLUTION \\nLEAVE A GITHUB REPOSITORY STAR IF IT HELPS YOU "
                    },
                    {
                        "username": "DVS08",
                        "content": "Why cant we just iterate from the back on both arrays and fill in the 0s with 2nd array\\'s values. Then using Arrays.sort(), sort it?"
                    },
                    {
                        "username": "shrutishastri_29",
                        "content": "Why my approach is wrong ??\\n\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = nums1[:m] \\n        nums = nums1 + nums2\\n        nums.sort()\\n        nums1 = nums"
                    },
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1;\\n    int j = n - 1;\\n    int k = (m + n - 1);\\n\\n    while (i >= 0 && j >= 0)\\n    {\\n\\n        if (nums1[i] > nums2[j])\\n        {\\n            nums1[k--] = nums1[i--];\\n        }\\n\\n        else\\n        {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n\\n    while (i >= 0)\\n    {\\n\\n        nums1[k--] = nums1[i--];\\n    }\\n\\n    while (j >= 0)\\n    {\\n\\n        nums1[k--] = nums2[j--];\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1716408,
                "content": [
                    {
                        "username": "thehacker4chan",
                        "content": "anyone know what is going on here? I am printing result and the output is showing the expected answer, but when I return the exact same result I am getting an incorrect output? \\n[my code](https://imgur.com/a/jfXGjhG)"
                    },
                    {
                        "username": "Rishabh_Sahu",
                        "content": "You don\\'t have to return the sorted array. You need to sort array1 in place with the elements of array2 inserted at the last positions storing 0 value .Append function will add elements after those 0 values and increase the size of nums1 beyond the limit of m elements as constrained by the question."
                    },
                    {
                        "username": "rudraVal",
                        "content": "In JS I wrote this code..\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1.push(...nums2);\\n    let sortNum = nums1.sort();\\n    sortNum.filter(e=>e!=0);\\n};\\n\\nIn other online editor and in VS Code, it working perfectly for all testcases but here it gives wrong output for Case 1 and Case 3.\\n\\nCan someone help me why it is happening or explain me what\\'s wrong in this."
                    },
                    {
                        "username": "jrinehuls",
                        "content": "catch (ArrayIndexOutOfBoundsException e)\\nbecause this one is total crap. "
                    },
                    {
                        "username": "xiangqyou",
                        "content": "Can anyone tell me why this typescript function doesn\\'t work?\\nfunction merge(nums1: number[], m: number, nums2: number[], n: number): void {\\n  nums1 = nums1.slice(0,m)\\n  nums1 = [...nums1, ...nums2].sort((a,b)=>(a-b))\\n};"
                    },
                    {
                        "username": "CoderBekamir",
                        "content": "pls help, why my code is wrong?\\n`class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        for(int j = 0; j < nums1.size(); j++)\\n        {\\n            if(nums1[j] == 0)\\n            {\\n                nums1.erase(nums1.begin() + j);\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums2[i] != 0) //check nums is 0\\n            {\\n                for(int bs = nums1.size() - 1; bs >= 0; bs--)\\n                {\\n                    if(nums2[i] >= nums1[bs])\\n                    {\\n                        if(nums2[i] >= nums1[bs - 1])\\n                        {\\n                            continue;\\n                        }\\n                        \\n                        else\\n                        {\\n                        nums1.insert(nums1.end() - bs, nums2[i]);\\n                        break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "Chuan21",
                        "content": "    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int maxIndex = nums1.length - 1;\\n        while (m > 0 || n > 0) {\\n            if (n == 0) {\\n                nums1[maxIndex--] = nums1[--m];\\n                continue;\\n            }\\n            if (m == 0) {\\n                nums1[maxIndex--] = nums2[--n];\\n                continue;\\n            }\\n            nums1[maxIndex--] = (nums1[m - 1] < nums2[n - 1]) ? nums2[--n] : nums1[--m];\\n        }\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/88_merge_sorted_array.cpp\\n\\nC++ SOLUTION \\nLEAVE A GITHUB REPOSITORY STAR IF IT HELPS YOU "
                    },
                    {
                        "username": "DVS08",
                        "content": "Why cant we just iterate from the back on both arrays and fill in the 0s with 2nd array\\'s values. Then using Arrays.sort(), sort it?"
                    },
                    {
                        "username": "shrutishastri_29",
                        "content": "Why my approach is wrong ??\\n\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = nums1[:m] \\n        nums = nums1 + nums2\\n        nums.sort()\\n        nums1 = nums"
                    },
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1;\\n    int j = n - 1;\\n    int k = (m + n - 1);\\n\\n    while (i >= 0 && j >= 0)\\n    {\\n\\n        if (nums1[i] > nums2[j])\\n        {\\n            nums1[k--] = nums1[i--];\\n        }\\n\\n        else\\n        {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n\\n    while (i >= 0)\\n    {\\n\\n        nums1[k--] = nums1[i--];\\n    }\\n\\n    while (j >= 0)\\n    {\\n\\n        nums1[k--] = nums2[j--];\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1716049,
                "content": [
                    {
                        "username": "thehacker4chan",
                        "content": "anyone know what is going on here? I am printing result and the output is showing the expected answer, but when I return the exact same result I am getting an incorrect output? \\n[my code](https://imgur.com/a/jfXGjhG)"
                    },
                    {
                        "username": "Rishabh_Sahu",
                        "content": "You don\\'t have to return the sorted array. You need to sort array1 in place with the elements of array2 inserted at the last positions storing 0 value .Append function will add elements after those 0 values and increase the size of nums1 beyond the limit of m elements as constrained by the question."
                    },
                    {
                        "username": "rudraVal",
                        "content": "In JS I wrote this code..\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1.push(...nums2);\\n    let sortNum = nums1.sort();\\n    sortNum.filter(e=>e!=0);\\n};\\n\\nIn other online editor and in VS Code, it working perfectly for all testcases but here it gives wrong output for Case 1 and Case 3.\\n\\nCan someone help me why it is happening or explain me what\\'s wrong in this."
                    },
                    {
                        "username": "jrinehuls",
                        "content": "catch (ArrayIndexOutOfBoundsException e)\\nbecause this one is total crap. "
                    },
                    {
                        "username": "xiangqyou",
                        "content": "Can anyone tell me why this typescript function doesn\\'t work?\\nfunction merge(nums1: number[], m: number, nums2: number[], n: number): void {\\n  nums1 = nums1.slice(0,m)\\n  nums1 = [...nums1, ...nums2].sort((a,b)=>(a-b))\\n};"
                    },
                    {
                        "username": "CoderBekamir",
                        "content": "pls help, why my code is wrong?\\n`class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        for(int j = 0; j < nums1.size(); j++)\\n        {\\n            if(nums1[j] == 0)\\n            {\\n                nums1.erase(nums1.begin() + j);\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums2[i] != 0) //check nums is 0\\n            {\\n                for(int bs = nums1.size() - 1; bs >= 0; bs--)\\n                {\\n                    if(nums2[i] >= nums1[bs])\\n                    {\\n                        if(nums2[i] >= nums1[bs - 1])\\n                        {\\n                            continue;\\n                        }\\n                        \\n                        else\\n                        {\\n                        nums1.insert(nums1.end() - bs, nums2[i]);\\n                        break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "Chuan21",
                        "content": "    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int maxIndex = nums1.length - 1;\\n        while (m > 0 || n > 0) {\\n            if (n == 0) {\\n                nums1[maxIndex--] = nums1[--m];\\n                continue;\\n            }\\n            if (m == 0) {\\n                nums1[maxIndex--] = nums2[--n];\\n                continue;\\n            }\\n            nums1[maxIndex--] = (nums1[m - 1] < nums2[n - 1]) ? nums2[--n] : nums1[--m];\\n        }\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/88_merge_sorted_array.cpp\\n\\nC++ SOLUTION \\nLEAVE A GITHUB REPOSITORY STAR IF IT HELPS YOU "
                    },
                    {
                        "username": "DVS08",
                        "content": "Why cant we just iterate from the back on both arrays and fill in the 0s with 2nd array\\'s values. Then using Arrays.sort(), sort it?"
                    },
                    {
                        "username": "shrutishastri_29",
                        "content": "Why my approach is wrong ??\\n\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = nums1[:m] \\n        nums = nums1 + nums2\\n        nums.sort()\\n        nums1 = nums"
                    },
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1;\\n    int j = n - 1;\\n    int k = (m + n - 1);\\n\\n    while (i >= 0 && j >= 0)\\n    {\\n\\n        if (nums1[i] > nums2[j])\\n        {\\n            nums1[k--] = nums1[i--];\\n        }\\n\\n        else\\n        {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n\\n    while (i >= 0)\\n    {\\n\\n        nums1[k--] = nums1[i--];\\n    }\\n\\n    while (j >= 0)\\n    {\\n\\n        nums1[k--] = nums2[j--];\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1715529,
                "content": [
                    {
                        "username": "thehacker4chan",
                        "content": "anyone know what is going on here? I am printing result and the output is showing the expected answer, but when I return the exact same result I am getting an incorrect output? \\n[my code](https://imgur.com/a/jfXGjhG)"
                    },
                    {
                        "username": "Rishabh_Sahu",
                        "content": "You don\\'t have to return the sorted array. You need to sort array1 in place with the elements of array2 inserted at the last positions storing 0 value .Append function will add elements after those 0 values and increase the size of nums1 beyond the limit of m elements as constrained by the question."
                    },
                    {
                        "username": "rudraVal",
                        "content": "In JS I wrote this code..\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1.push(...nums2);\\n    let sortNum = nums1.sort();\\n    sortNum.filter(e=>e!=0);\\n};\\n\\nIn other online editor and in VS Code, it working perfectly for all testcases but here it gives wrong output for Case 1 and Case 3.\\n\\nCan someone help me why it is happening or explain me what\\'s wrong in this."
                    },
                    {
                        "username": "jrinehuls",
                        "content": "catch (ArrayIndexOutOfBoundsException e)\\nbecause this one is total crap. "
                    },
                    {
                        "username": "xiangqyou",
                        "content": "Can anyone tell me why this typescript function doesn\\'t work?\\nfunction merge(nums1: number[], m: number, nums2: number[], n: number): void {\\n  nums1 = nums1.slice(0,m)\\n  nums1 = [...nums1, ...nums2].sort((a,b)=>(a-b))\\n};"
                    },
                    {
                        "username": "CoderBekamir",
                        "content": "pls help, why my code is wrong?\\n`class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        for(int j = 0; j < nums1.size(); j++)\\n        {\\n            if(nums1[j] == 0)\\n            {\\n                nums1.erase(nums1.begin() + j);\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums2[i] != 0) //check nums is 0\\n            {\\n                for(int bs = nums1.size() - 1; bs >= 0; bs--)\\n                {\\n                    if(nums2[i] >= nums1[bs])\\n                    {\\n                        if(nums2[i] >= nums1[bs - 1])\\n                        {\\n                            continue;\\n                        }\\n                        \\n                        else\\n                        {\\n                        nums1.insert(nums1.end() - bs, nums2[i]);\\n                        break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "Chuan21",
                        "content": "    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int maxIndex = nums1.length - 1;\\n        while (m > 0 || n > 0) {\\n            if (n == 0) {\\n                nums1[maxIndex--] = nums1[--m];\\n                continue;\\n            }\\n            if (m == 0) {\\n                nums1[maxIndex--] = nums2[--n];\\n                continue;\\n            }\\n            nums1[maxIndex--] = (nums1[m - 1] < nums2[n - 1]) ? nums2[--n] : nums1[--m];\\n        }\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/88_merge_sorted_array.cpp\\n\\nC++ SOLUTION \\nLEAVE A GITHUB REPOSITORY STAR IF IT HELPS YOU "
                    },
                    {
                        "username": "DVS08",
                        "content": "Why cant we just iterate from the back on both arrays and fill in the 0s with 2nd array\\'s values. Then using Arrays.sort(), sort it?"
                    },
                    {
                        "username": "shrutishastri_29",
                        "content": "Why my approach is wrong ??\\n\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = nums1[:m] \\n        nums = nums1 + nums2\\n        nums.sort()\\n        nums1 = nums"
                    },
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1;\\n    int j = n - 1;\\n    int k = (m + n - 1);\\n\\n    while (i >= 0 && j >= 0)\\n    {\\n\\n        if (nums1[i] > nums2[j])\\n        {\\n            nums1[k--] = nums1[i--];\\n        }\\n\\n        else\\n        {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n\\n    while (i >= 0)\\n    {\\n\\n        nums1[k--] = nums1[i--];\\n    }\\n\\n    while (j >= 0)\\n    {\\n\\n        nums1[k--] = nums2[j--];\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1715463,
                "content": [
                    {
                        "username": "thehacker4chan",
                        "content": "anyone know what is going on here? I am printing result and the output is showing the expected answer, but when I return the exact same result I am getting an incorrect output? \\n[my code](https://imgur.com/a/jfXGjhG)"
                    },
                    {
                        "username": "Rishabh_Sahu",
                        "content": "You don\\'t have to return the sorted array. You need to sort array1 in place with the elements of array2 inserted at the last positions storing 0 value .Append function will add elements after those 0 values and increase the size of nums1 beyond the limit of m elements as constrained by the question."
                    },
                    {
                        "username": "rudraVal",
                        "content": "In JS I wrote this code..\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1.push(...nums2);\\n    let sortNum = nums1.sort();\\n    sortNum.filter(e=>e!=0);\\n};\\n\\nIn other online editor and in VS Code, it working perfectly for all testcases but here it gives wrong output for Case 1 and Case 3.\\n\\nCan someone help me why it is happening or explain me what\\'s wrong in this."
                    },
                    {
                        "username": "jrinehuls",
                        "content": "catch (ArrayIndexOutOfBoundsException e)\\nbecause this one is total crap. "
                    },
                    {
                        "username": "xiangqyou",
                        "content": "Can anyone tell me why this typescript function doesn\\'t work?\\nfunction merge(nums1: number[], m: number, nums2: number[], n: number): void {\\n  nums1 = nums1.slice(0,m)\\n  nums1 = [...nums1, ...nums2].sort((a,b)=>(a-b))\\n};"
                    },
                    {
                        "username": "CoderBekamir",
                        "content": "pls help, why my code is wrong?\\n`class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        for(int j = 0; j < nums1.size(); j++)\\n        {\\n            if(nums1[j] == 0)\\n            {\\n                nums1.erase(nums1.begin() + j);\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums2[i] != 0) //check nums is 0\\n            {\\n                for(int bs = nums1.size() - 1; bs >= 0; bs--)\\n                {\\n                    if(nums2[i] >= nums1[bs])\\n                    {\\n                        if(nums2[i] >= nums1[bs - 1])\\n                        {\\n                            continue;\\n                        }\\n                        \\n                        else\\n                        {\\n                        nums1.insert(nums1.end() - bs, nums2[i]);\\n                        break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "Chuan21",
                        "content": "    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int maxIndex = nums1.length - 1;\\n        while (m > 0 || n > 0) {\\n            if (n == 0) {\\n                nums1[maxIndex--] = nums1[--m];\\n                continue;\\n            }\\n            if (m == 0) {\\n                nums1[maxIndex--] = nums2[--n];\\n                continue;\\n            }\\n            nums1[maxIndex--] = (nums1[m - 1] < nums2[n - 1]) ? nums2[--n] : nums1[--m];\\n        }\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/88_merge_sorted_array.cpp\\n\\nC++ SOLUTION \\nLEAVE A GITHUB REPOSITORY STAR IF IT HELPS YOU "
                    },
                    {
                        "username": "DVS08",
                        "content": "Why cant we just iterate from the back on both arrays and fill in the 0s with 2nd array\\'s values. Then using Arrays.sort(), sort it?"
                    },
                    {
                        "username": "shrutishastri_29",
                        "content": "Why my approach is wrong ??\\n\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = nums1[:m] \\n        nums = nums1 + nums2\\n        nums.sort()\\n        nums1 = nums"
                    },
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1;\\n    int j = n - 1;\\n    int k = (m + n - 1);\\n\\n    while (i >= 0 && j >= 0)\\n    {\\n\\n        if (nums1[i] > nums2[j])\\n        {\\n            nums1[k--] = nums1[i--];\\n        }\\n\\n        else\\n        {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n\\n    while (i >= 0)\\n    {\\n\\n        nums1[k--] = nums1[i--];\\n    }\\n\\n    while (j >= 0)\\n    {\\n\\n        nums1[k--] = nums2[j--];\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1711106,
                "content": [
                    {
                        "username": "thehacker4chan",
                        "content": "anyone know what is going on here? I am printing result and the output is showing the expected answer, but when I return the exact same result I am getting an incorrect output? \\n[my code](https://imgur.com/a/jfXGjhG)"
                    },
                    {
                        "username": "Rishabh_Sahu",
                        "content": "You don\\'t have to return the sorted array. You need to sort array1 in place with the elements of array2 inserted at the last positions storing 0 value .Append function will add elements after those 0 values and increase the size of nums1 beyond the limit of m elements as constrained by the question."
                    },
                    {
                        "username": "rudraVal",
                        "content": "In JS I wrote this code..\\nvar merge = function(nums1, m, nums2, n) {\\n    nums1.push(...nums2);\\n    let sortNum = nums1.sort();\\n    sortNum.filter(e=>e!=0);\\n};\\n\\nIn other online editor and in VS Code, it working perfectly for all testcases but here it gives wrong output for Case 1 and Case 3.\\n\\nCan someone help me why it is happening or explain me what\\'s wrong in this."
                    },
                    {
                        "username": "jrinehuls",
                        "content": "catch (ArrayIndexOutOfBoundsException e)\\nbecause this one is total crap. "
                    },
                    {
                        "username": "xiangqyou",
                        "content": "Can anyone tell me why this typescript function doesn\\'t work?\\nfunction merge(nums1: number[], m: number, nums2: number[], n: number): void {\\n  nums1 = nums1.slice(0,m)\\n  nums1 = [...nums1, ...nums2].sort((a,b)=>(a-b))\\n};"
                    },
                    {
                        "username": "CoderBekamir",
                        "content": "pls help, why my code is wrong?\\n`class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        \\n        for(int j = 0; j < nums1.size(); j++)\\n        {\\n            if(nums1[j] == 0)\\n            {\\n                nums1.erase(nums1.begin() + j);\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums2[i] != 0) //check nums is 0\\n            {\\n                for(int bs = nums1.size() - 1; bs >= 0; bs--)\\n                {\\n                    if(nums2[i] >= nums1[bs])\\n                    {\\n                        if(nums2[i] >= nums1[bs - 1])\\n                        {\\n                            continue;\\n                        }\\n                        \\n                        else\\n                        {\\n                        nums1.insert(nums1.end() - bs, nums2[i]);\\n                        break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "Chuan21",
                        "content": "    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int maxIndex = nums1.length - 1;\\n        while (m > 0 || n > 0) {\\n            if (n == 0) {\\n                nums1[maxIndex--] = nums1[--m];\\n                continue;\\n            }\\n            if (m == 0) {\\n                nums1[maxIndex--] = nums2[--n];\\n                continue;\\n            }\\n            nums1[maxIndex--] = (nums1[m - 1] < nums2[n - 1]) ? nums2[--n] : nums1[--m];\\n        }\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/88_merge_sorted_array.cpp\\n\\nC++ SOLUTION \\nLEAVE A GITHUB REPOSITORY STAR IF IT HELPS YOU "
                    },
                    {
                        "username": "DVS08",
                        "content": "Why cant we just iterate from the back on both arrays and fill in the 0s with 2nd array\\'s values. Then using Arrays.sort(), sort it?"
                    },
                    {
                        "username": "shrutishastri_29",
                        "content": "Why my approach is wrong ??\\n\\n\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \"\"\"\\n        nums1 = nums1[:m] \\n        nums = nums1 + nums2\\n        nums.sort()\\n        nums1 = nums"
                    },
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1;\\n    int j = n - 1;\\n    int k = (m + n - 1);\\n\\n    while (i >= 0 && j >= 0)\\n    {\\n\\n        if (nums1[i] > nums2[j])\\n        {\\n            nums1[k--] = nums1[i--];\\n        }\\n\\n        else\\n        {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n\\n    while (i >= 0)\\n    {\\n\\n        nums1[k--] = nums1[i--];\\n    }\\n\\n    while (j >= 0)\\n    {\\n\\n        nums1[k--] = nums2[j--];\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1707677,
                "content": [
                    {
                        "username": "rohitgupta_8055",
                        "content": "MERGE SORTED ARRAY CODE IN C++ || WITH EXPLANATION\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\n        int p1 = m-1;      //size of first array\\n        int p2 = n-1;      // size of second array\\n        int i =n+m-1;      //size of first array having lenth is sum of two array\\n\\n        while(p2>=0){      //edge case if first array doesnot cannot any element \\n\\n            if(p1>=0 && nums1[p1]>nums2[p2]){   //if greaterthen second array element than copy to last index of first array \\n              nums1[i--]=nums1[p1--];\\n            }\\n            else{\\n                nums1[i--]=nums2[p2--];\\n            }\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int k = 0;\\n        int i =0,j= 0;\\n        while(i<m && j<n){\\n            if(nums1[i]<nums2[j]){\\n                nums1[k++] = nums1[i++];\\n            }\\n            else{\\n                nums1[k++] = nums2[j++];\\n            }\\n        }\\n\\n        while(i<m){\\n            nums1[k++] = nums1[i++]; \\n        }\\n\\n        while(j<n){\\n            nums1[k++] = nums2[j++];\\n        }\\n    }\\n};\\n\\n\\n\\ncan any tell what is wrong in this approach for case1."
                    },
                    {
                        "username": "HarmonyHusher",
                        "content": "var merge = function (nums1, m, nums2, n) {\\n  let arrNums1 = nums1.slice(0, m);\\n  let arrNums2 = nums2.slice(0, n);\\n  let commonArr = arrNums1.concat(arrNums2);\\n  return commonArr.sort((a, b) => a - b);\\n};\\n\\nin other consoles it works, here is not....."
                    },
                    {
                        "username": "vyneeeth",
                        "content": "(Python) Why does this not work?\n\nnums1 = nums1[:m] + nums2\nnums1.sort()\n\nnums1 is still in-place right?"
                    },
                    {
                        "username": "cagridascan",
                        "content": "Why this code does not run correctly in python?\n\nclass Solution(object):\n    def merge(self, A, m, B, n):\n        A = A[:m] + B[:n] # especially this line\n        A = sorted(A)\n\nthis code works fine on my computer but leetcode doesn't work either\n"
                    },
                    {
                        "username": "sumitwagh2498",
                        "content": "why can\\'t we simply add 2 arrays and sort them in pyhton ? \\nnum1 = num1 + num2\\nnum1.sort()\\n\\nit showing error "
                    },
                    {
                        "username": "Aman__Patel",
                        "content": "100% correct and easy\\n\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int newArr[] = new int[m+n];\\n\\n        int i = 0, j = 0, k = 0;\\n        while(i != m && j != n) {\\n            if(nums1[i] < nums2[j]) {\\n                newArr[k++] = nums1[i++];\\n            }\\n            else {\\n                newArr[k++] = nums2[j++];\\n            }\\n        }\\n\\n        while(i != m) {\\n            newArr[k++] = nums1[i++];\\n        }\\n\\n        while(j != n) {\\n            newArr[k++] = nums2[j++];\\n        }\\n\\n        for(k = 0; k < m+n; k++) {\\n            nums1[k] = newArr[k];\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "rohit8400",
                        "content": " `nums1 = sorted(nums1[:m]+nums2)`\\nwhy is this not getting accepted?\\nI ran this on jupyter and it works for those 3 test cases given but on leetcode it wont accept,\\ncan someone explain !!"
                    },
                    {
                        "username": "akashdwivedi563",
                        "content": "java sol : \\nint j = 0;\\n        for (int k = m; k < nums1.length; k++) {\\n            if (nums2.length != 0) {\\n                nums1[k] = nums2[j];\\n            }\\n            j++;\\n        }\\n\\n        Arrays.sort(nums1);"
                    },
                    {
                        "username": "max_max_mir",
                        "content": "How come the same submission beats 14% once and 65% the other time? Seems completely random"
                    }
                ]
            },
            {
                "id": 1707671,
                "content": [
                    {
                        "username": "rohitgupta_8055",
                        "content": "MERGE SORTED ARRAY CODE IN C++ || WITH EXPLANATION\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\n        int p1 = m-1;      //size of first array\\n        int p2 = n-1;      // size of second array\\n        int i =n+m-1;      //size of first array having lenth is sum of two array\\n\\n        while(p2>=0){      //edge case if first array doesnot cannot any element \\n\\n            if(p1>=0 && nums1[p1]>nums2[p2]){   //if greaterthen second array element than copy to last index of first array \\n              nums1[i--]=nums1[p1--];\\n            }\\n            else{\\n                nums1[i--]=nums2[p2--];\\n            }\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int k = 0;\\n        int i =0,j= 0;\\n        while(i<m && j<n){\\n            if(nums1[i]<nums2[j]){\\n                nums1[k++] = nums1[i++];\\n            }\\n            else{\\n                nums1[k++] = nums2[j++];\\n            }\\n        }\\n\\n        while(i<m){\\n            nums1[k++] = nums1[i++]; \\n        }\\n\\n        while(j<n){\\n            nums1[k++] = nums2[j++];\\n        }\\n    }\\n};\\n\\n\\n\\ncan any tell what is wrong in this approach for case1."
                    },
                    {
                        "username": "HarmonyHusher",
                        "content": "var merge = function (nums1, m, nums2, n) {\\n  let arrNums1 = nums1.slice(0, m);\\n  let arrNums2 = nums2.slice(0, n);\\n  let commonArr = arrNums1.concat(arrNums2);\\n  return commonArr.sort((a, b) => a - b);\\n};\\n\\nin other consoles it works, here is not....."
                    },
                    {
                        "username": "vyneeeth",
                        "content": "(Python) Why does this not work?\n\nnums1 = nums1[:m] + nums2\nnums1.sort()\n\nnums1 is still in-place right?"
                    },
                    {
                        "username": "cagridascan",
                        "content": "Why this code does not run correctly in python?\n\nclass Solution(object):\n    def merge(self, A, m, B, n):\n        A = A[:m] + B[:n] # especially this line\n        A = sorted(A)\n\nthis code works fine on my computer but leetcode doesn't work either\n"
                    },
                    {
                        "username": "sumitwagh2498",
                        "content": "why can\\'t we simply add 2 arrays and sort them in pyhton ? \\nnum1 = num1 + num2\\nnum1.sort()\\n\\nit showing error "
                    },
                    {
                        "username": "Aman__Patel",
                        "content": "100% correct and easy\\n\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int newArr[] = new int[m+n];\\n\\n        int i = 0, j = 0, k = 0;\\n        while(i != m && j != n) {\\n            if(nums1[i] < nums2[j]) {\\n                newArr[k++] = nums1[i++];\\n            }\\n            else {\\n                newArr[k++] = nums2[j++];\\n            }\\n        }\\n\\n        while(i != m) {\\n            newArr[k++] = nums1[i++];\\n        }\\n\\n        while(j != n) {\\n            newArr[k++] = nums2[j++];\\n        }\\n\\n        for(k = 0; k < m+n; k++) {\\n            nums1[k] = newArr[k];\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "rohit8400",
                        "content": " `nums1 = sorted(nums1[:m]+nums2)`\\nwhy is this not getting accepted?\\nI ran this on jupyter and it works for those 3 test cases given but on leetcode it wont accept,\\ncan someone explain !!"
                    },
                    {
                        "username": "akashdwivedi563",
                        "content": "java sol : \\nint j = 0;\\n        for (int k = m; k < nums1.length; k++) {\\n            if (nums2.length != 0) {\\n                nums1[k] = nums2[j];\\n            }\\n            j++;\\n        }\\n\\n        Arrays.sort(nums1);"
                    },
                    {
                        "username": "max_max_mir",
                        "content": "How come the same submission beats 14% once and 65% the other time? Seems completely random"
                    }
                ]
            },
            {
                "id": 1706762,
                "content": [
                    {
                        "username": "rohitgupta_8055",
                        "content": "MERGE SORTED ARRAY CODE IN C++ || WITH EXPLANATION\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\n        int p1 = m-1;      //size of first array\\n        int p2 = n-1;      // size of second array\\n        int i =n+m-1;      //size of first array having lenth is sum of two array\\n\\n        while(p2>=0){      //edge case if first array doesnot cannot any element \\n\\n            if(p1>=0 && nums1[p1]>nums2[p2]){   //if greaterthen second array element than copy to last index of first array \\n              nums1[i--]=nums1[p1--];\\n            }\\n            else{\\n                nums1[i--]=nums2[p2--];\\n            }\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int k = 0;\\n        int i =0,j= 0;\\n        while(i<m && j<n){\\n            if(nums1[i]<nums2[j]){\\n                nums1[k++] = nums1[i++];\\n            }\\n            else{\\n                nums1[k++] = nums2[j++];\\n            }\\n        }\\n\\n        while(i<m){\\n            nums1[k++] = nums1[i++]; \\n        }\\n\\n        while(j<n){\\n            nums1[k++] = nums2[j++];\\n        }\\n    }\\n};\\n\\n\\n\\ncan any tell what is wrong in this approach for case1."
                    },
                    {
                        "username": "HarmonyHusher",
                        "content": "var merge = function (nums1, m, nums2, n) {\\n  let arrNums1 = nums1.slice(0, m);\\n  let arrNums2 = nums2.slice(0, n);\\n  let commonArr = arrNums1.concat(arrNums2);\\n  return commonArr.sort((a, b) => a - b);\\n};\\n\\nin other consoles it works, here is not....."
                    },
                    {
                        "username": "vyneeeth",
                        "content": "(Python) Why does this not work?\n\nnums1 = nums1[:m] + nums2\nnums1.sort()\n\nnums1 is still in-place right?"
                    },
                    {
                        "username": "cagridascan",
                        "content": "Why this code does not run correctly in python?\n\nclass Solution(object):\n    def merge(self, A, m, B, n):\n        A = A[:m] + B[:n] # especially this line\n        A = sorted(A)\n\nthis code works fine on my computer but leetcode doesn't work either\n"
                    },
                    {
                        "username": "sumitwagh2498",
                        "content": "why can\\'t we simply add 2 arrays and sort them in pyhton ? \\nnum1 = num1 + num2\\nnum1.sort()\\n\\nit showing error "
                    },
                    {
                        "username": "Aman__Patel",
                        "content": "100% correct and easy\\n\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int newArr[] = new int[m+n];\\n\\n        int i = 0, j = 0, k = 0;\\n        while(i != m && j != n) {\\n            if(nums1[i] < nums2[j]) {\\n                newArr[k++] = nums1[i++];\\n            }\\n            else {\\n                newArr[k++] = nums2[j++];\\n            }\\n        }\\n\\n        while(i != m) {\\n            newArr[k++] = nums1[i++];\\n        }\\n\\n        while(j != n) {\\n            newArr[k++] = nums2[j++];\\n        }\\n\\n        for(k = 0; k < m+n; k++) {\\n            nums1[k] = newArr[k];\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "rohit8400",
                        "content": " `nums1 = sorted(nums1[:m]+nums2)`\\nwhy is this not getting accepted?\\nI ran this on jupyter and it works for those 3 test cases given but on leetcode it wont accept,\\ncan someone explain !!"
                    },
                    {
                        "username": "akashdwivedi563",
                        "content": "java sol : \\nint j = 0;\\n        for (int k = m; k < nums1.length; k++) {\\n            if (nums2.length != 0) {\\n                nums1[k] = nums2[j];\\n            }\\n            j++;\\n        }\\n\\n        Arrays.sort(nums1);"
                    },
                    {
                        "username": "max_max_mir",
                        "content": "How come the same submission beats 14% once and 65% the other time? Seems completely random"
                    }
                ]
            },
            {
                "id": 1705166,
                "content": [
                    {
                        "username": "rohitgupta_8055",
                        "content": "MERGE SORTED ARRAY CODE IN C++ || WITH EXPLANATION\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\n        int p1 = m-1;      //size of first array\\n        int p2 = n-1;      // size of second array\\n        int i =n+m-1;      //size of first array having lenth is sum of two array\\n\\n        while(p2>=0){      //edge case if first array doesnot cannot any element \\n\\n            if(p1>=0 && nums1[p1]>nums2[p2]){   //if greaterthen second array element than copy to last index of first array \\n              nums1[i--]=nums1[p1--];\\n            }\\n            else{\\n                nums1[i--]=nums2[p2--];\\n            }\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int k = 0;\\n        int i =0,j= 0;\\n        while(i<m && j<n){\\n            if(nums1[i]<nums2[j]){\\n                nums1[k++] = nums1[i++];\\n            }\\n            else{\\n                nums1[k++] = nums2[j++];\\n            }\\n        }\\n\\n        while(i<m){\\n            nums1[k++] = nums1[i++]; \\n        }\\n\\n        while(j<n){\\n            nums1[k++] = nums2[j++];\\n        }\\n    }\\n};\\n\\n\\n\\ncan any tell what is wrong in this approach for case1."
                    },
                    {
                        "username": "HarmonyHusher",
                        "content": "var merge = function (nums1, m, nums2, n) {\\n  let arrNums1 = nums1.slice(0, m);\\n  let arrNums2 = nums2.slice(0, n);\\n  let commonArr = arrNums1.concat(arrNums2);\\n  return commonArr.sort((a, b) => a - b);\\n};\\n\\nin other consoles it works, here is not....."
                    },
                    {
                        "username": "vyneeeth",
                        "content": "(Python) Why does this not work?\n\nnums1 = nums1[:m] + nums2\nnums1.sort()\n\nnums1 is still in-place right?"
                    },
                    {
                        "username": "cagridascan",
                        "content": "Why this code does not run correctly in python?\n\nclass Solution(object):\n    def merge(self, A, m, B, n):\n        A = A[:m] + B[:n] # especially this line\n        A = sorted(A)\n\nthis code works fine on my computer but leetcode doesn't work either\n"
                    },
                    {
                        "username": "sumitwagh2498",
                        "content": "why can\\'t we simply add 2 arrays and sort them in pyhton ? \\nnum1 = num1 + num2\\nnum1.sort()\\n\\nit showing error "
                    },
                    {
                        "username": "Aman__Patel",
                        "content": "100% correct and easy\\n\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int newArr[] = new int[m+n];\\n\\n        int i = 0, j = 0, k = 0;\\n        while(i != m && j != n) {\\n            if(nums1[i] < nums2[j]) {\\n                newArr[k++] = nums1[i++];\\n            }\\n            else {\\n                newArr[k++] = nums2[j++];\\n            }\\n        }\\n\\n        while(i != m) {\\n            newArr[k++] = nums1[i++];\\n        }\\n\\n        while(j != n) {\\n            newArr[k++] = nums2[j++];\\n        }\\n\\n        for(k = 0; k < m+n; k++) {\\n            nums1[k] = newArr[k];\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "rohit8400",
                        "content": " `nums1 = sorted(nums1[:m]+nums2)`\\nwhy is this not getting accepted?\\nI ran this on jupyter and it works for those 3 test cases given but on leetcode it wont accept,\\ncan someone explain !!"
                    },
                    {
                        "username": "akashdwivedi563",
                        "content": "java sol : \\nint j = 0;\\n        for (int k = m; k < nums1.length; k++) {\\n            if (nums2.length != 0) {\\n                nums1[k] = nums2[j];\\n            }\\n            j++;\\n        }\\n\\n        Arrays.sort(nums1);"
                    },
                    {
                        "username": "max_max_mir",
                        "content": "How come the same submission beats 14% once and 65% the other time? Seems completely random"
                    }
                ]
            },
            {
                "id": 1698094,
                "content": [
                    {
                        "username": "rohitgupta_8055",
                        "content": "MERGE SORTED ARRAY CODE IN C++ || WITH EXPLANATION\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\n        int p1 = m-1;      //size of first array\\n        int p2 = n-1;      // size of second array\\n        int i =n+m-1;      //size of first array having lenth is sum of two array\\n\\n        while(p2>=0){      //edge case if first array doesnot cannot any element \\n\\n            if(p1>=0 && nums1[p1]>nums2[p2]){   //if greaterthen second array element than copy to last index of first array \\n              nums1[i--]=nums1[p1--];\\n            }\\n            else{\\n                nums1[i--]=nums2[p2--];\\n            }\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int k = 0;\\n        int i =0,j= 0;\\n        while(i<m && j<n){\\n            if(nums1[i]<nums2[j]){\\n                nums1[k++] = nums1[i++];\\n            }\\n            else{\\n                nums1[k++] = nums2[j++];\\n            }\\n        }\\n\\n        while(i<m){\\n            nums1[k++] = nums1[i++]; \\n        }\\n\\n        while(j<n){\\n            nums1[k++] = nums2[j++];\\n        }\\n    }\\n};\\n\\n\\n\\ncan any tell what is wrong in this approach for case1."
                    },
                    {
                        "username": "HarmonyHusher",
                        "content": "var merge = function (nums1, m, nums2, n) {\\n  let arrNums1 = nums1.slice(0, m);\\n  let arrNums2 = nums2.slice(0, n);\\n  let commonArr = arrNums1.concat(arrNums2);\\n  return commonArr.sort((a, b) => a - b);\\n};\\n\\nin other consoles it works, here is not....."
                    },
                    {
                        "username": "vyneeeth",
                        "content": "(Python) Why does this not work?\n\nnums1 = nums1[:m] + nums2\nnums1.sort()\n\nnums1 is still in-place right?"
                    },
                    {
                        "username": "cagridascan",
                        "content": "Why this code does not run correctly in python?\n\nclass Solution(object):\n    def merge(self, A, m, B, n):\n        A = A[:m] + B[:n] # especially this line\n        A = sorted(A)\n\nthis code works fine on my computer but leetcode doesn't work either\n"
                    },
                    {
                        "username": "sumitwagh2498",
                        "content": "why can\\'t we simply add 2 arrays and sort them in pyhton ? \\nnum1 = num1 + num2\\nnum1.sort()\\n\\nit showing error "
                    },
                    {
                        "username": "Aman__Patel",
                        "content": "100% correct and easy\\n\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int newArr[] = new int[m+n];\\n\\n        int i = 0, j = 0, k = 0;\\n        while(i != m && j != n) {\\n            if(nums1[i] < nums2[j]) {\\n                newArr[k++] = nums1[i++];\\n            }\\n            else {\\n                newArr[k++] = nums2[j++];\\n            }\\n        }\\n\\n        while(i != m) {\\n            newArr[k++] = nums1[i++];\\n        }\\n\\n        while(j != n) {\\n            newArr[k++] = nums2[j++];\\n        }\\n\\n        for(k = 0; k < m+n; k++) {\\n            nums1[k] = newArr[k];\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "rohit8400",
                        "content": " `nums1 = sorted(nums1[:m]+nums2)`\\nwhy is this not getting accepted?\\nI ran this on jupyter and it works for those 3 test cases given but on leetcode it wont accept,\\ncan someone explain !!"
                    },
                    {
                        "username": "akashdwivedi563",
                        "content": "java sol : \\nint j = 0;\\n        for (int k = m; k < nums1.length; k++) {\\n            if (nums2.length != 0) {\\n                nums1[k] = nums2[j];\\n            }\\n            j++;\\n        }\\n\\n        Arrays.sort(nums1);"
                    },
                    {
                        "username": "max_max_mir",
                        "content": "How come the same submission beats 14% once and 65% the other time? Seems completely random"
                    }
                ]
            },
            {
                "id": 1697027,
                "content": [
                    {
                        "username": "rohitgupta_8055",
                        "content": "MERGE SORTED ARRAY CODE IN C++ || WITH EXPLANATION\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\n        int p1 = m-1;      //size of first array\\n        int p2 = n-1;      // size of second array\\n        int i =n+m-1;      //size of first array having lenth is sum of two array\\n\\n        while(p2>=0){      //edge case if first array doesnot cannot any element \\n\\n            if(p1>=0 && nums1[p1]>nums2[p2]){   //if greaterthen second array element than copy to last index of first array \\n              nums1[i--]=nums1[p1--];\\n            }\\n            else{\\n                nums1[i--]=nums2[p2--];\\n            }\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int k = 0;\\n        int i =0,j= 0;\\n        while(i<m && j<n){\\n            if(nums1[i]<nums2[j]){\\n                nums1[k++] = nums1[i++];\\n            }\\n            else{\\n                nums1[k++] = nums2[j++];\\n            }\\n        }\\n\\n        while(i<m){\\n            nums1[k++] = nums1[i++]; \\n        }\\n\\n        while(j<n){\\n            nums1[k++] = nums2[j++];\\n        }\\n    }\\n};\\n\\n\\n\\ncan any tell what is wrong in this approach for case1."
                    },
                    {
                        "username": "HarmonyHusher",
                        "content": "var merge = function (nums1, m, nums2, n) {\\n  let arrNums1 = nums1.slice(0, m);\\n  let arrNums2 = nums2.slice(0, n);\\n  let commonArr = arrNums1.concat(arrNums2);\\n  return commonArr.sort((a, b) => a - b);\\n};\\n\\nin other consoles it works, here is not....."
                    },
                    {
                        "username": "vyneeeth",
                        "content": "(Python) Why does this not work?\n\nnums1 = nums1[:m] + nums2\nnums1.sort()\n\nnums1 is still in-place right?"
                    },
                    {
                        "username": "cagridascan",
                        "content": "Why this code does not run correctly in python?\n\nclass Solution(object):\n    def merge(self, A, m, B, n):\n        A = A[:m] + B[:n] # especially this line\n        A = sorted(A)\n\nthis code works fine on my computer but leetcode doesn't work either\n"
                    },
                    {
                        "username": "sumitwagh2498",
                        "content": "why can\\'t we simply add 2 arrays and sort them in pyhton ? \\nnum1 = num1 + num2\\nnum1.sort()\\n\\nit showing error "
                    },
                    {
                        "username": "Aman__Patel",
                        "content": "100% correct and easy\\n\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int newArr[] = new int[m+n];\\n\\n        int i = 0, j = 0, k = 0;\\n        while(i != m && j != n) {\\n            if(nums1[i] < nums2[j]) {\\n                newArr[k++] = nums1[i++];\\n            }\\n            else {\\n                newArr[k++] = nums2[j++];\\n            }\\n        }\\n\\n        while(i != m) {\\n            newArr[k++] = nums1[i++];\\n        }\\n\\n        while(j != n) {\\n            newArr[k++] = nums2[j++];\\n        }\\n\\n        for(k = 0; k < m+n; k++) {\\n            nums1[k] = newArr[k];\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "rohit8400",
                        "content": " `nums1 = sorted(nums1[:m]+nums2)`\\nwhy is this not getting accepted?\\nI ran this on jupyter and it works for those 3 test cases given but on leetcode it wont accept,\\ncan someone explain !!"
                    },
                    {
                        "username": "akashdwivedi563",
                        "content": "java sol : \\nint j = 0;\\n        for (int k = m; k < nums1.length; k++) {\\n            if (nums2.length != 0) {\\n                nums1[k] = nums2[j];\\n            }\\n            j++;\\n        }\\n\\n        Arrays.sort(nums1);"
                    },
                    {
                        "username": "max_max_mir",
                        "content": "How come the same submission beats 14% once and 65% the other time? Seems completely random"
                    }
                ]
            },
            {
                "id": 1693202,
                "content": [
                    {
                        "username": "rohitgupta_8055",
                        "content": "MERGE SORTED ARRAY CODE IN C++ || WITH EXPLANATION\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\n        int p1 = m-1;      //size of first array\\n        int p2 = n-1;      // size of second array\\n        int i =n+m-1;      //size of first array having lenth is sum of two array\\n\\n        while(p2>=0){      //edge case if first array doesnot cannot any element \\n\\n            if(p1>=0 && nums1[p1]>nums2[p2]){   //if greaterthen second array element than copy to last index of first array \\n              nums1[i--]=nums1[p1--];\\n            }\\n            else{\\n                nums1[i--]=nums2[p2--];\\n            }\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int k = 0;\\n        int i =0,j= 0;\\n        while(i<m && j<n){\\n            if(nums1[i]<nums2[j]){\\n                nums1[k++] = nums1[i++];\\n            }\\n            else{\\n                nums1[k++] = nums2[j++];\\n            }\\n        }\\n\\n        while(i<m){\\n            nums1[k++] = nums1[i++]; \\n        }\\n\\n        while(j<n){\\n            nums1[k++] = nums2[j++];\\n        }\\n    }\\n};\\n\\n\\n\\ncan any tell what is wrong in this approach for case1."
                    },
                    {
                        "username": "HarmonyHusher",
                        "content": "var merge = function (nums1, m, nums2, n) {\\n  let arrNums1 = nums1.slice(0, m);\\n  let arrNums2 = nums2.slice(0, n);\\n  let commonArr = arrNums1.concat(arrNums2);\\n  return commonArr.sort((a, b) => a - b);\\n};\\n\\nin other consoles it works, here is not....."
                    },
                    {
                        "username": "vyneeeth",
                        "content": "(Python) Why does this not work?\n\nnums1 = nums1[:m] + nums2\nnums1.sort()\n\nnums1 is still in-place right?"
                    },
                    {
                        "username": "cagridascan",
                        "content": "Why this code does not run correctly in python?\n\nclass Solution(object):\n    def merge(self, A, m, B, n):\n        A = A[:m] + B[:n] # especially this line\n        A = sorted(A)\n\nthis code works fine on my computer but leetcode doesn't work either\n"
                    },
                    {
                        "username": "sumitwagh2498",
                        "content": "why can\\'t we simply add 2 arrays and sort them in pyhton ? \\nnum1 = num1 + num2\\nnum1.sort()\\n\\nit showing error "
                    },
                    {
                        "username": "Aman__Patel",
                        "content": "100% correct and easy\\n\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int newArr[] = new int[m+n];\\n\\n        int i = 0, j = 0, k = 0;\\n        while(i != m && j != n) {\\n            if(nums1[i] < nums2[j]) {\\n                newArr[k++] = nums1[i++];\\n            }\\n            else {\\n                newArr[k++] = nums2[j++];\\n            }\\n        }\\n\\n        while(i != m) {\\n            newArr[k++] = nums1[i++];\\n        }\\n\\n        while(j != n) {\\n            newArr[k++] = nums2[j++];\\n        }\\n\\n        for(k = 0; k < m+n; k++) {\\n            nums1[k] = newArr[k];\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "rohit8400",
                        "content": " `nums1 = sorted(nums1[:m]+nums2)`\\nwhy is this not getting accepted?\\nI ran this on jupyter and it works for those 3 test cases given but on leetcode it wont accept,\\ncan someone explain !!"
                    },
                    {
                        "username": "akashdwivedi563",
                        "content": "java sol : \\nint j = 0;\\n        for (int k = m; k < nums1.length; k++) {\\n            if (nums2.length != 0) {\\n                nums1[k] = nums2[j];\\n            }\\n            j++;\\n        }\\n\\n        Arrays.sort(nums1);"
                    },
                    {
                        "username": "max_max_mir",
                        "content": "How come the same submission beats 14% once and 65% the other time? Seems completely random"
                    }
                ]
            },
            {
                "id": 1692089,
                "content": [
                    {
                        "username": "rohitgupta_8055",
                        "content": "MERGE SORTED ARRAY CODE IN C++ || WITH EXPLANATION\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\n        int p1 = m-1;      //size of first array\\n        int p2 = n-1;      // size of second array\\n        int i =n+m-1;      //size of first array having lenth is sum of two array\\n\\n        while(p2>=0){      //edge case if first array doesnot cannot any element \\n\\n            if(p1>=0 && nums1[p1]>nums2[p2]){   //if greaterthen second array element than copy to last index of first array \\n              nums1[i--]=nums1[p1--];\\n            }\\n            else{\\n                nums1[i--]=nums2[p2--];\\n            }\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int k = 0;\\n        int i =0,j= 0;\\n        while(i<m && j<n){\\n            if(nums1[i]<nums2[j]){\\n                nums1[k++] = nums1[i++];\\n            }\\n            else{\\n                nums1[k++] = nums2[j++];\\n            }\\n        }\\n\\n        while(i<m){\\n            nums1[k++] = nums1[i++]; \\n        }\\n\\n        while(j<n){\\n            nums1[k++] = nums2[j++];\\n        }\\n    }\\n};\\n\\n\\n\\ncan any tell what is wrong in this approach for case1."
                    },
                    {
                        "username": "HarmonyHusher",
                        "content": "var merge = function (nums1, m, nums2, n) {\\n  let arrNums1 = nums1.slice(0, m);\\n  let arrNums2 = nums2.slice(0, n);\\n  let commonArr = arrNums1.concat(arrNums2);\\n  return commonArr.sort((a, b) => a - b);\\n};\\n\\nin other consoles it works, here is not....."
                    },
                    {
                        "username": "vyneeeth",
                        "content": "(Python) Why does this not work?\n\nnums1 = nums1[:m] + nums2\nnums1.sort()\n\nnums1 is still in-place right?"
                    },
                    {
                        "username": "cagridascan",
                        "content": "Why this code does not run correctly in python?\n\nclass Solution(object):\n    def merge(self, A, m, B, n):\n        A = A[:m] + B[:n] # especially this line\n        A = sorted(A)\n\nthis code works fine on my computer but leetcode doesn't work either\n"
                    },
                    {
                        "username": "sumitwagh2498",
                        "content": "why can\\'t we simply add 2 arrays and sort them in pyhton ? \\nnum1 = num1 + num2\\nnum1.sort()\\n\\nit showing error "
                    },
                    {
                        "username": "Aman__Patel",
                        "content": "100% correct and easy\\n\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int newArr[] = new int[m+n];\\n\\n        int i = 0, j = 0, k = 0;\\n        while(i != m && j != n) {\\n            if(nums1[i] < nums2[j]) {\\n                newArr[k++] = nums1[i++];\\n            }\\n            else {\\n                newArr[k++] = nums2[j++];\\n            }\\n        }\\n\\n        while(i != m) {\\n            newArr[k++] = nums1[i++];\\n        }\\n\\n        while(j != n) {\\n            newArr[k++] = nums2[j++];\\n        }\\n\\n        for(k = 0; k < m+n; k++) {\\n            nums1[k] = newArr[k];\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "rohit8400",
                        "content": " `nums1 = sorted(nums1[:m]+nums2)`\\nwhy is this not getting accepted?\\nI ran this on jupyter and it works for those 3 test cases given but on leetcode it wont accept,\\ncan someone explain !!"
                    },
                    {
                        "username": "akashdwivedi563",
                        "content": "java sol : \\nint j = 0;\\n        for (int k = m; k < nums1.length; k++) {\\n            if (nums2.length != 0) {\\n                nums1[k] = nums2[j];\\n            }\\n            j++;\\n        }\\n\\n        Arrays.sort(nums1);"
                    },
                    {
                        "username": "max_max_mir",
                        "content": "How come the same submission beats 14% once and 65% the other time? Seems completely random"
                    }
                ]
            },
            {
                "id": 1687513,
                "content": [
                    {
                        "username": "rohitgupta_8055",
                        "content": "MERGE SORTED ARRAY CODE IN C++ || WITH EXPLANATION\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\n        int p1 = m-1;      //size of first array\\n        int p2 = n-1;      // size of second array\\n        int i =n+m-1;      //size of first array having lenth is sum of two array\\n\\n        while(p2>=0){      //edge case if first array doesnot cannot any element \\n\\n            if(p1>=0 && nums1[p1]>nums2[p2]){   //if greaterthen second array element than copy to last index of first array \\n              nums1[i--]=nums1[p1--];\\n            }\\n            else{\\n                nums1[i--]=nums2[p2--];\\n            }\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int k = 0;\\n        int i =0,j= 0;\\n        while(i<m && j<n){\\n            if(nums1[i]<nums2[j]){\\n                nums1[k++] = nums1[i++];\\n            }\\n            else{\\n                nums1[k++] = nums2[j++];\\n            }\\n        }\\n\\n        while(i<m){\\n            nums1[k++] = nums1[i++]; \\n        }\\n\\n        while(j<n){\\n            nums1[k++] = nums2[j++];\\n        }\\n    }\\n};\\n\\n\\n\\ncan any tell what is wrong in this approach for case1."
                    },
                    {
                        "username": "HarmonyHusher",
                        "content": "var merge = function (nums1, m, nums2, n) {\\n  let arrNums1 = nums1.slice(0, m);\\n  let arrNums2 = nums2.slice(0, n);\\n  let commonArr = arrNums1.concat(arrNums2);\\n  return commonArr.sort((a, b) => a - b);\\n};\\n\\nin other consoles it works, here is not....."
                    },
                    {
                        "username": "vyneeeth",
                        "content": "(Python) Why does this not work?\n\nnums1 = nums1[:m] + nums2\nnums1.sort()\n\nnums1 is still in-place right?"
                    },
                    {
                        "username": "cagridascan",
                        "content": "Why this code does not run correctly in python?\n\nclass Solution(object):\n    def merge(self, A, m, B, n):\n        A = A[:m] + B[:n] # especially this line\n        A = sorted(A)\n\nthis code works fine on my computer but leetcode doesn't work either\n"
                    },
                    {
                        "username": "sumitwagh2498",
                        "content": "why can\\'t we simply add 2 arrays and sort them in pyhton ? \\nnum1 = num1 + num2\\nnum1.sort()\\n\\nit showing error "
                    },
                    {
                        "username": "Aman__Patel",
                        "content": "100% correct and easy\\n\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int newArr[] = new int[m+n];\\n\\n        int i = 0, j = 0, k = 0;\\n        while(i != m && j != n) {\\n            if(nums1[i] < nums2[j]) {\\n                newArr[k++] = nums1[i++];\\n            }\\n            else {\\n                newArr[k++] = nums2[j++];\\n            }\\n        }\\n\\n        while(i != m) {\\n            newArr[k++] = nums1[i++];\\n        }\\n\\n        while(j != n) {\\n            newArr[k++] = nums2[j++];\\n        }\\n\\n        for(k = 0; k < m+n; k++) {\\n            nums1[k] = newArr[k];\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "rohit8400",
                        "content": " `nums1 = sorted(nums1[:m]+nums2)`\\nwhy is this not getting accepted?\\nI ran this on jupyter and it works for those 3 test cases given but on leetcode it wont accept,\\ncan someone explain !!"
                    },
                    {
                        "username": "akashdwivedi563",
                        "content": "java sol : \\nint j = 0;\\n        for (int k = m; k < nums1.length; k++) {\\n            if (nums2.length != 0) {\\n                nums1[k] = nums2[j];\\n            }\\n            j++;\\n        }\\n\\n        Arrays.sort(nums1);"
                    },
                    {
                        "username": "max_max_mir",
                        "content": "How come the same submission beats 14% once and 65% the other time? Seems completely random"
                    }
                ]
            },
            {
                "id": 1686920,
                "content": [
                    {
                        "username": "rohitgupta_8055",
                        "content": "MERGE SORTED ARRAY CODE IN C++ || WITH EXPLANATION\\n\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n\\n        int p1 = m-1;      //size of first array\\n        int p2 = n-1;      // size of second array\\n        int i =n+m-1;      //size of first array having lenth is sum of two array\\n\\n        while(p2>=0){      //edge case if first array doesnot cannot any element \\n\\n            if(p1>=0 && nums1[p1]>nums2[p2]){   //if greaterthen second array element than copy to last index of first array \\n              nums1[i--]=nums1[p1--];\\n            }\\n            else{\\n                nums1[i--]=nums2[p2--];\\n            }\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int k = 0;\\n        int i =0,j= 0;\\n        while(i<m && j<n){\\n            if(nums1[i]<nums2[j]){\\n                nums1[k++] = nums1[i++];\\n            }\\n            else{\\n                nums1[k++] = nums2[j++];\\n            }\\n        }\\n\\n        while(i<m){\\n            nums1[k++] = nums1[i++]; \\n        }\\n\\n        while(j<n){\\n            nums1[k++] = nums2[j++];\\n        }\\n    }\\n};\\n\\n\\n\\ncan any tell what is wrong in this approach for case1."
                    },
                    {
                        "username": "HarmonyHusher",
                        "content": "var merge = function (nums1, m, nums2, n) {\\n  let arrNums1 = nums1.slice(0, m);\\n  let arrNums2 = nums2.slice(0, n);\\n  let commonArr = arrNums1.concat(arrNums2);\\n  return commonArr.sort((a, b) => a - b);\\n};\\n\\nin other consoles it works, here is not....."
                    },
                    {
                        "username": "vyneeeth",
                        "content": "(Python) Why does this not work?\n\nnums1 = nums1[:m] + nums2\nnums1.sort()\n\nnums1 is still in-place right?"
                    },
                    {
                        "username": "cagridascan",
                        "content": "Why this code does not run correctly in python?\n\nclass Solution(object):\n    def merge(self, A, m, B, n):\n        A = A[:m] + B[:n] # especially this line\n        A = sorted(A)\n\nthis code works fine on my computer but leetcode doesn't work either\n"
                    },
                    {
                        "username": "sumitwagh2498",
                        "content": "why can\\'t we simply add 2 arrays and sort them in pyhton ? \\nnum1 = num1 + num2\\nnum1.sort()\\n\\nit showing error "
                    },
                    {
                        "username": "Aman__Patel",
                        "content": "100% correct and easy\\n\\n\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int newArr[] = new int[m+n];\\n\\n        int i = 0, j = 0, k = 0;\\n        while(i != m && j != n) {\\n            if(nums1[i] < nums2[j]) {\\n                newArr[k++] = nums1[i++];\\n            }\\n            else {\\n                newArr[k++] = nums2[j++];\\n            }\\n        }\\n\\n        while(i != m) {\\n            newArr[k++] = nums1[i++];\\n        }\\n\\n        while(j != n) {\\n            newArr[k++] = nums2[j++];\\n        }\\n\\n        for(k = 0; k < m+n; k++) {\\n            nums1[k] = newArr[k];\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "rohit8400",
                        "content": " `nums1 = sorted(nums1[:m]+nums2)`\\nwhy is this not getting accepted?\\nI ran this on jupyter and it works for those 3 test cases given but on leetcode it wont accept,\\ncan someone explain !!"
                    },
                    {
                        "username": "akashdwivedi563",
                        "content": "java sol : \\nint j = 0;\\n        for (int k = m; k < nums1.length; k++) {\\n            if (nums2.length != 0) {\\n                nums1[k] = nums2[j];\\n            }\\n            j++;\\n        }\\n\\n        Arrays.sort(nums1);"
                    },
                    {
                        "username": "max_max_mir",
                        "content": "How come the same submission beats 14% once and 65% the other time? Seems completely random"
                    }
                ]
            }
        ]
    },
    {
        "title": "Best Time to Buy and Sell Stock IV",
        "question_content": "<p>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day, and an integer <code>k</code>.</p>\n\n<p>Find the maximum profit you can achieve. You may complete at most <code>k</code> transactions: i.e. you may buy at most <code>k</code> times and sell at most <code>k</code> times.</p>\n\n<p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 2, prices = [2,4,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 2, prices = [3,2,6,5,0,3]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 100</code></li>\n\t<li><code>1 &lt;= prices.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 54113,
                "title": "a-concise-dp-solution-in-java",
                "content": "The general idea is DP, while I had to add a \"quickSolve\" function to tackle some corner cases to avoid TLE.\\n\\nDP: t(i,j) is the max profit for up to i transactions by time j (0<=i<=K, 0<=j<=T).\\n\\n        public int maxProfit(int k, int[] prices) {\\n            int len = prices.length;\\n            if (k >= len / 2) return quickSolve(prices);\\n            \\n            int[][] t = new int[k + 1][len];\\n            for (int i = 1; i <= k; i++) {\\n                int tmpMax =  -prices[0];\\n                for (int j = 1; j < len; j++) {\\n                    t[i][j] = Math.max(t[i][j - 1], prices[j] + tmpMax);\\n                    tmpMax =  Math.max(tmpMax, t[i - 1][j - 1] - prices[j]);\\n                }\\n            }\\n            return t[k][len - 1];\\n        }\\n        \\n\\n        private int quickSolve(int[] prices) {\\n            int len = prices.length, profit = 0;\\n            for (int i = 1; i < len; i++)\\n                // as long as there is a price gap, we gain a profit.\\n                if (prices[i] > prices[i - 1]) profit += prices[i] - prices[i - 1];\\n            return profit;\\n        }",
                "solutionTags": [],
                "code": "The general idea is DP, while I had to add a \"quickSolve\" function to tackle some corner cases to avoid TLE.\\n\\nDP: t(i,j) is the max profit for up to i transactions by time j (0<=i<=K, 0<=j<=T).\\n\\n        public int maxProfit(int k, int[] prices) {\\n            int len = prices.length;\\n            if (k >= len / 2) return quickSolve(prices);\\n            \\n            int[][] t = new int[k + 1][len];\\n            for (int i = 1; i <= k; i++) {\\n                int tmpMax =  -prices[0];\\n                for (int j = 1; j < len; j++) {\\n                    t[i][j] = Math.max(t[i][j - 1], prices[j] + tmpMax);\\n                    tmpMax =  Math.max(tmpMax, t[i - 1][j - 1] - prices[j]);\\n                }\\n            }\\n            return t[k][len - 1];\\n        }\\n        \\n\\n        private int quickSolve(int[] prices) {\\n            int len = prices.length, profit = 0;\\n            for (int i = 1; i < len; i++)\\n                // as long as there is a price gap, we gain a profit.\\n                if (prices[i] > prices[i - 1]) profit += prices[i] - prices[i - 1];\\n            return profit;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 54117,
                "title": "clean-java-dp-solution-with-comment",
                "content": "    /**\\n\\t * dp[i, j] represents the max profit up until prices[j] using at most i transactions. \\n     * dp[i, j] = max(dp[i, j-1], prices[j] - prices[jj] + dp[i-1, jj]) { jj in range of [0, j-1] }\\n     *          = max(dp[i, j-1], prices[j] + max(dp[i-1, jj] - prices[jj]))\\n     * dp[0, j] = 0; 0 transactions makes 0 profit\\n     * dp[i, 0] = 0; if there is only one price data point you can't make any transaction.\\n\\t */\\n\\n    public int maxProfit(int k, int[] prices) {\\n    \\tint n = prices.length;\\n    \\tif (n <= 1)\\n    \\t\\treturn 0;\\n    \\t\\n    \\t//if k >= n/2, then you can make maximum number of transactions.\\n    \\tif (k >=  n/2) {\\n    \\t\\tint maxPro = 0;\\n    \\t\\tfor (int i = 1; i < n; i++) {\\n    \\t\\t\\tif (prices[i] > prices[i-1])\\n    \\t\\t\\t\\tmaxPro += prices[i] - prices[i-1];\\n    \\t\\t}\\n    \\t\\treturn maxPro;\\n    \\t}\\n    \\t\\n        int[][] dp = new int[k+1][n];\\n        for (int i = 1; i <= k; i++) {\\n        \\tint localMax = dp[i-1][0] - prices[0];\\n        \\tfor (int j = 1; j < n; j++) {\\n        \\t\\tdp[i][j] = Math.max(dp[i][j-1],  prices[j] + localMax);\\n        \\t\\tlocalMax = Math.max(localMax, dp[i-1][j] - prices[j]);\\n        \\t}\\n        }\\n        return dp[k][n-1];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    /**\\n\\t * dp[i, j] represents the max profit up until prices[j] using at most i transactions. \\n     * dp[i, j] = max(dp[i, j-1], prices[j] - prices[jj] + dp[i-1, jj]) { jj in range of [0, j-1] }\\n     *          = max(dp[i, j-1], prices[j] + max(dp[i-1, jj] - prices[jj]))\\n     * dp[0, j] = 0; 0 transactions makes 0 profit\\n     * dp[i, 0] = 0; if there is only one price data point you can't make any transaction.\\n\\t */\\n\\n    public int maxProfit(int k, int[] prices) {\\n    \\tint n = prices.length;\\n    \\tif (n <= 1)\\n    \\t\\treturn 0;\\n    \\t\\n    \\t//if k >= n/2, then you can make maximum number of transactions.\\n    \\tif (k >=  n/2) {\\n    \\t\\tint maxPro = 0;\\n    \\t\\tfor (int i = 1; i < n; i++) {\\n    \\t\\t\\tif (prices[i] > prices[i-1])\\n    \\t\\t\\t\\tmaxPro += prices[i] - prices[i-1];\\n    \\t\\t}\\n    \\t\\treturn maxPro;\\n    \\t}\\n    \\t\\n        int[][] dp = new int[k+1][n];\\n        for (int i = 1; i <= k; i++) {\\n        \\tint localMax = dp[i-1][0] - prices[0];\\n        \\tfor (int j = 1; j < n; j++) {\\n        \\t\\tdp[i][j] = Math.max(dp[i][j-1],  prices[j] + localMax);\\n        \\t\\tlocalMax = Math.max(localMax, dp[i-1][j] - prices[j]);\\n        \\t}\\n        }\\n        return dp[k][n-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54118,
                "title": "c-solution-with-o-n-klgn-time-using-max-heap-and-stack",
                "content": "We can find all adjacent valley/peak pairs and calculate the profits easily. Instead of accumulating all these profits like Buy&Sell Stock II, we need the highest k ones.\\n\\nThe key point is when there are two v/p pairs (v1, p1) and (v2, p2), satisfying v1 <= v2 and p1 <= p2, we can either make one transaction at [v1, p2], or make two at both [v1, p1] and [v2, p2]. The trick is to treat [v1, p2] as the first transaction, and [v2, p1] as the second. Then we can guarantee the right max profits in both situations, **p2 - v1** for one transaction and **p1 - v1 + p2 - v2** for two.\\n\\nFinding all v/p pairs and calculating the profits takes O(n) since there are up to n/2 such pairs. And extracting k maximums from the heap consumes another O(klgn).\\n\\n\\n    class Solution {\\n    public:\\n        int maxProfit(int k, vector<int> &prices) {\\n            int n = (int)prices.size(), ret = 0, v, p = 0;\\n            priority_queue<int> profits;\\n            stack<pair<int, int> > vp_pairs;\\n            while (p < n) {\\n                // find next valley/peak pair\\n                for (v = p; v < n - 1 && prices[v] >= prices[v+1]; v++);\\n                for (p = v + 1; p < n && prices[p] >= prices[p-1]; p++);\\n                // save profit of 1 transaction at last v/p pair, if current v is lower than last v\\n                while (!vp_pairs.empty() && prices[v] < prices[vp_pairs.top().first]) {\\n                    profits.push(prices[vp_pairs.top().second-1] - prices[vp_pairs.top().first]);\\n                    vp_pairs.pop();\\n                }\\n                // save profit difference between 1 transaction (last v and current p) and 2 transactions (last v/p + current v/p),\\n                // if current v is higher than last v and current p is higher than last p\\n                while (!vp_pairs.empty() && prices[p-1] >= prices[vp_pairs.top().second-1]) {\\n                    profits.push(prices[vp_pairs.top().second-1] - prices[v]);\\n                    v = vp_pairs.top().first;\\n                    vp_pairs.pop();\\n                }\\n                vp_pairs.push(pair<int, int>(v, p));\\n            }\\n            // save profits of the rest v/p pairs\\n            while (!vp_pairs.empty()) {\\n                profits.push(prices[vp_pairs.top().second-1] - prices[vp_pairs.top().first]);\\n                vp_pairs.pop();\\n            }\\n            // sum up first k highest profits\\n            for (int i = 0; i < k && !profits.empty(); i++) {\\n                ret += profits.top();\\n                profits.pop();\\n            }\\n            return ret;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxProfit(int k, vector<int> &prices) {\\n            int n = (int)prices.size(), ret = 0, v, p = 0;\\n            priority_queue<int> profits;\\n            stack<pair<int, int> > vp_pairs;\\n            while (p < n) {\\n                // find next valley/peak pair\\n                for (v = p; v < n - 1 && prices[v] >= prices[v+1]; v++);\\n                for (p = v + 1; p < n && prices[p] >= prices[p-1]; p++);\\n                // save profit of 1 transaction at last v/p pair, if current v is lower than last v\\n                while (!vp_pairs.empty() && prices[v] < prices[vp_pairs.top().first]) {\\n                    profits.push(prices[vp_pairs.top().second-1] - prices[vp_pairs.top().first]);\\n                    vp_pairs.pop();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 54125,
                "title": "very-understandable-solution-by-reusing-problem-iii-idea",
                "content": "Re: [A Concise DP Solution in Java](/topic/8984/a-concise-dp-solution-in-java)\\n\\nIn Problem III (At most two transaction), I try to understand and solve this problem from state machine perspective inspired by this amazing post: https://discuss.leetcode.com/topic/30680/share-my-dp-solution-by-state-machine-thinking\\n\\nThen we conclude that we can use constant variable to represent 4 states and get a very concise solution as followed.\\n\\n```java\\n    public int maxProfit(int[] prices) {\\n        int buy1 = Integer.MIN_VALUE, sell1 = 0, buy2 = Integer.MIN_VALUE, sell2 = 0;\\n        for (int price : prices) {\\n            buy1 = Math.max(buy1, -price);\\n            sell1 = Math.max(sell1, buy1 + price);\\n            buy2 = Math.max(buy2, sell1 - price);\\n            sell2 = Math.max(sell2, buy2 + price);\\n        }\\n        return sell2;\\n    }\\n```\\n\\nNow for Problem IV, we can make at most K transaction rather than only two. Why not reuse the idea above? The only edge case is the first buy which has no previous sell. So here we create two int[k + 1] array to use sell[0] as a buffer region. Here is the solution.\\n\\n```java\\n    public int maxProfit(int k, int[] prices) {        \\n        int[] buy = new int[k + 1], sell = new int[k + 1];\\n        Arrays.fill(buy, Integer.MIN_VALUE);\\n        for (int price : prices) {\\n            for (int i = 1; i <= k; i++) {\\n                buy[i] = Math.max(buy[i], sell[i - 1] - price);\\n                sell[i] = Math.max(sell[i], buy[i] + price);\\n            }\\n        }\\n        return sell[k];\\n    }\\n```\\n\\nYes, that's all. While this will TLE for large test case, so it's necessary to add a special case handling to pass that. But don't be confused, the basic idea is only the piece of data above indeed.\\n\\n```java\\n        if (k >= prices.length / 2) { // if k >= n/2, then you can make maximum number of transactions\\n            int profit = 0;\\n            for (int i = 1; i < prices.length; i++)\\n                if (prices[i] > prices[i - 1]) profit += prices[i] - prices[i - 1];\\n            return profit;\\n        }\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int maxProfit(int[] prices) {\\n        int buy1 = Integer.MIN_VALUE, sell1 = 0, buy2 = Integer.MIN_VALUE, sell2 = 0;\\n        for (int price : prices) {\\n            buy1 = Math.max(buy1, -price);\\n            sell1 = Math.max(sell1, buy1 + price);\\n            buy2 = Math.max(buy2, sell1 - price);\\n            sell2 = Math.max(sell2, buy2 + price);\\n        }\\n        return sell2;\\n    }\\n```\n```java\\n    public int maxProfit(int k, int[] prices) {        \\n        int[] buy = new int[k + 1], sell = new int[k + 1];\\n        Arrays.fill(buy, Integer.MIN_VALUE);\\n        for (int price : prices) {\\n            for (int i = 1; i <= k; i++) {\\n                buy[i] = Math.max(buy[i], sell[i - 1] - price);\\n                sell[i] = Math.max(sell[i], buy[i] + price);\\n            }\\n        }\\n        return sell[k];\\n    }\\n```\n```java\\n        if (k >= prices.length / 2) { // if k >= n/2, then you can make maximum number of transactions\\n            int profit = 0;\\n            for (int i = 1; i < prices.length; i++)\\n                if (prices[i] > prices[i - 1]) profit += prices[i] - prices[i - 1];\\n            return profit;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2997000,
                "title": "solution",
                "content": "```C++ []\\n#include <stack>\\n#include <vector>\\n#include <utility>\\n#include <algorithm>\\n#include <numeric>\\nusing std::stack;\\nusing std::pair;\\nusing std::vector;\\nusing std::nth_element;\\nusing std::accumulate;\\n\\nclass Solution {\\n\\npublic:\\n    int maxProfit(int k, const vector<int>& prices) {\\n        vector<int> profits;\\n        stack<pair<int, int>> vps;\\n        int v = 0;\\n        int p = -1;\\n        \\n        const int n = prices.size();\\n        for (;;) {\\n            for (v = p + 1; (v + 1) < n && prices[v] >= prices[v + 1]; ++v);\\n            for (p = v; (p + 1) < n && prices[p] <= prices[p + 1]; ++p);\\n            if (p == v) break;\\n            \\n            while (!vps.empty() && prices[vps.top().first] >= prices[v]) {\\n                auto vp = vps.top();\\n                profits.push_back(prices[vp.second] - prices[vp.first]);\\n                vps.pop();\\n            }\\n            while (!vps.empty() && prices[vps.top().second] <= prices[p]) {\\n                profits.push_back(prices[vps.top().second] - prices[v]);\\n                v = vps.top().first; //  (v1, p2)\\n                vps.pop();\\n            }\\n            vps.emplace(v, p);\\n        }\\n        while (!vps.empty()) {\\n            auto vp = vps.top(); vps.pop();\\n            profits.push_back(prices[vp.second] - prices[vp.first]);\\n        }\\n        if (k >= profits.size()) {\\n            return accumulate(profits.begin(), profits.end(), 0);\\n        } else {\\n            nth_element(profits.begin(), profits.end() - k, profits.end());\\n            return accumulate(profits.end() - k, profits.end(), 0);\\n        }\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass DoubleLinkListNode:\\n    def __init__(self, ind, pre = None, next = None):\\n        self.ind = ind\\n        self.pre = pre if pre else self\\n        self.next = next if next else self\\n\\nclass Solution:\\n    def MinMaxList(self, arr: List[int]) -> List[int]:\\n        n = len(arr)\\n        if n == 0:\\n            return []\\n        sign = -1\\n        res = [9999]\\n        for num in arr:\\n            if num * sign > res[-1] * sign:\\n                res[-1] = num\\n            else:\\n                res.append(num)\\n                sign *= -1\\n        if len(res) & 1:\\n            res.pop()\\n        return res\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        newP = self.MinMaxList(prices)\\n        n = len(newP)\\n        m = n // 2\\n        res = 0\\n        for i in range(m):\\n            res += newP[i*2+1] - newP[i*2]\\n        if m <= k:\\n            return res\\n        head, tail = DoubleLinkListNode(-1), DoubleLinkListNode(-1)\\n        NodeList = [DoubleLinkListNode(0, head)]\\n        for i in range(1, n):\\n            NodeList.append(DoubleLinkListNode(i, NodeList[-1]))\\n            NodeList[i-1].next = NodeList[i]\\n        NodeList[n-1].next = tail\\n        head.next, tail.pre = NodeList[0], NodeList[n-1]\\n        heap = []\\n        for i in range(n-1):\\n            if i&1:\\n                heappush(heap, [newP[i] - newP[i+1], i, i+1, 0])\\n            else:\\n                heappush(heap, [newP[i+1] - newP[i], i, i+1, 1])\\n        while m > k:\\n            loss, i, j, t = heappop(heap)\\n            if NodeList[i] == None or NodeList[j] == None: continue\\n            m -= 1\\n            res -= loss\\n            nodei, nodej = NodeList[i], NodeList[j]\\n            nodel, noder = nodei.pre, nodej.next\\n            l, r = nodel.ind, noder.ind\\n            valL, valR = newP[l], newP[r]\\n            noder.pre, nodel.next = nodel, noder\\n            NodeList[i], NodeList[j] = None, None\\n            if t == 0:\\n                heappush(heap, [valR - valL, l, r, 1])\\n            elif l != -1 and r != -1:\\n                heappush(heap, [valL - valR, l, r, 0])\\n        return res\\n```\\n\\n```Java []\\nclass Solution {\\n    static int solveTab(int[] prices,int k){\\n        int n=prices.length;\\n\\n        int [][] curr = new int[2][k+2];\\n        int [][] next = new int[2][k+2];\\n\\n        for(int index=n-1;index>=0;index--){\\n            for(int buy=1;buy>=0;buy--){\\n                for(int limit=1;limit<=k;limit++){\\n                    int profit=0;\\n                    if(buy==1){\\n                        int salekaro=prices[index]+next[0][limit-1];\\n                        int skipkaro=0+next[1][limit];\\n                        profit+=Math.max(salekaro,skipkaro);\\n                    }\\n                    else{\\n                        int buykaro=-prices[index]+next[1][limit];\\n                        int skipkaro=0+next[0][limit];\\n                        profit+=Math.max(buykaro,skipkaro);\\n                    }\\n                    curr[buy][limit]=profit;\\n                }\\n            }\\n            next=curr;\\n        }\\n        return next[0][k];\\n    }\\n    public int maxProfit(int k, int[] prices) {\\n        return solveTab(prices,k);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\n#include <stack>\\n#include <vector>\\n#include <utility>\\n#include <algorithm>\\n#include <numeric>\\nusing std::stack;\\nusing std::pair;\\nusing std::vector;\\nusing std::nth_element;\\nusing std::accumulate;\\n\\nclass Solution {\\n\\npublic:\\n    int maxProfit(int k, const vector<int>& prices) {\\n        vector<int> profits;\\n        stack<pair<int, int>> vps;\\n        int v = 0;\\n        int p = -1;\\n        \\n        const int n = prices.size();\\n        for (;;) {\\n            for (v = p + 1; (v + 1) < n && prices[v] >= prices[v + 1]; ++v);\\n            for (p = v; (p + 1) < n && prices[p] <= prices[p + 1]; ++p);\\n            if (p == v) break;\\n            \\n            while (!vps.empty() && prices[vps.top().first] >= prices[v]) {\\n                auto vp = vps.top();\\n                profits.push_back(prices[vp.second] - prices[vp.first]);\\n                vps.pop();\\n            }\\n            while (!vps.empty() && prices[vps.top().second] <= prices[p]) {\\n                profits.push_back(prices[vps.top().second] - prices[v]);\\n                v = vps.top().first; //  (v1, p2)\\n                vps.pop();\\n            }\\n            vps.emplace(v, p);\\n        }\\n        while (!vps.empty()) {\\n            auto vp = vps.top(); vps.pop();\\n            profits.push_back(prices[vp.second] - prices[vp.first]);\\n        }\\n        if (k >= profits.size()) {\\n            return accumulate(profits.begin(), profits.end(), 0);\\n        } else {\\n            nth_element(profits.begin(), profits.end() - k, profits.end());\\n            return accumulate(profits.end() - k, profits.end(), 0);\\n        }\\n    }\\n};\\n```\n```Python3 []\\nclass DoubleLinkListNode:\\n    def __init__(self, ind, pre = None, next = None):\\n        self.ind = ind\\n        self.pre = pre if pre else self\\n        self.next = next if next else self\\n\\nclass Solution:\\n    def MinMaxList(self, arr: List[int]) -> List[int]:\\n        n = len(arr)\\n        if n == 0:\\n            return []\\n        sign = -1\\n        res = [9999]\\n        for num in arr:\\n            if num * sign > res[-1] * sign:\\n                res[-1] = num\\n            else:\\n                res.append(num)\\n                sign *= -1\\n        if len(res) & 1:\\n            res.pop()\\n        return res\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        newP = self.MinMaxList(prices)\\n        n = len(newP)\\n        m = n // 2\\n        res = 0\\n        for i in range(m):\\n            res += newP[i*2+1] - newP[i*2]\\n        if m <= k:\\n            return res\\n        head, tail = DoubleLinkListNode(-1), DoubleLinkListNode(-1)\\n        NodeList = [DoubleLinkListNode(0, head)]\\n        for i in range(1, n):\\n            NodeList.append(DoubleLinkListNode(i, NodeList[-1]))\\n            NodeList[i-1].next = NodeList[i]\\n        NodeList[n-1].next = tail\\n        head.next, tail.pre = NodeList[0], NodeList[n-1]\\n        heap = []\\n        for i in range(n-1):\\n            if i&1:\\n                heappush(heap, [newP[i] - newP[i+1], i, i+1, 0])\\n            else:\\n                heappush(heap, [newP[i+1] - newP[i], i, i+1, 1])\\n        while m > k:\\n            loss, i, j, t = heappop(heap)\\n            if NodeList[i] == None or NodeList[j] == None: continue\\n            m -= 1\\n            res -= loss\\n            nodei, nodej = NodeList[i], NodeList[j]\\n            nodel, noder = nodei.pre, nodej.next\\n            l, r = nodel.ind, noder.ind\\n            valL, valR = newP[l], newP[r]\\n            noder.pre, nodel.next = nodel, noder\\n            NodeList[i], NodeList[j] = None, None\\n            if t == 0:\\n                heappush(heap, [valR - valL, l, r, 1])\\n            elif l != -1 and r != -1:\\n                heappush(heap, [valL - valR, l, r, 0])\\n        return res\\n```\n```Java []\\nclass Solution {\\n    static int solveTab(int[] prices,int k){\\n        int n=prices.length;\\n\\n        int [][] curr = new int[2][k+2];\\n        int [][] next = new int[2][k+2];\\n\\n        for(int index=n-1;index>=0;index--){\\n            for(int buy=1;buy>=0;buy--){\\n                for(int limit=1;limit<=k;limit++){\\n                    int profit=0;\\n                    if(buy==1){\\n                        int salekaro=prices[index]+next[0][limit-1];\\n                        int skipkaro=0+next[1][limit];\\n                        profit+=Math.max(salekaro,skipkaro);\\n                    }\\n                    else{\\n                        int buykaro=-prices[index]+next[1][limit];\\n                        int skipkaro=0+next[0][limit];\\n                        profit+=Math.max(buykaro,skipkaro);\\n                    }\\n                    curr[buy][limit]=profit;\\n                }\\n            }\\n            next=curr;\\n        }\\n        return next[0][k];\\n    }\\n    public int maxProfit(int k, int[] prices) {\\n        return solveTab(prices,k);\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 54114,
                "title": "easy-understanding-and-can-be-easily-modified-to-different-situations-java-solution",
                "content": "The basic idea is to create two tables. hold and unhold. \\n \\nhold[i][j] means the maximum profit with at most j transaction for 0 to i-th day. hold means you have a stock in your hand.\\n\\nunhold[i][j] means the maximum profit with at most j transaction for 0 to i-th day. unhold means you don't have a stock in your hand.\\n\\nThe equation is \\n\\n> **hold[i][j] = Math.max(unhold[i-1][j]-prices[i],hold[i-1][j]);**\\n> \\n> \\n> **unhold[i][j] = Math.max(hold[i-1][j-1]+prices[i],unhold[i-1][j]);**\\n\\nwhen you sell your stock this is a transaction but when you buy a stock, it is not considered as a full transaction. so this is why the two equation look a little different.\\n\\nAnd we have to initiate hold table when **k = 0**.\\n\\nWhen the situation is you can not buy a new stock at the same day when you sell it. For example you can only buy a new stock after one day you sell it. The same idea. Another situation is when you have to pay a transaction fee for each transaction, just make a modification when you sell it, So just change the unhold equation a little. \\n\\n \\n\\n    public class Solution {\\n        //hold[i][k]  ith day k transaction have stock and maximum profit\\n        //unhold[i][k] ith day k transaction do not have stock at hand and maximum profit\\n        public int maxProfit(int k, int[] prices) {\\n            if(k>prices.length/2) return maxP(prices);\\n            int[][] hold = new int[prices.length][k+1];\\n            int[][] unhold = new int[prices.length][k+1];\\n            hold[0][0] = -prices[0];\\n            for(int i=1;i<prices.length;i++) hold[i][0] = Math.max(hold[i-1][0],-prices[i]);\\n            for(int j=1;j<=k;j++) hold[0][j] = -prices[0];\\n            for(int i=1;i<prices.length;i++){\\n                for(int j=1;j<=k;j++){\\n                    hold[i][j] = Math.max(unhold[i-1][j]-prices[i],hold[i-1][j]);\\n                    unhold[i][j] = Math.max(hold[i-1][j-1]+prices[i],unhold[i-1][j]);\\n                }\\n            }\\n            return Math.max(hold[prices.length-1][k],unhold[prices.length-1][k]);\\n        }\\n        public int maxP(int[] prices){\\n            int res =0;\\n            for(int i=0;i<prices.length;i++){\\n                if(i>0 && prices[i] > prices[i-1]){\\n                    res += prices[i]-prices[i-1];\\n                }\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        //hold[i][k]  ith day k transaction have stock and maximum profit\\n        //unhold[i][k] ith day k transaction do not have stock at hand and maximum profit\\n        public int maxProfit(int k, int[] prices) {\\n            if(k>prices.length/2) return maxP(prices);\\n            int[][] hold = new int[prices.length][k+1];\\n            int[][] unhold = new int[prices.length][k+1];\\n            hold[0][0] = -prices[0];\\n            for(int i=1;i<prices.length;i++) hold[i][0] = Math.max(hold[i-1][0],-prices[i]);\\n            for(int j=1;j<=k;j++) hold[0][j] = -prices[0];\\n            for(int i=1;i<prices.length;i++){\\n                for(int j=1;j<=k;j++){\\n                    hold[i][j] = Math.max(unhold[i-1][j]-prices[i],hold[i-1][j]);\\n                    unhold[i][j] = Math.max(hold[i-1][j-1]+prices[i],unhold[i-1][j]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 188630,
                "title": "c-top-down-and-bottom-up-dp",
                "content": "The first function is the solution for [Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/). We use it when we have unlimited transactions (```k >= prices.size() / 2```).\\nThe main function is generalizaton of the solution for [Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/192322/C++-DP), where you can complete at most *two* transactions.\\n\\n> OK, the tabulation logic - though simple - may be hard to come up with out of blue. You can first look at the top-down solution below. It requires an extra memory - which is common when comparing memoisation and tabulation.\\n\\nHere, we maintain ```k``` balances (instead of just two) to track best consecutive deals. Also note the ```+ 1``` sentinel element for balances to make the calculations simpler.\\n\\n**Bottom-Up DP**\\n```cpp\\nint maxProfit(vector<int>& p, int res = 0) {\\n  for (int i = 1; i < p.size(); ++i) res += max(0, p[i] - p[i - 1]);\\n  return res;\\n}\\nint maxProfit(int k, vector<int>& prices) {\\n  if (k >= prices.size() / 2) return maxProfit(prices);\\n  vector<int> buys(k + 1, INT_MIN), sells(k + 1, 0);\\n  for (auto p : prices)\\n    for (auto i = 1; i <= k; ++i) {\\n      buys[i] = max(buys[i], sells[i - 1] - p);\\n      sells[i] = max(sells[i], buys[i] + p);  \\n    }\\n  return sells[k];\\n}\\n```\\n**Top-Down DP**\\n```cpp\\nint dp[1000][101][2] = {};\\nint dfs(vector<int>& ps, int p, int k, bool buy) {\\n    if (p >= ps.size() || (k == 0 && buy))\\n        return 0;\\n    if (dp[p][k][buy] == 0)\\n        dp[p][k][buy] = max(dfs(ps, p + 1, k, buy), \\n            (buy ? -1 : 1) * ps[p] + dfs(ps, p + 1, k - buy, !buy));\\n    return dp[p][k][buy];\\n} \\nint maxProfit(int k, vector<int>& ps) {\\n    if (k * 2 >= ps.size()) \\n        return maxProfit2(ps);\\n    return dfs(ps, 0, k, true);\\n }\\nint maxProfit2(vector<int>& ps, int res = 0) {\\n    for (auto i = 1; i < ps.size(); ++i) \\n        res += max(0, ps[i] - ps[i - 1]);\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```k >= prices.size() / 2```\n```k```\n```+ 1```\n```cpp\\nint maxProfit(vector<int>& p, int res = 0) {\\n  for (int i = 1; i < p.size(); ++i) res += max(0, p[i] - p[i - 1]);\\n  return res;\\n}\\nint maxProfit(int k, vector<int>& prices) {\\n  if (k >= prices.size() / 2) return maxProfit(prices);\\n  vector<int> buys(k + 1, INT_MIN), sells(k + 1, 0);\\n  for (auto p : prices)\\n    for (auto i = 1; i <= k; ++i) {\\n      buys[i] = max(buys[i], sells[i - 1] - p);\\n      sells[i] = max(sells[i], buys[i] + p);  \\n    }\\n  return sells[k];\\n}\\n```\n```cpp\\nint dp[1000][101][2] = {};\\nint dfs(vector<int>& ps, int p, int k, bool buy) {\\n    if (p >= ps.size() || (k == 0 && buy))\\n        return 0;\\n    if (dp[p][k][buy] == 0)\\n        dp[p][k][buy] = max(dfs(ps, p + 1, k, buy), \\n            (buy ? -1 : 1) * ps[p] + dfs(ps, p + 1, k - buy, !buy));\\n    return dp[p][k][buy];\\n} \\nint maxProfit(int k, vector<int>& ps) {\\n    if (k * 2 >= ps.size()) \\n        return maxProfit2(ps);\\n    return dfs(ps, 0, k, true);\\n }\\nint maxProfit2(vector<int>& ps, int res = 0) {\\n    for (auto i = 1; i < ps.size(); ++i) \\n        res += max(0, ps[i] - ps[i - 1]);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 54121,
                "title": "share-my-c-dp-solution-with-o-kn-time-o-k-space-10ms",
                "content": "This is my DP solution:\\n\\nclass Solution {\\n\\n    public:\\n        int maxProfit(int k, vector<int> &prices) {\\n            int len = prices.size();\\n            if (len<2) return 0;\\n            if (k>len/2){ // simple case\\n                int ans = 0;\\n                for (int i=1; i<len; ++i){\\n                    ans += max(prices[i] - prices[i-1],0);\\n                }\\n                return ans;\\n            }\\n            int hold[k+1];\\n            int rele[k+1];\\n            for (int i=0;i<=k;++i){\\n                hold[i] = INT_MIN;\\n                rele[i] = 0;\\n            }\\n            int cur;\\n            for (int i=0; i<len; ++i){\\n                cur = prices[i];\\n                for(int j=k; j>0; --j){\\n                    rele[j] = max(rele[j],hold[j] + cur);\\n                    hold[j] = max(hold[j],rele[j-1] - cur);\\n                }\\n            }\\n            return rele[k];\\n        }\\n\\n};\\n\\nInspired by weijiac in Best Time to Buy and Sell Stock III\\n\\nhttps://leetcode.com/discuss/18330/is-it-best-solution-with-o-n-o-1",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public:\\n        int maxProfit(int k, vector<int> &prices) {\\n            int len = prices.size();\\n            if (len<2) return 0;\\n            if (k>len/2){ // simple case\\n                int ans = 0;\\n                for (int i=1; i<len; ++i){\\n                    ans += max(prices[i] - prices[i-1],0);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2555699,
                "title": "leetcode-the-hard-way-7-lines-line-by-line-explanation",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\nI\\'d suggest to finish the previous problems first.\\n\\n- [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\\n- [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)\\n- [123. Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)\\n\\n**C++**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        // no transaction, no profit\\n        if (k == 0) return 0;\\n        // dp[k][0] = min cost you need to spend at most k transactions\\n        // dp[k][1] = max profit you can achieve at most k transactions\\n        vector<vector<int>> dp(k + 1, vector<int>(2));\\n        for (int i = 0; i <= k; i++) dp[i][0] = INT_MAX;\\n        for (auto& price : prices) {\\n            for (int i = 1; i <= k; i++) {\\n                // price - dp[i - 1][1] is how much you need to spend\\n                // i.e use the profit you earned from previous transaction to buy the stock\\n                // we want to minimize it\\n                dp[i][0] = min(dp[i][0], price - dp[i - 1][1]);\\n                // price - dp[i][0] is how much you can achieve from previous min cost\\n                // we want to maximize it\\n                dp[i][1] = max(dp[i][1], price - dp[i][0]);\\n            }\\n        }\\n        // return max profit at most k transactions\\n        // or you can use `return dp.back()[1];`\\n        return dp[k][1];\\n    }\\n};\\n```\\n\\n**Python**\\n\\n```py\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        # no transaction, no profit\\n        if k == 0: return 0\\n        # dp[k][0] = min cost you need to spend at most k transactions\\n        # dp[k][1] = max profit you can achieve at most k transactions\\n        dp = [[1000, 0] for _ in range(k + 1)]\\n        for price in prices:\\n            for i in range(1, k + 1):\\n                # price - dp[i - 1][1] is how much you need to spend\\n                # i.e use the profit you earned from previous transaction to buy the stock\\n                # we want to minimize it\\n                dp[i][0] = min(dp[i][0], price - dp[i - 1][1])\\n                # price - dp[i][0] is how much you can achieve from previous min cost\\n                # we want to maximize it\\n                dp[i][1] = max(dp[i][1], price - dp[i][0])\\n        # return max profit at most k transactions\\n\\t\\t# or you can write `return dp[-1][1]`\\n        return dp[k][1]\\n```\\n\\n**Java**\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        // no transaction, no profit\\n        if (k == 0) return 0;\\n        // dp[k][0] = min cost you need to spend at most k transactions\\n        // dp[k][1] = max profit you can achieve at most k transactions\\n        int [][] dp = new int[k + 1][2];\\n        for (int i = 0; i <= k; i++) dp[i][0] = 1000;\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = 1; j <= k; j++) {\\n                // price - dp[i - 1][1] is how much you need to spend\\n                // i.e use the profit you earned from previous transaction to buy the stock\\n                // we want to minimize it\\n                dp[j][0] = Math.min(dp[j][0], prices[i] - dp[j - 1][1]);\\n                // price - dp[i][0] is how much you can achieve from previous min cost\\n                // we want to maximize it\\n                dp[j][1] = Math.max(dp[j][1], prices[i] - dp[j][0]);\\n            }\\n        }\\n        // return max profit at most k transactions\\n        return dp[k][1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        // no transaction, no profit\\n        if (k == 0) return 0;\\n        // dp[k][0] = min cost you need to spend at most k transactions\\n        // dp[k][1] = max profit you can achieve at most k transactions\\n        vector<vector<int>> dp(k + 1, vector<int>(2));\\n        for (int i = 0; i <= k; i++) dp[i][0] = INT_MAX;\\n        for (auto& price : prices) {\\n            for (int i = 1; i <= k; i++) {\\n                // price - dp[i - 1][1] is how much you need to spend\\n                // i.e use the profit you earned from previous transaction to buy the stock\\n                // we want to minimize it\\n                dp[i][0] = min(dp[i][0], price - dp[i - 1][1]);\\n                // price - dp[i][0] is how much you can achieve from previous min cost\\n                // we want to maximize it\\n                dp[i][1] = max(dp[i][1], price - dp[i][0]);\\n            }\\n        }\\n        // return max profit at most k transactions\\n        // or you can use `return dp.back()[1];`\\n        return dp[k][1];\\n    }\\n};\\n```\n```py\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        # no transaction, no profit\\n        if k == 0: return 0\\n        # dp[k][0] = min cost you need to spend at most k transactions\\n        # dp[k][1] = max profit you can achieve at most k transactions\\n        dp = [[1000, 0] for _ in range(k + 1)]\\n        for price in prices:\\n            for i in range(1, k + 1):\\n                # price - dp[i - 1][1] is how much you need to spend\\n                # i.e use the profit you earned from previous transaction to buy the stock\\n                # we want to minimize it\\n                dp[i][0] = min(dp[i][0], price - dp[i - 1][1])\\n                # price - dp[i][0] is how much you can achieve from previous min cost\\n                # we want to maximize it\\n                dp[i][1] = max(dp[i][1], price - dp[i][0])\\n        # return max profit at most k transactions\\n\\t\\t# or you can write `return dp[-1][1]`\\n        return dp[k][1]\\n```\n```java\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        // no transaction, no profit\\n        if (k == 0) return 0;\\n        // dp[k][0] = min cost you need to spend at most k transactions\\n        // dp[k][1] = max profit you can achieve at most k transactions\\n        int [][] dp = new int[k + 1][2];\\n        for (int i = 0; i <= k; i++) dp[i][0] = 1000;\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = 1; j <= k; j++) {\\n                // price - dp[i - 1][1] is how much you need to spend\\n                // i.e use the profit you earned from previous transaction to buy the stock\\n                // we want to minimize it\\n                dp[j][0] = Math.min(dp[j][0], prices[i] - dp[j - 1][1]);\\n                // price - dp[i][0] is how much you can achieve from previous min cost\\n                // we want to maximize it\\n                dp[j][1] = Math.max(dp[j][1], prices[i] - dp[j][0]);\\n            }\\n        }\\n        // return max profit at most k transactions\\n        return dp[k][1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54145,
                "title": "o-n-time-8ms-accepted-solution-with-detailed-explanation-c",
                "content": "The idea of this thread was originally proposed by **@yishiluo** in\\nhttps://leetcode.com/discuss/26745/c-solution-with-o-n-klgn-time-using-max-heap-and-stack\\n\\n**General idea:**\\n\\nWe use the term \"valley\" to denote a local minimum index of prices, and the term \"peak\" to denote a local maximum index of prices. Let (v1, p1) and (v2, p2) denote two successive valley-peak pairs of the prices, respectively. Consider the two cases:\\n\\n- **Case 1**: prices[v1] <= prices[v2] and prices[p1] <= prices[p2]. In this case, if we can conduct one transaction, we will use (v1, p2). If we can conduct two transactions, we will use (v1, p1) and (v2, p2). Equivalently, we can consider (v1, p2) as one transaction opportunity, and (v2, p1) as another transaction opportunity. The key idea is that these two original valley-peak pairs provide two transaction opportunities: (v1, p2) and (v2, p1).\\n\\n- **Case 2**: prices[v1] >= prices[v2] or prices[p1] >= prices[p2]. In this case, if we can conduct one transaction, we will use either (v1, p1) or (v2, p2). If we can conduct two transactions, we will use both (v1, p1) and (v2, p2). That is, these two valley-peak pairs provides two transaction opportunities: (v1, p1) and (v2, p2).\\n\\n**The algorithm consists of two steps:**\\n\\n- **Step 1**: Find all transaction opportunities and record their profits. We use a stack `vps` to store the valley-peak pairs of the stock prices, wherein the valley value is sorted in ascending order. (The valley value at the top of the stack is the largest.) The profit of all transaction opportunities are recorded in the vector `profits`. The time complexity of this step is O(n).\\n\\n- **Step 2**: Find the k most profitable transaction opportunities. The maximum profit we can get is the summation of the k opportunity. The time complexity of this step is O(n), too.\\n\\n**Overall complexity:**\\n\\n- Time: O(n)\\n\\n- Space: worse-case O(n)\\n\\n---------------------------\\n**C++ code** (Accepted 8ms)\\n\\n    class Solution {\\n    public:\\n        int maxProfit(int k, vector<int>& prices) {\\n\\n            // Step 1: Find out all profit opportunities            \\n            vector<int> profits;\\n            stack<pair<int, int>> vps; // valley-peak pairs\\n            \\n            int v;\\n            int p = -1;\\n            for (;;) {\\n                // find next valley-peak pair\\n                for (v = p+1; (v+1 < prices.size()) && (prices[v] >= prices[v+1]); ++v);\\n                for (p = v  ; (p+1 < prices.size()) && (prices[p] <= prices[p+1]); ++p);\\n                \\n                if (v == p) { // v==p means that both v and p reach the end of the array\\n                    break;\\n                }\\n                \\n                // Consider two transactions (v1, p1) (back of the stack) and (v2, p2) (the new-found).\\n                // If prices[v1] >= prices[v2], \\n                // it is meaningless to combine the two transactions.\\n                // Save of profit of (v1, p1), and pop it out of the record.\\n                while ((!vps.empty()) && (prices[v] <= prices[vps.top().first])) {\\n                    profits.push_back(prices[vps.top().second] - prices[vps.top().first]);\\n                    vps.pop();\\n                }\\n                \\n                // If prices[v1]<prices[v2] and prices[p1]<prices[p2], \\n                // then it is meaningful to combine the two transactions\\n                // update (v1, p1) to (v1, p2), and save the profit of (v2, p1)\\n                while ((!vps.empty()) && (prices[p] >= prices[vps.top().second])) {\\n                    profits.push_back(prices[vps.top().second] - prices[v]);\\n                    v = vps.top().first;\\n                    vps.pop();\\n                }\\n                \\n                // save the new-found valley-peak pair\\n                vps.emplace(v, p);\\n            }\\n            \\n            // save all remaining profits\\n            while (!vps.empty()) {\\n                profits.push_back(prices[vps.top().second] - prices[vps.top().first]);\\n                vps.pop();\\n            }\\n            \\n            // Step 2: Calculate the k highest profits\\n            int ret;\\n            if (profits.size() <= k) {\\n                ret = accumulate(profits.begin(), profits.end(), 0);\\n            } else {\\n                nth_element(profits.begin(), profits.end() - k, profits.end());\\n                ret = accumulate(profits.end() - k, profits.end(), 0);\\n            }\\n            return ret;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int maxProfit(int k, vector<int>& prices) {\\n\\n            // Step 1: Find out all profit opportunities            \\n            vector<int> profits;\\n            stack<pair<int, int>> vps; // valley-peak pairs\\n            \\n            int v;\\n            int p = -1;\\n            for (;;) {\\n                // find next valley-peak pair\\n                for (v = p+1; (v+1 < prices.size()) && (prices[v] >= prices[v+1]); ++v);\\n                for (p = v  ; (p+1 < prices.size()) && (prices[p] <= prices[p+1]); ++p);\\n                \\n                if (v == p) { // v==p means that both v and p reach the end of the array\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 54131,
                "title": "well-explained-python-dp-with-comments",
                "content": "I think the general idea has been thoroughly explained by other brilliant leetcoders. All of the solutions are beautiful and concise. However, most of the them don't look obvious to me, so I wrote this and hope it looks more straight forward.\\nIt's O(kn),  apparently not optimal. I name the key variables as local profit and global profit to make things much understandable (well, at least , to me). Performance is not too bad though. \\n\\n    def maxProfit4(self, k, prices):\\n        n = len(prices)\\n        if n < 2:\\n            return 0\\n        # k is big enougth to cover all ramps.\\n        if k >= n / 2:\\n            return sum(i - j\\n                       for i, j in zip(prices[1:], prices[:-1]) if i - j > 0)\\n        globalMax = [[0] * n for _ in xrange(k + 1)]\\n        for i in xrange(1, k + 1):\\n            # The max profit with i transations and selling stock on day j.\\n            localMax = [0] * n\\n            for j in xrange(1, n):\\n                profit = prices[j] - prices[j - 1]\\n                localMax[j] = max(\\n                    # We have made max profit with (i - 1) transations in\\n                    # (j - 1) days.\\n                    # For the last transation, we buy stock on day (j - 1)\\n                    # and sell it on day j.\\n                    globalMax[i - 1][j - 1] + profit,\\n                    # We have made max profit with (i - 1) transations in\\n                    # (j - 1) days.\\n                    # For the last transation, we buy stock on day j and\\n                    # sell it on the same day, so we have 0 profit, apparently\\n                    # we do not have to add it.\\n                    globalMax[i - 1][j - 1],  # + 0,\\n                    # We have made profit in (j - 1) days.\\n                    # We want to cancel the day (j - 1) sale and sell it on\\n                    # day j.\\n                    localMax[j - 1] + profit)\\n                globalMax[i][j] = max(globalMax[i][j - 1], localMax[j])\\n        return globalMax[k][-1]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "I think the general idea has been thoroughly explained by other brilliant leetcoders. All of the solutions are beautiful and concise. However, most of the them don't look obvious to me, so I wrote this and hope it looks more straight forward.\\nIt's O(kn),  apparently not optimal. I name the key variables as local profit and global profit to make things much understandable (well, at least , to me). Performance is not too bad though. \\n\\n    def maxProfit4(self, k, prices):\\n        n = len(prices)\\n        if n < 2:\\n            return 0\\n        # k is big enougth to cover all ramps.\\n        if k >= n / 2:\\n            return sum(i - j\\n                       for i, j in zip(prices[1:], prices[:-1]) if i - j > 0)\\n        globalMax = [[0] * n for _ in xrange(k + 1)]\\n        for i in xrange(1, k + 1):\\n            # The max profit with i transations and selling stock on day j.\\n            localMax = [0] * n\\n            for j in xrange(1, n):\\n                profit = prices[j] - prices[j - 1]\\n                localMax[j] = max(\\n                    # We have made max profit with (i - 1) transations in\\n                    # (j - 1) days.\\n                    # For the last transation, we buy stock on day (j - 1)\\n                    # and sell it on day j.\\n                    globalMax[i - 1][j - 1] + profit,\\n                    # We have made max profit with (i - 1) transations in\\n                    # (j - 1) days.\\n                    # For the last transation, we buy stock on day j and\\n                    # sell it on the same day, so we have 0 profit, apparently\\n                    # we do not have to add it.\\n                    globalMax[i - 1][j - 1],  # + 0,\\n                    # We have made profit in (j - 1) days.\\n                    # We want to cancel the day (j - 1) sale and sell it on\\n                    # day j.\\n                    localMax[j - 1] + profit)\\n                globalMax[i][j] = max(globalMax[i][j - 1], localMax[j])\\n        return globalMax[k][-1]",
                "codeTag": "Python3"
            },
            {
                "id": 900034,
                "title": "fully-explained-all-buy-and-sell-problems-c-recursive-memoization-minor-difference",
                "content": "**To solve this problem just start from basic similar problem. After solving these peoblems we wil reach at final this problem.**\\n\\n``` I have discussed all the problems by recursive and memoization approach , so that everyone can figure out minor differences between the questions :)```\\n\\n---------------------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------------------\\n**Recursive Solution and memoize solutions:**\\n\\n1. https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\\n\\n   **You can do at most one transaction**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices, int i,int k,bool buy,vector<vector<int>> &v)\\n    {\\n        //if we have no stock or we have no chance of transaction(k=0)\\n        if(i>=prices.size()||k<=0) return 0;\\n        if(v[i][buy]!=-1) return v[i][buy];\\n        \\n        if(buy)  //if we are buying then next time we will sell else next time we will buy\\n        {        //-prices[i], because bought stock of prices[i], expend money\\n            \\n           return v[i][buy]=max(-prices[i]+find(prices,i+1,k,!buy,v),find(prices,i+1,k,buy,v)); \\n        }\\n        else    //it\\'s time to sell , now decrease k, we have done 1 transaction\\n        {       //+prices[i], because we now gain (i.e) sell our stock at rate of prices[i]\\n           return v[i][buy]=max( prices[i]+find(prices,i+1,k-1,!buy,v),find(prices,i+1,k,buy,v)); \\n        }\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n=prices.size(); \\n        vector<vector<int>> v(n,vector<int> (2,-1));\\n        //passing here buy=1 because we will first buy then sell\\n        //we can do atmost k=1 transaction\\n        return find(prices,0,1,1,v);\\n    }\\n};\\n```\\n\\n***n -> size of vector  \\nTime Complexity:  O(n)\\nSpace Complexity: O(2 * n) ~ O(n)***\\n\\n\\n---------------------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------------------\\n2. https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/\\n\\n    **You can do as many transactions as you like**\\n\\n```\\nclass Solution {\\npublic:\\nint find(int ind,vector<int> &v,bool buy,vector<vector<int>> &memo)\\n{    \\n    if(ind>=v.size()) return 0;\\n    if(memo[ind][buy]!=-1) return memo[ind][buy];\\n    \\n    if(buy) //if we are buying then next time we will sell else next time we will buy\\n    {      //-prices[i], because bought stock of prices[i], expend money, !buy because next time sell\\n        \\n       return memo[ind][buy]=max(-v[ind]+find(ind+1,v,!buy,memo),find(ind+1,v,buy,memo));  \\n    }\\n    else   //it\\'s time to sell \\n    {      //+prices[i], because we now gain (i.e) sell our stock at rate of prices[i]\\n        \\n       return memo[ind][buy]=max(v[ind]+find(ind+1,v,!buy,memo),find(ind+1,v,buy,memo));  \\n    }\\n     \\n}\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n=prices.size();\\n        if(n<2) return 0;\\n        vector<vector<int>> v(n+1,vector<int>(2,-1));\\n        //passing here buy=1 because we will first buy then sell \\n        return find(0,prices,1,v); \\n    }\\n};\\n```\\n \\n ***n -> size of vector \\nTime Complexity:  O(n)\\nSpace Complexity: O(2 * n) ~ O(n)***\\n \\n---------------------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------------------\\n 3.  https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/\\n\\n      **You may complete at most two transactions.**\\n\\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices,int ind,bool buy,int c,vector<vector<vector<int>>> &memo)\\n    {   \\n        //if buy =1 means we have to buy now\\n        //else we have to sell now\\n        if(ind>=prices.size()||c>=2) return 0; //counter\\n        if(memo[ind][buy][c]!=-1) return memo[ind][buy][c];\\n        if(buy) //now we can either buy prices[i] or we can skip it and try next to buy\\n        {\\n            return memo[ind][buy][c]=max(-prices[ind]+find(prices,ind+1,!buy,c,memo),find(prices,ind+1,buy,c,memo));\\n        }\\n        else  //now we can either sell prices[i] or we can skip it and try next to sell\\n        {\\n            return memo[ind][buy][c]=max(prices[ind]+find(prices,ind+1,!buy,c+1,memo),find(prices,ind+1,buy,c,memo));\\n        }\\n        \\n    }\\n    int maxProfit(vector<int>& prices) {\\n        //here we can do maximum two transaction\\n        //Use 3-D vector because here three states i,k,buy/sell\\n        vector<vector<vector<int>>> memo(prices.size(),vector<vector<int>>(2,vector<int>(2,-1)));\\n          \\n       return find(prices,0,1,0,memo); \\n    }\\n};\\n \\n```\\n\\n***n -> size of vector \\nTime Complexity:  O(n)\\nSpace Complexity: O(4 * n) ~ O(n)***\\n\\n---------------------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------------------\\n4. https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/\\n\\n     **You may complete at most k transactions.**\\n\\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices,int ind,bool buy,int c,int k,vector<vector<vector<int>>> &memo)\\n    {   //if buy =1 means we have to buy now\\n        //else we have to sell now\\n        if(ind>=prices.size()||c>=k) return 0; //counter\\n        \\n        else if(memo[ind][buy][c]!=-1) return memo[ind][buy][c];\\n         \\n        if(buy) //now we can either buy prices[i] or we can skip it and try next to buy\\n        {\\n        return memo[ind][buy][c]=max(-prices[ind]+find(prices,ind+1,!buy,c,k,memo),find(prices,ind+1,buy,c,k,memo));\\n        }\\n        else  //now we can either sell prices[i] or we can skip it and try next to sell\\n        {\\n        return memo[ind][buy][c]=max(prices[ind]+find(prices,ind+1,!buy,c+1,k,memo),find(prices,ind+1,buy,c,k,memo));\\n        }\\n        \\n    }\\n    int maxProfit(int k, vector<int>& prices) {\\n        \\n        //edge case we are not able to pick 2k points from n points, which means \\n        //we will not reach the limit no matter how we try. \\n        //if the price of day i arise, buy the stock in i-1th day and sell it at ith day.\\n        if (2 * k > prices.size()) {\\n            int res = 0;\\n            for (int i = 1; i < prices.size(); i++) {\\n                res += max(0, prices[i] - prices[i - 1]);\\n            }\\n            return res;\\n        }\\n        \\n         //here we can do maximum k transaction\\n        vector<vector<vector<int>>> memo(prices.size()+1,vector<vector<int>>(2,vector<int>(k+1,-1)));\\n        return find(prices,0,1,0,k,memo); \\n    }\\n};\\n```\\n\\n***n -> size of vector ,\\nTime Complexity:  O(n * k)\\nSpace Complexity: O(n * k)***\\n\\n---------------------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------------------\\n\\n**Hit \\uD83D\\uDC4D if you like it :)\\nIf any improvement needed feel free to comment**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "``` I have discussed all the problems by recursive and memoization approach , so that everyone can figure out minor differences between the questions :)```\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices, int i,int k,bool buy,vector<vector<int>> &v)\\n    {\\n        //if we have no stock or we have no chance of transaction(k=0)\\n        if(i>=prices.size()||k<=0) return 0;\\n        if(v[i][buy]!=-1) return v[i][buy];\\n        \\n        if(buy)  //if we are buying then next time we will sell else next time we will buy\\n        {        //-prices[i], because bought stock of prices[i], expend money\\n            \\n           return v[i][buy]=max(-prices[i]+find(prices,i+1,k,!buy,v),find(prices,i+1,k,buy,v)); \\n        }\\n        else    //it\\'s time to sell , now decrease k, we have done 1 transaction\\n        {       //+prices[i], because we now gain (i.e) sell our stock at rate of prices[i]\\n           return v[i][buy]=max( prices[i]+find(prices,i+1,k-1,!buy,v),find(prices,i+1,k,buy,v)); \\n        }\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n=prices.size(); \\n        vector<vector<int>> v(n,vector<int> (2,-1));\\n        //passing here buy=1 because we will first buy then sell\\n        //we can do atmost k=1 transaction\\n        return find(prices,0,1,1,v);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint find(int ind,vector<int> &v,bool buy,vector<vector<int>> &memo)\\n{    \\n    if(ind>=v.size()) return 0;\\n    if(memo[ind][buy]!=-1) return memo[ind][buy];\\n    \\n    if(buy) //if we are buying then next time we will sell else next time we will buy\\n    {      //-prices[i], because bought stock of prices[i], expend money, !buy because next time sell\\n        \\n       return memo[ind][buy]=max(-v[ind]+find(ind+1,v,!buy,memo),find(ind+1,v,buy,memo));  \\n    }\\n    else   //it\\'s time to sell \\n    {      //+prices[i], because we now gain (i.e) sell our stock at rate of prices[i]\\n        \\n       return memo[ind][buy]=max(v[ind]+find(ind+1,v,!buy,memo),find(ind+1,v,buy,memo));  \\n    }\\n     \\n}\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n=prices.size();\\n        if(n<2) return 0;\\n        vector<vector<int>> v(n+1,vector<int>(2,-1));\\n        //passing here buy=1 because we will first buy then sell \\n        return find(0,prices,1,v); \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices,int ind,bool buy,int c,vector<vector<vector<int>>> &memo)\\n    {   \\n        //if buy =1 means we have to buy now\\n        //else we have to sell now\\n        if(ind>=prices.size()||c>=2) return 0; //counter\\n        if(memo[ind][buy][c]!=-1) return memo[ind][buy][c];\\n        if(buy) //now we can either buy prices[i] or we can skip it and try next to buy\\n        {\\n            return memo[ind][buy][c]=max(-prices[ind]+find(prices,ind+1,!buy,c,memo),find(prices,ind+1,buy,c,memo));\\n        }\\n        else  //now we can either sell prices[i] or we can skip it and try next to sell\\n        {\\n            return memo[ind][buy][c]=max(prices[ind]+find(prices,ind+1,!buy,c+1,memo),find(prices,ind+1,buy,c,memo));\\n        }\\n        \\n    }\\n    int maxProfit(vector<int>& prices) {\\n        //here we can do maximum two transaction\\n        //Use 3-D vector because here three states i,k,buy/sell\\n        vector<vector<vector<int>>> memo(prices.size(),vector<vector<int>>(2,vector<int>(2,-1)));\\n          \\n       return find(prices,0,1,0,memo); \\n    }\\n};\\n \\n```\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices,int ind,bool buy,int c,int k,vector<vector<vector<int>>> &memo)\\n    {   //if buy =1 means we have to buy now\\n        //else we have to sell now\\n        if(ind>=prices.size()||c>=k) return 0; //counter\\n        \\n        else if(memo[ind][buy][c]!=-1) return memo[ind][buy][c];\\n         \\n        if(buy) //now we can either buy prices[i] or we can skip it and try next to buy\\n        {\\n        return memo[ind][buy][c]=max(-prices[ind]+find(prices,ind+1,!buy,c,k,memo),find(prices,ind+1,buy,c,k,memo));\\n        }\\n        else  //now we can either sell prices[i] or we can skip it and try next to sell\\n        {\\n        return memo[ind][buy][c]=max(prices[ind]+find(prices,ind+1,!buy,c+1,k,memo),find(prices,ind+1,buy,c,k,memo));\\n        }\\n        \\n    }\\n    int maxProfit(int k, vector<int>& prices) {\\n        \\n        //edge case we are not able to pick 2k points from n points, which means \\n        //we will not reach the limit no matter how we try. \\n        //if the price of day i arise, buy the stock in i-1th day and sell it at ith day.\\n        if (2 * k > prices.size()) {\\n            int res = 0;\\n            for (int i = 1; i < prices.size(); i++) {\\n                res += max(0, prices[i] - prices[i - 1]);\\n            }\\n            return res;\\n        }\\n        \\n         //here we can do maximum k transaction\\n        vector<vector<vector<int>>> memo(prices.size()+1,vector<vector<int>>(2,vector<int>(k+1,-1)));\\n        return find(prices,0,1,0,k,memo); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555676,
                "title": "python-simple-dp-o-nk-uses-the-idea-of-reinvesting",
                "content": "**Solution**\\n```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        \"\"\"\\n        Use the idea of \"reinvesting\", we can \"carry-over\" a\\n        previous transaction into the next transaction in order\\n        to calculate a total profit.\\n        \\n        For example, given [3,2,6,5,7,0,3]\\n                \\n        If k = 1, then we would keep track of the lowest price and\\n        max profit for each day.\\n        \\n            3, min_price [3], max_profit [0]\\n            2, min_price [2], max_profit [0]\\n            6, min_price [2], max_profit [4]\\n            5, min_price [2], max_profit [4]\\n            7, min_price [2], max_profit [5]\\n            0, min_price [0], max_profit [5]\\n            3, min_price [0], max_profit [5]\\n        \\n        If k = 2, we want to understand how much money we could make\\n        if we \"reinvest\" profit from k = 1. This means we could only\\n        initiate a k=2 transaction IFF k=1 (on a previous day) has a\\n        non-zero max_profit.\\n        \\n            3, min_price [3, 3], max_profit [0, 0]\\n            2, min_price [2, 2], max_profit [0, 0]\\n            6, min_price [2, 2], max_profit [4, 4]\\n            5, min_price [2, 1], max_profit [4, 4]  <- Reinvest profit\\n            7, min_price [2, 1], max_profit [5, 6]\\n            0, min_price [0, -5], max_profit [5, 6]\\n            3, min_price [0, -5], max_profit [5, 8] <- Max profit with 2 transactions\\n        \\n        Notice that the new min_price is $1 when price is $5. Similarly, the new min_price\\n        is -$5 when price is $0. Why?\\n                \\n        To understand, imagine if we bought at $2 and sold at $6. Then bought at $5\\n        and sold at $7. That is two transactions with a total profit of\\n        $4 + $2 = $6.\\n        \\n        Alternative, we can also think of it as (-$2)(+$6)(-$5)(+$7). This means when\\n        the stock is at $5, we will use our profit to bring its effective price\\n        down to $1 (i.e. (-$2)(+$6)(-$5)). When we sell at $7, we capture a TOTAL\\n        profit of $6. Our tabulation is cumulative.\\n        \\n                \\n        If k = 3, we do the same thing:\\n        \\n            3, min_price [3, 3, 3], max_profit [0, 0, 0]\\n            2, min_price [2, 2, 2], max_profit [0, 0, 0]\\n            6, min_price [2, 2, 2], max_profit [4, 4, 4]\\n            5, min_price [2, 1, 1], max_profit [4, 4, 4]\\n            7, min_price [2, 1, 1], max_profit [5, 6, 6]\\n            0, min_price [0, -5, -6], max_profit [5, 6, 6]\\n            3, min_price [0, -5, -6], max_profit [5, 8, 9]\\n        \"\"\"\\n        min_price = [float(\"inf\")] * (k + 1)\\n        max_profit = [0] * (k + 1)\\n        \\n        for price in prices:\\n            for i in range(1, k + 1):\\n                min_price[i] = min(min_price[i], price - max_profit[i-1])\\n                max_profit[i] = max(max_profit[i], price - min_price[i])\\n\\n        return max_profit[k]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        \"\"\"\\n        Use the idea of \"reinvesting\", we can \"carry-over\" a\\n        previous transaction into the next transaction in order\\n        to calculate a total profit.\\n        \\n        For example, given [3,2,6,5,7,0,3]\\n                \\n        If k = 1, then we would keep track of the lowest price and\\n        max profit for each day.\\n        \\n            3, min_price [3], max_profit [0]\\n            2, min_price [2], max_profit [0]\\n            6, min_price [2], max_profit [4]\\n            5, min_price [2], max_profit [4]\\n            7, min_price [2], max_profit [5]\\n            0, min_price [0], max_profit [5]\\n            3, min_price [0], max_profit [5]\\n        \\n        If k = 2, we want to understand how much money we could make\\n        if we \"reinvest\" profit from k = 1. This means we could only\\n        initiate a k=2 transaction IFF k=1 (on a previous day) has a\\n        non-zero max_profit.\\n        \\n            3, min_price [3, 3], max_profit [0, 0]\\n            2, min_price [2, 2], max_profit [0, 0]\\n            6, min_price [2, 2], max_profit [4, 4]\\n            5, min_price [2, 1], max_profit [4, 4]  <- Reinvest profit\\n            7, min_price [2, 1], max_profit [5, 6]\\n            0, min_price [0, -5], max_profit [5, 6]\\n            3, min_price [0, -5], max_profit [5, 8] <- Max profit with 2 transactions\\n        \\n        Notice that the new min_price is $1 when price is $5. Similarly, the new min_price\\n        is -$5 when price is $0. Why?\\n                \\n        To understand, imagine if we bought at $2 and sold at $6. Then bought at $5\\n        and sold at $7. That is two transactions with a total profit of\\n        $4 + $2 = $6.\\n        \\n        Alternative, we can also think of it as (-$2)(+$6)(-$5)(+$7). This means when\\n        the stock is at $5, we will use our profit to bring its effective price\\n        down to $1 (i.e. (-$2)(+$6)(-$5)). When we sell at $7, we capture a TOTAL\\n        profit of $6. Our tabulation is cumulative.\\n        \\n                \\n        If k = 3, we do the same thing:\\n        \\n            3, min_price [3, 3, 3], max_profit [0, 0, 0]\\n            2, min_price [2, 2, 2], max_profit [0, 0, 0]\\n            6, min_price [2, 2, 2], max_profit [4, 4, 4]\\n            5, min_price [2, 1, 1], max_profit [4, 4, 4]\\n            7, min_price [2, 1, 1], max_profit [5, 6, 6]\\n            0, min_price [0, -5, -6], max_profit [5, 6, 6]\\n            3, min_price [0, -5, -6], max_profit [5, 8, 9]\\n        \"\"\"\\n        min_price = [float(\"inf\")] * (k + 1)\\n        max_profit = [0] * (k + 1)\\n        \\n        for price in prices:\\n            for i in range(1, k + 1):\\n                min_price[i] = min(min_price[i], price - max_profit[i-1])\\n                max_profit[i] = max(max_profit[i], price - min_price[i])\\n\\n        return max_profit[k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 714232,
                "title": "c-all-buy-sell-stock-problems-solved-in-similar-format-easy-to-understand",
                "content": "```\\n//Buy and Sell Stock:1\\nint maxProfit(vector<int>& prices) {\\n   int buy = INT_MAX;\\n   int sell = 0;\\n  for (int price : prices) {\\n        // the maximum profit if only one transaction is allowed\\n        buy = min(buy, price);\\n        sell = max(sell, price - buy);\\n    }\\n        return sell;\\n  }\\n//Buy and Sell Stock:2\\n//Method 1:\\nint maxProfit2(vector<int>& prices) {\\n      int maxprofit = 0;\\n      for (int i = 1; i < prices.size(); i++) {\\n          if (prices[i] > prices[i - 1])\\n              maxprofit += prices[i] - prices[i - 1];\\n      }\\n      return maxprofit;\\n  }\\n//Method 2:\\nint maxProfit2(vector<int>& prices) {\\n      int buy = INT_MAX;\\n      int sell = 0;\\n       for (int price : prices) {\\n           buy = min(buy, price-sell); //Use the previous profit for reinvetsment and minimize expenditure\\n           sell = max(sell, price - buy);\\n       }\\n       return sell;\\n   }\\n\\n//Buy and Sell Stock:3\\n//Method 1:\\nint maxProfit3(int* prices, int pricesSize){\\n    int len = pricesSize;\\n    if(len == 0)\\n        return 0;\\nint min_so_far = prices[0];\\n  int max_so_far = prices[len-1];\\n  int max_profit = 0;\\n  int maxProf[len];\\n    memset(maxProf,0,len*sizeof(int));\\n\\n  for(int i=1;i<len; i++){\\n    int profit = (prices[i] - min_so_far) ;\\n    max_profit = max_profit > profit ? max_profit : profit;\\n     maxProf[i] = max_profit;\\n    min_so_far = min_so_far < prices[i] ? min_so_far : prices[i];\\n\\n  }\\n\\n    for(int i = len-2;i>0;i--){\\n        int profit = (max_so_far - prices[i])+maxProf[i];\\n         max_profit = max_profit > profit ? max_profit : profit;\\n        max_so_far = max_so_far > prices[i] ? max_so_far : prices[i];\\n    }\\n\\n  return max_profit;\\n}\\n\\n//Method 2:\\nint maxProfit3(vector<int>& prices) {\\n    int buy1 = INT_MAX, buy2 = INT_MAX;\\n    int sell1 = 0, sell2 = 0;\\n    for (int price : prices) {\\n          // the maximum profit if only one transaction is allowed\\n          buy1 = min(buy1, price);\\n          sell1 = max(sell1, price - buy1);\\n          // re-invest the gained profit in the second transaction\\n          buy2 = min(buy2, price - sell1);\\n          sell2 = max(sell2, price - buy2);\\n      }\\n      return sell2;\\n   }\\n\\n//Buy and Sell Stock:4\\nint maxProfit4(int k, vector<int>& prices) {\\n\\n   if (k >= prices.size() / 2) { // if k >= n/2, then you can make maximum number of transactions\\n        int profit = 0;\\n        for (int i = 1; i < prices.size(); i++)\\n            if (prices[i] > prices[i - 1]) profit += prices[i] - prices[i - 1];\\n        return profit;\\n    }\\n   vector<int> buy(k+1,INT_MAX);\\n   vector<int> sell(k + 1,0);\\n\\n    for (int price : prices) {\\n        for (int i = 1; i <= k; i++) {\\n            buy[i] = min(buy[i], price-sell[i - 1]);\\n            sell[i] = max(sell[i], price-buy[i]);\\n        }\\n    }\\n    return sell[k];\\n}\\n\\n//Buy and sell stock with cooldown period\\nint maxProfit(vector<int>& prices) {\\n      int buy(INT_MAX), sell(0), prev_sell(0), prev_buy;\\n      for (int price : prices) {\\n          prev_buy = buy;\\n          buy = min(buy,price-prev_sell);\\n          prev_sell = sell;\\n          sell = max(sell,price-prev_buy);\\n      }\\n      return sell;\\n}\\n\\n//Buy and Sell with transaction fee\\n\\nint maxProfit(vector<int>& prices, int fee) {\\n      long buy(INT_MAX), sell(0), prev_sell(0), prev_buy;\\n  for (int price : prices) {\\n      buy = min(buy,price-sell);\\n      sell = max(sell,price-buy-fee);\\n  }\\n  return sell;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n//Buy and Sell Stock:1\\nint maxProfit(vector<int>& prices) {\\n   int buy = INT_MAX;\\n   int sell = 0;\\n  for (int price : prices) {\\n        // the maximum profit if only one transaction is allowed\\n        buy = min(buy, price);\\n        sell = max(sell, price - buy);\\n    }\\n        return sell;\\n  }\\n//Buy and Sell Stock:2\\n//Method 1:\\nint maxProfit2(vector<int>& prices) {\\n      int maxprofit = 0;\\n      for (int i = 1; i < prices.size(); i++) {\\n          if (prices[i] > prices[i - 1])\\n              maxprofit += prices[i] - prices[i - 1];\\n      }\\n      return maxprofit;\\n  }\\n//Method 2:\\nint maxProfit2(vector<int>& prices) {\\n      int buy = INT_MAX;\\n      int sell = 0;\\n       for (int price : prices) {\\n           buy = min(buy, price-sell); //Use the previous profit for reinvetsment and minimize expenditure\\n           sell = max(sell, price - buy);\\n       }\\n       return sell;\\n   }\\n\\n//Buy and Sell Stock:3\\n//Method 1:\\nint maxProfit3(int* prices, int pricesSize){\\n    int len = pricesSize;\\n    if(len == 0)\\n        return 0;\\nint min_so_far = prices[0];\\n  int max_so_far = prices[len-1];\\n  int max_profit = 0;\\n  int maxProf[len];\\n    memset(maxProf,0,len*sizeof(int));\\n\\n  for(int i=1;i<len; i++){\\n    int profit = (prices[i] - min_so_far) ;\\n    max_profit = max_profit > profit ? max_profit : profit;\\n     maxProf[i] = max_profit;\\n    min_so_far = min_so_far < prices[i] ? min_so_far : prices[i];\\n\\n  }\\n\\n    for(int i = len-2;i>0;i--){\\n        int profit = (max_so_far - prices[i])+maxProf[i];\\n         max_profit = max_profit > profit ? max_profit : profit;\\n        max_so_far = max_so_far > prices[i] ? max_so_far : prices[i];\\n    }\\n\\n  return max_profit;\\n}\\n\\n//Method 2:\\nint maxProfit3(vector<int>& prices) {\\n    int buy1 = INT_MAX, buy2 = INT_MAX;\\n    int sell1 = 0, sell2 = 0;\\n    for (int price : prices) {\\n          // the maximum profit if only one transaction is allowed\\n          buy1 = min(buy1, price);\\n          sell1 = max(sell1, price - buy1);\\n          // re-invest the gained profit in the second transaction\\n          buy2 = min(buy2, price - sell1);\\n          sell2 = max(sell2, price - buy2);\\n      }\\n      return sell2;\\n   }\\n\\n//Buy and Sell Stock:4\\nint maxProfit4(int k, vector<int>& prices) {\\n\\n   if (k >= prices.size() / 2) { // if k >= n/2, then you can make maximum number of transactions\\n        int profit = 0;\\n        for (int i = 1; i < prices.size(); i++)\\n            if (prices[i] > prices[i - 1]) profit += prices[i] - prices[i - 1];\\n        return profit;\\n    }\\n   vector<int> buy(k+1,INT_MAX);\\n   vector<int> sell(k + 1,0);\\n\\n    for (int price : prices) {\\n        for (int i = 1; i <= k; i++) {\\n            buy[i] = min(buy[i], price-sell[i - 1]);\\n            sell[i] = max(sell[i], price-buy[i]);\\n        }\\n    }\\n    return sell[k];\\n}\\n\\n//Buy and sell stock with cooldown period\\nint maxProfit(vector<int>& prices) {\\n      int buy(INT_MAX), sell(0), prev_sell(0), prev_buy;\\n      for (int price : prices) {\\n          prev_buy = buy;\\n          buy = min(buy,price-prev_sell);\\n          prev_sell = sell;\\n          sell = max(sell,price-prev_buy);\\n      }\\n      return sell;\\n}\\n\\n//Buy and Sell with transaction fee\\n\\nint maxProfit(vector<int>& prices, int fee) {\\n      long buy(INT_MAX), sell(0), prev_sell(0), prev_buy;\\n  for (int price : prices) {\\n      buy = min(buy,price-sell);\\n      sell = max(sell,price-buy-fee);\\n  }\\n  return sell;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 306282,
                "title": "different-dp-python-solutions-with-thinking-process",
                "content": "Please see and vote for my different solutions with thinking process.\\n[121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/306438/Python-O(n)-solution-with-thinking-process)\\n[122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/discuss/306427/Different-O(n)-Python-solutions-with-thinking-process)\\n[309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/306235/Different-DP-Python-solutions-with-thinking-process)\\n[188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/306282/Different-DP-Python-solutions-with-thinking-process)\\n[714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/444413/Different-Python-solutions-with-thinking-process-to-solve-the-series-of-stock-problems)\\n\\n**Method 1: naive DP algorithm with O(k n^2) time and O(k n) space**\\nLet dp[i][k] = maxProfit of prices[:i+1] with at most k transactions, the base cases and recursive relationship are\\n(i) dp[i][k]= 0 if i <= 0 or k <= 0\\n(ii) dp[i][k] = max(dp[i-1][k], prices[i] - prices[j] + dp[j-1][k-1] for j from 0 to i-1)\\nBecause we have two choices at day i: (1) do nothing at day i, (2) maxProfit of prices[:j], buy at day j, sell at day i.\\n\\nSolution 1: bottom-up approach with a 2D table (Time Limit Exceeded, 208 / 211 test cases passed.)\\n```\\n    def maxProfit(self, k, prices):\\n        n = len(prices)\\n        if n < 2: \\n            return 0\\n        dp = [[0 for _ in range(k+1)] for _ in range(n)]\\n        for k1 in range(1, k+1):\\n            for i in range(1, n):\\n                dp[i][k1] = dp[i-1][k1]\\n                for j in range(i):\\n                    tmp = prices[i] - prices[j]\\n                    tmp += dp[j][k1-1] if j > 0 and k1 - 1 > 0 else 0\\n                    dp[i][k1] = max(dp[i][k1], tmp)\\n        return dp[n-1][k]\\n```\\n\\nSolution 2: top-down approach with memoization (Time Limit Exceeded, 208 / 211 test cases passed.)\\n```\\n    def maxProfit(self, k, prices):\\n        def recursive(i, k):\\n            if i <= 0 or k <= 0:\\n                return 0\\n            if (i, k) in mp:\\n                return mp[(i, k)]\\n            max_profit = recursive(i - 1, k)\\n            for j in range(i):\\n                tmp = prices[i] - prices[j] + recursive(j - 1, k - 1)\\n                max_profit = max(max_profit, tmp)\\n            mp[(i, k)] = max_profit\\n            return mp[(i, k)]\\n        \\n        mp = {}\\n        return recursive(len(prices) - 1, k)\\n```\\n\\n**Method 2: DP algorithm with O(k n) time and O(k n) space (beat 45%)**\\nLet dp[i][k] = maxProfit of prices[:i+1] with at most k transactions, the base cases and recursive relationship are\\n(i) dp[i][k]= 0 if i <= 0 or k <= 0\\n(ii) dp[i][k] = max(dp[i-1][k], prices[i] - prices[j] + dp[j-1][k-1] for j from 0 to i-1)\\n**We can further use DP to get local_max = - prices[j] + dp[j-1][k-1] for j from 0 to i-1.** \\nSolution 3: it is an easier understandable version of https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/188630/C%2B%2B-8-lines-4-ms-DP\\n```\\n    def maxProfit(self, k, prices):\\n        n = len(prices)\\n        if n < 2: \\n            return 0\\n        if k >= n // 2: # problem 122. Best Time to Buy and Sell Stock II\\n            max_profit = 0\\n            for i in range(n - 1):\\n                max_profit += max(prices[i+1] - prices[i], 0)\\n            return max_profit\\n        dp = [[0 for _ in range(k+1)] for _ in range(n)]\\n        for k1 in range(1, k+1):\\n            local_max = -prices[0]\\n            for i in range(1, n):\\n                dp[i][k1] = max(dp[i-1][k1], prices[i] + local_max)\\n                local_max = max(local_max, dp[i-1][k1-1] - prices[i])\\n        return dp[n-1][k]\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def maxProfit(self, k, prices):\\n        n = len(prices)\\n        if n < 2: \\n            return 0\\n        dp = [[0 for _ in range(k+1)] for _ in range(n)]\\n        for k1 in range(1, k+1):\\n            for i in range(1, n):\\n                dp[i][k1] = dp[i-1][k1]\\n                for j in range(i):\\n                    tmp = prices[i] - prices[j]\\n                    tmp += dp[j][k1-1] if j > 0 and k1 - 1 > 0 else 0\\n                    dp[i][k1] = max(dp[i][k1], tmp)\\n        return dp[n-1][k]\\n```\n```\\n    def maxProfit(self, k, prices):\\n        def recursive(i, k):\\n            if i <= 0 or k <= 0:\\n                return 0\\n            if (i, k) in mp:\\n                return mp[(i, k)]\\n            max_profit = recursive(i - 1, k)\\n            for j in range(i):\\n                tmp = prices[i] - prices[j] + recursive(j - 1, k - 1)\\n                max_profit = max(max_profit, tmp)\\n            mp[(i, k)] = max_profit\\n            return mp[(i, k)]\\n        \\n        mp = {}\\n        return recursive(len(prices) - 1, k)\\n```\n```\\n    def maxProfit(self, k, prices):\\n        n = len(prices)\\n        if n < 2: \\n            return 0\\n        if k >= n // 2: # problem 122. Best Time to Buy and Sell Stock II\\n            max_profit = 0\\n            for i in range(n - 1):\\n                max_profit += max(prices[i+1] - prices[i], 0)\\n            return max_profit\\n        dp = [[0 for _ in range(k+1)] for _ in range(n)]\\n        for k1 in range(1, k+1):\\n            local_max = -prices[0]\\n            for i in range(1, n):\\n                dp[i][k1] = max(dp[i-1][k1], prices[i] + local_max)\\n                local_max = max(local_max, dp[i-1][k1-1] - prices[i])\\n        return dp[n-1][k]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 54150,
                "title": "state-machine-is-the-easiest-way-to-understand-stock-problem-could-solve-all-the-stock-problem-in-leetcode",
                "content": "\\n[looking for the state machine picture, please click here][1]\\n\\n[inspired from this link][2]\\n\\n\\n      class Solution {\\n        public:\\n            int maxProfit(int k, vector<int>& prices) {\\n                int m = prices.size();\\n                if(m==0 || m==1 || k == 0) return 0;\\n                if (k>m/2){ // simple case\\n                    int ans = 0;\\n                    for (int i=1; i<m; ++i){\\n                        ans += max(prices[i] - prices[i-1],0);\\n                    }\\n                    return ans;\\n                }\\n                vector<vector<int>> buy(k+1,vector<int>(m+1,0));\\n                vector<vector<int>> sell(k+1,vector<int>(m+1,0));\\n                vector<int> end(m+1,0);\\n                for(int i=1;i<=k;i++)\\n                    buy[i][0] = INT_MIN;\\n                for(int i=1;i<=m;i++){\\n                    for(int j=1;j<=k;j++){\\n                        //for the first buy state, need to compare the current price with the previous price. sell[0][0] are all initialized with 0, then sell[0][0] - prices[i-1] is the price of current first buy state\\n                        buy[j][i] = max(buy[j][i-1], sell[j-1][i-1] - prices[i-1]);\\n                        sell[j][i] = max(buy[j][i-1]+prices[i-1],sell[j][i-1]);\\n                    }\\n                }\\n                return sell[k][m];\\n            }\\n        };\\n\\n\\n  \\n\\n\\n  [1]: http://y74i.imgup.net/IMG_2016069497.jpg\\n  [2]: https://leetcode.com/discuss/72030/share-my-dp-solution-by-state-machine-thinking",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int maxProfit(int k, vector<int>& prices) {\\n                int m = prices.size();\\n                if(m==0 || m==1 || k == 0) return 0;\\n                if (k>m/2){ // simple case\\n                    int ans = 0;\\n                    for (int i=1; i<m; ++i){\\n                        ans += max(prices[i] - prices[i-1],0);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2555893,
                "title": "java-easy-solution-with-explanation-beginner-friendly",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        if (k == 0) {\\n            return 0;\\n        }\\n        \\n        int[] buy = new int[k]; // buy[i]: min cost at (i + 1)-th time stock purchased\\n        int[] sell = new int[k]; // sell[i]: max revenue at (i + 1)-th time stock sold\\n        Arrays.fill(buy, Integer.MIN_VALUE);\\n        Arrays.fill(sell, 0);\\n        \\n        for (int i : prices) {\\n            buy[0] = Math.max(buy[0], i * -1);\\n            sell[0] = Math.max(sell[0], buy[0] + i);\\n            for (int j = 1; j < k; j++) { // The i-th time buy & sell depens on the (i - 1)-th time buy & sell\\n                buy[j] = Math.max(buy[j], sell[j - 1] - i);\\n                sell[j] = Math.max(sell[j], buy[j] + i);\\n            }\\n        }\\n        return sell[k - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        if (k == 0) {\\n            return 0;\\n        }\\n        \\n        int[] buy = new int[k]; // buy[i]: min cost at (i + 1)-th time stock purchased\\n        int[] sell = new int[k]; // sell[i]: max revenue at (i + 1)-th time stock sold\\n        Arrays.fill(buy, Integer.MIN_VALUE);\\n        Arrays.fill(sell, 0);\\n        \\n        for (int i : prices) {\\n            buy[0] = Math.max(buy[0], i * -1);\\n            sell[0] = Math.max(sell[0], buy[0] + i);\\n            for (int j = 1; j < k; j++) { // The i-th time buy & sell depens on the (i - 1)-th time buy & sell\\n                buy[j] = Math.max(buy[j], sell[j - 1] - i);\\n                sell[j] = Math.max(sell[j], buy[j] + i);\\n            }\\n        }\\n        return sell[k - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54203,
                "title": "accepted-python-solution-with-explanation-inspired-by-leetcoders",
                "content": "    def maxProfit(self, k, prices):\\n        \"\"\"\\n        :type k: int\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        #The problem is hard\\n        #Time complexity, O(nk)\\n        #Space complexity, O(nk)\\n        length = len(prices)\\n        if length < 2:\\n            return 0\\n        max_profit = 0\\n        #if k>= n/2, then it can't complete k transactions. The problem becomes buy-and-sell problem 2\\n        if k>=length/2:\\n            for i in xrange(1,length):\\n                max_profit += max(prices[i]-prices[i-1],0)\\n            return max_profit\\n        \\n        #max_global[i][j] is to store the maximum profit, at day j, and having i transactions already\\n        #max_local[i][j] is to store the maximum profit at day j, having i transactions already, and having transaction at day j\\n        max_global = [[0]*length for _ in xrange(k+1)]\\n        max_local = [[0]*length for _ in xrange(k+1)]\\n\\n        #i indicates the transaction times, j indicates the times\\n        for j in xrange(1,length):\\n            cur_profit = prices[j]-prices[j-1] #variable introduced by the current day transaction\\n            for i in xrange(1,k+1):\\n                #max_global depends on max_local, so updata local first, and then global.\\n                max_local[i][j] = max( max_global[i-1][j-1]+max(cur_profit,0), max_local[i][j-1] + cur_profit)\\n                #if cur_profit <0, then the current transaction loses money, so max_local[i][j] = max_global[i-1][j-1]\\n                #else, it can be max_global[i-1][j-1] + cur_profit, by considering the current transaction\\n                #or it can be max_local[i][j-1] + cur_profit, this is to CANCEL the last day transaction and moves to the current transaction. Note this doesn't change the total number of transactions. Also, max_local[i-1] has already been considered by max_global[i-1] term\\n                max_global[i][j] = max(max_global[i][j-1], max_local[i][j])\\n                #This is more obvious, by looking at whether transaction on day j has influenced max_global or not. \\n        return max_global[k][-1] #the last day, the last transaction\\n\\nThe problem is hard. I looked at many solutions, and find this (type of) solution is easier to understand.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def maxProfit(self, k, prices):\\n        \"\"\"\\n        :type k: int\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        #The problem is hard\\n        #Time complexity, O(nk)\\n        #Space complexity, O(nk)\\n        length = len(prices)\\n        if length < 2:\\n            return 0\\n        max_profit = 0\\n        #if k>= n/2, then it can't complete k transactions. The problem becomes buy-and-sell problem 2\\n        if k>=length/2:\\n            for i in xrange(1,length):\\n                max_profit += max(prices[i]-prices[i-1],0)\\n            return max_profit\\n        \\n        #max_global[i][j] is to store the maximum profit, at day j, and having i transactions already\\n        #max_local[i][j] is to store the maximum profit at day j, having i transactions already, and having transaction at day j\\n        max_global = [[0]*length for _ in xrange(k+1)]\\n        max_local = [[0]*length for _ in xrange(k+1)]\\n\\n        #i indicates the transaction times, j indicates the times\\n        for j in xrange(1,length):\\n            cur_profit = prices[j]-prices[j-1] #variable introduced by the current day transaction\\n            for i in xrange(1,k+1):\\n                #max_global depends on max_local, so updata local first, and then global.\\n                max_local[i][j] = max( max_global[i-1][j-1]+max(cur_profit,0), max_local[i][j-1] + cur_profit)\\n                #if cur_profit <0, then the current transaction loses money, so max_local[i][j] = max_global[i-1][j-1]\\n                #else, it can be max_global[i-1][j-1] + cur_profit, by considering the current transaction\\n                #or it can be max_local[i][j-1] + cur_profit, this is to CANCEL the last day transaction and moves to the current transaction. Note this doesn't change the total number of transactions. Also, max_local[i-1] has already been considered by max_global[i-1] term\\n                max_global[i][j] = max(max_global[i][j-1], max_local[i][j])\\n                #This is more obvious, by looking at whether transaction on day j has influenced max_global or not. \\n        return max_global[k][-1] #the last day, the last transaction\\n\\nThe problem is hard. I looked at many solutions, and find this (type of) solution is easier to understand.",
                "codeTag": "Python3"
            },
            {
                "id": 638137,
                "title": "all-variants-of-best-time-to-buy-and-sell-stock-problems",
                "content": "\\n1. Atmost 1 Transaction      [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) Easy \\n2. Infinite Transactions        [Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/) Easy \\n3. Atmost K Transactions \\n\\t\\ti.    [Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/) Hard\\n\\t\\tii. [Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/) Hard\\n\\t\\t\\n.\\n1. **Atmost 1 Transaction - Kadane\\'s algorithm**\\n\\n```\\n public int maxProfit(int[] prices) {\\n        int maxEndingHere = 0;\\n\\t\\tint maxSoFar = 0;\\n\\t\\tfor (int i = 1; i < prices.length; i++) {\\n\\t\\t\\tmaxEndingHere = Math.max(0, maxEndingHere+prices[i] - prices[i - 1]);\\n\\t\\t\\tmaxSoFar = Math.max(maxSoFar, maxEndingHere);\\n\\t\\t}\\n\\t\\treturn maxSoFar;\\n    }\\n```\\nTime : O(n)\\nSpace: O(1)\\n\\n**2. Infinite Transactions**\\n\\tIf you have increase in price compared to previous price, add it to profit\\n```\\n public int maxProfit(int[] prices) {\\n        int profit = 0;\\n\\t\\tfor (int i = 0; i < prices.length - 1; i++) {\\n\\t\\t\\tif (prices[i + 1] > prices[i]) {\\n\\t\\t\\t\\tprofit += prices[i+1] - prices[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn profit;\\n    }\\n```\\nTime : O(n)\\nSpace: O(1)\\n\\n**3. Atmost K Transactions**\\nThe third & fourth requires DP & are almost the same. If you solve for generic K, you can use the same for specfic K=2.\\n\\nI would recommend to watch this video.\\nhttps://www.youtube.com/watch?v=oDhu5uGq_ic\\n\\n```\\nDP: \\ndp[i][j] = Max(dp[i][j-1],prices[j]-prices[m]+dp[i-1][m])\\nm = 0..j-1\\n\\ndp[i][j-1]                     -> if you are not making a transaction on day j\\nprices[j]-prices[m]+dp[i-1][m] -> if you are making a transaction on day j, find the m th day to buy the stock \\ni = no of transactions\\nj = prices.length\\n\\nTime: O(k * n * n) \\nSpace: O(k * n) \\nk = K transactions\\nn = prices.length\\n```\\n**Optimized DP** \\n```\\nmaxDiff = Max(maxDiff,dp[i-1][j-1] - prices[j-1])\\ndp[i][j] = Max(dp[i][j-1],prices[j]+maxDiff)\\n\\ndp[i][j-1]                     -> if you are not making a transaction on day j\\nprices[j]-prices[m]+dp[i-1][m] -> if you are making a transaction on day j, compute the maxDiff from 0 ..j-1. In other words, we are reusing the maxDiff computed before. This reduces O(n) time complexity \\n\\nTime: O(k * n) \\nSpace: O(k * n) \\nk = K transactions\\nn = prices.length\\n```\\n**Best Time to Buy and Sell Stock III : Atmost 2 transactions**\\n\\n```\\n public int maxProfit(int[] prices) {\\n       if(prices.length ==0)\\n            return 0;\\n       int k=2;\\n       int dp[][] = new int[k + 1][prices.length];\\n\\t\\tfor (int i = 1; i < dp.length; i++) {\\n\\t\\t\\tint maxDiff = -prices[0];\\n\\t\\t\\tfor (int j = 1; j < dp[0].length; j++) {\\n\\t\\t\\t\\tmaxDiff = Math.max(maxDiff, dp[i - 1][j - 1] - prices[j - 1]);\\n\\t\\t\\t\\tdp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[k][prices.length - 1];\\n    }\\n```\\nTime: O(k * n) \\nSpace: O(k * n) \\nk = K transactions\\nn = prices.length\\n\\n**Best Time to Buy and Sell Stock IV :**\\n```\\n\\tpublic int maxProfit(int k, int[] prices) {\\n\\t\\tif (k >= prices.length / 2)\\n\\t\\t\\treturn maxProfit(prices); // This is to avoid Memory Limit Exceeded for one of the test cases. In other words, you can make infinite transactions. Using variant 2 logic. \\n\\t\\tint dp[][] = new int[k + 1][prices.length];\\n\\t\\tfor (int i = 1; i < dp.length; i++) {\\n\\t\\t\\tint maxDiff = -prices[0];\\n\\t\\t\\tfor (int j = 1; j < dp[0].length; j++) {\\n\\t\\t\\t\\tmaxDiff = Math.max(maxDiff, dp[i - 1][j - 1] - prices[j - 1]);\\n\\t\\t\\t\\tdp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[k][prices.length - 1];\\n\\t}\\n\\n\\tprivate int maxProfit(int[] prices) {\\n        int profit = 0;\\n\\t\\tfor (int i = 0; i < prices.length - 1; i++) {\\n\\t\\t\\tif (prices[i + 1] > prices[i]) {\\n\\t\\t\\t\\tprofit += prices[i+1] - prices[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn profit;\\n    }\\n```\\nTime: O(k * n) \\nSpace: O(k * n) \\nk = K transactions\\nn = prices.length\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n public int maxProfit(int[] prices) {\\n        int maxEndingHere = 0;\\n\\t\\tint maxSoFar = 0;\\n\\t\\tfor (int i = 1; i < prices.length; i++) {\\n\\t\\t\\tmaxEndingHere = Math.max(0, maxEndingHere+prices[i] - prices[i - 1]);\\n\\t\\t\\tmaxSoFar = Math.max(maxSoFar, maxEndingHere);\\n\\t\\t}\\n\\t\\treturn maxSoFar;\\n    }\\n```\n```\\n public int maxProfit(int[] prices) {\\n        int profit = 0;\\n\\t\\tfor (int i = 0; i < prices.length - 1; i++) {\\n\\t\\t\\tif (prices[i + 1] > prices[i]) {\\n\\t\\t\\t\\tprofit += prices[i+1] - prices[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn profit;\\n    }\\n```\n```\\nDP: \\ndp[i][j] = Max(dp[i][j-1],prices[j]-prices[m]+dp[i-1][m])\\nm = 0..j-1\\n\\ndp[i][j-1]                     -> if you are not making a transaction on day j\\nprices[j]-prices[m]+dp[i-1][m] -> if you are making a transaction on day j, find the m th day to buy the stock \\ni = no of transactions\\nj = prices.length\\n\\nTime: O(k * n * n) \\nSpace: O(k * n) \\nk = K transactions\\nn = prices.length\\n```\n```\\nmaxDiff = Max(maxDiff,dp[i-1][j-1] - prices[j-1])\\ndp[i][j] = Max(dp[i][j-1],prices[j]+maxDiff)\\n\\ndp[i][j-1]                     -> if you are not making a transaction on day j\\nprices[j]-prices[m]+dp[i-1][m] -> if you are making a transaction on day j, compute the maxDiff from 0 ..j-1. In other words, we are reusing the maxDiff computed before. This reduces O(n) time complexity \\n\\nTime: O(k * n) \\nSpace: O(k * n) \\nk = K transactions\\nn = prices.length\\n```\n```\\n public int maxProfit(int[] prices) {\\n       if(prices.length ==0)\\n            return 0;\\n       int k=2;\\n       int dp[][] = new int[k + 1][prices.length];\\n\\t\\tfor (int i = 1; i < dp.length; i++) {\\n\\t\\t\\tint maxDiff = -prices[0];\\n\\t\\t\\tfor (int j = 1; j < dp[0].length; j++) {\\n\\t\\t\\t\\tmaxDiff = Math.max(maxDiff, dp[i - 1][j - 1] - prices[j - 1]);\\n\\t\\t\\t\\tdp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[k][prices.length - 1];\\n    }\\n```\n```\\n\\tpublic int maxProfit(int k, int[] prices) {\\n\\t\\tif (k >= prices.length / 2)\\n\\t\\t\\treturn maxProfit(prices); // This is to avoid Memory Limit Exceeded for one of the test cases. In other words, you can make infinite transactions. Using variant 2 logic. \\n\\t\\tint dp[][] = new int[k + 1][prices.length];\\n\\t\\tfor (int i = 1; i < dp.length; i++) {\\n\\t\\t\\tint maxDiff = -prices[0];\\n\\t\\t\\tfor (int j = 1; j < dp[0].length; j++) {\\n\\t\\t\\t\\tmaxDiff = Math.max(maxDiff, dp[i - 1][j - 1] - prices[j - 1]);\\n\\t\\t\\t\\tdp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[k][prices.length - 1];\\n\\t}\\n\\n\\tprivate int maxProfit(int[] prices) {\\n        int profit = 0;\\n\\t\\tfor (int i = 0; i < prices.length - 1; i++) {\\n\\t\\t\\tif (prices[i + 1] > prices[i]) {\\n\\t\\t\\t\\tprofit += prices[i+1] - prices[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn profit;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 54198,
                "title": "dp-o-kn-time-o-n-space-cpp-solution",
                "content": "if k >= n/2,  we can have transactions any time, it can be solved by O(n).\\n\\nelse, we can do it in DP.\\n\\nuse dp[k][i+1] represents, The max profit of using [0,i] data and k transactions.\\n\\nSo we have:\\n\\ndp[k][i+1] = max(dp[k-1][i+1], dp[k][i], max( dp[k-1][j]  + prices[i] - prices[j] ))\\n\\n= max(dp[k-1][i+1], dp[k][i], prices[i] + max( dp[k-1][j] - prices[j] )) { 0 <= j < i }\\n\\nit can be solved by O(kn).\\n\\n\\nThe Code:\\n\\n\\n    class Solution {\\n    public:\\n        int maxProfit_all(vector<int> &prices) {\\n            int n = prices.size();\\n            int sum = 0;\\n            for(int i = 1;i < n;i++){\\n                if(prices[i] > prices[i-1]){\\n                    sum += prices[i] - prices[i-1];\\n                }\\n            }\\n            return sum;\\n        }\\n        int maxProfit(int k, vector<int> &prices) {\\n            int n = prices.size();\\n            if(k >= n/2){\\n                return maxProfit_all(prices);    \\n            }\\n            int dp[2][n+1];\\n            memset(dp,0,sizeof(dp));\\n            for(int t = 1; t <= k; t++){\\n                int cur_max = 0x80000000;\\n                dp[t%2][0] = 0;\\n                for(int i = 0; i < n; i++){\\n                    dp[t%2][i+1] = max(dp[(t+1)%2][i+1],max(dp[t%2][i],prices[i] + cur_max));\\n                    cur_max = max(cur_max,dp[(t+1)%2][i] - prices[i]);\\n                }\\n            }\\n            return dp[k%2][n];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxProfit_all(vector<int> &prices) {\\n            int n = prices.size();\\n            int sum = 0;\\n            for(int i = 1;i < n;i++){\\n                if(prices[i] > prices[i-1]){\\n                    sum += prices[i] - prices[i-1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1465937,
                "title": "pictures-to-explain-both-o-nk-dp-solution-and-non-dp-o-n-stack-solution",
                "content": "\\n**1. O(nk) DP solution**\\n\\nFirst let\\'s nail down the state transition function,\\n\\n![image](https://assets.leetcode.com/users/images/da3cd218-6f92-43e1-918d-bd01495716e0_1631736468.7804964.png)\\n\\nBtw, some folks could end up with the 3 dimentional form and get a worse solution with time complexity of ![image](https://assets.leetcode.com/users/images/3e49013a-656a-4ab2-b108-19c15323b99a_1631737013.63085.png)\\n\\n![image](https://assets.leetcode.com/users/images/ef615154-bf16-4ee9-8b54-848b25e5144a_1631736807.8626459.png)\\n\\nTo avoid this you should always start deducing your state transition function from lower dimention first. Let\\'s focus on the first transition function. It\\'s easy to translate from the transition function to code:\\n\\n```\\nfor i from 0 to n-1\\n{\\n\\tfor k from 0 to K\\n\\t{\\n\\t\\tdp[i][k] = dp[i-1][k]; // if prices[i] is not selected\\n\\t\\tfor p from 0 to i\\n\\t\\t{\\n\\t\\t\\tdp[i][k] = max(dp[i][k] , dp[p-1][k-1] + prices[i] - prices[p]); // if prices[i] is selected\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\nwell, this seems still O(k*n^2), why a 2d DP[n][k] ends up being O(k*n^2)? Are we doing any dup operation? \\nYes, we are doing duplicate recalculations in below line, actually prices[i] can be moved out of the formula,\\n\\n`dp[i][k] = max(dp[i][k] , dp[p-1][k-1] + prices[i] - prices[p]); // if prices[i] is selected`\\n\\nequivalently it can be:\\n\\n`dp[i][k] = max(dp[i][k] , max(dp[p-1][k-1] - prices[p]) + prices[i]);`\\n\\nmax(dp[p-1][k-1] - prices[p]), 0<p<i, this max value can be pre-calculated and saved when we iterate i, then we can reduce from O(n) to O(1) \\n\\n\\nThen we get the O(kn) solution:\\n\\n```\\n   for (int k = 1; k <= K; k++) {\\n            int pre_max =  -prices[0];\\n            for (int i = 1; i < len; i++) {\\n                dp[i][k] = max(dp[i-1][k], prices[i] + pre_max);\\n                pre_max =  max(pre_max, dp[i - 1][k - 1] - prices[i]);  // save the max of dp[p-1][k-1]  - prices[p]\\n            }\\n        }\\n```\\n\\nThis is the solution [the top answer](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/54113/A-Concise-DP-Solution-in-Java) gives.\\n\\n**2. O(n) stack solution**\\n\\nThis question has a non-DP solution which is particular to this question itself. People never too greedy in stock market, some always want to buy at the lowest and sell at the highest point as a long term trade, some want to do short term swing trade and make even more. Bear this in mind, we already know that it is reasonable to collapse v1, p1, v2 ,p2 to v1, p2 when v1< v2 and p1 < p2 in order to make more in one transaction.\\n\\nTake [4, 8, 6, 8, 7, 9, 4, 5] and k=2 as an example, we can list all the possible single transaction we can do and sort the gains in decending order, then try to search the whole list from beginning to end to find the one whose indexes are not conflicting with ones already selected. Obviously this is at lease O(n^2) solution. \\n\\n![image](https://assets.leetcode.com/users/images/07573ae1-860f-4ff7-8c53-7b8133b59249_1631746126.7154567.png)\\n\\nLet\\'s think about a better solution, think about how many pattern that the numbers can fall into, the example we use above does\\'t cover all the patterns, let\\'s pick some better numbers and list the patterns it could have:\\n**there are basically 4 patterns:**\\n \\n```\\n\\tv1    p1       v2    p2\\n\\t\\n\\t4      9       8     12        // v2 >= v1, p2 >= p1, can collapse to (4, 12)\\n\\t\\n\\t4     12       8      9        // v2 >= v1, p2 < p1, can\\'t collapse for now but (4 , 12) be possible to collapse later with the numbers coming after 9\\n\\t\\n\\t8     12       4      9        // v2 < v1, p2 < p1, (4, 9) possible to collapse later, (8, 12) can only be taken as a single transaction\\n\\t\\n\\t8      9       4     12        // v2 < v1, p2 <= p1,   same as above\\n\\t\\n```\\n\\nThis is kind of like[ longest valid parenthesis match](https://leetcode.com/problems/longest-valid-parentheses/discuss/1424432/0-ms-faster-than-100.00-of-C%2B%2B-homework-for-the-Sophomore-in-computer-science), where we use stack to collapse a pair of \\'(\\', \\')\\' to nothing.\\n\\nLet\\'s try to use stack to process each prices[i] and try to collapse the new prices[i] with the old prices[i-1] on the top of stack: \\n\\n\\n```\\n\\t(v1    p1)    (v2    p2)       // (v1, p1) is on the top of the stack, (v2, p2) is the current pair under processing\\n\\t\\n\\t4      9       8     12        // v2 >= v1, p2 >= p1, collapse into one new pair, pop out the top to vector, push in the new pair \\n\\t\\n\\t4     12       8      9        // v2 >= v1, p2 < p1, push in the current pair \\n\\t\\n\\t8     12       4      9        // v2 < v1, p2 < p1, pop out the top to vector, push in the current pair\\n\\t\\n\\t8      9       4     12        // v2 < v1, p2 <= p1,   same as above\\n\\t\\n```\\n\\nCan the above stack solution work? No. the conflicting index issue is still there. We need solve it.\\n\\nNow we come to the core of this solution, there is one trick we need to leverage, that is, \\n\\nFor example we have a lengthy sequence of pairs which can fall into the first \"collapse\" pattern:\\n![image](https://assets.leetcode.com/users/images/5da7f6d5-9292-4ede-a826-83bc4d167151_1631751810.962142.png)\\n\\nthe following equation is always true:\\n\\n![image](https://assets.leetcode.com/users/images/669a5ec2-90bf-4f5a-8a77-2d4ec4f8404e_1631750814.7802377.png)\\n\\nit is true also for partial sum: \\n![image](https://assets.leetcode.com/users/images/2bf1ced7-57d5-4c33-a932-4fa9817a8ae9_1631750834.9336944.png)\\n\\n\\n**What\\'s the meaning of the equation as above?**\\n\\nThis means we collapse from n to t+1 to get one transaztion, from t to 1 to get another transation, then we can get the sum of these two transactions, we can easily to expand this to 3, 4, or more collapses(transactions), e.g. collapse from n to t, from t-1 to k, from k-1 to m, from m-1 to 1 and so on.\\n\\n![image](https://assets.leetcode.com/users/images/aef4f438-d61a-4319-b696-51492ce807f4_1631751432.2669985.png)\\n\\n\\nNow we know when we collapse two pairs (V1, P1) (V2, P2), we need to record the value of (P1 - V2), for example collapse (4, 9) (8, 12) to (4, 12) and keep the value of 9-8 = 1, which can be summed with 12-4 = 8 later when we need to take (4, 9) (8, 12) as two transaction to get more benefit.\\n\\n\\nThis ends up with the implementation in [this answer](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/54145/O(n)-time-8ms-Accepted-Solution-with-Detailed-Explanation-(C%2B%2B)):\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n\\n        // Step 1: Find out all profit opportunities            \\n        vector<int> profits;\\n        stack<pair<int, int>> vps; // valley-peak pairs\\n        \\n        int v;\\n        int p = -1;\\n        for (;;) {\\n            // find next valley-peak pair\\n            for (v = p+1; (v+1 < prices.size()) && (prices[v] >= prices[v+1]); ++v);\\n            for (p = v  ; (p+1 < prices.size()) && (prices[p] <= prices[p+1]); ++p);\\n            \\n            if (v == p) { // v==p means that both v and p reach the end of the array\\n                break;\\n            }\\n            \\n            // Consider two transactions (v1, p1) (back of the stack) and (v2, p2) (the new-found).\\n            // If prices[v1] >= prices[v2], \\n            // it is meaningless to combine the two transactions.\\n            // Save of profit of (v1, p1), and pop it out of the record.\\n            while ((!vps.empty()) && (prices[v] <= prices[vps.top().first])) {\\n                profits.push_back(prices[vps.top().second] - prices[vps.top().first]);\\n                vps.pop();\\n            }\\n            \\n            // If prices[v1]<prices[v2] and prices[p1]<prices[p2], \\n            // then it is meaningful to combine the two transactions\\n            // update (v1, p1) to (v1, p2), and save the profit of (v2, p1)\\n            while ((!vps.empty()) && (prices[p] >= prices[vps.top().second])) {\\n                profits.push_back(prices[vps.top().second] - prices[v]);\\n                v = vps.top().first;\\n                vps.pop();\\n            }\\n            \\n            // save the new-found valley-peak pair\\n            vps.emplace(v, p);\\n        }\\n        \\n        // save all remaining profits\\n        while (!vps.empty()) {\\n            profits.push_back(prices[vps.top().second] - prices[vps.top().first]);\\n            vps.pop();\\n        }\\n        \\n        // Step 2: Calculate the k highest profits\\n        int ret;\\n        if (profits.size() <= k) {\\n            ret = accumulate(profits.begin(), profits.end(), 0);\\n        } else {\\n            nth_element(profits.begin(), profits.end() - k, profits.end());\\n            ret = accumulate(profits.end() - k, profits.end(), 0);\\n        }\\n        return ret;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nfor i from 0 to n-1\\n{\\n\\tfor k from 0 to K\\n\\t{\\n\\t\\tdp[i][k] = dp[i-1][k]; // if prices[i] is not selected\\n\\t\\tfor p from 0 to i\\n\\t\\t{\\n\\t\\t\\tdp[i][k] = max(dp[i][k] , dp[p-1][k-1] + prices[i] - prices[p]); // if prices[i] is selected\\n\\t\\t}\\n\\t}\\n}\\n```\n```\\n   for (int k = 1; k <= K; k++) {\\n            int pre_max =  -prices[0];\\n            for (int i = 1; i < len; i++) {\\n                dp[i][k] = max(dp[i-1][k], prices[i] + pre_max);\\n                pre_max =  max(pre_max, dp[i - 1][k - 1] - prices[i]);  // save the max of dp[p-1][k-1]  - prices[p]\\n            }\\n        }\\n```\n```\\n\\tv1    p1       v2    p2\\n\\t\\n\\t4      9       8     12        // v2 >= v1, p2 >= p1, can collapse to (4, 12)\\n\\t\\n\\t4     12       8      9        // v2 >= v1, p2 < p1, can\\'t collapse for now but (4 , 12) be possible to collapse later with the numbers coming after 9\\n\\t\\n\\t8     12       4      9        // v2 < v1, p2 < p1, (4, 9) possible to collapse later, (8, 12) can only be taken as a single transaction\\n\\t\\n\\t8      9       4     12        // v2 < v1, p2 <= p1,   same as above\\n\\t\\n```\n```\\n\\t(v1    p1)    (v2    p2)       // (v1, p1) is on the top of the stack, (v2, p2) is the current pair under processing\\n\\t\\n\\t4      9       8     12        // v2 >= v1, p2 >= p1, collapse into one new pair, pop out the top to vector, push in the new pair \\n\\t\\n\\t4     12       8      9        // v2 >= v1, p2 < p1, push in the current pair \\n\\t\\n\\t8     12       4      9        // v2 < v1, p2 < p1, pop out the top to vector, push in the current pair\\n\\t\\n\\t8      9       4     12        // v2 < v1, p2 <= p1,   same as above\\n\\t\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n\\n        // Step 1: Find out all profit opportunities            \\n        vector<int> profits;\\n        stack<pair<int, int>> vps; // valley-peak pairs\\n        \\n        int v;\\n        int p = -1;\\n        for (;;) {\\n            // find next valley-peak pair\\n            for (v = p+1; (v+1 < prices.size()) && (prices[v] >= prices[v+1]); ++v);\\n            for (p = v  ; (p+1 < prices.size()) && (prices[p] <= prices[p+1]); ++p);\\n            \\n            if (v == p) { // v==p means that both v and p reach the end of the array\\n                break;\\n            }\\n            \\n            // Consider two transactions (v1, p1) (back of the stack) and (v2, p2) (the new-found).\\n            // If prices[v1] >= prices[v2], \\n            // it is meaningless to combine the two transactions.\\n            // Save of profit of (v1, p1), and pop it out of the record.\\n            while ((!vps.empty()) && (prices[v] <= prices[vps.top().first])) {\\n                profits.push_back(prices[vps.top().second] - prices[vps.top().first]);\\n                vps.pop();\\n            }\\n            \\n            // If prices[v1]<prices[v2] and prices[p1]<prices[p2], \\n            // then it is meaningful to combine the two transactions\\n            // update (v1, p1) to (v1, p2), and save the profit of (v2, p1)\\n            while ((!vps.empty()) && (prices[p] >= prices[vps.top().second])) {\\n                profits.push_back(prices[vps.top().second] - prices[v]);\\n                v = vps.top().first;\\n                vps.pop();\\n            }\\n            \\n            // save the new-found valley-peak pair\\n            vps.emplace(v, p);\\n        }\\n        \\n        // save all remaining profits\\n        while (!vps.empty()) {\\n            profits.push_back(prices[vps.top().second] - prices[vps.top().first]);\\n            vps.pop();\\n        }\\n        \\n        // Step 2: Calculate the k highest profits\\n        int ret;\\n        if (profits.size() <= k) {\\n            ret = accumulate(profits.begin(), profits.end(), 0);\\n        } else {\\n            nth_element(profits.begin(), profits.end() - k, profits.end());\\n            ret = accumulate(profits.end() - k, profits.end(), 0);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326825,
                "title": "complete-explanation-of-the-buy-and-sell-stock-problems-using-dp",
                "content": "I will be going over what I have learned while trying to solve these problems. I was initially using `Kadane\\'s algorithm` to do these problems. Infact, completed the first, second, and third **Buy and Sell Stock problems** using Kadane\\'s but the fourth problem gave me a concussion so, I embarked on a journey to learn a framework using which I can solve the complete set of these problems and handle any tweaks that an interviewer might throw at me in the future. I visited a number of resources, watched a number of videos and here is the culmination of everything I have picked so far.\\n\\nThese are all the problems we have in the Buy and Sell Stock set.\\n1. [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\\n2. [Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)\\n3. [Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)\\n4. [Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)\\n5. [Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)\\n6. [Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)\\n\\nFirst, we will see how we can come up with a framework which we can apply for all the above problems. A framework which is flexible enough to accomodate any tweaks an interviewer might throw at us in the future. *A framework which exhausts all the possible outcomes and then come up with the best solution*. A recursive solution would be exhaustive but we will use \"states\" for exhaustion in these problems. **We will consider each day and see how many possible \"states\" do we have for each day and then find \"choices\" corresponding to each state.**\\n\\n**Let\\'s talk about the constraints first.**\\n1. `Sell` must be after `Buy`.\\n2. `Buy` must be after `Sell`.\\n3.  Limit on the number of transaction(k), `k>0`.\\n\\n**For each day we have three choices.**\\n1. `Buy`.\\n2. `Sell`.\\n3. `Rest`. Which further has two states.\\n\\t a. `Rest after buy`. Here we are holding the stock. We are not selling or buying. We are just resting.\\n\\t b. `Rest after selling`. Here we are not holding any stocks. We are not selling or buying. We are just resting.\\n\\n**Let\\'s talk about the states now.**\\n1. The day we are on i.e `i`.\\n2. The maximum number of allowed transactions i.e `k`.\\n3. The holding state i.e the resting state we talked about before. This is either `1(holding stock)` or `0(not holding stock)`.\\n\\nNow, we can put all the combinations of these states in a 3D matrix like so :\\n\\n```\\nfor 0 <= i <= n:             // n is the number of days\\n\\tfor i <= k <= k:        // k is the maximum number of transactions\\n\\t\\tfor s in {1,0}:    // s is the rest state\\n\\t\\t\\t\\tdp[i][k][s] = max(buy,sell,rest)\\n```\\n\\n\\n***For every problem we have to find the `dp[n-1][k][0]`, which is the maximum profit for the maximum number of transactions allowed on the last day.***\\n\\nOne important observation. Why didn\\'t we say **`dp[n-1][k][1]`** instead of saying **`dp[n-1][k][0]`**? because if the resting state `S` is 1, it means we are still holding a stock and the profit cannot be maximum until and unless we are done selling all the stocks we have.\\n\\n\\n\\n\\nNow, let\\'s think about what choices do we have for each state and how we can update the \"state\". Let\\'s write our state transition equations. They will be something like this.\\n\\n`dp[i][k][0] = Max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) // prices is the array of stocks`\\n\\n***This equation corresponds to when you are not holding a stock. You are not holding a stock today because perhaps you didn\\'t have any stocks yesterday which we could sell today or maybe you have stocks that you want to sell today, so at the end of the day we will not be holding any stocks.***\\n\\n`dp[i][k][1] = Max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])`\\n\\n***This equation corresponds to when you are holding a stock. You are holding a stock today because perhaps you had stocks yesterday or maybe you want to buy stocks today, so at the end of the day we will be holding stocks.***\\n\\n***This explanation should be clear. If you buy, you need to subtract prices[i] from the profit, and if you sell, you need to increase prices[i] to the profit.***\\n\\n\\nNow, let\\'s talk about the base cases.\\n\\n1. `dp[-1][k][0]  = 0`     **// Because the day starts with 0 and here i is -1**\\n2. `dp[-1][k][1] = -Infinity`  **// Because we can\\'t hold any stocks before the first day**\\n3. `dp[i][0][0] = 0`  **// Because k = 0. There won\\'t be any transactions so the profit will be zero** \\n4. `dp[i][0][1] = -Infinity`  **// Because k = 0. We can\\'t hold any stocks without starting a transaction** \\n\\n\\nSo, to summarize the above base conditions and state transition equations\\n\\n```\\nbase case\\uFF1A\\ndp[-1][k][0] = dp[i][0][0] = 0\\ndp[-1][k][1] = dp[i][0][1] = -infinity\\n\\nstate transition equation\\uFF1A\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\\n```\\n\\n\\nNow, let\\'s begin with the problems.\\n\\n1. ***When k = 1***\\n\\nWe will put k = 1 directly in the state transition equations and see for ourselves.\\n\\n```\\ndp[i][1][0] = Max(dp[i-1][1][0], dp[i-1][1][1] + prices[i];\\ndp[i][1][1] = Max(dp[i-1][1][1], dp[i-1][0][0] - prices[i];\\n\\t        = Max(dp[i-1][1][1], 0 - prices[i];  // from the above base case when k is 0\\n```\\n\\nWe can also see that the presence of k when it is 1 does not change the state in any way so, we can simply ignore it.\\n\\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], -prices[i])\\n```\\n\\nWe can write the solution for it like so:\\n\\n```\\nvar maxProfit = function(prices){\\n  let n = prices.length;\\n  let dp = [];\\n  \\n  for(let i=0; i<n; i++){\\n    dp[i] = [];\\n    if(i-1 === -1){\\n      dp[i][0] = 0; \\n        // Explanation\\uFF1A\\n        //   dp[i][0] \\n        // = max(dp[-1][0], dp[-1][1] + prices[i])\\n        // = max(0, -infinity + prices[i]) = 0\\n      dp[i][1] = -prices[i];\\n        // Explanation\\uFF1A\\n        //   dp[i][1] \\n        // = max(dp[-1][1], dp[-1][0] - prices[i])\\n        // = max(-infinity, 0 - prices[i]) \\n        // = -prices[i]\\n      continue;\\n    }\\n    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);\\n    dp[i][1] = Math.max(dp[i-1][1],  -prices[i])\\n  }\\n  return dp[n-1][0];\\n}\\n```\\n\\n***We can reduce the Space complexity to 0(1) by not constructing the DP matrix as the new state is only related to an adjacent state. So, instead of the DP matrix we can store the states in a single variable. One variable for not holding and one for holding.***\\n\\nCode for that would look something like :\\n\\n```\\nvar maxProfit = function(prices){\\n  let d_i10 = 0;\\n  let d_i11 = -Infinity;\\n  \\n  for(let i=0; i<prices.length;i++){\\n    d_i10 = Math.max(d_i10, d_i11 + prices[i]);\\n    d_i11 = Math.max(d_i11, 0 - prices[i]);\\n  }\\n  return d_i10;\\n}\\n```\\n\\n2. ***When k = + Infinity***\\n\\nWhen k is Infinity, k and k-1 are practically the same. We will use that in our state transition equations.\\n\\n\\n```\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\\n            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]) // k and k-1 are the same\\n```\\n\\nSince, the presence of k is not really impacting the states, we will ignore it.\\n\\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\\n```\\n\\nAnd the solution would look like this : \\n\\n```\\nvar maxProfit = function(prices){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0 - prices[i]);\\n  }\\n  return d_ik0;\\n}\\n```\\n\\n\\n3. ***When k = 2***\\n\\nNow, we need to exhaust the value of k as well. Before this we were ignoring k because it was not impacting our states. We need to hold the states for the second transaction as well along with the first transaction. \\n\\n```\\ndp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])\\ndp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])\\ndp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])\\ndp[i][1][1] = max(dp[i-1][1][1], -prices[i])\\n```\\n\\nThe solution would look like this :\\n\\n```\\nvar maxProfit = function(prices){\\n  let d_i20 = 0;\\n  let d_i21 = -Infinity; // base case for second transaction\\n  let d_i10 = 0;\\n  let d_i11 = -Infinity; //base case for second transaction\\n  \\n  for(let i=0; i<prices.length; i++){\\n    d_i10 = Math.max(d_i10, d_i11 + prices[i]);\\n    d_i11 = Math.max(d_i11,  0 - prices[i]);\\n    d_i20 = Math.max(d_i20, d_i21 + prices[i]);\\n    d_i21 = Math.max(d_i21, d_i10 - prices[i]);\\n   \\n  }\\n  return d_i20\\n}\\n```\\n\\n\\n4. ***When k = + interger***\\n\\n**Important observation** : A transaction consists of buying and selling, which takes atleast 2 days. Therefore, the effective limit k should not exceed n/2( n is the number of days). If it exceeds, there is no contraint effect which makes k equivalent to +Infinity.\\n\\nThis is the only problem from this set which is a little difficult.\\n\\nSolution would look like this \\n```\\nvar maxProfit = function(k, prices) {\\n    if(prices.length == 0) return 0;\\n    \\n    // When k becomes so much larger than the number of prices we can make transactions whenever.\\n    if(k > (prices.length / 2) ){\\n      let d_ik0 = 0;\\n      let d_ik1 =  -Infinity;\\n      for(let i =0; i<prices.length;i++){\\n        d_ik0 = Math.max(d_ik0, d_ik1 + prices[i]);\\n        d_ik1 = Math.max(d_ik1, d_ik0 - prices[i]);\\n      }\\n      return d_ik0\\n    }\\n    else{\\n        let dp = [];\\n        let size = prices.length;\\n        for(let i=0; i<size; i++){\\n          dp[i] = [];\\n          for(let j=0; j<=k; j++){\\n            dp[i][j] = []\\n            if(i-1 === -1 || j-1 === -1){\\n              dp[i][j][0] = 0;\\n              dp[i][j][1] = -prices[i];\\n              continue;\\n            }\\n            dp[i][j][0] = Math.max(dp[i-1][j][0], dp[i-1][j][1] + prices[i]);\\n            dp[i][j][1] = Math.max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])\\n          }\\n        }\\n      return dp[size-1][k][0]\\n    }\\n};\\n```\\n\\n5. ***When k = +Infinity with cooldown***\\n\\nWe must wait one day after selling a stock to continue trading. We can write the state transition equations as :\\n\\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])\\nExplanation: When we choose to buy on day i, the state of i-2 should be transferred instead of i-1\\n```\\n\\nCode would look like \\n\\n```\\nvar maxProfit = function(prices){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  let d_ik0_pre = 0;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    let d_ik0_old = d_ik0; \\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0_pre - prices[i]);\\n    d_ik0_pre = d_ik0_old;\\n  }\\n  return d_ik0;\\n}\\n```\\n\\n\\n\\n6. ***When k = +Infinity with transaction fee***\\n\\nSince now we need to pay some fee for each transaction made, the profit after buying or selling the stock on the i-th day should be subtracted by this amount, therefore the new recurrence relations will be either\\n\\n```\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i] - fee)\\n\\nor\\n\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i] - fee)\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])\\n```\\n\\nCode can we written as  :\\n\\n```\\nvar maxProfit = function(prices, fee){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0 - prices[i] - fee);\\n  }\\n  return d_ik0;\\n}\\n```\\n\\n\\nI hope you enjoyed this post.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfor 0 <= i <= n:             // n is the number of days\\n\\tfor i <= k <= k:        // k is the maximum number of transactions\\n\\t\\tfor s in {1,0}:    // s is the rest state\\n\\t\\t\\t\\tdp[i][k][s] = max(buy,sell,rest)\\n```\n```\\nbase case\\uFF1A\\ndp[-1][k][0] = dp[i][0][0] = 0\\ndp[-1][k][1] = dp[i][0][1] = -infinity\\n\\nstate transition equation\\uFF1A\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\\n```\n```\\ndp[i][1][0] = Max(dp[i-1][1][0], dp[i-1][1][1] + prices[i];\\ndp[i][1][1] = Max(dp[i-1][1][1], dp[i-1][0][0] - prices[i];\\n\\t        = Max(dp[i-1][1][1], 0 - prices[i];  // from the above base case when k is 0\\n```\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], -prices[i])\\n```\n```\\nvar maxProfit = function(prices){\\n  let n = prices.length;\\n  let dp = [];\\n  \\n  for(let i=0; i<n; i++){\\n    dp[i] = [];\\n    if(i-1 === -1){\\n      dp[i][0] = 0; \\n        // Explanation\\uFF1A\\n        //   dp[i][0] \\n        // = max(dp[-1][0], dp[-1][1] + prices[i])\\n        // = max(0, -infinity + prices[i]) = 0\\n      dp[i][1] = -prices[i];\\n        // Explanation\\uFF1A\\n        //   dp[i][1] \\n        // = max(dp[-1][1], dp[-1][0] - prices[i])\\n        // = max(-infinity, 0 - prices[i]) \\n        // = -prices[i]\\n      continue;\\n    }\\n    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);\\n    dp[i][1] = Math.max(dp[i-1][1],  -prices[i])\\n  }\\n  return dp[n-1][0];\\n}\\n```\n```\\nvar maxProfit = function(prices){\\n  let d_i10 = 0;\\n  let d_i11 = -Infinity;\\n  \\n  for(let i=0; i<prices.length;i++){\\n    d_i10 = Math.max(d_i10, d_i11 + prices[i]);\\n    d_i11 = Math.max(d_i11, 0 - prices[i]);\\n  }\\n  return d_i10;\\n}\\n```\n```\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\\n            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]) // k and k-1 are the same\\n```\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\\n```\n```\\nvar maxProfit = function(prices){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0 - prices[i]);\\n  }\\n  return d_ik0;\\n}\\n```\n```\\ndp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])\\ndp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])\\ndp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])\\ndp[i][1][1] = max(dp[i-1][1][1], -prices[i])\\n```\n```\\nvar maxProfit = function(prices){\\n  let d_i20 = 0;\\n  let d_i21 = -Infinity; // base case for second transaction\\n  let d_i10 = 0;\\n  let d_i11 = -Infinity; //base case for second transaction\\n  \\n  for(let i=0; i<prices.length; i++){\\n    d_i10 = Math.max(d_i10, d_i11 + prices[i]);\\n    d_i11 = Math.max(d_i11,  0 - prices[i]);\\n    d_i20 = Math.max(d_i20, d_i21 + prices[i]);\\n    d_i21 = Math.max(d_i21, d_i10 - prices[i]);\\n   \\n  }\\n  return d_i20\\n}\\n```\n```\\nvar maxProfit = function(k, prices) {\\n    if(prices.length == 0) return 0;\\n    \\n    // When k becomes so much larger than the number of prices we can make transactions whenever.\\n    if(k > (prices.length / 2) ){\\n      let d_ik0 = 0;\\n      let d_ik1 =  -Infinity;\\n      for(let i =0; i<prices.length;i++){\\n        d_ik0 = Math.max(d_ik0, d_ik1 + prices[i]);\\n        d_ik1 = Math.max(d_ik1, d_ik0 - prices[i]);\\n      }\\n      return d_ik0\\n    }\\n    else{\\n        let dp = [];\\n        let size = prices.length;\\n        for(let i=0; i<size; i++){\\n          dp[i] = [];\\n          for(let j=0; j<=k; j++){\\n            dp[i][j] = []\\n            if(i-1 === -1 || j-1 === -1){\\n              dp[i][j][0] = 0;\\n              dp[i][j][1] = -prices[i];\\n              continue;\\n            }\\n            dp[i][j][0] = Math.max(dp[i-1][j][0], dp[i-1][j][1] + prices[i]);\\n            dp[i][j][1] = Math.max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])\\n          }\\n        }\\n      return dp[size-1][k][0]\\n    }\\n};\\n```\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])\\nExplanation: When we choose to buy on day i, the state of i-2 should be transferred instead of i-1\\n```\n```\\nvar maxProfit = function(prices){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  let d_ik0_pre = 0;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    let d_ik0_old = d_ik0; \\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0_pre - prices[i]);\\n    d_ik0_pre = d_ik0_old;\\n  }\\n  return d_ik0;\\n}\\n```\n```\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i] - fee)\\n\\nor\\n\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i] - fee)\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])\\n```\n```\\nvar maxProfit = function(prices, fee){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0 - prices[i] - fee);\\n  }\\n  return d_ik0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 655837,
                "title": "python-very-detailed-explanation-with-thought-process-dp",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : DP ##\\n        ## LOGIC ##\\n        \"\"\"\\n        1. Intuition : just like any other DP problem we have to start with basic sub problem. sub problem here is what is the maxProfit for k=1, k=2 ... k=k. So, draw matrix (K x N).\\n        Example : \\n                k = 2\\n                prices = [6,4,8,6,8,7,8,9]\\n        2. Formula is below, its better if we understand this with example. as words dont make sense.\\n                \\n                dp[i][j] = maximum of   a) dp[i][j-1]\\n                                        b) dp[i-1][x] + (prices[j] - prices[x]) (for all x in range of 0 to j-1)\\n                        \\n                        6   4   8   6   8   7   8   9\\n                k = 1   0   0   4   4   4   4   5   6\\n                k = 2   0   0   4   4   6   6  ???      \\n                \\n                for the position  k=2, price = 8.\\n                ??? = max of a) 6\\n                             b) max of (4 + 8 - 7) or ( 4 + 8 - 8 ) or ( 4 + 8 - 6 ) or ( 4 + 8 - 8 ) or ( 0 + 8 - 4 ) [ i.e for all x in range of 0 to j-1, profit from previous transaction till that position x i.e dp[i-1][x] and plus the profit if you buy at position x and sell at position j.(i.e prices[j] - prices[x]). We get the maximum of all values ]\\n                    \\n                ??? = 9\\n                    \\n        3. OPTIMIZATION : when you carefully observe the for loop where x = 0 to j-1, we are calculating dp[i-1][x] + prices[j] - prices[x].\\n        In that equation, prices[j] wont change, so we have to find maximum of ( dp[i-1][x] - prices[x] ) for 0 to j-1.\\n        instead of looping with x = [0,j-1]. In the j loop itself as we are filling the dp[i][j] we calculate the dp[i-1][x] - prices[x] and store the maximum.\\n        \\n        4. Edge case: # ( k = 10000000, n = 1000) k > n//2 indicates all possible transactions must happen. so we do best time to buy and sell stocks II.\\n        \\n        5. Further we can reduce the space complexicity using only 2 dp rows.\\n        \"\"\"\\n        \\n        n = len(prices)\\n        if not n: return 0\\n        dp = [ [0 for j in range(n)] for i in range(k+1) ]\\n        for i in range(1, k+1):\\n            for j in range(1, n):\\n                maxpr = 0\\n                for x in range(j, -1, -1):\\n                    maxpr = max(maxpr, dp[i-1][x] + ( prices[j] - prices[x] ) )\\n                dp[i][j] = max( dp[i][j-1], maxpr )\\n        return dp[-1][-1]\\n        \\n        ## OPTIMIZED TO O(KN) ##\\n        # EDGE CASE\\n        max_profit = 0\\n        if k >= n / 2:\\n            for i in range(1, n):\\n                max_profit += max(prices[i] - prices[i-1], 0)\\n            return max_profit\\n        \\n        dp = [ [0 for j in range(n)] for i in range(k+1) ]\\n        for i in range(1, k+1):\\n            maxpr = -prices[0]\\n            for j in range(1, n):\\n                dp[i][j] = max( dp[i][j-1], maxpr + prices[j] )\\n                maxpr = max( maxpr, -prices[j] + dp[i-1][j] )\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : DP ##\\n        ## LOGIC ##\\n        \"\"\"\\n        1. Intuition : just like any other DP problem we have to start with basic sub problem. sub problem here is what is the maxProfit for k=1, k=2 ... k=k. So, draw matrix (K x N).\\n        Example : \\n                k = 2\\n                prices = [6,4,8,6,8,7,8,9]\\n        2. Formula is below, its better if we understand this with example. as words dont make sense.\\n                \\n                dp[i][j] = maximum of   a) dp[i][j-1]\\n                                        b) dp[i-1][x] + (prices[j] - prices[x]) (for all x in range of 0 to j-1)\\n                        \\n                        6   4   8   6   8   7   8   9\\n                k = 1   0   0   4   4   4   4   5   6\\n                k = 2   0   0   4   4   6   6  ???      \\n                \\n                for the position  k=2, price = 8.\\n                ??? = max of a) 6\\n                             b) max of (4 + 8 - 7) or ( 4 + 8 - 8 ) or ( 4 + 8 - 6 ) or ( 4 + 8 - 8 ) or ( 0 + 8 - 4 ) [ i.e for all x in range of 0 to j-1, profit from previous transaction till that position x i.e dp[i-1][x] and plus the profit if you buy at position x and sell at position j.(i.e prices[j] - prices[x]). We get the maximum of all values ]\\n                    \\n                ??? = 9\\n                    \\n        3. OPTIMIZATION : when you carefully observe the for loop where x = 0 to j-1, we are calculating dp[i-1][x] + prices[j] - prices[x].\\n        In that equation, prices[j] wont change, so we have to find maximum of ( dp[i-1][x] - prices[x] ) for 0 to j-1.\\n        instead of looping with x = [0,j-1]. In the j loop itself as we are filling the dp[i][j] we calculate the dp[i-1][x] - prices[x] and store the maximum.\\n        \\n        4. Edge case: # ( k = 10000000, n = 1000) k > n//2 indicates all possible transactions must happen. so we do best time to buy and sell stocks II.\\n        \\n        5. Further we can reduce the space complexicity using only 2 dp rows.\\n        \"\"\"\\n        \\n        n = len(prices)\\n        if not n: return 0\\n        dp = [ [0 for j in range(n)] for i in range(k+1) ]\\n        for i in range(1, k+1):\\n            for j in range(1, n):\\n                maxpr = 0\\n                for x in range(j, -1, -1):\\n                    maxpr = max(maxpr, dp[i-1][x] + ( prices[j] - prices[x] ) )\\n                dp[i][j] = max( dp[i][j-1], maxpr )\\n        return dp[-1][-1]\\n        \\n        ## OPTIMIZED TO O(KN) ##\\n        # EDGE CASE\\n        max_profit = 0\\n        if k >= n / 2:\\n            for i in range(1, n):\\n                max_profit += max(prices[i] - prices[i-1], 0)\\n            return max_profit\\n        \\n        dp = [ [0 for j in range(n)] for i in range(k+1) ]\\n        for i in range(1, k+1):\\n            maxpr = -prices[0]\\n            for j in range(1, n):\\n                dp[i][j] = max( dp[i][j-1], maxpr + prices[j] )\\n                maxpr = max( maxpr, -prices[j] + dp[i-1][j] )\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54204,
                "title": "clean-java-dp-o-nk-solution-with-o-k-space",
                "content": "Extend small_box's idea for \"Best Time to Buy and Sell Stock III\" to general case.\\n[https://leetcode.com/discuss/18330/is-it-best-solution-with-o-n-o-1][1]\\n\\n    public int maxProfit(int k, int[] prices) {\\n        if(k>=prices.length/2){\\n            int maxProfit = 0;\\n            for(int i=1; i<prices.length; i++){\\n                if(prices[i]>prices[i-1]) maxProfit += prices[i]-prices[i-1];\\n            }\\n            return maxProfit;\\n        }\\n        \\n        int[] maxProfit = new int[k+1];\\n        int[] lowPrice = new int[k+1];\\n        for(int i=0; i<lowPrice.length; i++) lowPrice[i]=Integer.MAX_VALUE;\\n        for(int p : prices){\\n            for(int i=k; i>=1; i--){\\n                maxProfit[i] = Math.max(maxProfit[i],p-lowPrice[i]);\\n                lowPrice[i] = Math.min(lowPrice[i],p-maxProfit[i-1]);\\n            }\\n        }\\n        return maxProfit[k];\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/18330/is-it-best-solution-with-o-n-o-1",
                "solutionTags": [],
                "code": "Extend small_box's idea for \"Best Time to Buy and Sell Stock III\" to general case.\\n[https://leetcode.com/discuss/18330/is-it-best-solution-with-o-n-o-1][1]\\n\\n    public int maxProfit(int k, int[] prices) {\\n        if(k>=prices.length/2){\\n            int maxProfit = 0;\\n            for(int i=1; i<prices.length; i++){\\n                if(prices[i]>prices[i-1]) maxProfit += prices[i]-prices[i-1];\\n            }\\n            return maxProfit;\\n        }\\n        \\n        int[] maxProfit = new int[k+1];\\n        int[] lowPrice = new int[k+1];\\n        for(int i=0; i<lowPrice.length; i++) lowPrice[i]=Integer.MAX_VALUE;\\n        for(int p : prices){\\n            for(int i=k; i>=1; i--){\\n                maxProfit[i] = Math.max(maxProfit[i],p-lowPrice[i]);\\n                lowPrice[i] = Math.min(lowPrice[i],p-maxProfit[i-1]);\\n            }\\n        }\\n        return maxProfit[k];\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/18330/is-it-best-solution-with-o-n-o-1",
                "codeTag": "Unknown"
            },
            {
                "id": 900151,
                "title": "python-o-nk-dynamic-programming-explained",
                "content": "This problem is just extension of problem **123. Best Time to Buy and Sell Stock III**\\n\\nExplanations are exactly the same as problem 123: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/794633/Python-O(n)-solution-with-optimization-explained\\n\\n**Complexity**: time and space complexity is `O(nk)`, space comlexity can be improved to `O(k)`\\n\\n```\\nclass Solution:\\n    def maxProfit(self, k, prices):\\n        if len(prices) <= 1 or k == 0: return 0\\n        \\n        delta = [prices[i+1]-prices[i] for i in range (len(prices)-1)]\\n        B=[sum(delta) for _, delta in groupby(delta, key=lambda x: x < 0)]\\n        n = len(B) + 1\\n\\n        if k > len(prices)//2: return sum(x for x in B if x > 0)\\n        \\n        dp = [[0]*(k+1) for _ in range(n-1)] \\n        mp = [[0]*(k+1) for _ in range(n-1)] \\n\\n        dp[0][1], mp[0][1] = B[0], B[0]\\n\\n        for i in range(1, n-1):\\n            for j in range(1, k+1):\\n                dp[i][j] = max(mp[i-1][j-1], dp[i-1][j]) + B[i]\\n                mp[i][j] = max(dp[i][j], mp[i-1][j])\\n\\n        return max(mp[-1])\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, k, prices):\\n        if len(prices) <= 1 or k == 0: return 0\\n        \\n        delta = [prices[i+1]-prices[i] for i in range (len(prices)-1)]\\n        B=[sum(delta) for _, delta in groupby(delta, key=lambda x: x < 0)]\\n        n = len(B) + 1\\n\\n        if k > len(prices)//2: return sum(x for x in B if x > 0)\\n        \\n        dp = [[0]*(k+1) for _ in range(n-1)] \\n        mp = [[0]*(k+1) for _ in range(n-1)] \\n\\n        dp[0][1], mp[0][1] = B[0], B[0]\\n\\n        for i in range(1, n-1):\\n            for j in range(1, k+1):\\n                dp[i][j] = max(mp[i-1][j-1], dp[i-1][j]) + B[i]\\n                mp[i][j] = max(dp[i][j], mp[i-1][j])\\n\\n        return max(mp[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 298738,
                "title": "python-solution-faster-than-99-5-with-full-analysis",
                "content": "Simple explanation:\\n\\n1. Preprocess to remove all intermediate price points\\n2. Merge two consecutive trades or remove a trade to minimise the loss in profit, whichever is smaller\\n3. Repeat until we have k trades left \\n\\nDetailed explanation:\\n\\n1. As a first step, before we try to search for any solution, we can potentially reduce the number of prices we need to look at by observing that it can never be optimal to buy at some price at time t p(t) when the following price p(t+1) is lower than it. Conversely, it can never be optimal to sell at p(t) when p(t+1) is higher. So we can start by removing all \"intermediate\" prices, leaving us a consecutive set of buy and sell price points. Not only does this preprocessing reduce the number of prices, but it makes the next part of the problem much simpler, since buys and sells now have a structural relationship: in our cut-down vector of prices, every p(t) where t % 2 == 0 will be a buy, and every p(t) where t % 2 == 1 will be a sell. This is important, since it means we no longer need to search for entries/exits; we already know where they all will be.\\n2. Now we know that we\\'re constrained by the number of trades we can make. If k >= len(prices)/2, i.e. if we are allowed to make an equal or greater number of trades than the number of trades actually possible, then our optimal solution is simply to sum the difference of the consecutive buys and sells.\\n3. But now consider what happens when this isn\\'t the case. Suppose k trades are permitted, but we have k+1 possible trades from which to choose. To meet the constraint, we need to cull one of the possible trades, which we can do in one of two ways: we can either *merge* two consecutive trades or we can *remove* a trade, If we merge two trades, at best we\\'ll end up with a single trade that was as profitable as the pair of trades we merged; it cannot be more profitable. So we need to find the merge that will incur the least loss of profit.\\n4. The cost of merging two trades, assuming we have the vector p(t), p(t+1), p(t+2), p(t+3) is p(t+1) - p(t) + p(t+3) - p(t+2) - (p(t+3) - p(t)); in other words, the sum of the profit from making the two trades as before, less the profit from merging them together and just performing one trade between p(t) and p(t+3). Simplifying this, we get a cost function of p(t+1) - p(t+2). But merging trades might not be our best option. Suppose instead we decide to remove one. Our cost function here, assuming we buy at p(t) and sell at p(t+1), is just p(t+1) - p(t). So what we want to do is find the minimum from both cost functions, and then either delete one trade or merge two trade, depending on which has least impact on our profit.\\n5. But when we look at the cost functions again, we see they are actually the same thing! One is the difference between a closing sell and the next opening buy; the other is the difference between a sell and the previous buy. So all we actually need to minimise is the absolute difference p(t+1) - p(t) for all p\\n6. And the rest is simple. Starting with the set of all possible trades, we just keep on removing the one with the smallest cost until we are left with k trades. Then we sum the profit from each trade to give our answer.\\n\\n\\'\\'\\'\\nclass Solution:\\n    def getPriceReversals(prices):\\n      opt_prices = []\\n      buying = True\\n      i = 0\\n\\n      for i in range(0, len(prices)):\\n        if buying and (i != len(prices)-1 and prices[i+1] > prices[i]):\\n          opt_prices.append(prices[i]); buying = False\\n        else:\\n          if not buying and (i == len(prices)-1 or prices[i+1] < prices[i]): \\n            opt_prices.append(prices[i]); buying = True\\n      return opt_prices\\n\\n    def merge(prices):\\n      best_merge = 0\\n      best_merge_cost = sys.maxsize\\n\\n      for i in range(0, len(prices)-1):\\n        if abs(prices[i+1] - prices[i]) < best_merge_cost:\\n          best_merge = i\\n          best_merge_cost = abs(prices[best_merge+1] - prices[best_merge])\\n\\n      del(prices[best_merge : best_merge+2])\\n\\n    def simpleSum(prices):\\n      sum = 0\\n      for i in range(0, len(prices), 2):\\n        sum += prices[i+1] - prices[i]\\n      return sum\\n\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        if (k == 0):\\n          return 0\\n\\n        opt_prices = Solution.getPriceReversals(prices)\\n\\n        while len(opt_prices)/2 > k:\\n            Solution.merge(opt_prices)\\n\\t\\t\\t\\n        return Solution.simpleSum(opt_prices)\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "Simple explanation:\\n\\n1. Preprocess to remove all intermediate price points\\n2. Merge two consecutive trades or remove a trade to minimise the loss in profit, whichever is smaller\\n3. Repeat until we have k trades left \\n\\nDetailed explanation:\\n\\n1. As a first step, before we try to search for any solution, we can potentially reduce the number of prices we need to look at by observing that it can never be optimal to buy at some price at time t p(t) when the following price p(t+1) is lower than it. Conversely, it can never be optimal to sell at p(t) when p(t+1) is higher. So we can start by removing all \"intermediate\" prices, leaving us a consecutive set of buy and sell price points. Not only does this preprocessing reduce the number of prices, but it makes the next part of the problem much simpler, since buys and sells now have a structural relationship: in our cut-down vector of prices, every p(t) where t % 2 == 0 will be a buy, and every p(t) where t % 2 == 1 will be a sell. This is important, since it means we no longer need to search for entries/exits; we already know where they all will be.\\n2. Now we know that we\\'re constrained by the number of trades we can make. If k >= len(prices)/2, i.e. if we are allowed to make an equal or greater number of trades than the number of trades actually possible, then our optimal solution is simply to sum the difference of the consecutive buys and sells.\\n3. But now consider what happens when this isn\\'t the case. Suppose k trades are permitted, but we have k+1 possible trades from which to choose. To meet the constraint, we need to cull one of the possible trades, which we can do in one of two ways: we can either *merge* two consecutive trades or we can *remove* a trade, If we merge two trades, at best we\\'ll end up with a single trade that was as profitable as the pair of trades we merged; it cannot be more profitable. So we need to find the merge that will incur the least loss of profit.\\n4. The cost of merging two trades, assuming we have the vector p(t), p(t+1), p(t+2), p(t+3) is p(t+1) - p(t) + p(t+3) - p(t+2) - (p(t+3) - p(t)); in other words, the sum of the profit from making the two trades as before, less the profit from merging them together and just performing one trade between p(t) and p(t+3). Simplifying this, we get a cost function of p(t+1) - p(t+2). But merging trades might not be our best option. Suppose instead we decide to remove one. Our cost function here, assuming we buy at p(t) and sell at p(t+1), is just p(t+1) - p(t). So what we want to do is find the minimum from both cost functions, and then either delete one trade or merge two trade, depending on which has least impact on our profit.\\n5. But when we look at the cost functions again, we see they are actually the same thing! One is the difference between a closing sell and the next opening buy; the other is the difference between a sell and the previous buy. So all we actually need to minimise is the absolute difference p(t+1) - p(t) for all p\\n6. And the rest is simple. Starting with the set of all possible trades, we just keep on removing the one with the smallest cost until we are left with k trades. Then we sum the profit from each trade to give our answer.\\n\\n\\'\\'\\'\\nclass Solution:\\n    def getPriceReversals(prices):\\n      opt_prices = []\\n      buying = True\\n      i = 0\\n\\n      for i in range(0, len(prices)):\\n        if buying and (i != len(prices)-1 and prices[i+1] > prices[i]):\\n          opt_prices.append(prices[i]); buying = False\\n        else:\\n          if not buying and (i == len(prices)-1 or prices[i+1] < prices[i]): \\n            opt_prices.append(prices[i]); buying = True\\n      return opt_prices\\n\\n    def merge(prices):\\n      best_merge = 0\\n      best_merge_cost = sys.maxsize\\n\\n      for i in range(0, len(prices)-1):\\n        if abs(prices[i+1] - prices[i]) < best_merge_cost:\\n          best_merge = i\\n          best_merge_cost = abs(prices[best_merge+1] - prices[best_merge])\\n\\n      del(prices[best_merge : best_merge+2])\\n\\n    def simpleSum(prices):\\n      sum = 0\\n      for i in range(0, len(prices), 2):\\n        sum += prices[i+1] - prices[i]\\n      return sum\\n\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        if (k == 0):\\n          return 0\\n\\n        opt_prices = Solution.getPriceReversals(prices)\\n\\n        while len(opt_prices)/2 > k:\\n            Solution.merge(opt_prices)\\n\\t\\t\\t\\n        return Solution.simpleSum(opt_prices)\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1103113,
                "title": "easy-knapsack-pattern-3d-dp-top-down-memoization-accepted-code",
                "content": "x=0 denotes the state when you\\'ve to buy and stock & x=1 represents the state when you\\'ve to sell a stock. Rest of the explanation has been attempted through comments in the code.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>> dp; //3D DP memoization\\n    int solve(vector<int> &prices, int i, int x, int k){\\n        if(i>=prices.size() or k==0) return 0; //Base Case\\n        if(dp[i][k][x]!=-1) return dp[i][k][x];\\n        int profit=0;\\n        if(x==0){\\n            int Buy= solve(prices, i+1, 1, k)-prices[i]; //if we buy a stock then we recurse on rest of the array, subtract prices[i] from the current profit and change state to x=1 (selling)\\n            int noBuy= solve(prices, i+1, 0, k); //if we do not buy a stock then we simply recurse on the rest of the array and the state remains the same x=0 (buying)\\n            profit=max(Buy, noBuy);\\n        }\\n        else if(x==1){\\n            int Sell= solve(prices, i+1, 0, k-1)+prices[i]; //if we sell a stock then we recurse on rest of the array and add prices[i] to the current profit, state changes to x=0 (Buying) and k decreseas by 1 since a transaction is complete\\n            int noSell= solve(prices, i+1, 1, k); //if we do not sell a stock then we recurse on rest of the array, state remains the same (=1 for selling)\\n            profit=max(Sell, noSell);\\n        }\\n        return dp[i][k][x]= profit;\\n    }\\n    \\n    int maxProfit(int k, vector<int>& prices){\\n        dp= vector<vector<vector<int>>>(prices.size()+1, vector<vector<int>>(k+1, vector<int>(2, -1)));\\n        return solve(prices, 0, 0, k); //we start from i=0 and x=0 since we\\'ve to buy a stock initially\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>> dp; //3D DP memoization\\n    int solve(vector<int> &prices, int i, int x, int k){\\n        if(i>=prices.size() or k==0) return 0; //Base Case\\n        if(dp[i][k][x]!=-1) return dp[i][k][x];\\n        int profit=0;\\n        if(x==0){\\n            int Buy= solve(prices, i+1, 1, k)-prices[i]; //if we buy a stock then we recurse on rest of the array, subtract prices[i] from the current profit and change state to x=1 (selling)\\n            int noBuy= solve(prices, i+1, 0, k); //if we do not buy a stock then we simply recurse on the rest of the array and the state remains the same x=0 (buying)\\n            profit=max(Buy, noBuy);\\n        }\\n        else if(x==1){\\n            int Sell= solve(prices, i+1, 0, k-1)+prices[i]; //if we sell a stock then we recurse on rest of the array and add prices[i] to the current profit, state changes to x=0 (Buying) and k decreseas by 1 since a transaction is complete\\n            int noSell= solve(prices, i+1, 1, k); //if we do not sell a stock then we recurse on rest of the array, state remains the same (=1 for selling)\\n            profit=max(Sell, noSell);\\n        }\\n        return dp[i][k][x]= profit;\\n    }\\n    \\n    int maxProfit(int k, vector<int>& prices){\\n        dp= vector<vector<vector<int>>>(prices.size()+1, vector<vector<int>>(k+1, vector<int>(2, -1)));\\n        return solve(prices, 0, 0, k); //we start from i=0 and x=0 since we\\'ve to buy a stock initially\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555642,
                "title": "c-recursion-to-space-optimization-3-approaches",
                "content": "**Please upvote if you like the post :)**\\n\\n**Learned From:** TakeUForward(Aka **Striver**)\\n\\n**Intuition:**\\n\\n**Every day**, we will have **two** choices, either to do nothing and move to the next day or to buy/sell (based on the last transaction and the number of transactions left) and find out the **profit**. Therefore we need to generate all the choices in order to compare the profit. As we need to try out all the possible choices, we will use **recursion** and then further optimize it using **Dp** because of overlapping sub-problems. \\n### Recursive Solution:\\n\\n**Approach:(Recursion)**\\n\\n**Step 1:**\\n* Express the problem in terms of **indexes**.\\n* We need to think in the terms of the number of **days**, therefore one variable will be the array index( say ind). \\n* Next, we need to keep in mind the condition that we **can\\u2019t** buy a stock again, that is we need to **first sell** a stock, and then we can buy that again. Therefore we need a second variable \\u2018**buy**\\u2019 which tells us on a `particular day` whether `we can buy or sell the stock`. \\n* And Lastly, we have a cap on the number of transactions that we can make. \\n* Here the initial cap is `K`.We need to always keep in mind this constraint.\\n* So the function is something like - f(ind,buy,cap)\\n\\n **Step 2:**\\n* We need to try out all possible choices at a given `index`.\\n* Every day we have two choices either to **buy/sell**(keeping in mind the cap) or do **nothing** and move to the next day.\\n* When **buy==0**, we can **buy** a stock. \\n* Now if we have the choice to buy that means again we have two choices either `we buy the stock` i.e {**-prices[i] + f(ind+1,1, cap)**} or `we do nothing and move to the next day`  i,e  {0+**f(ind+1,0, cap)**}\\n* When **buy==1**, we can **sell** a stock. \\n* Now if we have the choice to sell that means again we have two choices either` we sell the stock` i.e {**prices[i] + f(ind+1,0, cap)**} or `we do nothing and move to the next day` i,e  {0+**f(ind+1,1, cap)**}\\n\\n **Step 3:**\\n*  As we are looking to **maximize** the **profit** earned, we will return the **maximum** value in both cases.\\n\\n**C++:(Recursion)**\\n```\\nclass Solution {\\npublic:\\n    int getAns(vector<int>& prices, int n, int ind, int buy, int cap,vector<vector<vector<int>>>& dp ){\\n        if(ind==n || cap==0) return 0; //base case\\n        if(dp[ind][buy][cap]!=-1) return dp[ind][buy][cap];\\n        int profit;\\n        if(buy==0){// We can buy the stock\\n            profit = max(0+getAns(prices,n,ind+1,0,cap,dp), -prices[ind] + getAns(prices,n,ind+1,1,cap,dp));\\n        }\\n        if(buy==1){// We can sell the stock\\n            profit = max(0+getAns(prices,n,ind+1,1,cap,dp),prices[ind] + getAns(prices,n,ind+1,0,cap-1,dp));\\n        }\\n        return dp[ind][buy][cap] = profit;\\n    }\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(2,vector<int>(k+1,-1)));\\n        return getAns(prices,n,0,0,k,dp);\\n    }\\n};\\n\\n```\\n****\\n**Time Complexity:** **O(N*2x3)**\\n**Space Complexity:** **O(Nx2*K) + O(N)**\\n****\\n### **Recursive Solution to Tabulation:**\\n\\n**Approach:(Tabulation DP)**\\n* First we declare the **dp** array of size [n+1][2][k+1] as zero.\\n* As we have initialized the array as `0`, we have automatically set the **base** condition i.e `if( ind == n || cap == 0) return 0`\\n* Now, when we are traversing the array in the opposite direction of that of the memoization technique. We will start from ind = n-1 -> ind =0, absolutely in the reverse fashion.\\n* In every iteration copy the recursive code logic.\\n* At last dp[0][0][k] ( maximum profit generated on ith day, when we can **buy** the stock on **0th day** and can have a total **k transactions**) gives us the final answer.\\n\\n**C++:(Tabulation)**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(2,vector<int>(k+1,0)));\\n        for(int ind = n-1; ind>=0; ind--){\\n            for(int buy = 0; buy<=1; buy++){\\n                for(int cap=1; cap<=k; cap++){\\n                    if(buy==0){// We can buy the stock\\n                        dp[ind][buy][cap] = max(0+dp[ind+1][0][cap], -prices[ind] + dp[ind+1][1][cap]);\\n                     }\\n                    if(buy==1){// We can sell the stock\\n                        dp[ind][buy][cap] = max(0+dp[ind+1][1][cap],prices[ind] + dp[ind+1][0][cap-1]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0][k];\\n    }\\n};\\n```\\n****\\n**Time Complexity:** **O(N*2xK)**\\n**Space Complexity:** **O(N*2xK)**\\n****\\n### Tabulation to Space Optimization:\\n* If we see carefully, one thing that we can notice is that: **dp[ind][buy][cap] = max( dp[ind+1][buy][cap] , max( dp[ind+1][!buy][cap])**\\n* So, to calculate a value of a cell of the **dp** array, we need only the **next row** values(say ahead of ind+1). So, we don\\u2019t need to store an entire **2-D** array. Hence we can **Space Optimize** it.\\n\\n**Steps:**\\n* We create two **2D** vector ahead and cur both initialized to 0 **(base condition)**\\n* Then we set three nested loops to calculate the cur array\\u2019s values.\\n* We replace `dp[ind]` with cur and `dp[ind+1]` with ahead in our tabulation code.\\n* After the inner loop execution is done, we set **ahead** as **cur** for the next outer loop iteration.\\n* At last, we return **ahead[0][k]** as our answer.\\n\\n**C++:(Space Optimized)**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> ahead(2,vector<int> (k+1,0));\\n        vector<vector<int>> cur(2,vector<int> (k+1,0));\\n        for(int ind = n-1; ind>=0; ind--){\\n            for(int buy = 0; buy<=1; buy++){\\n                for(int cap=1; cap<=k; cap++){\\n                    if(buy==0){// We can buy the stock\\n                        cur[buy][cap] = max(0+ahead[0][cap],-prices[ind] + ahead[1][cap]);\\n                    }\\n                    if(buy==1){// We can sell the stock\\n                        cur[buy][cap] = max(0+ahead[1][cap],prices[ind] + ahead[0][cap-1]);\\n                    }\\n                }\\n            }\\n            ahead = cur;\\n        }\\n        return ahead[0][k];\\n    }\\n};\\n```\\n****\\n**Time Complexity:** **O(N*2xK)**\\n**Space Complexity:** **O(K)** We are using two external arrays of size \\u20182*K\\u2019.\\n****",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getAns(vector<int>& prices, int n, int ind, int buy, int cap,vector<vector<vector<int>>>& dp ){\\n        if(ind==n || cap==0) return 0; //base case\\n        if(dp[ind][buy][cap]!=-1) return dp[ind][buy][cap];\\n        int profit;\\n        if(buy==0){// We can buy the stock\\n            profit = max(0+getAns(prices,n,ind+1,0,cap,dp), -prices[ind] + getAns(prices,n,ind+1,1,cap,dp));\\n        }\\n        if(buy==1){// We can sell the stock\\n            profit = max(0+getAns(prices,n,ind+1,1,cap,dp),prices[ind] + getAns(prices,n,ind+1,0,cap-1,dp));\\n        }\\n        return dp[ind][buy][cap] = profit;\\n    }\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(2,vector<int>(k+1,-1)));\\n        return getAns(prices,n,0,0,k,dp);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(2,vector<int>(k+1,0)));\\n        for(int ind = n-1; ind>=0; ind--){\\n            for(int buy = 0; buy<=1; buy++){\\n                for(int cap=1; cap<=k; cap++){\\n                    if(buy==0){// We can buy the stock\\n                        dp[ind][buy][cap] = max(0+dp[ind+1][0][cap], -prices[ind] + dp[ind+1][1][cap]);\\n                     }\\n                    if(buy==1){// We can sell the stock\\n                        dp[ind][buy][cap] = max(0+dp[ind+1][1][cap],prices[ind] + dp[ind+1][0][cap-1]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0][k];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> ahead(2,vector<int> (k+1,0));\\n        vector<vector<int>> cur(2,vector<int> (k+1,0));\\n        for(int ind = n-1; ind>=0; ind--){\\n            for(int buy = 0; buy<=1; buy++){\\n                for(int cap=1; cap<=k; cap++){\\n                    if(buy==0){// We can buy the stock\\n                        cur[buy][cap] = max(0+ahead[0][cap],-prices[ind] + ahead[1][cap]);\\n                    }\\n                    if(buy==1){// We can sell the stock\\n                        cur[buy][cap] = max(0+ahead[1][cap],prices[ind] + ahead[0][cap-1]);\\n                    }\\n                }\\n            }\\n            ahead = cur;\\n        }\\n        return ahead[0][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398543,
                "title": "c-solution-with-comments-and-representation-recursion-dp-space-optimisation",
                "content": "****\\n***Please upvote if it helps.....***\\n****\\n****\\n****\\n***Solution :***\\n****\\n\\nThis question is quite similar to the question discussed in Buy and Sell Stock III. There we can do at most two transactions whereas here we can do at most K transactions. Therefore, we will modify that approach according to our needs in this section. Readers are highly advised to go through Buy and Sell Stock III first.\\n****\\n***Intuition:***\\n****\\nEvery day, we will have two choices, either to do nothing and move to the next day or to buy/sell (based on the last transaction and the number of transactions left) and find out the profit. Therefore we need to generate all the choices in order to compare the profit. As we need to try out all the possible choices, we will use recursion.\\n****\\n****\\n***Steps to form the recursive solution:*** \\n\\n***Step 1:*** Express the problem in terms of indexes.\\n\\nWe need to think in the terms of the number of days, therefore one variable will be the array index( say ind). Next, we need to respect the condition that we can\\u2019t buy a stock again, that is we need to first sell a stock, and then we can buy that again. Therefore we need a second variable \\u2018buy\\u2019 which tells us on a particular day whether we can buy or sell the stock. Next, we have a cap on the number of transactions that we can make. Here the initial cap is K.We need to always keep in mind this constraint. We can generalize the function as :\\n\\n*  ![image](https://assets.leetcode.com/users/images/34eec949-ea74-4033-a0f0-4e1291145efa_1659973827.5470352.png)\\n\\n\\n***Step 2***: Try out all possible choices at a given index.\\n\\nEvery day, we have two choices:\\n\\n* To either buy/sell the stock(based on the buy variable\\u2019s value and if \\u2018cap\\u2019 > 0). \\n* To do nothing and move on to the next day.\\n.\\n\\n***Case 1:*** When buy == 0, we can buy the stock.\\n\\nIf we can buy the stock on a particular day, we have two options:\\n\\n* ***Option 1:*** To do no transaction and move to the next day. In this case, the net profit earned will be 0 from the current transaction, and to calculate the maximum profit starting from the next day, we will recursively call f(ind+1,0, cap). As we have not bought the stock, the \\u2018buy\\u2019 variable value will still remain 0, indicating that we can buy the stock the next day. And the \\u2018cap\\u2019 variable will remain the same as if no transaction took place.\\n\\n* ***Option 2:*** The other option is to buy the stock on the current day. In this case, the net profit earned from the current transaction will be -Arr[i]. As we are buying the stock, we are giving money out of our pocket, therefore the profit we earn is negative. To calculate the maximum profit starting from the next day, we will recursively call f(ind+1,1, cap). As we have bought the stock, the \\u2018buy\\u2019 variable value will change to 1, indicating that we can\\u2019t buy and only sell the stock the next day. As we have only bought the stock and not sold it the transaction remains incomplete and the \\u2018cap\\u2019 variable value remains unchanged.\\n\\n***Case 2:*** When buy == 1, we can sell the stock.\\n\\nIf we can buy the stock on a particular day, we have two options:\\n\\n***Option 1:*** To do no transaction and move to the next day. In this case, the net profit earned will be 0 from the current transaction, and to calculate the maximum profit starting from the next day, we will recursively call f(ind+1,1, cap). As we have not bought the stock, the \\u2018buy\\u2019 variable value will still remain at 1, indicating that we can\\u2019t buy and only sell the stock the next day. And the \\u2018cap\\u2019 variable will remain the same as if no transaction took place.\\n\\n***Option 2:*** The other option is to sell the stock on the current day. In this case, the net profit earned from the current transaction will be +Arr[i]. As we are selling the stock, we are putting the money into our pocket, therefore the profit we earn is positive. To calculate the maximum profit starting from the next day, we will recursively call f(ind+1,0,cap-1). As we have sold the stock, the \\u2018buy\\u2019 variable value will change to 0, indicating that we can buy the stock the next day. As we have sold the earlier bought stock, we make one complete transaction, therefore now we update the \\u2018cap\\u2019 variable\\u2019s value to cap-1.\\n\\n***Note:*** Buying and selling a stock together counts as one complete transaction.\\n\\nThe figure below gives us the summary:\\n* ![image](https://assets.leetcode.com/users/images/836c4112-2e02-4897-a032-e93cd1d5f6dd_1659973966.2007952.png)\\n* ![image](https://assets.leetcode.com/users/images/f905a58a-fb90-4b80-a878-e8ebf405d870_1659973986.8387861.png)\\n\\n***Step 3:***  ***Return the maximum*** \\n\\nAs we are looking to maximize the profit earned, we will return the maximum value in both cases.\\n****\\n****\\n***Base Cases:***\\n\\n* If ind==n, it means we have finished trading on all days, and there is no more money that we can get, therefore we simply return 0.\\n* If cap==0, it means that we cannot make any more transactions. Therefore we return 0.\\n\\nThe final pseudocode after steps 1, 2, and 3:\\n* ![image](https://assets.leetcode.com/users/images/2bcfe682-4f43-4f38-92ae-ef6807b9bfec_1659974033.2316318.png)\\n\\n****\\n****\\n\\n***Steps to memoize a recursive solution:***\\n\\nIf we draw the recursion tree, we will see that there are overlapping subproblems. In order to convert a recursive solution the following steps will be taken:\\n\\n1. Create a dp array of size [n][2][3]. The size of the input array is \\u2018n\\u2019, so the index will always lie between \\u20180\\u2019 and \\u2018n-1\\u2019. The \\u2018buy\\u2019  variable can take only two values: 0 and 1 and the \\u2018cap\\u2019 variable can only take three variables 0, 1, and 2. Therefore we take the dp array as dp[n][2][3].\\n1. We initialize the dp array to -1.\\n1. Whenever we want to find the answer of particular parameters (say f(ind,buy,cap)), we first check whether the answer is already calculated using the dp array(i.e dp[ind][buy][cap]!= -1 ). If yes, simply return the value from the dp array.\\n1. If not, then we are finding the answer for the given value for the first time, we will use the recursive relation as usual but before returning from the function, we will set dp[ind][buy][cap] to the solution we get.\\n\\n****\\n****\\n***C++ Code:*** \\n****\\n```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nint getAns(vector<int>& Arr, int n, int ind, int buy, int cap, vector<vector<vector<int>>>& dp ){\\n\\n    if(ind==n || cap==0) return 0; //base case\\n    \\n    if(dp[ind][buy][cap]!=-1)\\n        return dp[ind][buy][cap];\\n        \\n    int profit;\\n    \\n    if(buy==0){// We can buy the stock\\n        profit = max(0+getAns(Arr,n,ind+1,0,cap,dp), \\n                    -Arr[ind] + getAns(Arr,n,ind+1,1,cap,dp));\\n    }\\n    \\n    if(buy==1){// We can sell the stock\\n        profit = max(0+getAns(Arr,n,ind+1,1,cap,dp),\\n                    Arr[ind] + getAns(Arr,n,ind+1,0,cap-1,dp));\\n    }\\n    \\n    return dp[ind][buy][cap] = profit;\\n}\\n\\n\\nint maximumProfit(vector<int>& prices, int n, int k)\\n{\\n    // Creating a 3d - dp of size [n][2][k+1]\\n    vector<vector<vector<int>>> dp(n,\\n                                    vector<vector<int>> \\n                                            (2,vector<int>(k+1,-1)));\\n    \\n    return getAns(prices,n,0,0,k,dp);\\n   \\n}\\n\\nint main() {\\n\\n  vector<int> prices = {3,3,5,0,0,3,1,4};\\n  int n = prices.size();\\nint k = 2;\\n                                 \\n  cout<<\"The maximum profit that can be generated is \"<<maximumProfit(prices, n,k);\\n}\\n```\\n****\\n****\\n***Output:***\\n****\\nThe maximum profit that can be generated is 6\\n\\n***Time Complexity: O(Nx2x3)*** \\n\\nReason: There are N*2*K states therefore at max \\u2018N*2*K\\u2019 new problems will be solved.\\n\\n***Space Complexity: O(Nx2xK) + O(N)***\\n\\nReason: We are using a recursion stack space(O(N)) and a 3D array ( O(N*2*K)).\\n****\\n****\\n***Steps to convert Recursive Solution to Tabulation one.***\\n****\\nTo convert the memoization approach to a tabulation one, create a dp array with the size [N+1][2][K+1].\\n\\n***Handling the base case:***\\n\\nNow, what the base condition in the recursive relation is:\\n\\n***if( ind == n || cap == 0) return 0***\\n\\nWe handle this in the following way:\\n\\n1. ***ind == n***\\nWhen ind == n, the other two variables: cap and buy can take any value, therefore we can set the following two loops and set dp[n][buy][cap] = 0\\n![image](https://assets.leetcode.com/users/images/ea34ce9f-25d8-4425-8b29-16c331914c0c_1659974213.213135.png)\\n\\n2. ***cap == 0***\\nWhen cap == 0, the other two variables: ind and cap can take any value, therefore we can set the following two loops and set dp[ind][buy][0] = 0.\\n![image](https://assets.leetcode.com/users/images/09259553-175d-44eb-b5f8-029d73a53119_1659974247.7282832.png)\\n\\n\\nAnother hack is to initialize the entire 3D DP Array as 0. In this case, we need not worry about explicitly setting the base cases.\\n\\n* First we declare the dp array of size [n+1][2][k+1] as zero.\\n* As we have initialized the array as 0, we have automatically set the base condition as explained above.\\n* Now, traverse the array in the opposite direction of that of the memoization technique. We will start from ind = n-1 -> ind =0.\\n* In every iteration copy the recursive code logic.\\n* At last dp[0][0][2] ( maximum profit generated on ith day, when we can buy the stock on 0th day and can have a total 2 transactions) gives us the final answer.\\n****\\n****\\n\\n***C++ Code:***\\n****\\n```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\n\\nint maximumProfit(vector<int>& Arr, int n, int k)\\n{\\n    // Creating a 3d - dp of size [n+1][2][k+1] initialized to 0\\n    vector<vector<vector<int>>> dp(n+1,\\n                                    vector<vector<int>> \\n                                            (2,vector<int>(k+1,0)));\\n                                            \\n    // As dp array is initialized to 0, we have already covered the base case\\n    \\n    for(int ind = n-1; ind>=0; ind--){\\n        for(int buy = 0; buy<=1; buy++){\\n            for(int cap=1; cap<=k; cap++){\\n                \\n                if(buy==0){// We can buy the stock\\n                    dp[ind][buy][cap] = max(0+dp[ind+1][0][cap], \\n                                -Arr[ind] + dp[ind+1][1][cap]);\\n                 }\\n    \\n                if(buy==1){// We can sell the stock\\n                    dp[ind][buy][cap] = max(0+dp[ind+1][1][cap],\\n                                Arr[ind] + dp[ind+1][0][cap-1]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    return dp[0][0][k];\\n   \\n}\\n\\nint main() {\\n\\n  vector<int> prices = {3,3,5,0,0,3,1,4};\\n  int n = prices.size();\\n  int k =2;\\n                                 \\n  cout<<\"The maximum profit that can be generated is \"<<maximumProfit(prices, n, k);\\n}\\n```\\n****\\n****\\n***Output:***\\n\\nThe maximum profit that can be generated is 6\\n\\n***Time Complexity: O(Nx2xk)*** \\n\\nReason: There are three nested loops that account for O(N*2*K) complexity.\\n\\n***Space Complexity: O(Nx2xk)***\\n\\nReason: We are using an external array of size \\u2018N*2*K\\u2019. Stack Space is eliminated.\\n****\\n****\\n***Part 3: Space Optimization***\\n\\nIf we closely look the relation,\\n\\n***dp[ind][buy][cap] = max( dp[ind+1][buy][cap] , max( dp[ind+1][!buy][cap])***\\n\\nWe see that to calculate a value of a cell of the dp array, we need only the next row values(say ahead of ind+1). So, we don\\u2019t need to store an entire 2-D array. Hence we can space optimize it.\\n\\n* ![image](https://assets.leetcode.com/users/images/bcc7fbc5-031c-46a0-b8c1-348d8d89f9fd_1659974365.59976.png)\\n\\n* We set a 2D vector ahead initialized to 0 (base condition) and another 2D\\n* Then we set three nested loops to calculate the cur array\\u2019s values.\\n* We replace dp[ind] with cur and dp[ind+1] with ahead in our tabulation code.\\n* After the inner loop execution, we set ahead as cur for the next outer loop iteration.\\n* At last, we return ahead[0][k] as our answer.\\n****\\n****\\n***C++ Code:***\\n****\\n```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\n\\nint maxProfit(vector<int>& Arr, int n, int k)\\n{\\n    \\n    vector<vector<int>> ahead(2,vector<int> (k+1,0));\\n    \\n    vector<vector<int>> cur(2,vector<int> (k+1,0));\\n    \\n    \\n    for(int ind = n-1; ind>=0; ind--){\\n        for(int buy = 0; buy<=1; buy++){\\n            for(int cap=1; cap<=k; cap++){\\n                \\n                if(buy==0){// We can buy the stock\\n                    cur[buy][cap] = max(0+ahead[0][cap], \\n                                -Arr[ind] + ahead[1][cap]);\\n                 }\\n    \\n                if(buy==1){// We can sell the stock\\n                    cur[buy][cap] = max(0+ahead[1][cap],\\n                                Arr[ind] + ahead[0][cap-1]);\\n                }\\n            }\\n        }\\n        ahead = cur;\\n    }\\n    \\n    return ahead[0][k];\\n   \\n}\\n\\nint main() {\\n\\n  vector<int> prices = {3,3,5,0,0,3,1,4};\\n  int n = prices.size();\\n  int k=2;                             \\n  cout<<\"The maximum profit that can be generated is \"<<maxProfit(prices, n,k);\\n}\\n```\\n****\\n***Output:***\\n\\nThe maximum profit that can be generated is 6\\n\\n***Time Complexity: O(Nx2xK)***\\n\\nReason: There are three nested loops that account for O(N*2*K) complexity\\n\\n***Space Complexity: O(K)***\\n\\nReason: We are using two external arrays of size \\u20182*K\\u2019.\\n****\\n****\\n***Please upvote if it helps.....***\\n****",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nint getAns(vector<int>& Arr, int n, int ind, int buy, int cap, vector<vector<vector<int>>>& dp ){\\n\\n    if(ind==n || cap==0) return 0; //base case\\n    \\n    if(dp[ind][buy][cap]!=-1)\\n        return dp[ind][buy][cap];\\n        \\n    int profit;\\n    \\n    if(buy==0){// We can buy the stock\\n        profit = max(0+getAns(Arr,n,ind+1,0,cap,dp), \\n                    -Arr[ind] + getAns(Arr,n,ind+1,1,cap,dp));\\n    }\\n    \\n    if(buy==1){// We can sell the stock\\n        profit = max(0+getAns(Arr,n,ind+1,1,cap,dp),\\n                    Arr[ind] + getAns(Arr,n,ind+1,0,cap-1,dp));\\n    }\\n    \\n    return dp[ind][buy][cap] = profit;\\n}\\n\\n\\nint maximumProfit(vector<int>& prices, int n, int k)\\n{\\n    // Creating a 3d - dp of size [n][2][k+1]\\n    vector<vector<vector<int>>> dp(n,\\n                                    vector<vector<int>> \\n                                            (2,vector<int>(k+1,-1)));\\n    \\n    return getAns(prices,n,0,0,k,dp);\\n   \\n}\\n\\nint main() {\\n\\n  vector<int> prices = {3,3,5,0,0,3,1,4};\\n  int n = prices.size();\\nint k = 2;\\n                                 \\n  cout<<\"The maximum profit that can be generated is \"<<maximumProfit(prices, n,k);\\n}\\n```\n```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\n\\nint maximumProfit(vector<int>& Arr, int n, int k)\\n{\\n    // Creating a 3d - dp of size [n+1][2][k+1] initialized to 0\\n    vector<vector<vector<int>>> dp(n+1,\\n                                    vector<vector<int>> \\n                                            (2,vector<int>(k+1,0)));\\n                                            \\n    // As dp array is initialized to 0, we have already covered the base case\\n    \\n    for(int ind = n-1; ind>=0; ind--){\\n        for(int buy = 0; buy<=1; buy++){\\n            for(int cap=1; cap<=k; cap++){\\n                \\n                if(buy==0){// We can buy the stock\\n                    dp[ind][buy][cap] = max(0+dp[ind+1][0][cap], \\n                                -Arr[ind] + dp[ind+1][1][cap]);\\n                 }\\n    \\n                if(buy==1){// We can sell the stock\\n                    dp[ind][buy][cap] = max(0+dp[ind+1][1][cap],\\n                                Arr[ind] + dp[ind+1][0][cap-1]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    return dp[0][0][k];\\n   \\n}\\n\\nint main() {\\n\\n  vector<int> prices = {3,3,5,0,0,3,1,4};\\n  int n = prices.size();\\n  int k =2;\\n                                 \\n  cout<<\"The maximum profit that can be generated is \"<<maximumProfit(prices, n, k);\\n}\\n```\n```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\n\\nint maxProfit(vector<int>& Arr, int n, int k)\\n{\\n    \\n    vector<vector<int>> ahead(2,vector<int> (k+1,0));\\n    \\n    vector<vector<int>> cur(2,vector<int> (k+1,0));\\n    \\n    \\n    for(int ind = n-1; ind>=0; ind--){\\n        for(int buy = 0; buy<=1; buy++){\\n            for(int cap=1; cap<=k; cap++){\\n                \\n                if(buy==0){// We can buy the stock\\n                    cur[buy][cap] = max(0+ahead[0][cap], \\n                                -Arr[ind] + ahead[1][cap]);\\n                 }\\n    \\n                if(buy==1){// We can sell the stock\\n                    cur[buy][cap] = max(0+ahead[1][cap],\\n                                Arr[ind] + ahead[0][cap-1]);\\n                }\\n            }\\n        }\\n        ahead = cur;\\n    }\\n    \\n    return ahead[0][k];\\n   \\n}\\n\\nint main() {\\n\\n  vector<int> prices = {3,3,5,0,0,3,1,4};\\n  int n = prices.size();\\n  int k=2;                             \\n  cout<<\"The maximum profit that can be generated is \"<<maxProfit(prices, n,k);\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 273435,
                "title": "python-1-d-dp",
                "content": "I define ```asset = cash + stock_value```, or at time ```i+1```, ```asset[i+1] = cash + prices[i]```. So we can have two dp array to track max ```cash``` and ```asset``` at time ```i``` with ```k``` dealt transactions. ```cash``` is initialized to be filled with ```-inf``` to push us buy the first stock with 0 cash. ```asset``` is filled with 0.\\n\\nThe recurrence equations are:\\n```\\ncash[i+1][k] = max(cash[i][k], asset[i][k-1] - prices[i])\\nasset[i+1][k] = max(asset[i][k], cash[i+1][k] + prices[i])\\n```\\nFirst equation indicates that we might buy at a better(lower) price in time ```i+1```, ```k```th transaction. ```cash[i+1][k]``` stands for current max cash left after ```k``` transcations. For each time point, we would like to check whether we can left with more cash if we perform the ```k```th transcation at current time point instead of any previous time point. So ```cash = asset - stock_value``` and asset here is the max asset when we have done ```k-1``` transactions.\\n\\nSecond equation indicates that we might sell at a better(higher) price in time ```i+1```, ```k```th transaction. ```asset[i+1][k]``` stands for current max asset left after ```k``` transcations. And the asset can be increased if we sell stock at current price. So ```asset = cash + stack_value```. And we should use ```cash[i+1][k]``` instead of ```cash[i+1][k-1]``` here because we can only sell a stock in the ```k```th transcation after we have bought it. So the cash we use here should be the cash we are left with after ```k``` transcations.\\n\\nAnd if k > number of time points / 2, we can actually buy and sell as mush as we want. In that case, we just add up all price raises.\\n\\nAnd we can use rolling dp array to save one dimension. And I save time point dimension since k is always smaller than number of time points. So we can save memory space.\\n```\\ndef maxProfit(k, prices):\\n\\tif k > len(prices) >> 1: \\n\\t\\treturn sum(prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]>prices[i])\\n\\tcash, asset = [float(\\'-inf\\')] * (k+1), [0] * (k+1)\\n\\tfor price in prices:\\n\\t\\tfor i in range(1,k+1):\\n\\t\\t\\tcash[i] = max(cash[i], asset[i-1]-price)\\n\\t\\t\\tasset[i] = max(asset[i], cash[i]+price)\\n\\treturn asset[k]\\n```\\nTime complexity is O(nk) and space complexity is O(k).",
                "solutionTags": [
                    "Python"
                ],
                "code": "```asset = cash + stock_value```\n```i+1```\n```asset[i+1] = cash + prices[i]```\n```cash```\n```asset```\n```i```\n```k```\n```cash```\n```-inf```\n```asset```\n```\\ncash[i+1][k] = max(cash[i][k], asset[i][k-1] - prices[i])\\nasset[i+1][k] = max(asset[i][k], cash[i+1][k] + prices[i])\\n```\n```i+1```\n```k```\n```cash[i+1][k]```\n```k```\n```k```\n```cash = asset - stock_value```\n```k-1```\n```i+1```\n```k```\n```asset[i+1][k]```\n```k```\n```asset = cash + stack_value```\n```cash[i+1][k]```\n```cash[i+1][k-1]```\n```k```\n```k```\n```\\ndef maxProfit(k, prices):\\n\\tif k > len(prices) >> 1: \\n\\t\\treturn sum(prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]>prices[i])\\n\\tcash, asset = [float(\\'-inf\\')] * (k+1), [0] * (k+1)\\n\\tfor price in prices:\\n\\t\\tfor i in range(1,k+1):\\n\\t\\t\\tcash[i] = max(cash[i], asset[i-1]-price)\\n\\t\\t\\tasset[i] = max(asset[i], cash[i]+price)\\n\\treturn asset[k]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 338989,
                "title": "2d-dp-solution-step-by-step-explanation-c",
                "content": "Credit to the Youtube video: https://www.youtube.com/watch?v=oDhu5uGq_ic\\nand the author: Tushar Roy\\n\\nWe can start off by setting T[i][j] be the max-profit after i transactions and j days, then it\\'s easy to find out T[i][0] = 0 for 0<=i<=k, since no matter how many transactions we do at the first day, the profit remains 0; It\\'s also obvious that T[0][j] = 0 for 1<=j<=days, since if we do not do any transaction, the profit remains 0. The **BASE CASE ** are done.\\n\\nThen, we consider the evolution of T[i][j], since the answer we want it: T[k][days]. We can divide the evolution into two cases: \\n\\t\\n\\t1. We do not transact on day j; (So we need not to add on the profit)\\n\\t\\t\\tExpr: T[i][j] = T[i][j-1]\\n\\t\\t\\t\\n\\t2. We do transact on day j; (So we need to find out the previous buying day and sell it on day j, to add on the profit)\\n\\t\\t\\tExpr: T[i][j] = T[i-1][m] + P[j] - P[m] (for all 0<m<j)\\n\\t\\t\\t\\t\\t\\t  = P[j] + max_of_all_m(T[i-1][m] - P[m])\\n\\t\\t\\t\\nBy now, we need to take the max of the two expr to update T[i][j]:\\n\\n\\t\\t\\tT[i][j] = max(T[i][j-1]  ,   P[j] + max_of_all_m(T[i-1][m] - P[m]))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(for all 0<m<j)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\nSo the direct solution under this DP is looks like the following:\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        if (k == 0) return 0;\\n        if (k >= prices.size()) {\\n            k = prices.size()-1;\\n        }\\n        if (prices.size() <= 1) return 0;\\n        int days = prices.size();\\n        \\n        vector<vector<int>> T(k+1, vector<int>(days, 0));\\n        \\n        for (int i=1;i<k+1;i++)\\n        {\\n            for (int j=1;j<days;j++)\\n            {\\n                int cur_max = INT_MIN;\\n                for (int m=0;m<j;m++)\\n                {\\n                    cur_max = max(cur_max, T[i-1][m] - prices[m]);\\n                }\\n                T[i][j] = max(T[i][j-1], prices[j] + cur_max);\\n            }\\n        }\\n        \\n        return T[k][days-1];\\n    }\\n};\\n```\\n\\nCan we do better? The above code is in (n^2*k)\\n\\nObserve that the process of finding \"maxofallm\" is only related to i and T, and if i is fixed in the outer-loop, it\\'s strictly increasing as j increase. Consequently, we can use only one parameter to storage it, other than re-compute it every time, the resulting code is in O(nk)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        if (k == 0) return 0;\\n        if (k >= prices.size()) {\\n            k = prices.size()-1;\\n        }\\n        if (prices.size() <= 1) return 0;\\n        int days = prices.size();\\n        \\n        vector<vector<int>> T(k+1, vector<int>(days, 0));\\n        \\n        \\n        for (int i=1;i<k+1;i++)\\n        {\\n            int max_diff = -prices[0];\\n            for (int j=1;j<days;j++)\\n            {\\n                \\n                T[i][j] = max(T[i][j-1], prices[j] + max_diff);\\n                max_diff = max(max_diff, T[i-1][j] - prices[j]);\\n            }\\n        }\\n        \\n        return T[k][days-1];\\n    }\\n};\\n```\\n\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        if (k == 0) return 0;\\n        if (k >= prices.size()) {\\n            k = prices.size()-1;\\n        }\\n        if (prices.size() <= 1) return 0;\\n        int days = prices.size();\\n        \\n        vector<vector<int>> T(k+1, vector<int>(days, 0));\\n        \\n        for (int i=1;i<k+1;i++)\\n        {\\n            for (int j=1;j<days;j++)\\n            {\\n                int cur_max = INT_MIN;\\n                for (int m=0;m<j;m++)\\n                {\\n                    cur_max = max(cur_max, T[i-1][m] - prices[m]);\\n                }\\n                T[i][j] = max(T[i][j-1], prices[j] + cur_max);\\n            }\\n        }\\n        \\n        return T[k][days-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        if (k == 0) return 0;\\n        if (k >= prices.size()) {\\n            k = prices.size()-1;\\n        }\\n        if (prices.size() <= 1) return 0;\\n        int days = prices.size();\\n        \\n        vector<vector<int>> T(k+1, vector<int>(days, 0));\\n        \\n        \\n        for (int i=1;i<k+1;i++)\\n        {\\n            int max_diff = -prices[0];\\n            for (int j=1;j<days;j++)\\n            {\\n                \\n                T[i][j] = max(T[i][j-1], prices[j] + max_diff);\\n                max_diff = max(max_diff, T[i-1][j] - prices[j]);\\n            }\\n        }\\n        \\n        return T[k][days-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213474,
                "title": "dp-java-solution-for-k-transactions",
                "content": "Hi i have added my solution with clear comments, hope that it helps it is inspired from many links but mostly from https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/54114/Easy-understanding-and-can-be-easily-modified-to-different-situations-Java-Solution\\n\\n```\\npublic int maxProfit(int[] prices) {\\n        //hold[i][j] -  maximum profit at ith day j transactions done and have stock in hand \\n        //unhold[i][j] -  maximum profit at ith day j transactions done and  do not have stock in hand\\n        // unhold exits only after hold & one cycle of buying and selling is a transaction so for simplicity we shall treat a transaction (unhold ) as a selling,( as selling happens only after buying) \\n        // whenever we plan on holding(buying) an item it is a loss so we -ve the stock value and append it to our current profit\\n       \\n        int n = prices.length;\\n        if (n <= 1)\\n\\t\\treturn 0;\\n        \\n        int dphold[][] = new int[n][k+1];\\n        int dpunhold[][] = new int[n][k+1];\\n        \\n        \\n        //base case 1 - only one item and 0 to k transactions, there wont be unhold as we have only one item we can only buy it\\n        for(int j=0;j<=k;j++)\\n            dphold[0][j] = -prices[0];\\n        \\n    //base case 2 - many items but zero transactions, pick the chepeast of all values ( as we are buyinh so we negate the value)\\n        for(int i=1;i<n;i++)\\n            dphold[i][0] = Math.max(dphold[i-1][0],-prices[i]);\\n        \\n        // dp intuition - at any point of time you can hold a stock or you might not hold a stock -\\n        // case 1 - you plan on holding a stock now \\n            //sub case (a) you didnt have a stock on hand earlier\\n            //sub case (b) you did have have a stack on hand earlier\\n            // pick the best of these 2\\n        // dphold[i][j] = Max(dpunhold[i-1][j]-prices[i],dphold[i-1][j])\\n        \\n        // case 2 - you plan on unholding(selling) a stock now , \\n            //sub case (a) you didnt have a stock on hand earlier\\n            //sub case (b) you did have have a stack on hand earlier\\n            // pick the best of these 2\\n        // dpunhold[i][j] = Max(dpunhold[i-1][j],dphold[i-1][j-1]+prices[i])\\n        \\n        // finally pick the best of these 2 in the end.\\n        \\n        //dp solution\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=1;j<=k;j++)\\n            {\\n                dphold[i][j] = Math.max(dpunhold[i-1][j]-prices[i],dphold[i-1][j]);\\n                dpunhold[i][j] = Math.max(dpunhold[i-1][j],dphold[i-1][j-1]+prices[i]);\\n            }\\n        }\\n        \\n        return Math.max(dphold[n-1][k],dpunhold[n-1][k]);\\n    }",
                "solutionTags": [],
                "code": "Hi i have added my solution with clear comments, hope that it helps it is inspired from many links but mostly from https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/54114/Easy-understanding-and-can-be-easily-modified-to-different-situations-Java-Solution\\n\\n```\\npublic int maxProfit(int[] prices) {\\n        //hold[i][j] -  maximum profit at ith day j transactions done and have stock in hand \\n        //unhold[i][j] -  maximum profit at ith day j transactions done and  do not have stock in hand\\n        // unhold exits only after hold & one cycle of buying and selling is a transaction so for simplicity we shall treat a transaction (unhold ) as a selling,( as selling happens only after buying) \\n        // whenever we plan on holding(buying) an item it is a loss so we -ve the stock value and append it to our current profit\\n       \\n        int n = prices.length;\\n        if (n <= 1)\\n\\t\\treturn 0;\\n        \\n        int dphold[][] = new int[n][k+1];\\n        int dpunhold[][] = new int[n][k+1];\\n        \\n        \\n        //base case 1 - only one item and 0 to k transactions, there wont be unhold as we have only one item we can only buy it\\n        for(int j=0;j<=k;j++)\\n            dphold[0][j] = -prices[0];\\n        \\n    //base case 2 - many items but zero transactions, pick the chepeast of all values ( as we are buyinh so we negate the value)\\n        for(int i=1;i<n;i++)\\n            dphold[i][0] = Math.max(dphold[i-1][0],-prices[i]);\\n        \\n        // dp intuition - at any point of time you can hold a stock or you might not hold a stock -\\n        // case 1 - you plan on holding a stock now \\n            //sub case (a) you didnt have a stock on hand earlier\\n            //sub case (b) you did have have a stack on hand earlier\\n            // pick the best of these 2\\n        // dphold[i][j] = Max(dpunhold[i-1][j]-prices[i],dphold[i-1][j])\\n        \\n        // case 2 - you plan on unholding(selling) a stock now , \\n            //sub case (a) you didnt have a stock on hand earlier\\n            //sub case (b) you did have have a stack on hand earlier\\n            // pick the best of these 2\\n        // dpunhold[i][j] = Max(dpunhold[i-1][j],dphold[i-1][j-1]+prices[i])\\n        \\n        // finally pick the best of these 2 in the end.\\n        \\n        //dp solution\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=1;j<=k;j++)\\n            {\\n                dphold[i][j] = Math.max(dpunhold[i-1][j]-prices[i],dphold[i-1][j]);\\n                dpunhold[i][j] = Math.max(dpunhold[i-1][j],dphold[i-1][j-1]+prices[i]);\\n            }\\n        }\\n        \\n        return Math.max(dphold[n-1][k],dpunhold[n-1][k]);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 702612,
                "title": "python3-dp",
                "content": "This question unifies this series of problems. \\n\\n[121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/695515/Python3-two-approaches)\\n[122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/discuss/702615/Python3-1-line)\\n[123. Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/702602/Python3-two-approaches)\\n\\nRecall that in [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/695515/Python3-two-approaches), there are two approaches \\n1) buy low & sell high;\\n2) Kadane\\'s algorithm.\\n\\nBoth approaches could be generalized into cases with multiple transactions, say `K`. \\n\\n**Approach 1 -- buy low & sell high** (`O(NK)` time & `O(K)` space)\\n\\n```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        if k >= len(prices)//2: return sum(max(0, prices[i] - prices[i-1]) for i in range(1, len(prices)))\\n        buy, sell = [inf]*k, [0]*k\\n        for x in prices:\\n            for i in range(k):\\n                if i: buy[i] = min(buy[i], x - sell[i-1])\\n                else: buy[i] = min(buy[i], x)\\n                sell[i] = max(sell[i], x - buy[i])\\n        return sell[-1] if k and prices else 0\\n```\\n\\n**Approach 2 -- Kadane\\'s algo**\\nThe second approach is to extend Kadane\\'s algorithm to the cases with multiple transaction (`O(NK)` time & `O(N)` space)\\n\\n```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        if k >= len(prices)//2: return sum(max(0, prices[i] - prices[i-1]) for i in range(1, len(prices)))\\n        ans = [0]*len(prices)\\n        for _ in range(k):\\n            most = 0\\n            for i in range(1, len(prices)):\\n                most = max(ans[i], most + prices[i] - prices[i-1])\\n                ans[i] = max(ans[i-1], most)\\n        return ans[-1]\\n```\\n\\n**Reference**\\n[121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/695515/Python3-two-approaches)\\n[122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/discuss/565654/Python3-greedy-and-dp)\\n[123. Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/702602/Python3-two-approaches)\\n[188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/702612/Python3-two-approaches)\\n[309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/762801/Python3-dp)\\n[714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/1532323/Python3-dp)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        if k >= len(prices)//2: return sum(max(0, prices[i] - prices[i-1]) for i in range(1, len(prices)))\\n        buy, sell = [inf]*k, [0]*k\\n        for x in prices:\\n            for i in range(k):\\n                if i: buy[i] = min(buy[i], x - sell[i-1])\\n                else: buy[i] = min(buy[i], x)\\n                sell[i] = max(sell[i], x - buy[i])\\n        return sell[-1] if k and prices else 0\\n```\n```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        if k >= len(prices)//2: return sum(max(0, prices[i] - prices[i-1]) for i in range(1, len(prices)))\\n        ans = [0]*len(prices)\\n        for _ in range(k):\\n            most = 0\\n            for i in range(1, len(prices)):\\n                most = max(ans[i], most + prices[i] - prices[i-1])\\n                ans[i] = max(ans[i-1], most)\\n        return ans[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54147,
                "title": "my-journey-from-dp-o-kn-to-stack-heap-o-n-klgn",
                "content": "When I was solving Best Time to Buy and Sell Stock, I happened to know Kadane's Algorithm. On its [wiki page](https://www.wikiwand.com/en/Maximum_subarray_problem), it talks about a paper working on the generalisation version of this maximum subarray problem.\\n\\n> Generalizations\\nSimilar problems may be posed for higher-dimensional arrays, but their solutions are more complicated; see, e.g., Takaoka (2002). Brodal & J\\xf8rgensen (2007) showed how to find the k largest subarray sums in a one-dimensional array, in the optimal time bound O(n+k).\\n\\nI spent some time on the paper, but I stuck on it. If anyone is also interested it, please have a look at [Computing Maximum-Scoring\\nSegments Optimally](http://ltu.diva-portal.org/smash/get/diva2:995901/FULLTEXT01).\\n\\n- - -\\n\\nFinally I passed problem according to [jinwu's DP solution](https://discuss.leetcode.com/topic/26169/clean-java-dp-solution-with-comment), which is very intuitive, using `d[i, j]` represents the max profit until `prices[j]` at most `i` transactions.\\n\\nRuby code\\n\\n```ruby\\n  def max_profit(k, prices)\\n    return 0 if prices.count < 2\\n\\n    n = prices.count\\n    if k > n/2\\n      differences = (1..prices.count-1).reduce([]) {|ar, i| ar << (prices[i] - prices[i-1]) }\\n      return differences.select{|num| num > 0}.reduce(:+) || 0\\n    end\\n\\n    # d[i, j] represents the max profit until prices[j] at most i transactions\\n    d = Array.new(k+1){ Array.new(n+1){0} }\\n    (1..k).each do |i|\\n      tmp_max = d[i-1][0] - prices[0]\\n\\n      (1..n-1).each do |j|\\n        d[i][j] = [ d[i][j-1], prices[j] + tmp_max ].max\\n        tmp_max = [ tmp_max, d[i-1][j] - prices[j] ].max\\n      end\\n    end\\n\\n    return d[k][n-1]\\n  end\\n```\\n\\nTime complexity: `O(kn)`\\n\\n- - -\\n\\n*UPDATE 2016-11-07* \\n\\nI\\u2019ve been staring at [yishiluo\\u2019s](https://discuss.leetcode.com/user/yishiluo) post [C++ Solution with O(n + klgn) time using Max Heap and Stack](https://discuss.leetcode.com/topic/9522/c-solution-with-o-n-klgn-time-using-max-heap-and-stack/7) for a whole day. It took me some effort to finally write a `O(n)` version according to his explanation. Well, to be honest, I\\u2019m still a little confused about some bits. Here is my understanding, hoping someone could point out if my thought is right.\\n\\nThe **general idea** is to\\n\\n+ split the `prices` array into several consecutive ascending segments, with valley and peak index denoting the start and end point.\\n+ use a stack to process these segments into all possible profits. \\n+ employ a max heap to find the max `k` profits as the result.\\n\\nThe most challenging part for me is to understand when iterating valley-peak segments, how could we handle two adjacent segments? AKA\\n\\n***How could we find all possible profits?***\\n\\nSuppose we are facing two segments `(v1,p1)` and `(v2, p2)` under the limit `v1 < p1 < v2 < p2`, we would have two possible operations:\\n\\n- buy at v1, sell at p1; buy at v2, sell at p2 ( `p1 - v1 + p2 - v2` )\\n- buy at v1, sell at p2 ( `p2 - v1` )\\n\\nWhat we need to do is to find out which could make more profit. We would meet these situations:\\n\\n`prices[v2] <= prices[v1]`\\n+ it\\u2019s obvious that we\\u2019d better make two transactions: `p1-v1` and `p2-v2`, and `v2` is more possible to make bigger profit. So, we pop out `(v1,p1)` from the stack.\\n\\n`prices[v2] > prices[v1]`\\n+ `prices[p2] < prices[p1]` We\\u2019d better use two transactions `p1-v1` and `p2-v2`, and `v1` is still more possible to make bigger profit. So, we keep `(v1,p1)` in the stack.\\n+ `prices[p2] >= prices[p1]` We are not sure about using one or two transactions to get higher profit, so we push two possible results into the `profits` array. Here comes **the key point**: we push `p2-v1` and `p1-v2` into `profits` array. Why? If we could only use one transaction, `p2-v1` is what we want, and if with two transactions, `p2-v1 + p1-v2` is also the max profit.\\n\\nHere is an example about the key point situation: \\n\\n```ruby\\nprices #=> [ 1, 3, 2, 4 ]\\n\\n# we could get\\n(v1, p1): (0 ,1) \\n(v2, p2): (2, 3)\\n\\n# then push two possible profits\\nprofits << prices[p2] - prices[v1]\\nprofits << prices[p1] - prices[v2]\\n\\nprofits #=> [3, 1]\\n\\n# If k is 1, the top profits is 3\\n# If k is 2, the top profits is 3+1\\n```\\n\\nRuby code (it seems a bit longer as I've implement a max heap manually)\\n\\n```ruby\\n  # Stack and Heap - O(n) + O(klogn)\\n  def max_profit(k, prices)\\n    n       = prices.count\\n    pair    = Struct.new(:v, :p){ def to_a; [v, p]; end }\\n    stack   = []\\n    profits = []\\n\\n    if k > n/2\\n      differences = (1..prices.count-1).reduce([]) {|ar, i| ar << (prices[i] - prices[i-1]) }\\n      return differences.select{|num| num > 0}.reduce(:+) || 0\\n    end\\n\\n    v2, p2 = 0, 0\\n    loop do\\n      break if v2 >= n-1\\n\\n      v2 = (v2..n-2).detect{|i| prices[i] < prices[i+1]}\\n      break if v2.nil?\\n\\n      p2 = (v2+1..n-1).detect{|i| prices[i] > prices[i-1]}\\n\\n      # puts \"v2: #{v2} p2: #{p2}\"\\n\\n      # v2 <= v1\\n      while !(stack.empty?) && prices[v2] <= prices[stack.last.v]\\n        v1, p1 = stack.pop.to_a\\n        profits << prices[p1] - prices[v1]\\n      end\\n\\n      # v2 > v1 && p2 >= p1\\n      while !(stack.empty?) && prices[p2] >= prices[stack.last.p]\\n        v1, p1 = stack.pop.to_a\\n        profits << prices[p1] - prices[v2]\\n\\n        v2 = v1\\n      end\\n\\n      stack << pair.new(v2, p2)\\n\\n      v2 = p2\\n    end\\n\\n    while !(stack.empty?)\\n      v1, p1 = stack.pop.to_a\\n      profits << prices[p1] - prices[v1]\\n    end\\n\\n    # puts \"profits: #{profits.join(',')}\"\\n\\n    heap = PriorityQueue.new profits\\n    k.times.map{ heap.delete_max || 0 }.reduce(:+) || 0\\n  end\\n\\n  class PriorityQueue\\n    # Binary Heap implementation\\n\\n    attr_accessor :num, :array, :block\\n\\n    def initialize(arr = [], &block)\\n      @array = arr.clone\\n      @num   = array.size\\n      @array.unshift(nil)\\n\\n      @block = block || ->(a,b){ a < b }\\n\\n      construct\\n    end\\n\\n    def insert(item)\\n      self.num += 1\\n      array[num] = item\\n      swim(num)\\n    end\\n\\n    def get_max\\n      array[1]\\n    end\\n\\n    def delete_max\\n      return nil if num == 0\\n\\n      max = array[1]\\n\\n      exch(1, num)\\n      self.num -= 1\\n      sink(1)\\n\\n      return max\\n    end\\n\\n    def size\\n      num\\n    end\\n\\n    def empty?\\n      num == 0\\n    end\\n\\n    private\\n\\n      def construct\\n        (num/2).downto(1).each{|i| sink(i) }\\n      end\\n\\n      def swim(k)\\n        while k > 1 && less(k/2, k)\\n          exch(k, k/2)\\n          k = k/2\\n        end\\n        nil\\n      end\\n\\n      def sink(k)\\n        while 2*k <= num\\n          j = 2*k\\n          j += 1 if j < num && less(j, j+1)\\n\\n          break unless less(k, j)\\n\\n          exch(k, j)\\n          k = j\\n        end\\n        nil\\n      end\\n\\n      def less(a, b)\\n        block.call(array[a], array[b])\\n      end\\n\\n      def exch(i, j)\\n        t        = array[i]\\n        array[i] = array[j]\\n        array[j] = t\\n      end\\n\\n      def to_s\\n        puts (1..num).to_a.join(\"\\\\t\")\\n        puts array[1, num].join(\"\\\\t\")\\n      end\\n\\n  end\\n```\\n\\nTime complexity: `O(n + klgn)`",
                "solutionTags": [
                    "Ruby",
                    "Dynamic Programming",
                    "Stack",
                    "Heap (Priority Queue)"
                ],
                "code": "```ruby\\n  def max_profit(k, prices)\\n    return 0 if prices.count < 2\\n\\n    n = prices.count\\n    if k > n/2\\n      differences = (1..prices.count-1).reduce([]) {|ar, i| ar << (prices[i] - prices[i-1]) }\\n      return differences.select{|num| num > 0}.reduce(:+) || 0\\n    end\\n\\n    # d[i, j] represents the max profit until prices[j] at most i transactions\\n    d = Array.new(k+1){ Array.new(n+1){0} }\\n    (1..k).each do |i|\\n      tmp_max = d[i-1][0] - prices[0]\\n\\n      (1..n-1).each do |j|\\n        d[i][j] = [ d[i][j-1], prices[j] + tmp_max ].max\\n        tmp_max = [ tmp_max, d[i-1][j] - prices[j] ].max\\n      end\\n    end\\n\\n    return d[k][n-1]\\n  end\\n```\n```ruby\\nprices #=> [ 1, 3, 2, 4 ]\\n\\n# we could get\\n(v1, p1): (0 ,1) \\n(v2, p2): (2, 3)\\n\\n# then push two possible profits\\nprofits << prices[p2] - prices[v1]\\nprofits << prices[p1] - prices[v2]\\n\\nprofits #=> [3, 1]\\n\\n# If k is 1, the top profits is 3\\n# If k is 2, the top profits is 3+1\\n```\n```ruby\\n  # Stack and Heap - O(n) + O(klogn)\\n  def max_profit(k, prices)\\n    n       = prices.count\\n    pair    = Struct.new(:v, :p){ def to_a; [v, p]; end }\\n    stack   = []\\n    profits = []\\n\\n    if k > n/2\\n      differences = (1..prices.count-1).reduce([]) {|ar, i| ar << (prices[i] - prices[i-1]) }\\n      return differences.select{|num| num > 0}.reduce(:+) || 0\\n    end\\n\\n    v2, p2 = 0, 0\\n    loop do\\n      break if v2 >= n-1\\n\\n      v2 = (v2..n-2).detect{|i| prices[i] < prices[i+1]}\\n      break if v2.nil?\\n\\n      p2 = (v2+1..n-1).detect{|i| prices[i] > prices[i-1]}\\n\\n      # puts \"v2: #{v2} p2: #{p2}\"\\n\\n      # v2 <= v1\\n      while !(stack.empty?) && prices[v2] <= prices[stack.last.v]\\n        v1, p1 = stack.pop.to_a\\n        profits << prices[p1] - prices[v1]\\n      end\\n\\n      # v2 > v1 && p2 >= p1\\n      while !(stack.empty?) && prices[p2] >= prices[stack.last.p]\\n        v1, p1 = stack.pop.to_a\\n        profits << prices[p1] - prices[v2]\\n\\n        v2 = v1\\n      end\\n\\n      stack << pair.new(v2, p2)\\n\\n      v2 = p2\\n    end\\n\\n    while !(stack.empty?)\\n      v1, p1 = stack.pop.to_a\\n      profits << prices[p1] - prices[v1]\\n    end\\n\\n    # puts \"profits: #{profits.join(',')}\"\\n\\n    heap = PriorityQueue.new profits\\n    k.times.map{ heap.delete_max || 0 }.reduce(:+) || 0\\n  end\\n\\n  class PriorityQueue\\n    # Binary Heap implementation\\n\\n    attr_accessor :num, :array, :block\\n\\n    def initialize(arr = [], &block)\\n      @array = arr.clone\\n      @num   = array.size\\n      @array.unshift(nil)\\n\\n      @block = block || ->(a,b){ a < b }\\n\\n      construct\\n    end\\n\\n    def insert(item)\\n      self.num += 1\\n      array[num] = item\\n      swim(num)\\n    end\\n\\n    def get_max\\n      array[1]\\n    end\\n\\n    def delete_max\\n      return nil if num == 0\\n\\n      max = array[1]\\n\\n      exch(1, num)\\n      self.num -= 1\\n      sink(1)\\n\\n      return max\\n    end\\n\\n    def size\\n      num\\n    end\\n\\n    def empty?\\n      num == 0\\n    end\\n\\n    private\\n\\n      def construct\\n        (num/2).downto(1).each{|i| sink(i) }\\n      end\\n\\n      def swim(k)\\n        while k > 1 && less(k/2, k)\\n          exch(k, k/2)\\n          k = k/2\\n        end\\n        nil\\n      end\\n\\n      def sink(k)\\n        while 2*k <= num\\n          j = 2*k\\n          j += 1 if j < num && less(j, j+1)\\n\\n          break unless less(k, j)\\n\\n          exch(k, j)\\n          k = j\\n        end\\n        nil\\n      end\\n\\n      def less(a, b)\\n        block.call(array[a], array[b])\\n      end\\n\\n      def exch(i, j)\\n        t        = array[i]\\n        array[i] = array[j]\\n        array[j] = t\\n      end\\n\\n      def to_s\\n        puts (1..num).to_a.join(\"\\\\t\")\\n        puts array[1, num].join(\"\\\\t\")\\n      end\\n\\n  end\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54178,
                "title": "clear-c-solution",
                "content": "    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        if (k>=n/2) {\\n            int sum = 0;\\n            for(int i=1; i<n; i++){\\n                if(prices[i] > prices[i-1]){\\n                    sum += prices[i] - prices[i-1];\\n                }\\n            }\\n            return sum;\\n        }\\n        vector<int> buy(k+1, INT_MIN), sale(k+1, 0);\\n        for(int i=0; i<n; i++){\\n            for(int j=1; j<=k; j++){\\n                buy[j] = max(buy[j], sale[j-1]-prices[i]);\\n                sale[j] = max(sale[j], buy[j] + prices[i]);\\n            }\\n        }\\n        return sale[k];\\n    }\\n\\nIt is similar to Buy and Sell Stock III, but (k>=n/2) is needed or it will time limited.",
                "solutionTags": [],
                "code": "    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        if (k>=n/2) {\\n            int sum = 0;\\n            for(int i=1; i<n; i++){\\n                if(prices[i] > prices[i-1]){\\n                    sum += prices[i] - prices[i-1];\\n                }\\n            }\\n            return sum;\\n        }\\n        vector<int> buy(k+1, INT_MIN), sale(k+1, 0);\\n        for(int i=0; i<n; i++){\\n            for(int j=1; j<=k; j++){\\n                buy[j] = max(buy[j], sale[j-1]-prices[i]);\\n                sale[j] = max(sale[j], buy[j] + prices[i]);\\n            }\\n        }\\n        return sale[k];\\n    }\\n\\nIt is similar to Buy and Sell Stock III, but (k>=n/2) is needed or it will time limited.",
                "codeTag": "Unknown"
            },
            {
                "id": 1632995,
                "title": "python-dp-memoization-tabulation-simple-solutions-with-detailed-explanation",
                "content": "## Logic:\\n1. This problem can be solved using dynamic programming.\\n2. Let create a dp array (dp[i][k][a])in which the i-th position will tell the maximum profit at the end of i-th day with atmost k transaction. \\n\\t- dp[i][k][a], **i** denotes the day, **k** denotes the maximum number of allowed transactions and **a** denotes whether we have sold or buyes the stocks at the end of the ith day. For example,\\n\\t\\t- dp[i][k][0] will tell the maximum profit at i-th day with atmost k transaction such that on i-th day we have sold the stocks.\\n\\t\\t-  dp[i][k][1] will tell the maximum profit at i-th day with atmost k transaction such that on i-th day we have bought the stocks.\\n3. Base cases:\\n\\t- dp[0][k][0] = 0 => because on 0th day we don\\'t have any stock.\\n\\t- dp[0][k][1] = -infinity => since we don\\'t have any stocks on 0th day so we can\\'t buy any stock\\n\\t- dp[i][0][0] = 0 => because the number of transactions is 0 so profit is 0\\n\\t- dp[i][0][1] = -infinity => since the number of transactions is 0 so we can\\'t buy any stock\\n4. DP state:\\n\\t- dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1]+prices[i-1])\\n\\t\\t- Since **a** is 0 which means the action taken on ith day is either **Rest** or **Sell**. Therefore the max profit would be the max of **Rest** action(dp[i-1][k][0]) and **Sell** action(dp[i-1][k][1]+prices[i-1]). Note: To sell a stock we must have buyed a stock before.\\n\\t- dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0]-prices[i-1])\\n\\t\\t- Since **a** is 1 which means the action taken on ith day is either **Rest** or **Buy**. Therefore the max profit would be the max of **Rest** action(dp[i-1][k][1]) and **Buy** action(dp[i-1][k-1][0]-prices[i-1]).\\n5. At last, we have to return dp[-1][k][0] because if we don\\'t hold any stock at the end then only we can have the maximum profit.\\n\\n## Solution 1 (Memoization)\\n```\\nclass Solution:\\n    def dp(self, prices, currentDay, remainingTransactions, holding, lookup):\\n        # Return 0 if there aren\\'t any transactions left or there are no more stocks.\\n        if remainingTransactions == 0 or currentDay == len(prices):\\n            return 0\\n        if not lookup[currentDay][remainingTransactions][holding]:\\n            if holding:\\n                # Return max(did nothing on current day, sold all the stocks on current day).\\n                lookup[currentDay][remainingTransactions][holding] = max(self.dp(prices, currentDay+1, remainingTransactions, holding, lookup), prices[currentDay] + self.dp(prices, currentDay+1, remainingTransactions-1, 0, lookup))\\n            else:\\n                # Return max(did nothing on current day, bought all the stocks on current day).\\n                lookup[currentDay][remainingTransactions][holding] = max(self.dp(prices, currentDay+1, remainingTransactions, holding, lookup), -prices[currentDay] + self.dp(prices, currentDay+1, remainingTransactions, 1, lookup))\\n        return lookup[currentDay][remainingTransactions][holding]\\n            \\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        return self.dp(prices, 0, k, 0, [[[None for _ in range(2)] for _ in range(k+1)] for _ in range(len(prices))])\\n```\\n\\n\\n## Solution 2 (Tabulation)\\n```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        days = len(prices)\\n        dp = [[[None for _ in range(2)] for _ in range(k+1)] for _ in range(days+1)]\\n        \\n        for x in range(k+1):\\n            dp[0][x][0] = 0\\n            dp[0][x][1] = -sys.maxsize\\n        \\n        for i in range(1, days+1):\\n            dp[i][0][0] = 0\\n            dp[i][0][1] = -sys.maxsize\\n            for x in range(1, k+1):\\n                dp[i][x][0] = max(dp[i-1][x][0], dp[i-1][x][1]+prices[i-1])\\n                dp[i][x][1] = max(dp[i-1][x][1], dp[i-1][x-1][0]-prices[i-1])\\n        \\n        return dp[-1][k][0]\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def dp(self, prices, currentDay, remainingTransactions, holding, lookup):\\n        # Return 0 if there aren\\'t any transactions left or there are no more stocks.\\n        if remainingTransactions == 0 or currentDay == len(prices):\\n            return 0\\n        if not lookup[currentDay][remainingTransactions][holding]:\\n            if holding:\\n                # Return max(did nothing on current day, sold all the stocks on current day).\\n                lookup[currentDay][remainingTransactions][holding] = max(self.dp(prices, currentDay+1, remainingTransactions, holding, lookup), prices[currentDay] + self.dp(prices, currentDay+1, remainingTransactions-1, 0, lookup))\\n            else:\\n                # Return max(did nothing on current day, bought all the stocks on current day).\\n                lookup[currentDay][remainingTransactions][holding] = max(self.dp(prices, currentDay+1, remainingTransactions, holding, lookup), -prices[currentDay] + self.dp(prices, currentDay+1, remainingTransactions, 1, lookup))\\n        return lookup[currentDay][remainingTransactions][holding]\\n            \\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        return self.dp(prices, 0, k, 0, [[[None for _ in range(2)] for _ in range(k+1)] for _ in range(len(prices))])\\n```\n```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        days = len(prices)\\n        dp = [[[None for _ in range(2)] for _ in range(k+1)] for _ in range(days+1)]\\n        \\n        for x in range(k+1):\\n            dp[0][x][0] = 0\\n            dp[0][x][1] = -sys.maxsize\\n        \\n        for i in range(1, days+1):\\n            dp[i][0][0] = 0\\n            dp[i][0][1] = -sys.maxsize\\n            for x in range(1, k+1):\\n                dp[i][x][0] = max(dp[i-1][x][0], dp[i-1][x][1]+prices[i-1])\\n                dp[i][x][1] = max(dp[i-1][x][1], dp[i-1][x-1][0]-prices[i-1])\\n        \\n        return dp[-1][k][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1007170,
                "title": "java-recursive-memoization-3d-bottom-up-2d-bottom-up",
                "content": "```\\n- For each of the index \\'i\\'\\n\\t- We will be in one of the 2 different states\\n\\t\\t- We are either in the \\'buy\\' or \\'sell\\' state\\n\\t- If we are currently only allowed to \\'buy\\'\\n\\t\\t- Then we have 2 choices\\n\\t\\t\\t- We can either buy the current stock or move onto the next stock\\n\\t\\t\\t- We will pick the choice that will give us the higher amount of profit\\n\\t- If we are currently only allowed to \\'sell\\'\\n\\t\\t- Then we have 2 choices\\n\\t\\t\\t- We can either sell at the current stock or move onto the next stock\\n\\t\\t\\t- We will pick the choice that will give us the higher amount of profit\\n- We will denote our 2 states as two integers\\n\\t- 0, buy\\n\\t- 1, sell\\n```\\n```\\npublic class BestTimeToBuyAndSellStock {\\n    public int maxProfit(int k, int[] prices) {\\n        return maxProfit(0, 0, k, prices);\\n    }\\n\\n    private int maxProfit(int i, int state, int k, int[] prices) {\\n        if (i >= prices.length || k == 0) return 0;\\n\\n        return state == 0 ?\\n            Math.max(maxProfit(i + 1, 1, k, prices) - prices[i],\\n                     maxProfit(i + 1, state, k, prices)) :\\n            Math.max(maxProfit(i + 1, 0, k - 1, prices) + prices[i],\\n                     maxProfit(i + 1, state, k, prices));\\n    }\\n}\\n```\\n```\\npublic class BestTimeToBuyAndSellStockMemoizationApproach {\\n    public int maxProfit(int k, int[] prices) {\\n        int[][][] memo = new int[prices.length][2][k + 1];\\n\\n        for (int r = 0; r < memo.length; r++) {\\n            for (int c = 0; c < memo[r].length; c++) {\\n                Arrays.fill(memo[r][c], -1);\\n            }\\n        }\\n\\n        return maxProfit(0, 0, k, prices, memo);\\n    }\\n\\n    private int maxProfit(int i, int state, int k, int[] prices, int[][][] memo) {\\n        if (i >= prices.length || k == 0) return 0;\\n        if (memo[i][state][k] != -1) return memo[i][state][k];\\n\\n        return memo[i][state][k] = (state == 0) ?\\n            Math.max(maxProfit(i + 1, 1, k, prices, memo) - prices[i],\\n                     maxProfit(i + 1, state, k, prices, memo)) :\\n            Math.max(maxProfit(i + 1, 0, k - 1, prices, memo) + prices[i],\\n                     maxProfit(i + 1, state, k, prices, memo));\\n    }\\n}\\n```\\n```\\npublic class BestTimeToBuyAndSellStockBottomUp3DMatrixApproach {\\n    public int maxProfit(int k, int[] prices) {\\n        int[][][] profit = new int[prices.length + 1][2][k + 1];\\n\\n        for (int i = prices.length - 1; i >= 0; i--) {\\n            for (int state = 1; state >= 0; state--) {\\n                for (int j = 1; j <= k; j++) {\\n                    profit[i][state][j] = (state == 0) ?\\n                        Math.max(profit[i + 1][1][j] - prices[i],\\n                                profit[i + 1][state][j]) :\\n                        Math.max(profit[i + 1][0][j - 1] + prices[i],\\n                                profit[i + 1][state][j]);\\n                }\\n            }\\n        }\\n\\n        return profit[0][0][k];\\n    }\\n}\\n```\\n```\\npublic class BestTimeToBuyAndSellStockBottomUp2DMatrixApproach {\\n    public int maxProfit(int k, int[] prices) {\\n        int[][] profit = new int[2][k + 1];\\n\\n        for (int i = prices.length - 1; i >= 0; i--) {\\n            for (int state = 1; state >= 0; state--) {\\n                for (int j = 1; j <= k; j++) {\\n                    profit[state][j] = (state == 0) ?\\n                        Math.max(profit[1][j] - prices[i],\\n                                 profit[state][j]) :\\n                        Math.max(profit[0][j - 1] + prices[i],\\n                                 profit[state][j]);\\n                }\\n            }\\n        }\\n\\n        return profit[0][k];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n- For each of the index \\'i\\'\\n\\t- We will be in one of the 2 different states\\n\\t\\t- We are either in the \\'buy\\' or \\'sell\\' state\\n\\t- If we are currently only allowed to \\'buy\\'\\n\\t\\t- Then we have 2 choices\\n\\t\\t\\t- We can either buy the current stock or move onto the next stock\\n\\t\\t\\t- We will pick the choice that will give us the higher amount of profit\\n\\t- If we are currently only allowed to \\'sell\\'\\n\\t\\t- Then we have 2 choices\\n\\t\\t\\t- We can either sell at the current stock or move onto the next stock\\n\\t\\t\\t- We will pick the choice that will give us the higher amount of profit\\n- We will denote our 2 states as two integers\\n\\t- 0, buy\\n\\t- 1, sell\\n```\n```\\npublic class BestTimeToBuyAndSellStock {\\n    public int maxProfit(int k, int[] prices) {\\n        return maxProfit(0, 0, k, prices);\\n    }\\n\\n    private int maxProfit(int i, int state, int k, int[] prices) {\\n        if (i >= prices.length || k == 0) return 0;\\n\\n        return state == 0 ?\\n            Math.max(maxProfit(i + 1, 1, k, prices) - prices[i],\\n                     maxProfit(i + 1, state, k, prices)) :\\n            Math.max(maxProfit(i + 1, 0, k - 1, prices) + prices[i],\\n                     maxProfit(i + 1, state, k, prices));\\n    }\\n}\\n```\n```\\npublic class BestTimeToBuyAndSellStockMemoizationApproach {\\n    public int maxProfit(int k, int[] prices) {\\n        int[][][] memo = new int[prices.length][2][k + 1];\\n\\n        for (int r = 0; r < memo.length; r++) {\\n            for (int c = 0; c < memo[r].length; c++) {\\n                Arrays.fill(memo[r][c], -1);\\n            }\\n        }\\n\\n        return maxProfit(0, 0, k, prices, memo);\\n    }\\n\\n    private int maxProfit(int i, int state, int k, int[] prices, int[][][] memo) {\\n        if (i >= prices.length || k == 0) return 0;\\n        if (memo[i][state][k] != -1) return memo[i][state][k];\\n\\n        return memo[i][state][k] = (state == 0) ?\\n            Math.max(maxProfit(i + 1, 1, k, prices, memo) - prices[i],\\n                     maxProfit(i + 1, state, k, prices, memo)) :\\n            Math.max(maxProfit(i + 1, 0, k - 1, prices, memo) + prices[i],\\n                     maxProfit(i + 1, state, k, prices, memo));\\n    }\\n}\\n```\n```\\npublic class BestTimeToBuyAndSellStockBottomUp3DMatrixApproach {\\n    public int maxProfit(int k, int[] prices) {\\n        int[][][] profit = new int[prices.length + 1][2][k + 1];\\n\\n        for (int i = prices.length - 1; i >= 0; i--) {\\n            for (int state = 1; state >= 0; state--) {\\n                for (int j = 1; j <= k; j++) {\\n                    profit[i][state][j] = (state == 0) ?\\n                        Math.max(profit[i + 1][1][j] - prices[i],\\n                                profit[i + 1][state][j]) :\\n                        Math.max(profit[i + 1][0][j - 1] + prices[i],\\n                                profit[i + 1][state][j]);\\n                }\\n            }\\n        }\\n\\n        return profit[0][0][k];\\n    }\\n}\\n```\n```\\npublic class BestTimeToBuyAndSellStockBottomUp2DMatrixApproach {\\n    public int maxProfit(int k, int[] prices) {\\n        int[][] profit = new int[2][k + 1];\\n\\n        for (int i = prices.length - 1; i >= 0; i--) {\\n            for (int state = 1; state >= 0; state--) {\\n                for (int j = 1; j <= k; j++) {\\n                    profit[state][j] = (state == 0) ?\\n                        Math.max(profit[1][j] - prices[i],\\n                                 profit[state][j]) :\\n                        Math.max(profit[0][j - 1] + prices[i],\\n                                 profit[state][j]);\\n                }\\n            }\\n        }\\n\\n        return profit[0][k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 351578,
                "title": "javascript-dp-solution",
                "content": "```\\nvar maxProfit = function(k, prices) {\\n    if(prices.length == 0) return 0;\\n    \\n    // When k becomes so much larger than the number of prices we can make transactions whenever.\\n    if(k > (prices.length / 2) ){\\n        let profit = 0;\\n        for(let i = 1; i < prices.length; i++){\\n            if(prices[i] > prices[i - 1]){\\n                profit += prices[i] - prices[i - 1];\\n            }\\n        }\\n        return profit;\\n    }\\n    else{\\n        let dp = new Array(prices.length).fill(0);\\n        let size = prices.length;\\n        for(let t = 1; t <= k; t++){\\n            let min = prices[0];\\n            let max = 0;\\n            for(let i = 0; i < size; i++){\\n                min = Math.min(min, prices[i] - dp[i]);\\n                max = Math.max(max, prices[i] - min);\\n                dp[i] = max\\n            }\\n        }\\n        return dp.pop();   \\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxProfit = function(k, prices) {\\n    if(prices.length == 0) return 0;\\n    \\n    // When k becomes so much larger than the number of prices we can make transactions whenever.\\n    if(k > (prices.length / 2) ){\\n        let profit = 0;\\n        for(let i = 1; i < prices.length; i++){\\n            if(prices[i] > prices[i - 1]){\\n                profit += prices[i] - prices[i - 1];\\n            }\\n        }\\n        return profit;\\n    }\\n    else{\\n        let dp = new Array(prices.length).fill(0);\\n        let size = prices.length;\\n        for(let t = 1; t <= k; t++){\\n            let min = prices[0];\\n            let max = 0;\\n            for(let i = 0; i < size; i++){\\n                min = Math.min(min, prices[i] - dp[i]);\\n                max = Math.max(max, prices[i] - min);\\n                dp[i] = max\\n            }\\n        }\\n        return dp.pop();   \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 54180,
                "title": "8ms-concise-c",
                "content": "the `if (k >= prices.size()/2)` code block is just the solution to Best Time to Buy and Sell Stock II actually, because when k gets too big and prices is much smaller it will be much faster to calculate this way.\\n\\n    class Solution {\\n    public:\\n        int maxProfit(int k, vector<int>& prices) {\\n            if (k == 0) return 0;\\n            if (k >= prices.size()/2) {\\n                int res = 0;\\n                for (int i = 1; i < prices.size(); ++i)\\n                    res += max(prices[i] - prices[i-1], 0);\\n                return res;\\n            }\\n            vector<int> buy(k, INT_MIN);\\n            vector<int> sell(k, 0);\\n            for (int price : prices)\\n                for (int i = 0; i < k; ++i) {\\n                    buy[i] = max(buy[i], (i > 0 ? sell[i-1] : 0) - price);\\n                    sell[i] = max(sell[i], buy[i] + price);\\n                }\\n            return sell.back();\\n        }\\n    };",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int maxProfit(int k, vector<int>& prices) {\\n            if (k == 0) return 0;\\n            if (k >= prices.size()/2) {\\n                int res = 0;\\n                for (int i = 1; i < prices.size(); ++i)\\n                    res += max(prices[i] - prices[i-1], 0);\\n                return res;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2645267,
                "title": "java-o-n-k-time-and-o-k-space-with-explanation-easy-to-understand-hopefully",
                "content": "Note: I\\'ll be using 0 based indexing everywhere in this post.\\n\\nLet\\'s start with the example k = 2, prices = [3,2,6,5,0,3].\\n\\nHere, the answer is 7, buying on day 1 and selling on day 2,for a profit of 4 and then buying on day 4 and selling on day 5, for a profit of 3.\\n\\nMathematically, this can be represented as : (3 - 0) + (6 - 2),\\nwhich can be translated to  3 - (0 - (6 -2)).\\n\\nThus, a general expression can be written as SP<sub>1</sub> - (CP<sub>1</sub>  - (SP<sub>0</sub>  - CP<sub>0</sub> ))\\n,where SP<sub>i</sub>  is the selling price of the stock for the ith transaction, and CP<sub>i</sub>  is the cost price for the i<sup>th</sup> transaction.\\n\\nIt\\'s apparent that initially we have to minimize CP<sub>0</sub>, then maximize the expression (SP<sub>0</sub>  - CP<sub>0</sub> ), which is the profit for the 0th transaction, then minimize (CP<sub>1</sub>  - (SP<sub>0</sub> ,CP<sub>0</sub> )),  and ultimately maximize SP<sub>1</sub>  - (CP<sub>1</sub>  - (SP<sub>0</sub> ,CP<sub>0</sub> )) to get the optimal result.\\n\\nA general expression for k terms can be written as thus : SP<sub>k-1</sub>  - (CP<sub>k-1</sub>  - (SP<sub>k-2</sub>  - CP<sub>k-2</sub> -(.....-(SP<sub>1</sub>  - (CP<sub>1</sub>  - (SP<sub>0</sub>  - CP<sub>0</sub> ))))))\\n\\nIt\\'s important to note that (CP<sub>i</sub>  - (SP<sub>i-1</sub>  - CP<sub>i-1</sub> -(.....-(SP<sub>1</sub>  - (CP<sub>1</sub>  - (SP<sub>0</sub>  - CP<sub>0</sub> )))))) is the overall cost price for the i<sup>th</sup> transaction.\\nSimilarly, SP<sub>i</sub>  - (CP<sub>i</sub>  - (SP<sub>i-1</sub>  - CP<sub>i-2</sub> -(.....-(SP<sub>1</sub>  - (CP<sub>1</sub>  - (SP<sub>0</sub>  - CP<sub>0</sub> )))))) is the overall profit for the i<sup>th</sup> transaction.\\n\\nTherefore, the recurrent relation for the i<sup>th</sup> cost price can be written as :\\nCP<sub>i</sub> = CP<sub>i</sub> - Profit<sub>i-1</sub>\\nand the recurrent relation for profit for ith transaction can be written as :\\nProfit<sub>i</sub> = SP<sub>i</sub> - CP<sub>i</sub>\\n\\nSo here\\'s what we\\'ll do, maintain two arrays cost and profit, where cost[i] will store the minimum cost price of the stock for the i<sup>th</sup> transaction, and profit[i] will store the maximum profit for the i<sup>th</sup> transaction.\\n\\nCode : \\n```\\npublic int maxProfit(int k, int[] prices) {\\n       int profit[] = new int[k];\\n       int cost[] = new int[k];\\n       Arrays.fill(cost, Integer.MAX_VALUE);\\n       for(int currPrice : prices){\\n            cost[0] = Math.min(cost[0], currPrice);\\n            profit[0] = Math.max(profit[0], currPrice-cost[0]);\\n\\t\\t\\tfor(int j = 1;  j < k; j++){\\n                cost[j] = Math.min(cost[j], currPrice - profit[j-1]);\\n                profit[j] = Math.max(profit[j], currPrice - cost[j]);\\n            }\\n       }\\n       return profit[k-1];\\n   }\\n  \\n\\t",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "Note: I\\'ll be using 0 based indexing everywhere in this post.\\n\\nLet\\'s start with the example k = 2, prices = [3,2,6,5,0,3].\\n\\nHere, the answer is 7, buying on day 1 and selling on day 2,for a profit of 4 and then buying on day 4 and selling on day 5, for a profit of 3.\\n\\nMathematically, this can be represented as : (3 - 0) + (6 - 2),\\nwhich can be translated to  3 - (0 - (6 -2)).\\n\\nThus, a general expression can be written as SP<sub>1</sub> - (CP<sub>1</sub>  - (SP<sub>0</sub>  - CP<sub>0</sub> ))\\n,where SP<sub>i</sub>  is the selling price of the stock for the ith transaction, and CP<sub>i</sub>  is the cost price for the i<sup>th</sup> transaction.\\n\\nIt\\'s apparent that initially we have to minimize CP<sub>0</sub>, then maximize the expression (SP<sub>0</sub>  - CP<sub>0</sub> ), which is the profit for the 0th transaction, then minimize (CP<sub>1</sub>  - (SP<sub>0</sub> ,CP<sub>0</sub> )),  and ultimately maximize SP<sub>1</sub>  - (CP<sub>1</sub>  - (SP<sub>0</sub> ,CP<sub>0</sub> )) to get the optimal result.\\n\\nA general expression for k terms can be written as thus : SP<sub>k-1</sub>  - (CP<sub>k-1</sub>  - (SP<sub>k-2</sub>  - CP<sub>k-2</sub> -(.....-(SP<sub>1</sub>  - (CP<sub>1</sub>  - (SP<sub>0</sub>  - CP<sub>0</sub> ))))))\\n\\nIt\\'s important to note that (CP<sub>i</sub>  - (SP<sub>i-1</sub>  - CP<sub>i-1</sub> -(.....-(SP<sub>1</sub>  - (CP<sub>1</sub>  - (SP<sub>0</sub>  - CP<sub>0</sub> )))))) is the overall cost price for the i<sup>th</sup> transaction.\\nSimilarly, SP<sub>i</sub>  - (CP<sub>i</sub>  - (SP<sub>i-1</sub>  - CP<sub>i-2</sub> -(.....-(SP<sub>1</sub>  - (CP<sub>1</sub>  - (SP<sub>0</sub>  - CP<sub>0</sub> )))))) is the overall profit for the i<sup>th</sup> transaction.\\n\\nTherefore, the recurrent relation for the i<sup>th</sup> cost price can be written as :\\nCP<sub>i</sub> = CP<sub>i</sub> - Profit<sub>i-1</sub>\\nand the recurrent relation for profit for ith transaction can be written as :\\nProfit<sub>i</sub> = SP<sub>i</sub> - CP<sub>i</sub>\\n\\nSo here\\'s what we\\'ll do, maintain two arrays cost and profit, where cost[i] will store the minimum cost price of the stock for the i<sup>th</sup> transaction, and profit[i] will store the maximum profit for the i<sup>th</sup> transaction.\\n\\nCode : \\n```\\npublic int maxProfit(int k, int[] prices) {\\n       int profit[] = new int[k];\\n       int cost[] = new int[k];\\n       Arrays.fill(cost, Integer.MAX_VALUE);\\n       for(int currPrice : prices){\\n            cost[0] = Math.min(cost[0], currPrice);\\n            profit[0] = Math.max(profit[0], currPrice-cost[0]);\\n\\t\\t\\tfor(int j = 1;  j < k; j++){\\n                cost[j] = Math.min(cost[j], currPrice - profit[j-1]);\\n                profit[j] = Math.max(profit[j], currPrice - cost[j]);\\n            }\\n       }\\n       return profit[k-1];\\n   }\\n  \\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 54172,
                "title": "quick-n-easy-9-liner-in-python-using-memo",
                "content": "Gets TLE because no optimizations are there but it's quick and easy to code up during an interview, so we can demonstrate the interviewer we can code something quick and fast and then move on to more sophisticated implementations of the same algorithm. Hope you like it.\\n\\n```\\nclass Solution(object):\\n    def maxProfit(self, k, prices):\\n        def solve(prices, k, idx, memo={}):\\n            if idx <= 0 or not k: return 0\\n            if (k, idx) in memo: return memo[k, idx]\\n            nosell, sell = solve(prices, k, idx-1, memo), 0\\n            for i in range(idx):\\n                sell = max(sell, prices[idx] - prices[i] + solve(prices, k-1, i, memo))\\n            memo[k, idx] = max(sell, nosell)\\n            return memo[k, idx]\\n        return solve(prices, k, len(prices) - 1)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxProfit(self, k, prices):\\n        def solve(prices, k, idx, memo={}):\\n            if idx <= 0 or not k: return 0\\n            if (k, idx) in memo: return memo[k, idx]\\n            nosell, sell = solve(prices, k, idx-1, memo), 0\\n            for i in range(idx):\\n                sell = max(sell, prices[idx] - prices[i] + solve(prices, k-1, i, memo))\\n            memo[k, idx] = max(sell, nosell)\\n            return memo[k, idx]\\n        return solve(prices, k, len(prices) - 1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557154,
                "title": "dp-top-down-explained-and-commented",
                "content": "We want to maximize our profits and we only have `k` transactions to make.\\n\\nThe state machine of the states we can be at:\\n\\n* Holding a stock - we can sell or keep holding\\n* Not holding a stock - we can buy or keep not holding\\n\\nNow there are few optimizations that need to be made:\\n\\n* If we bought a stock yesterday for a price of 7, and today it\\'s 5. We should update that the purchased price to 5. We are trying to find the `local minima` for the purchase price to reduce the DP states.\\n* If we are considering to sell a stock today for 7 but tomorrow the price is 8, we should hold. We are trying to find the `local maxima` for the selling point to reduce DP states.\\n\\nIn the end we just try the our possible state transitions and cache the intermediate sub problems with memoization to reduce solving repeated subproblems. Finding local minima and maxima will reduce our states.\\n\\n```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        if not prices: return 0\\n        n = len(prices)\\n        \\n        @lru_cache(maxsize=None)\\n        def solve(t_left: int, i:int, bought_price: int):\\n            if i == n or t_left == 0:\\n                return 0\\n            \\n            # Not holding a stock\\n            if bought_price == -1:\\n                buy = 0\\n                # buy (optimize for minima)\\n                if not (i+1 < n and prices[i+1] < prices[i]):\\n                    buy = solve(t_left, i+1, prices[i])\\n                # or not buy\\n                not_buy = solve(t_left, i + 1, -1)\\n                return max(buy, not_buy)\\n        \\n            # holding\\n            else:\\n                sell = 0\\n                # make profit optimization + maxima optimization\\n                if prices[i] - bought_price > 0 and not (i+1 < n and prices[i+1] > prices[i]):\\n                    sell = prices[i] - bought_price + solve(t_left - 1, i + 1, -1)\\n                \\n                # if you don\\'t sell, optimize minima\\n                not_sell = solve(t_left, i + 1, min(bought_price, prices[i]))\\n                return max(sell, not_sell)\\n        \\n        return solve(k, 0, -1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        if not prices: return 0\\n        n = len(prices)\\n        \\n        @lru_cache(maxsize=None)\\n        def solve(t_left: int, i:int, bought_price: int):\\n            if i == n or t_left == 0:\\n                return 0\\n            \\n            # Not holding a stock\\n            if bought_price == -1:\\n                buy = 0\\n                # buy (optimize for minima)\\n                if not (i+1 < n and prices[i+1] < prices[i]):\\n                    buy = solve(t_left, i+1, prices[i])\\n                # or not buy\\n                not_buy = solve(t_left, i + 1, -1)\\n                return max(buy, not_buy)\\n        \\n            # holding\\n            else:\\n                sell = 0\\n                # make profit optimization + maxima optimization\\n                if prices[i] - bought_price > 0 and not (i+1 < n and prices[i+1] > prices[i]):\\n                    sell = prices[i] - bought_price + solve(t_left - 1, i + 1, -1)\\n                \\n                # if you don\\'t sell, optimize minima\\n                not_sell = solve(t_left, i + 1, min(bought_price, prices[i]))\\n                return max(sell, not_sell)\\n        \\n        return solve(k, 0, -1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504285,
                "title": "super-simple-and-easy-to-understand-js-solution-with-explanation",
                "content": "Before reading this, I suggest you have a try for https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/\\nfirst.\\n\\nMost of the solutions I found are using two status: buy and sell, and maintain the max profit for both, which I somehow found abstract and difficult to understand. If you also think so, this solution may help you understand the question from another perspective.\\n\\nThis is my ans to it:\\nit is obvious that in this question profit = price - cost. So we just need to store the min cost before curernt day, and sell it at the highest price to get the max profit for the 1st transaction.\\n\\nAnd for the second transaction, we need a find another minimum cost, meanwhile keeping the profit from 1st transaction as maximum.\\nTo satisfy this we can just use min(price - profit1) as min cost2.\\n\\n```\\nvar maxProfit = function(prices) {\\n    let cost1 = prices[0];\\n    let cost2 = prices[0];\\n    let profit1 = 0;\\n    let profit2 = 0;\\n    \\n    for(let i = 1; i < prices.length; i++){\\n        profit1 = Math.max(profit1, prices[i] - cost1);\\n        profit2 = Math.max(profit2, prices[i] - cost2);\\n        \\n        cost1 = Math.min(cost1, prices[i]);\\n        cost2 = Math.min(cost2, prices[i] - profit1);\\n    }\\n    \\n    return profit2;\\n};\\n```\\n\\nNow back to this question. Let\\'s say we have k = 3. Can we modify the solution above to get the ans?\\n\\nvery simple. we just copy and paste a set of codes for transaction3:\\n```\\nvar maxProfit = function(prices) {\\n    let cost1 = prices[0];\\n    let cost2 = prices[0];\\n\\tlet cost3 = prices[0];\\n\\t\\n    let profit1 = 0;\\n    let profit2 = 0;\\n\\tlet profit3 = 0;\\n    \\n    for(let i = 1; i < prices.length; i++){\\n        profit1 = Math.max(profit1, prices[i] - cost1);\\n        profit2 = Math.max(profit2, prices[i] - cost2);\\n\\t\\tprofit3 = Math.max(profit3, prices[i] - cost3);\\n        \\n        cost1 = Math.min(cost1, prices[i]);\\n        cost2 = Math.min(cost2, prices[i] - profit1);\\n\\t\\tcost3 = Math.min(cost3, prices[i] - profit2);\\n    }\\n    \\n    return profit3;\\n};\\n```\\n\\nOne point we observe is that, to determine the min cost for transaction[k], we need to know the profit of transaction[k-1]. \\n\\nNow we convert the copy and paste parts into arrays and a loop. \\n\\n```\\nvar maxProfit = function(k, prices) {\\n    if(prices.length <= 1) return 0;\\n\\t\\n\\t//as we are now using arrays, we also store \"cost0\" and \"profit0\" for easier coding. So we need have k+1 elements.\\n    let costs = Array(k+1).fill(Number.MAX_SAFE_INTEGER);\\n    let profits = Array(k+1).fill(0);\\n    \\n    profits[0] = 0;\\n    costs[0] = prices[0];\\n    \\n    for(let i = 0; i < prices.length; i++){\\n        for(let j = 1; j <= k; j++){\\n            profits[j] = Math.max(profits[j], prices[i] - costs[j]);  \\n            costs[j] = Math.min(costs[j], prices[i] - profits[j-1]);\\n        }\\n    }\\n\\n\\t//from the above loop we also maintain the max profits[k] with different i. So we can just return profits[k].\\n    return profits[k];\\n};\\n```\\n\\nPlease upvote if it helps. Thanks.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxProfit = function(prices) {\\n    let cost1 = prices[0];\\n    let cost2 = prices[0];\\n    let profit1 = 0;\\n    let profit2 = 0;\\n    \\n    for(let i = 1; i < prices.length; i++){\\n        profit1 = Math.max(profit1, prices[i] - cost1);\\n        profit2 = Math.max(profit2, prices[i] - cost2);\\n        \\n        cost1 = Math.min(cost1, prices[i]);\\n        cost2 = Math.min(cost2, prices[i] - profit1);\\n    }\\n    \\n    return profit2;\\n};\\n```\n```\\nvar maxProfit = function(prices) {\\n    let cost1 = prices[0];\\n    let cost2 = prices[0];\\n\\tlet cost3 = prices[0];\\n\\t\\n    let profit1 = 0;\\n    let profit2 = 0;\\n\\tlet profit3 = 0;\\n    \\n    for(let i = 1; i < prices.length; i++){\\n        profit1 = Math.max(profit1, prices[i] - cost1);\\n        profit2 = Math.max(profit2, prices[i] - cost2);\\n\\t\\tprofit3 = Math.max(profit3, prices[i] - cost3);\\n        \\n        cost1 = Math.min(cost1, prices[i]);\\n        cost2 = Math.min(cost2, prices[i] - profit1);\\n\\t\\tcost3 = Math.min(cost3, prices[i] - profit2);\\n    }\\n    \\n    return profit3;\\n};\\n```\n```\\nvar maxProfit = function(k, prices) {\\n    if(prices.length <= 1) return 0;\\n\\t\\n\\t//as we are now using arrays, we also store \"cost0\" and \"profit0\" for easier coding. So we need have k+1 elements.\\n    let costs = Array(k+1).fill(Number.MAX_SAFE_INTEGER);\\n    let profits = Array(k+1).fill(0);\\n    \\n    profits[0] = 0;\\n    costs[0] = prices[0];\\n    \\n    for(let i = 0; i < prices.length; i++){\\n        for(let j = 1; j <= k; j++){\\n            profits[j] = Math.max(profits[j], prices[i] - costs[j]);  \\n            costs[j] = Math.min(costs[j], prices[i] - profits[j-1]);\\n        }\\n    }\\n\\n\\t//from the above loop we also maintain the max profits[k] with different i. So we can just return profits[k].\\n    return profits[k];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2217435,
                "title": "buy-and-sell-stocks-iv-using-simple-dp-concept-o-n-o-k",
                "content": "Similar concept like Buy & Sell Stocks III, with little modification.\\nBuy & Sell Stocks III solutions:\\n```\\n int maxProfit(vector<int>& price) {\\n        vector<long int>dp(5, INT_MIN);\\n        dp[0]=0;\\n        for(int i=0;i<price.size();i++)\\n        {\\n            vector<long int> temp(5);\\n            temp = dp;\\n\\n            dp[1]=max(temp[1], temp[0]-price[i]);\\n            dp[2]=max(temp[2], temp[1]+price[i]);\\n            dp[3]=max(temp[3], temp[2]-price[i]);\\n            dp[4]=max(temp[4], temp[3]+price[i]);\\n        }\\n        \\n        return (int)max(dp[0], max(dp[2], dp[4]));\\n    }\\n```\\n\\nBuy & Sell Stock IV Solution:\\n```\\nint maxProfit(int k, vector<int>& price) {\\n       vector<int>dp(2*k +1 , INT_MIN);\\n       dp[0]=0;\\n       \\n           for(int j=0;j<price.size();j++)\\n           {\\n               for(int i=0;i+2<=2*k;i=i+2)\\n                {\\n                    dp[i+1] = max(dp[i+1], dp[i]-price[j]);\\n                    dp[i+2] = max(dp[i+2], dp[i+1]+price[j]);\\n                }\\n            }\\n       return *max_element(dp.begin(), dp.end());\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n int maxProfit(vector<int>& price) {\\n        vector<long int>dp(5, INT_MIN);\\n        dp[0]=0;\\n        for(int i=0;i<price.size();i++)\\n        {\\n            vector<long int> temp(5);\\n            temp = dp;\\n\\n            dp[1]=max(temp[1], temp[0]-price[i]);\\n            dp[2]=max(temp[2], temp[1]+price[i]);\\n            dp[3]=max(temp[3], temp[2]-price[i]);\\n            dp[4]=max(temp[4], temp[3]+price[i]);\\n        }\\n        \\n        return (int)max(dp[0], max(dp[2], dp[4]));\\n    }\\n```\n```\\nint maxProfit(int k, vector<int>& price) {\\n       vector<int>dp(2*k +1 , INT_MIN);\\n       dp[0]=0;\\n       \\n           for(int j=0;j<price.size();j++)\\n           {\\n               for(int i=0;i+2<=2*k;i=i+2)\\n                {\\n                    dp[i+1] = max(dp[i+1], dp[i]-price[j]);\\n                    dp[i+2] = max(dp[i+2], dp[i+1]+price[j]);\\n                }\\n            }\\n       return *max_element(dp.begin(), dp.end());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 762595,
                "title": "java-resursive-solution-with-memoization-easy-to-understand",
                "content": "```\\nclass Solution {\\n \\n    public int maxProfit(int k, int[] prices) {\\n        \\n        if(prices == null)return 0;\\n        \\n        int N = prices.length;\\n        \\n        if(N == 0){\\n            return 0;\\n          }\\n           \\n          if(k >= N/2){\\n             int ans = 0;\\n              for(int i = 1 ; i < N ; i++){\\n                  if(prices[i] > prices[i-1]){\\n                      ans += prices[i] - prices[i - 1];\\n                  }\\n              }\\n              return ans;\\n           }\\n        \\n        int[][][] memo = new int[k][N][2];\\n        \\n        return helper(prices , 0 , k - 1 , 0,memo);\\n    }\\n    \\n    \\n    private int helper(int[]prices,int index, int k, int flag , int[][][]memo){\\n       \\n        if(index >= prices.length || k == -1 ){\\n            return 0;\\n        }\\n        \\n         if(memo[k][index][flag] != 0){\\n             return memo[k][index][flag];\\n         }\\n        \\n          int buy = 0 , noBuy = 0, sell = 0, noSell = 0 , max = 0;\\n        \\n          if(flag == 0){\\n              buy =  helper(prices , index + 1 ,k , 1 , memo) - prices[index];\\n              noBuy = helper(prices , index + 1,k , 0 , memo);\\n          }else{\\n              sell = helper(prices ,index + 1  , k - 1 , 0 , memo) + prices[index];\\n              noSell = helper(prices ,index + 1  , k, 1 , memo);\\n          } \\n        max = Math.max(Math.max(buy,noBuy), Math.max(sell,noSell) );\\n        memo[k][index][flag] = max;\\n        return max;\\n     }\\n  \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n \\n    public int maxProfit(int k, int[] prices) {\\n        \\n        if(prices == null)return 0;\\n        \\n        int N = prices.length;\\n        \\n        if(N == 0){\\n            return 0;\\n          }\\n           \\n          if(k >= N/2){\\n             int ans = 0;\\n              for(int i = 1 ; i < N ; i++){\\n                  if(prices[i] > prices[i-1]){\\n                      ans += prices[i] - prices[i - 1];\\n                  }\\n              }\\n              return ans;\\n           }\\n        \\n        int[][][] memo = new int[k][N][2];\\n        \\n        return helper(prices , 0 , k - 1 , 0,memo);\\n    }\\n    \\n    \\n    private int helper(int[]prices,int index, int k, int flag , int[][][]memo){\\n       \\n        if(index >= prices.length || k == -1 ){\\n            return 0;\\n        }\\n        \\n         if(memo[k][index][flag] != 0){\\n             return memo[k][index][flag];\\n         }\\n        \\n          int buy = 0 , noBuy = 0, sell = 0, noSell = 0 , max = 0;\\n        \\n          if(flag == 0){\\n              buy =  helper(prices , index + 1 ,k , 1 , memo) - prices[index];\\n              noBuy = helper(prices , index + 1,k , 0 , memo);\\n          }else{\\n              sell = helper(prices ,index + 1  , k - 1 , 0 , memo) + prices[index];\\n              noSell = helper(prices ,index + 1  , k, 1 , memo);\\n          } \\n        max = Math.max(Math.max(buy,noBuy), Math.max(sell,noSell) );\\n        memo[k][index][flag] = max;\\n        return max;\\n     }\\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463598,
                "title": "python-short-o-nlogw-solution-with-alien-trick",
                "content": "Let\\'s give every transaction a transaction fee. An observation is that as we increase the transaction fee, the number of transactions we take will either stay or the same or decrease, so we can binary search for the transaction fee that results in K transactions. Then we just find the maximum profit we get and then re-add the amount we paid in transaction fees. \\n\\nUnderstanding why this is correct is tricky.\\n\\nLet `f(x)` be the maximum profit with `x` transactions with no transaction fee. We notice that `f(x)` is concave - `f(x + 1) - f(x) <= f(x) - f(x - 1)` (intuitively adding the x+1th transaction will help less than the xth transaction).  When we run `calc` over such a function, we get the global maximum (when what we really want is the value of the function at `f(k)`).  \\n\\nImagine if we could somehow shift the global maximum of `f(x)` to `k`. Then we could just run `calc` over it, find the new global maximum (just the value at k), and un-shift the function. That\\'s where the transaction fee comes in. We create a new function `g(x) = f(x) - fee * x`, where `g(k)` is the maximum point in `g`. Then we can simply run `calc` over `g` and then add `fee * k`. \\n\\nSince our function is concave, we binary search for the transaction fee `mid` that causes a maximum point at `k`. Then we compute the peak at the shifted function and then add `fee * k`. \\n\\n```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        if not prices: return 0\\n        def calc(cost):\\n            best = (-prices[0], 0)\\n            current = (0, 0)\\n            \\n            for i in range(1, len(prices)):\\n                if prices[i] + best[0] - cost > current[0]:\\n                    current = (prices[i] + best[0] - cost, 1 + best[-1])\\n                if current[0] - prices[i] > best[0]:\\n                    best = (current[0] - prices[i], current[-1])\\n            return current\\n        \\n        l = 0\\n        r = max(prices)\\n        while l < r:\\n            mid = (l + r)//2\\n            if calc(mid)[-1] > k:\\n                l = mid + 1\\n            else:\\n                r = mid\\n            \\n        return calc(l)[0] + l * k\\n```\\n\\nThe function `calc` is essentially https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/, it returns a tuple `(max_profit, n_transactions)`, when given a transaction fee.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        if not prices: return 0\\n        def calc(cost):\\n            best = (-prices[0], 0)\\n            current = (0, 0)\\n            \\n            for i in range(1, len(prices)):\\n                if prices[i] + best[0] - cost > current[0]:\\n                    current = (prices[i] + best[0] - cost, 1 + best[-1])\\n                if current[0] - prices[i] > best[0]:\\n                    best = (current[0] - prices[i], current[-1])\\n            return current\\n        \\n        l = 0\\n        r = max(prices)\\n        while l < r:\\n            mid = (l + r)//2\\n            if calc(mid)[-1] > k:\\n                l = mid + 1\\n            else:\\n                r = mid\\n            \\n        return calc(l)[0] + l * k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 407062,
                "title": "3-solutions-different-complexities-with-detailed-explanation",
                "content": "```\\nclass Solution {\\n    \\n    public int maxProfit(int k, int[] prices) {\\n        //return maxProfitInCubicTimeAndQuadraticSpace(k, prices);\\n        //return maxProfitInQuadraticTimeAndQuadraticSpace(k, prices);\\n        return maxProfitInQuadraticTimeAndLinearSpace(k, prices);\\n    }\\n    \\n    /*\\n        Approach - For a situation where k>n/2, it effectively means you can do any number of transactions \\n        so, follow the usual approach of buying and selling. For cases where k<=n/2, Think DP. \\n        \\n        Let\\'s say f(i,j) is the profit with doing at most j transactions until day i.\\n        If you have to calculate f(i, j), thinking logically, there could be two possibilities :-\\n        1. You don\\'t sell/buy anything on this day, i.e. by day number i-1, you have already completed j \\n        transactions. You can quantify this by saying, \"The profit I got by doing at most j transactions by \\n        day number i-1\". As a function that means f(i-1, j).\\n        2. You sold the last share on the ith day, thereby completing j transactions on the ith day. However,\\n        that would mean that you would have bought that share sometime earlier. Let\\'s say you bought that on \\n        day number m. Then you can quantify this by saying, \"The profit I got by doing j-1 transctions until \\n        mth day, then buying a share on the mth day and selling it on the ith day\". The reason for \"j-1 \\n        transactions until the mth day\" is that you\\'re allowed to be in the middle of any one buy/sell cycle.\\n        So if you bought your jth transaction on mth day, you should have sold your (j-1)th transaction on the \\n        mth day before buying the jth transaction. Now as a function this will have 3 components :-\\n            i) f(m, j-1) = Profit achieved by doing at most (j-1) transactions until day m.\\n            ii) -prices[m] = Because you bought on mth day, so your profit decreases by prices[m], i.e.\\n                the price of the stock on mth day. Thus -prices[m].\\n            iii) +prices[i] = Since you\\'re selling on ith day so you add prices[i] to your profit, i.e. the \\n                price of the stock on ith day.\\n        \\n        Combined it becomes f(m, j-1)-prices[m]+prices[i]. Now we assumed that we bought on mth day. This can\\n        actually be any day before ith day. Since we have to maximize our profit, so we take :-\\n        MAX(f(m, j-1)-prices[m]+prices[i]), for 0<m<i.\\n        \\n        Our formula then becomes :-\\n        f(i,j) = MAX(f(i-1, j), MAX(f(m, j-1)-prices[m]+prices[i])) where 0<m<i.\\n        \\n        This is applied using a usual DP solution. Time Complexity is O(n^2) is for the i,j traversal, and \\n        another linear search to find MAX(f(m, j-1)-prices[m]+prices[i]) where we traverse all\\n        values for m where 0<m<i;\\n        \\n        Thus TimeComplexity - O(n^3). Space Complexity - O(n^2);\\n    */\\n    public int maxProfitInCubicTimeAndQuadraticSpace(int k, int[] prices) {\\n        int n = prices.length;\\n        if(n<=0)return 0;\\n        if(k>n/2){\\n            int buy = -prices[0], sell=0, afterBuy=0, afterSell=0;\\n            for(int i=1;i<n;i++){\\n                afterSell = Math.max(sell, buy+prices[i]);\\n                afterBuy = Math.max(buy, sell-prices[i]);\\n                sell = afterSell;\\n                buy = afterBuy;\\n            }\\n            return afterSell;\\n        }\\n        int dp[][] = new int [n+1][k+1];\\n        for(int i=0;i<=n;i++)dp[i][0]=0;\\n        for(int i=0;i<=k;i++)dp[0][i]=0;\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<=k;j++){\\n                for (int m=0;m<i;m++){\\n                    dp[i][j] = Math.max(dp[i][j], Math.max(dp[i-1][j], dp[m][j-1]-prices[m]+prices[i]));\\n                }\\n            }\\n        }\\n        \\n        return dp[n-1][k];\\n    }\\n    \\n    /*\\n        The above approach gets accepted but it very slow. How can we optimize it? Let\\'s look at the second \\n        part of our expression, i.e. MAX(f(m, j-1)-prices[m]+prices[i]). This can be written as \\n        prices[i]+MAX(f(m, j-1)-prices[m]). Technically, we\\'re running a linear search to find the max value \\n        of the expression inside the parentheses. \\n        But we don\\'t need that. m is effectively different values of i. We\\'re already running a loop for i, \\n        why can\\'t we just keep track of the maximum value of f(i, j-1)-prices[i] encountered so far? \\n        And then when the next value of i is assigned, max the new value of this expression with the old one. \\n        This means that at every iteration of i, we can calculate prices[i]+MAX(f(m, j-1)-prices[m]) in \\n        constant time. That removes the need for linear search and hence reduces time complexity to O(n^2).\\n        \\n        Time Complexity - O(n^2) Space Complexity - O(n^2)\\n    */\\n\\n    public int maxProfitInQuadraticTimeAndQuadraticSpace(int k, int[] prices) {\\n        int n = prices.length;\\n        if(n<=1)return 0;\\n        if(k>n/2){\\n            int buy = -prices[0], sell=0, afterBuy=0, afterSell=0;\\n            for(int i=1;i<n;i++){\\n                afterSell = Math.max(sell, buy+prices[i]);\\n                afterBuy = Math.max(buy, sell-prices[i]);\\n                sell = afterSell;\\n                buy = afterBuy;\\n            }\\n            return afterSell;\\n        }\\n        int dp[][] = new int [n+1][k+1];\\n        for(int i=0;i<=n;i++)dp[i][0]=0;\\n        for(int i=0;i<=k;i++)dp[0][i]=0;\\n        \\n        for(int j=1;j<=k;j++){\\n            int state = Integer.MIN_VALUE;\\n            for(int i=1;i<n;i++){    \\n                state = Math.max(state, dp[i-1][j-1]-prices[i-1]);\\n                dp[i][j] = Math.max(dp[i][j], Math.max(dp[i-1][j], state+prices[i]));\\n            }\\n        }\\n        \\n        return dp[n-1][k];\\n    }\\n    \\n    /*\\n        The above solution optimized for time but the amount of space that we take is still huge. We can \\n        notice that any time, for calculating f(i,j) all we need is values of (i-1) and (j-1). That would\\n        mean that for our dp[][] array, we only ever require two columns - column j and column j-1. i-1 is in\\n        the same column as i so nothing special required there.\\n        \\n        Thus we keep two columns instead of a grid - prev and curr. prev is to denote j-1 column and curr is\\n        to denote j column. Then we just repeat what we did in the above function\\n        \\n        Time Complexity - O(n^2) Space Complexity - O(n);\\n    */\\n    public int maxProfitInQuadraticTimeAndLinearSpace(int k, int[] prices) {\\n        int n = prices.length;\\n        if(n<=1)return 0;\\n        if(k>n/2){\\n            int buy = -prices[0], sell=0, afterBuy=0, afterSell=0;\\n            for(int i=1;i<n;i++){\\n                afterSell = Math.max(sell, buy+prices[i]);\\n                afterBuy = Math.max(buy, sell-prices[i]);\\n                sell = afterSell;\\n                buy = afterBuy;\\n            }\\n            return afterSell;\\n        }\\n        int prev [] = new int [n];\\n        int curr [] = new int [n];\\n        \\n        for(int j=1;j<=k;j++){\\n            int state = Integer.MIN_VALUE;\\n            prev = Arrays.copyOf(curr,curr.length);\\n            Arrays.fill(curr, 0);\\n            for(int i=1;i<n;i++){\\n                state = Math.max(state, prev[i-1]-prices[i-1]);\\n                curr[i] = Math.max(curr[i], Math.max(curr[i-1], state+prices[i]));\\n            }\\n        }\\n        return curr[n-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int maxProfit(int k, int[] prices) {\\n        //return maxProfitInCubicTimeAndQuadraticSpace(k, prices);\\n        //return maxProfitInQuadraticTimeAndQuadraticSpace(k, prices);\\n        return maxProfitInQuadraticTimeAndLinearSpace(k, prices);\\n    }\\n    \\n    /*\\n        Approach - For a situation where k>n/2, it effectively means you can do any number of transactions \\n        so, follow the usual approach of buying and selling. For cases where k<=n/2, Think DP. \\n        \\n        Let\\'s say f(i,j) is the profit with doing at most j transactions until day i.\\n        If you have to calculate f(i, j), thinking logically, there could be two possibilities :-\\n        1. You don\\'t sell/buy anything on this day, i.e. by day number i-1, you have already completed j \\n        transactions. You can quantify this by saying, \"The profit I got by doing at most j transactions by \\n        day number i-1\". As a function that means f(i-1, j).\\n        2. You sold the last share on the ith day, thereby completing j transactions on the ith day. However,\\n        that would mean that you would have bought that share sometime earlier. Let\\'s say you bought that on \\n        day number m. Then you can quantify this by saying, \"The profit I got by doing j-1 transctions until \\n        mth day, then buying a share on the mth day and selling it on the ith day\". The reason for \"j-1 \\n        transactions until the mth day\" is that you\\'re allowed to be in the middle of any one buy/sell cycle.\\n        So if you bought your jth transaction on mth day, you should have sold your (j-1)th transaction on the \\n        mth day before buying the jth transaction. Now as a function this will have 3 components :-\\n            i) f(m, j-1) = Profit achieved by doing at most (j-1) transactions until day m.\\n            ii) -prices[m] = Because you bought on mth day, so your profit decreases by prices[m], i.e.\\n                the price of the stock on mth day. Thus -prices[m].\\n            iii) +prices[i] = Since you\\'re selling on ith day so you add prices[i] to your profit, i.e. the \\n                price of the stock on ith day.\\n        \\n        Combined it becomes f(m, j-1)-prices[m]+prices[i]. Now we assumed that we bought on mth day. This can\\n        actually be any day before ith day. Since we have to maximize our profit, so we take :-\\n        MAX(f(m, j-1)-prices[m]+prices[i]), for 0<m<i.\\n        \\n        Our formula then becomes :-\\n        f(i,j) = MAX(f(i-1, j), MAX(f(m, j-1)-prices[m]+prices[i])) where 0<m<i.\\n        \\n        This is applied using a usual DP solution. Time Complexity is O(n^2) is for the i,j traversal, and \\n        another linear search to find MAX(f(m, j-1)-prices[m]+prices[i]) where we traverse all\\n        values for m where 0<m<i;\\n        \\n        Thus TimeComplexity - O(n^3). Space Complexity - O(n^2);\\n    */\\n    public int maxProfitInCubicTimeAndQuadraticSpace(int k, int[] prices) {\\n        int n = prices.length;\\n        if(n<=0)return 0;\\n        if(k>n/2){\\n            int buy = -prices[0], sell=0, afterBuy=0, afterSell=0;\\n            for(int i=1;i<n;i++){\\n                afterSell = Math.max(sell, buy+prices[i]);\\n                afterBuy = Math.max(buy, sell-prices[i]);\\n                sell = afterSell;\\n                buy = afterBuy;\\n            }\\n            return afterSell;\\n        }\\n        int dp[][] = new int [n+1][k+1];\\n        for(int i=0;i<=n;i++)dp[i][0]=0;\\n        for(int i=0;i<=k;i++)dp[0][i]=0;\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<=k;j++){\\n                for (int m=0;m<i;m++){\\n                    dp[i][j] = Math.max(dp[i][j], Math.max(dp[i-1][j], dp[m][j-1]-prices[m]+prices[i]));\\n                }\\n            }\\n        }\\n        \\n        return dp[n-1][k];\\n    }\\n    \\n    /*\\n        The above approach gets accepted but it very slow. How can we optimize it? Let\\'s look at the second \\n        part of our expression, i.e. MAX(f(m, j-1)-prices[m]+prices[i]). This can be written as \\n        prices[i]+MAX(f(m, j-1)-prices[m]). Technically, we\\'re running a linear search to find the max value \\n        of the expression inside the parentheses. \\n        But we don\\'t need that. m is effectively different values of i. We\\'re already running a loop for i, \\n        why can\\'t we just keep track of the maximum value of f(i, j-1)-prices[i] encountered so far? \\n        And then when the next value of i is assigned, max the new value of this expression with the old one. \\n        This means that at every iteration of i, we can calculate prices[i]+MAX(f(m, j-1)-prices[m]) in \\n        constant time. That removes the need for linear search and hence reduces time complexity to O(n^2).\\n        \\n        Time Complexity - O(n^2) Space Complexity - O(n^2)\\n    */\\n\\n    public int maxProfitInQuadraticTimeAndQuadraticSpace(int k, int[] prices) {\\n        int n = prices.length;\\n        if(n<=1)return 0;\\n        if(k>n/2){\\n            int buy = -prices[0], sell=0, afterBuy=0, afterSell=0;\\n            for(int i=1;i<n;i++){\\n                afterSell = Math.max(sell, buy+prices[i]);\\n                afterBuy = Math.max(buy, sell-prices[i]);\\n                sell = afterSell;\\n                buy = afterBuy;\\n            }\\n            return afterSell;\\n        }\\n        int dp[][] = new int [n+1][k+1];\\n        for(int i=0;i<=n;i++)dp[i][0]=0;\\n        for(int i=0;i<=k;i++)dp[0][i]=0;\\n        \\n        for(int j=1;j<=k;j++){\\n            int state = Integer.MIN_VALUE;\\n            for(int i=1;i<n;i++){    \\n                state = Math.max(state, dp[i-1][j-1]-prices[i-1]);\\n                dp[i][j] = Math.max(dp[i][j], Math.max(dp[i-1][j], state+prices[i]));\\n            }\\n        }\\n        \\n        return dp[n-1][k];\\n    }\\n    \\n    /*\\n        The above solution optimized for time but the amount of space that we take is still huge. We can \\n        notice that any time, for calculating f(i,j) all we need is values of (i-1) and (j-1). That would\\n        mean that for our dp[][] array, we only ever require two columns - column j and column j-1. i-1 is in\\n        the same column as i so nothing special required there.\\n        \\n        Thus we keep two columns instead of a grid - prev and curr. prev is to denote j-1 column and curr is\\n        to denote j column. Then we just repeat what we did in the above function\\n        \\n        Time Complexity - O(n^2) Space Complexity - O(n);\\n    */\\n    public int maxProfitInQuadraticTimeAndLinearSpace(int k, int[] prices) {\\n        int n = prices.length;\\n        if(n<=1)return 0;\\n        if(k>n/2){\\n            int buy = -prices[0], sell=0, afterBuy=0, afterSell=0;\\n            for(int i=1;i<n;i++){\\n                afterSell = Math.max(sell, buy+prices[i]);\\n                afterBuy = Math.max(buy, sell-prices[i]);\\n                sell = afterSell;\\n                buy = afterBuy;\\n            }\\n            return afterSell;\\n        }\\n        int prev [] = new int [n];\\n        int curr [] = new int [n];\\n        \\n        for(int j=1;j<=k;j++){\\n            int state = Integer.MIN_VALUE;\\n            prev = Arrays.copyOf(curr,curr.length);\\n            Arrays.fill(curr, 0);\\n            for(int i=1;i<n;i++){\\n                state = Math.max(state, prev[i-1]-prices[i-1]);\\n                curr[i] = Math.max(curr[i], Math.max(curr[i-1], state+prices[i]));\\n            }\\n        }\\n        return curr[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296957,
                "title": "java-dp-thought-process",
                "content": "```java\\nclass Solution {\\n    \\n    // If we know max profit made on each day i\\n    // The answer will be max profit made on day N-1\\n    \\n    // On each day, we have 3 choices\\n    // 1) Buy - if not owned, use one transaction count\\n    // 2) Sell - if owned\\n    // 3) Do nothing\\n    \\n    // Let F(i, isOwned, k) be the max profix on day i, owning the stack or not, using k transactions total\\n    // F(i, isOwned=true, k) = max(F(i-1, isOwned=true, k), F(i-1, isOwned=false, k-1) - prices[i])\\n    // F(i, isOwned=false, k) = max(F(i-1, isOwned=false, k), F(i-1, isOwned=true, k) + prices[i])\\n\\n    // F(i, isOwned, 0) = 0\\n    // F(0, isOwned=true, k >= 1) = -prices[0]\\n    // F(0, isOwned=false, k) = 0\\n    \\n    public int maxProfit(int K, int[] prices) {\\n        if (K == 0 || prices.length == 0) return 0;\\n        if (K > prices.length / 2) {\\n            return getMax(prices);\\n        }\\n\\n        int N = prices.length;\\n        int[][] owned = new int[N][K + 1];\\n        int[][] clear = new int[N][K + 1];\\n\\n        for (int k = 1; k <= K; k++)\\n            owned[0][k] = -prices[0]; \\n        \\n        for (int i = 1; i < N; i++) {\\n            for (int k = 1; k <= K; k++) {\\n                owned[i][k] = Math.max(owned[i - 1][k], clear[i - 1][k - 1] - prices[i]);\\n                clear[i][k] = Math.max(clear[i - 1][k], owned[i - 1][k] + prices[i]);\\n            }\\n        }\\n\\n        return clear[N - 1][K];\\n    }\\n    \\n    private int getMax(int[] prices) {\\n        int ans = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            int diff = prices[i] - prices[i - 1];\\n            ans += Math.max(0, diff);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    \\n    // If we know max profit made on each day i\\n    // The answer will be max profit made on day N-1\\n    \\n    // On each day, we have 3 choices\\n    // 1) Buy - if not owned, use one transaction count\\n    // 2) Sell - if owned\\n    // 3) Do nothing\\n    \\n    // Let F(i, isOwned, k) be the max profix on day i, owning the stack or not, using k transactions total\\n    // F(i, isOwned=true, k) = max(F(i-1, isOwned=true, k), F(i-1, isOwned=false, k-1) - prices[i])\\n    // F(i, isOwned=false, k) = max(F(i-1, isOwned=false, k), F(i-1, isOwned=true, k) + prices[i])\\n\\n    // F(i, isOwned, 0) = 0\\n    // F(0, isOwned=true, k >= 1) = -prices[0]\\n    // F(0, isOwned=false, k) = 0\\n    \\n    public int maxProfit(int K, int[] prices) {\\n        if (K == 0 || prices.length == 0) return 0;\\n        if (K > prices.length / 2) {\\n            return getMax(prices);\\n        }\\n\\n        int N = prices.length;\\n        int[][] owned = new int[N][K + 1];\\n        int[][] clear = new int[N][K + 1];\\n\\n        for (int k = 1; k <= K; k++)\\n            owned[0][k] = -prices[0]; \\n        \\n        for (int i = 1; i < N; i++) {\\n            for (int k = 1; k <= K; k++) {\\n                owned[i][k] = Math.max(owned[i - 1][k], clear[i - 1][k - 1] - prices[i]);\\n                clear[i][k] = Math.max(clear[i - 1][k], owned[i - 1][k] + prices[i]);\\n            }\\n        }\\n\\n        return clear[N - 1][K];\\n    }\\n    \\n    private int getMax(int[] prices) {\\n        int ans = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            int diff = prices[i] - prices[i - 1];\\n            ans += Math.max(0, diff);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54219,
                "title": "fastest-python-solution-76ms-not-dp",
                "content": "    class Solution:\\n        def __init__(self):\\n            self.start = 0\\n            self.end = 0\\n            self.ans = 0\\n            self.p = []\\n        \\n        def maxProfit(self, k, prices):\\n            i = 1\\n            if len(prices) <= 1:\\n                return 0\\n            while i < len(prices):\\n                self.p.append(prices[i] - prices[i-1])\\n                i += 1\\n            if k >= len(self.p):\\n                return sum([x for x in self.p if x > 0])\\n            j = 0\\n            while j < k:\\n                ret = self.getProfit()\\n                if ret == 0:\\n                    return self.ans\\n                self.ans += ret\\n                self.updatePrice()\\n                j += 1\\n            return self.ans\\n    \\n        def getProfit(self):\\n            s, tmpS = 0, 0\\n            tmpStart = 0\\n            for i in range(0 ,len(self.p)):\\n                tmpS += self.p[i]\\n                if tmpS <= 0:\\n                    tmpS = 0\\n                    tmpStart = i + 1\\n                else:\\n                    if tmpS > s:\\n                        self.start = tmpStart\\n                        self.end = i + 1\\n                        s = tmpS\\n            return s\\n    \\n        def updatePrice(self):\\n            for i in range(self.start, self.end):\\n                self.p[i] *= -1",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        def __init__(self):\\n            self.start = 0\\n            self.end = 0\\n            self.ans = 0\\n            self.p = []\\n        \\n        def maxProfit(self, k, prices):\\n            i = 1\\n            if len(prices) <= 1:\\n                return 0\\n            while i < len(prices):\\n                self.p.append(prices[i] - prices[i-1])\\n                i += 1\\n            if k >= len(self.p):\\n                return sum([x for x in self.p if x > 0])\\n            j = 0\\n            while j < k:\\n                ret = self.getProfit()\\n                if ret == 0:\\n                    return self.ans\\n                self.ans += ret\\n                self.updatePrice()\\n                j += 1\\n            return self.ans\\n    \\n        def getProfit(self):\\n            s, tmpS = 0, 0\\n            tmpStart = 0\\n            for i in range(0 ,len(self.p)):\\n                tmpS += self.p[i]\\n                if tmpS <= 0:\\n                    tmpS = 0\\n                    tmpStart = i + 1\\n                else:\\n                    if tmpS > s:\\n                        self.start = tmpStart\\n                        self.end = i + 1\\n                        s = tmpS\\n            return s\\n    \\n        def updatePrice(self):\\n            for i in range(self.start, self.end):\\n                self.p[i] *= -1",
                "codeTag": "Java"
            },
            {
                "id": 3729742,
                "title": "dp-c-minimal-code-beats-99-both-6-8-lines",
                "content": "Inspired by amazing solution from Stock III by *weijiac*, shout out to him!\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/39611/is-it-best-solution-with-o-n-o-1/\\n\\nBasically we are keeping track of highest profit for each k, starting from 1 and ending with k transactions, each transaction is only feasible if the last transaction is completed.\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        vector<int> sell(k+1, 0), bought(k+1, INT_MIN);\\n        for(auto price: prices) {\\n            for(int i=k-1; i>=0; --i){\\n                sell[i] = max(sell[i], bought[i] + price);\\n                bought[i] = max(bought[i], i == 0 ? -price : sell[i-1]-price);\\n            }\\n        }\\n        return sell[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        vector<int> sell(k+1, 0), bought(k+1, INT_MIN);\\n        for(auto price: prices) {\\n            for(int i=k-1; i>=0; --i){\\n                sell[i] = max(sell[i], bought[i] + price);\\n                bought[i] = max(bought[i], i == 0 ? -price : sell[i-1]-price);\\n            }\\n        }\\n        return sell[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556543,
                "title": "c-dp-memoization-recursion-top-down-dp-easy-2-approaches",
                "content": "```\\nProblem :- Best Time to Buy and Sell Stock IV\\nApproaches:-\\n1) Recursive Approach\\n2) Dynamic Programming Approach (Top Down DP)\\n\\nEasy efficient approach!!\\n```\\n\\n**Approach 1:-**\\n\\n**Recursive Approach!!**\\n\\n*NOTE:- Gives TLE --> 207 / 211 Cases Passed (so need to optimised it by Dynamic Programming)*\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int dp_fun(int k,vector<int>& prices,int idx,int b){\\n        if(k==0){\\n            return 0;\\n        }\\n        \\n        if(idx==prices.size()){\\n            return 0;\\n        }\\n        \\n        if(b==1){\\n            return max((-prices[idx]+dp_fun(k,prices,idx+1,0)), dp_fun(k,prices,idx+1,1));\\n        }\\n        else{\\n            return max((prices[idx]+dp_fun(k-1,prices,idx+1,1)), dp_fun(k,prices,idx+1,0));\\n        }\\n    }\\n    int maxProfit(int k, vector<int>& prices) {\\n        \\n        return dp_fun(k,prices,0,1);\\n    }\\n};\\n```\\n\\n**Approach 2:-**\\n\\n**Dynamic Programming Approach!!**\\n**Recursion + Memoization\\nTop-Down Dynamic Programming Approach**\\n```\\n\\nclass Solution {\\npublic:\\n    \\n\\t// 3-DP array because there where three changing parameters.\\n\\t// 1) size of array, \\n\\t// 2)whether we buy or sell (0/1) \\n\\t// 3) k\\n\\t\\n    int dp[1001][2][101];\\n\\t\\n    int dp_fun(int k,vector<int>& prices,int idx,int b){\\n\\t// if k==0 we simply return 0 as all the k transactions are done \\n        if(k==0){\\n            return 0;\\n        }\\n        \\n\\t\\t// if we reached the end of the array then we return 0;\\n\\t\\t\\n        if(idx==prices.size()){\\n            return 0;\\n        }\\n        \\n\\t\\t//  Returning the already solved problem(overlapping subproblem)\\n\\t\\t\\n        if(dp[idx][b][k] != -1){\\n            return dp[idx][b][k];\\n        }\\n        \\n\\t\\t// if buying is possible and when selling is possible\\n        if(b==1){\\n            return dp[idx][b][k] = max((-prices[idx]+dp_fun(k,prices,idx+1,0)), dp_fun(k,prices,idx+1,1));\\n        }\\n        else{\\n            return dp[idx][b][k] = max((prices[idx]+dp_fun(k-1,prices,idx+1,1)), dp_fun(k,prices,idx+1,0));\\n        }\\n    }\\n    int maxProfit(int k, vector<int>& prices) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n        return dp_fun(k,prices,0,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nProblem :- Best Time to Buy and Sell Stock IV\\nApproaches:-\\n1) Recursive Approach\\n2) Dynamic Programming Approach (Top Down DP)\\n\\nEasy efficient approach!!\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int dp_fun(int k,vector<int>& prices,int idx,int b){\\n        if(k==0){\\n            return 0;\\n        }\\n        \\n        if(idx==prices.size()){\\n            return 0;\\n        }\\n        \\n        if(b==1){\\n            return max((-prices[idx]+dp_fun(k,prices,idx+1,0)), dp_fun(k,prices,idx+1,1));\\n        }\\n        else{\\n            return max((prices[idx]+dp_fun(k-1,prices,idx+1,1)), dp_fun(k,prices,idx+1,0));\\n        }\\n    }\\n    int maxProfit(int k, vector<int>& prices) {\\n        \\n        return dp_fun(k,prices,0,1);\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    \\n\\t// 3-DP array because there where three changing parameters.\\n\\t// 1) size of array, \\n\\t// 2)whether we buy or sell (0/1) \\n\\t// 3) k\\n\\t\\n    int dp[1001][2][101];\\n\\t\\n    int dp_fun(int k,vector<int>& prices,int idx,int b){\\n\\t// if k==0 we simply return 0 as all the k transactions are done \\n        if(k==0){\\n            return 0;\\n        }\\n        \\n\\t\\t// if we reached the end of the array then we return 0;\\n\\t\\t\\n        if(idx==prices.size()){\\n            return 0;\\n        }\\n        \\n\\t\\t//  Returning the already solved problem(overlapping subproblem)\\n\\t\\t\\n        if(dp[idx][b][k] != -1){\\n            return dp[idx][b][k];\\n        }\\n        \\n\\t\\t// if buying is possible and when selling is possible\\n        if(b==1){\\n            return dp[idx][b][k] = max((-prices[idx]+dp_fun(k,prices,idx+1,0)), dp_fun(k,prices,idx+1,1));\\n        }\\n        else{\\n            return dp[idx][b][k] = max((prices[idx]+dp_fun(k-1,prices,idx+1,1)), dp_fun(k,prices,idx+1,0));\\n        }\\n    }\\n    int maxProfit(int k, vector<int>& prices) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n        return dp_fun(k,prices,0,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555979,
                "title": "c-dp-memorization-very-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][102][2];\\n    int maxProfit(int k, vector<int>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        return fun(prices,k,0,0); // k, index, flag( buy(0) or sell(1))\\n    }\\n    int fun(vector<int>& p,int k,int i,int f)\\n    {\\n        if(k==0 || i>=p.size())\\n            return 0;\\n        \\n        if(dp[i][k][f]!=-1)\\n            return dp[i][k][f];\\n        \\n        int t;\\n        if(f)// max(sell, don\\'t sell)\\n            t=max(p[i]+fun(p,k-1,i+1,0),fun(p,k,i+1,1));\\n        else// max(don\\'t buy, buy) ( -1*p[i] because the buy amount need to be substracted )\\n            t=max(fun(p,k,i+1,0),-1*p[i]+fun(p,k,i+1,1));\\n        dp[i][k][f]=t;\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][102][2];\\n    int maxProfit(int k, vector<int>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        return fun(prices,k,0,0); // k, index, flag( buy(0) or sell(1))\\n    }\\n    int fun(vector<int>& p,int k,int i,int f)\\n    {\\n        if(k==0 || i>=p.size())\\n            return 0;\\n        \\n        if(dp[i][k][f]!=-1)\\n            return dp[i][k][f];\\n        \\n        int t;\\n        if(f)// max(sell, don\\'t sell)\\n            t=max(p[i]+fun(p,k-1,i+1,0),fun(p,k,i+1,1));\\n        else// max(don\\'t buy, buy) ( -1*p[i] because the buy amount need to be substracted )\\n            t=max(fun(p,k,i+1,0),-1*p[i]+fun(p,k,i+1,1));\\n        dp[i][k][f]=t;\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491651,
                "title": "dp-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n     \\n    int prof(vector<int> prices){\\n        int profit = 0, n = prices.size();\\n        for(int i = 1; i < n; i++){\\n            if(prices[i] > prices[i - 1]) profit += (prices[i] - prices[i - 1]);\\n        }\\n        return profit;\\n    }\\n    \\n    int maxProfit(int k, vector<int>& prices) {\\n        ios_base::sync_with_stdio(false);\\n        int n = prices.size();\\n        \\n        if(n == 0) return 0;\\n        \\n        if(k >= n/2) return prof(prices);\\n        \\n        int K = k;\\n        vector<int> dp(k+1);\\n        vector<int> minn(K+1, prices[0]);\\n        \\n        for(int i = 1; i<n; i++){\\n            for(int j = 1; j <= K; j++){\\n                minn[j] = min(prices[i] - dp[j-1], minn[j]);\\n                dp[j]   = max(dp[j], prices[i] - minn[j]);\\n            }\\n        }\\n        return dp[k];\\n    }\\n   \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     \\n    int prof(vector<int> prices){\\n        int profit = 0, n = prices.size();\\n        for(int i = 1; i < n; i++){\\n            if(prices[i] > prices[i - 1]) profit += (prices[i] - prices[i - 1]);\\n        }\\n        return profit;\\n    }\\n    \\n    int maxProfit(int k, vector<int>& prices) {\\n        ios_base::sync_with_stdio(false);\\n        int n = prices.size();\\n        \\n        if(n == 0) return 0;\\n        \\n        if(k >= n/2) return prof(prices);\\n        \\n        int K = k;\\n        vector<int> dp(k+1);\\n        vector<int> minn(K+1, prices[0]);\\n        \\n        for(int i = 1; i<n; i++){\\n            for(int j = 1; j <= K; j++){\\n                minn[j] = min(prices[i] - dp[j-1], minn[j]);\\n                dp[j]   = max(dp[j], prices[i] - minn[j]);\\n            }\\n        }\\n        return dp[k];\\n    }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072272,
                "title": "java-1ms-full-documentation-and-easier-than-official-solutuion",
                "content": "The solution I have here is an extension of the official solution of https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/ which I find much easier to understand. The basic idea really is that the profit of a previous transaction lowers the cost of the current transaction, which in turn increases is possible max profit. This concept is very easy to extend to k transactions with the use of a simple 2d array.\\n\\n```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        \\n        if(k == 0 || prices.length < 2)\\n            return 0;\\n        \\n        // All k transactions will be stored in an array where index 0 will represent the minimum cost\\n        // of the transaction and index 1 will represent the maximum profit of that transaction.\\n        // The first transaction will be built on the idea that 0 transactions have occured before it\\n        // and the kth transaction will have had k - 1 transactions already occur. The profits from \\n        // earlier transactions will affect the total profit of the later transactions, with the kth \\n        // transaction experiencing the largest effect. \\n        int[][] transactions = new int[k][2];\\n        \\n        // Since we are continuously searching for the minumum cost, initalize the cost of each transaction to \\n        // be the int max value, the first price will be lower and overwrite this. \\n        for(int i = 0; i < k; i++)\\n            transactions[i][0] = Integer.MAX_VALUE;\\n        \\n        for(int price : prices){\\n            \\n            // Check the minumum cost and maximum profit possible for all k transactions.\\n            for(int i = 0; i < k; i++){\\n                \\n                // This is the critical concept here, we understand that the profits from an earlier \\n                // transaction will actually lower the total cost of the current transaction. If we are on\\n                // the first transaction however, there are no previous transaction profits that could lower\\n                // the minumum price of the current transaction. This concept builds cumulatively which \\n                // means that the kth transaction will have the lowest possible cost which also means it\\n                // will have the hightest possible profit.\\n                int prevProfit = 0;\\n                \\n                // Only set the value of the previous transactions profit if we have moved past the first\\n                // transaction.\\n                if(i > 0)\\n                    prevProfit = transactions[i - 1][1];\\n                \\n                // set the current cost of the current transaction, if this is not the first transaction, \\n                // then the profit of the previous transaction will lower the current price.\\n                transactions[i][0] = Math.min(transactions[i][0], price - prevProfit);\\n                \\n                // given the current lowest possible seen price, check if the current price if \\n                // sold produces the maximum possible profit from this transaction.\\n                transactions[i][1] = Math.max(transactions[i][1], price - transactions[i][0]);\\n            }\\n        }\\n        \\n        // The kth transaction has the maximum possible profit.\\n        return transactions[k - 1][1];\\n    }\\n}\\n```\\n\\nRuntime: O(k * n)\\nSpace: O(k)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        \\n        if(k == 0 || prices.length < 2)\\n            return 0;\\n        \\n        // All k transactions will be stored in an array where index 0 will represent the minimum cost\\n        // of the transaction and index 1 will represent the maximum profit of that transaction.\\n        // The first transaction will be built on the idea that 0 transactions have occured before it\\n        // and the kth transaction will have had k - 1 transactions already occur. The profits from \\n        // earlier transactions will affect the total profit of the later transactions, with the kth \\n        // transaction experiencing the largest effect. \\n        int[][] transactions = new int[k][2];\\n        \\n        // Since we are continuously searching for the minumum cost, initalize the cost of each transaction to \\n        // be the int max value, the first price will be lower and overwrite this. \\n        for(int i = 0; i < k; i++)\\n            transactions[i][0] = Integer.MAX_VALUE;\\n        \\n        for(int price : prices){\\n            \\n            // Check the minumum cost and maximum profit possible for all k transactions.\\n            for(int i = 0; i < k; i++){\\n                \\n                // This is the critical concept here, we understand that the profits from an earlier \\n                // transaction will actually lower the total cost of the current transaction. If we are on\\n                // the first transaction however, there are no previous transaction profits that could lower\\n                // the minumum price of the current transaction. This concept builds cumulatively which \\n                // means that the kth transaction will have the lowest possible cost which also means it\\n                // will have the hightest possible profit.\\n                int prevProfit = 0;\\n                \\n                // Only set the value of the previous transactions profit if we have moved past the first\\n                // transaction.\\n                if(i > 0)\\n                    prevProfit = transactions[i - 1][1];\\n                \\n                // set the current cost of the current transaction, if this is not the first transaction, \\n                // then the profit of the previous transaction will lower the current price.\\n                transactions[i][0] = Math.min(transactions[i][0], price - prevProfit);\\n                \\n                // given the current lowest possible seen price, check if the current price if \\n                // sold produces the maximum possible profit from this transaction.\\n                transactions[i][1] = Math.max(transactions[i][1], price - transactions[i][0]);\\n            }\\n        }\\n        \\n        // The kth transaction has the maximum possible profit.\\n        return transactions[k - 1][1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900574,
                "title": "best-time-to-buy-and-sell-stock-iv-java",
                "content": "```\\nclass Solution \\n{\\n    /* There are two cases to consider here, one where the number of transactions allowed excedes the\\n     * length of the prices array divided in half, and the case where the number allowed is less than\\n     * half the length of the prices array.  When the number of transactions excedes half the the \\n     * length of prices this is the simple case.  There are enough transations to allow the capture of\\n     * every price increase and profit can be found by iterating over the array and adding any \\n     * increase in price into the return value.  For the case where the number of transactions is less\\n     * than half of the length of prices a basic dynamic-programming algorythm can be applied.\\n     */\\n    \\n    public int maxProfit(int k, int[] prices) \\n    {\\n        if( k > prices.length/2 )\\n        {\\n            return processSimple( prices );\\n        }\\n\\n        return processDynamic( prices, k );\\n    }\\n\\n    // Utility method to handle the simple case\\n    \\n    private static int processSimple( int[] prices )\\n    {\\n        int         n   = prices.length;\\n        int         ret = 0;\\n            \\n        for( int i = 1; i < n; i++ )\\n        {\\n            ret += Math.max( 0, prices[ i ] - prices[ i - 1 ] );\\n        }\\n    \\n        return ret;\\n    }\\n\\n    // Utility method to handle dynamic-programming process\\n    \\n    private static int processDynamic( int[] prices, int k )\\n    {\\n        int         n   = prices.length;\\n        int[][]     dp  = new int[ k + 1 ][ n ];\\n\\n        for (int i = 1; i <= k; i ++)\\n        {\\n            int         prf = -prices[ 0 ];\\n\\n            for (int j = 1; j < n; j ++)\\n            {\\n                dp[i][j]    = Math.max( dp[ i ][ j - 1 ], prf + prices[ j ] );\\n                prf         = Math.max( prf, dp[ i - 1 ][ j - 1 ] - prices[ j ] );\\n            }\\n        }\\n        \\n        return dp[ k ][ n - 1 ];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    /* There are two cases to consider here, one where the number of transactions allowed excedes the\\n     * length of the prices array divided in half, and the case where the number allowed is less than\\n     * half the length of the prices array.  When the number of transactions excedes half the the \\n     * length of prices this is the simple case.  There are enough transations to allow the capture of\\n     * every price increase and profit can be found by iterating over the array and adding any \\n     * increase in price into the return value.  For the case where the number of transactions is less\\n     * than half of the length of prices a basic dynamic-programming algorythm can be applied.\\n     */\\n    \\n    public int maxProfit(int k, int[] prices) \\n    {\\n        if( k > prices.length/2 )\\n        {\\n            return processSimple( prices );\\n        }\\n\\n        return processDynamic( prices, k );\\n    }\\n\\n    // Utility method to handle the simple case\\n    \\n    private static int processSimple( int[] prices )\\n    {\\n        int         n   = prices.length;\\n        int         ret = 0;\\n            \\n        for( int i = 1; i < n; i++ )\\n        {\\n            ret += Math.max( 0, prices[ i ] - prices[ i - 1 ] );\\n        }\\n    \\n        return ret;\\n    }\\n\\n    // Utility method to handle dynamic-programming process\\n    \\n    private static int processDynamic( int[] prices, int k )\\n    {\\n        int         n   = prices.length;\\n        int[][]     dp  = new int[ k + 1 ][ n ];\\n\\n        for (int i = 1; i <= k; i ++)\\n        {\\n            int         prf = -prices[ 0 ];\\n\\n            for (int j = 1; j < n; j ++)\\n            {\\n                dp[i][j]    = Math.max( dp[ i ][ j - 1 ], prf + prices[ j ] );\\n                prf         = Math.max( prf, dp[ i - 1 ][ j - 1 ] - prices[ j ] );\\n            }\\n        }\\n        \\n        return dp[ k ][ n - 1 ];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 814657,
                "title": "python-o-kn-dp-w-comment",
                "content": "Python by DP\\n\\n---\\n\\n```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        \\n        n = len(prices)\\n        \\n        if n == 0:\\n            \\n            ## Base case:\\n            # Price sequence is empty, we can do nothing : )\\n            return 0\\n        \\n        \\n        ## General case:\\n        \\n        # DP[ k ][ d ] = max profit on k, d\\n        # where k stands for k-th transaction, d stands for d-th trading day.\\n        dp = [ [ 0 for _ in range(n)] for _ in range(k+1) ]\\n        \\n        \\n        # Update by each transction as well as each trading day\\n        for trans_k in range(1, k+1):\\n            \\n            # Balance before 1st transaction must be zero\\n            # Buy stock on first day means -prices[0]\\n            cur_balance_with_buy = 0 - prices[0]\\n            \\n            for day_d in range(1, n):\\n                \\n                # Either we have finished all k transactions before, or just sell out stock and finished k-th transaction today\\n                dp[trans_k][day_d] = max( dp[trans_k][day_d-1], cur_balance_with_buy + prices[day_d] )\\n                \\n                # Either keep holding the stock we bought before, or just buy in today\\n                cur_balance_with_buy = max(cur_balance_with_buy, dp[trans_k-1][day_d-1] - prices[day_d] )\\n                \\n        return dp[k][n-1]\\n```\\n\\n---\\n\\nShare another implementation with top-down DP with memoization\\n\\n```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        \\n        @cache\\n        def trade(day_d, transaction_i):\\n            \\n            if day_d <= 0 or transaction_i <= 0:\\n                # Can not trade ealry than day #0\\n                # Can not trade with 0 transaction or less\\n                return 0\\n            \\n            \\n            ## Case_#1\\n            # not to transact on day d, all transactions are completed before\\n            not_to_transact = trade(day_d-1, transaction_i)\\n            \\n            \\n            ## Case_#2\\n            # transact on day_d\\n            \\n            # update price gain\\n            # define price_gain = max( -prices[buy_in] + trade(day_d-1, transaction_i-1) for buy_in in range(day_d) )\\n            \\n            if day_d == 1:\\n                trade.max_gain[transaction_i] = -prices[day_d-1] + trade(day_d-1, transaction_i-1)\\n            else:\\n                trade.max_gain[transaction_i] = max(trade.max_gain[transaction_i], -prices[day_d-1] + trade(day_d-1, transaction_i-1) )\\n                \\n            \\n            # transact on day_d, carry out i-th transaction now\\n            transact = prices[day_d] + trade.max_gain[transaction_i]\\n\\n            \\n            return max(not_to_transact, transact)\\n        \\n        # ---------------------------------------------------\\n            \\n        trade.max_gain = defaultdict(int)    \\n        return trade(len(prices)-1, k)\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #121 Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock)\\n\\n[Leetcode #122 Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii)\\n\\n[Leetcode #123 Best Time to Buy and Sell Stock III ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii)\\n\\n[Leetcode #188 Best Time to Buy and Sell Stock IV  ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv)\\n\\n[Leetcode #309 Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown)\\n\\n[Leetcode #714 Best Time to Buy and Sell Stock with Transaction Fee  ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee) \\n\\n---",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        \\n        n = len(prices)\\n        \\n        if n == 0:\\n            \\n            ## Base case:\\n            # Price sequence is empty, we can do nothing : )\\n            return 0\\n        \\n        \\n        ## General case:\\n        \\n        # DP[ k ][ d ] = max profit on k, d\\n        # where k stands for k-th transaction, d stands for d-th trading day.\\n        dp = [ [ 0 for _ in range(n)] for _ in range(k+1) ]\\n        \\n        \\n        # Update by each transction as well as each trading day\\n        for trans_k in range(1, k+1):\\n            \\n            # Balance before 1st transaction must be zero\\n            # Buy stock on first day means -prices[0]\\n            cur_balance_with_buy = 0 - prices[0]\\n            \\n            for day_d in range(1, n):\\n                \\n                # Either we have finished all k transactions before, or just sell out stock and finished k-th transaction today\\n                dp[trans_k][day_d] = max( dp[trans_k][day_d-1], cur_balance_with_buy + prices[day_d] )\\n                \\n                # Either keep holding the stock we bought before, or just buy in today\\n                cur_balance_with_buy = max(cur_balance_with_buy, dp[trans_k-1][day_d-1] - prices[day_d] )\\n                \\n        return dp[k][n-1]\\n```\n```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        \\n        @cache\\n        def trade(day_d, transaction_i):\\n            \\n            if day_d <= 0 or transaction_i <= 0:\\n                # Can not trade ealry than day #0\\n                # Can not trade with 0 transaction or less\\n                return 0\\n            \\n            \\n            ## Case_#1\\n            # not to transact on day d, all transactions are completed before\\n            not_to_transact = trade(day_d-1, transaction_i)\\n            \\n            \\n            ## Case_#2\\n            # transact on day_d\\n            \\n            # update price gain\\n            # define price_gain = max( -prices[buy_in] + trade(day_d-1, transaction_i-1) for buy_in in range(day_d) )\\n            \\n            if day_d == 1:\\n                trade.max_gain[transaction_i] = -prices[day_d-1] + trade(day_d-1, transaction_i-1)\\n            else:\\n                trade.max_gain[transaction_i] = max(trade.max_gain[transaction_i], -prices[day_d-1] + trade(day_d-1, transaction_i-1) )\\n                \\n            \\n            # transact on day_d, carry out i-th transaction now\\n            transact = prices[day_d] + trade.max_gain[transaction_i]\\n\\n            \\n            return max(not_to_transact, transact)\\n        \\n        # ---------------------------------------------------\\n            \\n        trade.max_gain = defaultdict(int)    \\n        return trade(len(prices)-1, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772197,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int getAns(vector<int>& prices, int n, int ind, int buy, int cap,vector<vector<vector<int>>>& dp ){\\n        if(ind==n || cap==0) return 0; //base case\\n        if(dp[ind][buy][cap]!=-1) return dp[ind][buy][cap];\\n        int profit;\\n        if(buy==0){// We can buy the stock\\n            profit = max(0+getAns(prices,n,ind+1,0,cap,dp), -prices[ind] + getAns(prices,n,ind+1,1,cap,dp));\\n        }\\n        if(buy==1){// We can sell the stock\\n            profit = max(0+getAns(prices,n,ind+1,1,cap,dp),prices[ind] + getAns(prices,n,ind+1,0,cap-1,dp));\\n        }\\n        return dp[ind][buy][cap] = profit;\\n    }\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(2,vector<int>(k+1,-1)));\\n        return getAns(prices,n,0,0,k,dp);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getAns(vector<int>& prices, int n, int ind, int buy, int cap,vector<vector<vector<int>>>& dp ){\\n        if(ind==n || cap==0) return 0; //base case\\n        if(dp[ind][buy][cap]!=-1) return dp[ind][buy][cap];\\n        int profit;\\n        if(buy==0){// We can buy the stock\\n            profit = max(0+getAns(prices,n,ind+1,0,cap,dp), -prices[ind] + getAns(prices,n,ind+1,1,cap,dp));\\n        }\\n        if(buy==1){// We can sell the stock\\n            profit = max(0+getAns(prices,n,ind+1,1,cap,dp),prices[ind] + getAns(prices,n,ind+1,0,cap-1,dp));\\n        }\\n        return dp[ind][buy][cap] = profit;\\n    }\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(2,vector<int>(k+1,-1)));\\n        return getAns(prices,n,0,0,k,dp);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558269,
                "title": "java-recursive-dp-tabulation-space-optimization",
                "content": "```\\n/*\\n// Recursive Solution : TLE\\n// TC - exponential, SC - O(n) : auxiliary space\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        \\n        int n = prices.length;\\n        int cap = k; // no of transactions allowed\\n        boolean buy = true; // can buy or not\\n        return maxProfit(0, buy, cap, prices, n);\\n    }\\n    \\n    private int maxProfit(int i, boolean buy, int cap, int[] prices, int n){\\n        \\n        if(i == n || cap == 0) return 0;\\n        \\n        // if can buy new stack else sell\\n        if(buy){\\n            return Math.max(-prices[i] + maxProfit(i+1, false, cap, prices, n)\\n                             , 0 + maxProfit(i+1, true, cap, prices, n));                     \\n        }\\n        else{\\n            return Math.max(prices[i] + maxProfit(i+1, true, cap-1, prices, n)\\n                             , 0 + maxProfit(i+1, false, cap, prices, n));\\n        }\\n    }\\n}\\n*/\\n\\n/*\\n// Recursive DP Solution\\n// TC - O(n*2*k) , SC - O(n*2*k), O(n): auxiliary space\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        \\n        int n = prices.length;\\n        int cap = k; // no of transactions allowed\\n        int buy = 1; // can buy or not\\n        Integer[][][] dp = new Integer[n][2][k+1];\\n        return maxProfit(0, buy, cap, prices, n, dp);\\n    }\\n    \\n    private int maxProfit(int i, int buy, int cap, int[] prices, int n, Integer[][][] dp){\\n        \\n        if(i == n || cap == 0) return 0;\\n        \\n        if(dp[i][buy][cap] != null) return dp[i][buy][cap];\\n        // if can buy new stack else sell\\n        if(buy == 1){\\n            return dp[i][buy][cap] = Math.max(-prices[i] + maxProfit(i+1, 0, cap, prices, n, dp)\\n                             , 0 + maxProfit(i+1, 1, cap, prices, n, dp));                     \\n        }\\n        else{\\n            return dp[i][buy][cap] = Math.max(prices[i] + maxProfit(i+1, 1, cap-1, prices, n, dp)\\n                             , 0 + maxProfit(i+1, 0, cap, prices, n, dp));\\n        }\\n    }\\n}\\n*/\\n\\n/*\\n// Tabulation Solution\\n// TC - O(n*2*k) , SC - O(n*2*k)\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        \\n        int n = prices.length;\\n        int[][][] dp = new int[n+1][2][k+1];\\n        for(int i = n-1; i >= 0; i--){\\n            for(int buy = 0; buy < 2; buy++){\\n                for(int cap = 1; cap < k+1; cap++){\\n                    if(buy == 1){\\n                        dp[i][buy][cap] = Math.max(-prices[i] + dp[i+1][0][cap]\\n                                                            , 0 + dp[i+1][1][cap]);                     \\n                        }\\n                    else{\\n                        dp[i][buy][cap] = Math.max(prices[i] + dp[i+1][1][cap-1]\\n                                                            , 0 + dp[i+1][0][cap]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][1][k];\\n    }\\n}\\n*/\\n\\n\\n// Space Optimization\\n// TC - O(n*2*k) , SC - O(2*2*k)\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        \\n        int n = prices.length;\\n        int[][][] dp = new int[2][2][k+1]; // for storing curr(ith) and prev((i+1)th) \\n        for(int i = n-1; i >= 0; i--){\\n            for(int buy = 0; buy < 2; buy++){\\n                for(int cap = 1; cap < k+1; cap++){\\n                    // if buy = 1 then you can buy, else you can sell\\n                    if(buy == 1){\\n                        dp[i%2][buy][cap] = Math.max(-prices[i] + dp[(i+1)%2][0][cap]\\n                                                            , 0 + dp[(i+1)%2][1][cap]);                     \\n                        }\\n                    else{\\n                        dp[i%2][buy][cap] = Math.max(prices[i] + dp[(i+1)%2][1][cap-1]\\n                                                            , 0 + dp[(i+1)%2][0][cap]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][1][k];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n/*\\n// Recursive Solution : TLE\\n// TC - exponential, SC - O(n) : auxiliary space\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        \\n        int n = prices.length;\\n        int cap = k; // no of transactions allowed\\n        boolean buy = true; // can buy or not\\n        return maxProfit(0, buy, cap, prices, n);\\n    }\\n    \\n    private int maxProfit(int i, boolean buy, int cap, int[] prices, int n){\\n        \\n        if(i == n || cap == 0) return 0;\\n        \\n        // if can buy new stack else sell\\n        if(buy){\\n            return Math.max(-prices[i] + maxProfit(i+1, false, cap, prices, n)\\n                             , 0 + maxProfit(i+1, true, cap, prices, n));                     \\n        }\\n        else{\\n            return Math.max(prices[i] + maxProfit(i+1, true, cap-1, prices, n)\\n                             , 0 + maxProfit(i+1, false, cap, prices, n));\\n        }\\n    }\\n}\\n*/\\n\\n/*\\n// Recursive DP Solution\\n// TC - O(n*2*k) , SC - O(n*2*k), O(n): auxiliary space\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        \\n        int n = prices.length;\\n        int cap = k; // no of transactions allowed\\n        int buy = 1; // can buy or not\\n        Integer[][][] dp = new Integer[n][2][k+1];\\n        return maxProfit(0, buy, cap, prices, n, dp);\\n    }\\n    \\n    private int maxProfit(int i, int buy, int cap, int[] prices, int n, Integer[][][] dp){\\n        \\n        if(i == n || cap == 0) return 0;\\n        \\n        if(dp[i][buy][cap] != null) return dp[i][buy][cap];\\n        // if can buy new stack else sell\\n        if(buy == 1){\\n            return dp[i][buy][cap] = Math.max(-prices[i] + maxProfit(i+1, 0, cap, prices, n, dp)\\n                             , 0 + maxProfit(i+1, 1, cap, prices, n, dp));                     \\n        }\\n        else{\\n            return dp[i][buy][cap] = Math.max(prices[i] + maxProfit(i+1, 1, cap-1, prices, n, dp)\\n                             , 0 + maxProfit(i+1, 0, cap, prices, n, dp));\\n        }\\n    }\\n}\\n*/\\n\\n/*\\n// Tabulation Solution\\n// TC - O(n*2*k) , SC - O(n*2*k)\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        \\n        int n = prices.length;\\n        int[][][] dp = new int[n+1][2][k+1];\\n        for(int i = n-1; i >= 0; i--){\\n            for(int buy = 0; buy < 2; buy++){\\n                for(int cap = 1; cap < k+1; cap++){\\n                    if(buy == 1){\\n                        dp[i][buy][cap] = Math.max(-prices[i] + dp[i+1][0][cap]\\n                                                            , 0 + dp[i+1][1][cap]);                     \\n                        }\\n                    else{\\n                        dp[i][buy][cap] = Math.max(prices[i] + dp[i+1][1][cap-1]\\n                                                            , 0 + dp[i+1][0][cap]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][1][k];\\n    }\\n}\\n*/\\n\\n\\n// Space Optimization\\n// TC - O(n*2*k) , SC - O(2*2*k)\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        \\n        int n = prices.length;\\n        int[][][] dp = new int[2][2][k+1]; // for storing curr(ith) and prev((i+1)th) \\n        for(int i = n-1; i >= 0; i--){\\n            for(int buy = 0; buy < 2; buy++){\\n                for(int cap = 1; cap < k+1; cap++){\\n                    // if buy = 1 then you can buy, else you can sell\\n                    if(buy == 1){\\n                        dp[i%2][buy][cap] = Math.max(-prices[i] + dp[(i+1)%2][0][cap]\\n                                                            , 0 + dp[(i+1)%2][1][cap]);                     \\n                        }\\n                    else{\\n                        dp[i%2][buy][cap] = Math.max(prices[i] + dp[(i+1)%2][1][cap-1]\\n                                                            , 0 + dp[(i+1)%2][0][cap]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][1][k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850245,
                "title": "a-concise-solution-in-python-using-idea-of-reinvesting-previously-earned-profit-from-problem-iii",
                "content": "Inspired by solution of [123. Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/) \\n\\n```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        \\n        min_price = [math.inf]*(k+1)\\n        max_profit = [0]*(k+1)\\n        \\n        for price in prices:    \\n            for i in range(1,k+1):\\n                min_price[i] = min(min_price[i],price - max_profit[i-1] )\\n                max_profit[i] = max(max_profit[i], price - min_price[i])\\n        return max_profit[k]\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Inspired by solution of [123. Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/) \\n\\n```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        \\n        min_price = [math.inf]*(k+1)\\n        max_profit = [0]*(k+1)\\n        \\n        for price in prices:    \\n            for i in range(1,k+1):\\n                min_price[i] = min(min_price[i],price - max_profit[i-1] )\\n                max_profit[i] = max(max_profit[i], price - min_price[i])\\n        return max_profit[k]\\n",
                "codeTag": "Java"
            },
            {
                "id": 1159725,
                "title": "cpp-100-fast-solution-with-explanation-and-examples",
                "content": "**Intution\\'s :** \\n\\t1.If we can do at most k transactions it means that we can do  **(2 * k)** operations . 1 single transaction comprise of two operation\\'s  buy  and then sell . \\n\\tFor example if k =2  , it means we can do 4 operations 2 buy and 2 sell for maximum profit.\\n\\n\\n**Case 1 :**\\n\\t1.  **k = 0** means we can\\'t do any operations  so max profit will be 0.\\n\\t2.  **Days  < 2** it means we have stock prices of  less than two days.  To make profit we need at least two days so that we can buy on one day and then sell on second day.\\n\\t**Case 2 :**\\n\\t3.  **Days  < 2 * k** it means number of operations we can do are greater than Days . \\n\\tFor Example : \\n\\t```\\n\\tprices[] = 2 , 3 , 5  and k = 2\\n\\t```\\n* In this example  k = 2 it means we can do 4 operations  but Days of prices are 3 , so we can do any number of operations we want . So we will iterate over each day and if price on  that day is less than price on previous day then we will add difference into max profit.\\n*  For day 1 : we can only buy on first so no profit.\\n*  For day 2 : 2 < 3   maxProfit = 3 - 2 = **1**\\n*  For day 3 : 3 < 5   maxProfit = 5 - 3 = **2**\\n*  So total Profit = **3** .\\n\\n**Case 3 :**\\n\\t4. **2 * k < Days** it means  number of days  are greater than number of operations we can perform . In this case we need to select the days we can buy and sell so that to maximize profit.\\n\\t\\t\\n\\t\\tTo maximizie profit we need k set of buy and sell.\\n* Initiallize DP array : Even days are buying days and on Odd days are selling days.\\n* For even index value =  INT_MIN because on buying days our profit can go upto INT_MIN\\n* For odd index value = 0 because on any day min profit we can achive is 0 by not doing any thing.\\n\\n\\t\\t`1. DP[2*k+1] = [ INT_MIN ] [ 0 ] [INT_MIN ] [ 0 ] [ INT_MIN ]`\\n\\t\\t\\nWe will iterate on each  price and will fill DP array to generate max profit till that price.\\nSo filling process of DP also based on same logic of Even days and off days.\\n\\n**Even Day : We buy on even days so:**\\n`dp[that day] = max ( dp[that day ] , dp[previous day] - price[that day]);`\\n*this means , max of doing nothing and buying . When we buy it means whatever profit was there on the previous day - price[today]  ( we are subtracting it becuause we are buying ).*\\n\\n**Odd Day : We sell on odd days so:**\\n`dp[that day] = max ( dp[that day ] , dp[previous day] + price[that day]);`\\n*this means , max of doing nothing and selling . When we sell it means whatever profit was there on the previous day + price[today]  ( we are adding it becuause we are selling , we will get money after selling. ).*\\t\\n\\n\\t\\tFor Example : \\n\\t\\t`prices[]  : 3 , 2 , 6 , 5 , 0 , 3  and k = 2`\\n\\t\\t\\n* For Price  = 3 \\n* \\tdp[0] =  max (INT_MIN, -3 )  = -3\\n* \\tdp[1] =  max( 0 , -3 +3 ) = 0\\n* \\tdp[2] = max ( INT_MIN , 0 -3 ) = -3\\n* \\tdp[3] = max (0 , -3 +3) = **0** if we had only 1 day its price as 3 then profit we can make is 0 because we get profit when sell.\\n* \\tdp[4] = max( INT_MIN , 0 - 3 ) = -3\\n\\nWe will do the same process for all the prices and in last we will get max profit on last selling day which will be dp[2* k -1].\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n\\t\\t\\n\\t\\t//Case 1 :\\n        if(k == 0 || prices.size() < 2){\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t//Case 2 :\\n        int maxProfit  = 0 ;\\n        if(n < k * 2){\\n            for(int i = 1 ;i < prices.size() ;i++){\\n                if(prices[i-1] < prices[i]){\\n                    maxProfit += prices[i] - prices[i-1];\\n                }\\n            }\\n            return maxProfit;\\n        }\\n        \\n        vector<int> dp((2 * k) + 1);\\n        dp[0] = -prices[0];\\n        \\n        for(int i = 1; i <= 2*k ;i++){\\n            if(i %2 ==0){\\n                dp[i] = INT_MIN;\\n            }else{\\n                dp[i] = 0;\\n            }\\n        }\\n        \\n        //Case 3 :\\n        for(int i = 0 ;i < n ;i++){\\n            for(int j = 0 ; j <= 2 * k ;j++){\\n                \\n                if(j  == 0){\\n                    dp[j] = max(dp[j] , -prices[i]);\\n                }\\n                else if ( j % 2 == 0){\\n                    dp[j] = max(dp[j] , dp[j-1] - prices[i]);\\n                }else{\\n                    dp[j] = max(dp[j] , dp[j-1] + prices[i]);\\n                }\\n            }\\n        }\\n        return dp[2 * k -1];\\n    }\\n};\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/dd5bf83d-66e6-4c60-b930-a399f86a4266_1618485805.9158192.png)\\n\\n\\n**Hi all ,\\nI tried to explain the problem in simplest possible way. Please let me know if i missed something. If you liked it please UPVOTE.\\nThanks!!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tprices[] = 2 , 3 , 5  and k = 2\\n\\t```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n\\t\\t\\n\\t\\t//Case 1 :\\n        if(k == 0 || prices.size() < 2){\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t//Case 2 :\\n        int maxProfit  = 0 ;\\n        if(n < k * 2){\\n            for(int i = 1 ;i < prices.size() ;i++){\\n                if(prices[i-1] < prices[i]){\\n                    maxProfit += prices[i] - prices[i-1];\\n                }\\n            }\\n            return maxProfit;\\n        }\\n        \\n        vector<int> dp((2 * k) + 1);\\n        dp[0] = -prices[0];\\n        \\n        for(int i = 1; i <= 2*k ;i++){\\n            if(i %2 ==0){\\n                dp[i] = INT_MIN;\\n            }else{\\n                dp[i] = 0;\\n            }\\n        }\\n        \\n        //Case 3 :\\n        for(int i = 0 ;i < n ;i++){\\n            for(int j = 0 ; j <= 2 * k ;j++){\\n                \\n                if(j  == 0){\\n                    dp[j] = max(dp[j] , -prices[i]);\\n                }\\n                else if ( j % 2 == 0){\\n                    dp[j] = max(dp[j] , dp[j-1] - prices[i]);\\n                }else{\\n                    dp[j] = max(dp[j] , dp[j-1] + prices[i]);\\n                }\\n            }\\n        }\\n        return dp[2 * k -1];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900592,
                "title": "java-dp-solve-from-brute-force-to-optimized",
                "content": "**Solution #1 - Recursion - Time Limit Exceeded**\\n1. Recursively find the max profit we can get in k transactions. The idea is to start at each index and if a price exists where we can make money by subtracting from our initial index AND we can still perform some transactions `k > 0`, then try it. \\n2. It is possible that during our recursive calls while calculating `v1` that we find a max that isn\\'t at the end, so we keep track of the max we have seen with Math.max() function.\\n\\n```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        return rec(prices, 0, k);\\n    }\\n    public int rec(int[] prices, int idx, int k) {\\n        if(idx == prices.length) \\n            return 0;\\n        \\n        int v1 = 0;\\n        for(int i = idx+1; i < prices.length; i++) {\\n            if(prices[idx] < prices[i] && k > 0) \\n                v1 = Math.max(v1, rec(prices, i+1, k-1) + prices[i]-prices[idx]);\\n        }\\n        int v2 = rec(prices, idx+1, k);\\n        \\n        return Math.max(v1, v2);\\n    }\\n}\\n```\\n\\n**Solution #2 - Recursion with Memoization - Accepted**\\n1. Same idea as before but we can store saved results into our dp table for fast lookups. \\n2. The two factors that are changing throughout our process our the current index we are on (**idx**) and **k**, so those are the two values we are going to keep track of when storing and looking up values.\\n3. We add a quicksolve for larger sets where our memory limit would get time limit exceeded and the solution is accepted.\\n\\n```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        int n = prices.length;\\n        if(k >= n/2) return quick(prices);\\n        \\n        return rec(prices, 0, k, new Integer[k+1][n]);\\n    }\\n    public int rec(int[] prices, int idx, int k, Integer[][] dp) {\\n        if(idx == prices.length) \\n            return 0;\\n        if(dp[k][idx] != null)\\n            return dp[k][idx];\\n        \\n        int v1 = 0;\\n        for(int i = idx+1; i < prices.length; i++) {\\n            if(prices[idx] < prices[i] && k > 0) \\n                v1 = Math.max(v1, rec(prices, i+1, k-1, dp) + prices[i]-prices[idx]);\\n        }\\n        int v2 = rec(prices, idx+1, k, dp);\\n        \\n        return dp[k][idx] = Math.max(v1, v2);\\n    }\\n    public int quick(int[] prices) {\\n        int res = 0;\\n        for(int i = 1; i < prices.length; i++)\\n            if(prices[i] > prices[i-1]) res += prices[i]-prices[i-1];\\n        return res;\\n    }\\n}\\n```\\n\\n**Solution #3 - Bottom-Up Dynammic Programming - Accepted**\\n1. The idea is similar to our other solutions but here instead of using recursion to check all the possible prices we can iteratively build up our dp table which will lead us to the correct final answer.\\n2. I think this pretty much explains itself but the biggest and most confusing aspect of this specific algorithm is `max = Math.max(max, prev[j-1]-prices[j-1]);`. What is going on here is we are optimizing our buy for each price, given what we computed for previous `k` values. \\n3. Once we have our max, we can check it based on our previously computed max, or value at `dp[i][j]` to see if we can need to carry over the old max, or create a new one. `dp[i][j] = Math.max(dp[i][j-1], max + prices[j]);` is saying if sell at prices[j] is this a new max profit?\\n\\n\\n```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        int n = prices.length;\\n        if(k >= n/2) return quick(prices);\\n        \\n        int[][] dp = new int[k+1][n];\\n        \\n        for(int i = 1; i <= k; i++) {\\n            int max = Integer.MIN_VALUE;\\n            for(int j = 1; j < n; j++) {\\n                max = Math.max(max, dp[i-1][j-1]-prices[j-1]);    // max so far if we buy at this price\\n                dp[i][j] = Math.max(dp[i][j-1], max + prices[j]); // max if we sell at prices[j]\\n            }\\n        }\\n        return dp[k][n-1];\\n    }\\n    public int quick(int[] prices) {\\n        int res = 0;\\n        for(int i = 1; i < prices.length; i++)\\n            if(prices[i] > prices[i-1]) res += prices[i]-prices[i-1];\\n        return res;\\n    }\\n}\\n```\\n\\n**Solution #4 - Bottom-Up Dynammic Programming, Space Optimized - Accepted**\\n1. We saw in our last solution that at most, we are only looking back 1, step. When this is the case in dynammic programming problems we can always using two arrays to look what was previously used to calculate our new max profit. You can name them whatever you like, but for me, I like to use `prev` and `curr` because it helps me keep track of where I am, and which array I need to look at.\\n2. This is pretty much identical to our 2d dp solution but we swap the prev and curr array at each iteration accordingly.\\n\\n```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        int n = prices.length;\\n        if(k >= n/2) return quick(prices);\\n        \\n        int[] prev = new int[n];\\n        \\n        for(int i = 1; i <= k; i++) {\\n            int max = Integer.MIN_VALUE;\\n            int[] curr = new int[n];\\n            for(int j = 1; j < n; j++) {\\n                max = Math.max(max, prev[j-1]-prices[j-1]);    // max so far if we buy at this price\\n                curr[j] = Math.max(curr[j-1], max + prices[j]); // max if we sell at prices[j]\\n            }\\n            prev = curr;\\n        }\\n        return prev[n-1];\\n    }\\n    public int quick(int[] prices) {\\n        int res = 0;\\n        for(int i = 1; i < prices.length; i++)\\n            if(prices[i] > prices[i-1]) res += prices[i]-prices[i-1];\\n        return res;\\n    }\\n}\\n```\\n\\nA lot of times with these dynammic programming solutions I only see writeups on the optimized dp code and I always like to see how you build them out from a brute force recursive example, to an optimized one. Especially in interviews they are going to want to know the recurrence relationship and how you got to an optimized version so have an idea of how you came to the final solution is important.\\n\\nIf this helped you please upvote and leave a comment.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        return rec(prices, 0, k);\\n    }\\n    public int rec(int[] prices, int idx, int k) {\\n        if(idx == prices.length) \\n            return 0;\\n        \\n        int v1 = 0;\\n        for(int i = idx+1; i < prices.length; i++) {\\n            if(prices[idx] < prices[i] && k > 0) \\n                v1 = Math.max(v1, rec(prices, i+1, k-1) + prices[i]-prices[idx]);\\n        }\\n        int v2 = rec(prices, idx+1, k);\\n        \\n        return Math.max(v1, v2);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        int n = prices.length;\\n        if(k >= n/2) return quick(prices);\\n        \\n        return rec(prices, 0, k, new Integer[k+1][n]);\\n    }\\n    public int rec(int[] prices, int idx, int k, Integer[][] dp) {\\n        if(idx == prices.length) \\n            return 0;\\n        if(dp[k][idx] != null)\\n            return dp[k][idx];\\n        \\n        int v1 = 0;\\n        for(int i = idx+1; i < prices.length; i++) {\\n            if(prices[idx] < prices[i] && k > 0) \\n                v1 = Math.max(v1, rec(prices, i+1, k-1, dp) + prices[i]-prices[idx]);\\n        }\\n        int v2 = rec(prices, idx+1, k, dp);\\n        \\n        return dp[k][idx] = Math.max(v1, v2);\\n    }\\n    public int quick(int[] prices) {\\n        int res = 0;\\n        for(int i = 1; i < prices.length; i++)\\n            if(prices[i] > prices[i-1]) res += prices[i]-prices[i-1];\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        int n = prices.length;\\n        if(k >= n/2) return quick(prices);\\n        \\n        int[][] dp = new int[k+1][n];\\n        \\n        for(int i = 1; i <= k; i++) {\\n            int max = Integer.MIN_VALUE;\\n            for(int j = 1; j < n; j++) {\\n                max = Math.max(max, dp[i-1][j-1]-prices[j-1]);    // max so far if we buy at this price\\n                dp[i][j] = Math.max(dp[i][j-1], max + prices[j]); // max if we sell at prices[j]\\n            }\\n        }\\n        return dp[k][n-1];\\n    }\\n    public int quick(int[] prices) {\\n        int res = 0;\\n        for(int i = 1; i < prices.length; i++)\\n            if(prices[i] > prices[i-1]) res += prices[i]-prices[i-1];\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        int n = prices.length;\\n        if(k >= n/2) return quick(prices);\\n        \\n        int[] prev = new int[n];\\n        \\n        for(int i = 1; i <= k; i++) {\\n            int max = Integer.MIN_VALUE;\\n            int[] curr = new int[n];\\n            for(int j = 1; j < n; j++) {\\n                max = Math.max(max, prev[j-1]-prices[j-1]);    // max so far if we buy at this price\\n                curr[j] = Math.max(curr[j-1], max + prices[j]); // max if we sell at prices[j]\\n            }\\n            prev = curr;\\n        }\\n        return prev[n-1];\\n    }\\n    public int quick(int[] prices) {\\n        int res = 0;\\n        for(int i = 1; i < prices.length; i++)\\n            if(prices[i] > prices[i-1]) res += prices[i]-prices[i-1];\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54132,
                "title": "how-to-optimize-the-o-n-3-dp-solution",
                "content": "This is my first O(N^3)  DP solution\\n\\nThe recursion equation is like this:\\n  \\n           dp[k][i] = max{ dp[k][i-1], dp[k-1][j] + prices[i-1]-prices[j] }       0<=j<i-1\\n\\nHere is the most naive implementation.\\n\\n \\n\\n      class Solution {\\n        public:\\n            int maxProfit(int k, vector<int>& prices) {\\n                /***\\n                 *  dp[k][i]:the max profit we get during prices[0...i-1] with at most k transactions\\n                 *  dp[k][i] = max{ dp[k][i-1], dp[k-1][j] + prices[i-1]-prices[j] }       0<=j<i-1\\n                 *\\n                 *  start :  dp[0][i]=0;  dp[k][0]=0\\n                 ***/\\n                 int n=prices.size();\\n                 if(n<=1)  return 0;\\n                 \\n                 /** to deal with the bigest cases **/\\n                 if(k>n/2){\\n                     int result=0;\\n                     for(int i=1; i<n; i++)\\n                        result+=max(prices[i]-prices[i-1], 0);\\n                     return result;\\n                 }\\n                 \\n                 vector<vector<int>> dp(k+1, vector<int>(n+1, 0));\\n                 \\n                 for(int kk=1; kk<=k; kk++){\\n                     for(int i=1; i<=n; i++){\\n                         for(int j=0; j<i-1; j++)\\n                            dp[kk][i]=max(dp[kk][i-1], dp[kk-1][j]+prices[i-1]-prices[j]);\\n                     }\\n                 }\\n                 return dp[k][n];\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int maxProfit(int k, vector<int>& prices) {\\n                /***\\n                 *  dp[k][i]:the max profit we get during prices[0...i-1] with at most k transactions\\n                 *  dp[k][i] = max{ dp[k][i-1], dp[k-1][j] + prices[i-1]-prices[j] }",
                "codeTag": "Java"
            },
            {
                "id": 3214966,
                "title": "188-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nThis problem can be solved using dynamic programming. We can create a two-dimensional table dp where dp[i][j] represents the maximum profit achievable up to day i using at most j transactions. The recurrence relation for this problem is as follows:\\n\\ndp[i][j] = max(dp[i-1][j], prices[i] - prices[m] + dp[m-1][j-1]) where m is any index from 0 to i-1.\\n\\nThe first term in the max function represents the maximum profit achievable up to day i using at most j transactions without selling the stock on day i. The second term represents the maximum profit achievable up to day m using at most j-1 transactions plus the profit obtained by buying the stock on day m and selling it on day i. We can obtain the maximum profit over all m to get the value of dp[i][j].\\n\\nThe final answer will be in dp[n-1][k] where n is the length of the prices array.\\n\\nHere\\'s the Python3 code with comments:\\n```\\nclass Solution:\\n  def maxProfit(self, k: int, prices: List[int]) -> int:\\n    n = len(prices)\\n    # edge case where there are no prices or no transactions\\n    if n == 0 or k == 0:\\n        return 0\\n    # edge case where we can perform an unlimited number of transactions\\n    if k >= n // 2:\\n        return sum(max(0, prices[i+1] - prices[i]) for i in range(n-1))\\n    # initialize dp table\\n    dp = [[0] * (k+1) for _ in range(n)]\\n    for j in range(1, k+1):\\n        max_diff = -prices[0] # keep track of the maximum difference seen so far\\n        for i in range(1, n):\\n            dp[i][j] = max(dp[i-1][j], prices[i] + max_diff)\\n            max_diff = max(max_diff, dp[i-1][j-1] - prices[i])\\n    return dp[n-1][k]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n  def maxProfit(self, k: int, prices: List[int]) -> int:\\n    n = len(prices)\\n    # edge case where there are no prices or no transactions\\n    if n == 0 or k == 0:\\n        return 0\\n    # edge case where we can perform an unlimited number of transactions\\n    if k >= n // 2:\\n        return sum(max(0, prices[i+1] - prices[i]) for i in range(n-1))\\n    # initialize dp table\\n    dp = [[0] * (k+1) for _ in range(n)]\\n    for j in range(1, k+1):\\n        max_diff = -prices[0] # keep track of the maximum difference seen so far\\n        for i in range(1, n):\\n            dp[i][j] = max(dp[i-1][j], prices[i] + max_diff)\\n            max_diff = max(max_diff, dp[i-1][j-1] - prices[i])\\n    return dp[n-1][k]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2559797,
                "title": "python3-runtime-81-ms-faster-than-95-84-memory-13-8-mb-less-than-98-29",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n            buy = [-inf]*(k+1)\\n            sell = [0] *(k+1)\\n            for price in prices:\\n                for i in range(1,k+1):\\n                    buy[i] = max(buy[i],sell[i-1]-price)\\n                    sell[i] = max(sell[i],buy[i]+price)\\n            return sell[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n            buy = [-inf]*(k+1)\\n            sell = [0] *(k+1)\\n            for price in prices:\\n                for i in range(1,k+1):\\n                    buy[i] = max(buy[i],sell[i-1]-price)\\n                    sell[i] = max(sell[i],buy[i]+price)\\n            return sell[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558848,
                "title": "c-dp",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint dp[1001][2][101];\\n\\t\\tint helper(vector<int>& prices, int n, int ind, int buy, int cap){\\n\\t\\t\\tif(ind==n || cap==0) return 0;\\n\\t\\t\\tif(dp[ind][buy][cap]!=-1) return dp[ind][buy][cap];\\n\\t\\t\\tint profit;\\n\\t\\t\\tif(buy==0){\\n\\t\\t\\t\\tprofit = max(helper(prices,n,ind+1,0,cap), -prices[ind] + helper(prices,n,ind+1,1,cap));\\n\\t\\t\\t}\\n\\t\\t\\tif(buy==1){\\n\\t\\t\\t\\tprofit = max(0+helper(prices,n,ind+1,1,cap),prices[ind] + helper(prices,n,ind+1,0,cap-1));\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[ind][buy][cap] = profit;\\n\\t\\t}\\n\\t\\tint maxProfit(int k, vector<int>& prices) {\\n\\t\\t\\tmemset(dp,-1,sizeof(dp));\\n\\t\\t\\treturn helper(prices,prices.size(),0,0,k);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint dp[1001][2][101];\\n\\t\\tint helper(vector<int>& prices, int n, int ind, int buy, int cap){\\n\\t\\t\\tif(ind==n || cap==0) return 0;\\n\\t\\t\\tif(dp[ind][buy][cap]!=-1) return dp[ind][buy][cap];\\n\\t\\t\\tint profit;\\n\\t\\t\\tif(buy==0){\\n\\t\\t\\t\\tprofit = max(helper(prices,n,ind+1,0,cap), -prices[ind] + helper(prices,n,ind+1,1,cap));\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2556760,
                "title": "python-recursion",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        N = len(prices)\\n        \\n        @cache\\n        def dfs(ind: int, can_sell: bool, k: int):\\n            if k == 0: return 0\\n            if ind == N: return 0\\n\\n            if ind == N - 1: \\n                if can_sell:\\n                    return prices[ind]\\n                else:\\n                    return 0\\n\\n            if can_sell:\\n\\t\\t\\t\\t# either not sell or sell; if sell, then complete one transaction(i.e. k - 1)\\n                res = max(dfs(ind + 1, True, k), prices[ind] + dfs(ind + 1, False, k - 1))\\n            else:\\n\\t\\t\\t\\t# either not buy or buy\\n                res = max(dfs(ind + 1, False, k), -prices[ind] + dfs(ind + 1, True, k))\\n            \\n            return res\\n            \\n        return dfs(0, False, k)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        N = len(prices)\\n        \\n        @cache\\n        def dfs(ind: int, can_sell: bool, k: int):\\n            if k == 0: return 0\\n            if ind == N: return 0\\n\\n            if ind == N - 1: \\n                if can_sell:\\n                    return prices[ind]\\n                else:\\n                    return 0\\n\\n            if can_sell:\\n\\t\\t\\t\\t# either not sell or sell; if sell, then complete one transaction(i.e. k - 1)\\n                res = max(dfs(ind + 1, True, k), prices[ind] + dfs(ind + 1, False, k - 1))\\n            else:\\n\\t\\t\\t\\t# either not buy or buy\\n                res = max(dfs(ind + 1, False, k), -prices[ind] + dfs(ind + 1, True, k))\\n            \\n            return res\\n            \\n        return dfs(0, False, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356983,
                "title": "c-easy-clear-and-simple-code-o-n-k-time-and-o-n-k-space-0-ms-faster-than-100-00",
                "content": "DP states and transitions are mention in comments\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        if(n==0) return 0;\\n        vector<vector<int>> dp(k+1,vector<int>(n,0));  \\n        for(int i=1;i<=k;i++){\\n            for(int j=1;j<n;j++){  \\n                    dp[i][j] = dp[i][j-1]; // previous day ans\\n                    for(int z=0;z<j;z++){  \\n            // i-1 transactions done now for ith take max of all the previous  possible transaction \\n                        dp[i][j] = max(dp[i][j],dp[i-1][z]+prices[j]-prices[z]);\\n                   }             \\n            }\\n        }\\n        return dp[k][n-1];\\n    }\\n};\\n```\\nFurther Optimization\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        if(n==0) return 0;\\n        vector<vector<int>> dp(k+1,vector<int>(n,0));  \\n        for(int i=1;i<=k;i++){\\n            int maxx = INT_MIN; \\n            for(int j=1;j<n;j++){  \\n                dp[i][j] = dp[i][j-1]; // previous day profit\\n                maxx = max(maxx,dp[i-1][j-1]-prices[j-1]); // cantains max profit till now in ( i-1 )th transaction\\n                dp[i][j] = max(dp[i][j],maxx+prices[j]);\\n            }\\n        }\\n        return dp[k][n-1];\\n    }\\n};\\n```\\ntime complexity : O(NK)\\nspace complexity : O(NK)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        if(n==0) return 0;\\n        vector<vector<int>> dp(k+1,vector<int>(n,0));  \\n        for(int i=1;i<=k;i++){\\n            for(int j=1;j<n;j++){  \\n                    dp[i][j] = dp[i][j-1]; // previous day ans\\n                    for(int z=0;z<j;z++){  \\n            // i-1 transactions done now for ith take max of all the previous  possible transaction \\n                        dp[i][j] = max(dp[i][j],dp[i-1][z]+prices[j]-prices[z]);\\n                   }             \\n            }\\n        }\\n        return dp[k][n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        if(n==0) return 0;\\n        vector<vector<int>> dp(k+1,vector<int>(n,0));  \\n        for(int i=1;i<=k;i++){\\n            int maxx = INT_MIN; \\n            for(int j=1;j<n;j++){  \\n                dp[i][j] = dp[i][j-1]; // previous day profit\\n                maxx = max(maxx,dp[i-1][j-1]-prices[j-1]); // cantains max profit till now in ( i-1 )th transaction\\n                dp[i][j] = max(dp[i][j],maxx+prices[j]);\\n            }\\n        }\\n        return dp[k][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672682,
                "title": "12-ms-c-recursion-with-memo",
                "content": "```\\nstatic auto speedup = []() {\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return nullptr;\\n}();\\n\\nclass Solution {\\npublic:\\n    int recur(vector<int>& nums, int i, int n, int k, int buy, vector<vector<vector<int>>>& dp){\\n        if (i==n || k==-1) return 0;\\n        if (dp[buy][k][i]!=-1) return dp[buy][k][i];\\n        int a, b;\\n        if (buy==0){             // buy==0 -> we need to to buy stock i.e no stock in hand\\n            a=recur(nums, i+1, n, k, 1, dp)-nums[i];\\n            b=recur(nums, i+1, n, k, 0, dp);\\n            return dp[buy][k][i]=(a>b)?a:b;\\n        }\\n        a=recur(nums, i+1, n, k-1, 0, dp)+nums[i];\\n        b=recur(nums, i+1, n, k, 1, dp);\\n        return dp[buy][k][i]=(a>b)?a:b;\\n    }\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n=prices.size();\\n        if (k>=n/2){\\n            int res=0;\\n            for (int i=1; i<n; ++i){\\n                if (prices[i]>prices[i-1]) res+=prices[i]-prices[i-1];\\n            }\\n            return res;\\n        }\\n        vector<vector<vector<int>>> dp(2, vector<vector<int>>(k, vector<int> (n, -1)));\\n        return recur(prices, 0, n, k-1, 0, dp);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nstatic auto speedup = []() {\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return nullptr;\\n}();\\n\\nclass Solution {\\npublic:\\n    int recur(vector<int>& nums, int i, int n, int k, int buy, vector<vector<vector<int>>>& dp){\\n        if (i==n || k==-1) return 0;\\n        if (dp[buy][k][i]!=-1) return dp[buy][k][i];\\n        int a, b;\\n        if (buy==0){             // buy==0 -> we need to to buy stock i.e no stock in hand\\n            a=recur(nums, i+1, n, k, 1, dp)-nums[i];\\n            b=recur(nums, i+1, n, k, 0, dp);\\n            return dp[buy][k][i]=(a>b)?a:b;\\n        }\\n        a=recur(nums, i+1, n, k-1, 0, dp)+nums[i];\\n        b=recur(nums, i+1, n, k, 1, dp);\\n        return dp[buy][k][i]=(a>b)?a:b;\\n    }\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n=prices.size();\\n        if (k>=n/2){\\n            int res=0;\\n            for (int i=1; i<n; ++i){\\n                if (prices[i]>prices[i-1]) res+=prices[i]-prices[i-1];\\n            }\\n            return res;\\n        }\\n        vector<vector<vector<int>>> dp(2, vector<vector<int>>(k, vector<int> (n, -1)));\\n        return recur(prices, 0, n, k-1, 0, dp);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 627973,
                "title": "top-down-approach-wrong-answer-on-memo-correct-ans-without-memo",
                "content": "I\\'m getting correct output without memoization. Could someone please explain what I\\'ve done wrong? \\n\\n```class Solution {\\n    Integer[][] dp;\\n    public int maxProfit(int k, int[] prices) {\\n        dp = new Integer[prices.length+1][k+1];\\n        return f(prices,0,false,-1,k);\\n    }\\n    public int f(int[] A,int index,boolean prev_buy,int prev_buy_value,int trans){\\n        if(index>A.length-1)\\n            return 0;\\n        if(trans==0)\\n            return 0;\\n        if(dp[index][trans]!=null)\\n            return dp[index][trans];\\n        int option1 = 0,option2 = 0;\\n        if(!prev_buy)\\n            option1 = f(A,index+1,true,A[index],trans);\\n        else if(prev_buy&&A[index]>=prev_buy_value)\\n            option1 = A[index]-prev_buy_value+f(A,index+1,false,-1,trans-1);\\n        option2 = f(A,index+1,prev_buy,prev_buy_value,trans);\\n        return dp[index][trans]=Math.max(option1,option2);\\n    }\\n}```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```class Solution {\\n    Integer[][] dp;\\n    public int maxProfit(int k, int[] prices) {\\n        dp = new Integer[prices.length+1][k+1];\\n        return f(prices,0,false,-1,k);\\n    }\\n    public int f(int[] A,int index,boolean prev_buy,int prev_buy_value,int trans){\\n        if(index>A.length-1)\\n            return 0;\\n        if(trans==0)\\n            return 0;\\n        if(dp[index][trans]!=null)\\n            return dp[index][trans];\\n        int option1 = 0,option2 = 0;\\n        if(!prev_buy)\\n            option1 = f(A,index+1,true,A[index],trans);\\n        else if(prev_buy&&A[index]>=prev_buy_value)\\n            option1 = A[index]-prev_buy_value+f(A,index+1,false,-1,trans-1);\\n        option2 = f(A,index+1,prev_buy,prev_buy_value,trans);\\n        return dp[index][trans]=Math.max(option1,option2);\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 580769,
                "title": "my-c-clean-solution-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        \\n        cin.tie(NULL);\\n        \\n        if(k==0 || prices.size()==0) return 0;\\n        \\n        int n=prices.size();\\n        \\n        if (k>n/2){\\n            \\n        int ans = 0;\\n            \\n        for (int i=1; i<n; ++i){\\n            \\n            ans += max(prices[i] - prices[i-1],0);\\n            \\n        }\\n            \\n        return ans;\\n            \\n    }\\n        vector<vector<int> > dp(prices.size()+1,vector<int>(k+1));\\n        \\n        for(int i=0;i<=n;i++){\\n            \\n            dp[i][0]=0;\\n        }\\n        \\n        for(int i=1;i<=k;i++){\\n            \\n            dp[n-1][i]=0;\\n            \\n            dp[n][i]=0;\\n        }\\n        \\n        for(int l=1;l<=k;l++){\\n            \\n            int ma=0,maxi=dp[n-1][l],tmp=prices[n-1]+dp[n][l-1];\\n            \\n            for(int i=n-2;i>=0;i--){\\n                      ma=max(ma,max(maxi,tmp-prices[i]));\\n                \\n                      maxi=max(maxi,dp[i][l]);\\n                \\n                      tmp=max(tmp,prices[i]+dp[i+1][l-1]);\\n                \\n                      dp[i][l]=ma;\\n            }\\n            \\n        }\\n    \\n        return dp[0][k];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        \\n        cin.tie(NULL);\\n        \\n        if(k==0 || prices.size()==0) return 0;\\n        \\n        int n=prices.size();\\n        \\n        if (k>n/2){\\n            \\n        int ans = 0;\\n            \\n        for (int i=1; i<n; ++i){\\n            \\n            ans += max(prices[i] - prices[i-1],0);\\n            \\n        }\\n            \\n        return ans;\\n            \\n    }\\n        vector<vector<int> > dp(prices.size()+1,vector<int>(k+1));\\n        \\n        for(int i=0;i<=n;i++){\\n            \\n            dp[i][0]=0;\\n        }\\n        \\n        for(int i=1;i<=k;i++){\\n            \\n            dp[n-1][i]=0;\\n            \\n            dp[n][i]=0;\\n        }\\n        \\n        for(int l=1;l<=k;l++){\\n            \\n            int ma=0,maxi=dp[n-1][l],tmp=prices[n-1]+dp[n][l-1];\\n            \\n            for(int i=n-2;i>=0;i--){\\n                      ma=max(ma,max(maxi,tmp-prices[i]));\\n                \\n                      maxi=max(maxi,dp[i][l]);\\n                \\n                      tmp=max(tmp,prices[i]+dp[i+1][l-1]);\\n                \\n                      dp[i][l]=ma;\\n            }\\n            \\n        }\\n    \\n        return dp[0][k];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 514970,
                "title": "python-3-3-d-array-dp",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        n = len(prices)\\n        if n<=1: return 0\\n        if k>n/2:\\n            res=0\\n            for i in range(1,n):\\n                res+=max(0,prices[i]-prices[i-1])\\n            return res\\n        dp = [[[0]*2 for _ in range(k+1)] for _ in range(n)]\\n\\n        for i in range(n):\\n            for j in range(1,k+1):\\n                if i==0:\\n                    dp[i][j][0]=0\\n                    dp[i][j][1]=-prices[i]\\n                    continue\\n                dp[i][j][0]=max(dp[i-1][j][0],dp[i-1][j][1]+prices[i])\\n                dp[i][j][1]=max(dp[i-1][j][1],dp[i-1][j-1][0]-prices[i])\\n        return dp[n-1][k][0]\\n            \\n```\\n\\n***\\nCheck on my [repo](https://github.com/zengtian006/LeetCode) to get Leetcode solution(Python) with classification: https://github.com/zengtian006/LeetCode\\n***",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        n = len(prices)\\n        if n<=1: return 0\\n        if k>n/2:\\n            res=0\\n            for i in range(1,n):\\n                res+=max(0,prices[i]-prices[i-1])\\n            return res\\n        dp = [[[0]*2 for _ in range(k+1)] for _ in range(n)]\\n\\n        for i in range(n):\\n            for j in range(1,k+1):\\n                if i==0:\\n                    dp[i][j][0]=0\\n                    dp[i][j][1]=-prices[i]\\n                    continue\\n                dp[i][j][0]=max(dp[i-1][j][0],dp[i-1][j][1]+prices[i])\\n                dp[i][j][1]=max(dp[i-1][j][1],dp[i-1][j-1][0]-prices[i])\\n        return dp[n-1][k][0]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 54220,
                "title": "accepted-8ms-c",
                "content": "    int maxProfit(int k, vector<int>& prices) {\\n        int n = (int)prices.size();\\n        if (n <= 1) return 0;\\n        int fm = 0, km = 0;\\n        for (int j = 1; j < n; j++) {\\n            int f = prices[j]-prices[j-1];\\n            if (f>0) {\\n                fm += f;\\n                km++;\\n            }\\n        }\\n        if (k >= km) {\\n            return fm;\\n        } else {\\n            int f[n], prev;\\n            fill_n(f, n, 0);\\n            for (int i = 1; i <= k; i++) {\\n                int S = INT_MIN;\\n                prev = f[0];\\n                for (int j = 1; j < n; j++) {\\n                    S = std::max(S, prev-prices[j-1]);\\n                    prev = f[j];\\n                    f[j] = std::max(f[j-1], S+prices[j]);\\n                }\\n            }\\n            return f[n-1];\\n        }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "    int maxProfit(int k, vector<int>& prices) {\\n        int n = (int)prices.size();\\n        if (n <= 1) return 0;\\n        int fm = 0, km = 0;\\n        for (int j = 1; j < n; j++) {\\n            int f = prices[j]-prices[j-1];\\n            if (f>0) {\\n                fm += f;\\n                km++;\\n            }\\n        }\\n        if (k >= km) {\\n            return fm;\\n        } else {\\n            int f[n], prev;\\n            fill_n(f, n, 0);\\n            for (int i = 1; i <= k; i++) {\\n                int S = INT_MIN;\\n                prev = f[0];\\n                for (int j = 1; j < n; j++) {\\n                    S = std::max(S, prev-prices[j-1]);\\n                    prev = f[j];\\n                    f[j] = std::max(f[j-1], S+prices[j]);\\n                }\\n            }\\n            return f[n-1];\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3369126,
                "title": "best-o-n-k-solution",
                "content": "# Approach 1\\nRecursion (TLE)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int idx, int buy, int cap, vector<int>& prices, int n) {\\n        if (cap == 0 || idx == n)\\n            return 0;\\n        if (buy == 1) \\n            return max (-prices[idx] + solve(idx+1, 0, cap, prices, n),\\n                        0 + solve(idx+1, 1, cap, prices, n));\\n        return max (prices[idx] + solve(idx+1, 1, cap-1, prices, n),\\n                    0 + solve(idx+1, 0, cap, prices, n));  \\n    }  \\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        return solve(0, 1, k, prices, n);\\n    }\\n};\\n```\\n\\n# Approach 2\\nDP (Top Down Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*k)$$\\n\\n- Space complexity:\\n$$O(n*k)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int idx, int buy, int cap, vector<int>& prices, vector<vector<vector<int>>>& dp, int n) {\\n        if (cap == 0 || idx == n)\\n            return 0;\\n            if (dp[idx][buy][cap] != -1)\\n                return dp[idx][buy][cap];\\n        if (buy == 1) \\n            return dp[idx][buy][cap] = max (-prices[idx] + solve(idx+1, 0, cap, prices, dp, n),\\n                        0 + solve(idx+1, 1, cap, prices, dp, n));\\n        return dp[idx][buy][cap] = max (prices[idx] + solve(idx+1, 1, cap-1, prices, dp, n),\\n                    0 + solve(idx+1, 0, cap, prices, dp, n));  \\n    }  \\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(2, vector<int>(k+1, -1)));\\n        return solve(0, 1, k, prices, dp, n);\\n    }\\n};\\n```\\n\\n# Approach 3\\nDP (Bottom Up Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*k)$$\\n\\n- Space complexity:\\n$$O(n*k)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(2, vector<int>(k+1, 0)));\\n        for (int idx = n-1; idx >= 0; idx--) {\\n            for (int buy = 0; buy <= 1; buy++) {\\n                for (int cap = 1; cap <= k; cap++) {\\n                    if (buy == 1) \\n                        dp[idx][buy][cap] = max (-prices[idx] + dp[idx+1][0][cap], 0 + dp[idx+1][1][cap]);\\n                    else    \\n                        dp[idx][buy][cap] = max (prices[idx] + dp[idx+1][1][cap-1], 0 + dp[idx+1][0][cap]);  \\n                }\\n            }\\n        }\\n        return dp[0][1][k];        \\n    }\\n};\\n```\\n\\n# Approach 4\\nDP (Bottom Up Approach) + Space Optimization\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*k)$$\\n\\n- Space complexity:\\n$$O(k)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> ahead(2, vector<int>(k+1, 0)), cur(2, vector<int>(k+1, 0));\\n        for (int idx = n-1; idx >= 0; idx--) {\\n            for (int buy = 0; buy <= 1; buy++) {\\n                for (int cap = 1; cap <= k; cap++) {\\n                    if (buy == 1) \\n                        cur[buy][cap] = max (-prices[idx] + ahead[0][cap], 0 + ahead[1][cap]);\\n                    else    \\n                        cur[buy][cap] = max (prices[idx] + ahead[1][cap-1], 0 + ahead[0][cap]);  \\n                }\\n            }\\n            ahead = cur;\\n        }\\n        return ahead[1][k];        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int idx, int buy, int cap, vector<int>& prices, int n) {\\n        if (cap == 0 || idx == n)\\n            return 0;\\n        if (buy == 1) \\n            return max (-prices[idx] + solve(idx+1, 0, cap, prices, n),\\n                        0 + solve(idx+1, 1, cap, prices, n));\\n        return max (prices[idx] + solve(idx+1, 1, cap-1, prices, n),\\n                    0 + solve(idx+1, 0, cap, prices, n));  \\n    }  \\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        return solve(0, 1, k, prices, n);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(int idx, int buy, int cap, vector<int>& prices, vector<vector<vector<int>>>& dp, int n) {\\n        if (cap == 0 || idx == n)\\n            return 0;\\n            if (dp[idx][buy][cap] != -1)\\n                return dp[idx][buy][cap];\\n        if (buy == 1) \\n            return dp[idx][buy][cap] = max (-prices[idx] + solve(idx+1, 0, cap, prices, dp, n),\\n                        0 + solve(idx+1, 1, cap, prices, dp, n));\\n        return dp[idx][buy][cap] = max (prices[idx] + solve(idx+1, 1, cap-1, prices, dp, n),\\n                    0 + solve(idx+1, 0, cap, prices, dp, n));  \\n    }  \\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(2, vector<int>(k+1, -1)));\\n        return solve(0, 1, k, prices, dp, n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(2, vector<int>(k+1, 0)));\\n        for (int idx = n-1; idx >= 0; idx--) {\\n            for (int buy = 0; buy <= 1; buy++) {\\n                for (int cap = 1; cap <= k; cap++) {\\n                    if (buy == 1) \\n                        dp[idx][buy][cap] = max (-prices[idx] + dp[idx+1][0][cap], 0 + dp[idx+1][1][cap]);\\n                    else    \\n                        dp[idx][buy][cap] = max (prices[idx] + dp[idx+1][1][cap-1], 0 + dp[idx+1][0][cap]);  \\n                }\\n            }\\n        }\\n        return dp[0][1][k];        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> ahead(2, vector<int>(k+1, 0)), cur(2, vector<int>(k+1, 0));\\n        for (int idx = n-1; idx >= 0; idx--) {\\n            for (int buy = 0; buy <= 1; buy++) {\\n                for (int cap = 1; cap <= k; cap++) {\\n                    if (buy == 1) \\n                        cur[buy][cap] = max (-prices[idx] + ahead[0][cap], 0 + ahead[1][cap]);\\n                    else    \\n                        cur[buy][cap] = max (prices[idx] + ahead[1][cap-1], 0 + ahead[0][cap]);  \\n                }\\n            }\\n            ahead = cur;\\n        }\\n        return ahead[1][k];        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555693,
                "title": "easy-python-15-line-dp-solution",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        def func(i,buy,prices,ct,dic):\\n            if i>=len(prices) or ct==0:\\n                return 0\\n            if (i,buy,ct) in dic:\\n                return dic[(i,buy,ct)]\\n            x,y,a,b=0,0,0,0\\n            if buy:\\n                x=-prices[i]+func(i+1,False,prices,ct,dic)\\n                y=0+func(i+1,buy,prices,ct,dic)\\n            else:\\n                a=prices[i]+func(i+1,True,prices,ct-1,dic)\\n                b=0+func(i+1,buy,prices,ct,dic)\\n            dic[(i,buy,ct)]=max(a,b,x,y)\\n            return max(a,b,x,y)\\n        return func(0,True,prices,k,{})\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        def func(i,buy,prices,ct,dic):\\n            if i>=len(prices) or ct==0:\\n                return 0\\n            if (i,buy,ct) in dic:\\n                return dic[(i,buy,ct)]\\n            x,y,a,b=0,0,0,0\\n            if buy:\\n                x=-prices[i]+func(i+1,False,prices,ct,dic)\\n                y=0+func(i+1,buy,prices,ct,dic)\\n            else:\\n                a=prices[i]+func(i+1,True,prices,ct-1,dic)\\n                b=0+func(i+1,buy,prices,ct,dic)\\n            dic[(i,buy,ct)]=max(a,b,x,y)\\n            return max(a,b,x,y)\\n        return func(0,True,prices,k,{})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480299,
                "title": "python-striver-solution-o-n-k-easy-solution",
                "content": "# Recursive :\\n```\\n\\nclass Solution:\\n    def f(self,ind,transNo,n,k,price):\\n        if ind==n or transNo==2*k:\\n            return 0\\n\\n        if transNo%2==0:    #buy\\n            profit=max(-price[ind] + self.f(ind+1,transNo+1,n,k,price),\\n                            0      + self.f(ind+1,transNo,n,k,price))\\n        else:\\n            profit=max(price[ind] + self.f(ind+1,transNo+1,n,k,price),\\n                            0     + self.f(ind+1,transNo,n,k,price))\\n\\n        return profit\\n            \\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        n=len(prices)\\n        return self.f(0,0,n,k,prices)\\n```\\n# Memoisation :\\n\\n```\\n\\n\\nclass Solution:\\n    def f(self,ind,transNo,n,k,price,dp):\\n        if ind==n or transNo==2*k:\\n            return 0\\n        if dp[ind][transNo]!=-1:\\n            return dp[ind][transNo]\\n        if transNo%2==0:    #buy\\n            profit=max(-price[ind] + self.f(ind+1,transNo+1,n,k,price,dp),\\n                            0      + self.f(ind+1,transNo,n,k,price,dp))\\n        else:\\n            profit=max(price[ind] + self.f(ind+1,transNo+1,n,k,price,dp),\\n                            0     + self.f(ind+1,transNo,n,k,price,dp))\\n        dp[ind][transNo]= profit\\n        return dp[ind][transNo]\\n            \\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        n=len(prices)\\n        dp=[[-1 for i in range(2*k)]for j in range(n)]\\n        return self.f(0,0,n,k,prices,dp)\\n```\\n# Tabulation :\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        n=len(prices)\\n        dp=[[0 for i in range(2*k+1)]for j in range(n+1)]\\n        \\n        for ind in range(n-1,-1,-1):\\n            for transNo in range(2*k-1,-1,-1):\\n                if transNo%2==0:    # buy\\n                    profit=max(-prices[ind] + dp[ind+1][transNo+1],\\n                            0      + dp[ind+1][transNo])\\n                else:\\n                    profit=max(prices[ind] + dp[ind+1][transNo+1],\\n                            0      + dp[ind+1][transNo])\\n                dp[ind][transNo]=profit\\n                \\n        return dp[0][0]\\n# Space Optimisation : )     --> O(2K)\\n```\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        n=len(prices)\\n\\n        after=[0]*(2*k+1)\\n        curr=[0]*(2*k+1)\\n        \\n        for ind in range(n-1,-1,-1):\\n            for transNo in range(2*k-1,-1,-1):\\n                if transNo%2==0:    # buy\\n                    profit=max(-prices[ind] + after[transNo+1],\\n                                     0      + after[transNo])\\n                else:\\n                    profit=max(prices[ind] + after[transNo+1],\\n                                    0      + after[transNo])\\n                curr[transNo]=profit\\n            after=curr\\n                \\n        return after[0]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution:\\n    def f(self,ind,transNo,n,k,price):\\n        if ind==n or transNo==2*k:\\n            return 0\\n\\n        if transNo%2==0:    #buy\\n            profit=max(-price[ind] + self.f(ind+1,transNo+1,n,k,price),\\n                            0      + self.f(ind+1,transNo,n,k,price))\\n        else:\\n            profit=max(price[ind] + self.f(ind+1,transNo+1,n,k,price),\\n                            0     + self.f(ind+1,transNo,n,k,price))\\n\\n        return profit\\n            \\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        n=len(prices)\\n        return self.f(0,0,n,k,prices)\\n```\n```\\n\\n\\nclass Solution:\\n    def f(self,ind,transNo,n,k,price,dp):\\n        if ind==n or transNo==2*k:\\n            return 0\\n        if dp[ind][transNo]!=-1:\\n            return dp[ind][transNo]\\n        if transNo%2==0:    #buy\\n            profit=max(-price[ind] + self.f(ind+1,transNo+1,n,k,price,dp),\\n                            0      + self.f(ind+1,transNo,n,k,price,dp))\\n        else:\\n            profit=max(price[ind] + self.f(ind+1,transNo+1,n,k,price,dp),\\n                            0     + self.f(ind+1,transNo,n,k,price,dp))\\n        dp[ind][transNo]= profit\\n        return dp[ind][transNo]\\n            \\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        n=len(prices)\\n        dp=[[-1 for i in range(2*k)]for j in range(n)]\\n        return self.f(0,0,n,k,prices,dp)\\n```\n```\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        n=len(prices)\\n\\n        after=[0]*(2*k+1)\\n        curr=[0]*(2*k+1)\\n        \\n        for ind in range(n-1,-1,-1):\\n            for transNo in range(2*k-1,-1,-1):\\n                if transNo%2==0:    # buy\\n                    profit=max(-prices[ind] + after[transNo+1],\\n                                     0      + after[transNo])\\n                else:\\n                    profit=max(prices[ind] + after[transNo+1],\\n                                    0      + after[transNo])\\n                curr[transNo]=profit\\n            after=curr\\n                \\n        return after[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738818,
                "title": "explained-python-solution-recursive-memoization-dp-optimal",
                "content": "```python\\n# ---------  Recursive + Memoization => TLE -----------------------\\nclass Solution:\\n    def maxProfit(self, k, prices):\\n        # Same as Matrix Chain Multiplication\\n        n = len(prices) - 1\\n        dp = [[-1]*(n+1) for i in range(k+1)]\\n        \\n        def solve(k, n):\\n            if k == 0 or n < 1: return 0\\n            \\n            if dp[k][n] != -1: return dp[k][n]\\n            \\n            ans = -2**31 - 1\\n            for i in range(n):\\n                ans = max(ans, solve(k-1, i) + (prices[n] - prices[i])) # Max profit for (k-1) transactions and stocks before today\\n            \\n            ans =  max(ans, solve(k, n-1))\\n            \\n            dp[k][n] = ans\\n            return dp[k][n]\\n        \\n        return solve(k, n)\\n\\n# Time Complexity: O(n^2 * k)\\n# Space Complexity: O(n*k)\\n# This solution will give TLE\\n\\n\\n# -------  Dynamic Programming => TLE ---------------------\\nclass Solution:\\n    def maxProfit(self, k, prices):\\n        n = len(prices)\\n        if n <= 1 or k == 0: return 0\\n        \\n        dp = [[0]*n for t in range(k+1)]\\n        \\n        for t in range(1, k+1):    # transaction\\n            for d in range(1, n):  # day\\n                \\n                ans = -2**31 -1\\n                \\n                for p in range(d): # previous days where (t-1) transactions allowed\\n                    ans = max(ans, dp[t-1][p] + prices[d]- prices[p])\\n                    \\n                ans = max(ans, dp[t][d-1]) # previous day with t transactions allowed\\n                \\n                dp[t][d] = ans\\n        \\n        return dp[-1][-1]\\n\\n# Time Complexity: O(n^2 * k)\\n# Space Complexity: O(n*k)\\n# This solution will give TLE\\n\\n\\n# ----  Dynamic Programming => OPTIMAL All TestCases Passed -------\\nclass Solution:\\n    def maxProfit(self, k, prices):\\n        n = len(prices)\\n        if n <= 1 or k== 0: return 0\\n        \\n        dp = [[0]*n for i in range(k+1)]\\n        \\n        for t in range(1, k+1):    # number transactions allowed\\n            prevMax = float(\"-inf\")  # to store the max profit for (t-1) transactions on previous days \\n            for d in range(1, n):  # current day\\n                prevMax = max(prevMax, dp[t-1][d-1] - prices[d-1])\\n                dp[t][d] = max(prevMax + prices[d], dp[t][d-1])\\n                \\n        return dp[-1][-1]\\n        \\n# Time Complexity: O(n*k)\\n# Space Complexity: O(n*k)\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```python\\n# ---------  Recursive + Memoization => TLE -----------------------\\nclass Solution:\\n    def maxProfit(self, k, prices):\\n        # Same as Matrix Chain Multiplication\\n        n = len(prices) - 1\\n        dp = [[-1]*(n+1) for i in range(k+1)]\\n        \\n        def solve(k, n):\\n            if k == 0 or n < 1: return 0\\n            \\n            if dp[k][n] != -1: return dp[k][n]\\n            \\n            ans = -2**31 - 1\\n            for i in range(n):\\n                ans = max(ans, solve(k-1, i) + (prices[n] - prices[i])) # Max profit for (k-1) transactions and stocks before today\\n            \\n            ans =  max(ans, solve(k, n-1))\\n            \\n            dp[k][n] = ans\\n            return dp[k][n]\\n        \\n        return solve(k, n)\\n\\n# Time Complexity: O(n^2 * k)\\n# Space Complexity: O(n*k)\\n# This solution will give TLE\\n\\n\\n# -------  Dynamic Programming => TLE ---------------------\\nclass Solution:\\n    def maxProfit(self, k, prices):\\n        n = len(prices)\\n        if n <= 1 or k == 0: return 0\\n        \\n        dp = [[0]*n for t in range(k+1)]\\n        \\n        for t in range(1, k+1):    # transaction\\n            for d in range(1, n):  # day\\n                \\n                ans = -2**31 -1\\n                \\n                for p in range(d): # previous days where (t-1) transactions allowed\\n                    ans = max(ans, dp[t-1][p] + prices[d]- prices[p])\\n                    \\n                ans = max(ans, dp[t][d-1]) # previous day with t transactions allowed\\n                \\n                dp[t][d] = ans\\n        \\n        return dp[-1][-1]\\n\\n# Time Complexity: O(n^2 * k)\\n# Space Complexity: O(n*k)\\n# This solution will give TLE\\n\\n\\n# ----  Dynamic Programming => OPTIMAL All TestCases Passed -------\\nclass Solution:\\n    def maxProfit(self, k, prices):\\n        n = len(prices)\\n        if n <= 1 or k== 0: return 0\\n        \\n        dp = [[0]*n for i in range(k+1)]\\n        \\n        for t in range(1, k+1):    # number transactions allowed\\n            prevMax = float(\"-inf\")  # to store the max profit for (t-1) transactions on previous days \\n            for d in range(1, n):  # current day\\n                prevMax = max(prevMax, dp[t-1][d-1] - prices[d-1])\\n                dp[t][d] = max(prevMax + prices[d], dp[t][d-1])\\n                \\n        return dp[-1][-1]\\n        \\n# Time Complexity: O(n*k)\\n# Space Complexity: O(n*k)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523386,
                "title": "c-recursive-memoization-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1001][101][2];\\n    int solve(int k, vector<int>& prices, int pos, bool hold){\\n        if(pos>=prices.size()) return 0;\\n        if(dp[pos][k][hold]!=-1) return dp[pos][k][hold];\\n        int sell=0, notsell=0, buy=0, notbuy=0;\\n        if(!hold and k) buy = solve(k-1,prices,pos+1,!hold) - prices[pos];\\n        notbuy = solve(k,prices,pos+1,hold);\\n        if(hold) sell = solve(k,prices,pos+1,!hold) + prices[pos];\\n        notsell = solve(k,prices,pos+1,hold);\\n        return dp[pos][k][hold] = max({buy,sell,notbuy,notsell});\\n    }\\n    \\n    int maxProfit(int k, vector<int>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(k,prices,0,false);\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][101][2];\\n    int solve(int k, vector<int>& prices, int pos, bool hold){\\n        if(pos>=prices.size()) return 0;\\n        if(dp[pos][k][hold]!=-1) return dp[pos][k][hold];\\n        int sell=0, notsell=0, buy=0, notbuy=0;\\n        if(!hold and k) buy = solve(k-1,prices,pos+1,!hold) - prices[pos];\\n        notbuy = solve(k,prices,pos+1,hold);\\n        if(hold) sell = solve(k,prices,pos+1,!hold) + prices[pos];\\n        notsell = solve(k,prices,pos+1,hold);\\n        return dp[pos][k][hold] = max({buy,sell,notbuy,notsell});\\n    }\\n    \\n    int maxProfit(int k, vector<int>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(k,prices,0,false);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522210,
                "title": "time-o-n-k-space-o-k-easy-to-understand",
                "content": "the same as [123. Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)\\nto calculate the sell[j], we only need the sell[j-1] and buy[j-1]\\nIf the jth sell we have two choice:\\n* \\t1. we don\\'t do anything, have the same profit of the j-1th day.\\n* \\t2. or we sell in the jth day.\\n\\nthen it would be \\nsell[j] = max(sell[j-1], prices[i] + buy[j-1]);\\nbuy[j] = max(buy[j-1], sell[j-1] - prices[i]);\\n\\nif we caculate in 1 to k\\nwe need a extra space to store the last day of buy and sell, because it will change when we caculate.\\nif we calculate in reverse and we only need the buy[j-1] and sell[j-1].  \\nwe can use sell[j] and buy[j] to store.\\nsell[j] would be sell[j-1] before it change.\\nbuy[j] would be buy[j-1] before it change.\\n\\nc++\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        vector<int> sell(k+1, 0), buy(k+1, INT_MIN);\\n        for(int i = 0; i < n; i++){\\n            for(int j = k; j; j--){\\n                sell[j] = max(sell[j], prices[i] + buy[j]);\\n                buy[j] = max(buy[j], sell[j-1] - prices[i]);\\n            }\\n        }\\n        return sell[k];\\n    }\\n};\\n```\\njava\\n```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        int n = prices.length;\\n        int[] sell = new int[k+1], buy = new int[k+1];\\n        for(int i = 0; i < k+1; i++){\\n            sell[i] = 0;\\n            buy[i] = Integer.MIN_VALUE;\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = k; j > 0; j--){\\n                sell[j] = Math.max(sell[j], prices[i] + buy[j]);\\n                buy[j] = Math.max(buy[j], sell[j-1] - prices[i]);\\n            }\\n        }\\n        return sell[k];\\n    }\\n}\\n```\\npython\\n```\\nclass Solution(object):\\n    def maxProfit(self, k, prices):\\n        n = len(prices)\\n        sell = [0 for i in range(k+1)]\\n        buy = [float(\\'-inf\\') for i in range(k+1)]\\n        for i in range(n):\\n            for j in range(k, 0, -1):\\n                sell[j] = max(sell[j], prices[i] + buy[j])\\n                buy[j] = max(buy[j], sell[j-1] - prices[i])\\n        return sell[k]\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        vector<int> sell(k+1, 0), buy(k+1, INT_MIN);\\n        for(int i = 0; i < n; i++){\\n            for(int j = k; j; j--){\\n                sell[j] = max(sell[j], prices[i] + buy[j]);\\n                buy[j] = max(buy[j], sell[j-1] - prices[i]);\\n            }\\n        }\\n        return sell[k];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        int n = prices.length;\\n        int[] sell = new int[k+1], buy = new int[k+1];\\n        for(int i = 0; i < k+1; i++){\\n            sell[i] = 0;\\n            buy[i] = Integer.MIN_VALUE;\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = k; j > 0; j--){\\n                sell[j] = Math.max(sell[j], prices[i] + buy[j]);\\n                buy[j] = Math.max(buy[j], sell[j-1] - prices[i]);\\n            }\\n        }\\n        return sell[k];\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def maxProfit(self, k, prices):\\n        n = len(prices)\\n        sell = [0 for i in range(k+1)]\\n        buy = [float(\\'-inf\\') for i in range(k+1)]\\n        for i in range(n):\\n            for j in range(k, 0, -1):\\n                sell[j] = max(sell[j], prices[i] + buy[j])\\n                buy[j] = max(buy[j], sell[j-1] - prices[i])\\n        return sell[k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299248,
                "title": "very-easy-memoization-recursive-java-solution",
                "content": "```\\nclass Solution {\\n\\t// state1 - either prev txn was a buy/sell buy=1, sell=0\\n\\t// state2 - current day (idx)\\n\\t// state3 - number of txn remaining (k)\\n    int dp[][][];\\n    public int maxProfit(int k, int[] prices) {\\n        int n = prices.length;\\n        dp = new int[2][n][k+1];\\n\\t\\t//base case\\n        if(n<=1 || k==0)\\n            return 0;\\n\\t\\t//initialize array with -1;\\n        for(int[][] x:dp)\\n            for(int[] y:x)\\n                Arrays.fill(y, -1);\\n        //as we need to start with a buy assuming prev txn was a sell(0).\\n        return solve(n, 0, k, 0, prices);\\n    }\\n    \\n    public int solve(int n, int idx, int k, int buy, int[] prices) {\\n\\t\\t//base case \\n        if(k == 0 || idx == n)\\n            return 0;\\n        if(dp[buy][idx][k] != -1) {\\n            return dp[buy][idx][k];\\n        }\\n        int res = -1;\\n\\t\\t//if prev transaction was a buy and currently i am holding the shares\\n        if(buy == 1) {\\n\\t\\t\\t// we have 2 cases if prev txn was a buy\\n\\t\\t\\t// either sell it and decrease \"k\" by 1, as 1 txn has taken place\\n\\t\\t\\tint sell =  solve(n, idx+1, k-1, 0, prices)+prices[idx];\\n\\t\\t\\t//hold the given stock\\n\\t\\t\\tint hold = solve(n, idx+1, k, 1, prices);\\n             res = Math.max(sell, hold);\\n        }else {\\n\\t\\t\\t// we have 2 cases if prev txn was a sell\\n\\t\\t\\t// either buy it \\n\\t\\t\\tint buy = solve(n, idx+1, k, 1, prices)-prices[idx];\\n\\t\\t\\t// or skip that day\\n\\t\\t\\tint skip = solve(n, idx+1, k, 0, prices);\\n\\t\\t\\t//take max for both\\n             res = Math.max(buy, skip);\\n        }\\n        dp[buy][idx][k] = res;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\t// state1 - either prev txn was a buy/sell buy=1, sell=0\\n\\t// state2 - current day (idx)\\n\\t// state3 - number of txn remaining (k)\\n    int dp[][][];\\n    public int maxProfit(int k, int[] prices) {\\n        int n = prices.length;\\n        dp = new int[2][n][k+1];\\n\\t\\t//base case\\n        if(n<=1 || k==0)\\n            return 0;\\n\\t\\t//initialize array with -1;\\n        for(int[][] x:dp)\\n            for(int[] y:x)\\n                Arrays.fill(y, -1);\\n        //as we need to start with a buy assuming prev txn was a sell(0).\\n        return solve(n, 0, k, 0, prices);\\n    }\\n    \\n    public int solve(int n, int idx, int k, int buy, int[] prices) {\\n\\t\\t//base case \\n        if(k == 0 || idx == n)\\n            return 0;\\n        if(dp[buy][idx][k] != -1) {\\n            return dp[buy][idx][k];\\n        }\\n        int res = -1;\\n\\t\\t//if prev transaction was a buy and currently i am holding the shares\\n        if(buy == 1) {\\n\\t\\t\\t// we have 2 cases if prev txn was a buy\\n\\t\\t\\t// either sell it and decrease \"k\" by 1, as 1 txn has taken place\\n\\t\\t\\tint sell =  solve(n, idx+1, k-1, 0, prices)+prices[idx];\\n\\t\\t\\t//hold the given stock\\n\\t\\t\\tint hold = solve(n, idx+1, k, 1, prices);\\n             res = Math.max(sell, hold);\\n        }else {\\n\\t\\t\\t// we have 2 cases if prev txn was a sell\\n\\t\\t\\t// either buy it \\n\\t\\t\\tint buy = solve(n, idx+1, k, 1, prices)-prices[idx];\\n\\t\\t\\t// or skip that day\\n\\t\\t\\tint skip = solve(n, idx+1, k, 0, prices);\\n\\t\\t\\t//take max for both\\n             res = Math.max(buy, skip);\\n        }\\n        dp[buy][idx][k] = res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265181,
                "title": "java-recursion-memoization-o-n-k",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        int n = prices.length;\\n        \\n        if(2*k >= n){ \\n            //basiaclly this means infinte transactions, no need to go for recursion take every local(high,lo) to profit\\n            return buyAndSellStock2(prices,n);\\n        }\\n        \\n        int[][][]dp = new int[(2*k)+1][2][n+1];\\n        for(int[][]d : dp){\\n            for(int[] d1: d){\\n                Arrays.fill(d1,-1);\\n            }\\n        }\\n        return findProfit(dp,prices,2*k,true,0,n);\\n    }\\n    \\n    int findProfit(int[][][]dp, int[]prices,int transaction,boolean buy, int indx, int end){\\n        if(dp[transaction][(buy==true ? 1 : 0)][indx] != -1){\\n            return dp[transaction][(buy==true ? 1 : 0)][indx];\\n        }        \\n        if(transaction == 0 || indx == end){\\n            return dp[transaction][(buy==true ? 1 : 0)][indx] = 0;\\n        }\\n        int max = 0;\\n        int skipping = findProfit(dp,prices,transaction,buy,indx+1,end);\\n        if(buy){\\n            int buying = findProfit(dp,prices,transaction-1,!buy,indx+1,end) - prices[indx];\\n            max = Math.max(skipping,buying);\\n        }\\n        else{\\n            int selling = findProfit(dp,prices,transaction-1,!buy,indx+1,end) + prices[indx];\\n            max = Math.max(skipping,selling);\\n        }\\n        return dp[transaction][(buy==true ? 1 : 0)][indx] = max;\\n    }\\n    \\n    int buyAndSellStock2(int[]prices,int n){\\n        int profit = 0;\\n        for(int i=1; i<n; i++){\\n            int transaction = prices[i]-prices[i-1];\\n            if(transaction > 0) profit += transaction;\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        int n = prices.length;\\n        \\n        if(2*k >= n){ \\n            //basiaclly this means infinte transactions, no need to go for recursion take every local(high,lo) to profit\\n            return buyAndSellStock2(prices,n);\\n        }\\n        \\n        int[][][]dp = new int[(2*k)+1][2][n+1];\\n        for(int[][]d : dp){\\n            for(int[] d1: d){\\n                Arrays.fill(d1,-1);\\n            }\\n        }\\n        return findProfit(dp,prices,2*k,true,0,n);\\n    }\\n    \\n    int findProfit(int[][][]dp, int[]prices,int transaction,boolean buy, int indx, int end){\\n        if(dp[transaction][(buy==true ? 1 : 0)][indx] != -1){\\n            return dp[transaction][(buy==true ? 1 : 0)][indx];\\n        }        \\n        if(transaction == 0 || indx == end){\\n            return dp[transaction][(buy==true ? 1 : 0)][indx] = 0;\\n        }\\n        int max = 0;\\n        int skipping = findProfit(dp,prices,transaction,buy,indx+1,end);\\n        if(buy){\\n            int buying = findProfit(dp,prices,transaction-1,!buy,indx+1,end) - prices[indx];\\n            max = Math.max(skipping,buying);\\n        }\\n        else{\\n            int selling = findProfit(dp,prices,transaction-1,!buy,indx+1,end) + prices[indx];\\n            max = Math.max(skipping,selling);\\n        }\\n        return dp[transaction][(buy==true ? 1 : 0)][indx] = max;\\n    }\\n    \\n    int buyAndSellStock2(int[]prices,int n){\\n        int profit = 0;\\n        for(int i=1; i<n; i++){\\n            int transaction = prices[i]-prices[i-1];\\n            if(transaction > 0) profit += transaction;\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152635,
                "title": "java-easy-solution",
                "content": "```\\npublic int maxProfit(int k, int[] prices) {\\n       \\n        int buy[]=new int[k+1];\\n        Arrays.fill(buy,Integer.MAX_VALUE);\\n        int sell[]=new int[k+1];\\n        \\n        for(int price:prices){\\n         for(int j=1;j<=k;j++){\\n             buy[j]=Math.min(buy[j],price-sell[j-1]);\\n             sell[j]=Math.max(sell[j],price-buy[j]);\\n         }\\n        }\\n        return sell[k];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxProfit(int k, int[] prices) {\\n       \\n        int buy[]=new int[k+1];\\n        Arrays.fill(buy,Integer.MAX_VALUE);\\n        int sell[]=new int[k+1];\\n        \\n        for(int price:prices){\\n         for(int j=1;j<=k;j++){\\n             buy[j]=Math.min(buy[j],price-sell[j-1]);\\n             sell[j]=Math.max(sell[j],price-buy[j]);\\n         }\\n        }\\n        return sell[k];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1019579,
                "title": "c-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[1002][102][2];\\n    \\n    int helper(vector<int>& prices, int k, int pos, int buy){\\n        \\n        if(k==0 || pos>=prices.size()){\\n            return 0;\\n        }\\n        \\n        int res=0;\\n        \\n        if(dp[pos][k][buy]!=-1){\\n            return dp[pos][k][buy];\\n        }\\n        \\n        if(buy){\\n            res= max( helper(prices,k,pos+1,0) - prices[pos] , \\n                                    helper(prices,k,pos+1,1));\\n        }\\n        else{\\n            res= max(helper(prices,k-1,pos+1,1) + prices[pos] , \\n                                    helper(prices,k,pos+1,0)); \\n        }\\n        \\n        return dp[pos][k][buy]=res;\\n    }\\n    \\n    int maxProfit(int k, vector<int>& prices) {\\n        memset(dp, -1, sizeof(dp));\\n        \\n        return helper(prices,k,0,1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[1002][102][2];\\n    \\n    int helper(vector<int>& prices, int k, int pos, int buy){\\n        \\n        if(k==0 || pos>=prices.size()){\\n            return 0;\\n        }\\n        \\n        int res=0;\\n        \\n        if(dp[pos][k][buy]!=-1){\\n            return dp[pos][k][buy];\\n        }\\n        \\n        if(buy){\\n            res= max( helper(prices,k,pos+1,0) - prices[pos] , \\n                                    helper(prices,k,pos+1,1));\\n        }\\n        else{\\n            res= max(helper(prices,k-1,pos+1,1) + prices[pos] , \\n                                    helper(prices,k,pos+1,0)); \\n        }\\n        \\n        return dp[pos][k][buy]=res;\\n    }\\n    \\n    int maxProfit(int k, vector<int>& prices) {\\n        memset(dp, -1, sizeof(dp));\\n        \\n        return helper(prices,k,0,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899877,
                "title": "need-leetcode-help-why-n-2-cause-tle-in-python",
                "content": "Hi @leetcode team or anyone can help.\\nWhen I solve Daily Challenge [188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/) problem, I implemented `Bottom-up DP` approach like following source code. It only costs total `N^2, N <= 1000`, but why it causes TLE? Is the Leetcode time so strict, should Leetcode update the correct time?\\nThanks.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        n = len(prices)\\n        if n <= 1: return 0\\n        k = min(k, n // 2) # Maximum n/2 transactions\\n        dp = [0] * n\\n        for _ in range(k):\\n            val = 0\\n            for i in range(1, n): \\n                val = max(dp[i], val + prices[i] - prices[i-1]) \\n                dp[i] = max(dp[i-1], val)\\n        return dp[-1]\\n```\\n\\n**Submission Detail:**\\nhttps://leetcode.com/submissions/detail/410163259/\\n![image](https://assets.leetcode.com/users/images/15d5bee8-2a8e-414a-97a0-4213e54e411d_1603006408.8775086.png)\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        n = len(prices)\\n        if n <= 1: return 0\\n        k = min(k, n // 2) # Maximum n/2 transactions\\n        dp = [0] * n\\n        for _ in range(k):\\n            val = 0\\n            for i in range(1, n): \\n                val = max(dp[i], val + prices[i] - prices[i-1]) \\n                dp[i] = max(dp[i-1], val)\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685164,
                "title": "go-golang-dp-simple-solution-beat-100",
                "content": "```go\\nfunc maxProfit(k int, prices []int) int {\\n    \\n    if len(prices) == 0 {\\n        return 0\\n    }\\n    n := len(prices)\\n    \\n    if k > n / 2{\\n        return bf(prices)\\n    }\\n    \\n    dp := make([][]int, k+1)\\n    for i := 0; i < k+1; i++ {\\n        dp[i] = make([]int, n+1)\\n    }\\n    \\n    // dp[k][i] = max(dp[k][i-1], prices[i] - prices[j] + dp[k-1][j-1])\\n    for j := 1; j < k+1; j++ {\\n        min_price := prices[0]\\n        for i := 1; i < n+1; i++ {\\n            min_price = Min(min_price, prices[i-1]-dp[j-1][i-1])\\n            dp[j][i] = Max(dp[j][i-1], prices[i-1]-min_price)\\n        }\\n    }\\n    \\n    return dp[k][n]\\n}\\n\\nfunc bf(prices []int) int {\\n    profit := 0\\n    for i:=1; i< len(prices); i++ {\\n        if prices[i]>prices[i-1] {\\n            profit += (prices[i]-prices[i-1])\\n        }\\n    }\\n    return profit\\n}\\n\\nfunc Min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc Max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```go\\nfunc maxProfit(k int, prices []int) int {\\n    \\n    if len(prices) == 0 {\\n        return 0\\n    }\\n    n := len(prices)\\n    \\n    if k > n / 2{\\n        return bf(prices)\\n    }\\n    \\n    dp := make([][]int, k+1)\\n    for i := 0; i < k+1; i++ {\\n        dp[i] = make([]int, n+1)\\n    }\\n    \\n    // dp[k][i] = max(dp[k][i-1], prices[i] - prices[j] + dp[k-1][j-1])\\n    for j := 1; j < k+1; j++ {\\n        min_price := prices[0]\\n        for i := 1; i < n+1; i++ {\\n            min_price = Min(min_price, prices[i-1]-dp[j-1][i-1])\\n            dp[j][i] = Max(dp[j][i-1], prices[i-1]-min_price)\\n        }\\n    }\\n    \\n    return dp[k][n]\\n}\\n\\nfunc bf(prices []int) int {\\n    profit := 0\\n    for i:=1; i< len(prices); i++ {\\n        if prices[i]>prices[i-1] {\\n            profit += (prices[i]-prices[i-1])\\n        }\\n    }\\n    return profit\\n}\\n\\nfunc Min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc Max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 530869,
                "title": "a-really-clean-and-straightforward-dp-induction-explanation",
                "content": "A lot discussions for this question are still super hard to understand, and one reason is that people swapped the i and j index, which commonly i should stand for the array index. Hope my explanation should be more clear and easier. \\n\\ndp[i,j]: i stands for the array index, i.e. the date, and the j stands for the the up to j transactions. One question at the very first thought, how can we deal with the notion of **at most**? Very easy, just refer to how we deal with the longest subsequence etc., that is, to let table[i] = table[i-1] as the initial value before the optimial induction. \\n\\nBased on the observation above, we can have the following induction. \\n- at the date i and up to j transactions, we can just not transact the jth transaction, so we have the dp[i,j] = dp[i, j-1] as the initial value \\n- what if we need to transact this jth transaction? As per the nature of DP\\'s top-down characteristics, the thing can happen on the ith day can only be a sell. As we should not have any transactions overlapped, there must be a date p before i that we buy, and between p+1 and i-1 there should not be any transaction any more. Therefore, the dp[i,j] is equal to, the price[i] that we sell, minors the price[p] that we buy, and the profit we already obtained on the p-1 day with at most j-1 times transaction. \\n- In order to reduce the time complexity, we dont have to loop repeatedly. Instead, we can use a greedy idea here, that we record the min value of (price[p]- dp[p-1, j-1]), because this min value can guarantee the profit on  dp[p-1, j-1] for sure is max \\n\\n```\\n  public int maxProfit(int k, int[] prices) {\\n    int len = prices.length;\\n    if (k >= len / 2)\\n      return greedy(prices);\\n\\n    int[][] dp = new int[len][k+1];\\n    for (int j = 1; j <= k; j++) {\\n      int prevMinProfit = prices[0];\\n      for (int i = 1; i < len; i++) {\\n        dp[i][j] = Math.max(dp[i-1][j], prices[i] - prevMinProfit);\\n        prevMinProfit = Math.min(prevMinProfit, prices[i] - dp[i - 1][j - 1]);\\n      }\\n    }\\n    return dp[len-1][k];\\n  }\\n\\n\\n  private int greedy(int[] prices) {\\n    int len = prices.length, profit = 0;\\n    for (int i = 1; i < len; i++){\\n      if (prices[i] > prices[i - 1])\\n        profit += prices[i] - prices[i - 1];\\n    }\\n    return profit;\\n  }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n  public int maxProfit(int k, int[] prices) {\\n    int len = prices.length;\\n    if (k >= len / 2)\\n      return greedy(prices);\\n\\n    int[][] dp = new int[len][k+1];\\n    for (int j = 1; j <= k; j++) {\\n      int prevMinProfit = prices[0];\\n      for (int i = 1; i < len; i++) {\\n        dp[i][j] = Math.max(dp[i-1][j], prices[i] - prevMinProfit);\\n        prevMinProfit = Math.min(prevMinProfit, prices[i] - dp[i - 1][j - 1]);\\n      }\\n    }\\n    return dp[len-1][k];\\n  }\\n\\n\\n  private int greedy(int[] prices) {\\n    int len = prices.length, profit = 0;\\n    for (int i = 1; i < len; i++){\\n      if (prices[i] > prices[i - 1])\\n        profit += prices[i] - prices[i - 1];\\n    }\\n    return profit;\\n  }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 351201,
                "title": "dp-solution-faster-than-100-with-explanation",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        return maxProfitDP(prices, k);\\n    }\\n    private int maxProfitDP(int[] prices, int transactions){\\n        /* f[k,i] represents max profit with K transactions and trading ending at day i\\n        There are two possiblities\\n           either we ignore day i, that means max profit is nothing but f[k, i-1]\\n           or we seel on day i, which means which must have purchased at some prior day\\n           j such that price[i] - price[j] + f[k-1, j] is maximum.\\n           \\n           f[0,i] = 0 as wth zero transaction you cannnot earn anything\\n           f[k,0] = 0 as nothing can be earned by zero  data points\\n        */\\n        \\n        if(prices.length == 0) return 0;\\n        \\n        /*This case handles the possibility that you may be allowed to have more than \\n         n/2 transactions, in this case, we can buy and sell on each possible day and\\n         maximize the problem.\\n         */\\n        if (transactions >=  prices.length/2) {\\n\\t\\t    int maxPro = 0;\\n\\t\\t    for (int i = 1; i < prices.length; i++) {\\n\\t\\t\\t    if (prices[i] > prices[i-1])\\n\\t\\t\\t\\t    maxPro += prices[i] - prices[i-1];\\n\\t\\t    }\\n\\t\\t    return maxPro;\\n\\t    }\\n        \\n        int[][] f = new int[2][prices.length];\\n        f[0][0] = 0;\\n        \\n        /*To avoid the memory limit exceeded, only two rows are used\\n        as we need only k-1 and k transaction rows, everything else \\n        can be done away with */\\n        \\n        for(int k=1; k<=transactions; k++){\\n            int tempMax =  f[0][0] - prices[0];\\n            for(int i=1; i<prices.length; i++){\\n                f[1][i] = Math.max(prices[i] + tempMax, f[1][i-1]);\\n                tempMax = Math.max(tempMax, f[0][i] - prices[i]);\\n                f[0][i] = f[1][i];\\n            }\\n        }\\n        \\n        return f[0][prices.length-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        return maxProfitDP(prices, k);\\n    }\\n    private int maxProfitDP(int[] prices, int transactions){\\n        /* f[k,i] represents max profit with K transactions and trading ending at day i\\n        There are two possiblities\\n           either we ignore day i, that means max profit is nothing but f[k, i-1]\\n           or we seel on day i, which means which must have purchased at some prior day\\n           j such that price[i] - price[j] + f[k-1, j] is maximum.\\n           \\n           f[0,i] = 0 as wth zero transaction you cannnot earn anything\\n           f[k,0] = 0 as nothing can be earned by zero  data points\\n        */\\n        \\n        if(prices.length == 0) return 0;\\n        \\n        /*This case handles the possibility that you may be allowed to have more than \\n         n/2 transactions, in this case, we can buy and sell on each possible day and\\n         maximize the problem.\\n         */\\n        if (transactions >=  prices.length/2) {\\n\\t\\t    int maxPro = 0;\\n\\t\\t    for (int i = 1; i < prices.length; i++) {\\n\\t\\t\\t    if (prices[i] > prices[i-1])\\n\\t\\t\\t\\t    maxPro += prices[i] - prices[i-1];\\n\\t\\t    }\\n\\t\\t    return maxPro;\\n\\t    }\\n        \\n        int[][] f = new int[2][prices.length];\\n        f[0][0] = 0;\\n        \\n        /*To avoid the memory limit exceeded, only two rows are used\\n        as we need only k-1 and k transaction rows, everything else \\n        can be done away with */\\n        \\n        for(int k=1; k<=transactions; k++){\\n            int tempMax =  f[0][0] - prices[0];\\n            for(int i=1; i<prices.length; i++){\\n                f[1][i] = Math.max(prices[i] + tempMax, f[1][i-1]);\\n                tempMax = Math.max(tempMax, f[0][i] - prices[i]);\\n                f[0][i] = f[1][i];\\n            }\\n        }\\n        \\n        return f[0][prices.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168931,
                "title": "my-7-lines-python-dp-solution",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, k, prices):\\n        if k >= len(prices) // 2: return sum(sell - buy for sell, buy in zip(prices[1:], prices[:-1]) if sell - buy > 0)\\n        dp = [[0, -float(\"inf\")] for _ in range(k + 1)]\\n        for p in prices:\\n            for i in range(k + 1):\\n                if i and dp[i - 1][1] + p > dp[i][0]: dp[i][0] = dp[i - 1][1] + p \\n                if dp[i][0] - p > dp[i][1]: dp[i][1] = dp[i][0] - p\\n        return dp[-1][0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, k, prices):\\n        if k >= len(prices) // 2: return sum(sell - buy for sell, buy in zip(prices[1:], prices[:-1]) if sell - buy > 0)\\n        dp = [[0, -float(\"inf\")] for _ in range(k + 1)]\\n        for p in prices:\\n            for i in range(k + 1):\\n                if i and dp[i - 1][1] + p > dp[i][0]: dp[i][0] = dp[i - 1][1] + p \\n                if dp[i][0] - p > dp[i][1]: dp[i][1] = dp[i][0] - p\\n        return dp[-1][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161725,
                "title": "share-the-best-solution-to-every-stock-problem",
                "content": "Hi everyone, I read the BEST solution to stock problem in \"123. Best Time to Buy and Sell Stock III\". But the solution\\'s vote is only 11. So here I give the link: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/149383/Easy-DP-solution-using-state-machine-O(n)-time-complexity-O(1)-space-complexity thanks @shetty4l !\\n\\nAnd here, I put the AC code for this problem, with severl modification form the code from @xxw289 to avoid MLE error.\\n```\\npublic int maxProfit(int t,int[] array) {\\n    if(t==0 || array.length==0) return 0;\\n    if(t>array.length/2) t=array.length+1;\\n    int[] stock = new int[t * 2];\\n    Arrays.fill(stock, Integer.MIN_VALUE);\\n    stock[0] = -array[0];\\n    for(int i = 1; i < array.length; ++i) {\\n      stock[0] = Math.max(stock[0], -array[i]);\\n      for (int j = 1; j < 2 * t; j += 2) {\\n        stock[j] = Math.max(stock[j], stock[j - 1] + array[i]);\\n        if (j + 1 < 2 * t) {\\n          stock[j + 1] = Math.max(stock[j + 1], stock[j] - array[i]);\\n        }\\n      }\\n    }\\n    return Math.max(0, stock[2 * t - 1]);\\n  }\\n```\\nTIme complexity: O(n)      Space complexity: O(n)\\n",
                "solutionTags": [],
                "code": "```\\npublic int maxProfit(int t,int[] array) {\\n    if(t==0 || array.length==0) return 0;\\n    if(t>array.length/2) t=array.length+1;\\n    int[] stock = new int[t * 2];\\n    Arrays.fill(stock, Integer.MIN_VALUE);\\n    stock[0] = -array[0];\\n    for(int i = 1; i < array.length; ++i) {\\n      stock[0] = Math.max(stock[0], -array[i]);\\n      for (int j = 1; j < 2 * t; j += 2) {\\n        stock[j] = Math.max(stock[j], stock[j - 1] + array[i]);\\n        if (j + 1 < 2 * t) {\\n          stock[j + 1] = Math.max(stock[j + 1], stock[j] - array[i]);\\n        }\\n      }\\n    }\\n    return Math.max(0, stock[2 * t - 1]);\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 54163,
                "title": "issue-with-recursive-solution",
                "content": "Hi, I found that my recursive solution gives correct answer to each test case, but it throws a TLE on the testcase with ```k=100```. I know it is throwing error due to limited heap space provided by the OJ. I get the correct answer when I run the program with that testcase manually. Can you guys suggest some modifications to my recursive code through which I can improve my code running time.\\n```\\npublic class Solution {\\n    int[][] mem;\\n    public int maxProfit(int k, int[] prices) {\\n        if(k>=prices.length/2){\\n            int maxProfit = 0;\\n            for(int i=1; i<prices.length; i++){\\n                if(prices[i]>prices[i-1]) \\n                      maxProfit += prices[i]-prices[i-1];\\n            }\\n            return maxProfit;\\n        }\\n        \\n        \\n        \\n        mem = new int[k+1][prices.length];\\n        for(int[] row : mem) {\\n            Arrays.fill(row,-1);\\n        }\\n        int max = findMax(prices,k,0);\\n        return max;\\n    }\\n    \\n    public int findMax(int[] prices, int k, int start)\\n    {\\n        if(k == 0)\\n            return 0;\\n        if(start >= prices.length)\\n            return 0;\\n        \\n        if(mem[k][start] != -1) {\\n            return mem[k][start];\\n        }\\n        \\n        int max = 0;\\n        int min = Integer.MAX_VALUE;\\n        int maxProfit = 0;\\n        for(int i=start; i<prices.length; i++)\\n        {\\n            min = Math.min(min, prices[i]);\\n            maxProfit = Math.max(maxProfit, prices[i] - min);\\n            int q = 0;\\n            if(maxProfit > 0)\\n                q = maxProfit + findMax(prices,k-1, i+1);\\n            max = Math.max(q,max);\\n        }\\n        \\n        mem[k][start] = max;\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```k=100```\n```\\npublic class Solution {\\n    int[][] mem;\\n    public int maxProfit(int k, int[] prices) {\\n        if(k>=prices.length/2){\\n            int maxProfit = 0;\\n            for(int i=1; i<prices.length; i++){\\n                if(prices[i]>prices[i-1]) \\n                      maxProfit += prices[i]-prices[i-1];\\n            }\\n            return maxProfit;\\n        }\\n        \\n        \\n        \\n        mem = new int[k+1][prices.length];\\n        for(int[] row : mem) {\\n            Arrays.fill(row,-1);\\n        }\\n        int max = findMax(prices,k,0);\\n        return max;\\n    }\\n    \\n    public int findMax(int[] prices, int k, int start)\\n    {\\n        if(k == 0)\\n            return 0;\\n        if(start >= prices.length)\\n            return 0;\\n        \\n        if(mem[k][start] != -1) {\\n            return mem[k][start];\\n        }\\n        \\n        int max = 0;\\n        int min = Integer.MAX_VALUE;\\n        int maxProfit = 0;\\n        for(int i=start; i<prices.length; i++)\\n        {\\n            min = Math.min(min, prices[i]);\\n            maxProfit = Math.max(maxProfit, prices[i] - min);\\n            int q = 0;\\n            if(maxProfit > 0)\\n                q = maxProfit + findMax(prices,k-1, i+1);\\n            max = Math.max(q,max);\\n        }\\n        \\n        mem[k][start] = max;\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54212,
                "title": "my-8ms-dp-solution-with-data-preprocessing",
                "content": "The test time is similar to other solutions reported. But it has significant advantage when prices size becomes large. The basic idea is to merge daily profit array such as \"+ - - - + - + +\" into array of pattern \"+ - + - + ...\" and do normal DP.\\n\\n    class Solution {\\n    public:\\n        // Merge transactions.\\n        int maxProfit(int k, vector<int>& prices) {\\n            if(k == 0 || prices.size() < 2) return 0;\\n            \\n            // The values in profits should be: + - + -...\\n            vector<int> profits{0};\\n            \\n            for(int i = 1; i < prices.size(); ++i) {\\n                int diff = prices[i] - prices[i-1];\\n                if(diff < 0 && profits.front() == 0) continue;\\n                if(diff * profits.back() >= 0) {\\n                    profits.back() += diff;\\n                } else {\\n                    profits.push_back(diff);\\n                }\\n            }\\n            \\n            // Number of positive blocks.\\n            int pos = ceil(profits.size()/2.0);\\n            if(k >= pos) {\\n                int sum = 0;\\n                for(int i = 0; i < profits.size(); ++i) sum += profits[i] >= 0 ? profits[i] : 0;\\n                return sum;\\n            } else {\\n    \\t\\t\\tvector<int> global(k, 0);\\n                vector<int> local(k, 0);\\n    \\t\\t\\tfor (int i = 0; i < pos; ++i) {\\n    \\t\\t\\t\\tfor (int j = 0, last = 0; j <= i && j < k; ++j) {\\n                        int tmp = global[j];\\n                        local[j] = max(last+profits[2*i], i == 0 ? 0 : (local[j] + profits[2 * i] + profits[2 * i - 1]));\\n                        global[j] = max(local[j], global[j]);\\n                        last = tmp;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t\\treturn global.back();\\n            }\\n            \\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        // Merge transactions.\\n        int maxProfit(int k, vector<int>& prices) {\\n            if(k == 0 || prices.size() < 2) return 0;\\n            \\n            // The values in profits should be: + - + -...\\n            vector<int> profits{0}",
                "codeTag": "Java"
            },
            {
                "id": 3809714,
                "title": "0-k-solution-with-other-solution-dp",
                "content": "# **PLS UPVOTE IF YOU LIKE MY SOLUTION AND FEEL FREE TO COMMENT YOUR PROBLEM IN COMMENTS**\\n\\n# SPACE OPTIMIZED SOLUTION \\n# Approach\\nThe function solvetab takes the prices vector and an integer k (maximum allowed transactions) as input.\\n\\nInitialize two 1D vectors curr and next, each with a size of 2*k+1. These vectors will be used to store the maximum profit for different scenarios. curr[op] represents the maximum profit at the current day with op indicating the number of operations (buy and sell transactions) performed so far.\\n\\nThe outer loop runs from n-1 to 0, iterating backward through the prices array. This helps us build the curr and next vectors from the last day to the first day.\\n\\nWithin the outer loop, there is a nested loop that runs from 0 to 2*k-1. This loop handles all possible scenarios for the number of operations performed at each day (both buying and selling).\\n\\nFor each index (current day) and op (number of operations), calculate the maximum profit for the current day and operation scenario:\\n\\nIf op is even, it means a buying operation is allowed, so we consider two options:\\na. Perform the buying operation on the current day and move to the next operation (op+1), considering the profit obtained by subtracting the stock price from the result of the next day\\'s calculation with the same number of allowed transactions (next[op+1]).\\nb. Skip the buying operation and move to the next operation (op), considering the profit obtained from the next day\\'s calculation with the same number of allowed transactions (next[op]).\\nIf op is odd, it means a selling operation is allowed, so we consider two options:\\na. Perform the selling operation on the current day and move to the next operation (op+1), considering the profit obtained by adding the stock price to the result of the next day\\'s calculation with the same number of allowed transactions (next[op+1]).\\nb. Skip the selling operation and move to the next operation (op), considering the profit obtained from the next day\\'s calculation with the same number of allowed transactions (next[op]).\\nUpdate the curr[op] value with the calculated maximum profit for the current index and op.\\n\\nAfter filling the curr vector for the current day, copy its values to the next vector. This is done to update the values for the next day in the next iteration.\\n\\nOnce the loops are completed, the answer will be stored in next[0], which represents the maximum profit achievable with at most k transactions on the given array of stock prices.\\n\\nReturn next[0] as the maximum profit.\\n```\\nclass Solution {\\npublic:\\n\\nint solvetab(vector<int>& prices,int k )\\n{\\n    int n = prices.size();\\n    vector<int>curr(2*k+1);\\n    vector<int>next(2*k+1);\\n\\n\\n    for(int index=n-1;index>=0;index--)\\n    {\\n        for(int op=0;op<2*k;op++)\\n        {\\n            int profit=0;\\n            if(op%2==0)\\n            {\\n                profit=max(-prices[index]+next[op+1] , 0 + next[op]); \\n            }\\n            else\\n            {\\n                profit=max(prices[index]+ next[op+1], 0 + next[op]); \\n            }\\n            curr[op]=profit;\\n            }\\n            next=curr;\\n        \\n\\n    }\\n    return next[0];\\n}\\n\\n    int maxProfit(int k, vector<int>& prices) {\\n        return solvetab(prices,k);\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity:0(N*K)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# TOP DOWN APPROACH\\n# Approach\\nThe function solve is a recursive function that takes the prices vector, the maximum allowed transactions k, the current index representing the current day, the number of operations (op) performed so far, and the memoization table dp as inputs.\\n\\nThe function handles two base cases:\\n\\nIf the current index goes beyond the size of the prices array or the number of operations op exceeds 2 * k, we return 0, as we cannot perform any more transactions.\\nIf the result for the current index and op is already present in the dp table, we return the precomputed value to avoid redundant calculations.\\nWithin the function, we calculate the maximum profit for the current day and operation scenario.\\n\\nIf op is even, it means a buying operation is allowed, so we consider two options:\\na. Perform the buying operation on the current day and move to the next day with the next operation (op+1), considering the profit obtained by subtracting the stock price from the result of the next day\\'s calculation with the same number of allowed transactions.\\nb. Skip the buying operation and move to the next day with the same operation (op), considering the profit obtained from the next day\\'s calculation with the same number of allowed transactions.\\nIf op is odd, it means a selling operation is allowed, so we consider two options:\\na. Perform the selling operation on the current day and move to the next day with the next operation (op+1), considering the profit obtained by adding the stock price to the result of the next day\\'s calculation with the same number of allowed transactions.\\nb. Skip the selling operation and move to the next day with the same operation (op), considering the profit obtained from the next day\\'s calculation with the same number of allowed transactions.\\nUpdate the dp table with the calculated maximum profit for the current index and op.\\n\\nReturn the calculated maximum profit for the current index and op.\\n\\nIn the maxProfit function, we initialize the memoization table dp of size n+1 (where n is the size of the prices vector) and 2 * k + 1 (to account for 2 * k possible operations, both buying and selling).\\n\\nCall the solve function with the starting parameters: prices, k, index=0, op=0, and the dp table.\\n\\nReturn the result obtained from the solve function as the maximum profit that can be obtained with at most k transactions on the given array of stock prices.\\n\\n\\n\\n# Complexity\\n- Time complexity:0(N*K)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N*K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint solve(vector<int>& prices,int k ,int index,int op,vector<vector<int>>&dp)\\n{\\n    if(index>=prices.size())\\n    return 0;\\n\\n    if(op==k*2)\\n    return 0;\\n    \\n    int profit=0;\\n    \\n    if(dp[index][op]!=-1)\\n    return dp[index][op];\\n    \\n    if(op%2==0)\\n    // BUY ALLOWED\\n    {\\n        profit = max(-prices[index] + solve(prices, k, index + 1,op+1,dp ), 0 + solve(prices, k, index + 1, op,dp));\\n    }\\n    else\\n    {\\n        profit = max(prices[index] + solve(prices, k, index + 1,op+1,dp ), 0 + solve(prices, k, index + 1, op,dp));\\n\\n    }\\n    return dp[index][op]=profit;\\n}\\n\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n= prices.size();\\n\\n        vector<vector<int>>dp(n+1,vector<int>(2*k,-1));\\n        return solve(prices,k,0,0,dp);\\n    }\\n};\\n```\\n# BOTTOM UP APPROACH\\n# Approach\\nThe function solvetab takes the prices vector and an integer k as input, representing the maximum number of allowed transactions.\\n\\nInitialize two 2D vectors curr and next, each with dimensions [2][k+1]. These vectors will be used to store the maximum profit for different scenarios. curr[buy][limit] represents the maximum profit at the current day with buy indicating whether the stock is bought (0 for not bought, 1 for bought), and limit representing the remaining transactions allowed (ranging from 0 to k).\\n\\nThe outer loop runs from n-1 to 0, iterating backward through the prices array. This helps us build the curr and next vectors from the last day to the first day.\\n\\nWithin the outer loop, there are two nested loops for buy and limit, each ranging from 0 to 1 and 1 to k, respectively. These loops handle all possible scenarios for buying or not buying the stock on each day and the number of remaining transactions.\\n\\nFor each combination of index, buy, and limit, calculate the maximum profit:\\n\\nIf buy is 1 (meaning the stock is bought on the current day), the profit is the maximum of two possibilities:\\na. The profit obtained by buying the stock on the current day and adding the profit from the next day with the same number of remaining transactions: -prices[index] + next[0][limit].\\nb. The profit obtained by not buying the stock on the current day and adding the profit from the next day with the same number of remaining transactions: 0 + next[1][limit].\\nIf buy is 0 (meaning the stock is not bought on the current day), the profit is the maximum of two possibilities:\\na. The profit obtained by not buying the stock on the current day and adding the profit from the next day with limit+1 transactions remaining: prices[index] + next[1][limit - 1].\\nb. The profit obtained by not buying the stock on the current day and adding the profit from the next day with the same number of remaining transactions: 0 + next[0][limit].\\nUpdate the curr[buy][limit] value with the calculated maximum profit.\\n\\nAfter filling the curr vector for the current day, copy its values to the next vector. This is done to update the values for the next day in the next iteration.\\n\\nOnce the loops are completed, the answer will be stored in next[1][k], where 1 indicates the stock is bought, and k represents the remaining transactions allowed.\\n\\nReturn next[1][k] as the maximum profit achievable with at most k transactions on the given array of stock prices.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N*K)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint solvetab(vector<int>& prices,int k )\\n{\\n    int n = prices.size();\\n    vector<vector<int>>curr(2,vector<int>(k+1,0));\\n    vector<vector<int>>next(2,vector<int>(k+1,0));\\n\\n\\n    for(int index=n-1;index>=0;index--)\\n    {\\n        for(int buy=0;buy<=1;buy++)\\n        {\\n            for(int limit=1;limit<=k;limit++)\\n            {\\n                int profit=0;\\n            if(buy==1)\\n            {\\n                profit=max(-prices[index]+next[0][limit] , 0 + next[1][limit]); \\n            }\\n            else\\n            {\\n                profit=max(prices[index]+ next[1][limit-1], 0 + next[0][limit]); \\n            }\\n            curr[buy][limit]=profit;\\n            }\\n            next=curr;\\n        }\\n\\n    }\\n    return next[1][k];\\n}\\n\\n    int maxProfit(int k, vector<int>& prices) {\\n        return solvetab(prices,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint solvetab(vector<int>& prices,int k )\\n{\\n    int n = prices.size();\\n    vector<int>curr(2*k+1);\\n    vector<int>next(2*k+1);\\n\\n\\n    for(int index=n-1;index>=0;index--)\\n    {\\n        for(int op=0;op<2*k;op++)\\n        {\\n            int profit=0;\\n            if(op%2==0)\\n            {\\n                profit=max(-prices[index]+next[op+1] , 0 + next[op]); \\n            }\\n            else\\n            {\\n                profit=max(prices[index]+ next[op+1], 0 + next[op]); \\n            }\\n            curr[op]=profit;\\n            }\\n            next=curr;\\n        \\n\\n    }\\n    return next[0];\\n}\\n\\n    int maxProfit(int k, vector<int>& prices) {\\n        return solvetab(prices,k);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\nint solve(vector<int>& prices,int k ,int index,int op,vector<vector<int>>&dp)\\n{\\n    if(index>=prices.size())\\n    return 0;\\n\\n    if(op==k*2)\\n    return 0;\\n    \\n    int profit=0;\\n    \\n    if(dp[index][op]!=-1)\\n    return dp[index][op];\\n    \\n    if(op%2==0)\\n    // BUY ALLOWED\\n    {\\n        profit = max(-prices[index] + solve(prices, k, index + 1,op+1,dp ), 0 + solve(prices, k, index + 1, op,dp));\\n    }\\n    else\\n    {\\n        profit = max(prices[index] + solve(prices, k, index + 1,op+1,dp ), 0 + solve(prices, k, index + 1, op,dp));\\n\\n    }\\n    return dp[index][op]=profit;\\n}\\n\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n= prices.size();\\n\\n        vector<vector<int>>dp(n+1,vector<int>(2*k,-1));\\n        return solve(prices,k,0,0,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\nint solvetab(vector<int>& prices,int k )\\n{\\n    int n = prices.size();\\n    vector<vector<int>>curr(2,vector<int>(k+1,0));\\n    vector<vector<int>>next(2,vector<int>(k+1,0));\\n\\n\\n    for(int index=n-1;index>=0;index--)\\n    {\\n        for(int buy=0;buy<=1;buy++)\\n        {\\n            for(int limit=1;limit<=k;limit++)\\n            {\\n                int profit=0;\\n            if(buy==1)\\n            {\\n                profit=max(-prices[index]+next[0][limit] , 0 + next[1][limit]); \\n            }\\n            else\\n            {\\n                profit=max(prices[index]+ next[1][limit-1], 0 + next[0][limit]); \\n            }\\n            curr[buy][limit]=profit;\\n            }\\n            next=curr;\\n        }\\n\\n    }\\n    return next[1][k];\\n}\\n\\n    int maxProfit(int k, vector<int>& prices) {\\n        return solvetab(prices,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667554,
                "title": "c-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int &n,vector<int> &v,int k,vector<vector<int>> &dp){\\n        if(i>=n||k<=0)return 0;\\n        if(dp[i][k] != -1)return dp[i][k];\\n        int ans1 = solve(i+1,n,v,k,dp);\\n        int ans2 = 0;\\n        if(!(k%2)){\\n            ans2 = -v[i]+solve(i+1,n,v,k-1,dp);\\n        }else{\\n            ans2 = v[i]+solve(i+1,n,v,k-1,dp);\\n        }\\n        return dp[i][k] = max(ans1,ans2);\\n    }\\n    int maxProfit(int k, vector<int>& v) {\\n        k <<= 1;\\n        int n = v.size();\\n        vector<vector<int>> dp(n,vector<int>(k+1,-1));\\n        return solve(0,n,v,k,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int &n,vector<int> &v,int k,vector<vector<int>> &dp){\\n        if(i>=n||k<=0)return 0;\\n        if(dp[i][k] != -1)return dp[i][k];\\n        int ans1 = solve(i+1,n,v,k,dp);\\n        int ans2 = 0;\\n        if(!(k%2)){\\n            ans2 = -v[i]+solve(i+1,n,v,k-1,dp);\\n        }else{\\n            ans2 = v[i]+solve(i+1,n,v,k-1,dp);\\n        }\\n        return dp[i][k] = max(ans1,ans2);\\n    }\\n    int maxProfit(int k, vector<int>& v) {\\n        k <<= 1;\\n        int n = v.size();\\n        vector<vector<int>> dp(n,vector<int>(k+1,-1));\\n        return solve(0,n,v,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499187,
                "title": "8-approach-recursion-memoization-tabulation-space-optimization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    //Approach-1 Recursion Time Complexity: O(2^N)[Take,notTake] Space Complexity: O(N)[Auxillary Stack Space]\\n     int solve(int ind,int buy,int transaction,vector<int>&prices){\\n        int n = prices.size() , profit=0; \\n        \\n        if(ind==n || transaction==0) return 0;\\n\\n        //Buying Stock when buy = 1 \\n        if(buy){\\n            //take -> means we bought ind stock \\n            //now,we can\\'t buy untill we sell this stock. ThereFore, buy=0\\n            //notTake -> means we didn\\'t bought ind stock \\n            //now,we can buy other stock. ThereFore, buy=1\\n            int take = -prices[ind]+solve(ind+1,0,transaction,prices) ; \\n            int notTake = 0+solve(ind+1,1,transaction,prices) ;\\n            profit = max(take,notTake);\\n        }\\n        //Selling Stock when buy = 0 \\n        else if(buy==0){\\n            //take -> means we sold ind stock \\n            //now,we can buy stock. ThereFore, buy=1\\n            //notTake -> means we didn\\'t sold ind stock \\n            //now,we can\\'t buy other stock. ThereFore, buy=0\\n            //After we sold the stock one transaction is done therefore transaction-1\\n            int take = prices[ind]+solve(ind+1,1,transaction-1,prices) ; \\n            int notTake = 0+solve(ind+1,0,transaction,prices) ;\\n            profit = max(take,notTake);\\n        }\\n        return profit;\\n    }\\n    //Approach-2 Memoization Time Complexity: O(N*2*k)[buy->0 or 1 --> 2 states] [transaction->0 to k --> k states] \\n// Space Complexity:O(N*2*k) + O(N) [O(N)[Auxillary Stack Space]]\\n    int solve2(int ind,int buy,int transaction,vector<int>&prices,vector<vector<vector<int>>>&dp){\\n            int n = prices.size() , profit=0; \\n            if(ind==n || transaction==0) return 0;\\n            if(dp[ind][buy][transaction]!=-1) return dp[ind][buy][transaction];\\n\\n            if(buy){\\n                int take = -prices[ind]+solve2(ind+1,0,transaction,prices,dp);\\n                int notTake = 0+solve2(ind+1,1,transaction,prices,dp);\\n                profit=max(take,notTake);\\n            }\\n            else{\\n                //transaction successfull after we sold the stock therefore transaction-1\\n                int take = prices[ind]+solve2(ind+1,1,transaction-1,prices,dp);\\n                int notTake = 0+solve2(ind+1,0,transaction,prices,dp);\\n                profit=max(take,notTake);\\n            }\\n           return dp[ind][buy][transaction]=profit;\\n    }\\n //Approach-3 Tabulation Time Complexity: O(N*2*k)[buy->0 or 1 --> 2 states] [transaction->0 or 1 or 2 --> 3 states] \\n// Space Complexity:O(N*2*k)  \\n     int tabulation(vector<int>& prices,int k){\\n            int n = prices.size(); \\n            // Creating a 3d - dp of size [n+1][2][k+1] initialized to 0\\n            vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(2,vector<int>(k+1,0)));\\n           // BASE CASE:- if(ind==n || transaction==0) return 0; \\n           //  As dp array is intialized to 0, we have already covered the base case\\n \\n            for(int ind=n-1;ind>=0;ind--){\\n                 // buy = 0 to 1 or buy = 1 to 0 -> both correct\\n                for(int buy=0;buy<=1;buy++){\\n                //     for(int buy=1;buy>=0;buy--){\\n                // transaction = 0 to k or transaction = k to 0 -> both correct\\n                    for(int transaction=0;transaction<=k;transaction++){\\n              //     for(int transaction=k;transaction>=0;transaction--){\\n                        int profit=0;\\n                             if(buy){\\n                                     int take = -prices[ind]+dp[ind+1][0][transaction];\\n                                    int notTake = 0+dp[ind+1][1][transaction];\\n                                    profit=max(take,notTake);\\n                                 }\\n                            else{   \\n                                    //transaction successfull after we sold the stock therefore transaction-1\\n                                    int take = INT_MIN;\\n                                    if(transaction>0) take=prices[ind]+dp[ind+1][1][transaction-1];\\n                                    int notTake = 0+dp[ind+1][0][transaction];;\\n                                    profit=max(take,notTake);\\n                                 }\\n                              dp[ind][buy][transaction]=profit;\\n                    }\\n                }\\n            }\\n    return dp[0][1][k];//as Recursion Call from (0,1,k)\\n    }\\n     //Approach-4 Tabulation With Space Optimization Time Complexity: O(N*2*k)\\n      //[buy->0 or 1 --> 2 states] [transaction->0 to k --> k states]  Space Complexity:O(1)  \\n     int tabulationWithSpaceOptimization(vector<int>& prices,int k){\\n            int n = prices.size(); \\n            vector<vector<int>>ahead(2,vector<int>(k+1,0)),curr(2,vector<int>(k+1,0));\\n\\n            for(int ind=n-1;ind>=0;ind--){\\n                 for(int buy=0;buy<=1;buy++){\\n                    for(int transaction=0;transaction<=k;transaction++){\\n                        int profit=0;\\n                             if(buy){\\n                                     int take = -prices[ind]+ahead[0][transaction];\\n                                    int notTake = 0+ahead[1][transaction];\\n                                    profit=max(take,notTake);\\n                                 }\\n                            else{   \\n                                    //transaction successfull after we sold the stock therefore transaction-1\\n                                    int take = INT_MIN;\\n                                    if(transaction>0) take=prices[ind]+ahead[1][transaction-1];\\n                                    int notTake = 0+ahead[0][transaction];\\n                                    profit=max(take,notTake);\\n                                 }\\n                              curr[buy][transaction]=profit;\\n                    }\\n                }\\n                ahead=curr; //update \\n            }\\n    return ahead[1][k];//as Recursion Call from (0,1,k)\\n    }\\n    //Approach-5 Recursion Time Complexity: Exponential Space Complexity: O(N)[Auxillary Stack Space]\\n    //Using N*K Method Now \\n    int solve4(int ind,int tranNo,int k,vector<int>&prices){\\n         int n = prices.size(),profit=0;\\n          //2*k as 2 operations -> Buy and Sell for each transaction\\n        if(ind==n || tranNo==2*k) return 0;\\n\\n        //when even tranNo we buy stock\\n        if(tranNo%2==0){\\n            //as we buy we go to next transaction\\n            int take = -prices[ind]+solve4(ind+1,tranNo+1,k,prices) ; \\n            int notTake = 0+solve4(ind+1,tranNo,k,prices) ;\\n            profit = max(take,notTake);\\n        }\\n        //when odd tranNo we sell stock \\n       else  if(tranNo%2!=0) {\\n            //as we sell we go to next transaction\\n            int take = prices[ind]+solve4(ind+1,tranNo+1,k,prices) ; \\n            int notTake = 0+solve4(ind+1,tranNo,k,prices) ;\\n            profit = max(take,notTake);\\n        }\\n        return profit;\\n    }\\n //Approach-6 Memoization Time Complexity: O(N*2*k)[buy->0 or 1 --> 2 states] [transaction->0 to k --> k states] \\n// Space Complexity:O(N*2*k) + O(N) [O(N)[Auxillary Stack Space]]\\n    int solve5(int ind,int tranNo,int k,vector<int>&prices,vector<vector<int>>&dp){\\n         int n = prices.size(),profit=0;\\n         //2*k as 2 operations -> Buy and Sell for each transaction \\n        if(ind==n || tranNo==2*k) return 0;\\n        if(dp[ind][tranNo]!=-1) return dp[ind][tranNo];\\n        //when even tranNo we buy stock\\n        if(tranNo%2==0){\\n            //as we buy we go to next transaction\\n            int take = -prices[ind]+solve5(ind+1,tranNo+1,k,prices,dp) ; \\n            int notTake = 0+solve5(ind+1,tranNo,k,prices,dp) ;\\n            profit = max(take,notTake);\\n        }\\n        //when odd tranNo we sell stock \\n       else  if(tranNo%2!=0) {\\n            //as we sell we go to next transaction\\n            int take = prices[ind]+solve5(ind+1,tranNo+1,k,prices,dp) ; \\n            int notTake = 0+solve5(ind+1,tranNo,k,prices,dp) ;\\n            profit = max(take,notTake);\\n        }\\n        return dp[ind][tranNo]= profit;\\n    }\\n//Approach-7 Tabulation Time Complexity: O(N*2*k)[buy->0 or 1 --> 2 states] [transaction->0 or 1 or 2 --> 3 states] \\n// Space Complexity:O(N*2*k)  \\n     int tabulation2(vector<int>& prices,int k){\\n            int n = prices.size(); \\n            // Creating a 2d - dp of size [n+1][2*k+1] initialized to 0\\n             vector<vector<int>>dp(n+1,vector<int>(2*k+1,0));\\n            //  As dp array is intialized to 0, we have already covered the base case\\n \\n            for(int ind=n-1;ind>=0;ind--){\\n                 // as for tranNo = 2*k  we return 0 [base case]\\n                 //thus,starting tranNo from 2*k-1 to 0 \\n                    for(int tranNo=2*k-1;tranNo>=0;tranNo--){\\n                        int profit=0;\\n                          //when even tranNo we buy stock\\n                                    if(tranNo%2==0){\\n                                        //as we buy we go to next transaction\\n                                        int take = -prices[ind]+dp[ind+1][tranNo+1] ; \\n                                        int notTake = 0+dp[ind+1][tranNo] ;\\n                                        profit = max(take,notTake);\\n                                    }\\n                                    //when odd tranNo we sell stock \\n                                    else  if(tranNo%2!=0) {\\n                                        //as we sell we go to next transaction\\n                                        int take = prices[ind]+dp[ind+1][tranNo+1] ;\\n                                        int notTake = 0+dp[ind+1][tranNo] ;\\n                                        profit = max(take,notTake);\\n                                    }\\n                                    dp[ind][tranNo]= profit;\\n                }\\n            }\\n    return dp[0][0];//as Recursion Call from (0,0)\\n    }\\n//Approach-8 Tabulation With Space Optimization Time Complexity: O(N*2*k)\\n      //[buy->0 or 1 --> 2 states] [transaction->0 to k --> k states]  Space Complexity:O(2*k)\\n      int tabulationWithSpaceOptimization2(vector<int>& prices,int k){\\n            int n = prices.size(); \\n              vector<int>ahead(2*k+1,0),curr(2*k+1,0);\\n  \\n            for(int ind=n-1;ind>=0;ind--){\\n                 // as for tranNo = 2*k  we return 0 [base case]\\n                 //thus,starting tranNo from 2*k-1 to 0 \\n                    for(int tranNo=0;tranNo<=2*k-1;tranNo++){\\n                        int profit=0;\\n                          //when even tranNo we buy stock\\n                                    if(tranNo%2==0){\\n                                        //as we buy we go to next transaction\\n                                        int take = -prices[ind]+ahead[tranNo+1] ; \\n                                        int notTake = 0+ahead[tranNo] ;\\n                                        curr[tranNo] = max(take,notTake);\\n                                    }\\n                                    //when odd tranNo we sell stock \\n                                    else  if(tranNo%2!=0) {\\n                                        //as we sell we go to next transaction\\n                                        int take = prices[ind]+ahead[tranNo+1] ;;\\n                                        int notTake = 0+ahead[tranNo] ;\\n                                        curr[tranNo] = max(take,notTake);\\n                                    }\\n                 }\\n                 ahead=curr; //update\\n            }\\n    return ahead[0];//as Recursion Call from (0,0)\\n    }\\n\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        //transaction=k , but=1 (can Buy) , ind=0\\n\\n       // return solve(0,1,k,prices); //Approach-1 Recursion\\n       //dp[ind][buy][transaction]\\n     // vector<vector<vector<int>>>dp(n,vector<vector<int>>(2,vector<int>(k+1,-1)));\\n      // return solve2(0,1,k,prices,dp); //Approach-2 Memoization\\n     //  return tabulation(prices,k); //Approach-3 Tabulation \\n     //   return tabulationWithSpaceOptimization(prices,k); //Approach-4 tabulation With Space Optimization\\n\\n     //  return solve4(0,0,k,prices); //Approach-5 Recursion\\n      //dp[ind][tranNo]\\n     // vector<vector<int>>dp(n,vector<int>(2*k,-1));\\n    //   return solve5(0,0,k,prices,dp); //Approach-6 Memoization\\n   //   return tabulation2(prices,k); //Approach-7 Tabulation\\n    return tabulationWithSpaceOptimization2(prices,k); //Approach-8 tabulation With Space Optimization\\n    }\\n};\\n```\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Approach-1 Recursion Time Complexity: O(2^N)[Take,notTake] Space Complexity: O(N)[Auxillary Stack Space]\\n     int solve(int ind,int buy,int transaction,vector<int>&prices){\\n        int n = prices.size() , profit=0; \\n        \\n        if(ind==n || transaction==0) return 0;\\n\\n        //Buying Stock when buy = 1 \\n        if(buy){\\n            //take -> means we bought ind stock \\n            //now,we can\\'t buy untill we sell this stock. ThereFore, buy=0\\n            //notTake -> means we didn\\'t bought ind stock \\n            //now,we can buy other stock. ThereFore, buy=1\\n            int take = -prices[ind]+solve(ind+1,0,transaction,prices) ; \\n            int notTake = 0+solve(ind+1,1,transaction,prices) ;\\n            profit = max(take,notTake);\\n        }\\n        //Selling Stock when buy = 0 \\n        else if(buy==0){\\n            //take -> means we sold ind stock \\n            //now,we can buy stock. ThereFore, buy=1\\n            //notTake -> means we didn\\'t sold ind stock \\n            //now,we can\\'t buy other stock. ThereFore, buy=0\\n            //After we sold the stock one transaction is done therefore transaction-1\\n            int take = prices[ind]+solve(ind+1,1,transaction-1,prices) ; \\n            int notTake = 0+solve(ind+1,0,transaction,prices) ;\\n            profit = max(take,notTake);\\n        }\\n        return profit;\\n    }\\n    //Approach-2 Memoization Time Complexity: O(N*2*k)[buy->0 or 1 --> 2 states] [transaction->0 to k --> k states] \\n// Space Complexity:O(N*2*k) + O(N) [O(N)[Auxillary Stack Space]]\\n    int solve2(int ind,int buy,int transaction,vector<int>&prices,vector<vector<vector<int>>>&dp){\\n            int n = prices.size() , profit=0; \\n            if(ind==n || transaction==0) return 0;\\n            if(dp[ind][buy][transaction]!=-1) return dp[ind][buy][transaction];\\n\\n            if(buy){\\n                int take = -prices[ind]+solve2(ind+1,0,transaction,prices,dp);\\n                int notTake = 0+solve2(ind+1,1,transaction,prices,dp);\\n                profit=max(take,notTake);\\n            }\\n            else{\\n                //transaction successfull after we sold the stock therefore transaction-1\\n                int take = prices[ind]+solve2(ind+1,1,transaction-1,prices,dp);\\n                int notTake = 0+solve2(ind+1,0,transaction,prices,dp);\\n                profit=max(take,notTake);\\n            }\\n           return dp[ind][buy][transaction]=profit;\\n    }\\n //Approach-3 Tabulation Time Complexity: O(N*2*k)[buy->0 or 1 --> 2 states] [transaction->0 or 1 or 2 --> 3 states] \\n// Space Complexity:O(N*2*k)  \\n     int tabulation(vector<int>& prices,int k){\\n            int n = prices.size(); \\n            // Creating a 3d - dp of size [n+1][2][k+1] initialized to 0\\n            vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(2,vector<int>(k+1,0)));\\n           // BASE CASE:- if(ind==n || transaction==0) return 0; \\n           //  As dp array is intialized to 0, we have already covered the base case\\n \\n            for(int ind=n-1;ind>=0;ind--){\\n                 // buy = 0 to 1 or buy = 1 to 0 -> both correct\\n                for(int buy=0;buy<=1;buy++){\\n                //     for(int buy=1;buy>=0;buy--){\\n                // transaction = 0 to k or transaction = k to 0 -> both correct\\n                    for(int transaction=0;transaction<=k;transaction++){\\n              //     for(int transaction=k;transaction>=0;transaction--){\\n                        int profit=0;\\n                             if(buy){\\n                                     int take = -prices[ind]+dp[ind+1][0][transaction];\\n                                    int notTake = 0+dp[ind+1][1][transaction];\\n                                    profit=max(take,notTake);\\n                                 }\\n                            else{   \\n                                    //transaction successfull after we sold the stock therefore transaction-1\\n                                    int take = INT_MIN;\\n                                    if(transaction>0) take=prices[ind]+dp[ind+1][1][transaction-1];\\n                                    int notTake = 0+dp[ind+1][0][transaction];;\\n                                    profit=max(take,notTake);\\n                                 }\\n                              dp[ind][buy][transaction]=profit;\\n                    }\\n                }\\n            }\\n    return dp[0][1][k];//as Recursion Call from (0,1,k)\\n    }\\n     //Approach-4 Tabulation With Space Optimization Time Complexity: O(N*2*k)\\n      //[buy->0 or 1 --> 2 states] [transaction->0 to k --> k states]  Space Complexity:O(1)  \\n     int tabulationWithSpaceOptimization(vector<int>& prices,int k){\\n            int n = prices.size(); \\n            vector<vector<int>>ahead(2,vector<int>(k+1,0)),curr(2,vector<int>(k+1,0));\\n\\n            for(int ind=n-1;ind>=0;ind--){\\n                 for(int buy=0;buy<=1;buy++){\\n                    for(int transaction=0;transaction<=k;transaction++){\\n                        int profit=0;\\n                             if(buy){\\n                                     int take = -prices[ind]+ahead[0][transaction];\\n                                    int notTake = 0+ahead[1][transaction];\\n                                    profit=max(take,notTake);\\n                                 }\\n                            else{   \\n                                    //transaction successfull after we sold the stock therefore transaction-1\\n                                    int take = INT_MIN;\\n                                    if(transaction>0) take=prices[ind]+ahead[1][transaction-1];\\n                                    int notTake = 0+ahead[0][transaction];\\n                                    profit=max(take,notTake);\\n                                 }\\n                              curr[buy][transaction]=profit;\\n                    }\\n                }\\n                ahead=curr; //update \\n            }\\n    return ahead[1][k];//as Recursion Call from (0,1,k)\\n    }\\n    //Approach-5 Recursion Time Complexity: Exponential Space Complexity: O(N)[Auxillary Stack Space]\\n    //Using N*K Method Now \\n    int solve4(int ind,int tranNo,int k,vector<int>&prices){\\n         int n = prices.size(),profit=0;\\n          //2*k as 2 operations -> Buy and Sell for each transaction\\n        if(ind==n || tranNo==2*k) return 0;\\n\\n        //when even tranNo we buy stock\\n        if(tranNo%2==0){\\n            //as we buy we go to next transaction\\n            int take = -prices[ind]+solve4(ind+1,tranNo+1,k,prices) ; \\n            int notTake = 0+solve4(ind+1,tranNo,k,prices) ;\\n            profit = max(take,notTake);\\n        }\\n        //when odd tranNo we sell stock \\n       else  if(tranNo%2!=0) {\\n            //as we sell we go to next transaction\\n            int take = prices[ind]+solve4(ind+1,tranNo+1,k,prices) ; \\n            int notTake = 0+solve4(ind+1,tranNo,k,prices) ;\\n            profit = max(take,notTake);\\n        }\\n        return profit;\\n    }\\n //Approach-6 Memoization Time Complexity: O(N*2*k)[buy->0 or 1 --> 2 states] [transaction->0 to k --> k states] \\n// Space Complexity:O(N*2*k) + O(N) [O(N)[Auxillary Stack Space]]\\n    int solve5(int ind,int tranNo,int k,vector<int>&prices,vector<vector<int>>&dp){\\n         int n = prices.size(),profit=0;\\n         //2*k as 2 operations -> Buy and Sell for each transaction \\n        if(ind==n || tranNo==2*k) return 0;\\n        if(dp[ind][tranNo]!=-1) return dp[ind][tranNo];\\n        //when even tranNo we buy stock\\n        if(tranNo%2==0){\\n            //as we buy we go to next transaction\\n            int take = -prices[ind]+solve5(ind+1,tranNo+1,k,prices,dp) ; \\n            int notTake = 0+solve5(ind+1,tranNo,k,prices,dp) ;\\n            profit = max(take,notTake);\\n        }\\n        //when odd tranNo we sell stock \\n       else  if(tranNo%2!=0) {\\n            //as we sell we go to next transaction\\n            int take = prices[ind]+solve5(ind+1,tranNo+1,k,prices,dp) ; \\n            int notTake = 0+solve5(ind+1,tranNo,k,prices,dp) ;\\n            profit = max(take,notTake);\\n        }\\n        return dp[ind][tranNo]= profit;\\n    }\\n//Approach-7 Tabulation Time Complexity: O(N*2*k)[buy->0 or 1 --> 2 states] [transaction->0 or 1 or 2 --> 3 states] \\n// Space Complexity:O(N*2*k)  \\n     int tabulation2(vector<int>& prices,int k){\\n            int n = prices.size(); \\n            // Creating a 2d - dp of size [n+1][2*k+1] initialized to 0\\n             vector<vector<int>>dp(n+1,vector<int>(2*k+1,0));\\n            //  As dp array is intialized to 0, we have already covered the base case\\n \\n            for(int ind=n-1;ind>=0;ind--){\\n                 // as for tranNo = 2*k  we return 0 [base case]\\n                 //thus,starting tranNo from 2*k-1 to 0 \\n                    for(int tranNo=2*k-1;tranNo>=0;tranNo--){\\n                        int profit=0;\\n                          //when even tranNo we buy stock\\n                                    if(tranNo%2==0){\\n                                        //as we buy we go to next transaction\\n                                        int take = -prices[ind]+dp[ind+1][tranNo+1] ; \\n                                        int notTake = 0+dp[ind+1][tranNo] ;\\n                                        profit = max(take,notTake);\\n                                    }\\n                                    //when odd tranNo we sell stock \\n                                    else  if(tranNo%2!=0) {\\n                                        //as we sell we go to next transaction\\n                                        int take = prices[ind]+dp[ind+1][tranNo+1] ;\\n                                        int notTake = 0+dp[ind+1][tranNo] ;\\n                                        profit = max(take,notTake);\\n                                    }\\n                                    dp[ind][tranNo]= profit;\\n                }\\n            }\\n    return dp[0][0];//as Recursion Call from (0,0)\\n    }\\n//Approach-8 Tabulation With Space Optimization Time Complexity: O(N*2*k)\\n      //[buy->0 or 1 --> 2 states] [transaction->0 to k --> k states]  Space Complexity:O(2*k)\\n      int tabulationWithSpaceOptimization2(vector<int>& prices,int k){\\n            int n = prices.size(); \\n              vector<int>ahead(2*k+1,0),curr(2*k+1,0);\\n  \\n            for(int ind=n-1;ind>=0;ind--){\\n                 // as for tranNo = 2*k  we return 0 [base case]\\n                 //thus,starting tranNo from 2*k-1 to 0 \\n                    for(int tranNo=0;tranNo<=2*k-1;tranNo++){\\n                        int profit=0;\\n                          //when even tranNo we buy stock\\n                                    if(tranNo%2==0){\\n                                        //as we buy we go to next transaction\\n                                        int take = -prices[ind]+ahead[tranNo+1] ; \\n                                        int notTake = 0+ahead[tranNo] ;\\n                                        curr[tranNo] = max(take,notTake);\\n                                    }\\n                                    //when odd tranNo we sell stock \\n                                    else  if(tranNo%2!=0) {\\n                                        //as we sell we go to next transaction\\n                                        int take = prices[ind]+ahead[tranNo+1] ;;\\n                                        int notTake = 0+ahead[tranNo] ;\\n                                        curr[tranNo] = max(take,notTake);\\n                                    }\\n                 }\\n                 ahead=curr; //update\\n            }\\n    return ahead[0];//as Recursion Call from (0,0)\\n    }\\n\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        //transaction=k , but=1 (can Buy) , ind=0\\n\\n       // return solve(0,1,k,prices); //Approach-1 Recursion\\n       //dp[ind][buy][transaction]\\n     // vector<vector<vector<int>>>dp(n,vector<vector<int>>(2,vector<int>(k+1,-1)));\\n      // return solve2(0,1,k,prices,dp); //Approach-2 Memoization\\n     //  return tabulation(prices,k); //Approach-3 Tabulation \\n     //   return tabulationWithSpaceOptimization(prices,k); //Approach-4 tabulation With Space Optimization\\n\\n     //  return solve4(0,0,k,prices); //Approach-5 Recursion\\n      //dp[ind][tranNo]\\n     // vector<vector<int>>dp(n,vector<int>(2*k,-1));\\n    //   return solve5(0,0,k,prices,dp); //Approach-6 Memoization\\n   //   return tabulation2(prices,k); //Approach-7 Tabulation\\n    return tabulationWithSpaceOptimization2(prices,k); //Approach-8 tabulation With Space Optimization\\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276607,
                "title": "c-concise-dp-solution-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size(); // Get the number of elements in the prices vector\\n        int transc  = k; // Set the maximum number of transactions to k\\n        // Initialize a 3D vector dp to store the maximum profit for each day, for each action (buy or sell), and for each transaction count\\n        vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(2, vector<int>(k+1, 0)));\\n        \\n        // Iterate over the prices vector backwards, starting from the second-to-last day\\n        for (int i = n-1; i >= 0; i--) {\\n            // Iterate over the two possible actions: buy or sell\\n            for (int canBuy = 0; canBuy <= 1; canBuy++) {\\n                // Iterate over the possible transaction counts\\n                for (int k = 1; k <= transc; k++) {\\n                    int maxProfit = 0; // Initialize the maximum profit to 0\\n                    \\n                    // If the current action is buying, calculate the maximum profit of buying or not buying\\n                    if (canBuy) {\\n                        int buy = -prices[i] + dp[i+1][0][k]; // Calculate the profit of buying today and selling later\\n                        int notbuy = 0 + dp[i+1][1][k]; // Calculate the profit of not buying today\\n                        maxProfit = max(buy, notbuy); // Choose the action that results in the maximum profit\\n                    }\\n                    // If the current action is selling, calculate the maximum profit of selling or not selling\\n                    else {\\n                        int sell = prices[i] + dp[i+1][1][k-1]; // Calculate the profit of selling today and buying later\\n                        int notsell = 0 + dp[i+1][0][k]; // Calculate the profit of not selling today\\n                        maxProfit = max(sell, notsell); // Choose the action that results in the maximum profit\\n                    }\\n                    \\n                    dp[i][canBuy][k] = maxProfit; // Store the maximum profit in the dp vector\\n                }\\n            }\\n        }\\n        \\n        return dp[0][1][transc]; // Return the maximum profit on the first day after making k transactions\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size(); // Get the number of elements in the prices vector\\n        int transc  = k; // Set the maximum number of transactions to k\\n        // Initialize a 3D vector dp to store the maximum profit for each day, for each action (buy or sell), and for each transaction count\\n        vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(2, vector<int>(k+1, 0)));\\n        \\n        // Iterate over the prices vector backwards, starting from the second-to-last day\\n        for (int i = n-1; i >= 0; i--) {\\n            // Iterate over the two possible actions: buy or sell\\n            for (int canBuy = 0; canBuy <= 1; canBuy++) {\\n                // Iterate over the possible transaction counts\\n                for (int k = 1; k <= transc; k++) {\\n                    int maxProfit = 0; // Initialize the maximum profit to 0\\n                    \\n                    // If the current action is buying, calculate the maximum profit of buying or not buying\\n                    if (canBuy) {\\n                        int buy = -prices[i] + dp[i+1][0][k]; // Calculate the profit of buying today and selling later\\n                        int notbuy = 0 + dp[i+1][1][k]; // Calculate the profit of not buying today\\n                        maxProfit = max(buy, notbuy); // Choose the action that results in the maximum profit\\n                    }\\n                    // If the current action is selling, calculate the maximum profit of selling or not selling\\n                    else {\\n                        int sell = prices[i] + dp[i+1][1][k-1]; // Calculate the profit of selling today and buying later\\n                        int notsell = 0 + dp[i+1][0][k]; // Calculate the profit of not selling today\\n                        maxProfit = max(sell, notsell); // Choose the action that results in the maximum profit\\n                    }\\n                    \\n                    dp[i][canBuy][k] = maxProfit; // Store the maximum profit in the dp vector\\n                }\\n            }\\n        }\\n        \\n        return dp[0][1][transc]; // Return the maximum profit on the first day after making k transactions\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2559038,
                "title": "java-striver-bhaiya-2-method-recursion-to-tabulation-4ms",
                "content": "**step 1: index=0, buy=true, k=n\\n  step 2: you have two choice\\n  -----> a.  \\'BUY or NOT BUY\\'  if(buy ==true)\\n  -----> b.  \\'SELL OR NOT SELL\\'  if(buy==false)\\n  step 3: return MAX from bith choice**\\n  \\n  \\n  \\n  **1.Tabulation\\\\Space Optimization (2*K mathod)**\\n   ```\\n   public int maxProfit(int k, int[] prices) {\\n        int n=prices.length;\\n        int[][] dp = new int[n+1][2*k+1];\\n\\n        for(int index=n-1;index>=0;index--){\\n            for(int trans=1;trans<=2*k;trans++){\\n                if(trans%2==0){\\n                    dp[index][trans] = Math.max(-prices[index]+dp[index+1][trans-1],dp[index+1][trans]);\\n                }else{\\n                    dp[index][trans] = Math.max(prices[index]+dp[index+1][trans-1],dp[index+1][trans]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][2*k];\\n    }\\n```\\n**2. Recursion/memoization (2*K method)**\\n```\\n   public int maxProfit(int k, int[] prices) {\\n        return stock(prices,0,2*k);\\n    }\\n    \\n    public int stock(int[] prices,int index, int trans){\\n        if(trans==0){\\n            return 0;\\n        }\\n        if(index==prices.length) return 0;\\n        int profit=0;\\n        if(trans%2==0){\\n            profit = Math.max(-prices[index]+stock(prices,index+1,trans-1),stock(prices,index+1,trans));\\n        }else{\\n            profit = Math.max(prices[index]+stock(prices,index+1,trans-1),stock(prices,index+1,trans));\\n        }\\n        \\n        \\n        return profit;\\n    }\\n```\\n**3.Tabulation**\\n```\\n    public int maxProfit(int k, int[] prices) {\\n        int n = prices.length;\\n        int[][][] dp = new int[n+1][2][k+1];\\n        \\n        for(int index=n-1;index>=0;index--){\\n            for(int buy=0;buy<=1;buy++){\\n                for(int tran=1;tran<=k;tran++){\\n                    if(buy==0){\\n                        dp[index][buy][tran] = Math.max(-prices[index]+dp[index+1][1][tran],dp[index+1][0][tran]);\\n                    }else{\\n                        dp[index][buy][tran] = Math.max(prices[index]+dp[index+1][0][tran-1],dp[index+1][1][tran]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0][k];\\n    }\\n    \\n```\\n**4. Recursion/Memoization**\\n```\\n    public int maxProfit(int k, int[] prices) {\\n        return stock(prices,0,true,k);\\n    }\\n    \\n    public int stock(int[] prices,int index,boolean buy, int k){\\n        if(k==0){\\n            return 0;\\n        }\\n        if(index==prices.length) return 0;\\n        int profit=0;\\n        if(buy){\\n            profit = Math.max(-prices[index]+stock(prices,index+1,false,k),stock(prices,index+1,true,k));\\n        }else{\\n            profit = Math.max(prices[index]+stock(prices,index+1,true,k-1),stock(prices,index+1,false,k));\\n        }\\n         \\n        return profit;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n   public int maxProfit(int k, int[] prices) {\\n        int n=prices.length;\\n        int[][] dp = new int[n+1][2*k+1];\\n\\n        for(int index=n-1;index>=0;index--){\\n            for(int trans=1;trans<=2*k;trans++){\\n                if(trans%2==0){\\n                    dp[index][trans] = Math.max(-prices[index]+dp[index+1][trans-1],dp[index+1][trans]);\\n                }else{\\n                    dp[index][trans] = Math.max(prices[index]+dp[index+1][trans-1],dp[index+1][trans]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][2*k];\\n    }\\n```\n```\\n   public int maxProfit(int k, int[] prices) {\\n        return stock(prices,0,2*k);\\n    }\\n    \\n    public int stock(int[] prices,int index, int trans){\\n        if(trans==0){\\n            return 0;\\n        }\\n        if(index==prices.length) return 0;\\n        int profit=0;\\n        if(trans%2==0){\\n            profit = Math.max(-prices[index]+stock(prices,index+1,trans-1),stock(prices,index+1,trans));\\n        }else{\\n            profit = Math.max(prices[index]+stock(prices,index+1,trans-1),stock(prices,index+1,trans));\\n        }\\n        \\n        \\n        return profit;\\n    }\\n```\n```\\n    public int maxProfit(int k, int[] prices) {\\n        int n = prices.length;\\n        int[][][] dp = new int[n+1][2][k+1];\\n        \\n        for(int index=n-1;index>=0;index--){\\n            for(int buy=0;buy<=1;buy++){\\n                for(int tran=1;tran<=k;tran++){\\n                    if(buy==0){\\n                        dp[index][buy][tran] = Math.max(-prices[index]+dp[index+1][1][tran],dp[index+1][0][tran]);\\n                    }else{\\n                        dp[index][buy][tran] = Math.max(prices[index]+dp[index+1][0][tran-1],dp[index+1][1][tran]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0][k];\\n    }\\n    \\n```\n```\\n    public int maxProfit(int k, int[] prices) {\\n        return stock(prices,0,true,k);\\n    }\\n    \\n    public int stock(int[] prices,int index,boolean buy, int k){\\n        if(k==0){\\n            return 0;\\n        }\\n        if(index==prices.length) return 0;\\n        int profit=0;\\n        if(buy){\\n            profit = Math.max(-prices[index]+stock(prices,index+1,false,k),stock(prices,index+1,true,k));\\n        }else{\\n            profit = Math.max(prices[index]+stock(prices,index+1,true,k-1),stock(prices,index+1,false,k));\\n        }\\n         \\n        return profit;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2558166,
                "title": "short-python-solution-based-on-fsm-state-machine-t-o-nk-s-o-k",
                "content": "In this solution, `2*k + 1` states are used.\\n- A: States 0, 2, 4, 6, ... represent `ready to buy`\\n- B: States 1, 3, 5, 7, ... represent `already bought (going to sell)`\\n\\nThe FSM is like:\\n```\\n[0] --buy--> [1] --sell--> [2] --buy--> [3] --sell--> ....  [2*k] --sell--> [2*k +1]\\n```\\n\\nEach state keeps the maximum value.\\n\\n1. Transfer from A->B at price P: `max(B, A-P)`\\n2. Transfer from B-> A at price P: `max(A, B+P)`\\n\\nI merge above transition as `max(states[i+1], states[i]+p*(1 if A else -1))`.\\nAs the initial value, we need to set B to `-prices[0]` to ensure that we could get `0` after first transaction (since 2. `max(0, -prices[0] + prices[0]) = 0` ).\\n\\nNoted that we need another list to save the new store values.\\n```\\nSpace = O(k)\\nTime = O(Nk), N is the length of prices\\n```\\n\\n```python\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        if k == 0 or len(prices) == 0: return 0\\n        states, new_states = [0, -prices[0]] * k + [0], [0] * (2 * k+1)\\n        for p in prices:\\n            for i in range(2*k): new_states[i+1] = max(states[i+1], states[i]+p * (i%2 * 2-1))\\n            states, new_states = new_states,states\\n        return states[-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n[0] --buy--> [1] --sell--> [2] --buy--> [3] --sell--> ....  [2*k] --sell--> [2*k +1]\\n```\n```\\nSpace = O(k)\\nTime = O(Nk), N is the length of prices\\n```\n```python\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        if k == 0 or len(prices) == 0: return 0\\n        states, new_states = [0, -prices[0]] * k + [0], [0] * (2 * k+1)\\n        for p in prices:\\n            for i in range(2*k): new_states[i+1] = max(states[i+1], states[i]+p * (i%2 * 2-1))\\n            states, new_states = new_states,states\\n        return states[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2556065,
                "title": "javascript-recursive-dp-136-ms",
                "content": "```\\n/**\\n * @param {number} k\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(k, prices) {\\n    const profit = Array.from(Array(prices.length), () => new Array(2*k+1));\\n    const dp = (i, tno, p) => {\\n        if(i == p.length || tno == 0){  \\n            return 0; \\n        }\\n        if(profit[i][tno] != undefined){ \\n            return profit[ i][tno];\\n        }\\n        if(tno%2 == 0){\\n            return profit[i][tno] = Math.max(-p[i]+dp(i+1, tno-1, p), dp(i+1, tno, p));\\n        }\\n        return profit[i][tno] = Math.max(p[i]+dp(i+1, tno-1, p), dp(i+1, tno, p));\\n    }\\n\\n    return dp(0, 2*k, prices);\\n};\\n```\\n\\n```\\nRuntime: 136 ms, faster than 44.92% of JavaScript online submissions for Best Time to Buy and Sell Stock IV.\\nMemory Usage: 44.3 MB, less than 60.43% of JavaScript online submissions for Best Time to Buy and Sell Stock IV.\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number} k\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(k, prices) {\\n    const profit = Array.from(Array(prices.length), () => new Array(2*k+1));\\n    const dp = (i, tno, p) => {\\n        if(i == p.length || tno == 0){  \\n            return 0; \\n        }\\n        if(profit[i][tno] != undefined){ \\n            return profit[ i][tno];\\n        }\\n        if(tno%2 == 0){\\n            return profit[i][tno] = Math.max(-p[i]+dp(i+1, tno-1, p), dp(i+1, tno, p));\\n        }\\n        return profit[i][tno] = Math.max(p[i]+dp(i+1, tno-1, p), dp(i+1, tno, p));\\n    }\\n\\n    return dp(0, 2*k, prices);\\n};\\n```\n```\\nRuntime: 136 ms, faster than 44.92% of JavaScript online submissions for Best Time to Buy and Sell Stock IV.\\nMemory Usage: 44.3 MB, less than 60.43% of JavaScript online submissions for Best Time to Buy and Sell Stock IV.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2555761,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * K)***\\n\\n* ***Space Complexity :- O(N * K)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // if state == true => we have to buy the stock\\n    \\n    // if state == false => we have to sell the stock\\n    \\n    // initially state will be true, b/c first we have to buy the stock \\n    \\n    // declare a dp\\n    \\n    int dp[1005][105][2];\\n    \\n    int dfs(vector<int>& prices, int i, int n, int k, bool state)\\n    {\\n        // base case\\n        \\n        // if there is no. transactions remaining\\n        \\n        if(k < 0)\\n            return 0;\\n        \\n        // if there is no. element remaining\\n        \\n        if(i == n)\\n        {\\n            return 0;\\n        }\\n        \\n        // if already calculated\\n      \\n        if(dp[i][k][state] != -1)\\n            return dp[i][k][state];\\n        \\n        int maxi = INT_MIN;\\n        \\n        // we have two option either include the curr_element or exclude\\n        \\n        // inclusion part (either we buying or selling depends on state)\\n        \\n        if(state)\\n        {\\n            maxi = max(maxi, - prices[i] + dfs(prices, i + 1, n, k - 1, !state));\\n        }\\n        else\\n        {\\n            maxi = max(maxi, prices[i] + dfs(prices, i + 1, n, k, !state));\\n        }\\n        \\n        // exclusion part\\n        \\n        maxi = max(maxi, dfs(prices, i + 1, n, k, state));\\n        \\n        // store the res then return \\n        \\n        return dp[i][k][state] = maxi;\\n    }\\n    \\n    int maxProfit(int k, vector<int>& prices) {\\n        \\n        int n = prices.size();\\n        \\n        // initialize dp with -1\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        // call dfs\\n        \\n        return dfs(prices, 0, n, k, true);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // if state == true => we have to buy the stock\\n    \\n    // if state == false => we have to sell the stock\\n    \\n    // initially state will be true, b/c first we have to buy the stock \\n    \\n    // declare a dp\\n    \\n    int dp[1005][105][2];\\n    \\n    int dfs(vector<int>& prices, int i, int n, int k, bool state)\\n    {\\n        // base case\\n        \\n        // if there is no. transactions remaining\\n        \\n        if(k < 0)\\n            return 0;\\n        \\n        // if there is no. element remaining\\n        \\n        if(i == n)\\n        {\\n            return 0;\\n        }\\n        \\n        // if already calculated\\n      \\n        if(dp[i][k][state] != -1)\\n            return dp[i][k][state];\\n        \\n        int maxi = INT_MIN;\\n        \\n        // we have two option either include the curr_element or exclude\\n        \\n        // inclusion part (either we buying or selling depends on state)\\n        \\n        if(state)\\n        {\\n            maxi = max(maxi, - prices[i] + dfs(prices, i + 1, n, k - 1, !state));\\n        }\\n        else\\n        {\\n            maxi = max(maxi, prices[i] + dfs(prices, i + 1, n, k, !state));\\n        }\\n        \\n        // exclusion part\\n        \\n        maxi = max(maxi, dfs(prices, i + 1, n, k, state));\\n        \\n        // store the res then return \\n        \\n        return dp[i][k][state] = maxi;\\n    }\\n    \\n    int maxProfit(int k, vector<int>& prices) {\\n        \\n        int n = prices.size();\\n        \\n        // initialize dp with -1\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        // call dfs\\n        \\n        return dfs(prices, 0, n, k, true);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555606,
                "title": "daily-leetcoding-challenge-september-day-10",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Merging\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2277708,
                "title": "best-solution-using-state-machine",
                "content": "This question is the generalization of Best Time to buy and sell stock III.\\nYou can refer my solution for better understanding.\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/2277045/State-Machine-Solution-with-diagram\\n\\n![image](https://assets.leetcode.com/users/images/839c7995-f9fa-415f-a6ba-3c342796b392_1657727721.9231765.png)\\n\\nSo for k transactions, number of states required is 2k+1\\nIf a state is even we have to take decision to buy or to do nothing\\nIf a state is odd we have to take decision to sell or to do nothing.\\n\\nThe following is a very optimized code with O(k) space and O(nk) time complexity:\\n```\\n int maxProfit(int k, vector<int>& prices) {\\n        \\n        // k transaction means 2*k+1 states;\\n        int n=prices.size();\\n        int ns=2*k+1;\\n        if(k==0 or n==0) return 0;\\n        \\n        vector<int> states(ns,0);\\n        vector<int> last_state(ns,0);\\n        for(int i=0;i<ns;i++)\\n        {\\n            if(i%2)last_state[i]=-prices[0];\\n        }\\n     \\n        for(int i=1;i<n;i++)\\n        {\\n           for(int j=1;j<ns;j++)\\n           {\\n               if(j%2)\\n               {\\n                   states[j]=max(last_state[j],last_state[j-1]-prices[i]);\\n                   \\n               }\\n               else{\\n                    states[j]=max(last_state[j],last_state[j-1]+prices[i]);\\n               }\\n           }\\n            for(int j=0;j<ns;j++)\\n            {\\n                last_state[j]=states[j];\\n            }\\n        }\\n\\t\\tint res=INT_MIN;\\n        for(int i=0;i<ns;i++)\\n            res=max(res,states[i]);\\n        \\n        return res;\\n```\\n**Note: Please refer to my solution of Best time to buy and sell stock III for better understanding.**\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n int maxProfit(int k, vector<int>& prices) {\\n        \\n        // k transaction means 2*k+1 states;\\n        int n=prices.size();\\n        int ns=2*k+1;\\n        if(k==0 or n==0) return 0;\\n        \\n        vector<int> states(ns,0);\\n        vector<int> last_state(ns,0);\\n        for(int i=0;i<ns;i++)\\n        {\\n            if(i%2)last_state[i]=-prices[0];\\n        }\\n     \\n        for(int i=1;i<n;i++)\\n        {\\n           for(int j=1;j<ns;j++)\\n           {\\n               if(j%2)\\n               {\\n                   states[j]=max(last_state[j],last_state[j-1]-prices[i]);\\n                   \\n               }\\n               else{\\n                    states[j]=max(last_state[j],last_state[j-1]+prices[i]);\\n               }\\n           }\\n            for(int j=0;j<ns;j++)\\n            {\\n                last_state[j]=states[j];\\n            }\\n        }\\n\\t\\tint res=INT_MIN;\\n        for(int i=0;i<ns;i++)\\n            res=max(res,states[i]);\\n        \\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2244914,
                "title": "c-tabulation-space-optimized-dp-explanation",
                "content": "Explanation : We will be starting from index 0. We will be using 3 parameters to keep track of every state(index, buy, k). Here buy means - do we currently have any stock in hand. \\nAt every index we will have 2 choices i.e either buy it or dont buy it and this is done by { ***if(buy==0) profit = max(-prices[ind] + solve(ind+1,prices,1,k,N),solve(ind+1,prices,0,k,N));*** }. If we buy current stock we will change buy variable to 1 else it remains 0. We will take max of both the choices.\\n\\nNow if we have bought any stock before, we have to sell it before buying new stock. Here also we have to choices i,e either sell now or sell later and this is done by { ***else profit = max(prices[ind] + solve(ind+1,prices,0,k-1,N),solve(ind+1,prices,1,k,N));*** }. After selling it we will change the buy option to 0(which means we can buy again) and also decrease k by 1..if we dont sell then we move to next index keeping buy and k value as it is. we will take max of both the choices.\\n\\n\\n\\n\\n**RECURSION**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint solve(int ind,vector<int> &prices,int buy,int k,int N){\\n\\t\\t\\tif(ind==N) return 0;\\n\\t\\t\\tif(k==0) return 0;\\n\\t\\t\\t\\n\\t\\t\\tint profit = 0;\\n\\t\\t\\tif(buy==0) profit = max(-prices[ind] + solve(ind+1,prices,1,k,N),solve(ind+1,prices,0,k,N));\\n\\t\\t\\telse profit = max(prices[ind] + solve(ind+1,prices,0,k-1,N),solve(ind+1,prices,1,k,N));\\n\\t\\t\\t\\n\\t\\t\\treturn profit;\\n\\t\\t}\\n\\t\\tint maxProfit(int k, vector<int>& prices) {\\n\\t\\t\\tint N = prices.size();\\n\\t\\t\\treturn solve(0,prices,0,k,N);\\n\\t\\t}\\n\\t};\\n\\n\\n**TABULTAION - SPACE OPTIMIZED**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxProfit(int k, vector<int>& prices) {\\n\\t\\t\\tint N = prices.size();\\n\\t\\t\\tvector<vector<int>> ahead(2,vector<int>(k+1,0)),curr(2,vector<int>(k+1,0));\\n\\t\\t\\tfor(int ind=N-1;ind>=0;ind--){\\n\\t\\t\\t\\tfor(int buy=0;buy<=1;buy++){\\n\\t\\t\\t\\t\\tfor(int trans=0;trans<k;trans++){\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tlong profit = 0;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tif(buy==0) profit = max(-prices[ind] + ahead[1][trans] ,ahead[0][trans]);\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\telse profit = max(prices[ind] + ahead[0][trans+1] ,ahead[1][trans]);\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tcurr[buy][trans] = profit;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tahead = curr;\\n\\t\\t\\t}\\n\\t\\t\\treturn ahead[0][0];\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint solve(int ind,vector<int> &prices,int buy,int k,int N){\\n\\t\\t\\tif(ind==N) return 0;\\n\\t\\t\\tif(k==0) return 0;\\n\\t\\t\\t\\n\\t\\t\\tint profit = 0;\\n\\t\\t\\tif(buy==0) profit = max(-prices[ind] + solve(ind+1,prices,1,k,N),solve(ind+1,prices,0,k,N));\\n\\t\\t\\telse profit = max(prices[ind] + solve(ind+1,prices,0,k-1,N),solve(ind+1,prices,1,k,N));\\n\\t\\t\\t\\n\\t\\t\\treturn profit;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1987196,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n***Java***\\n```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        int n = prices.length;\\n        int[] sell = new int[k+1], buy = new int[k+1];\\n        for(int i = 0; i < k+1; i++){\\n            sell[i] = 0;\\n            buy[i] = Integer.MIN_VALUE;\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = k; j > 0; j--){\\n                sell[j] = Math.max(sell[j], prices[i] + buy[j]);\\n                buy[j] = Math.max(buy[j], sell[j-1] - prices[i]);\\n            }\\n        }\\n        return sell[k];\\n    }\\n}\\n```\\n\\n***JavaScript***\\n```\\nvar maxProfit = function(k, prices) {\\n    if(prices.length == 0) return 0;\\n    \\n    // When k becomes so much larger than the number of prices we can make transactions whenever.\\n    if(k > (prices.length / 2) ){\\n        let profit = 0;\\n        for(let i = 1; i < prices.length; i++){\\n            if(prices[i] > prices[i - 1]){\\n                profit += prices[i] - prices[i - 1];\\n            }\\n        }\\n        return profit;\\n    }\\n    else{\\n        let dp = new Array(prices.length).fill(0);\\n        let size = prices.length;\\n        for(let t = 1; t <= k; t++){\\n            let min = prices[0];\\n            let max = 0;\\n            for(let i = 0; i < size; i++){\\n                min = Math.min(min, prices[i] - dp[i]);\\n                max = Math.max(max, prices[i] - min);\\n                dp[i] = max\\n            }\\n        }\\n        return dp.pop();   \\n    }\\n};\\n```\\n\\n***C++***\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n\\n        // Step 1: Find out all profit opportunities            \\n        vector<int> profits;\\n        stack<pair<int, int>> vps; // valley-peak pairs\\n        \\n        int v;\\n        int p = -1;\\n        for (;;) {\\n            // find next valley-peak pair\\n            for (v = p+1; (v+1 < prices.size()) && (prices[v] >= prices[v+1]); ++v);\\n            for (p = v  ; (p+1 < prices.size()) && (prices[p] <= prices[p+1]); ++p);\\n            \\n            if (v == p) { // v==p means that both v and p reach the end of the array\\n                break;\\n            }\\n            \\n            // Consider two transactions (v1, p1) (back of the stack) and (v2, p2) (the new-found).\\n            // If prices[v1] >= prices[v2], \\n            // it is meaningless to combine the two transactions.\\n            // Save of profit of (v1, p1), and pop it out of the record.\\n            while ((!vps.empty()) && (prices[v] <= prices[vps.top().first])) {\\n                profits.push_back(prices[vps.top().second] - prices[vps.top().first]);\\n                vps.pop();\\n            }\\n            \\n            // If prices[v1]<prices[v2] and prices[p1]<prices[p2], \\n            // then it is meaningful to combine the two transactions\\n            // update (v1, p1) to (v1, p2), and save the profit of (v2, p1)\\n            while ((!vps.empty()) && (prices[p] >= prices[vps.top().second])) {\\n                profits.push_back(prices[vps.top().second] - prices[v]);\\n                v = vps.top().first;\\n                vps.pop();\\n            }\\n            \\n            // save the new-found valley-peak pair\\n            vps.emplace(v, p);\\n        }\\n        \\n        // save all remaining profits\\n        while (!vps.empty()) {\\n            profits.push_back(prices[vps.top().second] - prices[vps.top().first]);\\n            vps.pop();\\n        }\\n        \\n        // Step 2: Calculate the k highest profits\\n        int ret;\\n        if (profits.size() <= k) {\\n            ret = accumulate(profits.begin(), profits.end(), 0);\\n        } else {\\n            nth_element(profits.begin(), profits.end() - k, profits.end());\\n            ret = accumulate(profits.end() - k, profits.end(), 0);\\n        }\\n        return ret;\\n    }\\n};\\n```\\n\\n***Python***\\n```\\nclass Solution(object):\\n    def maxProfit(self, k, prices):\\n        n = len(prices)\\n        sell = [0 for i in range(k+1)]\\n        buy = [float(\\'-inf\\') for i in range(k+1)]\\n        for i in range(n):\\n            for j in range(k, 0, -1):\\n                sell[j] = max(sell[j], prices[i] + buy[j])\\n                buy[j] = max(buy[j], sell[j-1] - prices[i])\\n        return sell[k]\\n```\\n\\n***Kotlin***\\n```\\nclass Solution {\\n    fun maxProfit(K: Int, prices: IntArray): Int {\\n        val totalDays = prices.size\\n        \\n        // lc0122\\n        if(K >= totalDays){\\n            var maxProfit = 0\\n            for(day in 1 until totalDays){\\n                if(prices[day - 1] < prices[day]){\\n                    maxProfit += prices[day] - prices[day - 1]\\n                }\\n            }\\n            \\n            return maxProfit\\n        }\\n        \\n        val dp = Array(K + 1){ IntArray(totalDays) { 0 }}\\n        for(k in 1..K){\\n            var localMax = dp[k - 1][0] - prices[0];\\n            \\n            for(day in 1 until totalDays){\\n                dp[k][day] = maxOf(dp[k][day - 1], prices[day] + localMax)\\n                localMax = maxOf(localMax, dp[k - 1][day] - prices[day])\\n            }\\n        }\\n        \\n        return dp[K][totalDays - 1]\\n    }\\n}\\n\\n```\\n\\n***Swift***\\n```\\nclass Solution {\\n    func maxProfit(_ k: Int, _ prices: [Int]) -> Int {\\n        guard k > 0 && prices.count > 1 else { return 0 }\\n        guard k >= prices.count/2 else {\\n            var low = [Int](repeating: prices[0], count: k)\\n            var res = [Int](repeating: 0, count: k)\\n            for i in prices.indices {\\n                for s in 0..<k {\\n                    let mj = low[s], pn = prices[i]\\n                    low[s] = min(mj, s == 0 ? pn : pn - res[s-1])\\n                    res[s] = max(res[s], pn - mj)\\n                }\\n            }\\n            return res[k - 1]\\n        }\\n        var res = 0\\n        for i in 1..<prices.count where prices[i] > prices[i-1] {\\n            res += (prices[i] - prices[i-1])\\n        }\\n        return res\\n    }\\n}\\n```\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        int n = prices.length;\\n        int[] sell = new int[k+1], buy = new int[k+1];\\n        for(int i = 0; i < k+1; i++){\\n            sell[i] = 0;\\n            buy[i] = Integer.MIN_VALUE;\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = k; j > 0; j--){\\n                sell[j] = Math.max(sell[j], prices[i] + buy[j]);\\n                buy[j] = Math.max(buy[j], sell[j-1] - prices[i]);\\n            }\\n        }\\n        return sell[k];\\n    }\\n}\\n```\n```\\nvar maxProfit = function(k, prices) {\\n    if(prices.length == 0) return 0;\\n    \\n    // When k becomes so much larger than the number of prices we can make transactions whenever.\\n    if(k > (prices.length / 2) ){\\n        let profit = 0;\\n        for(let i = 1; i < prices.length; i++){\\n            if(prices[i] > prices[i - 1]){\\n                profit += prices[i] - prices[i - 1];\\n            }\\n        }\\n        return profit;\\n    }\\n    else{\\n        let dp = new Array(prices.length).fill(0);\\n        let size = prices.length;\\n        for(let t = 1; t <= k; t++){\\n            let min = prices[0];\\n            let max = 0;\\n            for(let i = 0; i < size; i++){\\n                min = Math.min(min, prices[i] - dp[i]);\\n                max = Math.max(max, prices[i] - min);\\n                dp[i] = max\\n            }\\n        }\\n        return dp.pop();   \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n\\n        // Step 1: Find out all profit opportunities            \\n        vector<int> profits;\\n        stack<pair<int, int>> vps; // valley-peak pairs\\n        \\n        int v;\\n        int p = -1;\\n        for (;;) {\\n            // find next valley-peak pair\\n            for (v = p+1; (v+1 < prices.size()) && (prices[v] >= prices[v+1]); ++v);\\n            for (p = v  ; (p+1 < prices.size()) && (prices[p] <= prices[p+1]); ++p);\\n            \\n            if (v == p) { // v==p means that both v and p reach the end of the array\\n                break;\\n            }\\n            \\n            // Consider two transactions (v1, p1) (back of the stack) and (v2, p2) (the new-found).\\n            // If prices[v1] >= prices[v2], \\n            // it is meaningless to combine the two transactions.\\n            // Save of profit of (v1, p1), and pop it out of the record.\\n            while ((!vps.empty()) && (prices[v] <= prices[vps.top().first])) {\\n                profits.push_back(prices[vps.top().second] - prices[vps.top().first]);\\n                vps.pop();\\n            }\\n            \\n            // If prices[v1]<prices[v2] and prices[p1]<prices[p2], \\n            // then it is meaningful to combine the two transactions\\n            // update (v1, p1) to (v1, p2), and save the profit of (v2, p1)\\n            while ((!vps.empty()) && (prices[p] >= prices[vps.top().second])) {\\n                profits.push_back(prices[vps.top().second] - prices[v]);\\n                v = vps.top().first;\\n                vps.pop();\\n            }\\n            \\n            // save the new-found valley-peak pair\\n            vps.emplace(v, p);\\n        }\\n        \\n        // save all remaining profits\\n        while (!vps.empty()) {\\n            profits.push_back(prices[vps.top().second] - prices[vps.top().first]);\\n            vps.pop();\\n        }\\n        \\n        // Step 2: Calculate the k highest profits\\n        int ret;\\n        if (profits.size() <= k) {\\n            ret = accumulate(profits.begin(), profits.end(), 0);\\n        } else {\\n            nth_element(profits.begin(), profits.end() - k, profits.end());\\n            ret = accumulate(profits.end() - k, profits.end(), 0);\\n        }\\n        return ret;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def maxProfit(self, k, prices):\\n        n = len(prices)\\n        sell = [0 for i in range(k+1)]\\n        buy = [float(\\'-inf\\') for i in range(k+1)]\\n        for i in range(n):\\n            for j in range(k, 0, -1):\\n                sell[j] = max(sell[j], prices[i] + buy[j])\\n                buy[j] = max(buy[j], sell[j-1] - prices[i])\\n        return sell[k]\\n```\n```\\nclass Solution {\\n    fun maxProfit(K: Int, prices: IntArray): Int {\\n        val totalDays = prices.size\\n        \\n        // lc0122\\n        if(K >= totalDays){\\n            var maxProfit = 0\\n            for(day in 1 until totalDays){\\n                if(prices[day - 1] < prices[day]){\\n                    maxProfit += prices[day] - prices[day - 1]\\n                }\\n            }\\n            \\n            return maxProfit\\n        }\\n        \\n        val dp = Array(K + 1){ IntArray(totalDays) { 0 }}\\n        for(k in 1..K){\\n            var localMax = dp[k - 1][0] - prices[0];\\n            \\n            for(day in 1 until totalDays){\\n                dp[k][day] = maxOf(dp[k][day - 1], prices[day] + localMax)\\n                localMax = maxOf(localMax, dp[k - 1][day] - prices[day])\\n            }\\n        }\\n        \\n        return dp[K][totalDays - 1]\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    func maxProfit(_ k: Int, _ prices: [Int]) -> Int {\\n        guard k > 0 && prices.count > 1 else { return 0 }\\n        guard k >= prices.count/2 else {\\n            var low = [Int](repeating: prices[0], count: k)\\n            var res = [Int](repeating: 0, count: k)\\n            for i in prices.indices {\\n                for s in 0..<k {\\n                    let mj = low[s], pn = prices[i]\\n                    low[s] = min(mj, s == 0 ? pn : pn - res[s-1])\\n                    res[s] = max(res[s], pn - mj)\\n                }\\n            }\\n            return res[k - 1]\\n        }\\n        var res = 0\\n        for i in 1..<prices.count where prices[i] > prices[i-1] {\\n            res += (prices[i] - prices[i-1])\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775647,
                "title": "c-dp-solution-faster-than-100-runtime-0ms",
                "content": "Solution of  188. Best Time To Buy and Sell Stock IV\\n I hope this solution will help you ....\\n \\n \\n\\n```\\n `class Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n                int dp[prices.size() + 1][2*k+1];\\n```\\n        \\n        \\n        for(int day = (int) prices.size();day >= 0;day--){\\n            \\n            for(int transactionsLeft = 0;transactionsLeft <= 2*k;transactionsLeft++){\\n                \\n                int &ans = dp[day][transactionsLeft];\\n                \\n                if(day == prices.size()){\\n                    ans = 0;\\n                }else if(transactionsLeft == 0){\\n                    ans = 0;\\n                }else{\\n                    \\n                    // choice 1\\n                    // no transaction today\\n                    int ans1 = dp[day + 1][transactionsLeft];\\n                    \\n                    // choice 2\\n                    // doing the possible transaction today     \\n                    int ans2 = 0;\\n                    bool buy = (transactionsLeft % 2 == 0);\\n\\n                    if(buy == true){ // buy\\n                        ans2 = -prices[day] + dp[day + 1][transactionsLeft - 1];\\n                    }else{ // sell\\n                        ans2 = prices[day] + dp[day + 1][transactionsLeft - 1];\\n                    }\\n\\n                    ans = max(ans1, ans2);\\n\\n                }\\n                \\n            }\\n        }\\n        return dp[0][2*k];\\n    }\\n};`\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n `class Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n                int dp[prices.size() + 1][2*k+1];\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756968,
                "title": "c-well-commented-top-down-dp-solution",
                "content": "```\\npublic class Solution {\\n    private int[,,] memo;\\n    private int[] stockPrices;\\n    \\n    private int dp(int currentDay, int remainingTransactions, int isStockPurchased){\\n        //Base Case check\\n            //If no remaining transactions left or if no more days left to do any transaction\\n        if(remainingTransactions == 0 || currentDay == stockPrices.Length)\\n            return 0;\\n        \\n        //Start traversing through each state and transit until we find maximum profit made in k transactions\\n        if(memo[currentDay, remainingTransactions, isStockPurchased] == 0){\\n            //There are two posibilities here\\n                //Either do nothing and keep total profit as it is\\n                //Or purchase stock and deduct price[i] from total profit\\n            \\n            //Total profit if no stock is purchased or sold until currentDay\\n            int doNothing = dp(currentDay + 1, remainingTransactions, isStockPurchased);\\n            \\n            int doSomething;\\n            //If stock is purchased already\\n            if(isStockPurchased == 1){\\n                //Sell stock\\n                    //Move to next state with currentDay + 1, \\n                    //Reduce reminingTransactions count by 1 as we complete a transaction when we sell a stock\\n                    //Mark isStockPurchased = 0 as we sold the stock and will not have any stock purchased when moved to next state\\n                doSomething = stockPrices[currentDay] + dp(currentDay + 1, remainingTransactions-1, 0);\\n            }else{\\n                //Buy stock\\n                    //Move to next state with currentDay + 1\\n                    //Keep remaining transactions same as we will reduce this count when we sellthe stock\\n                    //Mark isStockPurchased flag to 1 as stock will be purchased when moved to next state\\n                doSomething = -stockPrices[currentDay] + dp(currentDay + 1, remainingTransactions, 1);\\n            }\\n            \\n            memo[currentDay, remainingTransactions, isStockPurchased] = Math.Max(doNothing, doSomething);\\n            \\n        }\\n        return memo[currentDay,remainingTransactions,isStockPurchased];\\n            \\n    }\\n    public int MaxProfit(int k, int[] prices) {\\n        //Top Down Implementation\\n        \\n        //State Variables for DP solution:\\n            //1. Current day i to determine price of stock prices[i]\\n            //2. Number of remaining trasnaction k\\n            //3. If stock is already purchased currently (0 = Not Purchased, 1 = Purchased)\\n        //Initialize memoization table to perform state transition\\n        this.stockPrices = prices;\\n        //Initialize memoization table with state variables\\n        this.memo = new int[prices.Length, k + 1, 2];\\n        //Start from the first day with k total transactions remaining and stock is yet not purchased\\n        return dp(0, k, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\npublic class Solution {\\n    private int[,,] memo;\\n    private int[] stockPrices;\\n    \\n    private int dp(int currentDay, int remainingTransactions, int isStockPurchased){\\n        //Base Case check\\n            //If no remaining transactions left or if no more days left to do any transaction\\n        if(remainingTransactions == 0 || currentDay == stockPrices.Length)\\n            return 0;\\n        \\n        //Start traversing through each state and transit until we find maximum profit made in k transactions\\n        if(memo[currentDay, remainingTransactions, isStockPurchased] == 0){\\n            //There are two posibilities here\\n                //Either do nothing and keep total profit as it is\\n                //Or purchase stock and deduct price[i] from total profit\\n            \\n            //Total profit if no stock is purchased or sold until currentDay\\n            int doNothing = dp(currentDay + 1, remainingTransactions, isStockPurchased);\\n            \\n            int doSomething;\\n            //If stock is purchased already\\n            if(isStockPurchased == 1){\\n                //Sell stock\\n                    //Move to next state with currentDay + 1, \\n                    //Reduce reminingTransactions count by 1 as we complete a transaction when we sell a stock\\n                    //Mark isStockPurchased = 0 as we sold the stock and will not have any stock purchased when moved to next state\\n                doSomething = stockPrices[currentDay] + dp(currentDay + 1, remainingTransactions-1, 0);\\n            }else{\\n                //Buy stock\\n                    //Move to next state with currentDay + 1\\n                    //Keep remaining transactions same as we will reduce this count when we sellthe stock\\n                    //Mark isStockPurchased flag to 1 as stock will be purchased when moved to next state\\n                doSomething = -stockPrices[currentDay] + dp(currentDay + 1, remainingTransactions, 1);\\n            }\\n            \\n            memo[currentDay, remainingTransactions, isStockPurchased] = Math.Max(doNothing, doSomething);\\n            \\n        }\\n        return memo[currentDay,remainingTransactions,isStockPurchased];\\n            \\n    }\\n    public int MaxProfit(int k, int[] prices) {\\n        //Top Down Implementation\\n        \\n        //State Variables for DP solution:\\n            //1. Current day i to determine price of stock prices[i]\\n            //2. Number of remaining trasnaction k\\n            //3. If stock is already purchased currently (0 = Not Purchased, 1 = Purchased)\\n        //Initialize memoization table to perform state transition\\n        this.stockPrices = prices;\\n        //Initialize memoization table with state variables\\n        this.memo = new int[prices.Length, k + 1, 2];\\n        //Start from the first day with k total transactions remaining and stock is yet not purchased\\n        return dp(0, k, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737023,
                "title": "c-dp-tabulation",
                "content": "\\n\\ndp[i][j] means max profit at day j with at most i transactions.\\n\\nso there are two possible situations on day j:\\n\\n1. do nothing on day j, which means at most i transactions are all done before day j, so dp[i][j] = dp[i][j-1]\\n\\n2. sell at price[j], which means before day j there will be at most i-1 transactions.\\n\\n*and because you sell the stock on day j, you must have already bought it before day j.the last time you bought it before day j could be any day between [0, j-1].*\\n\\nlet\\'s say the last time you bought it on day jj, where jj is in range [0, j-1].\\nApproach :- \\n\\nIn this case you didn\\'t touch price[jj] before you bought it. so what\\'s the max profit before you bought it on day jj, well obviously it\\'s dp[i-1][jj-1]. it\\'s also dp[i-1][jj] because in this case you can only buy it on day jj and to keep the profit maximum you will do nothing on day jj.\\n\\nafter all you bought it on day jj and the \"max profit\" becomes max(dp[i-1][jj] - prices[jj]), this isn\\'t the max profit on day jj with at most i-1 transaction, this is the max profit where you already bought the stock on day jj with at most i transactions.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        if(k == 0) return 0 ; \\n        if(prices.size() == 0 || prices.size() == 1) return 0 ; \\n        \\n        vector<vector<int>> dp(k+1 , vector<int>(prices.size())) ; \\n        for(int i = 0 ; i<dp.size() ; i++)\\n        {\\n            for(int j = 0 ; j < dp[i].size() ; j++)\\n            {\\n                if(i == 0) dp[i][j] = 0 ; \\n                else if(j == 0) dp[i][j] = 0 ;\\n                else \\n                { \\n                    int x ; \\n                    int mx = INT_MIN ; \\n                    for(int k = 0 ; k < j ; k++)\\n                    {\\n                        x = prices[j] - prices[k] + dp[i-1][k] ; \\n                        mx = max(x , mx) ; \\n                    }\\n                    dp[i][j] = max(dp[i][j-1] , mx) ; \\n                }\\n            }\\n        }\\n        return dp[dp.size()-1][prices.size()-1] ; \\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        if(k == 0) return 0 ; \\n        if(prices.size() == 0 || prices.size() == 1) return 0 ; \\n        \\n        vector<vector<int>> dp(k+1 , vector<int>(prices.size())) ; \\n        for(int i = 0 ; i<dp.size() ; i++)\\n        {\\n            for(int j = 0 ; j < dp[i].size() ; j++)\\n            {\\n                if(i == 0) dp[i][j] = 0 ; \\n                else if(j == 0) dp[i][j] = 0 ;\\n                else \\n                { \\n                    int x ; \\n                    int mx = INT_MIN ; \\n                    for(int k = 0 ; k < j ; k++)\\n                    {\\n                        x = prices[j] - prices[k] + dp[i-1][k] ; \\n                        mx = max(x , mx) ; \\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1686724,
                "title": "holding-atmost-k-transactions-explained",
                "content": "**Idea?**\\n* Maintain **buy[i][j]** and **sell[i][j]** where *buy[i][j]* denotes maximum profit we can have if we perform atmost j transactions with first i items and considering the last transaction is buying the stock.\\n* Similarly, *sell[i][j]* denotes maximum profit we can have if we perform atmost j transactions with first i items and considering the last transaction is selling the stock.\\n* Transition states for buying is :- **buy[i][j] = max(sell[i-1][j-1]-prices[i-1],buy[i-1][j])**, buy the stock right now (so previous stock must be sold earlier) or don\\'t buy.\\n* Transition states for selling is :-  **sell[i][j] = max(buy[i-1][j]+prices[i-1],sell[i-1][j])**, sell the stock right now (so previous stock must be bought earlier) or don\\'t sell.\\n* Check code.\\n```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(NK)\\n    // Space Complexity:- O(NK)\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size(),k = 2;\\n        vector<vector<int>> buy(n+1,vector<int>(k+1,INT_MIN));\\n        vector<vector<int>> sell(n+1,vector<int>(k+1,INT_MIN));\\n        for(int i=0;i<=n;i++)\\n            sell[i][0] = 0;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=k;j++){\\n                // buy this stock in jth transaction\\n                if(sell[i-1][j-1]!=INT_MIN)\\n                    buy[i][j] = max(buy[i][j],sell[i-1][j-1]-prices[i-1]);\\n                // don\\'t buy this stock in jth transaction\\n                buy[i][j] = max(buy[i][j],buy[i-1][j]);\\n                \\n                // sell this stock in jth transaction\\n                if(buy[i-1][j]!=INT_MIN)\\n                    sell[i][j] = max(sell[i][j],buy[i-1][j]+prices[i-1]);\\n                // don\\'t sell this stock in jth transaction\\n                sell[i][j] = max(sell[i][j],sell[i-1][j]);\\n            }\\n        }\\n        int ans = 0;\\n        for(int j=0;j<=k;j++)\\n            ans = max(ans,sell[n][j]);\\n        return ans;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(NK)\\n    // Space Complexity:- O(N)\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size(),k = 2;\\n        vector<vector<int>> buy(2,vector<int>(k+1,INT_MIN));\\n        vector<vector<int>> sell(2,vector<int>(k+1,INT_MIN));\\n        sell[0][0] = sell[1][0] = 0;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=k;j++){\\n                // buy this stock now in jth transaction\\n                if(sell[(i-1)%2][j-1]!=INT_MIN)\\n                    buy[i%2][j] = max(buy[i%2][j],sell[(i-1)%2][j-1]-prices[i-1]);\\n\\n                // don\\'t buy this stock in jth transaction\\n                buy[i%2][j] = max(buy[i%2][j],buy[(i-1)%2][j]);\\n\\n                // sell this stock in jth transaction\\n                if(buy[(i-1)%2][j]!=INT_MIN)\\n                    sell[i%2][j] = max(sell[i%2][j],buy[(i-1)%2][j]+prices[i-1]);\\n\\n                // don\\'t sell this stock in jth transaction\\n                sell[i%2][j] = max(sell[i%2][j],sell[(i-1)%2][j]);\\n            }\\n        }\\n        int ans = 0;\\n        for(int j=0;j<=k;j++)\\n            ans = max(ans,sell[n%2][j]);\\n        return ans;\\n    }\\n};\\n```\\n**Don\\'t Forget to Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(NK)\\n    // Space Complexity:- O(NK)\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size(),k = 2;\\n        vector<vector<int>> buy(n+1,vector<int>(k+1,INT_MIN));\\n        vector<vector<int>> sell(n+1,vector<int>(k+1,INT_MIN));\\n        for(int i=0;i<=n;i++)\\n            sell[i][0] = 0;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=k;j++){\\n                // buy this stock in jth transaction\\n                if(sell[i-1][j-1]!=INT_MIN)\\n                    buy[i][j] = max(buy[i][j],sell[i-1][j-1]-prices[i-1]);\\n                // don\\'t buy this stock in jth transaction\\n                buy[i][j] = max(buy[i][j],buy[i-1][j]);\\n                \\n                // sell this stock in jth transaction\\n                if(buy[i-1][j]!=INT_MIN)\\n                    sell[i][j] = max(sell[i][j],buy[i-1][j]+prices[i-1]);\\n                // don\\'t sell this stock in jth transaction\\n                sell[i][j] = max(sell[i][j],sell[i-1][j]);\\n            }\\n        }\\n        int ans = 0;\\n        for(int j=0;j<=k;j++)\\n            ans = max(ans,sell[n][j]);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(NK)\\n    // Space Complexity:- O(N)\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size(),k = 2;\\n        vector<vector<int>> buy(2,vector<int>(k+1,INT_MIN));\\n        vector<vector<int>> sell(2,vector<int>(k+1,INT_MIN));\\n        sell[0][0] = sell[1][0] = 0;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=k;j++){\\n                // buy this stock now in jth transaction\\n                if(sell[(i-1)%2][j-1]!=INT_MIN)\\n                    buy[i%2][j] = max(buy[i%2][j],sell[(i-1)%2][j-1]-prices[i-1]);\\n\\n                // don\\'t buy this stock in jth transaction\\n                buy[i%2][j] = max(buy[i%2][j],buy[(i-1)%2][j]);\\n\\n                // sell this stock in jth transaction\\n                if(buy[(i-1)%2][j]!=INT_MIN)\\n                    sell[i%2][j] = max(sell[i%2][j],buy[(i-1)%2][j]+prices[i-1]);\\n\\n                // don\\'t sell this stock in jth transaction\\n                sell[i%2][j] = max(sell[i%2][j],sell[(i-1)%2][j]);\\n            }\\n        }\\n        int ans = 0;\\n        for(int j=0;j<=k;j++)\\n            ans = max(ans,sell[n%2][j]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316179,
                "title": "easy-implementation-tc-n-2",
                "content": "```\\nclass Solution {\\n    // TC : O(n^2)\\n    public int maxProfit(int k, int[] A) {\\n\\t\\tint n = A.length;\\n        if(n==0) return 0;\\n\\t\\tint[][] dp = new int[k + 1][n];\\n\\n\\t\\tint trans, day = 0;\\n\\t\\tfor (trans = 1; trans <= k; trans++) {\\n\\t\\t\\tint mx = Integer.MIN_VALUE;\\n\\t\\t\\tfor (day = 1; day < n; day++) {\\n\\t\\t\\t\\tif (dp[trans - 1][day - 1] - A[day - 1] > mx)\\n\\t\\t\\t\\t\\tmx = dp[trans - 1][day - 1] - A[day - 1];\\n\\n\\t\\t\\t\\tif (mx + A[day] > dp[trans][day - 1])\\n\\t\\t\\t\\t\\tdp[trans][day] = mx + A[day];\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tdp[trans][day] = dp[trans][day - 1];\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[k][n-1];       \\n    }    \\n    \\n    \\n    \\n    \\n    \\n\\n //    TC: O(n^3)*\\n    public int maxProfit(int k, int[] A) {\\n\\t\\tint n = A.length;\\n        if(n==0) return 0;\\n\\t\\tint[][] dp = new int[k + 1][n];\\n\\n\\t\\tint trans, day = 0, pd = 0;\\n\\t\\tfor (trans = 1; trans <= k; trans++) {\\n\\t\\t\\tfor (day = 1; day < n; day++) {\\n\\n\\t\\t\\t\\tdp[trans][day] = dp[trans][day - 1];\\n\\t\\t\\t\\tint mx = Integer.MIN_VALUE;\\n\\t\\t\\t\\tfor (pd = 0; pd < day; pd++) {\\n\\t\\t\\t\\t\\tmx = Math.max(dp[trans - 1][pd] + A[day] - A[pd], mx);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdp[trans][day] = Math.max(mx, dp[trans][day]);\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[k][n-1];        \\n    }\\n   \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    // TC : O(n^2)\\n    public int maxProfit(int k, int[] A) {\\n\\t\\tint n = A.length;\\n        if(n==0) return 0;\\n\\t\\tint[][] dp = new int[k + 1][n];\\n\\n\\t\\tint trans, day = 0;\\n\\t\\tfor (trans = 1; trans <= k; trans++) {\\n\\t\\t\\tint mx = Integer.MIN_VALUE;\\n\\t\\t\\tfor (day = 1; day < n; day++) {\\n\\t\\t\\t\\tif (dp[trans - 1][day - 1] - A[day - 1] > mx)\\n\\t\\t\\t\\t\\tmx = dp[trans - 1][day - 1] - A[day - 1];\\n\\n\\t\\t\\t\\tif (mx + A[day] > dp[trans][day - 1])\\n\\t\\t\\t\\t\\tdp[trans][day] = mx + A[day];\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tdp[trans][day] = dp[trans][day - 1];\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[k][n-1];       \\n    }    \\n    \\n    \\n    \\n    \\n    \\n\\n //    TC: O(n^3)*\\n    public int maxProfit(int k, int[] A) {\\n\\t\\tint n = A.length;\\n        if(n==0) return 0;\\n\\t\\tint[][] dp = new int[k + 1][n];\\n\\n\\t\\tint trans, day = 0, pd = 0;\\n\\t\\tfor (trans = 1; trans <= k; trans++) {\\n\\t\\t\\tfor (day = 1; day < n; day++) {\\n\\n\\t\\t\\t\\tdp[trans][day] = dp[trans][day - 1];\\n\\t\\t\\t\\tint mx = Integer.MIN_VALUE;\\n\\t\\t\\t\\tfor (pd = 0; pd < day; pd++) {\\n\\t\\t\\t\\t\\tmx = Math.max(dp[trans - 1][pd] + A[day] - A[pd], mx);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdp[trans][day] = Math.max(mx, dp[trans][day]);\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[k][n-1];        \\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314156,
                "title": "swift-best-time-to-buy-and-sell-stock-iv-test-cases",
                "content": "```swift\\nclass Solution {\\n    func maxProfit(_ k: Int, _ prices: [Int]) -> Int {\\n        guard k > 0 && prices.count > 1 else { return 0 }\\n        guard k >= prices.count/2 else {\\n            var low = [Int](repeating: prices[0], count: k)\\n            var res = [Int](repeating: 0, count: k)\\n            for i in prices.indices {\\n                for s in 0..<k {\\n                    let mj = low[s], pn = prices[i]\\n                    low[s] = min(mj, s == 0 ? pn : pn - res[s-1])\\n                    res[s] = max(res[s], pn - mj)\\n                }\\n            }\\n            return res[k - 1]\\n        }\\n        var res = 0\\n        for i in 1..<prices.count where prices[i] > prices[i-1] {\\n            res += (prices[i] - prices[i-1])\\n        }\\n        return res\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        let profit = s.maxProfit(2, [2,4,1])\\n        XCTAssertEqual(profit, 2)\\n    }\\n    func test2() {\\n        let profit = s.maxProfit(2, [3,2,6,5,0,3])\\n        XCTAssertEqual(profit, 7)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func maxProfit(_ k: Int, _ prices: [Int]) -> Int {\\n        guard k > 0 && prices.count > 1 else { return 0 }\\n        guard k >= prices.count/2 else {\\n            var low = [Int](repeating: prices[0], count: k)\\n            var res = [Int](repeating: 0, count: k)\\n            for i in prices.indices {\\n                for s in 0..<k {\\n                    let mj = low[s], pn = prices[i]\\n                    low[s] = min(mj, s == 0 ? pn : pn - res[s-1])\\n                    res[s] = max(res[s], pn - mj)\\n                }\\n            }\\n            return res[k - 1]\\n        }\\n        var res = 0\\n        for i in 1..<prices.count where prices[i] > prices[i-1] {\\n            res += (prices[i] - prices[i-1])\\n        }\\n        return res\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        let profit = s.maxProfit(2, [2,4,1])\\n        XCTAssertEqual(profit, 2)\\n    }\\n    func test2() {\\n        let profit = s.maxProfit(2, [3,2,6,5,0,3])\\n        XCTAssertEqual(profit, 7)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231672,
                "title": "recursion-memoization-in-c",
                "content": "class Solution {\\npublic:\\n\\n    int dp[1001][101][2];\\n    int solve(vector<int>& prices,int idx,int k,bool is_stock)\\n    {\\n        int n=prices.size();\\n        if(idx>=n)\\n            return 0;\\n        if(k<=0)\\n            return 0;\\n        if(dp[idx][k][is_stock]!=-1)\\n            return dp[idx][k][is_stock];\\n        int ans=0;\\n        if(is_stock)\\n        {\\n            ans=max(prices[idx]+solve(prices,idx+1,k-1,0),solve(prices,idx+1,k,1));\\n        }\\n        else\\n        {\\n            ans=max(solve(prices,idx+1,k,1)-prices[idx],solve(prices,idx+1,k,0));\\n        }\\n        return dp[idx][k][is_stock]=ans;\\n    }\\n    int maxProfit(int k, vector<int>& prices)\\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(prices,0,k,0);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int dp[1001][101][2];\\n    int solve(vector<int>& prices,int idx,int k,bool is_stock)\\n    {\\n        int n=prices.size();\\n        if(idx>=n)\\n            return 0;\\n        if(k<=0)\\n            return 0;\\n        if(dp[idx][k][is_stock]!=-1)\\n            return dp[idx][k][is_stock];\\n        int ans=0;\\n        if(is_stock)\\n        {\\n            ans=max(prices[idx]+solve(prices,idx+1,k-1,0),solve(prices,idx+1,k,1));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1183502,
                "title": "c-simple-and-fast",
                "content": "b(t, j) -- the maximum money at hand after the j-th buy at time t\\ns(t, j) -- the maximum money at hand after the j-th sell at time t\\nthe j\\'th buy at t must precede the (j-1)-th sell at (t - 1)\\nbuy and sell cannot be done the same day, so updating b procede updating s\\n\\n```\\n        if (prices.empty()) return 0;\\n        const int n = prices.size();\\n        vector<int> b(k + 1, INT_MIN), s(k + 1, 0);\\n        for (int i = 0; i < prices.size(); ++i) {\\n            int p = prices[i]; \\n            for (int j = k; j >= 1; --j) {\\n                b[j] = max(b[j], s[j-1] - p);\\n                s[j] = max(s[j], b[j] + p);\\n            }\\n        }\\n        return s.back(); \\n```",
                "solutionTags": [],
                "code": "```\\n        if (prices.empty()) return 0;\\n        const int n = prices.size();\\n        vector<int> b(k + 1, INT_MIN), s(k + 1, 0);\\n        for (int i = 0; i < prices.size(); ++i) {\\n            int p = prices[i]; \\n            for (int j = k; j >= 1; --j) {\\n                b[j] = max(b[j], s[j-1] - p);\\n                s[j] = max(s[j], b[j] + p);\\n            }\\n        }\\n        return s.back(); \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 973721,
                "title": "python-memorization",
                "content": "```\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        \\n        @lru_cache(maxsize=None)\\n        def recursion(day: int, canBuy: bool, currNumTrans: int) -> int:\\n            if day >= len(prices):\\n                return 0\\n            if currNumTrans >= k:\\n                return 0\\n            \\n            buyOnTheDay = sellOnTheDay = 0\\n            if canBuy:\\n                buyOnTheDay = -prices[day] + recursion(day + 1, False, currNumTrans)\\n            else:\\n                sellOnTheDay = prices[day] + recursion(day + 1, True, currNumTrans + 1)\\n            doNothing = recursion(day + 1, canBuy, currNumTrans)\\n            \\n            return max(buyOnTheDay, sellOnTheDay, doNothing)\\n        \\n        return recursion(0, True, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Memoization"
                ],
                "code": "```\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        \\n        @lru_cache(maxsize=None)\\n        def recursion(day: int, canBuy: bool, currNumTrans: int) -> int:\\n            if day >= len(prices):\\n                return 0\\n            if currNumTrans >= k:\\n                return 0\\n            \\n            buyOnTheDay = sellOnTheDay = 0\\n            if canBuy:\\n                buyOnTheDay = -prices[day] + recursion(day + 1, False, currNumTrans)\\n            else:\\n                sellOnTheDay = prices[day] + recursion(day + 1, True, currNumTrans + 1)\\n            doNothing = recursion(day + 1, canBuy, currNumTrans)\\n            \\n            return max(buyOnTheDay, sellOnTheDay, doNothing)\\n        \\n        return recursion(0, True, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 909314,
                "title": "c-8ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n\\n        // Step 1: Find out all profit opportunities            \\n        vector<int> profits;\\n        stack<pair<int, int>> vps; // valley-peak pairs\\n        \\n        int v;\\n        int p = -1;\\n        for (;;) {\\n            // find next valley-peak pair\\n            for (v = p+1; (v+1 < prices.size()) && (prices[v] >= prices[v+1]); ++v);\\n            for (p = v  ; (p+1 < prices.size()) && (prices[p] <= prices[p+1]); ++p);\\n            \\n            if (v == p) { // v==p means that both v and p reach the end of the array\\n                break;\\n            }\\n            \\n            // Consider two transactions (v1, p1) (back of the stack) and (v2, p2) (the new-found).\\n            // If prices[v1] >= prices[v2], \\n            // it is meaningless to combine the two transactions.\\n            // Save of profit of (v1, p1), and pop it out of the record.\\n            while ((!vps.empty()) && (prices[v] <= prices[vps.top().first])) {\\n                profits.push_back(prices[vps.top().second] - prices[vps.top().first]);\\n                vps.pop();\\n            }\\n            \\n            // If prices[v1]<prices[v2] and prices[p1]<prices[p2], \\n            // then it is meaningful to combine the two transactions\\n            // update (v1, p1) to (v1, p2), and save the profit of (v2, p1)\\n            while ((!vps.empty()) && (prices[p] >= prices[vps.top().second])) {\\n                profits.push_back(prices[vps.top().second] - prices[v]);\\n                v = vps.top().first;\\n                vps.pop();\\n            }\\n            \\n            // save the new-found valley-peak pair\\n            vps.emplace(v, p);\\n        }\\n        \\n        // save all remaining profits\\n        while (!vps.empty()) {\\n            profits.push_back(prices[vps.top().second] - prices[vps.top().first]);\\n            vps.pop();\\n        }\\n        \\n        // Step 2: Calculate the k highest profits\\n        int ret;\\n        if (profits.size() <= k) {\\n            ret = accumulate(profits.begin(), profits.end(), 0);\\n        } else {\\n            nth_element(profits.begin(), profits.end() - k, profits.end());\\n            ret = accumulate(profits.end() - k, profits.end(), 0);\\n        }\\n        return ret;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n\\n        // Step 1: Find out all profit opportunities            \\n        vector<int> profits;\\n        stack<pair<int, int>> vps; // valley-peak pairs\\n        \\n        int v;\\n        int p = -1;\\n        for (;;) {\\n            // find next valley-peak pair\\n            for (v = p+1; (v+1 < prices.size()) && (prices[v] >= prices[v+1]); ++v);\\n            for (p = v  ; (p+1 < prices.size()) && (prices[p] <= prices[p+1]); ++p);\\n            \\n            if (v == p) { // v==p means that both v and p reach the end of the array\\n                break;\\n            }\\n            \\n            // Consider two transactions (v1, p1) (back of the stack) and (v2, p2) (the new-found).\\n            // If prices[v1] >= prices[v2], \\n            // it is meaningless to combine the two transactions.\\n            // Save of profit of (v1, p1), and pop it out of the record.\\n            while ((!vps.empty()) && (prices[v] <= prices[vps.top().first])) {\\n                profits.push_back(prices[vps.top().second] - prices[vps.top().first]);\\n                vps.pop();\\n            }\\n            \\n            // If prices[v1]<prices[v2] and prices[p1]<prices[p2], \\n            // then it is meaningful to combine the two transactions\\n            // update (v1, p1) to (v1, p2), and save the profit of (v2, p1)\\n            while ((!vps.empty()) && (prices[p] >= prices[vps.top().second])) {\\n                profits.push_back(prices[vps.top().second] - prices[v]);\\n                v = vps.top().first;\\n                vps.pop();\\n            }\\n            \\n            // save the new-found valley-peak pair\\n            vps.emplace(v, p);\\n        }\\n        \\n        // save all remaining profits\\n        while (!vps.empty()) {\\n            profits.push_back(prices[vps.top().second] - prices[vps.top().first]);\\n            vps.pop();\\n        }\\n        \\n        // Step 2: Calculate the k highest profits\\n        int ret;\\n        if (profits.size() <= k) {\\n            ret = accumulate(profits.begin(), profits.end(), 0);\\n        } else {\\n            nth_element(profits.begin(), profits.end() - k, profits.end());\\n            ret = accumulate(profits.end() - k, profits.end(), 0);\\n        }\\n        return ret;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 900434,
                "title": "cpp-dp-4-different-conditions-on-each-state",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        \\n        // 1 => have a stock and 0 => don\\'t have a stock\\n        // to have a stock at least 1 transaction should be there\\n        \\n        // skip the price when you have a stock\\n        // stage[i][j][1] = stage[i-1][j][1];\\n        \\n        // buy the stock at price\\n        // stage[i][j][1] = stage[i-1][j-1][0] - prices[i];\\n        \\n        // release the stock at the price\\n        // stage[i][j][0] = stage[i-1][j][1] + prices[i];\\n        \\n        // skip the price when you don\\'t have a stock\\n        // stage[i][j][0] = stage[i-1][j][0];\\n        int ans;\\n        if(k == 0 || n == 0) return 0;\\n        if(n < 2*k) {\\n           ans = 0;\\n            for(int i=1; i<n; i++) {\\n               ans += max(0, prices[i] - prices[i-1]);\\n           }\\n            return ans;\\n        }\\n        \\n        vector<vector<vector<int>>> stage(n, vector<vector<int>>(k+1, vector<int>(2, -1e9)));\\n        stage[0][0][0] = 0;\\n        stage[0][1][1] = -prices[0];\\n        for(int i=1; i<n; i++) {\\n            for(int j=0; j<=k; j++) {\\n                    stage[i][j][0] =  max(stage[i-1][j][0], stage[i-1][j][1] + prices[i]);\\n               if(j > 0) {\\n                    stage[i][j][1] =  max(stage[i-1][j][1], stage[i-1][j-1][0] - prices[i]);\\n                }\\n            }\\n        }\\n        ans = 0;\\n        for(int j=0; j<=k; ++j) {\\n            // cout << stage[n-1][j][0] << \\' \\';\\n            ans = max(ans, stage[n-1][j][0]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        \\n        // 1 => have a stock and 0 => don\\'t have a stock\\n        // to have a stock at least 1 transaction should be there\\n        \\n        // skip the price when you have a stock\\n        // stage[i][j][1] = stage[i-1][j][1];\\n        \\n        // buy the stock at price\\n        // stage[i][j][1] = stage[i-1][j-1][0] - prices[i];\\n        \\n        // release the stock at the price\\n        // stage[i][j][0] = stage[i-1][j][1] + prices[i];\\n        \\n        // skip the price when you don\\'t have a stock\\n        // stage[i][j][0] = stage[i-1][j][0];\\n        int ans;\\n        if(k == 0 || n == 0) return 0;\\n        if(n < 2*k) {\\n           ans = 0;\\n            for(int i=1; i<n; i++) {\\n               ans += max(0, prices[i] - prices[i-1]);\\n           }\\n            return ans;\\n        }\\n        \\n        vector<vector<vector<int>>> stage(n, vector<vector<int>>(k+1, vector<int>(2, -1e9)));\\n        stage[0][0][0] = 0;\\n        stage[0][1][1] = -prices[0];\\n        for(int i=1; i<n; i++) {\\n            for(int j=0; j<=k; j++) {\\n                    stage[i][j][0] =  max(stage[i-1][j][0], stage[i-1][j][1] + prices[i]);\\n               if(j > 0) {\\n                    stage[i][j][1] =  max(stage[i-1][j][1], stage[i-1][j-1][0] - prices[i]);\\n                }\\n            }\\n        }\\n        ans = 0;\\n        for(int j=0; j<=k; ++j) {\\n            // cout << stage[n-1][j][0] << \\' \\';\\n            ans = max(ans, stage[n-1][j][0]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 900345,
                "title": "best-time-to-buy-and-sell-stock-iv-c-beat-95-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n=prices.size(),b=0;\\n        if(n==0 || n==1)\\n            return 0;\\n        if((n/2)<=k)            //it can be solved in order of n time\\n        {\\n            int i = 0,ans=0; \\n            while (i < n - 1) { \\n                while ((i < n - 1) && (prices[i + 1] <= prices[i])) \\n                    i++; \\n                if (i == n - 1) \\n                    break; \\n                int buy = i++; \\n                while ((i < n) && (prices[i] >= prices[i - 1])) \\n                    i++; \\n                int sell = i - 1; \\n                ans+=prices[sell]-prices[buy];\\n\\n            } \\n            return ans;\\n        }\\n        \\n        int dp[2][n];\\n        for(int i=0;i<n;i++)\\n            dp[0][i]=0;\\n        dp[1][0]=0;\\n        for(int i=1;i<=k;i++)\\n        {\\n            b=1-b;\\n            int l=-prices[0];\\n            for(int j=1;j<n;j++)\\n            {\\n                dp[b][j]=max(dp[b][j-1],l+prices[j]);\\n                l=max(l,dp[1-b][j-1]-prices[j]);\\n            }\\n        }\\n        return dp[b][n-1];\\n\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n=prices.size(),b=0;\\n        if(n==0 || n==1)\\n            return 0;\\n        if((n/2)<=k)            //it can be solved in order of n time\\n        {\\n            int i = 0,ans=0; \\n            while (i < n - 1) { \\n                while ((i < n - 1) && (prices[i + 1] <= prices[i])) \\n                    i++; \\n                if (i == n - 1) \\n                    break; \\n                int buy = i++; \\n                while ((i < n) && (prices[i] >= prices[i - 1])) \\n                    i++; \\n                int sell = i - 1; \\n                ans+=prices[sell]-prices[buy];\\n\\n            } \\n            return ans;\\n        }\\n        \\n        int dp[2][n];\\n        for(int i=0;i<n;i++)\\n            dp[0][i]=0;\\n        dp[1][0]=0;\\n        for(int i=1;i<=k;i++)\\n        {\\n            b=1-b;\\n            int l=-prices[0];\\n            for(int j=1;j<n;j++)\\n            {\\n                dp[b][j]=max(dp[b][j-1],l+prices[j]);\\n                l=max(l,dp[1-b][j-1]-prices[j]);\\n            }\\n        }\\n        return dp[b][n-1];\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900061,
                "title": "c-dp-based-general-solution-95-time-10-space",
                "content": "For this problem I went back to [the logic of his little brother problem](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/794836/), which I invite you to check and read in order to get a closer step-by-step idea with a simpler scenario, and worked to make it more general.\\n\\nTo do so, I had first of all to grab `nums` size and store it in `len`; then we get rid of edge cases, when `k == 0` or `len < 2`: in these occurrences, we just return `0`.\\n\\n`k` needs then to be \"fixed\": despite being told that it represents the number of \"transactions\" (ie: buy or sell operations), it is actually more like the number of profit-bearinng trades (ie: selling, after having bought for less); furthermore, it is pointless to consider a `k` which is wildly bigger than the number of days we are going to trade - and this in turn needs to be reduced to an even number to make sense (we would otherwise end up just buying for the last transaction, but it would be rather pointless).\\n\\nHence the expression: `min(k * 2, len - len % 2)`.\\n\\nWe do all this because we are going to create an array `dp` of values to help us, initialising all the odd cells to `0` and all the even ones to `INT_MAX`.\\n\\nThen it is time to loop through our list of prices for good, storing them as `currPrice`.\\n\\nAnd for each one, we apply the generalised version of [the logic I mentionend above](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/794836/):\\n* the very first cell of `dp` is going to be set as the minimum between its current value and `currPrice` - `min(dp[0], currPrice)`;\\n* each following odd indexed cell is going to be the maximum between its current value and `currPrice` minus the prevous one - `max(dp[i], currPrice - dp[i - 1])`;\\n* each following even indexed cell is going to be the minimum between its current value and `currPrice` minus the prevous one - `min(dp[i], currPrice - dp[i - 1])`;\\n\\nAfter we are done, we can just return the value of the last cell :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int len = prices.size();\\n        // edge cases away\\n        if (!k || len < 2) return 0;\\n        // fixing k to be a meaningful, even number\\n        k = min(k * 2, len - len % 2);\\n        // declaring and setting up dp\\n        int dp[k];\\n        for (int i = 0; i < k; i++) dp[i] = i % 2 ? 0 : INT_MAX;\\n        for (int currPrice: prices) {\\n            // setting up the first dp element\\n            dp[0] = min(dp[0], currPrice);\\n            // updating dp with all the subsequent trades\\n            for (int i = 1; i < k; i++) {\\n                dp[i] = i % 2 ? max(dp[i], currPrice - dp[i - 1]) : min(dp[i], currPrice - dp[i - 1]);\\n            }\\n        }\\n        return dp[k - 1];\\n    }\\n};\\n```\\n\\nAnd with a small change to handle edge cases, I moved down from an average 648ms time to a wooping 8ms, still with the same memory usage (not sure how one could get less, then); full explanation of the logic [here](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/discuss/788360/) - the improved code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int len = prices.size();\\n        // edge cases away\\n        if (!k || len < 2) return 0;\\n        // special case of unlimited transactions\\n        if (len < k * 2) {\\n            int sum = 0;\\n            for (int i = 1; i < len; i++) sum += max(0, prices[i] - prices[i - 1]);\\n            return sum;\\n        }\\n        // fixing k to be a meaningful, even number\\n        k = k * 2;\\n        // declaring and setting up dp\\n        int dp[k];\\n        for (int i = 0; i < k; i++) dp[i] = i % 2 ? 0 : INT_MAX;\\n        for (int currPrice: prices) {\\n            // setting up the first dp element\\n            dp[0] = min(dp[0], currPrice);\\n            // updating dp with all the subsequent trades\\n            for (int i = 1; i < k; i++) {\\n                dp[i] = i % 2 ? max(dp[i], currPrice - dp[i - 1]) : min(dp[i], currPrice - dp[i - 1]);\\n            }\\n        }\\n        return dp[k - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int len = prices.size();\\n        // edge cases away\\n        if (!k || len < 2) return 0;\\n        // fixing k to be a meaningful, even number\\n        k = min(k * 2, len - len % 2);\\n        // declaring and setting up dp\\n        int dp[k];\\n        for (int i = 0; i < k; i++) dp[i] = i % 2 ? 0 : INT_MAX;\\n        for (int currPrice: prices) {\\n            // setting up the first dp element\\n            dp[0] = min(dp[0], currPrice);\\n            // updating dp with all the subsequent trades\\n            for (int i = 1; i < k; i++) {\\n                dp[i] = i % 2 ? max(dp[i], currPrice - dp[i - 1]) : min(dp[i], currPrice - dp[i - 1]);\\n            }\\n        }\\n        return dp[k - 1];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int len = prices.size();\\n        // edge cases away\\n        if (!k || len < 2) return 0;\\n        // special case of unlimited transactions\\n        if (len < k * 2) {\\n            int sum = 0;\\n            for (int i = 1; i < len; i++) sum += max(0, prices[i] - prices[i - 1]);\\n            return sum;\\n        }\\n        // fixing k to be a meaningful, even number\\n        k = k * 2;\\n        // declaring and setting up dp\\n        int dp[k];\\n        for (int i = 0; i < k; i++) dp[i] = i % 2 ? 0 : INT_MAX;\\n        for (int currPrice: prices) {\\n            // setting up the first dp element\\n            dp[0] = min(dp[0], currPrice);\\n            // updating dp with all the subsequent trades\\n            for (int i = 1; i < k; i++) {\\n                dp[i] = i % 2 ? max(dp[i], currPrice - dp[i - 1]) : min(dp[i], currPrice - dp[i - 1]);\\n            }\\n        }\\n        return dp[k - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883211,
                "title": "simple-8-lines-of-code",
                "content": "For atmost k times transactions vectors of buys[k],sells[k] ,\\nbuys[i] for ith buy,sells[i] for ith sells and return sells[k] i.e. maximum profit\\n```\\n  int maxProfit(int k, vector<int>& prices) {\\n          k=k>prices.size()/2?prices.size()/2:k;\\n          vector<int> buys(k + 1, INT_MIN), sells(k + 1, 0);\\n       for (auto p : prices)\\n            for (auto i = 1; i <= k; ++i) {\\n                    buys[i] = max(buys[i], sells[i - 1] - p);\\n                     sells[i] = max(sells[i], buys[i] + p);  \\n             }\\n  return sells[k];\\n    }",
                "solutionTags": [],
                "code": "For atmost k times transactions vectors of buys[k],sells[k] ,\\nbuys[i] for ith buy,sells[i] for ith sells and return sells[k] i.e. maximum profit\\n```\\n  int maxProfit(int k, vector<int>& prices) {\\n          k=k>prices.size()/2?prices.size()/2:k;\\n          vector<int> buys(k + 1, INT_MIN), sells(k + 1, 0);\\n       for (auto p : prices)\\n            for (auto i = 1; i <= k; ++i) {\\n                    buys[i] = max(buys[i], sells[i - 1] - p);\\n                     sells[i] = max(sells[i], buys[i] + p);  \\n             }\\n  return sells[k];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 833004,
                "title": "cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        if (k >= n/2) // we can take as many cases as we want\\n        {\\n            int profit = 0;\\n            for (int i = 1; i < n; i++)\\n                if (prices[i] > prices[i - 1]) \\n                    profit += prices[i] - prices[i - 1];\\n            return profit;\\n        }\\n    \\n        vector<int>buy(k+1, INT_MIN); \\n        vector<int>sell(k+1, 0);    \\n        \\n        int ans  = 0;\\n        for (int i = 0; i < n; i++) {\\n\\t\\t// for every prices[i] , we see the maximum profit sell[j] (j from 1-k)  which can be generated in k transactions.\\n            for (int j = 1; j <= k; j++) {\\n                 buy[j] = max(buy[j],sell[j-1] - prices[i]); \\n                sell[j] = max(sell[j],  buy[j] + prices[i]);\\n            }\\n        }\\n        return sell[k];\\n    }\\n};\\n```\\nIF YOU FIND THIS HELPFUL PLEASE UPVOTE !",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        if (k >= n/2) // we can take as many cases as we want\\n        {\\n            int profit = 0;\\n            for (int i = 1; i < n; i++)\\n                if (prices[i] > prices[i - 1]) \\n                    profit += prices[i] - prices[i - 1];\\n            return profit;\\n        }\\n    \\n        vector<int>buy(k+1, INT_MIN); \\n        vector<int>sell(k+1, 0);    \\n        \\n        int ans  = 0;\\n        for (int i = 0; i < n; i++) {\\n\\t\\t// for every prices[i] , we see the maximum profit sell[j] (j from 1-k)  which can be generated in k transactions.\\n            for (int j = 1; j <= k; j++) {\\n                 buy[j] = max(buy[j],sell[j-1] - prices[i]); \\n                sell[j] = max(sell[j],  buy[j] + prices[i]);\\n            }\\n        }\\n        return sell[k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741380,
                "title": "clean-python-100-speed",
                "content": "**Clean Python | 100% Speed**\\n\\nThe code below is an extension of the O(1) space algorithm using to find the best two transactions in [Problem #123](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/):\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/\\n\\nThe algorithm starts by considering a low number of transactions, and then it uses their profits to \"subsidize\" new stock purchases.  The main benefit is that the last transactions have \"subsidized\" costs, which reflect the global profits. \\n\\nOne cool idea is that we can stop iterating if \"k\" purchases don\\'t yield higher profits (than k-1), becuase it means that making more transactions at this point has no effect (the result are getting copied).\\n\\nI hope you find the code helpful. Cheers,\\n\\n```\\nclass Solution:\\n    inf = float(\\'inf\\')\\n    def cleaned(self,B):\\n        A, c = [ B[0] ], B[1]\\n        for i in range(1,len(B)-1):\\n            a,b,c = A[-1], c, B[i+1]\\n            if b==a or b==c or (a<b<c) or (a>b>c):\\n                continue\\n            A.append(b)\\n        A.append( B[-1] )\\n        return A\\n    def maxProfit(self, k, prices):\\n        # For Problem # 123: \\n\\t\\t#     -> Uncomment k = 2 here, and remove it from the function parameters\\n\\t\\t# k = 2\\n\\t\\t# -------------------- Initial Edge Cases --------------------\\n        if not k or len(prices)<2:\\n            return 0\\n        #\\n        # Clean Prices\\n        prices = self.cleaned(prices) \\n        #\\n        # Use all Profits\\n        profits = [ prices[i]-prices[i-1] for i in range(1,len(prices)) if prices[i]>prices[i-1] ]\\n        if k>=len(profits):\\n            return sum(profits)\\n        #\\n        # -------------------- Main Code --------------------\\n        B = [0       ]*k\\n        P = [self.inf]*k\\n        i = None\\n        for x in prices:\\n            P[0] = min(P[0],x     ) # track min-buy point\\n            B[0] = max(B[0],x-P[0]) # track max. profit (buying now at lowest cost)\\n            for i in range(1,k):\\n                P[i] = min(P[i], x - B[i-1] ) # Min Buy Point Subsidized by \"i\" Transactions\\n                B[i] = max(B[i], x - P[i]   ) # Subsidized Profits (with current point)\\n                if B[i]==B[i-1]:\\n                    break # We\\'re just copying the previous transactions\\n        return B[i] if i!=None else B[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    inf = float(\\'inf\\')\\n    def cleaned(self,B):\\n        A, c = [ B[0] ], B[1]\\n        for i in range(1,len(B)-1):\\n            a,b,c = A[-1], c, B[i+1]\\n            if b==a or b==c or (a<b<c) or (a>b>c):\\n                continue\\n            A.append(b)\\n        A.append( B[-1] )\\n        return A\\n    def maxProfit(self, k, prices):\\n        # For Problem # 123: \\n\\t\\t#     -> Uncomment k = 2 here, and remove it from the function parameters\\n\\t\\t# k = 2\\n\\t\\t# -------------------- Initial Edge Cases --------------------\\n        if not k or len(prices)<2:\\n            return 0\\n        #\\n        # Clean Prices\\n        prices = self.cleaned(prices) \\n        #\\n        # Use all Profits\\n        profits = [ prices[i]-prices[i-1] for i in range(1,len(prices)) if prices[i]>prices[i-1] ]\\n        if k>=len(profits):\\n            return sum(profits)\\n        #\\n        # -------------------- Main Code --------------------\\n        B = [0       ]*k\\n        P = [self.inf]*k\\n        i = None\\n        for x in prices:\\n            P[0] = min(P[0],x     ) # track min-buy point\\n            B[0] = max(B[0],x-P[0]) # track max. profit (buying now at lowest cost)\\n            for i in range(1,k):\\n                P[i] = min(P[i], x - B[i-1] ) # Min Buy Point Subsidized by \"i\" Transactions\\n                B[i] = max(B[i], x - P[i]   ) # Subsidized Profits (with current point)\\n                if B[i]==B[i-1]:\\n                    break # We\\'re just copying the previous transactions\\n        return B[i] if i!=None else B[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648059,
                "title": "simple-python-solution-using-one-pass-and-k-recurrence-relations-o-n-min-n-k",
                "content": "# Buy and Sell Stock IV\\nWe re-use the solution idea from problem III (last solution): https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solution/\\n\\nThe idea is to define two arrays of length k:\\n\\n```\\ncosts[0], ..., costs[k-1]\\nprofits[0], ..., profits[k-1]\\n```\\n\\nWe define `costs[i]` to be the minimal cost to acquire the stock on the `ith` purchase (e.g., the purchase price minus any profits from prior stock sales).\\n\\nWe define `profits[i]` to the maximal profit from selling the stock on the `ith` purchase (e.g., the sale price minus the cost of acquiring the stock).  \\n\\nWe can then update these quantities by a single loop through `prices`, and within that loop looping over the `k` entries of these two arrays.  \\n\\n## Time Complexity\\nLet `n = len(prices)`, and `k` be the number of transactions.  If `k > n/2` the problem becomes much simpler and is `O(n)`.\\n\\nNow, we need to loop over `n` prices.  Inside each loop, we loop over `k` entries.  Hence, overall the problem is `O(n * k)`.\\n\\nHowever, we\\'ve seen that if `k > n/2`, then the problem becomes `O(n)`.  So we may assume `k <= n / 2`.  Hence, the solution time complexity is `O(n * min(n,k))`.\\n\\n## Space Complexity\\n`O(k)`, since we need to store the `costs` and `profits` arrays, each of length `k`.\\n\\n## Code\\n\\n```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n\\n        if(k == 0):\\n            return 0\\n        if(len(prices) == 0):\\n            return 0\\n        if(k > len(prices) / 2):\\n            #if k is large, we can take every possible transaction\\n            #the calculation is then very simple: take next_price - price whenever it is positive.\\n            profit = 0\\n            prices.append(0)\\n            for price, next_price in zip(prices[0:-1],prices[1:]):\\n                profit += max(0, next_price - price)\\n            return profit\\n\\n        costs = [float(\\'inf\\')] * k\\n        profits = [0] * k\\n\\n\\n        #costs[i] is the cost to acquire a stock on the ith purchase, adjusted for the maximum profit\\n        #obtaining on the previous (i-1) transactions.\\n        #profits[i] is the maximal profit obtained after the ith sale\\n\\n        for p_ind, price in enumerate(prices):\\n            for i in range(min(k, (p_ind) // 2 + 1)):\\n                if(i == 0):\\n                    costs[i] = min(costs[i], price)\\n                else:\\n                    costs[i] = min(costs[i], price - profits[i-1])\\n\\n                profits[i] = max(profits[i], price - costs[i])\\n\\n        return max(profits)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ncosts[0], ..., costs[k-1]\\nprofits[0], ..., profits[k-1]\\n```\n```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n\\n        if(k == 0):\\n            return 0\\n        if(len(prices) == 0):\\n            return 0\\n        if(k > len(prices) / 2):\\n            #if k is large, we can take every possible transaction\\n            #the calculation is then very simple: take next_price - price whenever it is positive.\\n            profit = 0\\n            prices.append(0)\\n            for price, next_price in zip(prices[0:-1],prices[1:]):\\n                profit += max(0, next_price - price)\\n            return profit\\n\\n        costs = [float(\\'inf\\')] * k\\n        profits = [0] * k\\n\\n\\n        #costs[i] is the cost to acquire a stock on the ith purchase, adjusted for the maximum profit\\n        #obtaining on the previous (i-1) transactions.\\n        #profits[i] is the maximal profit obtained after the ith sale\\n\\n        for p_ind, price in enumerate(prices):\\n            for i in range(min(k, (p_ind) // 2 + 1)):\\n                if(i == 0):\\n                    costs[i] = min(costs[i], price)\\n                else:\\n                    costs[i] = min(costs[i], price - profits[i-1])\\n\\n                profits[i] = max(profits[i], price - costs[i])\\n\\n        return max(profits)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 640927,
                "title": "c-dp-based-on-best-time-to-buy-and-sell-stock-iii",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        \\n        int n = prices.size();\\n        if (k >= n/2) {\\n            int profit = 0;\\n            for (int i = 1; i < n; i++)\\n                if (prices[i] > prices[i - 1]) profit += prices[i] - prices[i - 1];\\n            return profit;\\n        }\\n    \\n        vector<int>buy(k+1, INT_MIN);\\n        vector<int>sell(k+1, 0);\\n        \\n        int ans  = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 1; j <= k; j++) {\\n                buy[j] = max(buy[j], sell[j-1] - prices[i]);\\n                sell[j] = max(sell[j], buy[j] + prices[i]);\\n            }\\n        }\\n        \\n        return sell[k];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        \\n        int n = prices.size();\\n        if (k >= n/2) {\\n            int profit = 0;\\n            for (int i = 1; i < n; i++)\\n                if (prices[i] > prices[i - 1]) profit += prices[i] - prices[i - 1];\\n            return profit;\\n        }\\n    \\n        vector<int>buy(k+1, INT_MIN);\\n        vector<int>sell(k+1, 0);\\n        \\n        int ans  = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 1; j <= k; j++) {\\n                buy[j] = max(buy[j], sell[j-1] - prices[i]);\\n                sell[j] = max(sell[j], buy[j] + prices[i]);\\n            }\\n        }\\n        \\n        return sell[k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 581984,
                "title": "c-top-down-dp-using-recursion",
                "content": "Many solutions use state machine approach, which is really nice but hard to explain to others. So I came up with this recursion approach.\\n\\nIf K is really large, we can get all the possible profit. This is what findAll() does.\\nrecursion idea:\\nThe original problem is to find the max profit from day 0 with at most K transactions allowed.\\nAnd subproblem is the max profit from day i with at most k transactions allowed.\\nSo the recursion function depends on two states: day i, and max number of transactions allowed k.\\nWhat dfs() do is to find the first possible transaction and use recursion to find the profit of remaining transactions, and compare all these results to get the max profit.\\nAs subproblems have overlaps, we can use a 2-d array to improve time complexity.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        if(k >= n/2)\\n            return findAll(prices);\\n        vector<vector<int>> dp(n, vector<int>(k+1, -1));\\n        return dfs(prices, 0, k, dp);\\n    }\\n    \\nprivate:\\n    int dfs(vector<int>& prices, int i, int k, vector<vector<int>>& dp){\\n        int n = prices.size();\\n        if(i == n || k == 0)\\n            return 0;\\n        if(dp[i][k] != -1)\\n            return dp[i][k];\\n        \\n        int curMin = INT_MAX;\\n        dp[i][k] = 0;\\n        for(int j=i; j<n; ++j){\\n            curMin = min(curMin, prices[j]);\\n            if(prices[j] > curMin)\\n                dp[i][k] = max(dp[i][k], prices[j] - curMin + dfs(prices, j+1, k-1, dp));\\n        }\\n        return dp[i][k];\\n    }\\n    \\n    int findAll(vector<int>& prices){\\n        int n = prices.size();\\n        if(n < 2)\\n            return 0;\\n        int res = 0;\\n        for(int i=1; i<n; ++i){\\n            if(prices[i] - prices[i-1] > 0)\\n                res += prices[i] - prices[i-1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        if(k >= n/2)\\n            return findAll(prices);\\n        vector<vector<int>> dp(n, vector<int>(k+1, -1));\\n        return dfs(prices, 0, k, dp);\\n    }\\n    \\nprivate:\\n    int dfs(vector<int>& prices, int i, int k, vector<vector<int>>& dp){\\n        int n = prices.size();\\n        if(i == n || k == 0)\\n            return 0;\\n        if(dp[i][k] != -1)\\n            return dp[i][k];\\n        \\n        int curMin = INT_MAX;\\n        dp[i][k] = 0;\\n        for(int j=i; j<n; ++j){\\n            curMin = min(curMin, prices[j]);\\n            if(prices[j] > curMin)\\n                dp[i][k] = max(dp[i][k], prices[j] - curMin + dfs(prices, j+1, k-1, dp));\\n        }\\n        return dp[i][k];\\n    }\\n    \\n    int findAll(vector<int>& prices){\\n        int n = prices.size();\\n        if(n < 2)\\n            return 0;\\n        int res = 0;\\n        for(int i=1; i<n; ++i){\\n            if(prices[i] - prices[i-1] > 0)\\n                res += prices[i] - prices[i-1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529548,
                "title": "accepted-c-solution-easy-to-understand",
                "content": "# Approach\\nExtended the idea in solution from 2 to k\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/529530/Accepted-C-solution-time-O(N)-space-O(1)%3AEasy-to-understand\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/\\n\\n```\\npublic class Solution {\\n    public int MaxProfit(int k, int[] prices)\\n    {\\n        if (k < 1 || prices.Length < 2)\\n            return 0;\\n        \\n        k = Math.Min(k, prices.Length / 2);\\n        int[] buys = new int[k];\\n        int[] sells = new int[k];\\n        \\n        for (int i = 0; i < k; i++)\\n            buys[i] = int.MaxValue;\\n        \\n        for (int i = 0; i < prices.Length; i++)\\n        {\\n            buys[0] = Math.Min(buys[0], prices[i]);\\n            sells[0] = Math.Max(sells[0], prices[i] - buys[0]);\\n            for (int j = 1; j < k; j++)\\n            {\\n                buys[j] = Math.Min(buys[j], prices[i] - sells[j-1]);\\n                sells[j] = Math.Max(sells[j], prices[i] - buys[j]);\\n            }            \\n        }\\n        return sells[k-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxProfit(int k, int[] prices)\\n    {\\n        if (k < 1 || prices.Length < 2)\\n            return 0;\\n        \\n        k = Math.Min(k, prices.Length / 2);\\n        int[] buys = new int[k];\\n        int[] sells = new int[k];\\n        \\n        for (int i = 0; i < k; i++)\\n            buys[i] = int.MaxValue;\\n        \\n        for (int i = 0; i < prices.Length; i++)\\n        {\\n            buys[0] = Math.Min(buys[0], prices[i]);\\n            sells[0] = Math.Max(sells[0], prices[i] - buys[0]);\\n            for (int j = 1; j < k; j++)\\n            {\\n                buys[j] = Math.Min(buys[j], prices[i] - sells[j-1]);\\n                sells[j] = Math.Max(sells[j], prices[i] - buys[j]);\\n            }            \\n        }\\n        return sells[k-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478253,
                "title": "c-solution-using-state-transitions-detailed-explanation",
                "content": "```\\n/*\\n    We use state transition for this. Since there are k transactions, that means there are 2k states:\\n    One state when we have bought something and another when we have sold something.\\n    (Bought1)---sell---->(Sold1)-----buy----->(Bought2)------sell----->(Sold2)-----buy----->(Boughtk)------sell----->(Soldk)\\n    \\n    Also for each of the states, we can decide to not do anything, that would mean just using the\\n    current state.\\n    TC: O(Nk), SC: O(k)\\n*/\\n\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        if(prices.empty() || k == 0)\\n            return 0;\\n        \\n        const int N = prices.size();\\n        // to buy stock on ith day and sell on i+1th day takes N/2 transactions and repeating.\\n        // and need no order to decide when to buy or sell\\n        // So if k > N/2, then there is no need to decide when to buy or sell\\n        if(k >= N / 2) {\\n            int total_profit = 0;\\n            for(int i = 0; i < N-1; i++)\\n                if(prices[i] < prices[i+1])\\n                    total_profit += (prices[i+1] - prices[i]);\\n            \\n            return total_profit;\\n        }\\n        \\n        // states after buying and selling\\n        // bought(i): (i+1) state in the state transition, \\n        // each (except first) happens after a sold state\\n        vector<int> bought(k, INT_MIN);\\n        // sold(i): (i+2) state in state transition, each sold\\n        // state happens after (i+1)th bought(bought[i] in array) state\\n        vector<int> sold(k, INT_MIN);\\n        \\n        for(int i = 0; i < N; i++) {\\n            // first Bought and sold states\\n            bought[0] = max(bought[0], -prices[i]);\\n            sold[0] = max(sold[0], bought[0] + prices[i]);\\n            \\n            // update the remaining states\\n            for(int j = 1; j < k; j++) {\\n                // For each Bought state, either don\\'t do anything or buy the current stock\\n                bought[j] = max(bought[j], sold[j-1] - prices[i]);        \\n                // Either don\\'t sell or sell the stock bought earlier\\n                sold[j] = max(sold[j], bought[j] + prices[i]);\\n            }\\n        }\\n        \\n        // final answer is the last sold state\\n        return sold.back();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    We use state transition for this. Since there are k transactions, that means there are 2k states:\\n    One state when we have bought something and another when we have sold something.\\n    (Bought1)---sell---->(Sold1)-----buy----->(Bought2)------sell----->(Sold2)-----buy----->(Boughtk)------sell----->(Soldk)\\n    \\n    Also for each of the states, we can decide to not do anything, that would mean just using the\\n    current state.\\n    TC: O(Nk), SC: O(k)\\n*/\\n\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        if(prices.empty() || k == 0)\\n            return 0;\\n        \\n        const int N = prices.size();\\n        // to buy stock on ith day and sell on i+1th day takes N/2 transactions and repeating.\\n        // and need no order to decide when to buy or sell\\n        // So if k > N/2, then there is no need to decide when to buy or sell\\n        if(k >= N / 2) {\\n            int total_profit = 0;\\n            for(int i = 0; i < N-1; i++)\\n                if(prices[i] < prices[i+1])\\n                    total_profit += (prices[i+1] - prices[i]);\\n            \\n            return total_profit;\\n        }\\n        \\n        // states after buying and selling\\n        // bought(i): (i+1) state in the state transition, \\n        // each (except first) happens after a sold state\\n        vector<int> bought(k, INT_MIN);\\n        // sold(i): (i+2) state in state transition, each sold\\n        // state happens after (i+1)th bought(bought[i] in array) state\\n        vector<int> sold(k, INT_MIN);\\n        \\n        for(int i = 0; i < N; i++) {\\n            // first Bought and sold states\\n            bought[0] = max(bought[0], -prices[i]);\\n            sold[0] = max(sold[0], bought[0] + prices[i]);\\n            \\n            // update the remaining states\\n            for(int j = 1; j < k; j++) {\\n                // For each Bought state, either don\\'t do anything or buy the current stock\\n                bought[j] = max(bought[j], sold[j-1] - prices[i]);        \\n                // Either don\\'t sell or sell the stock bought earlier\\n                sold[j] = max(sold[j], bought[j] + prices[i]);\\n            }\\n        }\\n        \\n        // final answer is the last sold state\\n        return sold.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 471524,
                "title": "easiest-recursive-dp-o-n-k-2-solution-with-memoization",
                "content": "```\\nclass Solution {\\n\\n    private Integer[][][] dp;\\n\\n    private int callMe(int k, int[] prices, int d, int buy) {\\n        if (d == prices.length || k == 0) { // NO TRANSACTIONS LEFT OR NO PRICES LEFT\\n            return 0;\\n        }\\n        if (dp[k][d][buy] != null) {\\n            return dp[k][d][buy];\\n        }\\n        int x1;\\n        if (buy == 1) {\\n            x1 = callMe(k, prices, d + 1, 0) - prices[d]; // BUY\\n        } else {\\n            x1 = callMe(k - 1, prices, d + 1, 1) + prices[d]; // SELL\\n        }\\n        int x2 = callMe(k, prices, d + 1, buy); // SKIP\\n        int ans = Math.max(x1, x2);\\n        return dp[k][d][buy] = ans;\\n    }\\n\\n    public int maxProfit(int k, int[] prices) {\\n        int res = 0;\\n        if (k > prices.length / 2) {\\n            for (int i = 1; i < prices.length; i++)\\n                if (prices[i] > prices[i - 1])\\n                    res += prices[i] - prices[i - 1];\\n            return res;\\n        }\\n        dp = new Integer[k + 1][prices.length + 1][2];\\n        return callMe(k, prices, 0, 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    private Integer[][][] dp;\\n\\n    private int callMe(int k, int[] prices, int d, int buy) {\\n        if (d == prices.length || k == 0) { // NO TRANSACTIONS LEFT OR NO PRICES LEFT\\n            return 0;\\n        }\\n        if (dp[k][d][buy] != null) {\\n            return dp[k][d][buy];\\n        }\\n        int x1;\\n        if (buy == 1) {\\n            x1 = callMe(k, prices, d + 1, 0) - prices[d]; // BUY\\n        } else {\\n            x1 = callMe(k - 1, prices, d + 1, 1) + prices[d]; // SELL\\n        }\\n        int x2 = callMe(k, prices, d + 1, buy); // SKIP\\n        int ans = Math.max(x1, x2);\\n        return dp[k][d][buy] = ans;\\n    }\\n\\n    public int maxProfit(int k, int[] prices) {\\n        int res = 0;\\n        if (k > prices.length / 2) {\\n            for (int i = 1; i < prices.length; i++)\\n                if (prices[i] > prices[i - 1])\\n                    res += prices[i] - prices[i - 1];\\n            return res;\\n        }\\n        dp = new Integer[k + 1][prices.length + 1][2];\\n        return callMe(k, prices, 0, 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 449097,
                "title": "java-o-kn-with-explanation",
                "content": "#### Idea\\nThis problem has a boundary case: 2 * k >= n, which means you could make transactions as often as you want. So, it becomes a greedy problem, just summarizing every sub-profits. Time: O(n) | Space: O(1).\\n\\n    public int unlimitedTrans(int[] prices) {\\n            int maxProfit = 0;\\n            for(int i = 1; i < prices.length; i++) {\\n                maxProfit += Math.max(0, prices[i] - prices[i - 1]);\\n            }\\n            return maxProfit;\\n        }\\n\\n---\\n\\nNow suppose 2 * k < n. This problem is a DP problem, solving current problem using previous optimum solution. Iterate t from 1 to k and iterate through prices , recording for each index i the best solution for prices[0, i] with t transactions. We store these solutions using two 2D auxiliary array, buy and sell.\\n\\n`buy[t][i]`: the most money you can have after you completing t-1 transactions and buying at day i.\\n\\n`sell[t][i]`: the max profit you can have when you sell at day i (currently at t th transaction).\\n\\nWe could summarize the formula:\\n\\n`buy[t][i] = max(sell[t-1][1..(i-1)]) - prices[i]` Note: you buy at day i, you must complete t-1 transactions.\\n\\n`sell[t][i] = max(buy[t][1..(i-1)]) + prices[i]` Note: when you sell at day i, currently you are at transaction t.\\n\\nTime: `O(kn)` | Space: `O(kn)`\\n\\nTake a look at the formula again, we could find that we don\\u2019t need to store all optimum solution from 1 to k. So we could further reduce the space complexity buy using two 1-D array (buy[i], sell[i]). Space: `O(n)`.\\n\\nThe initialization of buy[i] and sell[i], which is the state of 0th transaction, is all 0. Inside the double for-loop, we just update the array and keep track of previous max value, which takes constant time. We first update buy because it uses the previous state of sell. Then we update sell. \\n#### Code\\n```\\npublic int maxProfit(int k, int[] prices) {\\n        if(prices.length <= 1 || k == 0) return 0;\\n        if(2*k >= prices.length) return unlimitedTrans(prices);\\n        int[] buy = new int[prices.length];\\n        int[] sell = new int[prices.length];\\n        int maxProfit = Integer.MIN_VALUE;\\n        \\n        for(int t = 1; t < k + 1; t++) {\\n            // Update buy\\n            int maxPreSell = sell[0];\\n            for(int i = 0; i < prices.length; i++) {\\n                buy[i] = i == 0 ? prices[i] * (-1) : maxPreSell - prices[i];\\n                maxPreSell = Math.max(maxPreSell, sell[i]);\\n            }\\n            // Update sell\\n            int maxCurrBuy = buy[0];\\n            for(int i = 0; i < prices.length; i++) {\\n                sell[i] = i == 0 ? 0 : maxCurrBuy + prices[i];\\n                maxCurrBuy = Math.max(maxCurrBuy, buy[i]);\\n                maxProfit = Math.max(maxProfit, sell[i]);\\n            }\\n        }\\n        \\n        return maxProfit;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int maxProfit(int k, int[] prices) {\\n        if(prices.length <= 1 || k == 0) return 0;\\n        if(2*k >= prices.length) return unlimitedTrans(prices);\\n        int[] buy = new int[prices.length];\\n        int[] sell = new int[prices.length];\\n        int maxProfit = Integer.MIN_VALUE;\\n        \\n        for(int t = 1; t < k + 1; t++) {\\n            // Update buy\\n            int maxPreSell = sell[0];\\n            for(int i = 0; i < prices.length; i++) {\\n                buy[i] = i == 0 ? prices[i] * (-1) : maxPreSell - prices[i];\\n                maxPreSell = Math.max(maxPreSell, sell[i]);\\n            }\\n            // Update sell\\n            int maxCurrBuy = buy[0];\\n            for(int i = 0; i < prices.length; i++) {\\n                sell[i] = i == 0 ? 0 : maxCurrBuy + prices[i];\\n                maxCurrBuy = Math.max(maxCurrBuy, buy[i]);\\n                maxProfit = Math.max(maxProfit, sell[i]);\\n            }\\n        }\\n        \\n        return maxProfit;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 418667,
                "title": "java-o-kn-beat-100-sorry-no-explanation",
                "content": "This might not be easy to understand. You can refer to https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/39611/Is-it-Best-Solution-with-O(n)-O(1), where the following idea is based on.\\n\\n```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        if(k == 0 || prices == null || prices.length < 2) {return 0;}\\n        \\n        int increaseCount = 0, maxProfit = 0;\\n        boolean incraseFlag = false;\\n        for(int i = 1; i < prices.length; i++) {\\n            int tmp = prices[i] - prices[i - 1];\\n            if(tmp > 0) {\\n                increaseCount += incraseFlag? 0 : 1;\\n                incraseFlag = true;\\n                maxProfit += tmp;\\n            } else {incraseFlag = false;}\\n        }\\n        \\n        if(k >= increaseCount) {return maxProfit;}\\n        \\n        int[] costs = new int[k + 1];\\n        int[] profits = new int[k + 1];\\n        \\n        for(int i = 0; i <= k; i++) {costs[i] = Integer.MAX_VALUE;}\\n        \\n        for(int price : prices) {\\n            for(int i = 1; i <= k; i++) {\\n                costs[i] = Math.min(costs[i], price - profits[i - 1]);\\n                profits[i] = Math.max(profits[i], price - costs[i]);\\n            }\\n        }\\n        \\n        return profits[k];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        if(k == 0 || prices == null || prices.length < 2) {return 0;}\\n        \\n        int increaseCount = 0, maxProfit = 0;\\n        boolean incraseFlag = false;\\n        for(int i = 1; i < prices.length; i++) {\\n            int tmp = prices[i] - prices[i - 1];\\n            if(tmp > 0) {\\n                increaseCount += incraseFlag? 0 : 1;\\n                incraseFlag = true;\\n                maxProfit += tmp;\\n            } else {incraseFlag = false;}\\n        }\\n        \\n        if(k >= increaseCount) {return maxProfit;}\\n        \\n        int[] costs = new int[k + 1];\\n        int[] profits = new int[k + 1];\\n        \\n        for(int i = 0; i <= k; i++) {costs[i] = Integer.MAX_VALUE;}\\n        \\n        for(int price : prices) {\\n            for(int i = 1; i <= k; i++) {\\n                costs[i] = Math.min(costs[i], price - profits[i - 1]);\\n                profits[i] = Math.max(profits[i], price - costs[i]);\\n            }\\n        }\\n        \\n        return profits[k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 405218,
                "title": "python-method-based-on-previous-work-and-easy-understanding",
                "content": "This solution is based on the previous work of problem 122 and 123.\\n* [Review problem 122](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)  ->  [My Solution](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/discuss/405107/2-python-methods-%3A-for-loop-using-elements-and-index)\\n* [Review problem 123](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)  ->   [My Solution](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/405165/python-method-%3A-dynamic-programming-keep-clean)\\n\\nIt divides into two parts : \\n~~~\\nif k >= len(prices) : # can garantee to sum all price \\n\\t   ### (problem 122)\\n\\nelse : # will have to choose largest interval between price difference\\n\\t   ### (problem 123)\\n~~~\\n\\nBefore viewing solution, I suggest you to firstly review the URL above in problem 122 and problem 123. You can have better understanding about the solution here.\\n```\\nclass Solution(object):\\n\\n    def maxProfit(self, k, prices):\\n        if not k or not prices: \\n            return 0\\n        \\n        l = len(prices)\\n        if k >= l/2: # The same case in 122. Best Time to Buy and Sell Stock II\\n            profit = 0\\n            for i in range(1, l):\\n                if prices[i] > prices[i-1]: # add each interval with earning price\\n                    profit += prices[i] - prices[i-1]\\n            return profit\\n\\n        # two list for recording each element dynamic programming\\n        # doing k times 123. Best Time to Buy and Sell Stock III\\n        \\n        buy = [prices[0]]+[0]*(l-1) # take first price as the lowest price\\n        sell = [0]*l\\n        for _ in range(k): # run k times\\n            for i in range(1, l):\\n                buy[i] = min(buy[i-1], prices[i]-buy[i]) # renew buy price\\n                sell[i] = max(sell[i-1], prices[i]-buy[i]) # renew accumulate sell price\\n            \\n            buy = [prices[0]]+sell[0:] # new shift\\n            sell = [0]*l # initialize for next k\\n        \\n        return buy[-1] # Because accumulate last price was store in buy list\\n```\\n\\nPlease feel free to leave a comment if you know how to well explain what it works. It would be helpful to all programmers to understand this problem and solution :)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n\\n    def maxProfit(self, k, prices):\\n        if not k or not prices: \\n            return 0\\n        \\n        l = len(prices)\\n        if k >= l/2: # The same case in 122. Best Time to Buy and Sell Stock II\\n            profit = 0\\n            for i in range(1, l):\\n                if prices[i] > prices[i-1]: # add each interval with earning price\\n                    profit += prices[i] - prices[i-1]\\n            return profit\\n\\n        # two list for recording each element dynamic programming\\n        # doing k times 123. Best Time to Buy and Sell Stock III\\n        \\n        buy = [prices[0]]+[0]*(l-1) # take first price as the lowest price\\n        sell = [0]*l\\n        for _ in range(k): # run k times\\n            for i in range(1, l):\\n                buy[i] = min(buy[i-1], prices[i]-buy[i]) # renew buy price\\n                sell[i] = max(sell[i-1], prices[i]-buy[i]) # renew accumulate sell price\\n            \\n            buy = [prices[0]]+sell[0:] # new shift\\n            sell = [0]*l # initialize for next k\\n        \\n        return buy[-1] # Because accumulate last price was store in buy list\\n```",
                "codeTag": "Java"
            },
            {
                "id": 396115,
                "title": "c-beats-100-time-and-space-detailed-explanation",
                "content": "I included my solution to Best Time to Buy and Sell Stock III as the solution to the current problem builds naturally off of the solution to the previous problem. I hope the comments are clear to others and not just myself. I absolutely hated solving this, so if you have any questions please feel free to comment here and I will try to walk you through it. I am considering making some videos on youtube about this entire series of problems because I spent so many hours trying to understand it, I want to save others from the pain!\\n\\n```\\n    public class Solution\\n    {\\n\\n        public int MaxProfit(int k, int[] prices)\\n        {\\n            // A transaction is defined as a Buy and a Sell\\n            if (prices == null || prices.Length == 0 || k == 0) return 0;\\n            int tranNumber = k * 2;\\n            int len = prices.Length;\\n            if (k >= len / 2) return QuickSolve(prices);\\n\\n            int[] dp = new int[tranNumber];\\n\\n            // Even indexed items in the array indicate purchases, odd indicate sales\\n            for (int i = 0; i < tranNumber; i++)\\n                dp[i] = i % 2 == 0 ? int.MinValue : 0;\\n\\n            foreach (int price in prices)\\n            {\\n                // the first item in the array indicates the amount of money\\n                // we have after the first day. Notice this value must be negative, \\n                // since on the first day we have no choice but to buy. \\n                dp[0] = Math.Max(dp[0], -price);\\n\\n                // On each day, we update all of our values for each of our possible transactions. \\n                for (int i = 1; i < tranNumber; i++)\\n                {\\n                    // Recall from earlier comment that even indexed values are purchases, hence we deduct the price \\n                    // of the stock from our total amount. (Think of it like \"I bought a $10 stock, therefor I have 10 less dollars)\\n                    int dif = i % 2 == 0 ? -price : price;\\n\\n                    // Now we have a choice to make. Is it better to simply hold with what we have,\\n                    // or is it better to apply the difference to the previous transacation? \\n                    // A further explanation of this is as follows....\\n\\n                    // I can apply today\\' buy or sell to my previous transaction, but I\\'ll only do that if \\n                    // I experience a net gain as a result. Otherwise, I\\'m not going to do anything - I\\'ll just hold with what I have\\n                    dp[i] = Math.Max(dp[i], dp[i - 1] + dif);\\n                }\\n            }\\n\\n            return dp[tranNumber - 1];\\n        }\\n\\n\\n        private int QuickSolve(int[] prices)\\n        {\\n            // If we reach here, it means we are allowed more transactions \\n            // then there are days, so we can just buy and sell for every single \\n            // valley and peak. \\n\\n            int len = prices.Length;\\n            int profit = 0;\\n            for (int i = 1; i < len; i++)\\n                if (prices[i] > prices[i - 1])\\n                    profit += prices[i] - prices[i - 1];\\n            return profit;\\n        }\\n\\n        // This is my solution to Best Time to Buy or sell stock III. \\n        // I\\'m including this as if you truly understand this,\\n        // the DP solution to Best Time to Buy or sell stock IV is simpler to understand.\\n        public int MaxProfit(int[] prices)\\n        {\\n            int firstPurchaseDebt = int.MinValue;\\n            int firstSaleProfit = 0;\\n            int secondPurchaseDebt = int.MinValue;\\n            int secondPurchaseProfit = 0;\\n\\n            foreach (int price in prices)\\n            {\\n                // This variable indicates our money holdings after the purchase of a stock.\\n                // For that reason, we update it using negative price, since on a purchase we SPEND MONEY\\n                firstPurchaseDebt = Math.Max(firstPurchaseDebt, -price);\\n\\n                // This variable indicates our money after we have sold a piece of stock. At each day, we either hold the value \\n                // that we already had in this variable (aka, do nothing), or we sell the current stock we are holding. \\n                // If we sell the current stock we are holding, then it is mathematically equivalent to saying \\n                // amountInWalletAfterPurchase + priceOfCurrentStock, since we will have a NEGATIVE in our wallet since we BOUGHT stock,\\n                // and by adding the current day\\'s price we get our new profit. \\n                firstSaleProfit = Math.Max(firstSaleProfit, firstPurchaseDebt + price);\\n\\n                // This variable indicates the amount of money we have left in our wallet after we use our profits from the first sale\\n                // to purchase the second stock. Mathematically, at each day we can either choose to do nothing (aka, take the value\\n                // that is already in the variable), or we can take our profits and reduce it by the amount of the current stock for sale. \\n                secondPurchaseDebt = Math.Max(secondPurchaseDebt, firstSaleProfit - price);\\n\\n                // This variable indicates the amount of money we hold after selling the second stock we purchased. Notice the two states. \\n                // In one case, we simply hold the value of the stock, aka, do nothing. If, however, our debt from the second purhcase, plus \\n                // the cost of the current stock is greater than what we currently have in this variable, then we sell the second stock. \\n                // Recall that secondPurchaseDebt is the total amount of money we have AFTER the purchase of a stock. Adding the price is mathematically \\n                // equivalent to saying (Price - current holdings after purchase of second stock)\\n                secondPurchaseProfit = Math.Max(secondPurchaseProfit, secondPurchaseDebt + price);\\n\\n                Console.WriteLine($\"Today\\'s price was {price}\");\\n                Console.WriteLine(\"At the end of the day, our values are: \");\\n                Console.WriteLine($\"FirstPurchaseDebt: {firstPurchaseDebt}, FirstSaleProfit:{firstSaleProfit}, SecondPurchaseDebt: {secondPurchaseDebt}, secondPurchasProfit: {secondPurchaseProfit}\");\\n                Console.WriteLine();\\n            }\\n\\n            return secondPurchaseProfit;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n\\n        public int MaxProfit(int k, int[] prices)\\n        {\\n            // A transaction is defined as a Buy and a Sell\\n            if (prices == null || prices.Length == 0 || k == 0) return 0;\\n            int tranNumber = k * 2;\\n            int len = prices.Length;\\n            if (k >= len / 2) return QuickSolve(prices);\\n\\n            int[] dp = new int[tranNumber];\\n\\n            // Even indexed items in the array indicate purchases, odd indicate sales\\n            for (int i = 0; i < tranNumber; i++)\\n                dp[i] = i % 2 == 0 ? int.MinValue : 0;\\n\\n            foreach (int price in prices)\\n            {\\n                // the first item in the array indicates the amount of money\\n                // we have after the first day. Notice this value must be negative, \\n                // since on the first day we have no choice but to buy. \\n                dp[0] = Math.Max(dp[0], -price);\\n\\n                // On each day, we update all of our values for each of our possible transactions. \\n                for (int i = 1; i < tranNumber; i++)\\n                {\\n                    // Recall from earlier comment that even indexed values are purchases, hence we deduct the price \\n                    // of the stock from our total amount. (Think of it like \"I bought a $10 stock, therefor I have 10 less dollars)\\n                    int dif = i % 2 == 0 ? -price : price;\\n\\n                    // Now we have a choice to make. Is it better to simply hold with what we have,\\n                    // or is it better to apply the difference to the previous transacation? \\n                    // A further explanation of this is as follows....\\n\\n                    // I can apply today\\' buy or sell to my previous transaction, but I\\'ll only do that if \\n                    // I experience a net gain as a result. Otherwise, I\\'m not going to do anything - I\\'ll just hold with what I have\\n                    dp[i] = Math.Max(dp[i], dp[i - 1] + dif);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 361168,
                "title": "sharing-my-thought-on-why-people-use-2-dp-arrays-and-the-thinking-process",
                "content": "I didn\\'t come up with the solution until I see the brilliant community\\'s fantastic answers. But what bothers me is - what\\'s the thinking process? Why do I need the global and local dp arrays? Below are my thinking process:\\n\\n1. there are only two conditions in a certain day: **you sell stocks at that day, or you don\\'t sell stocks at that day.** The best result would be the larger of the two.\\n2. For a given day, we can define an array global[k][i], indicating that the maximum profit till day i, and it has completed k transactions (not necessisarily conducted on day i). So global[k][i] would have some relationship with global[k][i-1] or global[k-1][i-1]. Ideally, global[k][i] should be the max of:\\na. the profit you can make when: in the previous i-1 days, you have completed all the k transactions (i.e. no transction on ith day)\\nb. the profit you can make when: in the previous i-1 days, you have completed k-1 trasactions, and in the ith day, you have completed the kth transaction (i.e. have transaction on ith day)\\na) is obviously global[k][i-1], however b) is not relevant to global array. So we would define another array local[k][i], indicating that the max profit that we can make when we completed k transactions in the first i days (and the last transaction is performed on ith day)\\n**Ah - so we actually need another array (aka local)**\\n\\n3. We now need to know how do we construct global and local array. For global array, it\\'s relatively easier. It would be:\\nglobal[k][i] = max(global[k][i-1], local[k][i]), corresponding to above (whether there\\'s transaction on day i)\\n\\n\\n4. How do we calculate local[k][i] then? Since we will conduct a transaction on day i (per definition), there would be two cases:\\nc. in the previous i-1 days, k-1 transactions have been completed (i.e. global[k-1][i-1]; the kth transaction would be performed on day i. There are two sub-cases here: if we define diff=price[i]-price[i-1], if diff > 0, we know we can make money in the last transaction; otherwise if diff <=0, we won\\'t be able to make money by buying at day i-1 and selling at day i, so we will just do buy and sell at day i, i.e. making 0 dollar. Overall, the max profit we can make for condition c) is: global[k-1][i-1]+max(diff, 0)\\nd. in the previous i-1 days, k transactions have been completed and the kth transaction is happening on day i-1 (i.e. local[k][i-1]. In this case, no matter what we have done on day i-1, we can always \"extend\" the last transaction to day i. For example, if you buy at price 2 and sell at price 3, and buy at price 3 (on the same day) and sell at price 4, which has 2 transactions, you can actually combine the two transactions and have just 1 transaction which is buy at price 2 and sell at price 4. Thru this, we know that we can always extend the last transaction from day i-1 to day i, and also add diff. So the max profit for d) is: local[k][i-1]+diff\\ne. Why don\\'t we consider a case where in the previous i-1 days, k transactions have been completed and kth transaction is NOT necessarily performed on day i-1 (following case d above)? This is already covered by global[k][i-1], which is one of the input for global[k][i].\\nSo for local[k][i] = max(global[k-1][i-1]+max(diff,0), local[k][i-1]+diff)\\n5. Lastly, pay attention to some implementation details:\\na. Note that the above approach uses O(kn) memory, but when k is very large and n is small, this can actually be reduced to the Stock II problem, where you can buy and sell stocks in unlimited time. This will help avoid some OOM issue\\nb. Also pay attention to the dp array. It should be (k+1)*n, since the k dimension would range from 0 to k which is k+1 numbers.\\n\\n\\n\\n```\\nclass Solution:\\n    def maxProfit(self, k: int, price: List[int]) -> int:\\n        n = len(price)\\n        if n <= 1 or k == 0:\\n            return 0\\n        if k> n/2:\\n            max_profit = 0\\n            for i in range(1,n):\\n                diff = price[i] - price[i-1]\\n                if diff > 0:\\n                    max_profit += diff\\n            return max_profit\\n        \\n        local_dp = [[0]*n for _ in range(k+1)]\\n        global_dp = [[0]*n for _ in range(k+1)]\\n        for i in range(1,n):\\n            diff = price[i] - price[i-1]\\n            for kk in range(1,k+1):\\n                local_dp[kk][i] = max(global_dp[kk-1][i-1]+max(diff,0), local_dp[kk][i-1]+diff)\\n                global_dp[kk][i] = max(global_dp[kk][i-1], local_dp[kk][i])\\n        return global_dp[-1][-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, k: int, price: List[int]) -> int:\\n        n = len(price)\\n        if n <= 1 or k == 0:\\n            return 0\\n        if k> n/2:\\n            max_profit = 0\\n            for i in range(1,n):\\n                diff = price[i] - price[i-1]\\n                if diff > 0:\\n                    max_profit += diff\\n            return max_profit\\n        \\n        local_dp = [[0]*n for _ in range(k+1)]\\n        global_dp = [[0]*n for _ in range(k+1)]\\n        for i in range(1,n):\\n            diff = price[i] - price[i-1]\\n            for kk in range(1,k+1):\\n                local_dp[kk][i] = max(global_dp[kk-1][i-1]+max(diff,0), local_dp[kk][i-1]+diff)\\n                global_dp[kk][i] = max(global_dp[kk][i-1], local_dp[kk][i])\\n        return global_dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 347479,
                "title": "python-solution-with-detailed-explanation",
                "content": "This problem can be solved by dynamic programming. Let r[i, j] denote the maximum profit at day i (starts at day 0) for at most j transactions. The recurrence relation can be defined as follows:\\n```\\nr[i, j] = max(r[i-1, j], max_{0 <= m <= i-1}(r[m, j-1] + p[i] - p[m]))  for i > 0 and j > 0,\\nr[i, j] = 0  if i = 0 or j = 0.\\n```\\n \\nThe value `max_{0 <= m <= i-1}(r[m, j-1] + p[i] - p[m])` can be computed efficiently using dynamic programming again. For all j > 0, we define s[i, j] as follows:\\n```\\ns[i, j] = max_{0 <= m <= i-1}(r[m, j] + p[i] - p[m])  for i > 0,\\ns[i, j] = 0  if i = 0,\\n```\\nwhere the case j = 0 uses the definition r[m, 0] = 0.\\n\\nWe can rewrite s recursively:\\n```\\ns[i, j] = max(r[i-1, j] + p[i] - p[i - 1], max_{0 <= m <= i-2}(r[m, j] + p[i] - p[m])).\\n```\\nSince \\n```\\nmax_{0 <= m <= i-2}(r[m, j] + p[i] - p[m]) = max_{0 <= m <= i-2}(s[i-1, j]) + p[i] - p[i-1],\\n```\\nwe have \\n```\\ns[i, j] = max(r[i-1, j], s[i-1, j]) + p[i] - p[i-1]  for i > 0. \\n```\\n\\nPutting everything together:\\n```\\nr[i, j] = max(r[i-1, j], s[i, j-1])  for i > 0 and j > 0,\\nr[i, j] = 0  if i = 0 or j = 0.\\n\\ns[i, j] = max(r[i-1, j], s[i-1, j]) + p[i] - p[i-1]  for i > 0 and j > 0,\\ns[i, j] = 0  if i = 0 or j = 0.\\n```\\n\\nThe answer is going to be r[n, k] if ended at the n-th day with at most k transactions.\\n \\nFinally, we can reduce space complexity by computing r and s in the bottom-up order that uses O(n) space for r and O(1) space for s. The overall time complexity is O(nk).\\n\\n```python\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        n = len(prices)\\n        \\n        if n == 0 or k == 0:\\n            return 0\\n        \\n        if k >= n // 2:\\n\\t\\t    # Same as 122: Best Time to Buy and Sell Stock II\\n            profit = 0\\n            for i in range(1, n):\\n                profit += max(prices[i] - prices[i - 1], 0)\\n            return profit\\n        \\n        r_cur = [0] * n\\n        r_pre = [0] * n\\n        \\n        # Convert prices to the difference between two consecutive values.\\n        for i in range(n - 1, 0, -1):\\n            prices[i] -= prices[i - 1]\\n            \\n        for j in range(k):\\n            r_cur[0] = s = 0\\n            for i in range(1, n):\\n                s = max(r_pre[i - 1], s) + prices[i]\\n                r_cur[i] = max(r_cur[i - 1], s)\\n            r_pre, r_cur = r_cur, r_pre\\n        return r_pre[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nr[i, j] = max(r[i-1, j], max_{0 <= m <= i-1}(r[m, j-1] + p[i] - p[m]))  for i > 0 and j > 0,\\nr[i, j] = 0  if i = 0 or j = 0.\\n```\n```\\ns[i, j] = max_{0 <= m <= i-1}(r[m, j] + p[i] - p[m])  for i > 0,\\ns[i, j] = 0  if i = 0,\\n```\n```\\ns[i, j] = max(r[i-1, j] + p[i] - p[i - 1], max_{0 <= m <= i-2}(r[m, j] + p[i] - p[m])).\\n```\n```\\nmax_{0 <= m <= i-2}(r[m, j] + p[i] - p[m]) = max_{0 <= m <= i-2}(s[i-1, j]) + p[i] - p[i-1],\\n```\n```\\ns[i, j] = max(r[i-1, j], s[i-1, j]) + p[i] - p[i-1]  for i > 0. \\n```\n```\\nr[i, j] = max(r[i-1, j], s[i, j-1])  for i > 0 and j > 0,\\nr[i, j] = 0  if i = 0 or j = 0.\\n\\ns[i, j] = max(r[i-1, j], s[i-1, j]) + p[i] - p[i-1]  for i > 0 and j > 0,\\ns[i, j] = 0  if i = 0 or j = 0.\\n```\n```python\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        n = len(prices)\\n        \\n        if n == 0 or k == 0:\\n            return 0\\n        \\n        if k >= n // 2:\\n\\t\\t    # Same as 122: Best Time to Buy and Sell Stock II\\n            profit = 0\\n            for i in range(1, n):\\n                profit += max(prices[i] - prices[i - 1], 0)\\n            return profit\\n        \\n        r_cur = [0] * n\\n        r_pre = [0] * n\\n        \\n        # Convert prices to the difference between two consecutive values.\\n        for i in range(n - 1, 0, -1):\\n            prices[i] -= prices[i - 1]\\n            \\n        for j in range(k):\\n            r_cur[0] = s = 0\\n            for i in range(1, n):\\n                s = max(r_pre[i - 1], s) + prices[i]\\n                r_cur[i] = max(r_cur[i - 1], s)\\n            r_pre, r_cur = r_cur, r_pre\\n        return r_pre[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343528,
                "title": "javascript-solution-dp-easy-understand",
                "content": "```\\n/**\\n * @param {number} k\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(k, prices) {\\n    if(prices.length < 2) return 0;\\n    if(k >= Math.floor(prices.length / 2)) {\\n        let max = 0;\\n        let min = prices[0];\\n        for(let i = 1; i < prices.length; i++) {\\n            if(prices[i] - min > 0) {\\n                max = max + prices[i] - min;\\n            }\\n            min = prices[i];\\n        }\\n        return max;\\n    } else {\\n        let buy = new Array(k + 1).fill(-Number.MAX_VALUE);\\n        let sell = new Array(k + 1).fill(0);\\n        for(let val of prices) {\\n            for(let i = 1; i <= k; i++) {\\n                buy[i] = Math.max(sell[i - 1] - val, buy[i]);\\n                sell[i] = Math.max(buy[i] + val, sell[i]);\\n            }\\n        }\\n        return sell[k];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} k\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(k, prices) {\\n    if(prices.length < 2) return 0;\\n    if(k >= Math.floor(prices.length / 2)) {\\n        let max = 0;\\n        let min = prices[0];\\n        for(let i = 1; i < prices.length; i++) {\\n            if(prices[i] - min > 0) {\\n                max = max + prices[i] - min;\\n            }\\n            min = prices[i];\\n        }\\n        return max;\\n    } else {\\n        let buy = new Array(k + 1).fill(-Number.MAX_VALUE);\\n        let sell = new Array(k + 1).fill(0);\\n        for(let val of prices) {\\n            for(let i = 1; i <= k; i++) {\\n                buy[i] = Math.max(sell[i - 1] - val, buy[i]);\\n                sell[i] = Math.max(buy[i] + val, sell[i]);\\n            }\\n        }\\n        return sell[k];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 275295,
                "title": "slow-but-easy-to-understand-java-solution-with-explanation",
                "content": "This problem is similar to [123. Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/). The previous problem define we can only make at most two transactions. In this problem, we can make at most k transactions.\\nSimilarly, we define two array ```sell``` and ```hold``` to record maximum profit where ```sell[i]``` is the maximum profit after selling stock ```i``` times and ```hold[i]``` is the maximum profit after buying stock ```i``` times. \\nSince we can only hold at most one stock at the same time, we can make at most ```prices.length / 2``` transactions. The length of ```sell``` and ```hold``` is ```max(k, prices.length / 2) + 1``` (If we don\\'t compare ```k``` and ```prices.length / 2```, MLE will occur).\\nNote that we should initiate elements in ```hold``` to ```Integer.MIN_VALUE``` (If we set ```hold[i]``` to zero, we won\\'t get correct answer). \\n\\n```\\npublic int maxProfit(int k, int[] prices) {\\n\\tint length = Math.min(k, prices.length / 2) + 1; // caculate the theoretically max transactions we can make\\n\\tint sell[] = new int[length];\\n\\tint hold[] = new int[length];\\n\\tfor(int i = 0; i < length; i++)\\n\\t\\thold[i] = Integer.MIN_VALUE;\\n\\tfor(int i = 0; i < prices.length; i++) {\\n\\t\\tfor(int j = length - 1; j >= 1; j--) { // index from high to low since hold[k] depends on sell[k - 1]\\n\\t\\t\\tsell[j] = Math.max(sell[j], hold[j] + prices[i]);\\n\\t\\t\\thold[j] = Math.max(hold[j], sell[j - 1] - prices[i]);\\n\\t\\t}\\n\\t}\\n\\treturn sell[length - 1];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```sell```\n```hold```\n```sell[i]```\n```i```\n```hold[i]```\n```i```\n```prices.length / 2```\n```sell```\n```hold```\n```max(k, prices.length / 2) + 1```\n```k```\n```prices.length / 2```\n```hold```\n```Integer.MIN_VALUE```\n```hold[i]```\n```\\npublic int maxProfit(int k, int[] prices) {\\n\\tint length = Math.min(k, prices.length / 2) + 1; // caculate the theoretically max transactions we can make\\n\\tint sell[] = new int[length];\\n\\tint hold[] = new int[length];\\n\\tfor(int i = 0; i < length; i++)\\n\\t\\thold[i] = Integer.MIN_VALUE;\\n\\tfor(int i = 0; i < prices.length; i++) {\\n\\t\\tfor(int j = length - 1; j >= 1; j--) { // index from high to low since hold[k] depends on sell[k - 1]\\n\\t\\t\\tsell[j] = Math.max(sell[j], hold[j] + prices[i]);\\n\\t\\t\\thold[j] = Math.max(hold[j], sell[j - 1] - prices[i]);\\n\\t\\t}\\n\\t}\\n\\treturn sell[length - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 193407,
                "title": "c-neat-fast-dp",
                "content": "```\\nclass Solution {\\nprivate:\\n    int maxProfitN(vector<int>& p) {\\n        int res = 0;\\n        for (int i = 1; i < p.size(); ++i) \\n            res += max(0, p[i] - p[i - 1]);\\n        return res;\\n    }\\n    \\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int buy = 0, i = 0, t = 0;\\n        int T = k, N = prices.size();\\n        \\n        if (T >= N/2)\\n            return maxProfitN(prices);\\n        \\n        if (N < 2)\\n            return 0;\\n        \\n        vector<vector<int>> maxp(T+1, vector<int>(N, 0));\\n        for(t = 1; t <= T; ++t) {\\n            buy = prices[0];\\n            for (i = 1; i < N; ++i) {\\n                maxp[t][i] = max(maxp[t][i-1], prices[i] - buy);\\n                buy = min(buy, prices[i] - maxp[t-1][i]);\\n            }\\n        }\\n        return maxp[T][N-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int maxProfitN(vector<int>& p) {\\n        int res = 0;\\n        for (int i = 1; i < p.size(); ++i) \\n            res += max(0, p[i] - p[i - 1]);\\n        return res;\\n    }\\n    \\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int buy = 0, i = 0, t = 0;\\n        int T = k, N = prices.size();\\n        \\n        if (T >= N/2)\\n            return maxProfitN(prices);\\n        \\n        if (N < 2)\\n            return 0;\\n        \\n        vector<vector<int>> maxp(T+1, vector<int>(N, 0));\\n        for(t = 1; t <= T; ++t) {\\n            buy = prices[0];\\n            for (i = 1; i < N; ++i) {\\n                maxp[t][i] = max(maxp[t][i-1], prices[i] - buy);\\n                buy = min(buy, prices[i] - maxp[t-1][i]);\\n            }\\n        }\\n        return maxp[T][N-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181377,
                "title": "using-state-machine",
                "content": "The idea is to use state machine to keep track of every possible profit\\nFor one transaction, we have two states: buying and selling\\nFor every state: we could stay, or buying/selling, but we should choose the maximum profit way\\nFor buying: we will pay stock price so profit -= stock price from last selling state\\nFor selling: we will earn money so profit += stock price from last buying state\\nFor rest: we remain same profit\\n\\nOne special case is that when k > prices.length / 2, in this case we could consider only prices.length / 2 possible transactions. ( K is so large that we could consider as unlimited transactions)\\n\\n```\\nclass Solution {\\n  public int maxProfit(int k, int[] prices) {\\n    if (k == 0 || prices.length == 0 || prices.length == 1) {\\n      return 0;\\n    }\\n    k = Math.min(k, prices.length / 2);\\n    int[] states = new int[k * 2];\\n    for (int i = 0; i < states.length; i++) {\\n      states[i] = Integer.MIN_VALUE;\\n    }\\n    for (int i = 0; i < prices.length; i++) {\\n      states[0] = Math.max(states[0], -prices[i]);\\n      for (int j = 1; j < states.length; j++) {\\n        if (j % 2 == 0) {\\n          states[j]= Math.max(states[j], states[j - 1] - prices[i]);\\n        } else {\\n          states[j] = Math.max(states[j], states[j - 1] + prices[i]);\\n        }\\n      }\\n    }\\n    return Math.max(states[k * 2 - 1], 0);\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public int maxProfit(int k, int[] prices) {\\n    if (k == 0 || prices.length == 0 || prices.length == 1) {\\n      return 0;\\n    }\\n    k = Math.min(k, prices.length / 2);\\n    int[] states = new int[k * 2];\\n    for (int i = 0; i < states.length; i++) {\\n      states[i] = Integer.MIN_VALUE;\\n    }\\n    for (int i = 0; i < prices.length; i++) {\\n      states[0] = Math.max(states[0], -prices[i]);\\n      for (int j = 1; j < states.length; j++) {\\n        if (j % 2 == 0) {\\n          states[j]= Math.max(states[j], states[j - 1] - prices[i]);\\n        } else {\\n          states[j] = Math.max(states[j], states[j - 1] + prices[i]);\\n        }\\n      }\\n    }\\n    return Math.max(states[k * 2 - 1], 0);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 154598,
                "title": "c-dp-solution-combining-the-excellent-code-and-ideas-of-the-genius",
                "content": "Combining the excellent code and ideas of the Genius.\\nTo avoid TLE, add a \"quickSolve\" function to tackle some corner cases.\\n\\nEasy to understand explanation for the below solution:\\ndp[i][j] = maximum profit from most i transactions using prices[0..j]\\nA transaction is defined as one buy + sell.\\nNow on day j, we have two options:\\n\\nDo nothing (or buy) which doesn\\'t change the acquired profit : dp[i][j] = dp[i][j-1]\\n\\nSell the stock: In order to sell the stock, you must\\'ve bought it on a day t=[0..j-1]. Maximum profit that can be attained is t:0->j-1 max(prices[j]-prices[t]+dp[i-1][t-1]) where prices[j]-prices[t] is the profit from buying on day t and selling on day j. dp[i-1][t-1] is the maximum profit that can be made with at most i-1 transactions with prices prices[0..t-1].\\n\\nTime complexity of this approach is O(n2k).\\n\\nIn order to reduce it to O(nk), we must find t:0->j-1 max(prices[j]-prices[t]+dp[i-1][t-1]) this expression in constant time. \\nIf you see carefully,\\nt:0->j-1 max(prices[j]-prices[t]+dp[i-1][t-1]) is same as\\nprices[j] + t:0->j-1 max(dp[i-1][t-1]-prices[t])\\n\\nSecond part of the below expression tmpMax = t:0->j-1 max(dp[i-1][t-1]-prices[t]) can be included in the dp loop by keeping track of the maximum value till j-1.\\n\\nBase case:\\n\\ndp[0][j] = 0; dp[i][0] = 0\\n\\nDP loop:\\n\\nfor i : 1 -> k\\n    tmpMax = -prices[0];\\n    for j : 1 -> n-1\\n        dp[i][j] = max(dp[i][j-1], prices[j]+tmpMax);\\n        tmpMax = max(tmpMax, dp[i-1][j-1]-prices[j]);\\nreturn dp[k][n-1];\\n\\nAC:\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int len = prices.size();\\n        if (k >= len / 2) return quickSolve(prices);\\n        vector<vector<int>> dp(k + 1, vector<int>(len));\\n        for (int i = 1; i <= k; ++i) {\\n            int tmpMax =  -prices[0];\\n            for (int j = 1; j < len; ++j) {\\n                dp[i][j] = max(dp[i][j - 1], prices[j] + tmpMax);\\n                tmpMax =  max(tmpMax, dp[i - 1][j - 1] - prices[j]);\\n            }\\n        }\\n        return dp[k][len - 1];\\n    }\\n\\n    int quickSolve(vector<int>& prices) {\\n        int profit = 0;\\n        for (int i = 1; i < prices.size(); ++i)\\n            // as long as there is a price gap, we gain a profit.\\n            if (prices[i] > prices[i - 1]) profit += prices[i] - prices[i - 1];\\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int len = prices.size();\\n        if (k >= len / 2) return quickSolve(prices);\\n        vector<vector<int>> dp(k + 1, vector<int>(len));\\n        for (int i = 1; i <= k; ++i) {\\n            int tmpMax =  -prices[0];\\n            for (int j = 1; j < len; ++j) {\\n                dp[i][j] = max(dp[i][j - 1], prices[j] + tmpMax);\\n                tmpMax =  max(tmpMax, dp[i - 1][j - 1] - prices[j]);\\n            }\\n        }\\n        return dp[k][len - 1];\\n    }\\n\\n    int quickSolve(vector<int>& prices) {\\n        int profit = 0;\\n        for (int i = 1; i < prices.size(); ++i)\\n            // as long as there is a price gap, we gain a profit.\\n            if (prices[i] > prices[i - 1]) profit += prices[i] - prices[i - 1];\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 122690,
                "title": "dp-solution-with-idea-of-finite-state-machine",
                "content": "I just like to present another idea of DP solution, which I didn\\'t find yet in the Discuss. \\n\\nTransaction is defined as two operations (buy and sell). And the question has a constraint that \"buy must precede the sell\" and \"no multiple transactions can be engaged at one day\". To take advantage of this constraint, We can model the question as a finite state machine. \\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/heronalps/image_1523144222.png)\\n\\nThe transaction function follows:\\n\\nHold[i] = Max(Hold[i], Sold[i - 1] - prices[i])\\nSold[i] = Max(Sold[i], Hold[i - 1] + prices[i])\\n\\ndp[i][Hold] equals to the max profit upon i day by holding the stock at the end.\\ndp[i][Sold] equals to the max profit upon i day by selling the stock at the end.\\n\\nLet\\'s take an example: [2, ,7, 3, 1, 5, 8, 9, 4, 13], 2. The dp array should be constructed like this at day 3:\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/heronalps/image_1523145107.png)\\n\\nEvery time a new price comes in play, we enlarge the dp array row-wise with two negative infinity and calculate backwards up to first operation. The dp array is updated at day 4 to the below:\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/heronalps/image_1523145341.png)\\n\\nNotice that the operation sequence has to be checkered, so odd operations could only be Hold and even operations can only be Sold. The final max profit must be within Sold column, which will be returned at the end. \\n\\nAs what the common solutions do, this one gets TLE without using pruning trick. The worst runtime is O(n * k). \\n\\nHappy coding!\\n\\n\\n\\tpublic int maxProfit(int k, int[] prices) {\\n\\t    if (k >= prices.length / 2) return max(prices);\\n\\t\\t\\t\\n        int rows = Math.min(2 * k, prices.length);\\n        int[][] dp = new int[rows + 1][2];\\n        dp[0][0] = dp[0][1] = 0;\\n        int max = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = Math.min(rows, i + 1); j >= 1; j--) {\\n                if (i + 1 <= rows && j == Math.min(rows, i + 1)) {\\n                    dp[j][0] = dp[j][1] = Integer.MIN_VALUE;\\n                }\\n                if (j % 2 == 1) {\\n                    dp[j][0] = Math.max(dp[j][0], dp[j - 1][1] - prices[i]);\\n                } \\n                else {\\n                    dp[j][1] = Math.max(dp[j][1], dp[j - 1][0] + prices[i]);\\n                    max = Math.max(max, dp[j][1]);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    private int max(int[] prices) {\\n        int sum = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            if (prices[i] > prices[i - 1]) {\\n                sum += prices[i] - prices[i - 1];\\n            }\\n        }\\n        return sum;\\n    }\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "I just like to present another idea of DP solution, which I didn\\'t find yet in the Discuss. \\n\\nTransaction is defined as two operations (buy and sell). And the question has a constraint that \"buy must precede the sell\" and \"no multiple transactions can be engaged at one day\". To take advantage of this constraint, We can model the question as a finite state machine. \\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/heronalps/image_1523144222.png)\\n\\nThe transaction function follows:\\n\\nHold[i] = Max(Hold[i], Sold[i - 1] - prices[i])\\nSold[i] = Max(Sold[i], Hold[i - 1] + prices[i])\\n\\ndp[i][Hold] equals to the max profit upon i day by holding the stock at the end.\\ndp[i][Sold] equals to the max profit upon i day by selling the stock at the end.\\n\\nLet\\'s take an example: [2, ,7, 3, 1, 5, 8, 9, 4, 13], 2. The dp array should be constructed like this at day 3:\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/heronalps/image_1523145107.png)\\n\\nEvery time a new price comes in play, we enlarge the dp array row-wise with two negative infinity and calculate backwards up to first operation. The dp array is updated at day 4 to the below:\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/heronalps/image_1523145341.png)\\n\\nNotice that the operation sequence has to be checkered, so odd operations could only be Hold and even operations can only be Sold. The final max profit must be within Sold column, which will be returned at the end. \\n\\nAs what the common solutions do, this one gets TLE without using pruning trick. The worst runtime is O(n * k). \\n\\nHappy coding!\\n\\n\\n\\tpublic int maxProfit(int k, int[] prices) {\\n\\t    if (k >= prices.length / 2) return max(prices);\\n\\t\\t\\t\\n        int rows = Math.min(2 * k, prices.length);\\n        int[][] dp = new int[rows + 1][2];\\n        dp[0][0] = dp[0][1] = 0;\\n        int max = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = Math.min(rows, i + 1); j >= 1; j--) {\\n                if (i + 1 <= rows && j == Math.min(rows, i + 1)) {\\n                    dp[j][0] = dp[j][1] = Integer.MIN_VALUE;\\n                }\\n                if (j % 2 == 1) {\\n                    dp[j][0] = Math.max(dp[j][0], dp[j - 1][1] - prices[i]);\\n                } \\n                else {\\n                    dp[j][1] = Math.max(dp[j][1], dp[j - 1][0] + prices[i]);\\n                    max = Math.max(max, dp[j][1]);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    private int max(int[] prices) {\\n        int sum = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            if (prices[i] > prices[i - 1]) {\\n                sum += prices[i] - prices[i - 1];\\n            }\\n        }\\n        return sum;\\n    }\\n\\n\\n\\n\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 54135,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Best Time to Buy and Sell Stock IV** https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/\\n\\n**Recursive DP Memoization Solution**\\n* f[k, i] represents the max profit up until prices[i] (Note: NOT ending with prices[i]) using at most k transactions.\\n* We can include price[i] or not include price[i]. \\n* Include price[i]: max(price[i]-price[j] + f(k-1,j-1)) for j in [0,i-1]\\n* Do not Include price[i]:f(k,i-1)\\n* f[k, i] = max(f[k, i-1], price[i]-price[j] + f[k-1, j-1]) (j in the range of 0 to i-1)\\n* f[k, i] = max(f[k, i-1], price[i] + max( f[k-1, j-1]--price[j])) (j in the range of 0 to i-1)\\n* f[0,i] = 0 (0 times transaction makes 0 profit)\\n* f[k,0] = 0 (if there is only one price data point you can't make any money no matter how many times you can trade)\\n\\n```\\nclass Solution(object):\\n    def maxProfit_as_many_transactions(self, prices):\\n        if prices == []:\\n            return 0\\n        profit, prev = 0, prices[0]\\n        for i in range(1,len(prices)):\\n            if prices[i] >= prices[i-1]:\\n                profit = profit + prices[i]-prices[i-1]\\n        return profit    \\n    \\n    def maxProfit(self, K, prices):\\n        \"\"\"\\n        :type k: int\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not prices:\\n            return 0\\n        K = min(K, len(prices)-1)\\n        if K == 0:\\n            return 0\\n        if K >= len(prices)//2:\\n            return self.maxProfit_as_many_transactions(prices)\\n        N = len(prices)\\n        dp = [[0]*N for _ in range(K+1)]\\n        for k in range(1, K+1):\\n            tmpMax = - prices[0]\\n            for i in range(1, N):\\n                dp[k][i] = max(dp[k][i-1], prices[i] + tmpMax)\\n                # f[k, i] = max(f[k, i-1], price[i] + max(f[k-1, j-1]--price[j])) \\n                # max(f[k-1, j-1]--price[j]) => tmpMax\\n                tmpMax = max(tmpMax, dp[k-1][i-1] - prices[i])\\n        return dp[K][N-1]        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxProfit_as_many_transactions(self, prices):\\n        if prices == []:\\n            return 0\\n        profit, prev = 0, prices[0]\\n        for i in range(1,len(prices)):\\n            if prices[i] >= prices[i-1]:\\n                profit = profit + prices[i]-prices[i-1]\\n        return profit    \\n    \\n    def maxProfit(self, K, prices):\\n        \"\"\"\\n        :type k: int\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not prices:\\n            return 0\\n        K = min(K, len(prices)-1)\\n        if K == 0:\\n            return 0\\n        if K >= len(prices)//2:\\n            return self.maxProfit_as_many_transactions(prices)\\n        N = len(prices)\\n        dp = [[0]*N for _ in range(K+1)]\\n        for k in range(1, K+1):\\n            tmpMax = - prices[0]\\n            for i in range(1, N):\\n                dp[k][i] = max(dp[k][i-1], prices[i] + tmpMax)\\n                # f[k, i] = max(f[k, i-1], price[i] + max(f[k-1, j-1]--price[j])) \\n                # max(f[k-1, j-1]--price[j]) => tmpMax\\n                tmpMax = max(tmpMax, dp[k-1][i-1] - prices[i])\\n        return dp[K][N-1]        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 54155,
                "title": "cpp-o-kn-time-and-o-k-space",
                "content": "This method is derived from III question and II question\\n\\n```\\n// O(kn) O(k)\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        if (prices.size() < 2 || k < 1) return 0;\\n        if (k > prices.size() / 2) return greedy(prices);\\n        vector<int> buy(k, INT_MIN), sell(k, 0);\\n        for (auto p : prices) {\\n            buy[0] = max(buy[0], -p);\\n            sell[0] = max(sell[0], buy[0] + p);\\n            for (int i = 1; i < k; i++) {\\n                buy[i] = max(buy[i], sell[i - 1] - p);\\n                sell[i] = max(sell[i], buy[i] + p);\\n            }\\n        }\\n        return sell[k - 1];\\n    }\\nprivate:\\n    int greedy(vector<int>& prices) {\\n        int profit = 0;\\n        for (int i = 1; i < prices.size(); i++) {\\n            profit += (prices[i] > prices[i - 1]) ? (prices[i] - prices[i - 1]) : 0;\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// O(kn) O(k)\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        if (prices.size() < 2 || k < 1) return 0;\\n        if (k > prices.size() / 2) return greedy(prices);\\n        vector<int> buy(k, INT_MIN), sell(k, 0);\\n        for (auto p : prices) {\\n            buy[0] = max(buy[0], -p);\\n            sell[0] = max(sell[0], buy[0] + p);\\n            for (int i = 1; i < k; i++) {\\n                buy[i] = max(buy[i], sell[i - 1] - p);\\n                sell[i] = max(sell[i], buy[i] + p);\\n            }\\n        }\\n        return sell[k - 1];\\n    }\\nprivate:\\n    int greedy(vector<int>& prices) {\\n        int profit = 0;\\n        for (int i = 1; i < prices.size(); i++) {\\n            profit += (prices[i] > prices[i - 1]) ? (prices[i] - prices[i - 1]) : 0;\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54167,
                "title": "java-solution-in-o-n-time-and-o-k-space",
                "content": "Extended from Best Time to Buy and Sell Stock III.\\n\\n```\\n    public int maxProfit(int k, int[] prices) {\\n        if(prices.length ==0){\\n            return 0;\\n        }\\n        \\n        if(k>=prices.length/2){\\n            int maxProfit = 0;\\n            for(int i=1; i<prices.length; i++){\\n                maxProfit += Math.max(0, prices[i]-prices[i-1]);\\n            }\\n            return maxProfit;\\n        }\\n        \\n        int[] buy = new int[k+1];  //profit after buying at k-th transaction\\n        int[] sell = new int[k+1];  //profit at k-th transaction\\n        Arrays.fill(buy, Integer.MIN_VALUE);\\n        Arrays.fill(sell, 0);\\n        for(int price : prices){\\n            for(int i = 1; i<=k;i++){\\n                buy[i] = Math.max(buy[i], sell[i-1]- price);\\n                sell[i] = Math.max(sell[i], buy[i] + price);\\n            }\\n        }\\n        \\n        return sell[k];\\n    }\\n````",
                "solutionTags": [],
                "code": "```\\n    public int maxProfit(int k, int[] prices) {\\n        if(prices.length ==0){\\n            return 0;\\n        }\\n        \\n        if(k>=prices.length/2){\\n            int maxProfit = 0;\\n            for(int i=1; i<prices.length; i++){\\n                maxProfit += Math.max(0, prices[i]-prices[i-1]);\\n            }\\n            return maxProfit;\\n        }\\n        \\n        int[] buy = new int[k+1];  //profit after buying at k-th transaction\\n        int[] sell = new int[k+1];  //profit at k-th transaction\\n        Arrays.fill(buy, Integer.MIN_VALUE);\\n        Arrays.fill(sell, 0);\\n        for(int price : prices){\\n            for(int i = 1; i<=k;i++){\\n                buy[i] = Math.max(buy[i], sell[i-1]- price);\\n                sell[i] = Math.max(sell[i], buy[i] + price);\\n            }\\n        }\\n        \\n        return sell[k];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 54161,
                "title": "2-ms-java-dp-solution-beats-99-87",
                "content": "The basic idea is similar to solution here: https://leetcode.com/discuss/75785/2ms-java-dp-solution\\n\\nI generalized it to K transactions.\\n\\n    public class Solution {\\n        public int maxProfit(int k, int[] prices) {\\n            if (k <= 0 || prices == null || prices.length <= 0) return 0;\\n            if (k > prices.length / 2) { // in this case, it's the same problem as Best Time to Buy & Sell Stock II\\n                int max = 0;\\n                for (int i = 0; i < prices.length - 1; i++) {\\n                    int diff = prices[i + 1] - prices[i];\\n                    max += diff>0 ? diff : 0;\\n                }\\n                return max;\\n            } else {\\n                int [] buy = new int[k];\\n                int [] sell = new int[k];\\n                \\n                Arrays.fill(buy, Integer.MIN_VALUE);\\n                \\n                for (int price: prices) {\\n                    int tmp = 0;\\n                    for (int i = 0; i < k; i ++) {\\n                        int buffer = 0;                          // used to avoid duplicate calculation\\n                        buffer = tmp - price;\\n                        if (buy[i] < buffer) buy[i] = buffer;\\n                        \\n                        buffer = buy[i] + price;\\n                        if (sell[i] < buffer) sell[i] = buffer;\\n                        tmp = sell[i];\\n                    }\\n                }\\n                \\n                return sell[k - 1];\\n            }\\n            \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maxProfit(int k, int[] prices) {\\n            if (k <= 0 || prices == null || prices.length <= 0) return 0;\\n            if (k > prices.length / 2) { // in this case, it's the same problem as Best Time to Buy & Sell Stock II\\n                int max = 0;\\n                for (int i = 0; i < prices.length - 1; i++) {\\n                    int diff = prices[i + 1] - prices[i];\\n                    max += diff>0 ? diff : 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 54217,
                "title": "my-simple-c-dp-soluton-8ms",
                "content": "It is still similar to the previous stock problems: use DP and define an array of states to track the maximum margin that state can make.\\n\\n - states[0] : no buy/sell operation at all, so always 0 \\n - states[1] : one buy/no sell \\n - states[2] : one buy/one sell \\n...\\n - states[2i] : i buy/i sell \\n - states[2i+1] : i+1 buy/i sell \\n...\\n\\nOne trick to play is to maximize the margin, all buy operations should be executed at local minimum points and all sell operations should be executed at local maximum points. So first the function findMinMax is called to detect local min and local max (save minP and maxP) and calculate sum(maxP-minP). If the number of local maximum points is no larger than k, then we should operate at all the maxP points and the maximum margin we can make is sum(maxP-minP). Otherwise, we need to run DP via a finite state machine using the state definition provided as above. The FSM is implemented in the function FSM_stock. Hopefully, the size of maxP is much less than the size of prices, so we can reduce the execution time.\\n\\n    class Solution {\\n    private:\\n        int findMinMax(const vector<int>& prices, vector<int>& minP, vector<int>& maxP)\\n        {\\n            int i, len = prices.size(), res = 0;\\n            for(i=0; i<len-1; i++)\\n            {\\n                while(i<len-1 && prices[i+1] <= prices[i]) i++; // detect the local minimum points\\n                if(i<len-1) minP.push_back(prices[i]);\\n                else break;\\n                while(i<len-1 && prices[i+1] >= prices[i]) i++; // detect the local maximum points\\n                maxP.push_back(prices[i]);\\n                res +=maxP.back()-minP.back(); // res  = sum(maxP - minP), the maximum margin we can make\\n            }\\n            return res;\\n        }\\n        \\n        int FSM_stock(vector<int>& minP, vector<int>& maxP, int k)\\n        {\\n                int states[2][1+2*k], i, j, cur =0, next =1, res =0, numMax = maxP.size();\\n                fill_n(&states[0][1], 2*k, INT_MIN/2);\\n                states[0][0] = states[1][0] = 0;\\n    \\n                for(i=0; i<numMax;++i)\\n                {\\n                    for(j=0; j<k; ++j)  \\n                    { // only buy at the local minimum points\\n                        states[next][j*2+1] = max(states[cur][j*2+1], states[cur][j*2]-minP[i]); \\n                        states[next][j*2+2] = states[cur][j*2+2];\\n                    }\\n                    swap(cur, next);\\n                    for(j=1; j<=k; ++j) \\n                    { // only sell at the local maximum points\\n                        states[next][j*2] = max(states[cur][j*2], states[cur][j*2-1] + maxP[i]);\\n                        states[next][j*2-1] = states[cur][j*2-1];\\n                    }\\n                    swap(cur, next);\\n                }\\n                for(i=1; i<=k;++i) res = max(res, states[cur][i*2]);\\n                return res;\\n        }\\n        \\n    public:\\n        int maxProfit(int k, vector<int>& prices) {\\n    \\n            vector<int> minP, maxP;\\n            \\n            int res = findMinMax(prices, minP, maxP);\\n            if(maxP.size() <= k) return res;\\n            else\\n                return FSM_stock(minP, maxP, k);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    private:\\n        int findMinMax(const vector<int>& prices, vector<int>& minP, vector<int>& maxP)\\n        {\\n            int i, len = prices.size(), res = 0;\\n            for(i=0; i<len-1; i++)\\n            {\\n                while(i<len-1 && prices[i+1] <= prices[i]) i++; // detect the local minimum points\\n                if(i<len-1) minP.push_back(prices[i]);\\n                else break;\\n                while(i<len-1 && prices[i+1] >= prices[i]) i++; // detect the local maximum points\\n                maxP.push_back(prices[i]);\\n                res +=maxP.back()-minP.back(); // res  = sum(maxP - minP), the maximum margin we can make\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 54226,
                "title": "not-elegant-but-easy-to-understand-15ms",
                "content": "\\n\\nThe idea is to calculate the maximum profit (unlimited transactions), then reduce the number of transactions by either deleting or combing transactions.    \\n\\n    class Solution {\\n        public:\\n            int maxProfit(int k, vector<int>& prices) {\\n                if(prices.size()<=1 || k==0)\\n                    return 0;\\n                vector<int> lowPrices;\\n                vector<int> highPrices;\\n                for(int i=0; i<prices.size(); ++i){\\n                    if((i==0 && prices[i] < prices[i+1]) || (i>0 && i<prices.size()-1 && prices[i]<=prices[i-1] && prices[i+1] >prices[i])){\\n                        if(lowPrices.size() == highPrices.size())\\n                            lowPrices.push_back(prices[i]);\\n                    }\\n                    if((i==prices.size()-1 && prices[i] >= prices[i-1]) || (i>0 && i<prices.size()-1 && prices[i]>=prices[i-1] && prices[i+1] < prices[i])){\\n                        if(lowPrices.size() > highPrices.size())\\n                            highPrices.push_back(prices[i]);\\n                    }\\n                }      \\n                int profit = 0;\\n                for(int i=0; i<lowPrices.size(); ++i)\\n                    profit += highPrices[i] - lowPrices[i];\\n                if(k >= lowPrices.size() || profit == 0)\\n                    return profit;           \\n                int count = lowPrices.size() - k;\\n                //either delete some transactions or combine neighbor transactions\\n                while(count > 0){\\n                    int delLoss = INT_MAX;\\n                    int delIndex;\\n                    int comLoss = INT_MAX;\\n                    pair<int, int> comPair;\\n                    for(int i=0; i<lowPrices.size(); ++i){\\n                        if(lowPrices[i]!=-1 && highPrices[i]-lowPrices[i]<delLoss){\\n                            delIndex = i;\\n                            delLoss = highPrices[i]-lowPrices[i];\\n                        }\\n                        if(lowPrices[i] != -1){\\n                            int j = i+1;\\n                            while(j<lowPrices.size() && lowPrices[j] == -1)\\n                                ++j;\\n                            if(j<lowPrices.size() && (highPrices[i]-lowPrices[j] < comLoss)){\\n                                comLoss = highPrices[i]-lowPrices[j];\\n                                comPair.first = i;\\n                                comPair.second = j;\\n                            }\\n                        }\\n                    }\\n                    if(delLoss <= comLoss){\\n                        lowPrices[delIndex] = -1;\\n                        profit -= delLoss;\\n                    }\\n                    else{\\n                        highPrices[comPair.first] = highPrices[comPair.second];\\n                        lowPrices[comPair.second] = -1;\\n                        profit -= comLoss;\\n                    }\\n                    --count;\\n                }\\n                return profit;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int maxProfit(int k, vector<int>& prices) {\\n                if(prices.size()<=1 || k==0)\\n                    return 0;\\n                vector<int> lowPrices;\\n                vector<int> highPrices;\\n                for(int i=0; i<prices.size(); ++i){\\n                    if((i==0 && prices[i] < prices[i+1]) || (i>0 && i<prices.size()-1 && prices[i]<=prices[i-1] && prices[i+1] >prices[i])){\\n                        if(lowPrices.size() == highPrices.size())\\n                            lowPrices.push_back(prices[i]);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3930523,
                "title": "python-dp-recursion-space-optimization",
                "content": "```\\n\\n#Recursion \\n#Time Complexity: O(2^n)\\n#Space Complexity: O(n)\\nclass Solution1:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        def solve(ind,buy,cap):\\n            if ind==n or cap==0:\\n                return 0\\n            profit=0\\n            if buy==0: # buy a stock\\n                take=-prices[ind]+solve(ind+1,1,cap)\\n                not_take=0+solve(ind+1,0,cap)\\n                profit=max(take,not_take)\\n            else: # sell a stock\\n                take=prices[ind]+solve(ind+1,0,cap-1)\\n                not_take=0+solve(ind+1,1,cap)\\n                profit=max(take,not_take)\\n            return profit\\n        n=len(prices)\\n        return solve(0,0,k)\\n\\n#Memoization (Top-Down)\\n#Time Complexity: O(n^2)\\n#Space Complexity: O(n*2*3) + O(n)\\nclass Solution2:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        def solve(ind,buy,cap):\\n            if ind==n or cap==0:\\n                return 0\\n            if dp[ind][buy][cap]!=-1:\\n                return dp[ind][buy][cap]\\n            profit=0\\n            if buy==0:\\n                take=-prices[ind]+solve(ind+1,1,cap)\\n                not_take=0+solve(ind+1,0,cap)\\n                profit=max(take,not_take)\\n            else:\\n                take=prices[ind]+solve(ind+1,0,cap-1)\\n                not_take=0+solve(ind+1,1,cap)\\n                profit=max(take,not_take)\\n            dp[ind][buy][cap]=profit\\n            return dp[ind][buy][cap]\\n        n=len(prices)\\n        dp=[[[ -1 for _ in range(k+1)] for _ in range(2)] for _ in range(n)]\\n        return solve(0,0,k)\\n    \\n#Tabulation (Bottom-Up)\\n#Time Complexity: O(n^2)\\n#Space Complexity: O(n*2*3)\\nclass Solution3:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        n=len(prices)\\n        dp=[[[0 for _ in range(k+1)] for _ in range(2)] for _ in range(n+1)]\\n        for ind in range(n-1,-1,-1):\\n            for buy in range(2):\\n                for cap in range(1,k+1):\\n                    profit=0\\n                    if buy==0:\\n                        take=-prices[ind]+dp[ind+1][1][cap]\\n                        not_take=0+dp[ind+1][0][cap]\\n                        profit=max(take,not_take)\\n                    else:\\n                        take=prices[ind]+dp[ind+1][0][cap-1]\\n                        not_take=0+dp[ind+1][1][cap]\\n                        profit=max(take,not_take)\\n                    dp[ind][buy][cap]=profit\\n        return dp[0][0][k]\\n\\n#Space Optimization\\n#Time Complexity: O(n^2)\\n#Space Complexity: O(1)\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        n=len(prices)\\n        ahead=[[0]*(k+1) for _ in range(2)]\\n        curr=[[0]*(k+1) for _ in range(2)]\\n        for ind in range(n-1,-1,-1):\\n            for buy in range(2):\\n                for cap in range(1,k+1):\\n                    profit=0\\n                    if buy==0:\\n                        take=-prices[ind]+ahead[1][cap]\\n                        not_take=0+ahead[0][cap]\\n                        profit=max(take,not_take)\\n                    else:\\n                        take=prices[ind]+ahead[0][cap-1]\\n                        not_take=0+ahead[1][cap]\\n                        profit=max(take,not_take)\\n                    curr[buy][cap]=profit\\n            ahead=curr\\n        return curr[0][k]\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\n#Recursion \\n#Time Complexity: O(2^n)\\n#Space Complexity: O(n)\\nclass Solution1:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        def solve(ind,buy,cap):\\n            if ind==n or cap==0:\\n                return 0\\n            profit=0\\n            if buy==0: # buy a stock\\n                take=-prices[ind]+solve(ind+1,1,cap)\\n                not_take=0+solve(ind+1,0,cap)\\n                profit=max(take,not_take)\\n            else: # sell a stock\\n                take=prices[ind]+solve(ind+1,0,cap-1)\\n                not_take=0+solve(ind+1,1,cap)\\n                profit=max(take,not_take)\\n            return profit\\n        n=len(prices)\\n        return solve(0,0,k)\\n\\n#Memoization (Top-Down)\\n#Time Complexity: O(n^2)\\n#Space Complexity: O(n*2*3) + O(n)\\nclass Solution2:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        def solve(ind,buy,cap):\\n            if ind==n or cap==0:\\n                return 0\\n            if dp[ind][buy][cap]!=-1:\\n                return dp[ind][buy][cap]\\n            profit=0\\n            if buy==0:\\n                take=-prices[ind]+solve(ind+1,1,cap)\\n                not_take=0+solve(ind+1,0,cap)\\n                profit=max(take,not_take)\\n            else:\\n                take=prices[ind]+solve(ind+1,0,cap-1)\\n                not_take=0+solve(ind+1,1,cap)\\n                profit=max(take,not_take)\\n            dp[ind][buy][cap]=profit\\n            return dp[ind][buy][cap]\\n        n=len(prices)\\n        dp=[[[ -1 for _ in range(k+1)] for _ in range(2)] for _ in range(n)]\\n        return solve(0,0,k)\\n    \\n#Tabulation (Bottom-Up)\\n#Time Complexity: O(n^2)\\n#Space Complexity: O(n*2*3)\\nclass Solution3:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        n=len(prices)\\n        dp=[[[0 for _ in range(k+1)] for _ in range(2)] for _ in range(n+1)]\\n        for ind in range(n-1,-1,-1):\\n            for buy in range(2):\\n                for cap in range(1,k+1):\\n                    profit=0\\n                    if buy==0:\\n                        take=-prices[ind]+dp[ind+1][1][cap]\\n                        not_take=0+dp[ind+1][0][cap]\\n                        profit=max(take,not_take)\\n                    else:\\n                        take=prices[ind]+dp[ind+1][0][cap-1]\\n                        not_take=0+dp[ind+1][1][cap]\\n                        profit=max(take,not_take)\\n                    dp[ind][buy][cap]=profit\\n        return dp[0][0][k]\\n\\n#Space Optimization\\n#Time Complexity: O(n^2)\\n#Space Complexity: O(1)\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        n=len(prices)\\n        ahead=[[0]*(k+1) for _ in range(2)]\\n        curr=[[0]*(k+1) for _ in range(2)]\\n        for ind in range(n-1,-1,-1):\\n            for buy in range(2):\\n                for cap in range(1,k+1):\\n                    profit=0\\n                    if buy==0:\\n                        take=-prices[ind]+ahead[1][cap]\\n                        not_take=0+ahead[0][cap]\\n                        profit=max(take,not_take)\\n                    else:\\n                        take=prices[ind]+ahead[0][cap-1]\\n                        not_take=0+ahead[1][cap]\\n                        profit=max(take,not_take)\\n                    curr[buy][cap]=profit\\n            ahead=curr\\n        return curr[0][k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725364,
                "title": "java-recursion-memoization-tabulation-and-space-optimization-approaches",
                "content": "# Description\\n\\nAlso Check out previous solutions\\nPart 3 :- https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/3723973/java-recursive-memoization-tabulation-and-space-optimization-approach-using-3d-dp/\\n\\nPart 2 :- https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/3723894/java-recursion-memoization-tabulation-space-optimization-and-one-pass-method-solution/\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        // return helper(prices, 0, 1, k);\\n\\n        // int[][][] dp = new int[prices.length + 1][2][k + 1];\\n        // for(int[][] row : dp) for(int[] col : row) Arrays.fill(col, -1);\\n        // return helperMem(prices, 0, 1, k, dp);\\n\\n        // return helperTab(prices, k);\\n\\n        return helperSO(prices, k);\\n    }\\n\\n    // Recursion Method\\n    public int helper(int[] prices, int index, int buy, int limit){\\n        // Base Case\\n        if(index == prices.length) return 0;\\n        if(limit == 0) return 0;\\n\\n        int totalProfit = 0;\\n        if(buy == 1){\\n            int buyKaro = -prices[index] + helper(prices, index + 1, 0, limit);\\n            int skipKaro = helper(prices, index + 1, 1, limit);\\n            totalProfit = Math.max(buyKaro, skipKaro);\\n        }else{\\n            int sellKaro = prices[index] + helper(prices, index + 1, 1, limit - 1);\\n            int skipKaro = helper(prices, index + 1, 0, limit);\\n            totalProfit = Math.max(sellKaro, skipKaro);\\n        }\\n        return totalProfit;\\n    }\\n\\n    // Memoization Method\\n    public int helperMem(int[] prices, int index, int buy, int limit, int[][][] dp){\\n        // Base Case\\n        if(index == prices.length) return 0;\\n        if(limit == 0) return 0;\\n\\n        if(dp[index][buy][limit] != -1) return dp[index][buy][limit];\\n        int totalProfit = 0;\\n        if(buy == 1){\\n            int buyKaro = -prices[index] + helperMem(prices, index + 1, 0, limit, dp);\\n            int skipKaro = helperMem(prices, index + 1, 1, limit, dp);\\n            totalProfit = Math.max(buyKaro, skipKaro);\\n        }else{\\n            int sellKaro = prices[index] + helperMem(prices, index + 1, 1, limit - 1, dp);\\n            int skipKaro = helperMem(prices, index + 1, 0, limit, dp);\\n            totalProfit = Math.max(sellKaro, skipKaro);\\n        }\\n        return dp[index][buy][limit] = totalProfit;\\n    }\\n\\n    // Tabulation Method\\n    public int helperTab(int[] prices, int k){\\n        int[][][] dp = new int[prices.length + 1][2][k + 1];\\n        for(int[][] row : dp) for(int[] col : row) Arrays.fill(col, 0);\\n\\n        for(int index = prices.length - 1; index >= 0; index--){\\n            for(int buy = 0; buy < 2; buy++){\\n                for(int limit = 1; limit < k + 1; limit++){\\n                    int totalProfit = 0;\\n                    if(buy == 1){\\n                        int buyKaro = -prices[index] + dp[index + 1][0][limit];\\n                        int skipKaro = dp[index + 1][1][limit];\\n                        totalProfit = Math.max(buyKaro, skipKaro);\\n                    }else{\\n                        int sellKaro = prices[index] + dp[index + 1][1][limit - 1];\\n                        int skipKaro = dp[index + 1][0][limit];\\n                        totalProfit = Math.max(sellKaro, skipKaro);\\n                    }\\n                    dp[index][buy][limit] = totalProfit;\\n                }\\n            }\\n        }\\n        return dp[0][1][k];\\n    }\\n\\n    // Space Optimization Method\\n    public int helperSO(int[] prices, int k){\\n        int[][] curr = new int[2][k + 1];\\n        int[][] next = new int[2][k + 1];\\n        for(int[] row : curr) Arrays.fill(row, 0);\\n        for(int[] row : next) Arrays.fill(row, 0);\\n\\n        for(int index = prices.length - 1; index >= 0; index--){\\n            for(int buy = 0; buy < 2; buy++){\\n                for(int limit = 1; limit < k + 1; limit++){\\n                    int totalProfit = 0;\\n                    if(buy == 1){\\n                        int buyKaro = -prices[index] + next[0][limit];\\n                        int skipKaro = next[1][limit];\\n                        totalProfit = Math.max(buyKaro, skipKaro);\\n                    }else{\\n                        int sellKaro = prices[index] + next[1][limit - 1];\\n                        int skipKaro = next[0][limit];\\n                        totalProfit = Math.max(sellKaro, skipKaro);\\n                    }\\n                    curr[buy][limit] = totalProfit;\\n                }\\n            }\\n            next = curr.clone();\\n        }\\n        return next[1][k];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        // return helper(prices, 0, 1, k);\\n\\n        // int[][][] dp = new int[prices.length + 1][2][k + 1];\\n        // for(int[][] row : dp) for(int[] col : row) Arrays.fill(col, -1);\\n        // return helperMem(prices, 0, 1, k, dp);\\n\\n        // return helperTab(prices, k);\\n\\n        return helperSO(prices, k);\\n    }\\n\\n    // Recursion Method\\n    public int helper(int[] prices, int index, int buy, int limit){\\n        // Base Case\\n        if(index == prices.length) return 0;\\n        if(limit == 0) return 0;\\n\\n        int totalProfit = 0;\\n        if(buy == 1){\\n            int buyKaro = -prices[index] + helper(prices, index + 1, 0, limit);\\n            int skipKaro = helper(prices, index + 1, 1, limit);\\n            totalProfit = Math.max(buyKaro, skipKaro);\\n        }else{\\n            int sellKaro = prices[index] + helper(prices, index + 1, 1, limit - 1);\\n            int skipKaro = helper(prices, index + 1, 0, limit);\\n            totalProfit = Math.max(sellKaro, skipKaro);\\n        }\\n        return totalProfit;\\n    }\\n\\n    // Memoization Method\\n    public int helperMem(int[] prices, int index, int buy, int limit, int[][][] dp){\\n        // Base Case\\n        if(index == prices.length) return 0;\\n        if(limit == 0) return 0;\\n\\n        if(dp[index][buy][limit] != -1) return dp[index][buy][limit];\\n        int totalProfit = 0;\\n        if(buy == 1){\\n            int buyKaro = -prices[index] + helperMem(prices, index + 1, 0, limit, dp);\\n            int skipKaro = helperMem(prices, index + 1, 1, limit, dp);\\n            totalProfit = Math.max(buyKaro, skipKaro);\\n        }else{\\n            int sellKaro = prices[index] + helperMem(prices, index + 1, 1, limit - 1, dp);\\n            int skipKaro = helperMem(prices, index + 1, 0, limit, dp);\\n            totalProfit = Math.max(sellKaro, skipKaro);\\n        }\\n        return dp[index][buy][limit] = totalProfit;\\n    }\\n\\n    // Tabulation Method\\n    public int helperTab(int[] prices, int k){\\n        int[][][] dp = new int[prices.length + 1][2][k + 1];\\n        for(int[][] row : dp) for(int[] col : row) Arrays.fill(col, 0);\\n\\n        for(int index = prices.length - 1; index >= 0; index--){\\n            for(int buy = 0; buy < 2; buy++){\\n                for(int limit = 1; limit < k + 1; limit++){\\n                    int totalProfit = 0;\\n                    if(buy == 1){\\n                        int buyKaro = -prices[index] + dp[index + 1][0][limit];\\n                        int skipKaro = dp[index + 1][1][limit];\\n                        totalProfit = Math.max(buyKaro, skipKaro);\\n                    }else{\\n                        int sellKaro = prices[index] + dp[index + 1][1][limit - 1];\\n                        int skipKaro = dp[index + 1][0][limit];\\n                        totalProfit = Math.max(sellKaro, skipKaro);\\n                    }\\n                    dp[index][buy][limit] = totalProfit;\\n                }\\n            }\\n        }\\n        return dp[0][1][k];\\n    }\\n\\n    // Space Optimization Method\\n    public int helperSO(int[] prices, int k){\\n        int[][] curr = new int[2][k + 1];\\n        int[][] next = new int[2][k + 1];\\n        for(int[] row : curr) Arrays.fill(row, 0);\\n        for(int[] row : next) Arrays.fill(row, 0);\\n\\n        for(int index = prices.length - 1; index >= 0; index--){\\n            for(int buy = 0; buy < 2; buy++){\\n                for(int limit = 1; limit < k + 1; limit++){\\n                    int totalProfit = 0;\\n                    if(buy == 1){\\n                        int buyKaro = -prices[index] + next[0][limit];\\n                        int skipKaro = next[1][limit];\\n                        totalProfit = Math.max(buyKaro, skipKaro);\\n                    }else{\\n                        int sellKaro = prices[index] + next[1][limit - 1];\\n                        int skipKaro = next[0][limit];\\n                        totalProfit = Math.max(sellKaro, skipKaro);\\n                    }\\n                    curr[buy][limit] = totalProfit;\\n                }\\n            }\\n            next = curr.clone();\\n        }\\n        return next[1][k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682941,
                "title": "188",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        if (k == 0) {\\n            return 0;\\n        }\\n        \\n        int[] buy = new int[k]; // buy[i]: min cost at (i + 1)-th time stock purchased\\n        int[] sell = new int[k]; // sell[i]: max revenue at (i + 1)-th time stock sold\\n        Arrays.fill(buy, Integer.MIN_VALUE);\\n        Arrays.fill(sell, 0);\\n        \\n        for (int i : prices) {\\n            buy[0] = Math.max(buy[0], i * -1);\\n            sell[0] = Math.max(sell[0], buy[0] + i);\\n            for (int j = 1; j < k; j++) { // The i-th time buy & sell depens on the (i - 1)-th time buy & sell\\n                buy[j] = Math.max(buy[j], sell[j - 1] - i);\\n                sell[j] = Math.max(sell[j], buy[j] + i);\\n            }\\n        }\\n        return sell[k - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        if (k == 0) {\\n            return 0;\\n        }\\n        \\n        int[] buy = new int[k]; // buy[i]: min cost at (i + 1)-th time stock purchased\\n        int[] sell = new int[k]; // sell[i]: max revenue at (i + 1)-th time stock sold\\n        Arrays.fill(buy, Integer.MIN_VALUE);\\n        Arrays.fill(sell, 0);\\n        \\n        for (int i : prices) {\\n            buy[0] = Math.max(buy[0], i * -1);\\n            sell[0] = Math.max(sell[0], buy[0] + i);\\n            for (int j = 1; j < k; j++) { // The i-th time buy & sell depens on the (i - 1)-th time buy & sell\\n                buy[j] = Math.max(buy[j], sell[j - 1] - i);\\n                sell[j] = Math.max(sell[j], buy[j] + i);\\n            }\\n        }\\n        return sell[k - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679841,
                "title": "q188-accepted-c-rec-memo-bottomup-easiest-method",
                "content": "CRUX\\n1) Simple Modification from Buy and Sell Stock III.\\n2) Changing parameters prices, opt(buy,sell), limit (0,1,2.....k)[Atmost]\\n3) 3D DP Problem\\n4) We need to sell before we buy another stock.\\n\\n*Recursion*\\n```\\nclass Solution {\\npublic:\\n    // int opt = 0 (buy)\\n    // int opt = 1 (sell)\\n    int solve(int idx,int opt,int k,vector<int>& prices){\\n        if(idx == prices.size())\\n            return 0;\\n        if(k == 0)\\n            return 0;\\n        int profit = 0;\\n        if(opt == 0)\\n            profit = max(-prices[idx]+solve(idx+1,1,k,prices),solve(idx+1,0,k,prices));\\n        else\\n            profit = max(prices[idx]+solve(idx+1,0,k-1,prices),solve(idx+1,1,k,prices));\\n        return profit;\\n    }\\n    int maxProfit(int k, vector<int>& prices) {\\n        return solve(0,0,k,prices);\\n    }\\n};\\n```\\n\\n*Recursion + Storing = Memoization*\\n```\\nclass Solution {\\npublic:\\n    // int opt = 0 (buy)\\n    // int opt = 1 (sell)\\n    int solve(int idx,int opt,int k,vector<int>& prices,vector<vector<vector<int>>> &dp){\\n        if(idx == prices.size())\\n            return 0;\\n        if(k == 0)\\n            return 0;\\n        if(dp[idx][opt][k] != -1)\\n            return dp[idx][opt][k];\\n        int profit = 0;\\n        if(opt == 0)\\n            profit = max(-prices[idx]+solve(idx+1,1,k,prices,dp),solve(idx+1,0,k,prices,dp));\\n        else\\n            profit = max(prices[idx]+solve(idx+1,0,k-1,prices,dp),solve(idx+1,1,k,prices,dp));\\n        \\n        return dp[idx][opt][k] = profit;\\n    }\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(2,vector<int>(k+1,-1)));\\n        return solve(0,0,k,prices,dp);\\n    }\\n};\\n```\\n\\n*Tabulation BottomUP*\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(2,vector<int>(k+1,0)));\\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=1;j>=0;j--){\\n                for(int l=k;l>=1;l--){\\n                    if(j == 0) \\n                        dp[i][j][l] = max(-prices[i]+dp[i+1][1][l],dp[i+1][0][l]);\\n                    else\\n                        dp[i][j][l] = max(prices[i]+dp[i+1][0][l-1],dp[i+1][1][l]);\\n                }\\n            }\\n        }\\n        return dp[0][0][k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // int opt = 0 (buy)\\n    // int opt = 1 (sell)\\n    int solve(int idx,int opt,int k,vector<int>& prices){\\n        if(idx == prices.size())\\n            return 0;\\n        if(k == 0)\\n            return 0;\\n        int profit = 0;\\n        if(opt == 0)\\n            profit = max(-prices[idx]+solve(idx+1,1,k,prices),solve(idx+1,0,k,prices));\\n        else\\n            profit = max(prices[idx]+solve(idx+1,0,k-1,prices),solve(idx+1,1,k,prices));\\n        return profit;\\n    }\\n    int maxProfit(int k, vector<int>& prices) {\\n        return solve(0,0,k,prices);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    // int opt = 0 (buy)\\n    // int opt = 1 (sell)\\n    int solve(int idx,int opt,int k,vector<int>& prices,vector<vector<vector<int>>> &dp){\\n        if(idx == prices.size())\\n            return 0;\\n        if(k == 0)\\n            return 0;\\n        if(dp[idx][opt][k] != -1)\\n            return dp[idx][opt][k];\\n        int profit = 0;\\n        if(opt == 0)\\n            profit = max(-prices[idx]+solve(idx+1,1,k,prices,dp),solve(idx+1,0,k,prices,dp));\\n        else\\n            profit = max(prices[idx]+solve(idx+1,0,k-1,prices,dp),solve(idx+1,1,k,prices,dp));\\n        \\n        return dp[idx][opt][k] = profit;\\n    }\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(2,vector<int>(k+1,-1)));\\n        return solve(0,0,k,prices,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(2,vector<int>(k+1,0)));\\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=1;j>=0;j--){\\n                for(int l=k;l>=1;l--){\\n                    if(j == 0) \\n                        dp[i][j][l] = max(-prices[i]+dp[i+1][1][l],dp[i+1][0][l]);\\n                    else\\n                        dp[i][j][l] = max(prices[i]+dp[i+1][0][l-1],dp[i+1][1][l]);\\n                }\\n            }\\n        }\\n        return dp[0][0][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673786,
                "title": "simple-dp-solution-using-python",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        # Similar to 123. Best Time to Buy and Sell Stock III\\n        \\n        n = len(prices)\\n        dp = [[[0 for m in range(k+1)] for i in range(3)] for j in range(n+1)]\\n\\n        # Tabulation ..!!!!\\n        \\n        for ind in range(n-1 , -1 , -1):\\n            for buy in range(2):\\n                for days in range(k):\\n                    if buy:\\n                        take = -prices[ind] + dp[ind+1][0][days]\\n                        not_take = 0 + dp[ind+1][1][days]\\n                    \\n                    else:\\n                        take = prices[ind] + dp[ind+1][1][days-1]\\n                        not_take = 0 + dp[ind+1][0][days]\\n                    \\n                    dp[ind][buy][days] = max(take , not_take)\\n        \\n        return dp[0][1][k-1]\\n        \\n\\n        # Memoization .. !!!\\n        \\n        \"\"\"\\n        def solve(ind , buy , days):\\n            if ind >= n or days <= 0: return 0\\n\\n            if dp[ind][buy][days] != -1: return dp[ind][buy][days]\\n\\n            if buy:\\n                take = -prices[ind] + solve(ind+1 , 0 , days)\\n                not_take = 0 + solve(ind+1 , 1 , days)\\n            \\n            else:\\n                take = prices[ind] + solve(ind+1 , 1 , days-1)\\n                not_take = 0 + solve(ind+1 , 0 , days)\\n            \\n            dp[ind][buy][days] = max(take , not_take)\\n            return dp[ind][buy][days]\\n\\n        return solve(0 , 1 , k)\\n        \"\"\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        # Similar to 123. Best Time to Buy and Sell Stock III\\n        \\n        n = len(prices)\\n        dp = [[[0 for m in range(k+1)] for i in range(3)] for j in range(n+1)]\\n\\n        # Tabulation ..!!!!\\n        \\n        for ind in range(n-1 , -1 , -1):\\n            for buy in range(2):\\n                for days in range(k):\\n                    if buy:\\n                        take = -prices[ind] + dp[ind+1][0][days]\\n                        not_take = 0 + dp[ind+1][1][days]\\n                    \\n                    else:\\n                        take = prices[ind] + dp[ind+1][1][days-1]\\n                        not_take = 0 + dp[ind+1][0][days]\\n                    \\n                    dp[ind][buy][days] = max(take , not_take)\\n        \\n        return dp[0][1][k-1]\\n        \\n\\n        # Memoization .. !!!\\n        \\n        \"\"\"\\n        def solve(ind , buy , days):\\n            if ind >= n or days <= 0: return 0\\n\\n            if dp[ind][buy][days] != -1: return dp[ind][buy][days]\\n\\n            if buy:\\n                take = -prices[ind] + solve(ind+1 , 0 , days)\\n                not_take = 0 + solve(ind+1 , 1 , days)\\n            \\n            else:\\n                take = prices[ind] + solve(ind+1 , 1 , days-1)\\n                not_take = 0 + solve(ind+1 , 0 , days)\\n            \\n            dp[ind][buy][days] = max(take , not_take)\\n            return dp[ind][buy][days]\\n\\n        return solve(0 , 1 , k)\\n        \"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672997,
                "title": "bhut-simple-full-explaination-all-6-stock-problems",
                "content": "I am writing only memeoized code becuase i never gets idea directly of top-down approach and not able to think what should be filled in  cell even if i recognize the size of 2d or 3d matrix to be filled and i think there might be some programmers like me who struggle with visualizing the process of filling cells in adynamic programming matrix or determining the contents of each cell as i myse focusing solely on memoized code can provide a helpful alternative. \\n\\nIn this article, we will explore dynamic programming problems exclusively from the perspective of memoized code. By adopting this approach, we aim to provide a simplified understanding of dynamic programming and demonstrate how memoization can be a valuable tool for solving complex optimization problems--->\\n\\n\\n# Understanding the problem\\n\\n\\nThe stock trading problems presented involve an array of stock prices, where each element represents the price of the stock on a given day. The objective is to determine the maximum profit that can be obtained by performing a series of buy and sell transactions, subject to certain constraints. These constraints may include *transaction fees*, *cooldown periods*, or a *maximum number of transactions allowed*.\\n\\n\\n# What are things we should take care of-\\n\\n- The value of stock on the day at which we are currently on.\\n- Total number of transactions\\n- Whether it is possible to buy stock ot not on that day (Explained below)\\n\\n# Variable and their Significance\\n\\n- Index---- we have to keep track of index as it can\\'t go beyond size of prices.\\n\\n---\\n\\n\\n- State/Buy---- First we need to understand we can not buy or sale at any day, means if we are holding any stock we must have to sell it before buying another one. the state is kind of flag representing whether we have liberty to buy stock or not.\\n\\n---\\n\\n\\n- K/Transactions----The variable k represents the maximum number of transactions allowed in the given problem. It determines the number of buy-sell pairs we can perform. The initial value of k depends on the problem statement and constraints. In some scenarios, it may be a fixed constant, while in others, it may vary based on the input or problem requirements. For example, if the problem allows at most k transactions, we initialize k to the given value. As transactions occur (both buying and selling), k is decremented by 1 to reflect the completion of a transaction pair.\\n\\n\\n\\n---\\n\\n\\n\\n\\n# Generalized Code\\n```\\nint dp[MAX_DAYS][MAX_STATES][MAX_TRANSACTIONS];\\n\\nint solve(int index,  int state, vector<int>& prices,int transactions) {\\n    // Base case: Check if we have reached the end or any other termination condition\\n    \\n    // Memoization: Check if the state has already been computed\\n    \\n    int profit = 0;\\n    \\n    // Make decisions based on the current state and constraints\\n    \\n    // Recursive calls: Explore all possible transitions\\n    \\n    // Update the memoization table with the computed profit\\n    \\n    return profit;\\n}\\n\\nint maxProfit(vector<int>& prices, /* additional parameters based on specific constraints */) {\\n    // Initialize the memoization table\\n    \\n    // Call the recursive function with appropriate initial parameters\\n    \\n    // Return the maximum profit\\n}\\n```\\n\\n# Understanding the Similarities\\nWhile each stock trading problem may appear unique, they can be broken down into common elements. Let\\'s identify the core components that are shared across these problems:\\n\\n- State Representation:\\n    In all stock trading problems, we need to define the state of our trading decisions. This state typically includes information such as the index of the current day, the number of transactions made, and whether we hold a stock or not.\\n\\n- Decision-Making:\\n    At each day, we have three options: buy, sell, or do nothing. The specific constraints of each problem determine the valid choices. For instance, in some problems, we cannot buy on the next day after selling, while in others, we may have a cooldown period or transaction fees.\\n\\n- Profit Calculation:\\n    The ultimate goal is to maximize the profit. This requires tracking the total profit obtained by making the right buying and selling decisions, while considering any applicable constraints.\\n\\n\\n\\n---\\n# Best Time to Buy and Sell Stock \\n\\n- This problem can be simply soolved in single iteration of stock array keeping the minimum price of stock on left as we traverse and keep calculating profit on each day with comparing with maximum profit.\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.size()==1)\\n        return 0;\\n        int buy=0;\\n        int maxi=INT_MIN;\\n        int profit=0;\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(prices[i]<prices[buy])\\n            {\\n                buy=i;\\n             \\n            }\\n            else\\n            {\\n                profit=prices[i]-prices[buy];\\n            }\\n               maxi=max(maxi,profit);\\n\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n# BASE CASE (notation used to denote this problem)\\n# Best Time to Buy and Sell Stock II  [Most Important case ]after understanding all other problems will be cakewalk :)\\n\\n- Problem Statement: Find the maximum profit achievable by buying and selling stocks multiple times means we can make transactions any number of times.\\n- Similarities:\\n   - Variables: buy variable initialized to 1 since we start with a buying state.\\n   - Base Case: When index reaches the end of the prices array, return 0.\\n    - Recursive Calls: Call the function recursively with index + 1 and buy flipped to simulate buying or selling.\\n\\n# Explaination- \\n\\n- if(buy==1) means we have liberty to buy and currently we haven\\'t bought any stock so we can buy stock on current date or skip and if we buy we simply subtract that stock amount from our finally profit and make buy=0 becuase after that we have to sell it and if we skip we still have liberty to buy that why in skip case buy remains unchanged,\\n```\\n if (buy == 1) \\n            profit = max(-prices[index] + solve(index + 1, 0,\\n prices), solve(index + 1, 1, prices))\\n\\n```\\n- if(buy==0) means we have already bought a stock on previous days and now we have to sell it ,we can\\'t buy another stock before selling it,so we can either sell on current day or skip , if we sell then price of that stock will be added to our final profit and buy get toggled because we get liberty to buy another stock then , else if we skip buy remains unchanged,\\n```\\nif(buy==0) \\nprofit = max(prices[index] + solve(index + 1, 1, prices), \\nsolve(index + 1, 0, prices))\\n```\\n```\\n\\n```\\n```\\nclass Solution {\\npublic:\\n    int dp[100000][2];\\n    int solve(int index, int buy, vector<int>& prices) {\\n        if (index >= prices.size()) {\\n            return 0;\\n        }\\n        \\n        if (dp[index][buy] != -1) {\\n            return dp[index][buy];\\n        }\\n        \\n        int profit = 0;\\n        \\n        if (buy == 1) {\\n            profit = max(-prices[index] + solve(index + 1, 0, prices), solve(index + 1, 1, prices));\\n        } else {\\n            profit = max(prices[index] + solve(index + 1, 1, prices), solve(index + 1, 0, prices));\\n        }\\n        \\n        return dp[index][buy] = profit;\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 1, prices);\\n    }\\n};\\n```\\n\\n\\n---\\n\\n\\n# Best Time to Buy and Sell Stock III\\n- Problem Statement: Find the maximum profit achievable by buying and selling stocks at most twice.\\n- Similarities:\\n    - Variables: buy variable initialized to 1 since we start with a buying state.\\n    - Base Case: When index reaches the end of the prices array or k becomes 0, return 0.\\n    - Recursive Calls: Call the function recursively with index + 1 and buy flipped to simulate buying or selling, and decrement k when buying.\\n- How it is different from base case :- Here,transactions allowed is only 2, so we have another base case here which is ocntraint over number of transactions .\\n- Notice:- Transaction will be complete only if both buy and sell gets completed that why \\'k\\' (number of transactions ) gets decremented only after selling it.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[100000][2][3];\\n    \\n    int solve(int index, int buy, int k, vector<int>& prices) {\\n        if (index >= prices.size() || k == 0) {\\n            return 0;\\n        }\\n        \\n        if (dp[index][buy][k] != -1) {\\n            return dp[index][buy][k];\\n        }\\n        \\n        int profit = 0;\\n        \\n        if (buy == 1) {\\n            profit = max(-prices[index] + solve(index + 1, 0, k - 1, prices), solve(index + 1, 1, k, prices));\\n        } else {\\n            profit = max(prices[index] + solve(index + 1, 1, k, prices), solve(index + 1, 0, k, prices));\\n        }\\n        \\n        return dp[index][buy][k] = profit;\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 1, 2, prices);\\n    }\\n};\\n```\\n\\n---\\n\\n\\n# Best Time to Buy and Sell Stock IV:\\n- Problem Statement: Find the maximum profit achievable by buying and selling stocks at most k transactions.\\n- Similarities:\\n    - Variables: buy variable initialized to 1 since we start with a buying state.\\n    - Base Case: When index reaches the end of the prices array or k becomes 0, return 0.\\n    - Recursive Calls: Call the function recursively with index + 1 and buy flipped to simulate buying or selling, and decrement k when buying.\\n- How it is different from base case :- Here,transactions allowed is only k, so we have another base case here which is ocntraint over number of transactions .\\n- Notice:- Transaction will be complete only if both buy and sell gets completed that why \\'k\\' (number of transactions ) gets decremented only after selling it.\\n- Actually same code  as case 3 will work beacuse here only number of transactions have changed.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int dp[100000][2][k + 1];\\n    \\n    int solve(int index, int buy, int k, vector<int>& prices) {\\n        if (index >= prices.size() || k == 0) {\\n            return 0;\\n        }\\n        \\n        if (dp[index][buy][k] != -1) {\\n            return dp[index][buy][k];\\n        }\\n        \\n        int profit = 0;\\n        \\n        if (buy == 1) {\\n            profit = max(-prices[index] + solve(index + 1, 0, k - 1, prices), solve(index + 1, 1, k, prices));\\n        } else {\\n            profit = max(prices[index] + solve(index + 1, 1, k, prices), solve(index + 1, 0, k, prices));\\n        }\\n        \\n        return dp[index][buy][k] = profit;\\n    }\\n    \\n    int maxProfit(int k, vector<int>& prices) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 1, k, prices);\\n    }\\n};\\n```\\n\\n---\\n\\n\\n# Best Time to Buy and Sell Stock with Cooldown:\\n- Problem Statement: Find the maximum profit achievable by buying and selling stocks with a one-day cooldown period.\\n- Similarities:\\n    - Variables: buy variable initialized to 1 since we start with a buying state.\\n    - Base Case: When index reaches the end of the prices array, return 0.\\n    - Recursive Calls: Call the function recursively with index + 1 and buy flipped to simulate buying or selling.\\n- How it is different from base case :- Here, cooldown is important means we can\\'t buy just after selling stock on previous day. We have only one change in code from base code is that after selling our index will be changed to index+2 not index+1 becuase there is colldown of 1 day after selling a stock.\\n```\\n//selling case\\nprofit = max(prices[index] + solve(index + 2, 1, prices), \\nsolve(index + 1, 0, prices));\\n```\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int dp[100000][2];\\n    \\n    int solve(int index, int buy, vector<int>& prices) {\\n        if (index >= prices.size()) {\\n            return 0;\\n        }\\n        \\n        if (dp[index][buy] != -1) {\\n            return dp[index][buy];\\n        }\\n        \\n        int profit = 0;\\n        \\n        if (buy == 1) {\\n            profit = max(-prices[index] + solve(index + 1, 0, prices), solve(index + 1, 1, prices));\\n        } else {\\n            profit = max(prices[index] + solve(index + 2, 1, prices), solve(index + 1, 0, prices));\\n        }\\n        \\n        return dp[index][buy] = profit;\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 1, prices);\\n    }\\n};\\n\\n```\\n\\n---\\n\\n\\n# Best Time to Buy and Sell Stock with Transaction Fee:\\n- Problem Statement: Find the maximum profit achievable by buying and selling stocks with a transaction fee.\\n- Similarities:\\n    - Variables: buy variable initialized to 1 since we start with a buying state.\\n    - Base Case: When index reaches the end of the prices array, return 0.\\n    - Recursive Calls: Call the function recursively with index + 1 and buy flipped to simulate buying or selling.\\n\\n- How it is different from base case :- Here, A fixed amount will also deduct for each transaction so simply in buy condition , we deducted fee from our final profit.\\n```\\nif (buy == 1) {\\n            profit = max(-prices[index] - fee + solve(index + \\n1, 0, prices, fee), solve(index + 1, 1, prices, fee));\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[100000][2];\\n    \\n    int solve(int index, int buy, vector<int>& prices, int fee) {\\n        if (index >= prices.size()) {\\n            return 0;\\n        }\\n        \\n        if (dp[index][buy] != -1) {\\n            return dp[index][buy];\\n        }\\n        \\n        int profit = 0;\\n        \\n        if (buy == 1) {\\n            profit = max(-prices[index] - fee + solve(index + 1, 0, prices, fee), solve(index + 1, 1, prices, fee));\\n        } else {\\n            profit = max(prices[index] + solve(index + 1, 1, prices, fee), solve(index + 1, 0, prices, fee));\\n        }\\n        \\n        return dp[index][buy] = profit;\\n    }\\n    \\n    int maxProfit(vector<int>& prices, int fee) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 1, prices, fee);\\n    }\\n};\\n```\\nThese memoized solutions for the six stock trading problems share similarities in terms of the variables used (buy variable to indicate the buying state), the base case (when the index reaches the end of the prices array), and the recursive calls (calling the function with index + 1 and flipping the buy variable to simulate buying or selling). Understanding these similarities can help in deriving a more general recursive code that can handle slight variations in the constraints of the stock trading problems.\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint dp[MAX_DAYS][MAX_STATES][MAX_TRANSACTIONS];\\n\\nint solve(int index,  int state, vector<int>& prices,int transactions) {\\n    // Base case: Check if we have reached the end or any other termination condition\\n    \\n    // Memoization: Check if the state has already been computed\\n    \\n    int profit = 0;\\n    \\n    // Make decisions based on the current state and constraints\\n    \\n    // Recursive calls: Explore all possible transitions\\n    \\n    // Update the memoization table with the computed profit\\n    \\n    return profit;\\n}\\n\\nint maxProfit(vector<int>& prices, /* additional parameters based on specific constraints */) {\\n    // Initialize the memoization table\\n    \\n    // Call the recursive function with appropriate initial parameters\\n    \\n    // Return the maximum profit\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.size()==1)\\n        return 0;\\n        int buy=0;\\n        int maxi=INT_MIN;\\n        int profit=0;\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(prices[i]<prices[buy])\\n            {\\n                buy=i;\\n             \\n            }\\n            else\\n            {\\n                profit=prices[i]-prices[buy];\\n            }\\n               maxi=max(maxi,profit);\\n\\n        }\\n        return maxi;\\n    }\\n};\\n```\n```\\n if (buy == 1) \\n            profit = max(-prices[index] + solve(index + 1, 0,\\n prices), solve(index + 1, 1, prices))\\n\\n```\n```\\nif(buy==0) \\nprofit = max(prices[index] + solve(index + 1, 1, prices), \\nsolve(index + 1, 0, prices))\\n```\n```\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[100000][2];\\n    int solve(int index, int buy, vector<int>& prices) {\\n        if (index >= prices.size()) {\\n            return 0;\\n        }\\n        \\n        if (dp[index][buy] != -1) {\\n            return dp[index][buy];\\n        }\\n        \\n        int profit = 0;\\n        \\n        if (buy == 1) {\\n            profit = max(-prices[index] + solve(index + 1, 0, prices), solve(index + 1, 1, prices));\\n        } else {\\n            profit = max(prices[index] + solve(index + 1, 1, prices), solve(index + 1, 0, prices));\\n        }\\n        \\n        return dp[index][buy] = profit;\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 1, prices);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[100000][2][3];\\n    \\n    int solve(int index, int buy, int k, vector<int>& prices) {\\n        if (index >= prices.size() || k == 0) {\\n            return 0;\\n        }\\n        \\n        if (dp[index][buy][k] != -1) {\\n            return dp[index][buy][k];\\n        }\\n        \\n        int profit = 0;\\n        \\n        if (buy == 1) {\\n            profit = max(-prices[index] + solve(index + 1, 0, k - 1, prices), solve(index + 1, 1, k, prices));\\n        } else {\\n            profit = max(prices[index] + solve(index + 1, 1, k, prices), solve(index + 1, 0, k, prices));\\n        }\\n        \\n        return dp[index][buy][k] = profit;\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 1, 2, prices);\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int dp[100000][2][k + 1];\\n    \\n    int solve(int index, int buy, int k, vector<int>& prices) {\\n        if (index >= prices.size() || k == 0) {\\n            return 0;\\n        }\\n        \\n        if (dp[index][buy][k] != -1) {\\n            return dp[index][buy][k];\\n        }\\n        \\n        int profit = 0;\\n        \\n        if (buy == 1) {\\n            profit = max(-prices[index] + solve(index + 1, 0, k - 1, prices), solve(index + 1, 1, k, prices));\\n        } else {\\n            profit = max(prices[index] + solve(index + 1, 1, k, prices), solve(index + 1, 0, k, prices));\\n        }\\n        \\n        return dp[index][buy][k] = profit;\\n    }\\n    \\n    int maxProfit(int k, vector<int>& prices) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 1, k, prices);\\n    }\\n};\\n```\n```\\n//selling case\\nprofit = max(prices[index] + solve(index + 2, 1, prices), \\nsolve(index + 1, 0, prices));\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int dp[100000][2];\\n    \\n    int solve(int index, int buy, vector<int>& prices) {\\n        if (index >= prices.size()) {\\n            return 0;\\n        }\\n        \\n        if (dp[index][buy] != -1) {\\n            return dp[index][buy];\\n        }\\n        \\n        int profit = 0;\\n        \\n        if (buy == 1) {\\n            profit = max(-prices[index] + solve(index + 1, 0, prices), solve(index + 1, 1, prices));\\n        } else {\\n            profit = max(prices[index] + solve(index + 2, 1, prices), solve(index + 1, 0, prices));\\n        }\\n        \\n        return dp[index][buy] = profit;\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 1, prices);\\n    }\\n};\\n\\n```\n```\\nif (buy == 1) {\\n            profit = max(-prices[index] - fee + solve(index + \\n1, 0, prices, fee), solve(index + 1, 1, prices, fee));\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[100000][2];\\n    \\n    int solve(int index, int buy, vector<int>& prices, int fee) {\\n        if (index >= prices.size()) {\\n            return 0;\\n        }\\n        \\n        if (dp[index][buy] != -1) {\\n            return dp[index][buy];\\n        }\\n        \\n        int profit = 0;\\n        \\n        if (buy == 1) {\\n            profit = max(-prices[index] - fee + solve(index + 1, 0, prices, fee), solve(index + 1, 1, prices, fee));\\n        } else {\\n            profit = max(prices[index] + solve(index + 1, 1, prices, fee), solve(index + 1, 0, prices, fee));\\n        }\\n        \\n        return dp[index][buy] = profit;\\n    }\\n    \\n    int maxProfit(vector<int>& prices, int fee) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 1, prices, fee);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539768,
                "title": "easy-solution-recursive-method-dp-method-c",
                "content": "# Intuition\\nStock selling problem always reminds me the concept of DP.\\n\\n# Approach\\nIn the question it is clearly given that you can buy and sell the stocks multiple times but there are limited transactions possible.\\n\\nSo we take two things into consideration. \\n1) Whether a stock is bought.\\n2) Transactions left.\\n\\nLet us make a flag variable which determines whether we hold a stock. If we hold the stock flag is 1 else it is 0. \\n\\nIf we do not hold a stack, we have two ways either buy the stock or just do not buy. We need to pick the maximum from both the cases. In the case considering that you buy the stock update the flag as 1 and subtract 1 from Transactions Left as one of the transaction is done for buying. As you buy the stoct your money is debited so we subtract the money. In the case considering that you donot buy the stock update nothing.\\n\\nIf we do hold a stack, we have two ways either sell the stock or just do not sell. We need to pick the maximum from both the cases. In the case considering that you sell the stock update the flag as 0 and subtract 1 from Transactions Left as one of the transaction is done for selling. As you sell the stoct your money is credited so we add the money. In the case considering that you donot sell the stock update nothing.\\n\\nThe terminating Case would be either index is greater than size or no transactions left.\\n\\n# Complexity\\n- Time complexity:\\nO(N*K);\\n\\n- Space complexity:\\nO(N*K);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint soln(vector<int>&prices,int idx,int transactionsleft,int flag, vector<vector<vector<int>>>&dp){\\n    if(idx>=prices.size() || (transactionsleft == 0)){\\n        return 0;\\n    }\\n    if(dp[idx][transactionsleft][flag] != -1){\\n        return dp[idx][transactionsleft][flag];\\n    }\\n    int ans = INT_MIN;\\n    if(flag){\\n        ans = max(ans,soln(prices,idx+1,transactionsleft-1,0,dp)+prices[idx]);\\n        ans = max(ans,soln(prices,idx+1,transactionsleft,1,dp));\\n    }else{\\n        ans = max(ans,soln(prices,idx+1,transactionsleft-1,1,dp)-prices[idx]);\\n        ans = max(ans,soln(prices,idx+1,transactionsleft,0,dp));\\n    }\\n    return dp[idx][transactionsleft][flag] = ans;\\n}\\n    int maxProfit(int k, vector<int>& prices) {\\n       vector<vector<vector<int>>>dp(prices.size(),vector<vector<int>>(2*k+1,vector<int>(2,-1)));\\n       return soln(prices,0,2*k,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint soln(vector<int>&prices,int idx,int transactionsleft,int flag, vector<vector<vector<int>>>&dp){\\n    if(idx>=prices.size() || (transactionsleft == 0)){\\n        return 0;\\n    }\\n    if(dp[idx][transactionsleft][flag] != -1){\\n        return dp[idx][transactionsleft][flag];\\n    }\\n    int ans = INT_MIN;\\n    if(flag){\\n        ans = max(ans,soln(prices,idx+1,transactionsleft-1,0,dp)+prices[idx]);\\n        ans = max(ans,soln(prices,idx+1,transactionsleft,1,dp));\\n    }else{\\n        ans = max(ans,soln(prices,idx+1,transactionsleft-1,1,dp)-prices[idx]);\\n        ans = max(ans,soln(prices,idx+1,transactionsleft,0,dp));\\n    }\\n    return dp[idx][transactionsleft][flag] = ans;\\n}\\n    int maxProfit(int k, vector<int>& prices) {\\n       vector<vector<vector<int>>>dp(prices.size(),vector<vector<int>>(2*k+1,vector<int>(2,-1)));\\n       return soln(prices,0,2*k,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500429,
                "title": "c-o-nk-dp-with-comments-3-ms",
                "content": "```\\nclass Solution {\\npublic:\\n  int maxProfit(int K, vector<int>& prices) {\\n    int n = prices.size();\\n    \\n    // The array profit records the maximum profit we can achieve if we were to\\n    // sell on or before the i\\'th day. This array will change with the value of k.\\n    vector<int> profit(n, 0);\\n    \\n    // First compute profit for k = 1.\\n    int minSoFar = prices[0];\\n    for (int i = 1; i < n; ++i) {\\n      minSoFar = min(minSoFar, prices[i]);\\n      profit[i] = max(profit[i - 1], prices[i] - minSoFar);\\n    }\\n    \\n    // Compute for k = [2..K].\\n    for (int k = 2; k <= K; ++k) {\\n      int firstIdx = 2 * (k - 1);\\n      if (firstIdx >= n) break;\\n      \\n      // oldProfit is profit from K <= (k - 1).\\n      auto oldProfit = profit;\\n      \\n      // Let i and j be days such that j < i. If [j, i] were to be the k\\'th trading\\n      // window, the profit would be prices[i] - prices[j] + oldProfit[j - 1].\\n      // Therefore, for every i, we must maximize oldProfit[j - 1] - prices[j],\\n      // so we keep track of that in maxSoFar.\\n      int maxSoFar = oldProfit[firstIdx - 1] - prices[firstIdx];\\n      for (int i = firstIdx + 1; i < n; ++i) {\\n        profit[i] = max(max(profit[i], prices[i] + maxSoFar), profit[i - 1]);\\n        maxSoFar = max(maxSoFar, oldProfit[i - 1] - prices[i]);\\n      }\\n    }\\n    \\n    // Now that we have taken all values of k into consideration, just get the\\n    // maximum value in the profit array.\\n    return *max_element(profit.begin(), profit.end());\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int maxProfit(int K, vector<int>& prices) {\\n    int n = prices.size();\\n    \\n    // The array profit records the maximum profit we can achieve if we were to\\n    // sell on or before the i\\'th day. This array will change with the value of k.\\n    vector<int> profit(n, 0);\\n    \\n    // First compute profit for k = 1.\\n    int minSoFar = prices[0];\\n    for (int i = 1; i < n; ++i) {\\n      minSoFar = min(minSoFar, prices[i]);\\n      profit[i] = max(profit[i - 1], prices[i] - minSoFar);\\n    }\\n    \\n    // Compute for k = [2..K].\\n    for (int k = 2; k <= K; ++k) {\\n      int firstIdx = 2 * (k - 1);\\n      if (firstIdx >= n) break;\\n      \\n      // oldProfit is profit from K <= (k - 1).\\n      auto oldProfit = profit;\\n      \\n      // Let i and j be days such that j < i. If [j, i] were to be the k\\'th trading\\n      // window, the profit would be prices[i] - prices[j] + oldProfit[j - 1].\\n      // Therefore, for every i, we must maximize oldProfit[j - 1] - prices[j],\\n      // so we keep track of that in maxSoFar.\\n      int maxSoFar = oldProfit[firstIdx - 1] - prices[firstIdx];\\n      for (int i = firstIdx + 1; i < n; ++i) {\\n        profit[i] = max(max(profit[i], prices[i] + maxSoFar), profit[i - 1]);\\n        maxSoFar = max(maxSoFar, oldProfit[i - 1] - prices[i]);\\n      }\\n    }\\n    \\n    // Now that we have taken all values of k into consideration, just get the\\n    // maximum value in the profit array.\\n    return *max_element(profit.begin(), profit.end());\\n  }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567221,
                "content": [
                    {
                        "username": "elison",
                        "content": "It seemed ambiguous to me, but I am going off the assumption that buy and sell together is 1 transaction. Am I correct?"
                    },
                    {
                        "username": "benakrish",
                        "content": "Yes."
                    },
                    {
                        "username": "whshph",
                        "content": "Why every solution is bottom up solution? Looking for top-down variant. Actually, I\\'m looking for gradual improvement from brute-force to better brute-force (if any) to top-down dp to bottom up dp. This kind of incremental learning strongly imprints concepts and make it easy to understand the complexity in increments. Please share if there\\'s any such post."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "go for code with love babbar c++ "
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "[@Goblin_Cyanide](/Goblin_Cyanide)  look at this post \\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/900051/fully-explained-all-buy-and-sell-problems-c-recursive-memoization-minor-difference/?orderBy=most_votes&topicTags=dynamic-programming\\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Watch Striver\\'s video on youtube.\\nOr you can see this for top down approach\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2964060/c-easy-to-understand-recursion-and-top-down-memoization-dp-solution/"
                    },
                    {
                        "username": "dengzj2014",
                        "content": "when K > prices.length/2, the problem becomes to any transation problem, and it becomes to O(N) problem"
                    },
                    {
                        "username": "Vucibatina",
                        "content": "This does not make sense.  Is there a  charity based stock exchange that gives out stocks for free?"
                    },
                    {
                        "username": "swapnilgupta",
                        "content": "Nope, a stock price can drop to zero if the company goes bankrupt or loses all its value to various reasons. However, a stock price cannot go below zero."
                    },
                    {
                        "username": "Prithvi_raj",
                        "content": "if anyone know solution to this problem please take a moment to explain ...earlier my code was running perfectly with 90% speed .. but some new test cases are added and its giving me TLE...."
                    },
                    {
                        "username": "gvinaycr",
                        "content": "Can anyone explain the expected result?\\n\\nInput:\\t2, [6,1,3,2,4,7]\\nOutput:\\t6\\nExpected:\\t7"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Buy at 1, sell at 3 then buy at 2, sell at 7"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I saw some solutions use the condition: if(k >= n/2) then it is said that this question becomes \"BEST TIME TO BUY AND SELL STOCK II\", in which case you can have unlimited transactions. Suppose we have 7 days (n=7) so the above condition implies that as long as we have k >= 7/2 (i.e k=3) we have unlimited transactions. \\n\\nHowever, by definition, unlimited transactions means k=6. So we are actually saying that as long as we have k>=n/2=3, we are as good as if we have k=6.\\n\\nI don't know if it is correct or not, but I cannot think of a case that this is wrong. Say you have 7 days prices, think of an price array that you will be better off having > 3 transactions than <= 3 transactions. Can anyone think of such an example? If not then it is probably right. Sorry if this is just too trivial to see."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "You need two prices to make a transaction. So you can\\'t make more than n/2 transactions with a price array of size n. \\nIf you have a price array of 7 days, you cannot make more than 3 transactions:\\nBuy on day 1, sell on day 2 -> 1transaction\\nbuy on day 3 sell on day 4 -> 2 transactions\\nbuy 5 sell 6 -> 3 transactions \\nand you\\'re left with only one day so no more possible transaction "
                    },
                    {
                        "username": "deft235",
                        "content": "After having finished this four problems and having read some others\\' answers, I think maybe it will help someone to provide a somehow clear explanation. That\\'s why I wrote this summary. If you find it useful, a like will be appreciated.\\n\\nI will introduce IV before III, as III is actually a special case. However, there exists a different solution for III as well.\\n\\nI,II\\nDefine a peak as a local maximum, a valley as a local minimum.\\n\\nThe essence of these first two problems is to find 1) largest difference between a peak and a valley in an array; 2) the sum of all peak-valley-differences that exist.(as there is no limit of the number of transactions, which makes things easier compared to problem[3,4]).\\n\\nfor (1), keeps track of minimum until current position and records maximum possible profit; for (2), add all positive gaps suffices. Remember, a valley-peak-valley-peak will make profit greater rather than a merged valley-peak though the absolute difference may be greater for the latter one. See the graph explanation on Leetcode solution.\\n\\nIV\\nProblem 4 actually generalises all cases in this scenario. However, as k becomes larger, the problem 4 degrades to problem 2. It is important to note that the dynamic programming solution works when k is less than the maximum possible number of transactions.\\n\\nDP Solution: split the problem hierarchically. Consider the case where we make i transactions, i = 1, 2, ... k.\\n\\nOn each day, there are two states: hold stocks(H) or not hold stocks(NH). Three possible options for the operator: buy, sell or None.\\n\\nDenote the number of days by j. The transition formula for dp here is:\\n\\nH[i][j] = max(NH[i-1][j-1]-prices[j],H[i][j-1]) NH[i][j] = max(H[i][j]+prices[j],NH[i][j-1])\\n\\nExplaination for the first formula: on each day j, either we 1)buy the stock, which begins a new transaction, thus the profit is NH[i-1][j-1] minus current stock price; either 2)None, and the profit keeps the same as on day j-1.\\n\\nFor implementation, note that updating H concerns previous NH and current H, while updating NH concerns both current NH and current NH. Thus, update firstly H, then NH, a one-dimensional dp array suffices.\\n\\nIII\\nProblem 3 can be solved using the solution for 4, but in the case of at most 2 transactions permitted, there exists a simpler solution. As we can find the two(if existed) maximum profit seperately, until day i and after day i.\\n\\nOn day i, we calculate two maximum, in forward and backward ways respectively. Record the sum of these two maximums for each day, and pick the largest one.\\n\\nI\\'ve uploaded my solutions for III and IV on my Github. If you are confused about implementation, visit:\\nhttps://github.com/Maple177/Leetcode/tree/master/typical%20questions/Best%20Time%20to%20Buy%20and%20Sell%20Stock"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    },
                    {
                        "username": "sruzic",
                        "content": "I think there is an error in test case with k = 100 000."
                    },
                    {
                        "username": "at218808",
                        "content": "k less than 100"
                    }
                ]
            },
            {
                "id": 1568308,
                "content": [
                    {
                        "username": "elison",
                        "content": "It seemed ambiguous to me, but I am going off the assumption that buy and sell together is 1 transaction. Am I correct?"
                    },
                    {
                        "username": "benakrish",
                        "content": "Yes."
                    },
                    {
                        "username": "whshph",
                        "content": "Why every solution is bottom up solution? Looking for top-down variant. Actually, I\\'m looking for gradual improvement from brute-force to better brute-force (if any) to top-down dp to bottom up dp. This kind of incremental learning strongly imprints concepts and make it easy to understand the complexity in increments. Please share if there\\'s any such post."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "go for code with love babbar c++ "
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "[@Goblin_Cyanide](/Goblin_Cyanide)  look at this post \\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/900051/fully-explained-all-buy-and-sell-problems-c-recursive-memoization-minor-difference/?orderBy=most_votes&topicTags=dynamic-programming\\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Watch Striver\\'s video on youtube.\\nOr you can see this for top down approach\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2964060/c-easy-to-understand-recursion-and-top-down-memoization-dp-solution/"
                    },
                    {
                        "username": "dengzj2014",
                        "content": "when K > prices.length/2, the problem becomes to any transation problem, and it becomes to O(N) problem"
                    },
                    {
                        "username": "Vucibatina",
                        "content": "This does not make sense.  Is there a  charity based stock exchange that gives out stocks for free?"
                    },
                    {
                        "username": "swapnilgupta",
                        "content": "Nope, a stock price can drop to zero if the company goes bankrupt or loses all its value to various reasons. However, a stock price cannot go below zero."
                    },
                    {
                        "username": "Prithvi_raj",
                        "content": "if anyone know solution to this problem please take a moment to explain ...earlier my code was running perfectly with 90% speed .. but some new test cases are added and its giving me TLE...."
                    },
                    {
                        "username": "gvinaycr",
                        "content": "Can anyone explain the expected result?\\n\\nInput:\\t2, [6,1,3,2,4,7]\\nOutput:\\t6\\nExpected:\\t7"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Buy at 1, sell at 3 then buy at 2, sell at 7"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I saw some solutions use the condition: if(k >= n/2) then it is said that this question becomes \"BEST TIME TO BUY AND SELL STOCK II\", in which case you can have unlimited transactions. Suppose we have 7 days (n=7) so the above condition implies that as long as we have k >= 7/2 (i.e k=3) we have unlimited transactions. \\n\\nHowever, by definition, unlimited transactions means k=6. So we are actually saying that as long as we have k>=n/2=3, we are as good as if we have k=6.\\n\\nI don't know if it is correct or not, but I cannot think of a case that this is wrong. Say you have 7 days prices, think of an price array that you will be better off having > 3 transactions than <= 3 transactions. Can anyone think of such an example? If not then it is probably right. Sorry if this is just too trivial to see."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "You need two prices to make a transaction. So you can\\'t make more than n/2 transactions with a price array of size n. \\nIf you have a price array of 7 days, you cannot make more than 3 transactions:\\nBuy on day 1, sell on day 2 -> 1transaction\\nbuy on day 3 sell on day 4 -> 2 transactions\\nbuy 5 sell 6 -> 3 transactions \\nand you\\'re left with only one day so no more possible transaction "
                    },
                    {
                        "username": "deft235",
                        "content": "After having finished this four problems and having read some others\\' answers, I think maybe it will help someone to provide a somehow clear explanation. That\\'s why I wrote this summary. If you find it useful, a like will be appreciated.\\n\\nI will introduce IV before III, as III is actually a special case. However, there exists a different solution for III as well.\\n\\nI,II\\nDefine a peak as a local maximum, a valley as a local minimum.\\n\\nThe essence of these first two problems is to find 1) largest difference between a peak and a valley in an array; 2) the sum of all peak-valley-differences that exist.(as there is no limit of the number of transactions, which makes things easier compared to problem[3,4]).\\n\\nfor (1), keeps track of minimum until current position and records maximum possible profit; for (2), add all positive gaps suffices. Remember, a valley-peak-valley-peak will make profit greater rather than a merged valley-peak though the absolute difference may be greater for the latter one. See the graph explanation on Leetcode solution.\\n\\nIV\\nProblem 4 actually generalises all cases in this scenario. However, as k becomes larger, the problem 4 degrades to problem 2. It is important to note that the dynamic programming solution works when k is less than the maximum possible number of transactions.\\n\\nDP Solution: split the problem hierarchically. Consider the case where we make i transactions, i = 1, 2, ... k.\\n\\nOn each day, there are two states: hold stocks(H) or not hold stocks(NH). Three possible options for the operator: buy, sell or None.\\n\\nDenote the number of days by j. The transition formula for dp here is:\\n\\nH[i][j] = max(NH[i-1][j-1]-prices[j],H[i][j-1]) NH[i][j] = max(H[i][j]+prices[j],NH[i][j-1])\\n\\nExplaination for the first formula: on each day j, either we 1)buy the stock, which begins a new transaction, thus the profit is NH[i-1][j-1] minus current stock price; either 2)None, and the profit keeps the same as on day j-1.\\n\\nFor implementation, note that updating H concerns previous NH and current H, while updating NH concerns both current NH and current NH. Thus, update firstly H, then NH, a one-dimensional dp array suffices.\\n\\nIII\\nProblem 3 can be solved using the solution for 4, but in the case of at most 2 transactions permitted, there exists a simpler solution. As we can find the two(if existed) maximum profit seperately, until day i and after day i.\\n\\nOn day i, we calculate two maximum, in forward and backward ways respectively. Record the sum of these two maximums for each day, and pick the largest one.\\n\\nI\\'ve uploaded my solutions for III and IV on my Github. If you are confused about implementation, visit:\\nhttps://github.com/Maple177/Leetcode/tree/master/typical%20questions/Best%20Time%20to%20Buy%20and%20Sell%20Stock"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    },
                    {
                        "username": "sruzic",
                        "content": "I think there is an error in test case with k = 100 000."
                    },
                    {
                        "username": "at218808",
                        "content": "k less than 100"
                    }
                ]
            },
            {
                "id": 1566608,
                "content": [
                    {
                        "username": "elison",
                        "content": "It seemed ambiguous to me, but I am going off the assumption that buy and sell together is 1 transaction. Am I correct?"
                    },
                    {
                        "username": "benakrish",
                        "content": "Yes."
                    },
                    {
                        "username": "whshph",
                        "content": "Why every solution is bottom up solution? Looking for top-down variant. Actually, I\\'m looking for gradual improvement from brute-force to better brute-force (if any) to top-down dp to bottom up dp. This kind of incremental learning strongly imprints concepts and make it easy to understand the complexity in increments. Please share if there\\'s any such post."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "go for code with love babbar c++ "
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "[@Goblin_Cyanide](/Goblin_Cyanide)  look at this post \\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/900051/fully-explained-all-buy-and-sell-problems-c-recursive-memoization-minor-difference/?orderBy=most_votes&topicTags=dynamic-programming\\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Watch Striver\\'s video on youtube.\\nOr you can see this for top down approach\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2964060/c-easy-to-understand-recursion-and-top-down-memoization-dp-solution/"
                    },
                    {
                        "username": "dengzj2014",
                        "content": "when K > prices.length/2, the problem becomes to any transation problem, and it becomes to O(N) problem"
                    },
                    {
                        "username": "Vucibatina",
                        "content": "This does not make sense.  Is there a  charity based stock exchange that gives out stocks for free?"
                    },
                    {
                        "username": "swapnilgupta",
                        "content": "Nope, a stock price can drop to zero if the company goes bankrupt or loses all its value to various reasons. However, a stock price cannot go below zero."
                    },
                    {
                        "username": "Prithvi_raj",
                        "content": "if anyone know solution to this problem please take a moment to explain ...earlier my code was running perfectly with 90% speed .. but some new test cases are added and its giving me TLE...."
                    },
                    {
                        "username": "gvinaycr",
                        "content": "Can anyone explain the expected result?\\n\\nInput:\\t2, [6,1,3,2,4,7]\\nOutput:\\t6\\nExpected:\\t7"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Buy at 1, sell at 3 then buy at 2, sell at 7"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I saw some solutions use the condition: if(k >= n/2) then it is said that this question becomes \"BEST TIME TO BUY AND SELL STOCK II\", in which case you can have unlimited transactions. Suppose we have 7 days (n=7) so the above condition implies that as long as we have k >= 7/2 (i.e k=3) we have unlimited transactions. \\n\\nHowever, by definition, unlimited transactions means k=6. So we are actually saying that as long as we have k>=n/2=3, we are as good as if we have k=6.\\n\\nI don't know if it is correct or not, but I cannot think of a case that this is wrong. Say you have 7 days prices, think of an price array that you will be better off having > 3 transactions than <= 3 transactions. Can anyone think of such an example? If not then it is probably right. Sorry if this is just too trivial to see."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "You need two prices to make a transaction. So you can\\'t make more than n/2 transactions with a price array of size n. \\nIf you have a price array of 7 days, you cannot make more than 3 transactions:\\nBuy on day 1, sell on day 2 -> 1transaction\\nbuy on day 3 sell on day 4 -> 2 transactions\\nbuy 5 sell 6 -> 3 transactions \\nand you\\'re left with only one day so no more possible transaction "
                    },
                    {
                        "username": "deft235",
                        "content": "After having finished this four problems and having read some others\\' answers, I think maybe it will help someone to provide a somehow clear explanation. That\\'s why I wrote this summary. If you find it useful, a like will be appreciated.\\n\\nI will introduce IV before III, as III is actually a special case. However, there exists a different solution for III as well.\\n\\nI,II\\nDefine a peak as a local maximum, a valley as a local minimum.\\n\\nThe essence of these first two problems is to find 1) largest difference between a peak and a valley in an array; 2) the sum of all peak-valley-differences that exist.(as there is no limit of the number of transactions, which makes things easier compared to problem[3,4]).\\n\\nfor (1), keeps track of minimum until current position and records maximum possible profit; for (2), add all positive gaps suffices. Remember, a valley-peak-valley-peak will make profit greater rather than a merged valley-peak though the absolute difference may be greater for the latter one. See the graph explanation on Leetcode solution.\\n\\nIV\\nProblem 4 actually generalises all cases in this scenario. However, as k becomes larger, the problem 4 degrades to problem 2. It is important to note that the dynamic programming solution works when k is less than the maximum possible number of transactions.\\n\\nDP Solution: split the problem hierarchically. Consider the case where we make i transactions, i = 1, 2, ... k.\\n\\nOn each day, there are two states: hold stocks(H) or not hold stocks(NH). Three possible options for the operator: buy, sell or None.\\n\\nDenote the number of days by j. The transition formula for dp here is:\\n\\nH[i][j] = max(NH[i-1][j-1]-prices[j],H[i][j-1]) NH[i][j] = max(H[i][j]+prices[j],NH[i][j-1])\\n\\nExplaination for the first formula: on each day j, either we 1)buy the stock, which begins a new transaction, thus the profit is NH[i-1][j-1] minus current stock price; either 2)None, and the profit keeps the same as on day j-1.\\n\\nFor implementation, note that updating H concerns previous NH and current H, while updating NH concerns both current NH and current NH. Thus, update firstly H, then NH, a one-dimensional dp array suffices.\\n\\nIII\\nProblem 3 can be solved using the solution for 4, but in the case of at most 2 transactions permitted, there exists a simpler solution. As we can find the two(if existed) maximum profit seperately, until day i and after day i.\\n\\nOn day i, we calculate two maximum, in forward and backward ways respectively. Record the sum of these two maximums for each day, and pick the largest one.\\n\\nI\\'ve uploaded my solutions for III and IV on my Github. If you are confused about implementation, visit:\\nhttps://github.com/Maple177/Leetcode/tree/master/typical%20questions/Best%20Time%20to%20Buy%20and%20Sell%20Stock"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    },
                    {
                        "username": "sruzic",
                        "content": "I think there is an error in test case with k = 100 000."
                    },
                    {
                        "username": "at218808",
                        "content": "k less than 100"
                    }
                ]
            },
            {
                "id": 1567909,
                "content": [
                    {
                        "username": "elison",
                        "content": "It seemed ambiguous to me, but I am going off the assumption that buy and sell together is 1 transaction. Am I correct?"
                    },
                    {
                        "username": "benakrish",
                        "content": "Yes."
                    },
                    {
                        "username": "whshph",
                        "content": "Why every solution is bottom up solution? Looking for top-down variant. Actually, I\\'m looking for gradual improvement from brute-force to better brute-force (if any) to top-down dp to bottom up dp. This kind of incremental learning strongly imprints concepts and make it easy to understand the complexity in increments. Please share if there\\'s any such post."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "go for code with love babbar c++ "
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "[@Goblin_Cyanide](/Goblin_Cyanide)  look at this post \\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/900051/fully-explained-all-buy-and-sell-problems-c-recursive-memoization-minor-difference/?orderBy=most_votes&topicTags=dynamic-programming\\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Watch Striver\\'s video on youtube.\\nOr you can see this for top down approach\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2964060/c-easy-to-understand-recursion-and-top-down-memoization-dp-solution/"
                    },
                    {
                        "username": "dengzj2014",
                        "content": "when K > prices.length/2, the problem becomes to any transation problem, and it becomes to O(N) problem"
                    },
                    {
                        "username": "Vucibatina",
                        "content": "This does not make sense.  Is there a  charity based stock exchange that gives out stocks for free?"
                    },
                    {
                        "username": "swapnilgupta",
                        "content": "Nope, a stock price can drop to zero if the company goes bankrupt or loses all its value to various reasons. However, a stock price cannot go below zero."
                    },
                    {
                        "username": "Prithvi_raj",
                        "content": "if anyone know solution to this problem please take a moment to explain ...earlier my code was running perfectly with 90% speed .. but some new test cases are added and its giving me TLE...."
                    },
                    {
                        "username": "gvinaycr",
                        "content": "Can anyone explain the expected result?\\n\\nInput:\\t2, [6,1,3,2,4,7]\\nOutput:\\t6\\nExpected:\\t7"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Buy at 1, sell at 3 then buy at 2, sell at 7"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I saw some solutions use the condition: if(k >= n/2) then it is said that this question becomes \"BEST TIME TO BUY AND SELL STOCK II\", in which case you can have unlimited transactions. Suppose we have 7 days (n=7) so the above condition implies that as long as we have k >= 7/2 (i.e k=3) we have unlimited transactions. \\n\\nHowever, by definition, unlimited transactions means k=6. So we are actually saying that as long as we have k>=n/2=3, we are as good as if we have k=6.\\n\\nI don't know if it is correct or not, but I cannot think of a case that this is wrong. Say you have 7 days prices, think of an price array that you will be better off having > 3 transactions than <= 3 transactions. Can anyone think of such an example? If not then it is probably right. Sorry if this is just too trivial to see."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "You need two prices to make a transaction. So you can\\'t make more than n/2 transactions with a price array of size n. \\nIf you have a price array of 7 days, you cannot make more than 3 transactions:\\nBuy on day 1, sell on day 2 -> 1transaction\\nbuy on day 3 sell on day 4 -> 2 transactions\\nbuy 5 sell 6 -> 3 transactions \\nand you\\'re left with only one day so no more possible transaction "
                    },
                    {
                        "username": "deft235",
                        "content": "After having finished this four problems and having read some others\\' answers, I think maybe it will help someone to provide a somehow clear explanation. That\\'s why I wrote this summary. If you find it useful, a like will be appreciated.\\n\\nI will introduce IV before III, as III is actually a special case. However, there exists a different solution for III as well.\\n\\nI,II\\nDefine a peak as a local maximum, a valley as a local minimum.\\n\\nThe essence of these first two problems is to find 1) largest difference between a peak and a valley in an array; 2) the sum of all peak-valley-differences that exist.(as there is no limit of the number of transactions, which makes things easier compared to problem[3,4]).\\n\\nfor (1), keeps track of minimum until current position and records maximum possible profit; for (2), add all positive gaps suffices. Remember, a valley-peak-valley-peak will make profit greater rather than a merged valley-peak though the absolute difference may be greater for the latter one. See the graph explanation on Leetcode solution.\\n\\nIV\\nProblem 4 actually generalises all cases in this scenario. However, as k becomes larger, the problem 4 degrades to problem 2. It is important to note that the dynamic programming solution works when k is less than the maximum possible number of transactions.\\n\\nDP Solution: split the problem hierarchically. Consider the case where we make i transactions, i = 1, 2, ... k.\\n\\nOn each day, there are two states: hold stocks(H) or not hold stocks(NH). Three possible options for the operator: buy, sell or None.\\n\\nDenote the number of days by j. The transition formula for dp here is:\\n\\nH[i][j] = max(NH[i-1][j-1]-prices[j],H[i][j-1]) NH[i][j] = max(H[i][j]+prices[j],NH[i][j-1])\\n\\nExplaination for the first formula: on each day j, either we 1)buy the stock, which begins a new transaction, thus the profit is NH[i-1][j-1] minus current stock price; either 2)None, and the profit keeps the same as on day j-1.\\n\\nFor implementation, note that updating H concerns previous NH and current H, while updating NH concerns both current NH and current NH. Thus, update firstly H, then NH, a one-dimensional dp array suffices.\\n\\nIII\\nProblem 3 can be solved using the solution for 4, but in the case of at most 2 transactions permitted, there exists a simpler solution. As we can find the two(if existed) maximum profit seperately, until day i and after day i.\\n\\nOn day i, we calculate two maximum, in forward and backward ways respectively. Record the sum of these two maximums for each day, and pick the largest one.\\n\\nI\\'ve uploaded my solutions for III and IV on my Github. If you are confused about implementation, visit:\\nhttps://github.com/Maple177/Leetcode/tree/master/typical%20questions/Best%20Time%20to%20Buy%20and%20Sell%20Stock"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    },
                    {
                        "username": "sruzic",
                        "content": "I think there is an error in test case with k = 100 000."
                    },
                    {
                        "username": "at218808",
                        "content": "k less than 100"
                    }
                ]
            },
            {
                "id": 1567545,
                "content": [
                    {
                        "username": "elison",
                        "content": "It seemed ambiguous to me, but I am going off the assumption that buy and sell together is 1 transaction. Am I correct?"
                    },
                    {
                        "username": "benakrish",
                        "content": "Yes."
                    },
                    {
                        "username": "whshph",
                        "content": "Why every solution is bottom up solution? Looking for top-down variant. Actually, I\\'m looking for gradual improvement from brute-force to better brute-force (if any) to top-down dp to bottom up dp. This kind of incremental learning strongly imprints concepts and make it easy to understand the complexity in increments. Please share if there\\'s any such post."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "go for code with love babbar c++ "
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "[@Goblin_Cyanide](/Goblin_Cyanide)  look at this post \\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/900051/fully-explained-all-buy-and-sell-problems-c-recursive-memoization-minor-difference/?orderBy=most_votes&topicTags=dynamic-programming\\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Watch Striver\\'s video on youtube.\\nOr you can see this for top down approach\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2964060/c-easy-to-understand-recursion-and-top-down-memoization-dp-solution/"
                    },
                    {
                        "username": "dengzj2014",
                        "content": "when K > prices.length/2, the problem becomes to any transation problem, and it becomes to O(N) problem"
                    },
                    {
                        "username": "Vucibatina",
                        "content": "This does not make sense.  Is there a  charity based stock exchange that gives out stocks for free?"
                    },
                    {
                        "username": "swapnilgupta",
                        "content": "Nope, a stock price can drop to zero if the company goes bankrupt or loses all its value to various reasons. However, a stock price cannot go below zero."
                    },
                    {
                        "username": "Prithvi_raj",
                        "content": "if anyone know solution to this problem please take a moment to explain ...earlier my code was running perfectly with 90% speed .. but some new test cases are added and its giving me TLE...."
                    },
                    {
                        "username": "gvinaycr",
                        "content": "Can anyone explain the expected result?\\n\\nInput:\\t2, [6,1,3,2,4,7]\\nOutput:\\t6\\nExpected:\\t7"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Buy at 1, sell at 3 then buy at 2, sell at 7"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I saw some solutions use the condition: if(k >= n/2) then it is said that this question becomes \"BEST TIME TO BUY AND SELL STOCK II\", in which case you can have unlimited transactions. Suppose we have 7 days (n=7) so the above condition implies that as long as we have k >= 7/2 (i.e k=3) we have unlimited transactions. \\n\\nHowever, by definition, unlimited transactions means k=6. So we are actually saying that as long as we have k>=n/2=3, we are as good as if we have k=6.\\n\\nI don't know if it is correct or not, but I cannot think of a case that this is wrong. Say you have 7 days prices, think of an price array that you will be better off having > 3 transactions than <= 3 transactions. Can anyone think of such an example? If not then it is probably right. Sorry if this is just too trivial to see."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "You need two prices to make a transaction. So you can\\'t make more than n/2 transactions with a price array of size n. \\nIf you have a price array of 7 days, you cannot make more than 3 transactions:\\nBuy on day 1, sell on day 2 -> 1transaction\\nbuy on day 3 sell on day 4 -> 2 transactions\\nbuy 5 sell 6 -> 3 transactions \\nand you\\'re left with only one day so no more possible transaction "
                    },
                    {
                        "username": "deft235",
                        "content": "After having finished this four problems and having read some others\\' answers, I think maybe it will help someone to provide a somehow clear explanation. That\\'s why I wrote this summary. If you find it useful, a like will be appreciated.\\n\\nI will introduce IV before III, as III is actually a special case. However, there exists a different solution for III as well.\\n\\nI,II\\nDefine a peak as a local maximum, a valley as a local minimum.\\n\\nThe essence of these first two problems is to find 1) largest difference between a peak and a valley in an array; 2) the sum of all peak-valley-differences that exist.(as there is no limit of the number of transactions, which makes things easier compared to problem[3,4]).\\n\\nfor (1), keeps track of minimum until current position and records maximum possible profit; for (2), add all positive gaps suffices. Remember, a valley-peak-valley-peak will make profit greater rather than a merged valley-peak though the absolute difference may be greater for the latter one. See the graph explanation on Leetcode solution.\\n\\nIV\\nProblem 4 actually generalises all cases in this scenario. However, as k becomes larger, the problem 4 degrades to problem 2. It is important to note that the dynamic programming solution works when k is less than the maximum possible number of transactions.\\n\\nDP Solution: split the problem hierarchically. Consider the case where we make i transactions, i = 1, 2, ... k.\\n\\nOn each day, there are two states: hold stocks(H) or not hold stocks(NH). Three possible options for the operator: buy, sell or None.\\n\\nDenote the number of days by j. The transition formula for dp here is:\\n\\nH[i][j] = max(NH[i-1][j-1]-prices[j],H[i][j-1]) NH[i][j] = max(H[i][j]+prices[j],NH[i][j-1])\\n\\nExplaination for the first formula: on each day j, either we 1)buy the stock, which begins a new transaction, thus the profit is NH[i-1][j-1] minus current stock price; either 2)None, and the profit keeps the same as on day j-1.\\n\\nFor implementation, note that updating H concerns previous NH and current H, while updating NH concerns both current NH and current NH. Thus, update firstly H, then NH, a one-dimensional dp array suffices.\\n\\nIII\\nProblem 3 can be solved using the solution for 4, but in the case of at most 2 transactions permitted, there exists a simpler solution. As we can find the two(if existed) maximum profit seperately, until day i and after day i.\\n\\nOn day i, we calculate two maximum, in forward and backward ways respectively. Record the sum of these two maximums for each day, and pick the largest one.\\n\\nI\\'ve uploaded my solutions for III and IV on my Github. If you are confused about implementation, visit:\\nhttps://github.com/Maple177/Leetcode/tree/master/typical%20questions/Best%20Time%20to%20Buy%20and%20Sell%20Stock"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    },
                    {
                        "username": "sruzic",
                        "content": "I think there is an error in test case with k = 100 000."
                    },
                    {
                        "username": "at218808",
                        "content": "k less than 100"
                    }
                ]
            },
            {
                "id": 1571396,
                "content": [
                    {
                        "username": "elison",
                        "content": "It seemed ambiguous to me, but I am going off the assumption that buy and sell together is 1 transaction. Am I correct?"
                    },
                    {
                        "username": "benakrish",
                        "content": "Yes."
                    },
                    {
                        "username": "whshph",
                        "content": "Why every solution is bottom up solution? Looking for top-down variant. Actually, I\\'m looking for gradual improvement from brute-force to better brute-force (if any) to top-down dp to bottom up dp. This kind of incremental learning strongly imprints concepts and make it easy to understand the complexity in increments. Please share if there\\'s any such post."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "go for code with love babbar c++ "
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "[@Goblin_Cyanide](/Goblin_Cyanide)  look at this post \\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/900051/fully-explained-all-buy-and-sell-problems-c-recursive-memoization-minor-difference/?orderBy=most_votes&topicTags=dynamic-programming\\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Watch Striver\\'s video on youtube.\\nOr you can see this for top down approach\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2964060/c-easy-to-understand-recursion-and-top-down-memoization-dp-solution/"
                    },
                    {
                        "username": "dengzj2014",
                        "content": "when K > prices.length/2, the problem becomes to any transation problem, and it becomes to O(N) problem"
                    },
                    {
                        "username": "Vucibatina",
                        "content": "This does not make sense.  Is there a  charity based stock exchange that gives out stocks for free?"
                    },
                    {
                        "username": "swapnilgupta",
                        "content": "Nope, a stock price can drop to zero if the company goes bankrupt or loses all its value to various reasons. However, a stock price cannot go below zero."
                    },
                    {
                        "username": "Prithvi_raj",
                        "content": "if anyone know solution to this problem please take a moment to explain ...earlier my code was running perfectly with 90% speed .. but some new test cases are added and its giving me TLE...."
                    },
                    {
                        "username": "gvinaycr",
                        "content": "Can anyone explain the expected result?\\n\\nInput:\\t2, [6,1,3,2,4,7]\\nOutput:\\t6\\nExpected:\\t7"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Buy at 1, sell at 3 then buy at 2, sell at 7"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I saw some solutions use the condition: if(k >= n/2) then it is said that this question becomes \"BEST TIME TO BUY AND SELL STOCK II\", in which case you can have unlimited transactions. Suppose we have 7 days (n=7) so the above condition implies that as long as we have k >= 7/2 (i.e k=3) we have unlimited transactions. \\n\\nHowever, by definition, unlimited transactions means k=6. So we are actually saying that as long as we have k>=n/2=3, we are as good as if we have k=6.\\n\\nI don't know if it is correct or not, but I cannot think of a case that this is wrong. Say you have 7 days prices, think of an price array that you will be better off having > 3 transactions than <= 3 transactions. Can anyone think of such an example? If not then it is probably right. Sorry if this is just too trivial to see."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "You need two prices to make a transaction. So you can\\'t make more than n/2 transactions with a price array of size n. \\nIf you have a price array of 7 days, you cannot make more than 3 transactions:\\nBuy on day 1, sell on day 2 -> 1transaction\\nbuy on day 3 sell on day 4 -> 2 transactions\\nbuy 5 sell 6 -> 3 transactions \\nand you\\'re left with only one day so no more possible transaction "
                    },
                    {
                        "username": "deft235",
                        "content": "After having finished this four problems and having read some others\\' answers, I think maybe it will help someone to provide a somehow clear explanation. That\\'s why I wrote this summary. If you find it useful, a like will be appreciated.\\n\\nI will introduce IV before III, as III is actually a special case. However, there exists a different solution for III as well.\\n\\nI,II\\nDefine a peak as a local maximum, a valley as a local minimum.\\n\\nThe essence of these first two problems is to find 1) largest difference between a peak and a valley in an array; 2) the sum of all peak-valley-differences that exist.(as there is no limit of the number of transactions, which makes things easier compared to problem[3,4]).\\n\\nfor (1), keeps track of minimum until current position and records maximum possible profit; for (2), add all positive gaps suffices. Remember, a valley-peak-valley-peak will make profit greater rather than a merged valley-peak though the absolute difference may be greater for the latter one. See the graph explanation on Leetcode solution.\\n\\nIV\\nProblem 4 actually generalises all cases in this scenario. However, as k becomes larger, the problem 4 degrades to problem 2. It is important to note that the dynamic programming solution works when k is less than the maximum possible number of transactions.\\n\\nDP Solution: split the problem hierarchically. Consider the case where we make i transactions, i = 1, 2, ... k.\\n\\nOn each day, there are two states: hold stocks(H) or not hold stocks(NH). Three possible options for the operator: buy, sell or None.\\n\\nDenote the number of days by j. The transition formula for dp here is:\\n\\nH[i][j] = max(NH[i-1][j-1]-prices[j],H[i][j-1]) NH[i][j] = max(H[i][j]+prices[j],NH[i][j-1])\\n\\nExplaination for the first formula: on each day j, either we 1)buy the stock, which begins a new transaction, thus the profit is NH[i-1][j-1] minus current stock price; either 2)None, and the profit keeps the same as on day j-1.\\n\\nFor implementation, note that updating H concerns previous NH and current H, while updating NH concerns both current NH and current NH. Thus, update firstly H, then NH, a one-dimensional dp array suffices.\\n\\nIII\\nProblem 3 can be solved using the solution for 4, but in the case of at most 2 transactions permitted, there exists a simpler solution. As we can find the two(if existed) maximum profit seperately, until day i and after day i.\\n\\nOn day i, we calculate two maximum, in forward and backward ways respectively. Record the sum of these two maximums for each day, and pick the largest one.\\n\\nI\\'ve uploaded my solutions for III and IV on my Github. If you are confused about implementation, visit:\\nhttps://github.com/Maple177/Leetcode/tree/master/typical%20questions/Best%20Time%20to%20Buy%20and%20Sell%20Stock"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    },
                    {
                        "username": "sruzic",
                        "content": "I think there is an error in test case with k = 100 000."
                    },
                    {
                        "username": "at218808",
                        "content": "k less than 100"
                    }
                ]
            },
            {
                "id": 1567908,
                "content": [
                    {
                        "username": "elison",
                        "content": "It seemed ambiguous to me, but I am going off the assumption that buy and sell together is 1 transaction. Am I correct?"
                    },
                    {
                        "username": "benakrish",
                        "content": "Yes."
                    },
                    {
                        "username": "whshph",
                        "content": "Why every solution is bottom up solution? Looking for top-down variant. Actually, I\\'m looking for gradual improvement from brute-force to better brute-force (if any) to top-down dp to bottom up dp. This kind of incremental learning strongly imprints concepts and make it easy to understand the complexity in increments. Please share if there\\'s any such post."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "go for code with love babbar c++ "
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "[@Goblin_Cyanide](/Goblin_Cyanide)  look at this post \\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/900051/fully-explained-all-buy-and-sell-problems-c-recursive-memoization-minor-difference/?orderBy=most_votes&topicTags=dynamic-programming\\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Watch Striver\\'s video on youtube.\\nOr you can see this for top down approach\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2964060/c-easy-to-understand-recursion-and-top-down-memoization-dp-solution/"
                    },
                    {
                        "username": "dengzj2014",
                        "content": "when K > prices.length/2, the problem becomes to any transation problem, and it becomes to O(N) problem"
                    },
                    {
                        "username": "Vucibatina",
                        "content": "This does not make sense.  Is there a  charity based stock exchange that gives out stocks for free?"
                    },
                    {
                        "username": "swapnilgupta",
                        "content": "Nope, a stock price can drop to zero if the company goes bankrupt or loses all its value to various reasons. However, a stock price cannot go below zero."
                    },
                    {
                        "username": "Prithvi_raj",
                        "content": "if anyone know solution to this problem please take a moment to explain ...earlier my code was running perfectly with 90% speed .. but some new test cases are added and its giving me TLE...."
                    },
                    {
                        "username": "gvinaycr",
                        "content": "Can anyone explain the expected result?\\n\\nInput:\\t2, [6,1,3,2,4,7]\\nOutput:\\t6\\nExpected:\\t7"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Buy at 1, sell at 3 then buy at 2, sell at 7"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I saw some solutions use the condition: if(k >= n/2) then it is said that this question becomes \"BEST TIME TO BUY AND SELL STOCK II\", in which case you can have unlimited transactions. Suppose we have 7 days (n=7) so the above condition implies that as long as we have k >= 7/2 (i.e k=3) we have unlimited transactions. \\n\\nHowever, by definition, unlimited transactions means k=6. So we are actually saying that as long as we have k>=n/2=3, we are as good as if we have k=6.\\n\\nI don't know if it is correct or not, but I cannot think of a case that this is wrong. Say you have 7 days prices, think of an price array that you will be better off having > 3 transactions than <= 3 transactions. Can anyone think of such an example? If not then it is probably right. Sorry if this is just too trivial to see."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "You need two prices to make a transaction. So you can\\'t make more than n/2 transactions with a price array of size n. \\nIf you have a price array of 7 days, you cannot make more than 3 transactions:\\nBuy on day 1, sell on day 2 -> 1transaction\\nbuy on day 3 sell on day 4 -> 2 transactions\\nbuy 5 sell 6 -> 3 transactions \\nand you\\'re left with only one day so no more possible transaction "
                    },
                    {
                        "username": "deft235",
                        "content": "After having finished this four problems and having read some others\\' answers, I think maybe it will help someone to provide a somehow clear explanation. That\\'s why I wrote this summary. If you find it useful, a like will be appreciated.\\n\\nI will introduce IV before III, as III is actually a special case. However, there exists a different solution for III as well.\\n\\nI,II\\nDefine a peak as a local maximum, a valley as a local minimum.\\n\\nThe essence of these first two problems is to find 1) largest difference between a peak and a valley in an array; 2) the sum of all peak-valley-differences that exist.(as there is no limit of the number of transactions, which makes things easier compared to problem[3,4]).\\n\\nfor (1), keeps track of minimum until current position and records maximum possible profit; for (2), add all positive gaps suffices. Remember, a valley-peak-valley-peak will make profit greater rather than a merged valley-peak though the absolute difference may be greater for the latter one. See the graph explanation on Leetcode solution.\\n\\nIV\\nProblem 4 actually generalises all cases in this scenario. However, as k becomes larger, the problem 4 degrades to problem 2. It is important to note that the dynamic programming solution works when k is less than the maximum possible number of transactions.\\n\\nDP Solution: split the problem hierarchically. Consider the case where we make i transactions, i = 1, 2, ... k.\\n\\nOn each day, there are two states: hold stocks(H) or not hold stocks(NH). Three possible options for the operator: buy, sell or None.\\n\\nDenote the number of days by j. The transition formula for dp here is:\\n\\nH[i][j] = max(NH[i-1][j-1]-prices[j],H[i][j-1]) NH[i][j] = max(H[i][j]+prices[j],NH[i][j-1])\\n\\nExplaination for the first formula: on each day j, either we 1)buy the stock, which begins a new transaction, thus the profit is NH[i-1][j-1] minus current stock price; either 2)None, and the profit keeps the same as on day j-1.\\n\\nFor implementation, note that updating H concerns previous NH and current H, while updating NH concerns both current NH and current NH. Thus, update firstly H, then NH, a one-dimensional dp array suffices.\\n\\nIII\\nProblem 3 can be solved using the solution for 4, but in the case of at most 2 transactions permitted, there exists a simpler solution. As we can find the two(if existed) maximum profit seperately, until day i and after day i.\\n\\nOn day i, we calculate two maximum, in forward and backward ways respectively. Record the sum of these two maximums for each day, and pick the largest one.\\n\\nI\\'ve uploaded my solutions for III and IV on my Github. If you are confused about implementation, visit:\\nhttps://github.com/Maple177/Leetcode/tree/master/typical%20questions/Best%20Time%20to%20Buy%20and%20Sell%20Stock"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    },
                    {
                        "username": "sruzic",
                        "content": "I think there is an error in test case with k = 100 000."
                    },
                    {
                        "username": "at218808",
                        "content": "k less than 100"
                    }
                ]
            },
            {
                "id": 1569805,
                "content": [
                    {
                        "username": "elison",
                        "content": "It seemed ambiguous to me, but I am going off the assumption that buy and sell together is 1 transaction. Am I correct?"
                    },
                    {
                        "username": "benakrish",
                        "content": "Yes."
                    },
                    {
                        "username": "whshph",
                        "content": "Why every solution is bottom up solution? Looking for top-down variant. Actually, I\\'m looking for gradual improvement from brute-force to better brute-force (if any) to top-down dp to bottom up dp. This kind of incremental learning strongly imprints concepts and make it easy to understand the complexity in increments. Please share if there\\'s any such post."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "go for code with love babbar c++ "
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "[@Goblin_Cyanide](/Goblin_Cyanide)  look at this post \\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/900051/fully-explained-all-buy-and-sell-problems-c-recursive-memoization-minor-difference/?orderBy=most_votes&topicTags=dynamic-programming\\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Watch Striver\\'s video on youtube.\\nOr you can see this for top down approach\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2964060/c-easy-to-understand-recursion-and-top-down-memoization-dp-solution/"
                    },
                    {
                        "username": "dengzj2014",
                        "content": "when K > prices.length/2, the problem becomes to any transation problem, and it becomes to O(N) problem"
                    },
                    {
                        "username": "Vucibatina",
                        "content": "This does not make sense.  Is there a  charity based stock exchange that gives out stocks for free?"
                    },
                    {
                        "username": "swapnilgupta",
                        "content": "Nope, a stock price can drop to zero if the company goes bankrupt or loses all its value to various reasons. However, a stock price cannot go below zero."
                    },
                    {
                        "username": "Prithvi_raj",
                        "content": "if anyone know solution to this problem please take a moment to explain ...earlier my code was running perfectly with 90% speed .. but some new test cases are added and its giving me TLE...."
                    },
                    {
                        "username": "gvinaycr",
                        "content": "Can anyone explain the expected result?\\n\\nInput:\\t2, [6,1,3,2,4,7]\\nOutput:\\t6\\nExpected:\\t7"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Buy at 1, sell at 3 then buy at 2, sell at 7"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I saw some solutions use the condition: if(k >= n/2) then it is said that this question becomes \"BEST TIME TO BUY AND SELL STOCK II\", in which case you can have unlimited transactions. Suppose we have 7 days (n=7) so the above condition implies that as long as we have k >= 7/2 (i.e k=3) we have unlimited transactions. \\n\\nHowever, by definition, unlimited transactions means k=6. So we are actually saying that as long as we have k>=n/2=3, we are as good as if we have k=6.\\n\\nI don't know if it is correct or not, but I cannot think of a case that this is wrong. Say you have 7 days prices, think of an price array that you will be better off having > 3 transactions than <= 3 transactions. Can anyone think of such an example? If not then it is probably right. Sorry if this is just too trivial to see."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "You need two prices to make a transaction. So you can\\'t make more than n/2 transactions with a price array of size n. \\nIf you have a price array of 7 days, you cannot make more than 3 transactions:\\nBuy on day 1, sell on day 2 -> 1transaction\\nbuy on day 3 sell on day 4 -> 2 transactions\\nbuy 5 sell 6 -> 3 transactions \\nand you\\'re left with only one day so no more possible transaction "
                    },
                    {
                        "username": "deft235",
                        "content": "After having finished this four problems and having read some others\\' answers, I think maybe it will help someone to provide a somehow clear explanation. That\\'s why I wrote this summary. If you find it useful, a like will be appreciated.\\n\\nI will introduce IV before III, as III is actually a special case. However, there exists a different solution for III as well.\\n\\nI,II\\nDefine a peak as a local maximum, a valley as a local minimum.\\n\\nThe essence of these first two problems is to find 1) largest difference between a peak and a valley in an array; 2) the sum of all peak-valley-differences that exist.(as there is no limit of the number of transactions, which makes things easier compared to problem[3,4]).\\n\\nfor (1), keeps track of minimum until current position and records maximum possible profit; for (2), add all positive gaps suffices. Remember, a valley-peak-valley-peak will make profit greater rather than a merged valley-peak though the absolute difference may be greater for the latter one. See the graph explanation on Leetcode solution.\\n\\nIV\\nProblem 4 actually generalises all cases in this scenario. However, as k becomes larger, the problem 4 degrades to problem 2. It is important to note that the dynamic programming solution works when k is less than the maximum possible number of transactions.\\n\\nDP Solution: split the problem hierarchically. Consider the case where we make i transactions, i = 1, 2, ... k.\\n\\nOn each day, there are two states: hold stocks(H) or not hold stocks(NH). Three possible options for the operator: buy, sell or None.\\n\\nDenote the number of days by j. The transition formula for dp here is:\\n\\nH[i][j] = max(NH[i-1][j-1]-prices[j],H[i][j-1]) NH[i][j] = max(H[i][j]+prices[j],NH[i][j-1])\\n\\nExplaination for the first formula: on each day j, either we 1)buy the stock, which begins a new transaction, thus the profit is NH[i-1][j-1] minus current stock price; either 2)None, and the profit keeps the same as on day j-1.\\n\\nFor implementation, note that updating H concerns previous NH and current H, while updating NH concerns both current NH and current NH. Thus, update firstly H, then NH, a one-dimensional dp array suffices.\\n\\nIII\\nProblem 3 can be solved using the solution for 4, but in the case of at most 2 transactions permitted, there exists a simpler solution. As we can find the two(if existed) maximum profit seperately, until day i and after day i.\\n\\nOn day i, we calculate two maximum, in forward and backward ways respectively. Record the sum of these two maximums for each day, and pick the largest one.\\n\\nI\\'ve uploaded my solutions for III and IV on my Github. If you are confused about implementation, visit:\\nhttps://github.com/Maple177/Leetcode/tree/master/typical%20questions/Best%20Time%20to%20Buy%20and%20Sell%20Stock"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    },
                    {
                        "username": "sruzic",
                        "content": "I think there is an error in test case with k = 100 000."
                    },
                    {
                        "username": "at218808",
                        "content": "k less than 100"
                    }
                ]
            },
            {
                "id": 1570430,
                "content": [
                    {
                        "username": "elison",
                        "content": "It seemed ambiguous to me, but I am going off the assumption that buy and sell together is 1 transaction. Am I correct?"
                    },
                    {
                        "username": "benakrish",
                        "content": "Yes."
                    },
                    {
                        "username": "whshph",
                        "content": "Why every solution is bottom up solution? Looking for top-down variant. Actually, I\\'m looking for gradual improvement from brute-force to better brute-force (if any) to top-down dp to bottom up dp. This kind of incremental learning strongly imprints concepts and make it easy to understand the complexity in increments. Please share if there\\'s any such post."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "go for code with love babbar c++ "
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "[@Goblin_Cyanide](/Goblin_Cyanide)  look at this post \\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/900051/fully-explained-all-buy-and-sell-problems-c-recursive-memoization-minor-difference/?orderBy=most_votes&topicTags=dynamic-programming\\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Watch Striver\\'s video on youtube.\\nOr you can see this for top down approach\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2964060/c-easy-to-understand-recursion-and-top-down-memoization-dp-solution/"
                    },
                    {
                        "username": "dengzj2014",
                        "content": "when K > prices.length/2, the problem becomes to any transation problem, and it becomes to O(N) problem"
                    },
                    {
                        "username": "Vucibatina",
                        "content": "This does not make sense.  Is there a  charity based stock exchange that gives out stocks for free?"
                    },
                    {
                        "username": "swapnilgupta",
                        "content": "Nope, a stock price can drop to zero if the company goes bankrupt or loses all its value to various reasons. However, a stock price cannot go below zero."
                    },
                    {
                        "username": "Prithvi_raj",
                        "content": "if anyone know solution to this problem please take a moment to explain ...earlier my code was running perfectly with 90% speed .. but some new test cases are added and its giving me TLE...."
                    },
                    {
                        "username": "gvinaycr",
                        "content": "Can anyone explain the expected result?\\n\\nInput:\\t2, [6,1,3,2,4,7]\\nOutput:\\t6\\nExpected:\\t7"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Buy at 1, sell at 3 then buy at 2, sell at 7"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I saw some solutions use the condition: if(k >= n/2) then it is said that this question becomes \"BEST TIME TO BUY AND SELL STOCK II\", in which case you can have unlimited transactions. Suppose we have 7 days (n=7) so the above condition implies that as long as we have k >= 7/2 (i.e k=3) we have unlimited transactions. \\n\\nHowever, by definition, unlimited transactions means k=6. So we are actually saying that as long as we have k>=n/2=3, we are as good as if we have k=6.\\n\\nI don't know if it is correct or not, but I cannot think of a case that this is wrong. Say you have 7 days prices, think of an price array that you will be better off having > 3 transactions than <= 3 transactions. Can anyone think of such an example? If not then it is probably right. Sorry if this is just too trivial to see."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "You need two prices to make a transaction. So you can\\'t make more than n/2 transactions with a price array of size n. \\nIf you have a price array of 7 days, you cannot make more than 3 transactions:\\nBuy on day 1, sell on day 2 -> 1transaction\\nbuy on day 3 sell on day 4 -> 2 transactions\\nbuy 5 sell 6 -> 3 transactions \\nand you\\'re left with only one day so no more possible transaction "
                    },
                    {
                        "username": "deft235",
                        "content": "After having finished this four problems and having read some others\\' answers, I think maybe it will help someone to provide a somehow clear explanation. That\\'s why I wrote this summary. If you find it useful, a like will be appreciated.\\n\\nI will introduce IV before III, as III is actually a special case. However, there exists a different solution for III as well.\\n\\nI,II\\nDefine a peak as a local maximum, a valley as a local minimum.\\n\\nThe essence of these first two problems is to find 1) largest difference between a peak and a valley in an array; 2) the sum of all peak-valley-differences that exist.(as there is no limit of the number of transactions, which makes things easier compared to problem[3,4]).\\n\\nfor (1), keeps track of minimum until current position and records maximum possible profit; for (2), add all positive gaps suffices. Remember, a valley-peak-valley-peak will make profit greater rather than a merged valley-peak though the absolute difference may be greater for the latter one. See the graph explanation on Leetcode solution.\\n\\nIV\\nProblem 4 actually generalises all cases in this scenario. However, as k becomes larger, the problem 4 degrades to problem 2. It is important to note that the dynamic programming solution works when k is less than the maximum possible number of transactions.\\n\\nDP Solution: split the problem hierarchically. Consider the case where we make i transactions, i = 1, 2, ... k.\\n\\nOn each day, there are two states: hold stocks(H) or not hold stocks(NH). Three possible options for the operator: buy, sell or None.\\n\\nDenote the number of days by j. The transition formula for dp here is:\\n\\nH[i][j] = max(NH[i-1][j-1]-prices[j],H[i][j-1]) NH[i][j] = max(H[i][j]+prices[j],NH[i][j-1])\\n\\nExplaination for the first formula: on each day j, either we 1)buy the stock, which begins a new transaction, thus the profit is NH[i-1][j-1] minus current stock price; either 2)None, and the profit keeps the same as on day j-1.\\n\\nFor implementation, note that updating H concerns previous NH and current H, while updating NH concerns both current NH and current NH. Thus, update firstly H, then NH, a one-dimensional dp array suffices.\\n\\nIII\\nProblem 3 can be solved using the solution for 4, but in the case of at most 2 transactions permitted, there exists a simpler solution. As we can find the two(if existed) maximum profit seperately, until day i and after day i.\\n\\nOn day i, we calculate two maximum, in forward and backward ways respectively. Record the sum of these two maximums for each day, and pick the largest one.\\n\\nI\\'ve uploaded my solutions for III and IV on my Github. If you are confused about implementation, visit:\\nhttps://github.com/Maple177/Leetcode/tree/master/typical%20questions/Best%20Time%20to%20Buy%20and%20Sell%20Stock"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    },
                    {
                        "username": "sruzic",
                        "content": "I think there is an error in test case with k = 100 000."
                    },
                    {
                        "username": "at218808",
                        "content": "k less than 100"
                    }
                ]
            },
            {
                "id": 1569003,
                "content": [
                    {
                        "username": "elison",
                        "content": "It seemed ambiguous to me, but I am going off the assumption that buy and sell together is 1 transaction. Am I correct?"
                    },
                    {
                        "username": "benakrish",
                        "content": "Yes."
                    },
                    {
                        "username": "whshph",
                        "content": "Why every solution is bottom up solution? Looking for top-down variant. Actually, I\\'m looking for gradual improvement from brute-force to better brute-force (if any) to top-down dp to bottom up dp. This kind of incremental learning strongly imprints concepts and make it easy to understand the complexity in increments. Please share if there\\'s any such post."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "go for code with love babbar c++ "
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "[@Goblin_Cyanide](/Goblin_Cyanide)  look at this post \\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/900051/fully-explained-all-buy-and-sell-problems-c-recursive-memoization-minor-difference/?orderBy=most_votes&topicTags=dynamic-programming\\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Watch Striver\\'s video on youtube.\\nOr you can see this for top down approach\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2964060/c-easy-to-understand-recursion-and-top-down-memoization-dp-solution/"
                    },
                    {
                        "username": "dengzj2014",
                        "content": "when K > prices.length/2, the problem becomes to any transation problem, and it becomes to O(N) problem"
                    },
                    {
                        "username": "Vucibatina",
                        "content": "This does not make sense.  Is there a  charity based stock exchange that gives out stocks for free?"
                    },
                    {
                        "username": "swapnilgupta",
                        "content": "Nope, a stock price can drop to zero if the company goes bankrupt or loses all its value to various reasons. However, a stock price cannot go below zero."
                    },
                    {
                        "username": "Prithvi_raj",
                        "content": "if anyone know solution to this problem please take a moment to explain ...earlier my code was running perfectly with 90% speed .. but some new test cases are added and its giving me TLE...."
                    },
                    {
                        "username": "gvinaycr",
                        "content": "Can anyone explain the expected result?\\n\\nInput:\\t2, [6,1,3,2,4,7]\\nOutput:\\t6\\nExpected:\\t7"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Buy at 1, sell at 3 then buy at 2, sell at 7"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I saw some solutions use the condition: if(k >= n/2) then it is said that this question becomes \"BEST TIME TO BUY AND SELL STOCK II\", in which case you can have unlimited transactions. Suppose we have 7 days (n=7) so the above condition implies that as long as we have k >= 7/2 (i.e k=3) we have unlimited transactions. \\n\\nHowever, by definition, unlimited transactions means k=6. So we are actually saying that as long as we have k>=n/2=3, we are as good as if we have k=6.\\n\\nI don't know if it is correct or not, but I cannot think of a case that this is wrong. Say you have 7 days prices, think of an price array that you will be better off having > 3 transactions than <= 3 transactions. Can anyone think of such an example? If not then it is probably right. Sorry if this is just too trivial to see."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "You need two prices to make a transaction. So you can\\'t make more than n/2 transactions with a price array of size n. \\nIf you have a price array of 7 days, you cannot make more than 3 transactions:\\nBuy on day 1, sell on day 2 -> 1transaction\\nbuy on day 3 sell on day 4 -> 2 transactions\\nbuy 5 sell 6 -> 3 transactions \\nand you\\'re left with only one day so no more possible transaction "
                    },
                    {
                        "username": "deft235",
                        "content": "After having finished this four problems and having read some others\\' answers, I think maybe it will help someone to provide a somehow clear explanation. That\\'s why I wrote this summary. If you find it useful, a like will be appreciated.\\n\\nI will introduce IV before III, as III is actually a special case. However, there exists a different solution for III as well.\\n\\nI,II\\nDefine a peak as a local maximum, a valley as a local minimum.\\n\\nThe essence of these first two problems is to find 1) largest difference between a peak and a valley in an array; 2) the sum of all peak-valley-differences that exist.(as there is no limit of the number of transactions, which makes things easier compared to problem[3,4]).\\n\\nfor (1), keeps track of minimum until current position and records maximum possible profit; for (2), add all positive gaps suffices. Remember, a valley-peak-valley-peak will make profit greater rather than a merged valley-peak though the absolute difference may be greater for the latter one. See the graph explanation on Leetcode solution.\\n\\nIV\\nProblem 4 actually generalises all cases in this scenario. However, as k becomes larger, the problem 4 degrades to problem 2. It is important to note that the dynamic programming solution works when k is less than the maximum possible number of transactions.\\n\\nDP Solution: split the problem hierarchically. Consider the case where we make i transactions, i = 1, 2, ... k.\\n\\nOn each day, there are two states: hold stocks(H) or not hold stocks(NH). Three possible options for the operator: buy, sell or None.\\n\\nDenote the number of days by j. The transition formula for dp here is:\\n\\nH[i][j] = max(NH[i-1][j-1]-prices[j],H[i][j-1]) NH[i][j] = max(H[i][j]+prices[j],NH[i][j-1])\\n\\nExplaination for the first formula: on each day j, either we 1)buy the stock, which begins a new transaction, thus the profit is NH[i-1][j-1] minus current stock price; either 2)None, and the profit keeps the same as on day j-1.\\n\\nFor implementation, note that updating H concerns previous NH and current H, while updating NH concerns both current NH and current NH. Thus, update firstly H, then NH, a one-dimensional dp array suffices.\\n\\nIII\\nProblem 3 can be solved using the solution for 4, but in the case of at most 2 transactions permitted, there exists a simpler solution. As we can find the two(if existed) maximum profit seperately, until day i and after day i.\\n\\nOn day i, we calculate two maximum, in forward and backward ways respectively. Record the sum of these two maximums for each day, and pick the largest one.\\n\\nI\\'ve uploaded my solutions for III and IV on my Github. If you are confused about implementation, visit:\\nhttps://github.com/Maple177/Leetcode/tree/master/typical%20questions/Best%20Time%20to%20Buy%20and%20Sell%20Stock"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    },
                    {
                        "username": "sruzic",
                        "content": "I think there is an error in test case with k = 100 000."
                    },
                    {
                        "username": "at218808",
                        "content": "k less than 100"
                    }
                ]
            },
            {
                "id": 1567221,
                "content": [
                    {
                        "username": "elison",
                        "content": "It seemed ambiguous to me, but I am going off the assumption that buy and sell together is 1 transaction. Am I correct?"
                    },
                    {
                        "username": "benakrish",
                        "content": "Yes."
                    },
                    {
                        "username": "whshph",
                        "content": "Why every solution is bottom up solution? Looking for top-down variant. Actually, I\\'m looking for gradual improvement from brute-force to better brute-force (if any) to top-down dp to bottom up dp. This kind of incremental learning strongly imprints concepts and make it easy to understand the complexity in increments. Please share if there\\'s any such post."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "go for code with love babbar c++ "
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "[@Goblin_Cyanide](/Goblin_Cyanide)  look at this post \\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/900051/fully-explained-all-buy-and-sell-problems-c-recursive-memoization-minor-difference/?orderBy=most_votes&topicTags=dynamic-programming\\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Watch Striver\\'s video on youtube.\\nOr you can see this for top down approach\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2964060/c-easy-to-understand-recursion-and-top-down-memoization-dp-solution/"
                    },
                    {
                        "username": "dengzj2014",
                        "content": "when K > prices.length/2, the problem becomes to any transation problem, and it becomes to O(N) problem"
                    },
                    {
                        "username": "Vucibatina",
                        "content": "This does not make sense.  Is there a  charity based stock exchange that gives out stocks for free?"
                    },
                    {
                        "username": "swapnilgupta",
                        "content": "Nope, a stock price can drop to zero if the company goes bankrupt or loses all its value to various reasons. However, a stock price cannot go below zero."
                    },
                    {
                        "username": "Prithvi_raj",
                        "content": "if anyone know solution to this problem please take a moment to explain ...earlier my code was running perfectly with 90% speed .. but some new test cases are added and its giving me TLE...."
                    },
                    {
                        "username": "gvinaycr",
                        "content": "Can anyone explain the expected result?\\n\\nInput:\\t2, [6,1,3,2,4,7]\\nOutput:\\t6\\nExpected:\\t7"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Buy at 1, sell at 3 then buy at 2, sell at 7"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I saw some solutions use the condition: if(k >= n/2) then it is said that this question becomes \"BEST TIME TO BUY AND SELL STOCK II\", in which case you can have unlimited transactions. Suppose we have 7 days (n=7) so the above condition implies that as long as we have k >= 7/2 (i.e k=3) we have unlimited transactions. \\n\\nHowever, by definition, unlimited transactions means k=6. So we are actually saying that as long as we have k>=n/2=3, we are as good as if we have k=6.\\n\\nI don't know if it is correct or not, but I cannot think of a case that this is wrong. Say you have 7 days prices, think of an price array that you will be better off having > 3 transactions than <= 3 transactions. Can anyone think of such an example? If not then it is probably right. Sorry if this is just too trivial to see."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "You need two prices to make a transaction. So you can\\'t make more than n/2 transactions with a price array of size n. \\nIf you have a price array of 7 days, you cannot make more than 3 transactions:\\nBuy on day 1, sell on day 2 -> 1transaction\\nbuy on day 3 sell on day 4 -> 2 transactions\\nbuy 5 sell 6 -> 3 transactions \\nand you\\'re left with only one day so no more possible transaction "
                    },
                    {
                        "username": "deft235",
                        "content": "After having finished this four problems and having read some others\\' answers, I think maybe it will help someone to provide a somehow clear explanation. That\\'s why I wrote this summary. If you find it useful, a like will be appreciated.\\n\\nI will introduce IV before III, as III is actually a special case. However, there exists a different solution for III as well.\\n\\nI,II\\nDefine a peak as a local maximum, a valley as a local minimum.\\n\\nThe essence of these first two problems is to find 1) largest difference between a peak and a valley in an array; 2) the sum of all peak-valley-differences that exist.(as there is no limit of the number of transactions, which makes things easier compared to problem[3,4]).\\n\\nfor (1), keeps track of minimum until current position and records maximum possible profit; for (2), add all positive gaps suffices. Remember, a valley-peak-valley-peak will make profit greater rather than a merged valley-peak though the absolute difference may be greater for the latter one. See the graph explanation on Leetcode solution.\\n\\nIV\\nProblem 4 actually generalises all cases in this scenario. However, as k becomes larger, the problem 4 degrades to problem 2. It is important to note that the dynamic programming solution works when k is less than the maximum possible number of transactions.\\n\\nDP Solution: split the problem hierarchically. Consider the case where we make i transactions, i = 1, 2, ... k.\\n\\nOn each day, there are two states: hold stocks(H) or not hold stocks(NH). Three possible options for the operator: buy, sell or None.\\n\\nDenote the number of days by j. The transition formula for dp here is:\\n\\nH[i][j] = max(NH[i-1][j-1]-prices[j],H[i][j-1]) NH[i][j] = max(H[i][j]+prices[j],NH[i][j-1])\\n\\nExplaination for the first formula: on each day j, either we 1)buy the stock, which begins a new transaction, thus the profit is NH[i-1][j-1] minus current stock price; either 2)None, and the profit keeps the same as on day j-1.\\n\\nFor implementation, note that updating H concerns previous NH and current H, while updating NH concerns both current NH and current NH. Thus, update firstly H, then NH, a one-dimensional dp array suffices.\\n\\nIII\\nProblem 3 can be solved using the solution for 4, but in the case of at most 2 transactions permitted, there exists a simpler solution. As we can find the two(if existed) maximum profit seperately, until day i and after day i.\\n\\nOn day i, we calculate two maximum, in forward and backward ways respectively. Record the sum of these two maximums for each day, and pick the largest one.\\n\\nI\\'ve uploaded my solutions for III and IV on my Github. If you are confused about implementation, visit:\\nhttps://github.com/Maple177/Leetcode/tree/master/typical%20questions/Best%20Time%20to%20Buy%20and%20Sell%20Stock"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    },
                    {
                        "username": "sruzic",
                        "content": "I think there is an error in test case with k = 100 000."
                    },
                    {
                        "username": "at218808",
                        "content": "k less than 100"
                    }
                ]
            },
            {
                "id": 1568308,
                "content": [
                    {
                        "username": "elison",
                        "content": "It seemed ambiguous to me, but I am going off the assumption that buy and sell together is 1 transaction. Am I correct?"
                    },
                    {
                        "username": "benakrish",
                        "content": "Yes."
                    },
                    {
                        "username": "whshph",
                        "content": "Why every solution is bottom up solution? Looking for top-down variant. Actually, I\\'m looking for gradual improvement from brute-force to better brute-force (if any) to top-down dp to bottom up dp. This kind of incremental learning strongly imprints concepts and make it easy to understand the complexity in increments. Please share if there\\'s any such post."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "go for code with love babbar c++ "
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "[@Goblin_Cyanide](/Goblin_Cyanide)  look at this post \\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/900051/fully-explained-all-buy-and-sell-problems-c-recursive-memoization-minor-difference/?orderBy=most_votes&topicTags=dynamic-programming\\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Watch Striver\\'s video on youtube.\\nOr you can see this for top down approach\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2964060/c-easy-to-understand-recursion-and-top-down-memoization-dp-solution/"
                    },
                    {
                        "username": "dengzj2014",
                        "content": "when K > prices.length/2, the problem becomes to any transation problem, and it becomes to O(N) problem"
                    },
                    {
                        "username": "Vucibatina",
                        "content": "This does not make sense.  Is there a  charity based stock exchange that gives out stocks for free?"
                    },
                    {
                        "username": "swapnilgupta",
                        "content": "Nope, a stock price can drop to zero if the company goes bankrupt or loses all its value to various reasons. However, a stock price cannot go below zero."
                    },
                    {
                        "username": "Prithvi_raj",
                        "content": "if anyone know solution to this problem please take a moment to explain ...earlier my code was running perfectly with 90% speed .. but some new test cases are added and its giving me TLE...."
                    },
                    {
                        "username": "gvinaycr",
                        "content": "Can anyone explain the expected result?\\n\\nInput:\\t2, [6,1,3,2,4,7]\\nOutput:\\t6\\nExpected:\\t7"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Buy at 1, sell at 3 then buy at 2, sell at 7"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I saw some solutions use the condition: if(k >= n/2) then it is said that this question becomes \"BEST TIME TO BUY AND SELL STOCK II\", in which case you can have unlimited transactions. Suppose we have 7 days (n=7) so the above condition implies that as long as we have k >= 7/2 (i.e k=3) we have unlimited transactions. \\n\\nHowever, by definition, unlimited transactions means k=6. So we are actually saying that as long as we have k>=n/2=3, we are as good as if we have k=6.\\n\\nI don't know if it is correct or not, but I cannot think of a case that this is wrong. Say you have 7 days prices, think of an price array that you will be better off having > 3 transactions than <= 3 transactions. Can anyone think of such an example? If not then it is probably right. Sorry if this is just too trivial to see."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "You need two prices to make a transaction. So you can\\'t make more than n/2 transactions with a price array of size n. \\nIf you have a price array of 7 days, you cannot make more than 3 transactions:\\nBuy on day 1, sell on day 2 -> 1transaction\\nbuy on day 3 sell on day 4 -> 2 transactions\\nbuy 5 sell 6 -> 3 transactions \\nand you\\'re left with only one day so no more possible transaction "
                    },
                    {
                        "username": "deft235",
                        "content": "After having finished this four problems and having read some others\\' answers, I think maybe it will help someone to provide a somehow clear explanation. That\\'s why I wrote this summary. If you find it useful, a like will be appreciated.\\n\\nI will introduce IV before III, as III is actually a special case. However, there exists a different solution for III as well.\\n\\nI,II\\nDefine a peak as a local maximum, a valley as a local minimum.\\n\\nThe essence of these first two problems is to find 1) largest difference between a peak and a valley in an array; 2) the sum of all peak-valley-differences that exist.(as there is no limit of the number of transactions, which makes things easier compared to problem[3,4]).\\n\\nfor (1), keeps track of minimum until current position and records maximum possible profit; for (2), add all positive gaps suffices. Remember, a valley-peak-valley-peak will make profit greater rather than a merged valley-peak though the absolute difference may be greater for the latter one. See the graph explanation on Leetcode solution.\\n\\nIV\\nProblem 4 actually generalises all cases in this scenario. However, as k becomes larger, the problem 4 degrades to problem 2. It is important to note that the dynamic programming solution works when k is less than the maximum possible number of transactions.\\n\\nDP Solution: split the problem hierarchically. Consider the case where we make i transactions, i = 1, 2, ... k.\\n\\nOn each day, there are two states: hold stocks(H) or not hold stocks(NH). Three possible options for the operator: buy, sell or None.\\n\\nDenote the number of days by j. The transition formula for dp here is:\\n\\nH[i][j] = max(NH[i-1][j-1]-prices[j],H[i][j-1]) NH[i][j] = max(H[i][j]+prices[j],NH[i][j-1])\\n\\nExplaination for the first formula: on each day j, either we 1)buy the stock, which begins a new transaction, thus the profit is NH[i-1][j-1] minus current stock price; either 2)None, and the profit keeps the same as on day j-1.\\n\\nFor implementation, note that updating H concerns previous NH and current H, while updating NH concerns both current NH and current NH. Thus, update firstly H, then NH, a one-dimensional dp array suffices.\\n\\nIII\\nProblem 3 can be solved using the solution for 4, but in the case of at most 2 transactions permitted, there exists a simpler solution. As we can find the two(if existed) maximum profit seperately, until day i and after day i.\\n\\nOn day i, we calculate two maximum, in forward and backward ways respectively. Record the sum of these two maximums for each day, and pick the largest one.\\n\\nI\\'ve uploaded my solutions for III and IV on my Github. If you are confused about implementation, visit:\\nhttps://github.com/Maple177/Leetcode/tree/master/typical%20questions/Best%20Time%20to%20Buy%20and%20Sell%20Stock"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    },
                    {
                        "username": "sruzic",
                        "content": "I think there is an error in test case with k = 100 000."
                    },
                    {
                        "username": "at218808",
                        "content": "k less than 100"
                    }
                ]
            },
            {
                "id": 1566608,
                "content": [
                    {
                        "username": "elison",
                        "content": "It seemed ambiguous to me, but I am going off the assumption that buy and sell together is 1 transaction. Am I correct?"
                    },
                    {
                        "username": "benakrish",
                        "content": "Yes."
                    },
                    {
                        "username": "whshph",
                        "content": "Why every solution is bottom up solution? Looking for top-down variant. Actually, I\\'m looking for gradual improvement from brute-force to better brute-force (if any) to top-down dp to bottom up dp. This kind of incremental learning strongly imprints concepts and make it easy to understand the complexity in increments. Please share if there\\'s any such post."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "go for code with love babbar c++ "
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "[@Goblin_Cyanide](/Goblin_Cyanide)  look at this post \\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/900051/fully-explained-all-buy-and-sell-problems-c-recursive-memoization-minor-difference/?orderBy=most_votes&topicTags=dynamic-programming\\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Watch Striver\\'s video on youtube.\\nOr you can see this for top down approach\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2964060/c-easy-to-understand-recursion-and-top-down-memoization-dp-solution/"
                    },
                    {
                        "username": "dengzj2014",
                        "content": "when K > prices.length/2, the problem becomes to any transation problem, and it becomes to O(N) problem"
                    },
                    {
                        "username": "Vucibatina",
                        "content": "This does not make sense.  Is there a  charity based stock exchange that gives out stocks for free?"
                    },
                    {
                        "username": "swapnilgupta",
                        "content": "Nope, a stock price can drop to zero if the company goes bankrupt or loses all its value to various reasons. However, a stock price cannot go below zero."
                    },
                    {
                        "username": "Prithvi_raj",
                        "content": "if anyone know solution to this problem please take a moment to explain ...earlier my code was running perfectly with 90% speed .. but some new test cases are added and its giving me TLE...."
                    },
                    {
                        "username": "gvinaycr",
                        "content": "Can anyone explain the expected result?\\n\\nInput:\\t2, [6,1,3,2,4,7]\\nOutput:\\t6\\nExpected:\\t7"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Buy at 1, sell at 3 then buy at 2, sell at 7"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I saw some solutions use the condition: if(k >= n/2) then it is said that this question becomes \"BEST TIME TO BUY AND SELL STOCK II\", in which case you can have unlimited transactions. Suppose we have 7 days (n=7) so the above condition implies that as long as we have k >= 7/2 (i.e k=3) we have unlimited transactions. \\n\\nHowever, by definition, unlimited transactions means k=6. So we are actually saying that as long as we have k>=n/2=3, we are as good as if we have k=6.\\n\\nI don't know if it is correct or not, but I cannot think of a case that this is wrong. Say you have 7 days prices, think of an price array that you will be better off having > 3 transactions than <= 3 transactions. Can anyone think of such an example? If not then it is probably right. Sorry if this is just too trivial to see."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "You need two prices to make a transaction. So you can\\'t make more than n/2 transactions with a price array of size n. \\nIf you have a price array of 7 days, you cannot make more than 3 transactions:\\nBuy on day 1, sell on day 2 -> 1transaction\\nbuy on day 3 sell on day 4 -> 2 transactions\\nbuy 5 sell 6 -> 3 transactions \\nand you\\'re left with only one day so no more possible transaction "
                    },
                    {
                        "username": "deft235",
                        "content": "After having finished this four problems and having read some others\\' answers, I think maybe it will help someone to provide a somehow clear explanation. That\\'s why I wrote this summary. If you find it useful, a like will be appreciated.\\n\\nI will introduce IV before III, as III is actually a special case. However, there exists a different solution for III as well.\\n\\nI,II\\nDefine a peak as a local maximum, a valley as a local minimum.\\n\\nThe essence of these first two problems is to find 1) largest difference between a peak and a valley in an array; 2) the sum of all peak-valley-differences that exist.(as there is no limit of the number of transactions, which makes things easier compared to problem[3,4]).\\n\\nfor (1), keeps track of minimum until current position and records maximum possible profit; for (2), add all positive gaps suffices. Remember, a valley-peak-valley-peak will make profit greater rather than a merged valley-peak though the absolute difference may be greater for the latter one. See the graph explanation on Leetcode solution.\\n\\nIV\\nProblem 4 actually generalises all cases in this scenario. However, as k becomes larger, the problem 4 degrades to problem 2. It is important to note that the dynamic programming solution works when k is less than the maximum possible number of transactions.\\n\\nDP Solution: split the problem hierarchically. Consider the case where we make i transactions, i = 1, 2, ... k.\\n\\nOn each day, there are two states: hold stocks(H) or not hold stocks(NH). Three possible options for the operator: buy, sell or None.\\n\\nDenote the number of days by j. The transition formula for dp here is:\\n\\nH[i][j] = max(NH[i-1][j-1]-prices[j],H[i][j-1]) NH[i][j] = max(H[i][j]+prices[j],NH[i][j-1])\\n\\nExplaination for the first formula: on each day j, either we 1)buy the stock, which begins a new transaction, thus the profit is NH[i-1][j-1] minus current stock price; either 2)None, and the profit keeps the same as on day j-1.\\n\\nFor implementation, note that updating H concerns previous NH and current H, while updating NH concerns both current NH and current NH. Thus, update firstly H, then NH, a one-dimensional dp array suffices.\\n\\nIII\\nProblem 3 can be solved using the solution for 4, but in the case of at most 2 transactions permitted, there exists a simpler solution. As we can find the two(if existed) maximum profit seperately, until day i and after day i.\\n\\nOn day i, we calculate two maximum, in forward and backward ways respectively. Record the sum of these two maximums for each day, and pick the largest one.\\n\\nI\\'ve uploaded my solutions for III and IV on my Github. If you are confused about implementation, visit:\\nhttps://github.com/Maple177/Leetcode/tree/master/typical%20questions/Best%20Time%20to%20Buy%20and%20Sell%20Stock"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    },
                    {
                        "username": "sruzic",
                        "content": "I think there is an error in test case with k = 100 000."
                    },
                    {
                        "username": "at218808",
                        "content": "k less than 100"
                    }
                ]
            },
            {
                "id": 1567909,
                "content": [
                    {
                        "username": "elison",
                        "content": "It seemed ambiguous to me, but I am going off the assumption that buy and sell together is 1 transaction. Am I correct?"
                    },
                    {
                        "username": "benakrish",
                        "content": "Yes."
                    },
                    {
                        "username": "whshph",
                        "content": "Why every solution is bottom up solution? Looking for top-down variant. Actually, I\\'m looking for gradual improvement from brute-force to better brute-force (if any) to top-down dp to bottom up dp. This kind of incremental learning strongly imprints concepts and make it easy to understand the complexity in increments. Please share if there\\'s any such post."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "go for code with love babbar c++ "
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "[@Goblin_Cyanide](/Goblin_Cyanide)  look at this post \\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/900051/fully-explained-all-buy-and-sell-problems-c-recursive-memoization-minor-difference/?orderBy=most_votes&topicTags=dynamic-programming\\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Watch Striver\\'s video on youtube.\\nOr you can see this for top down approach\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2964060/c-easy-to-understand-recursion-and-top-down-memoization-dp-solution/"
                    },
                    {
                        "username": "dengzj2014",
                        "content": "when K > prices.length/2, the problem becomes to any transation problem, and it becomes to O(N) problem"
                    },
                    {
                        "username": "Vucibatina",
                        "content": "This does not make sense.  Is there a  charity based stock exchange that gives out stocks for free?"
                    },
                    {
                        "username": "swapnilgupta",
                        "content": "Nope, a stock price can drop to zero if the company goes bankrupt or loses all its value to various reasons. However, a stock price cannot go below zero."
                    },
                    {
                        "username": "Prithvi_raj",
                        "content": "if anyone know solution to this problem please take a moment to explain ...earlier my code was running perfectly with 90% speed .. but some new test cases are added and its giving me TLE...."
                    },
                    {
                        "username": "gvinaycr",
                        "content": "Can anyone explain the expected result?\\n\\nInput:\\t2, [6,1,3,2,4,7]\\nOutput:\\t6\\nExpected:\\t7"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Buy at 1, sell at 3 then buy at 2, sell at 7"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I saw some solutions use the condition: if(k >= n/2) then it is said that this question becomes \"BEST TIME TO BUY AND SELL STOCK II\", in which case you can have unlimited transactions. Suppose we have 7 days (n=7) so the above condition implies that as long as we have k >= 7/2 (i.e k=3) we have unlimited transactions. \\n\\nHowever, by definition, unlimited transactions means k=6. So we are actually saying that as long as we have k>=n/2=3, we are as good as if we have k=6.\\n\\nI don't know if it is correct or not, but I cannot think of a case that this is wrong. Say you have 7 days prices, think of an price array that you will be better off having > 3 transactions than <= 3 transactions. Can anyone think of such an example? If not then it is probably right. Sorry if this is just too trivial to see."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "You need two prices to make a transaction. So you can\\'t make more than n/2 transactions with a price array of size n. \\nIf you have a price array of 7 days, you cannot make more than 3 transactions:\\nBuy on day 1, sell on day 2 -> 1transaction\\nbuy on day 3 sell on day 4 -> 2 transactions\\nbuy 5 sell 6 -> 3 transactions \\nand you\\'re left with only one day so no more possible transaction "
                    },
                    {
                        "username": "deft235",
                        "content": "After having finished this four problems and having read some others\\' answers, I think maybe it will help someone to provide a somehow clear explanation. That\\'s why I wrote this summary. If you find it useful, a like will be appreciated.\\n\\nI will introduce IV before III, as III is actually a special case. However, there exists a different solution for III as well.\\n\\nI,II\\nDefine a peak as a local maximum, a valley as a local minimum.\\n\\nThe essence of these first two problems is to find 1) largest difference between a peak and a valley in an array; 2) the sum of all peak-valley-differences that exist.(as there is no limit of the number of transactions, which makes things easier compared to problem[3,4]).\\n\\nfor (1), keeps track of minimum until current position and records maximum possible profit; for (2), add all positive gaps suffices. Remember, a valley-peak-valley-peak will make profit greater rather than a merged valley-peak though the absolute difference may be greater for the latter one. See the graph explanation on Leetcode solution.\\n\\nIV\\nProblem 4 actually generalises all cases in this scenario. However, as k becomes larger, the problem 4 degrades to problem 2. It is important to note that the dynamic programming solution works when k is less than the maximum possible number of transactions.\\n\\nDP Solution: split the problem hierarchically. Consider the case where we make i transactions, i = 1, 2, ... k.\\n\\nOn each day, there are two states: hold stocks(H) or not hold stocks(NH). Three possible options for the operator: buy, sell or None.\\n\\nDenote the number of days by j. The transition formula for dp here is:\\n\\nH[i][j] = max(NH[i-1][j-1]-prices[j],H[i][j-1]) NH[i][j] = max(H[i][j]+prices[j],NH[i][j-1])\\n\\nExplaination for the first formula: on each day j, either we 1)buy the stock, which begins a new transaction, thus the profit is NH[i-1][j-1] minus current stock price; either 2)None, and the profit keeps the same as on day j-1.\\n\\nFor implementation, note that updating H concerns previous NH and current H, while updating NH concerns both current NH and current NH. Thus, update firstly H, then NH, a one-dimensional dp array suffices.\\n\\nIII\\nProblem 3 can be solved using the solution for 4, but in the case of at most 2 transactions permitted, there exists a simpler solution. As we can find the two(if existed) maximum profit seperately, until day i and after day i.\\n\\nOn day i, we calculate two maximum, in forward and backward ways respectively. Record the sum of these two maximums for each day, and pick the largest one.\\n\\nI\\'ve uploaded my solutions for III and IV on my Github. If you are confused about implementation, visit:\\nhttps://github.com/Maple177/Leetcode/tree/master/typical%20questions/Best%20Time%20to%20Buy%20and%20Sell%20Stock"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    },
                    {
                        "username": "sruzic",
                        "content": "I think there is an error in test case with k = 100 000."
                    },
                    {
                        "username": "at218808",
                        "content": "k less than 100"
                    }
                ]
            },
            {
                "id": 1567545,
                "content": [
                    {
                        "username": "elison",
                        "content": "It seemed ambiguous to me, but I am going off the assumption that buy and sell together is 1 transaction. Am I correct?"
                    },
                    {
                        "username": "benakrish",
                        "content": "Yes."
                    },
                    {
                        "username": "whshph",
                        "content": "Why every solution is bottom up solution? Looking for top-down variant. Actually, I\\'m looking for gradual improvement from brute-force to better brute-force (if any) to top-down dp to bottom up dp. This kind of incremental learning strongly imprints concepts and make it easy to understand the complexity in increments. Please share if there\\'s any such post."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "go for code with love babbar c++ "
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "[@Goblin_Cyanide](/Goblin_Cyanide)  look at this post \\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/900051/fully-explained-all-buy-and-sell-problems-c-recursive-memoization-minor-difference/?orderBy=most_votes&topicTags=dynamic-programming\\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Watch Striver\\'s video on youtube.\\nOr you can see this for top down approach\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2964060/c-easy-to-understand-recursion-and-top-down-memoization-dp-solution/"
                    },
                    {
                        "username": "dengzj2014",
                        "content": "when K > prices.length/2, the problem becomes to any transation problem, and it becomes to O(N) problem"
                    },
                    {
                        "username": "Vucibatina",
                        "content": "This does not make sense.  Is there a  charity based stock exchange that gives out stocks for free?"
                    },
                    {
                        "username": "swapnilgupta",
                        "content": "Nope, a stock price can drop to zero if the company goes bankrupt or loses all its value to various reasons. However, a stock price cannot go below zero."
                    },
                    {
                        "username": "Prithvi_raj",
                        "content": "if anyone know solution to this problem please take a moment to explain ...earlier my code was running perfectly with 90% speed .. but some new test cases are added and its giving me TLE...."
                    },
                    {
                        "username": "gvinaycr",
                        "content": "Can anyone explain the expected result?\\n\\nInput:\\t2, [6,1,3,2,4,7]\\nOutput:\\t6\\nExpected:\\t7"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Buy at 1, sell at 3 then buy at 2, sell at 7"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I saw some solutions use the condition: if(k >= n/2) then it is said that this question becomes \"BEST TIME TO BUY AND SELL STOCK II\", in which case you can have unlimited transactions. Suppose we have 7 days (n=7) so the above condition implies that as long as we have k >= 7/2 (i.e k=3) we have unlimited transactions. \\n\\nHowever, by definition, unlimited transactions means k=6. So we are actually saying that as long as we have k>=n/2=3, we are as good as if we have k=6.\\n\\nI don't know if it is correct or not, but I cannot think of a case that this is wrong. Say you have 7 days prices, think of an price array that you will be better off having > 3 transactions than <= 3 transactions. Can anyone think of such an example? If not then it is probably right. Sorry if this is just too trivial to see."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "You need two prices to make a transaction. So you can\\'t make more than n/2 transactions with a price array of size n. \\nIf you have a price array of 7 days, you cannot make more than 3 transactions:\\nBuy on day 1, sell on day 2 -> 1transaction\\nbuy on day 3 sell on day 4 -> 2 transactions\\nbuy 5 sell 6 -> 3 transactions \\nand you\\'re left with only one day so no more possible transaction "
                    },
                    {
                        "username": "deft235",
                        "content": "After having finished this four problems and having read some others\\' answers, I think maybe it will help someone to provide a somehow clear explanation. That\\'s why I wrote this summary. If you find it useful, a like will be appreciated.\\n\\nI will introduce IV before III, as III is actually a special case. However, there exists a different solution for III as well.\\n\\nI,II\\nDefine a peak as a local maximum, a valley as a local minimum.\\n\\nThe essence of these first two problems is to find 1) largest difference between a peak and a valley in an array; 2) the sum of all peak-valley-differences that exist.(as there is no limit of the number of transactions, which makes things easier compared to problem[3,4]).\\n\\nfor (1), keeps track of minimum until current position and records maximum possible profit; for (2), add all positive gaps suffices. Remember, a valley-peak-valley-peak will make profit greater rather than a merged valley-peak though the absolute difference may be greater for the latter one. See the graph explanation on Leetcode solution.\\n\\nIV\\nProblem 4 actually generalises all cases in this scenario. However, as k becomes larger, the problem 4 degrades to problem 2. It is important to note that the dynamic programming solution works when k is less than the maximum possible number of transactions.\\n\\nDP Solution: split the problem hierarchically. Consider the case where we make i transactions, i = 1, 2, ... k.\\n\\nOn each day, there are two states: hold stocks(H) or not hold stocks(NH). Three possible options for the operator: buy, sell or None.\\n\\nDenote the number of days by j. The transition formula for dp here is:\\n\\nH[i][j] = max(NH[i-1][j-1]-prices[j],H[i][j-1]) NH[i][j] = max(H[i][j]+prices[j],NH[i][j-1])\\n\\nExplaination for the first formula: on each day j, either we 1)buy the stock, which begins a new transaction, thus the profit is NH[i-1][j-1] minus current stock price; either 2)None, and the profit keeps the same as on day j-1.\\n\\nFor implementation, note that updating H concerns previous NH and current H, while updating NH concerns both current NH and current NH. Thus, update firstly H, then NH, a one-dimensional dp array suffices.\\n\\nIII\\nProblem 3 can be solved using the solution for 4, but in the case of at most 2 transactions permitted, there exists a simpler solution. As we can find the two(if existed) maximum profit seperately, until day i and after day i.\\n\\nOn day i, we calculate two maximum, in forward and backward ways respectively. Record the sum of these two maximums for each day, and pick the largest one.\\n\\nI\\'ve uploaded my solutions for III and IV on my Github. If you are confused about implementation, visit:\\nhttps://github.com/Maple177/Leetcode/tree/master/typical%20questions/Best%20Time%20to%20Buy%20and%20Sell%20Stock"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    },
                    {
                        "username": "sruzic",
                        "content": "I think there is an error in test case with k = 100 000."
                    },
                    {
                        "username": "at218808",
                        "content": "k less than 100"
                    }
                ]
            },
            {
                "id": 1571396,
                "content": [
                    {
                        "username": "elison",
                        "content": "It seemed ambiguous to me, but I am going off the assumption that buy and sell together is 1 transaction. Am I correct?"
                    },
                    {
                        "username": "benakrish",
                        "content": "Yes."
                    },
                    {
                        "username": "whshph",
                        "content": "Why every solution is bottom up solution? Looking for top-down variant. Actually, I\\'m looking for gradual improvement from brute-force to better brute-force (if any) to top-down dp to bottom up dp. This kind of incremental learning strongly imprints concepts and make it easy to understand the complexity in increments. Please share if there\\'s any such post."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "go for code with love babbar c++ "
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "[@Goblin_Cyanide](/Goblin_Cyanide)  look at this post \\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/900051/fully-explained-all-buy-and-sell-problems-c-recursive-memoization-minor-difference/?orderBy=most_votes&topicTags=dynamic-programming\\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Watch Striver\\'s video on youtube.\\nOr you can see this for top down approach\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2964060/c-easy-to-understand-recursion-and-top-down-memoization-dp-solution/"
                    },
                    {
                        "username": "dengzj2014",
                        "content": "when K > prices.length/2, the problem becomes to any transation problem, and it becomes to O(N) problem"
                    },
                    {
                        "username": "Vucibatina",
                        "content": "This does not make sense.  Is there a  charity based stock exchange that gives out stocks for free?"
                    },
                    {
                        "username": "swapnilgupta",
                        "content": "Nope, a stock price can drop to zero if the company goes bankrupt or loses all its value to various reasons. However, a stock price cannot go below zero."
                    },
                    {
                        "username": "Prithvi_raj",
                        "content": "if anyone know solution to this problem please take a moment to explain ...earlier my code was running perfectly with 90% speed .. but some new test cases are added and its giving me TLE...."
                    },
                    {
                        "username": "gvinaycr",
                        "content": "Can anyone explain the expected result?\\n\\nInput:\\t2, [6,1,3,2,4,7]\\nOutput:\\t6\\nExpected:\\t7"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Buy at 1, sell at 3 then buy at 2, sell at 7"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I saw some solutions use the condition: if(k >= n/2) then it is said that this question becomes \"BEST TIME TO BUY AND SELL STOCK II\", in which case you can have unlimited transactions. Suppose we have 7 days (n=7) so the above condition implies that as long as we have k >= 7/2 (i.e k=3) we have unlimited transactions. \\n\\nHowever, by definition, unlimited transactions means k=6. So we are actually saying that as long as we have k>=n/2=3, we are as good as if we have k=6.\\n\\nI don't know if it is correct or not, but I cannot think of a case that this is wrong. Say you have 7 days prices, think of an price array that you will be better off having > 3 transactions than <= 3 transactions. Can anyone think of such an example? If not then it is probably right. Sorry if this is just too trivial to see."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "You need two prices to make a transaction. So you can\\'t make more than n/2 transactions with a price array of size n. \\nIf you have a price array of 7 days, you cannot make more than 3 transactions:\\nBuy on day 1, sell on day 2 -> 1transaction\\nbuy on day 3 sell on day 4 -> 2 transactions\\nbuy 5 sell 6 -> 3 transactions \\nand you\\'re left with only one day so no more possible transaction "
                    },
                    {
                        "username": "deft235",
                        "content": "After having finished this four problems and having read some others\\' answers, I think maybe it will help someone to provide a somehow clear explanation. That\\'s why I wrote this summary. If you find it useful, a like will be appreciated.\\n\\nI will introduce IV before III, as III is actually a special case. However, there exists a different solution for III as well.\\n\\nI,II\\nDefine a peak as a local maximum, a valley as a local minimum.\\n\\nThe essence of these first two problems is to find 1) largest difference between a peak and a valley in an array; 2) the sum of all peak-valley-differences that exist.(as there is no limit of the number of transactions, which makes things easier compared to problem[3,4]).\\n\\nfor (1), keeps track of minimum until current position and records maximum possible profit; for (2), add all positive gaps suffices. Remember, a valley-peak-valley-peak will make profit greater rather than a merged valley-peak though the absolute difference may be greater for the latter one. See the graph explanation on Leetcode solution.\\n\\nIV\\nProblem 4 actually generalises all cases in this scenario. However, as k becomes larger, the problem 4 degrades to problem 2. It is important to note that the dynamic programming solution works when k is less than the maximum possible number of transactions.\\n\\nDP Solution: split the problem hierarchically. Consider the case where we make i transactions, i = 1, 2, ... k.\\n\\nOn each day, there are two states: hold stocks(H) or not hold stocks(NH). Three possible options for the operator: buy, sell or None.\\n\\nDenote the number of days by j. The transition formula for dp here is:\\n\\nH[i][j] = max(NH[i-1][j-1]-prices[j],H[i][j-1]) NH[i][j] = max(H[i][j]+prices[j],NH[i][j-1])\\n\\nExplaination for the first formula: on each day j, either we 1)buy the stock, which begins a new transaction, thus the profit is NH[i-1][j-1] minus current stock price; either 2)None, and the profit keeps the same as on day j-1.\\n\\nFor implementation, note that updating H concerns previous NH and current H, while updating NH concerns both current NH and current NH. Thus, update firstly H, then NH, a one-dimensional dp array suffices.\\n\\nIII\\nProblem 3 can be solved using the solution for 4, but in the case of at most 2 transactions permitted, there exists a simpler solution. As we can find the two(if existed) maximum profit seperately, until day i and after day i.\\n\\nOn day i, we calculate two maximum, in forward and backward ways respectively. Record the sum of these two maximums for each day, and pick the largest one.\\n\\nI\\'ve uploaded my solutions for III and IV on my Github. If you are confused about implementation, visit:\\nhttps://github.com/Maple177/Leetcode/tree/master/typical%20questions/Best%20Time%20to%20Buy%20and%20Sell%20Stock"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    },
                    {
                        "username": "sruzic",
                        "content": "I think there is an error in test case with k = 100 000."
                    },
                    {
                        "username": "at218808",
                        "content": "k less than 100"
                    }
                ]
            },
            {
                "id": 1567908,
                "content": [
                    {
                        "username": "elison",
                        "content": "It seemed ambiguous to me, but I am going off the assumption that buy and sell together is 1 transaction. Am I correct?"
                    },
                    {
                        "username": "benakrish",
                        "content": "Yes."
                    },
                    {
                        "username": "whshph",
                        "content": "Why every solution is bottom up solution? Looking for top-down variant. Actually, I\\'m looking for gradual improvement from brute-force to better brute-force (if any) to top-down dp to bottom up dp. This kind of incremental learning strongly imprints concepts and make it easy to understand the complexity in increments. Please share if there\\'s any such post."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "go for code with love babbar c++ "
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "[@Goblin_Cyanide](/Goblin_Cyanide)  look at this post \\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/900051/fully-explained-all-buy-and-sell-problems-c-recursive-memoization-minor-difference/?orderBy=most_votes&topicTags=dynamic-programming\\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Watch Striver\\'s video on youtube.\\nOr you can see this for top down approach\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2964060/c-easy-to-understand-recursion-and-top-down-memoization-dp-solution/"
                    },
                    {
                        "username": "dengzj2014",
                        "content": "when K > prices.length/2, the problem becomes to any transation problem, and it becomes to O(N) problem"
                    },
                    {
                        "username": "Vucibatina",
                        "content": "This does not make sense.  Is there a  charity based stock exchange that gives out stocks for free?"
                    },
                    {
                        "username": "swapnilgupta",
                        "content": "Nope, a stock price can drop to zero if the company goes bankrupt or loses all its value to various reasons. However, a stock price cannot go below zero."
                    },
                    {
                        "username": "Prithvi_raj",
                        "content": "if anyone know solution to this problem please take a moment to explain ...earlier my code was running perfectly with 90% speed .. but some new test cases are added and its giving me TLE...."
                    },
                    {
                        "username": "gvinaycr",
                        "content": "Can anyone explain the expected result?\\n\\nInput:\\t2, [6,1,3,2,4,7]\\nOutput:\\t6\\nExpected:\\t7"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Buy at 1, sell at 3 then buy at 2, sell at 7"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I saw some solutions use the condition: if(k >= n/2) then it is said that this question becomes \"BEST TIME TO BUY AND SELL STOCK II\", in which case you can have unlimited transactions. Suppose we have 7 days (n=7) so the above condition implies that as long as we have k >= 7/2 (i.e k=3) we have unlimited transactions. \\n\\nHowever, by definition, unlimited transactions means k=6. So we are actually saying that as long as we have k>=n/2=3, we are as good as if we have k=6.\\n\\nI don't know if it is correct or not, but I cannot think of a case that this is wrong. Say you have 7 days prices, think of an price array that you will be better off having > 3 transactions than <= 3 transactions. Can anyone think of such an example? If not then it is probably right. Sorry if this is just too trivial to see."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "You need two prices to make a transaction. So you can\\'t make more than n/2 transactions with a price array of size n. \\nIf you have a price array of 7 days, you cannot make more than 3 transactions:\\nBuy on day 1, sell on day 2 -> 1transaction\\nbuy on day 3 sell on day 4 -> 2 transactions\\nbuy 5 sell 6 -> 3 transactions \\nand you\\'re left with only one day so no more possible transaction "
                    },
                    {
                        "username": "deft235",
                        "content": "After having finished this four problems and having read some others\\' answers, I think maybe it will help someone to provide a somehow clear explanation. That\\'s why I wrote this summary. If you find it useful, a like will be appreciated.\\n\\nI will introduce IV before III, as III is actually a special case. However, there exists a different solution for III as well.\\n\\nI,II\\nDefine a peak as a local maximum, a valley as a local minimum.\\n\\nThe essence of these first two problems is to find 1) largest difference between a peak and a valley in an array; 2) the sum of all peak-valley-differences that exist.(as there is no limit of the number of transactions, which makes things easier compared to problem[3,4]).\\n\\nfor (1), keeps track of minimum until current position and records maximum possible profit; for (2), add all positive gaps suffices. Remember, a valley-peak-valley-peak will make profit greater rather than a merged valley-peak though the absolute difference may be greater for the latter one. See the graph explanation on Leetcode solution.\\n\\nIV\\nProblem 4 actually generalises all cases in this scenario. However, as k becomes larger, the problem 4 degrades to problem 2. It is important to note that the dynamic programming solution works when k is less than the maximum possible number of transactions.\\n\\nDP Solution: split the problem hierarchically. Consider the case where we make i transactions, i = 1, 2, ... k.\\n\\nOn each day, there are two states: hold stocks(H) or not hold stocks(NH). Three possible options for the operator: buy, sell or None.\\n\\nDenote the number of days by j. The transition formula for dp here is:\\n\\nH[i][j] = max(NH[i-1][j-1]-prices[j],H[i][j-1]) NH[i][j] = max(H[i][j]+prices[j],NH[i][j-1])\\n\\nExplaination for the first formula: on each day j, either we 1)buy the stock, which begins a new transaction, thus the profit is NH[i-1][j-1] minus current stock price; either 2)None, and the profit keeps the same as on day j-1.\\n\\nFor implementation, note that updating H concerns previous NH and current H, while updating NH concerns both current NH and current NH. Thus, update firstly H, then NH, a one-dimensional dp array suffices.\\n\\nIII\\nProblem 3 can be solved using the solution for 4, but in the case of at most 2 transactions permitted, there exists a simpler solution. As we can find the two(if existed) maximum profit seperately, until day i and after day i.\\n\\nOn day i, we calculate two maximum, in forward and backward ways respectively. Record the sum of these two maximums for each day, and pick the largest one.\\n\\nI\\'ve uploaded my solutions for III and IV on my Github. If you are confused about implementation, visit:\\nhttps://github.com/Maple177/Leetcode/tree/master/typical%20questions/Best%20Time%20to%20Buy%20and%20Sell%20Stock"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    },
                    {
                        "username": "sruzic",
                        "content": "I think there is an error in test case with k = 100 000."
                    },
                    {
                        "username": "at218808",
                        "content": "k less than 100"
                    }
                ]
            },
            {
                "id": 1569805,
                "content": [
                    {
                        "username": "elison",
                        "content": "It seemed ambiguous to me, but I am going off the assumption that buy and sell together is 1 transaction. Am I correct?"
                    },
                    {
                        "username": "benakrish",
                        "content": "Yes."
                    },
                    {
                        "username": "whshph",
                        "content": "Why every solution is bottom up solution? Looking for top-down variant. Actually, I\\'m looking for gradual improvement from brute-force to better brute-force (if any) to top-down dp to bottom up dp. This kind of incremental learning strongly imprints concepts and make it easy to understand the complexity in increments. Please share if there\\'s any such post."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "go for code with love babbar c++ "
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "[@Goblin_Cyanide](/Goblin_Cyanide)  look at this post \\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/900051/fully-explained-all-buy-and-sell-problems-c-recursive-memoization-minor-difference/?orderBy=most_votes&topicTags=dynamic-programming\\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Watch Striver\\'s video on youtube.\\nOr you can see this for top down approach\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2964060/c-easy-to-understand-recursion-and-top-down-memoization-dp-solution/"
                    },
                    {
                        "username": "dengzj2014",
                        "content": "when K > prices.length/2, the problem becomes to any transation problem, and it becomes to O(N) problem"
                    },
                    {
                        "username": "Vucibatina",
                        "content": "This does not make sense.  Is there a  charity based stock exchange that gives out stocks for free?"
                    },
                    {
                        "username": "swapnilgupta",
                        "content": "Nope, a stock price can drop to zero if the company goes bankrupt or loses all its value to various reasons. However, a stock price cannot go below zero."
                    },
                    {
                        "username": "Prithvi_raj",
                        "content": "if anyone know solution to this problem please take a moment to explain ...earlier my code was running perfectly with 90% speed .. but some new test cases are added and its giving me TLE...."
                    },
                    {
                        "username": "gvinaycr",
                        "content": "Can anyone explain the expected result?\\n\\nInput:\\t2, [6,1,3,2,4,7]\\nOutput:\\t6\\nExpected:\\t7"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Buy at 1, sell at 3 then buy at 2, sell at 7"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I saw some solutions use the condition: if(k >= n/2) then it is said that this question becomes \"BEST TIME TO BUY AND SELL STOCK II\", in which case you can have unlimited transactions. Suppose we have 7 days (n=7) so the above condition implies that as long as we have k >= 7/2 (i.e k=3) we have unlimited transactions. \\n\\nHowever, by definition, unlimited transactions means k=6. So we are actually saying that as long as we have k>=n/2=3, we are as good as if we have k=6.\\n\\nI don't know if it is correct or not, but I cannot think of a case that this is wrong. Say you have 7 days prices, think of an price array that you will be better off having > 3 transactions than <= 3 transactions. Can anyone think of such an example? If not then it is probably right. Sorry if this is just too trivial to see."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "You need two prices to make a transaction. So you can\\'t make more than n/2 transactions with a price array of size n. \\nIf you have a price array of 7 days, you cannot make more than 3 transactions:\\nBuy on day 1, sell on day 2 -> 1transaction\\nbuy on day 3 sell on day 4 -> 2 transactions\\nbuy 5 sell 6 -> 3 transactions \\nand you\\'re left with only one day so no more possible transaction "
                    },
                    {
                        "username": "deft235",
                        "content": "After having finished this four problems and having read some others\\' answers, I think maybe it will help someone to provide a somehow clear explanation. That\\'s why I wrote this summary. If you find it useful, a like will be appreciated.\\n\\nI will introduce IV before III, as III is actually a special case. However, there exists a different solution for III as well.\\n\\nI,II\\nDefine a peak as a local maximum, a valley as a local minimum.\\n\\nThe essence of these first two problems is to find 1) largest difference between a peak and a valley in an array; 2) the sum of all peak-valley-differences that exist.(as there is no limit of the number of transactions, which makes things easier compared to problem[3,4]).\\n\\nfor (1), keeps track of minimum until current position and records maximum possible profit; for (2), add all positive gaps suffices. Remember, a valley-peak-valley-peak will make profit greater rather than a merged valley-peak though the absolute difference may be greater for the latter one. See the graph explanation on Leetcode solution.\\n\\nIV\\nProblem 4 actually generalises all cases in this scenario. However, as k becomes larger, the problem 4 degrades to problem 2. It is important to note that the dynamic programming solution works when k is less than the maximum possible number of transactions.\\n\\nDP Solution: split the problem hierarchically. Consider the case where we make i transactions, i = 1, 2, ... k.\\n\\nOn each day, there are two states: hold stocks(H) or not hold stocks(NH). Three possible options for the operator: buy, sell or None.\\n\\nDenote the number of days by j. The transition formula for dp here is:\\n\\nH[i][j] = max(NH[i-1][j-1]-prices[j],H[i][j-1]) NH[i][j] = max(H[i][j]+prices[j],NH[i][j-1])\\n\\nExplaination for the first formula: on each day j, either we 1)buy the stock, which begins a new transaction, thus the profit is NH[i-1][j-1] minus current stock price; either 2)None, and the profit keeps the same as on day j-1.\\n\\nFor implementation, note that updating H concerns previous NH and current H, while updating NH concerns both current NH and current NH. Thus, update firstly H, then NH, a one-dimensional dp array suffices.\\n\\nIII\\nProblem 3 can be solved using the solution for 4, but in the case of at most 2 transactions permitted, there exists a simpler solution. As we can find the two(if existed) maximum profit seperately, until day i and after day i.\\n\\nOn day i, we calculate two maximum, in forward and backward ways respectively. Record the sum of these two maximums for each day, and pick the largest one.\\n\\nI\\'ve uploaded my solutions for III and IV on my Github. If you are confused about implementation, visit:\\nhttps://github.com/Maple177/Leetcode/tree/master/typical%20questions/Best%20Time%20to%20Buy%20and%20Sell%20Stock"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    },
                    {
                        "username": "sruzic",
                        "content": "I think there is an error in test case with k = 100 000."
                    },
                    {
                        "username": "at218808",
                        "content": "k less than 100"
                    }
                ]
            },
            {
                "id": 1570430,
                "content": [
                    {
                        "username": "elison",
                        "content": "It seemed ambiguous to me, but I am going off the assumption that buy and sell together is 1 transaction. Am I correct?"
                    },
                    {
                        "username": "benakrish",
                        "content": "Yes."
                    },
                    {
                        "username": "whshph",
                        "content": "Why every solution is bottom up solution? Looking for top-down variant. Actually, I\\'m looking for gradual improvement from brute-force to better brute-force (if any) to top-down dp to bottom up dp. This kind of incremental learning strongly imprints concepts and make it easy to understand the complexity in increments. Please share if there\\'s any such post."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "go for code with love babbar c++ "
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "[@Goblin_Cyanide](/Goblin_Cyanide)  look at this post \\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/900051/fully-explained-all-buy-and-sell-problems-c-recursive-memoization-minor-difference/?orderBy=most_votes&topicTags=dynamic-programming\\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Watch Striver\\'s video on youtube.\\nOr you can see this for top down approach\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2964060/c-easy-to-understand-recursion-and-top-down-memoization-dp-solution/"
                    },
                    {
                        "username": "dengzj2014",
                        "content": "when K > prices.length/2, the problem becomes to any transation problem, and it becomes to O(N) problem"
                    },
                    {
                        "username": "Vucibatina",
                        "content": "This does not make sense.  Is there a  charity based stock exchange that gives out stocks for free?"
                    },
                    {
                        "username": "swapnilgupta",
                        "content": "Nope, a stock price can drop to zero if the company goes bankrupt or loses all its value to various reasons. However, a stock price cannot go below zero."
                    },
                    {
                        "username": "Prithvi_raj",
                        "content": "if anyone know solution to this problem please take a moment to explain ...earlier my code was running perfectly with 90% speed .. but some new test cases are added and its giving me TLE...."
                    },
                    {
                        "username": "gvinaycr",
                        "content": "Can anyone explain the expected result?\\n\\nInput:\\t2, [6,1,3,2,4,7]\\nOutput:\\t6\\nExpected:\\t7"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Buy at 1, sell at 3 then buy at 2, sell at 7"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I saw some solutions use the condition: if(k >= n/2) then it is said that this question becomes \"BEST TIME TO BUY AND SELL STOCK II\", in which case you can have unlimited transactions. Suppose we have 7 days (n=7) so the above condition implies that as long as we have k >= 7/2 (i.e k=3) we have unlimited transactions. \\n\\nHowever, by definition, unlimited transactions means k=6. So we are actually saying that as long as we have k>=n/2=3, we are as good as if we have k=6.\\n\\nI don't know if it is correct or not, but I cannot think of a case that this is wrong. Say you have 7 days prices, think of an price array that you will be better off having > 3 transactions than <= 3 transactions. Can anyone think of such an example? If not then it is probably right. Sorry if this is just too trivial to see."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "You need two prices to make a transaction. So you can\\'t make more than n/2 transactions with a price array of size n. \\nIf you have a price array of 7 days, you cannot make more than 3 transactions:\\nBuy on day 1, sell on day 2 -> 1transaction\\nbuy on day 3 sell on day 4 -> 2 transactions\\nbuy 5 sell 6 -> 3 transactions \\nand you\\'re left with only one day so no more possible transaction "
                    },
                    {
                        "username": "deft235",
                        "content": "After having finished this four problems and having read some others\\' answers, I think maybe it will help someone to provide a somehow clear explanation. That\\'s why I wrote this summary. If you find it useful, a like will be appreciated.\\n\\nI will introduce IV before III, as III is actually a special case. However, there exists a different solution for III as well.\\n\\nI,II\\nDefine a peak as a local maximum, a valley as a local minimum.\\n\\nThe essence of these first two problems is to find 1) largest difference between a peak and a valley in an array; 2) the sum of all peak-valley-differences that exist.(as there is no limit of the number of transactions, which makes things easier compared to problem[3,4]).\\n\\nfor (1), keeps track of minimum until current position and records maximum possible profit; for (2), add all positive gaps suffices. Remember, a valley-peak-valley-peak will make profit greater rather than a merged valley-peak though the absolute difference may be greater for the latter one. See the graph explanation on Leetcode solution.\\n\\nIV\\nProblem 4 actually generalises all cases in this scenario. However, as k becomes larger, the problem 4 degrades to problem 2. It is important to note that the dynamic programming solution works when k is less than the maximum possible number of transactions.\\n\\nDP Solution: split the problem hierarchically. Consider the case where we make i transactions, i = 1, 2, ... k.\\n\\nOn each day, there are two states: hold stocks(H) or not hold stocks(NH). Three possible options for the operator: buy, sell or None.\\n\\nDenote the number of days by j. The transition formula for dp here is:\\n\\nH[i][j] = max(NH[i-1][j-1]-prices[j],H[i][j-1]) NH[i][j] = max(H[i][j]+prices[j],NH[i][j-1])\\n\\nExplaination for the first formula: on each day j, either we 1)buy the stock, which begins a new transaction, thus the profit is NH[i-1][j-1] minus current stock price; either 2)None, and the profit keeps the same as on day j-1.\\n\\nFor implementation, note that updating H concerns previous NH and current H, while updating NH concerns both current NH and current NH. Thus, update firstly H, then NH, a one-dimensional dp array suffices.\\n\\nIII\\nProblem 3 can be solved using the solution for 4, but in the case of at most 2 transactions permitted, there exists a simpler solution. As we can find the two(if existed) maximum profit seperately, until day i and after day i.\\n\\nOn day i, we calculate two maximum, in forward and backward ways respectively. Record the sum of these two maximums for each day, and pick the largest one.\\n\\nI\\'ve uploaded my solutions for III and IV on my Github. If you are confused about implementation, visit:\\nhttps://github.com/Maple177/Leetcode/tree/master/typical%20questions/Best%20Time%20to%20Buy%20and%20Sell%20Stock"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    },
                    {
                        "username": "sruzic",
                        "content": "I think there is an error in test case with k = 100 000."
                    },
                    {
                        "username": "at218808",
                        "content": "k less than 100"
                    }
                ]
            },
            {
                "id": 1569003,
                "content": [
                    {
                        "username": "elison",
                        "content": "It seemed ambiguous to me, but I am going off the assumption that buy and sell together is 1 transaction. Am I correct?"
                    },
                    {
                        "username": "benakrish",
                        "content": "Yes."
                    },
                    {
                        "username": "whshph",
                        "content": "Why every solution is bottom up solution? Looking for top-down variant. Actually, I\\'m looking for gradual improvement from brute-force to better brute-force (if any) to top-down dp to bottom up dp. This kind of incremental learning strongly imprints concepts and make it easy to understand the complexity in increments. Please share if there\\'s any such post."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "go for code with love babbar c++ "
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "[@Goblin_Cyanide](/Goblin_Cyanide)  look at this post \\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/900051/fully-explained-all-buy-and-sell-problems-c-recursive-memoization-minor-difference/?orderBy=most_votes&topicTags=dynamic-programming\\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Watch Striver\\'s video on youtube.\\nOr you can see this for top down approach\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2964060/c-easy-to-understand-recursion-and-top-down-memoization-dp-solution/"
                    },
                    {
                        "username": "dengzj2014",
                        "content": "when K > prices.length/2, the problem becomes to any transation problem, and it becomes to O(N) problem"
                    },
                    {
                        "username": "Vucibatina",
                        "content": "This does not make sense.  Is there a  charity based stock exchange that gives out stocks for free?"
                    },
                    {
                        "username": "swapnilgupta",
                        "content": "Nope, a stock price can drop to zero if the company goes bankrupt or loses all its value to various reasons. However, a stock price cannot go below zero."
                    },
                    {
                        "username": "Prithvi_raj",
                        "content": "if anyone know solution to this problem please take a moment to explain ...earlier my code was running perfectly with 90% speed .. but some new test cases are added and its giving me TLE...."
                    },
                    {
                        "username": "gvinaycr",
                        "content": "Can anyone explain the expected result?\\n\\nInput:\\t2, [6,1,3,2,4,7]\\nOutput:\\t6\\nExpected:\\t7"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Buy at 1, sell at 3 then buy at 2, sell at 7"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I saw some solutions use the condition: if(k >= n/2) then it is said that this question becomes \"BEST TIME TO BUY AND SELL STOCK II\", in which case you can have unlimited transactions. Suppose we have 7 days (n=7) so the above condition implies that as long as we have k >= 7/2 (i.e k=3) we have unlimited transactions. \\n\\nHowever, by definition, unlimited transactions means k=6. So we are actually saying that as long as we have k>=n/2=3, we are as good as if we have k=6.\\n\\nI don't know if it is correct or not, but I cannot think of a case that this is wrong. Say you have 7 days prices, think of an price array that you will be better off having > 3 transactions than <= 3 transactions. Can anyone think of such an example? If not then it is probably right. Sorry if this is just too trivial to see."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "You need two prices to make a transaction. So you can\\'t make more than n/2 transactions with a price array of size n. \\nIf you have a price array of 7 days, you cannot make more than 3 transactions:\\nBuy on day 1, sell on day 2 -> 1transaction\\nbuy on day 3 sell on day 4 -> 2 transactions\\nbuy 5 sell 6 -> 3 transactions \\nand you\\'re left with only one day so no more possible transaction "
                    },
                    {
                        "username": "deft235",
                        "content": "After having finished this four problems and having read some others\\' answers, I think maybe it will help someone to provide a somehow clear explanation. That\\'s why I wrote this summary. If you find it useful, a like will be appreciated.\\n\\nI will introduce IV before III, as III is actually a special case. However, there exists a different solution for III as well.\\n\\nI,II\\nDefine a peak as a local maximum, a valley as a local minimum.\\n\\nThe essence of these first two problems is to find 1) largest difference between a peak and a valley in an array; 2) the sum of all peak-valley-differences that exist.(as there is no limit of the number of transactions, which makes things easier compared to problem[3,4]).\\n\\nfor (1), keeps track of minimum until current position and records maximum possible profit; for (2), add all positive gaps suffices. Remember, a valley-peak-valley-peak will make profit greater rather than a merged valley-peak though the absolute difference may be greater for the latter one. See the graph explanation on Leetcode solution.\\n\\nIV\\nProblem 4 actually generalises all cases in this scenario. However, as k becomes larger, the problem 4 degrades to problem 2. It is important to note that the dynamic programming solution works when k is less than the maximum possible number of transactions.\\n\\nDP Solution: split the problem hierarchically. Consider the case where we make i transactions, i = 1, 2, ... k.\\n\\nOn each day, there are two states: hold stocks(H) or not hold stocks(NH). Three possible options for the operator: buy, sell or None.\\n\\nDenote the number of days by j. The transition formula for dp here is:\\n\\nH[i][j] = max(NH[i-1][j-1]-prices[j],H[i][j-1]) NH[i][j] = max(H[i][j]+prices[j],NH[i][j-1])\\n\\nExplaination for the first formula: on each day j, either we 1)buy the stock, which begins a new transaction, thus the profit is NH[i-1][j-1] minus current stock price; either 2)None, and the profit keeps the same as on day j-1.\\n\\nFor implementation, note that updating H concerns previous NH and current H, while updating NH concerns both current NH and current NH. Thus, update firstly H, then NH, a one-dimensional dp array suffices.\\n\\nIII\\nProblem 3 can be solved using the solution for 4, but in the case of at most 2 transactions permitted, there exists a simpler solution. As we can find the two(if existed) maximum profit seperately, until day i and after day i.\\n\\nOn day i, we calculate two maximum, in forward and backward ways respectively. Record the sum of these two maximums for each day, and pick the largest one.\\n\\nI\\'ve uploaded my solutions for III and IV on my Github. If you are confused about implementation, visit:\\nhttps://github.com/Maple177/Leetcode/tree/master/typical%20questions/Best%20Time%20to%20Buy%20and%20Sell%20Stock"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    },
                    {
                        "username": "sruzic",
                        "content": "I think there is an error in test case with k = 100 000."
                    },
                    {
                        "username": "at218808",
                        "content": "k less than 100"
                    }
                ]
            },
            {
                "id": 1573494,
                "content": [
                    {
                        "username": "Chronoviser",
                        "content": "https://www.evernote.com/l/ArC6wyigpi5LYYn7so1p1-bRXn__Q7_kDzc/"
                    },
                    {
                        "username": "nitissssh",
                        "content": "why does this question even exist , buy and sell stock 3 is exactly like this , if you were able to solve that you just here to increase your counts"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Why is this question HARD. Make it medium"
                    },
                    {
                        "username": "vectoreal",
                        "content": "maybe easy?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t know if that\\'s a bug or a feature but my O(kn^2) solution was accepted in python3 among the slowest. Might wanna use some slightly more constraining tescases to avoid that"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "192 / 210 testcases passed and I died.... \\uD83D\\uDE2D"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nstatic int [][][]dp;\\n    static int helper(int []price,int buy,int count,int index){\\n        if(index==price.length||count==0){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(price,0,count-1,index+1)+price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }else{\\n            int ans1=helper(price,1,count,index+1)-price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int k, int[] prices) {\\n        int N=prices.length;\\n        dp=new int[N+1][2+1][k+1];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr){\\n                Arrays.fill(arr2,-1);\\n            }\\n        }\\n        return helper(prices,0,k,0);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "static int [][][]dp;\\n    static int helper(int []price,int buy,int count,int index){\\n        if(index==price.length||count==0){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(price,0,count-1,index+1)+price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }else{\\n            int ans1=helper(price,1,count,index+1)-price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ddhacks007",
                        "content": "Given a matrix A of m \\xD7n integers (non-negative) representing the predicted prices of m\\nstocks for n days and an integer k (positive), find a sequence of at most k transactions\\nthat gives maximum profit. [Hint :- Try to solve for k = 2 first and then expand that\\nsolution.]\\nDesign a \\u0398(m \\u2217(n^2k)) time brute force algorithm for solving Problem2"
                    },
                    {
                        "username": "ddhacks007",
                        "content": "Given a matrix A of m \\xD7n integers (non-negative) representing the predicted prices of m\\nstocks for n days and an integer k (positive), find a sequence of at most k transactions\\nthat gives maximum profit. [Hint :- Try to solve for k = 2 first and then expand that\\nsolution.]\\nDesign a \\u0398(m \\u2217n2k) time brute force algorithm for solving Problem2"
                    }
                ]
            },
            {
                "id": 2037702,
                "content": [
                    {
                        "username": "Chronoviser",
                        "content": "https://www.evernote.com/l/ArC6wyigpi5LYYn7so1p1-bRXn__Q7_kDzc/"
                    },
                    {
                        "username": "nitissssh",
                        "content": "why does this question even exist , buy and sell stock 3 is exactly like this , if you were able to solve that you just here to increase your counts"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Why is this question HARD. Make it medium"
                    },
                    {
                        "username": "vectoreal",
                        "content": "maybe easy?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t know if that\\'s a bug or a feature but my O(kn^2) solution was accepted in python3 among the slowest. Might wanna use some slightly more constraining tescases to avoid that"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "192 / 210 testcases passed and I died.... \\uD83D\\uDE2D"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nstatic int [][][]dp;\\n    static int helper(int []price,int buy,int count,int index){\\n        if(index==price.length||count==0){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(price,0,count-1,index+1)+price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }else{\\n            int ans1=helper(price,1,count,index+1)-price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int k, int[] prices) {\\n        int N=prices.length;\\n        dp=new int[N+1][2+1][k+1];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr){\\n                Arrays.fill(arr2,-1);\\n            }\\n        }\\n        return helper(prices,0,k,0);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "static int [][][]dp;\\n    static int helper(int []price,int buy,int count,int index){\\n        if(index==price.length||count==0){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(price,0,count-1,index+1)+price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }else{\\n            int ans1=helper(price,1,count,index+1)-price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ddhacks007",
                        "content": "Given a matrix A of m \\xD7n integers (non-negative) representing the predicted prices of m\\nstocks for n days and an integer k (positive), find a sequence of at most k transactions\\nthat gives maximum profit. [Hint :- Try to solve for k = 2 first and then expand that\\nsolution.]\\nDesign a \\u0398(m \\u2217(n^2k)) time brute force algorithm for solving Problem2"
                    },
                    {
                        "username": "ddhacks007",
                        "content": "Given a matrix A of m \\xD7n integers (non-negative) representing the predicted prices of m\\nstocks for n days and an integer k (positive), find a sequence of at most k transactions\\nthat gives maximum profit. [Hint :- Try to solve for k = 2 first and then expand that\\nsolution.]\\nDesign a \\u0398(m \\u2217n2k) time brute force algorithm for solving Problem2"
                    }
                ]
            },
            {
                "id": 2022119,
                "content": [
                    {
                        "username": "Chronoviser",
                        "content": "https://www.evernote.com/l/ArC6wyigpi5LYYn7so1p1-bRXn__Q7_kDzc/"
                    },
                    {
                        "username": "nitissssh",
                        "content": "why does this question even exist , buy and sell stock 3 is exactly like this , if you were able to solve that you just here to increase your counts"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Why is this question HARD. Make it medium"
                    },
                    {
                        "username": "vectoreal",
                        "content": "maybe easy?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t know if that\\'s a bug or a feature but my O(kn^2) solution was accepted in python3 among the slowest. Might wanna use some slightly more constraining tescases to avoid that"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "192 / 210 testcases passed and I died.... \\uD83D\\uDE2D"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nstatic int [][][]dp;\\n    static int helper(int []price,int buy,int count,int index){\\n        if(index==price.length||count==0){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(price,0,count-1,index+1)+price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }else{\\n            int ans1=helper(price,1,count,index+1)-price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int k, int[] prices) {\\n        int N=prices.length;\\n        dp=new int[N+1][2+1][k+1];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr){\\n                Arrays.fill(arr2,-1);\\n            }\\n        }\\n        return helper(prices,0,k,0);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "static int [][][]dp;\\n    static int helper(int []price,int buy,int count,int index){\\n        if(index==price.length||count==0){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(price,0,count-1,index+1)+price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }else{\\n            int ans1=helper(price,1,count,index+1)-price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ddhacks007",
                        "content": "Given a matrix A of m \\xD7n integers (non-negative) representing the predicted prices of m\\nstocks for n days and an integer k (positive), find a sequence of at most k transactions\\nthat gives maximum profit. [Hint :- Try to solve for k = 2 first and then expand that\\nsolution.]\\nDesign a \\u0398(m \\u2217(n^2k)) time brute force algorithm for solving Problem2"
                    },
                    {
                        "username": "ddhacks007",
                        "content": "Given a matrix A of m \\xD7n integers (non-negative) representing the predicted prices of m\\nstocks for n days and an integer k (positive), find a sequence of at most k transactions\\nthat gives maximum profit. [Hint :- Try to solve for k = 2 first and then expand that\\nsolution.]\\nDesign a \\u0398(m \\u2217n2k) time brute force algorithm for solving Problem2"
                    }
                ]
            },
            {
                "id": 1855377,
                "content": [
                    {
                        "username": "Chronoviser",
                        "content": "https://www.evernote.com/l/ArC6wyigpi5LYYn7so1p1-bRXn__Q7_kDzc/"
                    },
                    {
                        "username": "nitissssh",
                        "content": "why does this question even exist , buy and sell stock 3 is exactly like this , if you were able to solve that you just here to increase your counts"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Why is this question HARD. Make it medium"
                    },
                    {
                        "username": "vectoreal",
                        "content": "maybe easy?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t know if that\\'s a bug or a feature but my O(kn^2) solution was accepted in python3 among the slowest. Might wanna use some slightly more constraining tescases to avoid that"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "192 / 210 testcases passed and I died.... \\uD83D\\uDE2D"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nstatic int [][][]dp;\\n    static int helper(int []price,int buy,int count,int index){\\n        if(index==price.length||count==0){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(price,0,count-1,index+1)+price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }else{\\n            int ans1=helper(price,1,count,index+1)-price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int k, int[] prices) {\\n        int N=prices.length;\\n        dp=new int[N+1][2+1][k+1];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr){\\n                Arrays.fill(arr2,-1);\\n            }\\n        }\\n        return helper(prices,0,k,0);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "static int [][][]dp;\\n    static int helper(int []price,int buy,int count,int index){\\n        if(index==price.length||count==0){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(price,0,count-1,index+1)+price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }else{\\n            int ans1=helper(price,1,count,index+1)-price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ddhacks007",
                        "content": "Given a matrix A of m \\xD7n integers (non-negative) representing the predicted prices of m\\nstocks for n days and an integer k (positive), find a sequence of at most k transactions\\nthat gives maximum profit. [Hint :- Try to solve for k = 2 first and then expand that\\nsolution.]\\nDesign a \\u0398(m \\u2217(n^2k)) time brute force algorithm for solving Problem2"
                    },
                    {
                        "username": "ddhacks007",
                        "content": "Given a matrix A of m \\xD7n integers (non-negative) representing the predicted prices of m\\nstocks for n days and an integer k (positive), find a sequence of at most k transactions\\nthat gives maximum profit. [Hint :- Try to solve for k = 2 first and then expand that\\nsolution.]\\nDesign a \\u0398(m \\u2217n2k) time brute force algorithm for solving Problem2"
                    }
                ]
            },
            {
                "id": 1826770,
                "content": [
                    {
                        "username": "Chronoviser",
                        "content": "https://www.evernote.com/l/ArC6wyigpi5LYYn7so1p1-bRXn__Q7_kDzc/"
                    },
                    {
                        "username": "nitissssh",
                        "content": "why does this question even exist , buy and sell stock 3 is exactly like this , if you were able to solve that you just here to increase your counts"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Why is this question HARD. Make it medium"
                    },
                    {
                        "username": "vectoreal",
                        "content": "maybe easy?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t know if that\\'s a bug or a feature but my O(kn^2) solution was accepted in python3 among the slowest. Might wanna use some slightly more constraining tescases to avoid that"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "192 / 210 testcases passed and I died.... \\uD83D\\uDE2D"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nstatic int [][][]dp;\\n    static int helper(int []price,int buy,int count,int index){\\n        if(index==price.length||count==0){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(price,0,count-1,index+1)+price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }else{\\n            int ans1=helper(price,1,count,index+1)-price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int k, int[] prices) {\\n        int N=prices.length;\\n        dp=new int[N+1][2+1][k+1];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr){\\n                Arrays.fill(arr2,-1);\\n            }\\n        }\\n        return helper(prices,0,k,0);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "static int [][][]dp;\\n    static int helper(int []price,int buy,int count,int index){\\n        if(index==price.length||count==0){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(price,0,count-1,index+1)+price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }else{\\n            int ans1=helper(price,1,count,index+1)-price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ddhacks007",
                        "content": "Given a matrix A of m \\xD7n integers (non-negative) representing the predicted prices of m\\nstocks for n days and an integer k (positive), find a sequence of at most k transactions\\nthat gives maximum profit. [Hint :- Try to solve for k = 2 first and then expand that\\nsolution.]\\nDesign a \\u0398(m \\u2217(n^2k)) time brute force algorithm for solving Problem2"
                    },
                    {
                        "username": "ddhacks007",
                        "content": "Given a matrix A of m \\xD7n integers (non-negative) representing the predicted prices of m\\nstocks for n days and an integer k (positive), find a sequence of at most k transactions\\nthat gives maximum profit. [Hint :- Try to solve for k = 2 first and then expand that\\nsolution.]\\nDesign a \\u0398(m \\u2217n2k) time brute force algorithm for solving Problem2"
                    }
                ]
            },
            {
                "id": 1815373,
                "content": [
                    {
                        "username": "Chronoviser",
                        "content": "https://www.evernote.com/l/ArC6wyigpi5LYYn7so1p1-bRXn__Q7_kDzc/"
                    },
                    {
                        "username": "nitissssh",
                        "content": "why does this question even exist , buy and sell stock 3 is exactly like this , if you were able to solve that you just here to increase your counts"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Why is this question HARD. Make it medium"
                    },
                    {
                        "username": "vectoreal",
                        "content": "maybe easy?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t know if that\\'s a bug or a feature but my O(kn^2) solution was accepted in python3 among the slowest. Might wanna use some slightly more constraining tescases to avoid that"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "192 / 210 testcases passed and I died.... \\uD83D\\uDE2D"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nstatic int [][][]dp;\\n    static int helper(int []price,int buy,int count,int index){\\n        if(index==price.length||count==0){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(price,0,count-1,index+1)+price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }else{\\n            int ans1=helper(price,1,count,index+1)-price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int k, int[] prices) {\\n        int N=prices.length;\\n        dp=new int[N+1][2+1][k+1];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr){\\n                Arrays.fill(arr2,-1);\\n            }\\n        }\\n        return helper(prices,0,k,0);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "static int [][][]dp;\\n    static int helper(int []price,int buy,int count,int index){\\n        if(index==price.length||count==0){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(price,0,count-1,index+1)+price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }else{\\n            int ans1=helper(price,1,count,index+1)-price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ddhacks007",
                        "content": "Given a matrix A of m \\xD7n integers (non-negative) representing the predicted prices of m\\nstocks for n days and an integer k (positive), find a sequence of at most k transactions\\nthat gives maximum profit. [Hint :- Try to solve for k = 2 first and then expand that\\nsolution.]\\nDesign a \\u0398(m \\u2217(n^2k)) time brute force algorithm for solving Problem2"
                    },
                    {
                        "username": "ddhacks007",
                        "content": "Given a matrix A of m \\xD7n integers (non-negative) representing the predicted prices of m\\nstocks for n days and an integer k (positive), find a sequence of at most k transactions\\nthat gives maximum profit. [Hint :- Try to solve for k = 2 first and then expand that\\nsolution.]\\nDesign a \\u0398(m \\u2217n2k) time brute force algorithm for solving Problem2"
                    }
                ]
            },
            {
                "id": 1815371,
                "content": [
                    {
                        "username": "Chronoviser",
                        "content": "https://www.evernote.com/l/ArC6wyigpi5LYYn7so1p1-bRXn__Q7_kDzc/"
                    },
                    {
                        "username": "nitissssh",
                        "content": "why does this question even exist , buy and sell stock 3 is exactly like this , if you were able to solve that you just here to increase your counts"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Why is this question HARD. Make it medium"
                    },
                    {
                        "username": "vectoreal",
                        "content": "maybe easy?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t know if that\\'s a bug or a feature but my O(kn^2) solution was accepted in python3 among the slowest. Might wanna use some slightly more constraining tescases to avoid that"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "192 / 210 testcases passed and I died.... \\uD83D\\uDE2D"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nstatic int [][][]dp;\\n    static int helper(int []price,int buy,int count,int index){\\n        if(index==price.length||count==0){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(price,0,count-1,index+1)+price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }else{\\n            int ans1=helper(price,1,count,index+1)-price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int k, int[] prices) {\\n        int N=prices.length;\\n        dp=new int[N+1][2+1][k+1];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr){\\n                Arrays.fill(arr2,-1);\\n            }\\n        }\\n        return helper(prices,0,k,0);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "static int [][][]dp;\\n    static int helper(int []price,int buy,int count,int index){\\n        if(index==price.length||count==0){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(price,0,count-1,index+1)+price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }else{\\n            int ans1=helper(price,1,count,index+1)-price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ddhacks007",
                        "content": "Given a matrix A of m \\xD7n integers (non-negative) representing the predicted prices of m\\nstocks for n days and an integer k (positive), find a sequence of at most k transactions\\nthat gives maximum profit. [Hint :- Try to solve for k = 2 first and then expand that\\nsolution.]\\nDesign a \\u0398(m \\u2217(n^2k)) time brute force algorithm for solving Problem2"
                    },
                    {
                        "username": "ddhacks007",
                        "content": "Given a matrix A of m \\xD7n integers (non-negative) representing the predicted prices of m\\nstocks for n days and an integer k (positive), find a sequence of at most k transactions\\nthat gives maximum profit. [Hint :- Try to solve for k = 2 first and then expand that\\nsolution.]\\nDesign a \\u0398(m \\u2217n2k) time brute force algorithm for solving Problem2"
                    }
                ]
            },
            {
                "id": 1756394,
                "content": [
                    {
                        "username": "Chronoviser",
                        "content": "https://www.evernote.com/l/ArC6wyigpi5LYYn7so1p1-bRXn__Q7_kDzc/"
                    },
                    {
                        "username": "nitissssh",
                        "content": "why does this question even exist , buy and sell stock 3 is exactly like this , if you were able to solve that you just here to increase your counts"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Why is this question HARD. Make it medium"
                    },
                    {
                        "username": "vectoreal",
                        "content": "maybe easy?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t know if that\\'s a bug or a feature but my O(kn^2) solution was accepted in python3 among the slowest. Might wanna use some slightly more constraining tescases to avoid that"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "192 / 210 testcases passed and I died.... \\uD83D\\uDE2D"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nstatic int [][][]dp;\\n    static int helper(int []price,int buy,int count,int index){\\n        if(index==price.length||count==0){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(price,0,count-1,index+1)+price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }else{\\n            int ans1=helper(price,1,count,index+1)-price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int k, int[] prices) {\\n        int N=prices.length;\\n        dp=new int[N+1][2+1][k+1];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr){\\n                Arrays.fill(arr2,-1);\\n            }\\n        }\\n        return helper(prices,0,k,0);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "static int [][][]dp;\\n    static int helper(int []price,int buy,int count,int index){\\n        if(index==price.length||count==0){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(price,0,count-1,index+1)+price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }else{\\n            int ans1=helper(price,1,count,index+1)-price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ddhacks007",
                        "content": "Given a matrix A of m \\xD7n integers (non-negative) representing the predicted prices of m\\nstocks for n days and an integer k (positive), find a sequence of at most k transactions\\nthat gives maximum profit. [Hint :- Try to solve for k = 2 first and then expand that\\nsolution.]\\nDesign a \\u0398(m \\u2217(n^2k)) time brute force algorithm for solving Problem2"
                    },
                    {
                        "username": "ddhacks007",
                        "content": "Given a matrix A of m \\xD7n integers (non-negative) representing the predicted prices of m\\nstocks for n days and an integer k (positive), find a sequence of at most k transactions\\nthat gives maximum profit. [Hint :- Try to solve for k = 2 first and then expand that\\nsolution.]\\nDesign a \\u0398(m \\u2217n2k) time brute force algorithm for solving Problem2"
                    }
                ]
            },
            {
                "id": 1681211,
                "content": [
                    {
                        "username": "Chronoviser",
                        "content": "https://www.evernote.com/l/ArC6wyigpi5LYYn7so1p1-bRXn__Q7_kDzc/"
                    },
                    {
                        "username": "nitissssh",
                        "content": "why does this question even exist , buy and sell stock 3 is exactly like this , if you were able to solve that you just here to increase your counts"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Why is this question HARD. Make it medium"
                    },
                    {
                        "username": "vectoreal",
                        "content": "maybe easy?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t know if that\\'s a bug or a feature but my O(kn^2) solution was accepted in python3 among the slowest. Might wanna use some slightly more constraining tescases to avoid that"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "192 / 210 testcases passed and I died.... \\uD83D\\uDE2D"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nstatic int [][][]dp;\\n    static int helper(int []price,int buy,int count,int index){\\n        if(index==price.length||count==0){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(price,0,count-1,index+1)+price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }else{\\n            int ans1=helper(price,1,count,index+1)-price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int k, int[] prices) {\\n        int N=prices.length;\\n        dp=new int[N+1][2+1][k+1];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr){\\n                Arrays.fill(arr2,-1);\\n            }\\n        }\\n        return helper(prices,0,k,0);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "static int [][][]dp;\\n    static int helper(int []price,int buy,int count,int index){\\n        if(index==price.length||count==0){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(price,0,count-1,index+1)+price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }else{\\n            int ans1=helper(price,1,count,index+1)-price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ddhacks007",
                        "content": "Given a matrix A of m \\xD7n integers (non-negative) representing the predicted prices of m\\nstocks for n days and an integer k (positive), find a sequence of at most k transactions\\nthat gives maximum profit. [Hint :- Try to solve for k = 2 first and then expand that\\nsolution.]\\nDesign a \\u0398(m \\u2217(n^2k)) time brute force algorithm for solving Problem2"
                    },
                    {
                        "username": "ddhacks007",
                        "content": "Given a matrix A of m \\xD7n integers (non-negative) representing the predicted prices of m\\nstocks for n days and an integer k (positive), find a sequence of at most k transactions\\nthat gives maximum profit. [Hint :- Try to solve for k = 2 first and then expand that\\nsolution.]\\nDesign a \\u0398(m \\u2217n2k) time brute force algorithm for solving Problem2"
                    }
                ]
            },
            {
                "id": 1681210,
                "content": [
                    {
                        "username": "Chronoviser",
                        "content": "https://www.evernote.com/l/ArC6wyigpi5LYYn7so1p1-bRXn__Q7_kDzc/"
                    },
                    {
                        "username": "nitissssh",
                        "content": "why does this question even exist , buy and sell stock 3 is exactly like this , if you were able to solve that you just here to increase your counts"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Why is this question HARD. Make it medium"
                    },
                    {
                        "username": "vectoreal",
                        "content": "maybe easy?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t know if that\\'s a bug or a feature but my O(kn^2) solution was accepted in python3 among the slowest. Might wanna use some slightly more constraining tescases to avoid that"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "192 / 210 testcases passed and I died.... \\uD83D\\uDE2D"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nstatic int [][][]dp;\\n    static int helper(int []price,int buy,int count,int index){\\n        if(index==price.length||count==0){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(price,0,count-1,index+1)+price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }else{\\n            int ans1=helper(price,1,count,index+1)-price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int k, int[] prices) {\\n        int N=prices.length;\\n        dp=new int[N+1][2+1][k+1];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr){\\n                Arrays.fill(arr2,-1);\\n            }\\n        }\\n        return helper(prices,0,k,0);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "static int [][][]dp;\\n    static int helper(int []price,int buy,int count,int index){\\n        if(index==price.length||count==0){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(price,0,count-1,index+1)+price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }else{\\n            int ans1=helper(price,1,count,index+1)-price[index];\\n            int ans2=helper(price,buy,count,index+1);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ddhacks007",
                        "content": "Given a matrix A of m \\xD7n integers (non-negative) representing the predicted prices of m\\nstocks for n days and an integer k (positive), find a sequence of at most k transactions\\nthat gives maximum profit. [Hint :- Try to solve for k = 2 first and then expand that\\nsolution.]\\nDesign a \\u0398(m \\u2217(n^2k)) time brute force algorithm for solving Problem2"
                    },
                    {
                        "username": "ddhacks007",
                        "content": "Given a matrix A of m \\xD7n integers (non-negative) representing the predicted prices of m\\nstocks for n days and an integer k (positive), find a sequence of at most k transactions\\nthat gives maximum profit. [Hint :- Try to solve for k = 2 first and then expand that\\nsolution.]\\nDesign a \\u0398(m \\u2217n2k) time brute force algorithm for solving Problem2"
                    }
                ]
            }
        ]
    },
    {
        "title": "Unique Word Abbreviation",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1564567,
                "content": [
                    {
                        "username": "2016trojan",
                        "content": "The description (**A word's abbreviation is unique if no other word from the dictionary has the same abbreviation**) is clear however a bit twisting. It took me a few \"Wrong Answer\"s to finally understand what it's asking for.  \\nWe are trying to search for a word in a dictionary. If this word (also this word\\u2019s abbreviation) is not in the dictionary OR this word and only it\\u2019s abbreviation in the dictionary. We call a word\\u2019s abbreviation unique.  \\nEX:  \\n\\n    1) [\\u201cdog\\u201d]; isUnique(\\u201cdig\\u201d);   \\n\\n//False, because \\u201cdig\\u201d has the same abbreviation with \\u201cdog\" and \\u201cdog\\u201d is already in the dictionary. It\\u2019s not unique.  \\n\\n    2) [\\u201cdog\\u201d, \\u201cdog\"]; isUnique(\\u201cdog\\u201d);  \\n\\n //True, because \\u201cdog\\u201d is the only word that has \\u201cd1g\\u201d abbreviation.  \\n\\n    3) [\\u201cdog\\u201d, \\u201cdig\\u201d]; isUnique(\\u201cdog\\u201d);   \\n\\n//False, because if we have more than one word match to the same abbreviation, this abbreviation will never be unique."
                    },
                    {
                        "username": "GaoLiaoLiao",
                        "content": "why should [\"hello\"],isUnique(\"hello\") return [true] ?\\n\\nbut in the case below\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\nisUnique(\"cane\") -> false"
                    },
                    {
                        "username": "user4276gm",
                        "content": "1. Either there is no word in dictionary with same abbreviation or\\n2. If word has same abbreviation with any word of the dictionary then there should be only one word with that abbreviation in dictionary and it has to be same as word (which is being evaluated as unique)."
                    },
                    {
                        "username": "Felomeng",
                        "content": "I\\'m confused by the statement as well. From the description, one cannot deduce this conclusion."
                    },
                    {
                        "username": "medivhsteve",
                        "content": "37 / 53 test cases passed.\\n\\n\\nInput:\\n\\n[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nOutput:\\n\\n[true,true,true,true,true]\\n\\nExpected:\\n\\n[false,false,false,true,true]\\n\\n\\n\\n\\nPlease google \"doge\"."
                    },
                    {
                        "username": "jpaunikar8",
                        "content": "[\"ValidWordAbbr\",\"isUnique\",\"isUnique\",\"isUnique\",\"isUnique\"]\\n[[[\"deer\",\"door\",\"cake\",\"card\"]],[\"dear\"],[\"door\"],[\"cart\"],[\"cake\"]]\\nOutput:\\n[null,false,true,true,true]\\nExpected:\\n[null,false,false,true,true]\\n\\nWhy is door false?"
                    },
                    {
                        "username": "dominion0331",
                        "content": "[@jsk9421](/jsk9421) \"door\" is in the original array\\noriginal array = [\"deer\",\"door\",\"cake\",\"card\"]\\nword = \"door\""
                    },
                    {
                        "username": "jsk9421",
                        "content": "It has to be the only word from the original array with the same abbr. \\nHere, deer and door have the same abbr.\\n\\n\"There\\'s no same abbr\" \\nor\\n1. Having the same word in the original array AND\\n2. No other words in the original array have the same abbr."
                    },
                    {
                        "username": "kai54",
                        "content": "[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nThis should return [true, true, true, true, true]. I don't understand why it will be [false, false, false,true,true]"
                    },
                    {
                        "username": "rainhacker",
                        "content": "Per the example provided in question:\\n\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\n\\nisUnique(\"dear\") -> false\\n\\nisUnique(\"cart\") -> true\\n\\nisUnique(\"cane\") -> false\\n\\nisUnique(\"make\") -> true\\n\\n\\n\\nisUnique(\"cane\") -> false because \"cane\" is not present in the dictionary.\\n\\n\\nHowever, the following test case with empty dictionary as input expects a true response. Seems like this test case is wrong ?\\n\\nInput:          [],isUnique(\"hello\")\\n\\nOutput:       [false]\\n\\nExpected:   [true]"
                    },
                    {
                        "username": "JJ_LL",
                        "content": "Hi everyone,\\n\\nCan anyone tell me what is the mistake and how to fix it?\\n\\nThanks a lot!!!!\\n\\n![image](https://assets.leetcode.com/users/images/d3649a1f-59f2-4c4c-8558-684dd99daa02_1620665080.1850584.png)\\n"
                    },
                    {
                        "username": "javac123",
                        "content": "For input array : {\"deer\",\"door\",\"cake\",\"card\"} why is false expected for the word \"door\"."
                    },
                    {
                        "username": "skywalk3r",
                        "content": "The qestion descrption is not making any sense to me. Can someone explain me in simpler words, in plain english what the author is tryig to convey ?"
                    }
                ]
            },
            {
                "id": 1566492,
                "content": [
                    {
                        "username": "2016trojan",
                        "content": "The description (**A word's abbreviation is unique if no other word from the dictionary has the same abbreviation**) is clear however a bit twisting. It took me a few \"Wrong Answer\"s to finally understand what it's asking for.  \\nWe are trying to search for a word in a dictionary. If this word (also this word\\u2019s abbreviation) is not in the dictionary OR this word and only it\\u2019s abbreviation in the dictionary. We call a word\\u2019s abbreviation unique.  \\nEX:  \\n\\n    1) [\\u201cdog\\u201d]; isUnique(\\u201cdig\\u201d);   \\n\\n//False, because \\u201cdig\\u201d has the same abbreviation with \\u201cdog\" and \\u201cdog\\u201d is already in the dictionary. It\\u2019s not unique.  \\n\\n    2) [\\u201cdog\\u201d, \\u201cdog\"]; isUnique(\\u201cdog\\u201d);  \\n\\n //True, because \\u201cdog\\u201d is the only word that has \\u201cd1g\\u201d abbreviation.  \\n\\n    3) [\\u201cdog\\u201d, \\u201cdig\\u201d]; isUnique(\\u201cdog\\u201d);   \\n\\n//False, because if we have more than one word match to the same abbreviation, this abbreviation will never be unique."
                    },
                    {
                        "username": "GaoLiaoLiao",
                        "content": "why should [\"hello\"],isUnique(\"hello\") return [true] ?\\n\\nbut in the case below\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\nisUnique(\"cane\") -> false"
                    },
                    {
                        "username": "user4276gm",
                        "content": "1. Either there is no word in dictionary with same abbreviation or\\n2. If word has same abbreviation with any word of the dictionary then there should be only one word with that abbreviation in dictionary and it has to be same as word (which is being evaluated as unique)."
                    },
                    {
                        "username": "Felomeng",
                        "content": "I\\'m confused by the statement as well. From the description, one cannot deduce this conclusion."
                    },
                    {
                        "username": "medivhsteve",
                        "content": "37 / 53 test cases passed.\\n\\n\\nInput:\\n\\n[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nOutput:\\n\\n[true,true,true,true,true]\\n\\nExpected:\\n\\n[false,false,false,true,true]\\n\\n\\n\\n\\nPlease google \"doge\"."
                    },
                    {
                        "username": "jpaunikar8",
                        "content": "[\"ValidWordAbbr\",\"isUnique\",\"isUnique\",\"isUnique\",\"isUnique\"]\\n[[[\"deer\",\"door\",\"cake\",\"card\"]],[\"dear\"],[\"door\"],[\"cart\"],[\"cake\"]]\\nOutput:\\n[null,false,true,true,true]\\nExpected:\\n[null,false,false,true,true]\\n\\nWhy is door false?"
                    },
                    {
                        "username": "dominion0331",
                        "content": "[@jsk9421](/jsk9421) \"door\" is in the original array\\noriginal array = [\"deer\",\"door\",\"cake\",\"card\"]\\nword = \"door\""
                    },
                    {
                        "username": "jsk9421",
                        "content": "It has to be the only word from the original array with the same abbr. \\nHere, deer and door have the same abbr.\\n\\n\"There\\'s no same abbr\" \\nor\\n1. Having the same word in the original array AND\\n2. No other words in the original array have the same abbr."
                    },
                    {
                        "username": "kai54",
                        "content": "[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nThis should return [true, true, true, true, true]. I don't understand why it will be [false, false, false,true,true]"
                    },
                    {
                        "username": "rainhacker",
                        "content": "Per the example provided in question:\\n\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\n\\nisUnique(\"dear\") -> false\\n\\nisUnique(\"cart\") -> true\\n\\nisUnique(\"cane\") -> false\\n\\nisUnique(\"make\") -> true\\n\\n\\n\\nisUnique(\"cane\") -> false because \"cane\" is not present in the dictionary.\\n\\n\\nHowever, the following test case with empty dictionary as input expects a true response. Seems like this test case is wrong ?\\n\\nInput:          [],isUnique(\"hello\")\\n\\nOutput:       [false]\\n\\nExpected:   [true]"
                    },
                    {
                        "username": "JJ_LL",
                        "content": "Hi everyone,\\n\\nCan anyone tell me what is the mistake and how to fix it?\\n\\nThanks a lot!!!!\\n\\n![image](https://assets.leetcode.com/users/images/d3649a1f-59f2-4c4c-8558-684dd99daa02_1620665080.1850584.png)\\n"
                    },
                    {
                        "username": "javac123",
                        "content": "For input array : {\"deer\",\"door\",\"cake\",\"card\"} why is false expected for the word \"door\"."
                    },
                    {
                        "username": "skywalk3r",
                        "content": "The qestion descrption is not making any sense to me. Can someone explain me in simpler words, in plain english what the author is tryig to convey ?"
                    }
                ]
            },
            {
                "id": 1570307,
                "content": [
                    {
                        "username": "2016trojan",
                        "content": "The description (**A word's abbreviation is unique if no other word from the dictionary has the same abbreviation**) is clear however a bit twisting. It took me a few \"Wrong Answer\"s to finally understand what it's asking for.  \\nWe are trying to search for a word in a dictionary. If this word (also this word\\u2019s abbreviation) is not in the dictionary OR this word and only it\\u2019s abbreviation in the dictionary. We call a word\\u2019s abbreviation unique.  \\nEX:  \\n\\n    1) [\\u201cdog\\u201d]; isUnique(\\u201cdig\\u201d);   \\n\\n//False, because \\u201cdig\\u201d has the same abbreviation with \\u201cdog\" and \\u201cdog\\u201d is already in the dictionary. It\\u2019s not unique.  \\n\\n    2) [\\u201cdog\\u201d, \\u201cdog\"]; isUnique(\\u201cdog\\u201d);  \\n\\n //True, because \\u201cdog\\u201d is the only word that has \\u201cd1g\\u201d abbreviation.  \\n\\n    3) [\\u201cdog\\u201d, \\u201cdig\\u201d]; isUnique(\\u201cdog\\u201d);   \\n\\n//False, because if we have more than one word match to the same abbreviation, this abbreviation will never be unique."
                    },
                    {
                        "username": "GaoLiaoLiao",
                        "content": "why should [\"hello\"],isUnique(\"hello\") return [true] ?\\n\\nbut in the case below\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\nisUnique(\"cane\") -> false"
                    },
                    {
                        "username": "user4276gm",
                        "content": "1. Either there is no word in dictionary with same abbreviation or\\n2. If word has same abbreviation with any word of the dictionary then there should be only one word with that abbreviation in dictionary and it has to be same as word (which is being evaluated as unique)."
                    },
                    {
                        "username": "Felomeng",
                        "content": "I\\'m confused by the statement as well. From the description, one cannot deduce this conclusion."
                    },
                    {
                        "username": "medivhsteve",
                        "content": "37 / 53 test cases passed.\\n\\n\\nInput:\\n\\n[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nOutput:\\n\\n[true,true,true,true,true]\\n\\nExpected:\\n\\n[false,false,false,true,true]\\n\\n\\n\\n\\nPlease google \"doge\"."
                    },
                    {
                        "username": "jpaunikar8",
                        "content": "[\"ValidWordAbbr\",\"isUnique\",\"isUnique\",\"isUnique\",\"isUnique\"]\\n[[[\"deer\",\"door\",\"cake\",\"card\"]],[\"dear\"],[\"door\"],[\"cart\"],[\"cake\"]]\\nOutput:\\n[null,false,true,true,true]\\nExpected:\\n[null,false,false,true,true]\\n\\nWhy is door false?"
                    },
                    {
                        "username": "dominion0331",
                        "content": "[@jsk9421](/jsk9421) \"door\" is in the original array\\noriginal array = [\"deer\",\"door\",\"cake\",\"card\"]\\nword = \"door\""
                    },
                    {
                        "username": "jsk9421",
                        "content": "It has to be the only word from the original array with the same abbr. \\nHere, deer and door have the same abbr.\\n\\n\"There\\'s no same abbr\" \\nor\\n1. Having the same word in the original array AND\\n2. No other words in the original array have the same abbr."
                    },
                    {
                        "username": "kai54",
                        "content": "[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nThis should return [true, true, true, true, true]. I don't understand why it will be [false, false, false,true,true]"
                    },
                    {
                        "username": "rainhacker",
                        "content": "Per the example provided in question:\\n\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\n\\nisUnique(\"dear\") -> false\\n\\nisUnique(\"cart\") -> true\\n\\nisUnique(\"cane\") -> false\\n\\nisUnique(\"make\") -> true\\n\\n\\n\\nisUnique(\"cane\") -> false because \"cane\" is not present in the dictionary.\\n\\n\\nHowever, the following test case with empty dictionary as input expects a true response. Seems like this test case is wrong ?\\n\\nInput:          [],isUnique(\"hello\")\\n\\nOutput:       [false]\\n\\nExpected:   [true]"
                    },
                    {
                        "username": "JJ_LL",
                        "content": "Hi everyone,\\n\\nCan anyone tell me what is the mistake and how to fix it?\\n\\nThanks a lot!!!!\\n\\n![image](https://assets.leetcode.com/users/images/d3649a1f-59f2-4c4c-8558-684dd99daa02_1620665080.1850584.png)\\n"
                    },
                    {
                        "username": "javac123",
                        "content": "For input array : {\"deer\",\"door\",\"cake\",\"card\"} why is false expected for the word \"door\"."
                    },
                    {
                        "username": "skywalk3r",
                        "content": "The qestion descrption is not making any sense to me. Can someone explain me in simpler words, in plain english what the author is tryig to convey ?"
                    }
                ]
            },
            {
                "id": 1566493,
                "content": [
                    {
                        "username": "2016trojan",
                        "content": "The description (**A word's abbreviation is unique if no other word from the dictionary has the same abbreviation**) is clear however a bit twisting. It took me a few \"Wrong Answer\"s to finally understand what it's asking for.  \\nWe are trying to search for a word in a dictionary. If this word (also this word\\u2019s abbreviation) is not in the dictionary OR this word and only it\\u2019s abbreviation in the dictionary. We call a word\\u2019s abbreviation unique.  \\nEX:  \\n\\n    1) [\\u201cdog\\u201d]; isUnique(\\u201cdig\\u201d);   \\n\\n//False, because \\u201cdig\\u201d has the same abbreviation with \\u201cdog\" and \\u201cdog\\u201d is already in the dictionary. It\\u2019s not unique.  \\n\\n    2) [\\u201cdog\\u201d, \\u201cdog\"]; isUnique(\\u201cdog\\u201d);  \\n\\n //True, because \\u201cdog\\u201d is the only word that has \\u201cd1g\\u201d abbreviation.  \\n\\n    3) [\\u201cdog\\u201d, \\u201cdig\\u201d]; isUnique(\\u201cdog\\u201d);   \\n\\n//False, because if we have more than one word match to the same abbreviation, this abbreviation will never be unique."
                    },
                    {
                        "username": "GaoLiaoLiao",
                        "content": "why should [\"hello\"],isUnique(\"hello\") return [true] ?\\n\\nbut in the case below\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\nisUnique(\"cane\") -> false"
                    },
                    {
                        "username": "user4276gm",
                        "content": "1. Either there is no word in dictionary with same abbreviation or\\n2. If word has same abbreviation with any word of the dictionary then there should be only one word with that abbreviation in dictionary and it has to be same as word (which is being evaluated as unique)."
                    },
                    {
                        "username": "Felomeng",
                        "content": "I\\'m confused by the statement as well. From the description, one cannot deduce this conclusion."
                    },
                    {
                        "username": "medivhsteve",
                        "content": "37 / 53 test cases passed.\\n\\n\\nInput:\\n\\n[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nOutput:\\n\\n[true,true,true,true,true]\\n\\nExpected:\\n\\n[false,false,false,true,true]\\n\\n\\n\\n\\nPlease google \"doge\"."
                    },
                    {
                        "username": "jpaunikar8",
                        "content": "[\"ValidWordAbbr\",\"isUnique\",\"isUnique\",\"isUnique\",\"isUnique\"]\\n[[[\"deer\",\"door\",\"cake\",\"card\"]],[\"dear\"],[\"door\"],[\"cart\"],[\"cake\"]]\\nOutput:\\n[null,false,true,true,true]\\nExpected:\\n[null,false,false,true,true]\\n\\nWhy is door false?"
                    },
                    {
                        "username": "dominion0331",
                        "content": "[@jsk9421](/jsk9421) \"door\" is in the original array\\noriginal array = [\"deer\",\"door\",\"cake\",\"card\"]\\nword = \"door\""
                    },
                    {
                        "username": "jsk9421",
                        "content": "It has to be the only word from the original array with the same abbr. \\nHere, deer and door have the same abbr.\\n\\n\"There\\'s no same abbr\" \\nor\\n1. Having the same word in the original array AND\\n2. No other words in the original array have the same abbr."
                    },
                    {
                        "username": "kai54",
                        "content": "[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nThis should return [true, true, true, true, true]. I don't understand why it will be [false, false, false,true,true]"
                    },
                    {
                        "username": "rainhacker",
                        "content": "Per the example provided in question:\\n\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\n\\nisUnique(\"dear\") -> false\\n\\nisUnique(\"cart\") -> true\\n\\nisUnique(\"cane\") -> false\\n\\nisUnique(\"make\") -> true\\n\\n\\n\\nisUnique(\"cane\") -> false because \"cane\" is not present in the dictionary.\\n\\n\\nHowever, the following test case with empty dictionary as input expects a true response. Seems like this test case is wrong ?\\n\\nInput:          [],isUnique(\"hello\")\\n\\nOutput:       [false]\\n\\nExpected:   [true]"
                    },
                    {
                        "username": "JJ_LL",
                        "content": "Hi everyone,\\n\\nCan anyone tell me what is the mistake and how to fix it?\\n\\nThanks a lot!!!!\\n\\n![image](https://assets.leetcode.com/users/images/d3649a1f-59f2-4c4c-8558-684dd99daa02_1620665080.1850584.png)\\n"
                    },
                    {
                        "username": "javac123",
                        "content": "For input array : {\"deer\",\"door\",\"cake\",\"card\"} why is false expected for the word \"door\"."
                    },
                    {
                        "username": "skywalk3r",
                        "content": "The qestion descrption is not making any sense to me. Can someone explain me in simpler words, in plain english what the author is tryig to convey ?"
                    }
                ]
            },
            {
                "id": 1576105,
                "content": [
                    {
                        "username": "2016trojan",
                        "content": "The description (**A word's abbreviation is unique if no other word from the dictionary has the same abbreviation**) is clear however a bit twisting. It took me a few \"Wrong Answer\"s to finally understand what it's asking for.  \\nWe are trying to search for a word in a dictionary. If this word (also this word\\u2019s abbreviation) is not in the dictionary OR this word and only it\\u2019s abbreviation in the dictionary. We call a word\\u2019s abbreviation unique.  \\nEX:  \\n\\n    1) [\\u201cdog\\u201d]; isUnique(\\u201cdig\\u201d);   \\n\\n//False, because \\u201cdig\\u201d has the same abbreviation with \\u201cdog\" and \\u201cdog\\u201d is already in the dictionary. It\\u2019s not unique.  \\n\\n    2) [\\u201cdog\\u201d, \\u201cdog\"]; isUnique(\\u201cdog\\u201d);  \\n\\n //True, because \\u201cdog\\u201d is the only word that has \\u201cd1g\\u201d abbreviation.  \\n\\n    3) [\\u201cdog\\u201d, \\u201cdig\\u201d]; isUnique(\\u201cdog\\u201d);   \\n\\n//False, because if we have more than one word match to the same abbreviation, this abbreviation will never be unique."
                    },
                    {
                        "username": "GaoLiaoLiao",
                        "content": "why should [\"hello\"],isUnique(\"hello\") return [true] ?\\n\\nbut in the case below\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\nisUnique(\"cane\") -> false"
                    },
                    {
                        "username": "user4276gm",
                        "content": "1. Either there is no word in dictionary with same abbreviation or\\n2. If word has same abbreviation with any word of the dictionary then there should be only one word with that abbreviation in dictionary and it has to be same as word (which is being evaluated as unique)."
                    },
                    {
                        "username": "Felomeng",
                        "content": "I\\'m confused by the statement as well. From the description, one cannot deduce this conclusion."
                    },
                    {
                        "username": "medivhsteve",
                        "content": "37 / 53 test cases passed.\\n\\n\\nInput:\\n\\n[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nOutput:\\n\\n[true,true,true,true,true]\\n\\nExpected:\\n\\n[false,false,false,true,true]\\n\\n\\n\\n\\nPlease google \"doge\"."
                    },
                    {
                        "username": "jpaunikar8",
                        "content": "[\"ValidWordAbbr\",\"isUnique\",\"isUnique\",\"isUnique\",\"isUnique\"]\\n[[[\"deer\",\"door\",\"cake\",\"card\"]],[\"dear\"],[\"door\"],[\"cart\"],[\"cake\"]]\\nOutput:\\n[null,false,true,true,true]\\nExpected:\\n[null,false,false,true,true]\\n\\nWhy is door false?"
                    },
                    {
                        "username": "dominion0331",
                        "content": "[@jsk9421](/jsk9421) \"door\" is in the original array\\noriginal array = [\"deer\",\"door\",\"cake\",\"card\"]\\nword = \"door\""
                    },
                    {
                        "username": "jsk9421",
                        "content": "It has to be the only word from the original array with the same abbr. \\nHere, deer and door have the same abbr.\\n\\n\"There\\'s no same abbr\" \\nor\\n1. Having the same word in the original array AND\\n2. No other words in the original array have the same abbr."
                    },
                    {
                        "username": "kai54",
                        "content": "[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nThis should return [true, true, true, true, true]. I don't understand why it will be [false, false, false,true,true]"
                    },
                    {
                        "username": "rainhacker",
                        "content": "Per the example provided in question:\\n\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\n\\nisUnique(\"dear\") -> false\\n\\nisUnique(\"cart\") -> true\\n\\nisUnique(\"cane\") -> false\\n\\nisUnique(\"make\") -> true\\n\\n\\n\\nisUnique(\"cane\") -> false because \"cane\" is not present in the dictionary.\\n\\n\\nHowever, the following test case with empty dictionary as input expects a true response. Seems like this test case is wrong ?\\n\\nInput:          [],isUnique(\"hello\")\\n\\nOutput:       [false]\\n\\nExpected:   [true]"
                    },
                    {
                        "username": "JJ_LL",
                        "content": "Hi everyone,\\n\\nCan anyone tell me what is the mistake and how to fix it?\\n\\nThanks a lot!!!!\\n\\n![image](https://assets.leetcode.com/users/images/d3649a1f-59f2-4c4c-8558-684dd99daa02_1620665080.1850584.png)\\n"
                    },
                    {
                        "username": "javac123",
                        "content": "For input array : {\"deer\",\"door\",\"cake\",\"card\"} why is false expected for the word \"door\"."
                    },
                    {
                        "username": "skywalk3r",
                        "content": "The qestion descrption is not making any sense to me. Can someone explain me in simpler words, in plain english what the author is tryig to convey ?"
                    }
                ]
            },
            {
                "id": 1569055,
                "content": [
                    {
                        "username": "2016trojan",
                        "content": "The description (**A word's abbreviation is unique if no other word from the dictionary has the same abbreviation**) is clear however a bit twisting. It took me a few \"Wrong Answer\"s to finally understand what it's asking for.  \\nWe are trying to search for a word in a dictionary. If this word (also this word\\u2019s abbreviation) is not in the dictionary OR this word and only it\\u2019s abbreviation in the dictionary. We call a word\\u2019s abbreviation unique.  \\nEX:  \\n\\n    1) [\\u201cdog\\u201d]; isUnique(\\u201cdig\\u201d);   \\n\\n//False, because \\u201cdig\\u201d has the same abbreviation with \\u201cdog\" and \\u201cdog\\u201d is already in the dictionary. It\\u2019s not unique.  \\n\\n    2) [\\u201cdog\\u201d, \\u201cdog\"]; isUnique(\\u201cdog\\u201d);  \\n\\n //True, because \\u201cdog\\u201d is the only word that has \\u201cd1g\\u201d abbreviation.  \\n\\n    3) [\\u201cdog\\u201d, \\u201cdig\\u201d]; isUnique(\\u201cdog\\u201d);   \\n\\n//False, because if we have more than one word match to the same abbreviation, this abbreviation will never be unique."
                    },
                    {
                        "username": "GaoLiaoLiao",
                        "content": "why should [\"hello\"],isUnique(\"hello\") return [true] ?\\n\\nbut in the case below\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\nisUnique(\"cane\") -> false"
                    },
                    {
                        "username": "user4276gm",
                        "content": "1. Either there is no word in dictionary with same abbreviation or\\n2. If word has same abbreviation with any word of the dictionary then there should be only one word with that abbreviation in dictionary and it has to be same as word (which is being evaluated as unique)."
                    },
                    {
                        "username": "Felomeng",
                        "content": "I\\'m confused by the statement as well. From the description, one cannot deduce this conclusion."
                    },
                    {
                        "username": "medivhsteve",
                        "content": "37 / 53 test cases passed.\\n\\n\\nInput:\\n\\n[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nOutput:\\n\\n[true,true,true,true,true]\\n\\nExpected:\\n\\n[false,false,false,true,true]\\n\\n\\n\\n\\nPlease google \"doge\"."
                    },
                    {
                        "username": "jpaunikar8",
                        "content": "[\"ValidWordAbbr\",\"isUnique\",\"isUnique\",\"isUnique\",\"isUnique\"]\\n[[[\"deer\",\"door\",\"cake\",\"card\"]],[\"dear\"],[\"door\"],[\"cart\"],[\"cake\"]]\\nOutput:\\n[null,false,true,true,true]\\nExpected:\\n[null,false,false,true,true]\\n\\nWhy is door false?"
                    },
                    {
                        "username": "dominion0331",
                        "content": "[@jsk9421](/jsk9421) \"door\" is in the original array\\noriginal array = [\"deer\",\"door\",\"cake\",\"card\"]\\nword = \"door\""
                    },
                    {
                        "username": "jsk9421",
                        "content": "It has to be the only word from the original array with the same abbr. \\nHere, deer and door have the same abbr.\\n\\n\"There\\'s no same abbr\" \\nor\\n1. Having the same word in the original array AND\\n2. No other words in the original array have the same abbr."
                    },
                    {
                        "username": "kai54",
                        "content": "[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nThis should return [true, true, true, true, true]. I don't understand why it will be [false, false, false,true,true]"
                    },
                    {
                        "username": "rainhacker",
                        "content": "Per the example provided in question:\\n\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\n\\nisUnique(\"dear\") -> false\\n\\nisUnique(\"cart\") -> true\\n\\nisUnique(\"cane\") -> false\\n\\nisUnique(\"make\") -> true\\n\\n\\n\\nisUnique(\"cane\") -> false because \"cane\" is not present in the dictionary.\\n\\n\\nHowever, the following test case with empty dictionary as input expects a true response. Seems like this test case is wrong ?\\n\\nInput:          [],isUnique(\"hello\")\\n\\nOutput:       [false]\\n\\nExpected:   [true]"
                    },
                    {
                        "username": "JJ_LL",
                        "content": "Hi everyone,\\n\\nCan anyone tell me what is the mistake and how to fix it?\\n\\nThanks a lot!!!!\\n\\n![image](https://assets.leetcode.com/users/images/d3649a1f-59f2-4c4c-8558-684dd99daa02_1620665080.1850584.png)\\n"
                    },
                    {
                        "username": "javac123",
                        "content": "For input array : {\"deer\",\"door\",\"cake\",\"card\"} why is false expected for the word \"door\"."
                    },
                    {
                        "username": "skywalk3r",
                        "content": "The qestion descrption is not making any sense to me. Can someone explain me in simpler words, in plain english what the author is tryig to convey ?"
                    }
                ]
            },
            {
                "id": 1569056,
                "content": [
                    {
                        "username": "2016trojan",
                        "content": "The description (**A word's abbreviation is unique if no other word from the dictionary has the same abbreviation**) is clear however a bit twisting. It took me a few \"Wrong Answer\"s to finally understand what it's asking for.  \\nWe are trying to search for a word in a dictionary. If this word (also this word\\u2019s abbreviation) is not in the dictionary OR this word and only it\\u2019s abbreviation in the dictionary. We call a word\\u2019s abbreviation unique.  \\nEX:  \\n\\n    1) [\\u201cdog\\u201d]; isUnique(\\u201cdig\\u201d);   \\n\\n//False, because \\u201cdig\\u201d has the same abbreviation with \\u201cdog\" and \\u201cdog\\u201d is already in the dictionary. It\\u2019s not unique.  \\n\\n    2) [\\u201cdog\\u201d, \\u201cdog\"]; isUnique(\\u201cdog\\u201d);  \\n\\n //True, because \\u201cdog\\u201d is the only word that has \\u201cd1g\\u201d abbreviation.  \\n\\n    3) [\\u201cdog\\u201d, \\u201cdig\\u201d]; isUnique(\\u201cdog\\u201d);   \\n\\n//False, because if we have more than one word match to the same abbreviation, this abbreviation will never be unique."
                    },
                    {
                        "username": "GaoLiaoLiao",
                        "content": "why should [\"hello\"],isUnique(\"hello\") return [true] ?\\n\\nbut in the case below\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\nisUnique(\"cane\") -> false"
                    },
                    {
                        "username": "user4276gm",
                        "content": "1. Either there is no word in dictionary with same abbreviation or\\n2. If word has same abbreviation with any word of the dictionary then there should be only one word with that abbreviation in dictionary and it has to be same as word (which is being evaluated as unique)."
                    },
                    {
                        "username": "Felomeng",
                        "content": "I\\'m confused by the statement as well. From the description, one cannot deduce this conclusion."
                    },
                    {
                        "username": "medivhsteve",
                        "content": "37 / 53 test cases passed.\\n\\n\\nInput:\\n\\n[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nOutput:\\n\\n[true,true,true,true,true]\\n\\nExpected:\\n\\n[false,false,false,true,true]\\n\\n\\n\\n\\nPlease google \"doge\"."
                    },
                    {
                        "username": "jpaunikar8",
                        "content": "[\"ValidWordAbbr\",\"isUnique\",\"isUnique\",\"isUnique\",\"isUnique\"]\\n[[[\"deer\",\"door\",\"cake\",\"card\"]],[\"dear\"],[\"door\"],[\"cart\"],[\"cake\"]]\\nOutput:\\n[null,false,true,true,true]\\nExpected:\\n[null,false,false,true,true]\\n\\nWhy is door false?"
                    },
                    {
                        "username": "dominion0331",
                        "content": "[@jsk9421](/jsk9421) \"door\" is in the original array\\noriginal array = [\"deer\",\"door\",\"cake\",\"card\"]\\nword = \"door\""
                    },
                    {
                        "username": "jsk9421",
                        "content": "It has to be the only word from the original array with the same abbr. \\nHere, deer and door have the same abbr.\\n\\n\"There\\'s no same abbr\" \\nor\\n1. Having the same word in the original array AND\\n2. No other words in the original array have the same abbr."
                    },
                    {
                        "username": "kai54",
                        "content": "[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nThis should return [true, true, true, true, true]. I don't understand why it will be [false, false, false,true,true]"
                    },
                    {
                        "username": "rainhacker",
                        "content": "Per the example provided in question:\\n\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\n\\nisUnique(\"dear\") -> false\\n\\nisUnique(\"cart\") -> true\\n\\nisUnique(\"cane\") -> false\\n\\nisUnique(\"make\") -> true\\n\\n\\n\\nisUnique(\"cane\") -> false because \"cane\" is not present in the dictionary.\\n\\n\\nHowever, the following test case with empty dictionary as input expects a true response. Seems like this test case is wrong ?\\n\\nInput:          [],isUnique(\"hello\")\\n\\nOutput:       [false]\\n\\nExpected:   [true]"
                    },
                    {
                        "username": "JJ_LL",
                        "content": "Hi everyone,\\n\\nCan anyone tell me what is the mistake and how to fix it?\\n\\nThanks a lot!!!!\\n\\n![image](https://assets.leetcode.com/users/images/d3649a1f-59f2-4c4c-8558-684dd99daa02_1620665080.1850584.png)\\n"
                    },
                    {
                        "username": "javac123",
                        "content": "For input array : {\"deer\",\"door\",\"cake\",\"card\"} why is false expected for the word \"door\"."
                    },
                    {
                        "username": "skywalk3r",
                        "content": "The qestion descrption is not making any sense to me. Can someone explain me in simpler words, in plain english what the author is tryig to convey ?"
                    }
                ]
            },
            {
                "id": 1575250,
                "content": [
                    {
                        "username": "2016trojan",
                        "content": "The description (**A word's abbreviation is unique if no other word from the dictionary has the same abbreviation**) is clear however a bit twisting. It took me a few \"Wrong Answer\"s to finally understand what it's asking for.  \\nWe are trying to search for a word in a dictionary. If this word (also this word\\u2019s abbreviation) is not in the dictionary OR this word and only it\\u2019s abbreviation in the dictionary. We call a word\\u2019s abbreviation unique.  \\nEX:  \\n\\n    1) [\\u201cdog\\u201d]; isUnique(\\u201cdig\\u201d);   \\n\\n//False, because \\u201cdig\\u201d has the same abbreviation with \\u201cdog\" and \\u201cdog\\u201d is already in the dictionary. It\\u2019s not unique.  \\n\\n    2) [\\u201cdog\\u201d, \\u201cdog\"]; isUnique(\\u201cdog\\u201d);  \\n\\n //True, because \\u201cdog\\u201d is the only word that has \\u201cd1g\\u201d abbreviation.  \\n\\n    3) [\\u201cdog\\u201d, \\u201cdig\\u201d]; isUnique(\\u201cdog\\u201d);   \\n\\n//False, because if we have more than one word match to the same abbreviation, this abbreviation will never be unique."
                    },
                    {
                        "username": "GaoLiaoLiao",
                        "content": "why should [\"hello\"],isUnique(\"hello\") return [true] ?\\n\\nbut in the case below\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\nisUnique(\"cane\") -> false"
                    },
                    {
                        "username": "user4276gm",
                        "content": "1. Either there is no word in dictionary with same abbreviation or\\n2. If word has same abbreviation with any word of the dictionary then there should be only one word with that abbreviation in dictionary and it has to be same as word (which is being evaluated as unique)."
                    },
                    {
                        "username": "Felomeng",
                        "content": "I\\'m confused by the statement as well. From the description, one cannot deduce this conclusion."
                    },
                    {
                        "username": "medivhsteve",
                        "content": "37 / 53 test cases passed.\\n\\n\\nInput:\\n\\n[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nOutput:\\n\\n[true,true,true,true,true]\\n\\nExpected:\\n\\n[false,false,false,true,true]\\n\\n\\n\\n\\nPlease google \"doge\"."
                    },
                    {
                        "username": "jpaunikar8",
                        "content": "[\"ValidWordAbbr\",\"isUnique\",\"isUnique\",\"isUnique\",\"isUnique\"]\\n[[[\"deer\",\"door\",\"cake\",\"card\"]],[\"dear\"],[\"door\"],[\"cart\"],[\"cake\"]]\\nOutput:\\n[null,false,true,true,true]\\nExpected:\\n[null,false,false,true,true]\\n\\nWhy is door false?"
                    },
                    {
                        "username": "dominion0331",
                        "content": "[@jsk9421](/jsk9421) \"door\" is in the original array\\noriginal array = [\"deer\",\"door\",\"cake\",\"card\"]\\nword = \"door\""
                    },
                    {
                        "username": "jsk9421",
                        "content": "It has to be the only word from the original array with the same abbr. \\nHere, deer and door have the same abbr.\\n\\n\"There\\'s no same abbr\" \\nor\\n1. Having the same word in the original array AND\\n2. No other words in the original array have the same abbr."
                    },
                    {
                        "username": "kai54",
                        "content": "[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nThis should return [true, true, true, true, true]. I don't understand why it will be [false, false, false,true,true]"
                    },
                    {
                        "username": "rainhacker",
                        "content": "Per the example provided in question:\\n\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\n\\nisUnique(\"dear\") -> false\\n\\nisUnique(\"cart\") -> true\\n\\nisUnique(\"cane\") -> false\\n\\nisUnique(\"make\") -> true\\n\\n\\n\\nisUnique(\"cane\") -> false because \"cane\" is not present in the dictionary.\\n\\n\\nHowever, the following test case with empty dictionary as input expects a true response. Seems like this test case is wrong ?\\n\\nInput:          [],isUnique(\"hello\")\\n\\nOutput:       [false]\\n\\nExpected:   [true]"
                    },
                    {
                        "username": "JJ_LL",
                        "content": "Hi everyone,\\n\\nCan anyone tell me what is the mistake and how to fix it?\\n\\nThanks a lot!!!!\\n\\n![image](https://assets.leetcode.com/users/images/d3649a1f-59f2-4c4c-8558-684dd99daa02_1620665080.1850584.png)\\n"
                    },
                    {
                        "username": "javac123",
                        "content": "For input array : {\"deer\",\"door\",\"cake\",\"card\"} why is false expected for the word \"door\"."
                    },
                    {
                        "username": "skywalk3r",
                        "content": "The qestion descrption is not making any sense to me. Can someone explain me in simpler words, in plain english what the author is tryig to convey ?"
                    }
                ]
            },
            {
                "id": 1575248,
                "content": [
                    {
                        "username": "2016trojan",
                        "content": "The description (**A word's abbreviation is unique if no other word from the dictionary has the same abbreviation**) is clear however a bit twisting. It took me a few \"Wrong Answer\"s to finally understand what it's asking for.  \\nWe are trying to search for a word in a dictionary. If this word (also this word\\u2019s abbreviation) is not in the dictionary OR this word and only it\\u2019s abbreviation in the dictionary. We call a word\\u2019s abbreviation unique.  \\nEX:  \\n\\n    1) [\\u201cdog\\u201d]; isUnique(\\u201cdig\\u201d);   \\n\\n//False, because \\u201cdig\\u201d has the same abbreviation with \\u201cdog\" and \\u201cdog\\u201d is already in the dictionary. It\\u2019s not unique.  \\n\\n    2) [\\u201cdog\\u201d, \\u201cdog\"]; isUnique(\\u201cdog\\u201d);  \\n\\n //True, because \\u201cdog\\u201d is the only word that has \\u201cd1g\\u201d abbreviation.  \\n\\n    3) [\\u201cdog\\u201d, \\u201cdig\\u201d]; isUnique(\\u201cdog\\u201d);   \\n\\n//False, because if we have more than one word match to the same abbreviation, this abbreviation will never be unique."
                    },
                    {
                        "username": "GaoLiaoLiao",
                        "content": "why should [\"hello\"],isUnique(\"hello\") return [true] ?\\n\\nbut in the case below\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\nisUnique(\"cane\") -> false"
                    },
                    {
                        "username": "user4276gm",
                        "content": "1. Either there is no word in dictionary with same abbreviation or\\n2. If word has same abbreviation with any word of the dictionary then there should be only one word with that abbreviation in dictionary and it has to be same as word (which is being evaluated as unique)."
                    },
                    {
                        "username": "Felomeng",
                        "content": "I\\'m confused by the statement as well. From the description, one cannot deduce this conclusion."
                    },
                    {
                        "username": "medivhsteve",
                        "content": "37 / 53 test cases passed.\\n\\n\\nInput:\\n\\n[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nOutput:\\n\\n[true,true,true,true,true]\\n\\nExpected:\\n\\n[false,false,false,true,true]\\n\\n\\n\\n\\nPlease google \"doge\"."
                    },
                    {
                        "username": "jpaunikar8",
                        "content": "[\"ValidWordAbbr\",\"isUnique\",\"isUnique\",\"isUnique\",\"isUnique\"]\\n[[[\"deer\",\"door\",\"cake\",\"card\"]],[\"dear\"],[\"door\"],[\"cart\"],[\"cake\"]]\\nOutput:\\n[null,false,true,true,true]\\nExpected:\\n[null,false,false,true,true]\\n\\nWhy is door false?"
                    },
                    {
                        "username": "dominion0331",
                        "content": "[@jsk9421](/jsk9421) \"door\" is in the original array\\noriginal array = [\"deer\",\"door\",\"cake\",\"card\"]\\nword = \"door\""
                    },
                    {
                        "username": "jsk9421",
                        "content": "It has to be the only word from the original array with the same abbr. \\nHere, deer and door have the same abbr.\\n\\n\"There\\'s no same abbr\" \\nor\\n1. Having the same word in the original array AND\\n2. No other words in the original array have the same abbr."
                    },
                    {
                        "username": "kai54",
                        "content": "[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nThis should return [true, true, true, true, true]. I don't understand why it will be [false, false, false,true,true]"
                    },
                    {
                        "username": "rainhacker",
                        "content": "Per the example provided in question:\\n\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\n\\nisUnique(\"dear\") -> false\\n\\nisUnique(\"cart\") -> true\\n\\nisUnique(\"cane\") -> false\\n\\nisUnique(\"make\") -> true\\n\\n\\n\\nisUnique(\"cane\") -> false because \"cane\" is not present in the dictionary.\\n\\n\\nHowever, the following test case with empty dictionary as input expects a true response. Seems like this test case is wrong ?\\n\\nInput:          [],isUnique(\"hello\")\\n\\nOutput:       [false]\\n\\nExpected:   [true]"
                    },
                    {
                        "username": "JJ_LL",
                        "content": "Hi everyone,\\n\\nCan anyone tell me what is the mistake and how to fix it?\\n\\nThanks a lot!!!!\\n\\n![image](https://assets.leetcode.com/users/images/d3649a1f-59f2-4c4c-8558-684dd99daa02_1620665080.1850584.png)\\n"
                    },
                    {
                        "username": "javac123",
                        "content": "For input array : {\"deer\",\"door\",\"cake\",\"card\"} why is false expected for the word \"door\"."
                    },
                    {
                        "username": "skywalk3r",
                        "content": "The qestion descrption is not making any sense to me. Can someone explain me in simpler words, in plain english what the author is tryig to convey ?"
                    }
                ]
            },
            {
                "id": 1573098,
                "content": [
                    {
                        "username": "2016trojan",
                        "content": "The description (**A word's abbreviation is unique if no other word from the dictionary has the same abbreviation**) is clear however a bit twisting. It took me a few \"Wrong Answer\"s to finally understand what it's asking for.  \\nWe are trying to search for a word in a dictionary. If this word (also this word\\u2019s abbreviation) is not in the dictionary OR this word and only it\\u2019s abbreviation in the dictionary. We call a word\\u2019s abbreviation unique.  \\nEX:  \\n\\n    1) [\\u201cdog\\u201d]; isUnique(\\u201cdig\\u201d);   \\n\\n//False, because \\u201cdig\\u201d has the same abbreviation with \\u201cdog\" and \\u201cdog\\u201d is already in the dictionary. It\\u2019s not unique.  \\n\\n    2) [\\u201cdog\\u201d, \\u201cdog\"]; isUnique(\\u201cdog\\u201d);  \\n\\n //True, because \\u201cdog\\u201d is the only word that has \\u201cd1g\\u201d abbreviation.  \\n\\n    3) [\\u201cdog\\u201d, \\u201cdig\\u201d]; isUnique(\\u201cdog\\u201d);   \\n\\n//False, because if we have more than one word match to the same abbreviation, this abbreviation will never be unique."
                    },
                    {
                        "username": "GaoLiaoLiao",
                        "content": "why should [\"hello\"],isUnique(\"hello\") return [true] ?\\n\\nbut in the case below\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\nisUnique(\"cane\") -> false"
                    },
                    {
                        "username": "user4276gm",
                        "content": "1. Either there is no word in dictionary with same abbreviation or\\n2. If word has same abbreviation with any word of the dictionary then there should be only one word with that abbreviation in dictionary and it has to be same as word (which is being evaluated as unique)."
                    },
                    {
                        "username": "Felomeng",
                        "content": "I\\'m confused by the statement as well. From the description, one cannot deduce this conclusion."
                    },
                    {
                        "username": "medivhsteve",
                        "content": "37 / 53 test cases passed.\\n\\n\\nInput:\\n\\n[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nOutput:\\n\\n[true,true,true,true,true]\\n\\nExpected:\\n\\n[false,false,false,true,true]\\n\\n\\n\\n\\nPlease google \"doge\"."
                    },
                    {
                        "username": "jpaunikar8",
                        "content": "[\"ValidWordAbbr\",\"isUnique\",\"isUnique\",\"isUnique\",\"isUnique\"]\\n[[[\"deer\",\"door\",\"cake\",\"card\"]],[\"dear\"],[\"door\"],[\"cart\"],[\"cake\"]]\\nOutput:\\n[null,false,true,true,true]\\nExpected:\\n[null,false,false,true,true]\\n\\nWhy is door false?"
                    },
                    {
                        "username": "dominion0331",
                        "content": "[@jsk9421](/jsk9421) \"door\" is in the original array\\noriginal array = [\"deer\",\"door\",\"cake\",\"card\"]\\nword = \"door\""
                    },
                    {
                        "username": "jsk9421",
                        "content": "It has to be the only word from the original array with the same abbr. \\nHere, deer and door have the same abbr.\\n\\n\"There\\'s no same abbr\" \\nor\\n1. Having the same word in the original array AND\\n2. No other words in the original array have the same abbr."
                    },
                    {
                        "username": "kai54",
                        "content": "[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nThis should return [true, true, true, true, true]. I don't understand why it will be [false, false, false,true,true]"
                    },
                    {
                        "username": "rainhacker",
                        "content": "Per the example provided in question:\\n\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\n\\nisUnique(\"dear\") -> false\\n\\nisUnique(\"cart\") -> true\\n\\nisUnique(\"cane\") -> false\\n\\nisUnique(\"make\") -> true\\n\\n\\n\\nisUnique(\"cane\") -> false because \"cane\" is not present in the dictionary.\\n\\n\\nHowever, the following test case with empty dictionary as input expects a true response. Seems like this test case is wrong ?\\n\\nInput:          [],isUnique(\"hello\")\\n\\nOutput:       [false]\\n\\nExpected:   [true]"
                    },
                    {
                        "username": "JJ_LL",
                        "content": "Hi everyone,\\n\\nCan anyone tell me what is the mistake and how to fix it?\\n\\nThanks a lot!!!!\\n\\n![image](https://assets.leetcode.com/users/images/d3649a1f-59f2-4c4c-8558-684dd99daa02_1620665080.1850584.png)\\n"
                    },
                    {
                        "username": "javac123",
                        "content": "For input array : {\"deer\",\"door\",\"cake\",\"card\"} why is false expected for the word \"door\"."
                    },
                    {
                        "username": "skywalk3r",
                        "content": "The qestion descrption is not making any sense to me. Can someone explain me in simpler words, in plain english what the author is tryig to convey ?"
                    }
                ]
            },
            {
                "id": 1564567,
                "content": [
                    {
                        "username": "2016trojan",
                        "content": "The description (**A word's abbreviation is unique if no other word from the dictionary has the same abbreviation**) is clear however a bit twisting. It took me a few \"Wrong Answer\"s to finally understand what it's asking for.  \\nWe are trying to search for a word in a dictionary. If this word (also this word\\u2019s abbreviation) is not in the dictionary OR this word and only it\\u2019s abbreviation in the dictionary. We call a word\\u2019s abbreviation unique.  \\nEX:  \\n\\n    1) [\\u201cdog\\u201d]; isUnique(\\u201cdig\\u201d);   \\n\\n//False, because \\u201cdig\\u201d has the same abbreviation with \\u201cdog\" and \\u201cdog\\u201d is already in the dictionary. It\\u2019s not unique.  \\n\\n    2) [\\u201cdog\\u201d, \\u201cdog\"]; isUnique(\\u201cdog\\u201d);  \\n\\n //True, because \\u201cdog\\u201d is the only word that has \\u201cd1g\\u201d abbreviation.  \\n\\n    3) [\\u201cdog\\u201d, \\u201cdig\\u201d]; isUnique(\\u201cdog\\u201d);   \\n\\n//False, because if we have more than one word match to the same abbreviation, this abbreviation will never be unique."
                    },
                    {
                        "username": "GaoLiaoLiao",
                        "content": "why should [\"hello\"],isUnique(\"hello\") return [true] ?\\n\\nbut in the case below\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\nisUnique(\"cane\") -> false"
                    },
                    {
                        "username": "user4276gm",
                        "content": "1. Either there is no word in dictionary with same abbreviation or\\n2. If word has same abbreviation with any word of the dictionary then there should be only one word with that abbreviation in dictionary and it has to be same as word (which is being evaluated as unique)."
                    },
                    {
                        "username": "Felomeng",
                        "content": "I\\'m confused by the statement as well. From the description, one cannot deduce this conclusion."
                    },
                    {
                        "username": "medivhsteve",
                        "content": "37 / 53 test cases passed.\\n\\n\\nInput:\\n\\n[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nOutput:\\n\\n[true,true,true,true,true]\\n\\nExpected:\\n\\n[false,false,false,true,true]\\n\\n\\n\\n\\nPlease google \"doge\"."
                    },
                    {
                        "username": "jpaunikar8",
                        "content": "[\"ValidWordAbbr\",\"isUnique\",\"isUnique\",\"isUnique\",\"isUnique\"]\\n[[[\"deer\",\"door\",\"cake\",\"card\"]],[\"dear\"],[\"door\"],[\"cart\"],[\"cake\"]]\\nOutput:\\n[null,false,true,true,true]\\nExpected:\\n[null,false,false,true,true]\\n\\nWhy is door false?"
                    },
                    {
                        "username": "dominion0331",
                        "content": "[@jsk9421](/jsk9421) \"door\" is in the original array\\noriginal array = [\"deer\",\"door\",\"cake\",\"card\"]\\nword = \"door\""
                    },
                    {
                        "username": "jsk9421",
                        "content": "It has to be the only word from the original array with the same abbr. \\nHere, deer and door have the same abbr.\\n\\n\"There\\'s no same abbr\" \\nor\\n1. Having the same word in the original array AND\\n2. No other words in the original array have the same abbr."
                    },
                    {
                        "username": "kai54",
                        "content": "[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nThis should return [true, true, true, true, true]. I don't understand why it will be [false, false, false,true,true]"
                    },
                    {
                        "username": "rainhacker",
                        "content": "Per the example provided in question:\\n\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\n\\nisUnique(\"dear\") -> false\\n\\nisUnique(\"cart\") -> true\\n\\nisUnique(\"cane\") -> false\\n\\nisUnique(\"make\") -> true\\n\\n\\n\\nisUnique(\"cane\") -> false because \"cane\" is not present in the dictionary.\\n\\n\\nHowever, the following test case with empty dictionary as input expects a true response. Seems like this test case is wrong ?\\n\\nInput:          [],isUnique(\"hello\")\\n\\nOutput:       [false]\\n\\nExpected:   [true]"
                    },
                    {
                        "username": "JJ_LL",
                        "content": "Hi everyone,\\n\\nCan anyone tell me what is the mistake and how to fix it?\\n\\nThanks a lot!!!!\\n\\n![image](https://assets.leetcode.com/users/images/d3649a1f-59f2-4c4c-8558-684dd99daa02_1620665080.1850584.png)\\n"
                    },
                    {
                        "username": "javac123",
                        "content": "For input array : {\"deer\",\"door\",\"cake\",\"card\"} why is false expected for the word \"door\"."
                    },
                    {
                        "username": "skywalk3r",
                        "content": "The qestion descrption is not making any sense to me. Can someone explain me in simpler words, in plain english what the author is tryig to convey ?"
                    }
                ]
            },
            {
                "id": 1566492,
                "content": [
                    {
                        "username": "2016trojan",
                        "content": "The description (**A word's abbreviation is unique if no other word from the dictionary has the same abbreviation**) is clear however a bit twisting. It took me a few \"Wrong Answer\"s to finally understand what it's asking for.  \\nWe are trying to search for a word in a dictionary. If this word (also this word\\u2019s abbreviation) is not in the dictionary OR this word and only it\\u2019s abbreviation in the dictionary. We call a word\\u2019s abbreviation unique.  \\nEX:  \\n\\n    1) [\\u201cdog\\u201d]; isUnique(\\u201cdig\\u201d);   \\n\\n//False, because \\u201cdig\\u201d has the same abbreviation with \\u201cdog\" and \\u201cdog\\u201d is already in the dictionary. It\\u2019s not unique.  \\n\\n    2) [\\u201cdog\\u201d, \\u201cdog\"]; isUnique(\\u201cdog\\u201d);  \\n\\n //True, because \\u201cdog\\u201d is the only word that has \\u201cd1g\\u201d abbreviation.  \\n\\n    3) [\\u201cdog\\u201d, \\u201cdig\\u201d]; isUnique(\\u201cdog\\u201d);   \\n\\n//False, because if we have more than one word match to the same abbreviation, this abbreviation will never be unique."
                    },
                    {
                        "username": "GaoLiaoLiao",
                        "content": "why should [\"hello\"],isUnique(\"hello\") return [true] ?\\n\\nbut in the case below\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\nisUnique(\"cane\") -> false"
                    },
                    {
                        "username": "user4276gm",
                        "content": "1. Either there is no word in dictionary with same abbreviation or\\n2. If word has same abbreviation with any word of the dictionary then there should be only one word with that abbreviation in dictionary and it has to be same as word (which is being evaluated as unique)."
                    },
                    {
                        "username": "Felomeng",
                        "content": "I\\'m confused by the statement as well. From the description, one cannot deduce this conclusion."
                    },
                    {
                        "username": "medivhsteve",
                        "content": "37 / 53 test cases passed.\\n\\n\\nInput:\\n\\n[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nOutput:\\n\\n[true,true,true,true,true]\\n\\nExpected:\\n\\n[false,false,false,true,true]\\n\\n\\n\\n\\nPlease google \"doge\"."
                    },
                    {
                        "username": "jpaunikar8",
                        "content": "[\"ValidWordAbbr\",\"isUnique\",\"isUnique\",\"isUnique\",\"isUnique\"]\\n[[[\"deer\",\"door\",\"cake\",\"card\"]],[\"dear\"],[\"door\"],[\"cart\"],[\"cake\"]]\\nOutput:\\n[null,false,true,true,true]\\nExpected:\\n[null,false,false,true,true]\\n\\nWhy is door false?"
                    },
                    {
                        "username": "dominion0331",
                        "content": "[@jsk9421](/jsk9421) \"door\" is in the original array\\noriginal array = [\"deer\",\"door\",\"cake\",\"card\"]\\nword = \"door\""
                    },
                    {
                        "username": "jsk9421",
                        "content": "It has to be the only word from the original array with the same abbr. \\nHere, deer and door have the same abbr.\\n\\n\"There\\'s no same abbr\" \\nor\\n1. Having the same word in the original array AND\\n2. No other words in the original array have the same abbr."
                    },
                    {
                        "username": "kai54",
                        "content": "[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nThis should return [true, true, true, true, true]. I don't understand why it will be [false, false, false,true,true]"
                    },
                    {
                        "username": "rainhacker",
                        "content": "Per the example provided in question:\\n\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\n\\nisUnique(\"dear\") -> false\\n\\nisUnique(\"cart\") -> true\\n\\nisUnique(\"cane\") -> false\\n\\nisUnique(\"make\") -> true\\n\\n\\n\\nisUnique(\"cane\") -> false because \"cane\" is not present in the dictionary.\\n\\n\\nHowever, the following test case with empty dictionary as input expects a true response. Seems like this test case is wrong ?\\n\\nInput:          [],isUnique(\"hello\")\\n\\nOutput:       [false]\\n\\nExpected:   [true]"
                    },
                    {
                        "username": "JJ_LL",
                        "content": "Hi everyone,\\n\\nCan anyone tell me what is the mistake and how to fix it?\\n\\nThanks a lot!!!!\\n\\n![image](https://assets.leetcode.com/users/images/d3649a1f-59f2-4c4c-8558-684dd99daa02_1620665080.1850584.png)\\n"
                    },
                    {
                        "username": "javac123",
                        "content": "For input array : {\"deer\",\"door\",\"cake\",\"card\"} why is false expected for the word \"door\"."
                    },
                    {
                        "username": "skywalk3r",
                        "content": "The qestion descrption is not making any sense to me. Can someone explain me in simpler words, in plain english what the author is tryig to convey ?"
                    }
                ]
            },
            {
                "id": 1570307,
                "content": [
                    {
                        "username": "2016trojan",
                        "content": "The description (**A word's abbreviation is unique if no other word from the dictionary has the same abbreviation**) is clear however a bit twisting. It took me a few \"Wrong Answer\"s to finally understand what it's asking for.  \\nWe are trying to search for a word in a dictionary. If this word (also this word\\u2019s abbreviation) is not in the dictionary OR this word and only it\\u2019s abbreviation in the dictionary. We call a word\\u2019s abbreviation unique.  \\nEX:  \\n\\n    1) [\\u201cdog\\u201d]; isUnique(\\u201cdig\\u201d);   \\n\\n//False, because \\u201cdig\\u201d has the same abbreviation with \\u201cdog\" and \\u201cdog\\u201d is already in the dictionary. It\\u2019s not unique.  \\n\\n    2) [\\u201cdog\\u201d, \\u201cdog\"]; isUnique(\\u201cdog\\u201d);  \\n\\n //True, because \\u201cdog\\u201d is the only word that has \\u201cd1g\\u201d abbreviation.  \\n\\n    3) [\\u201cdog\\u201d, \\u201cdig\\u201d]; isUnique(\\u201cdog\\u201d);   \\n\\n//False, because if we have more than one word match to the same abbreviation, this abbreviation will never be unique."
                    },
                    {
                        "username": "GaoLiaoLiao",
                        "content": "why should [\"hello\"],isUnique(\"hello\") return [true] ?\\n\\nbut in the case below\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\nisUnique(\"cane\") -> false"
                    },
                    {
                        "username": "user4276gm",
                        "content": "1. Either there is no word in dictionary with same abbreviation or\\n2. If word has same abbreviation with any word of the dictionary then there should be only one word with that abbreviation in dictionary and it has to be same as word (which is being evaluated as unique)."
                    },
                    {
                        "username": "Felomeng",
                        "content": "I\\'m confused by the statement as well. From the description, one cannot deduce this conclusion."
                    },
                    {
                        "username": "medivhsteve",
                        "content": "37 / 53 test cases passed.\\n\\n\\nInput:\\n\\n[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nOutput:\\n\\n[true,true,true,true,true]\\n\\nExpected:\\n\\n[false,false,false,true,true]\\n\\n\\n\\n\\nPlease google \"doge\"."
                    },
                    {
                        "username": "jpaunikar8",
                        "content": "[\"ValidWordAbbr\",\"isUnique\",\"isUnique\",\"isUnique\",\"isUnique\"]\\n[[[\"deer\",\"door\",\"cake\",\"card\"]],[\"dear\"],[\"door\"],[\"cart\"],[\"cake\"]]\\nOutput:\\n[null,false,true,true,true]\\nExpected:\\n[null,false,false,true,true]\\n\\nWhy is door false?"
                    },
                    {
                        "username": "dominion0331",
                        "content": "[@jsk9421](/jsk9421) \"door\" is in the original array\\noriginal array = [\"deer\",\"door\",\"cake\",\"card\"]\\nword = \"door\""
                    },
                    {
                        "username": "jsk9421",
                        "content": "It has to be the only word from the original array with the same abbr. \\nHere, deer and door have the same abbr.\\n\\n\"There\\'s no same abbr\" \\nor\\n1. Having the same word in the original array AND\\n2. No other words in the original array have the same abbr."
                    },
                    {
                        "username": "kai54",
                        "content": "[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nThis should return [true, true, true, true, true]. I don't understand why it will be [false, false, false,true,true]"
                    },
                    {
                        "username": "rainhacker",
                        "content": "Per the example provided in question:\\n\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\n\\nisUnique(\"dear\") -> false\\n\\nisUnique(\"cart\") -> true\\n\\nisUnique(\"cane\") -> false\\n\\nisUnique(\"make\") -> true\\n\\n\\n\\nisUnique(\"cane\") -> false because \"cane\" is not present in the dictionary.\\n\\n\\nHowever, the following test case with empty dictionary as input expects a true response. Seems like this test case is wrong ?\\n\\nInput:          [],isUnique(\"hello\")\\n\\nOutput:       [false]\\n\\nExpected:   [true]"
                    },
                    {
                        "username": "JJ_LL",
                        "content": "Hi everyone,\\n\\nCan anyone tell me what is the mistake and how to fix it?\\n\\nThanks a lot!!!!\\n\\n![image](https://assets.leetcode.com/users/images/d3649a1f-59f2-4c4c-8558-684dd99daa02_1620665080.1850584.png)\\n"
                    },
                    {
                        "username": "javac123",
                        "content": "For input array : {\"deer\",\"door\",\"cake\",\"card\"} why is false expected for the word \"door\"."
                    },
                    {
                        "username": "skywalk3r",
                        "content": "The qestion descrption is not making any sense to me. Can someone explain me in simpler words, in plain english what the author is tryig to convey ?"
                    }
                ]
            },
            {
                "id": 1566493,
                "content": [
                    {
                        "username": "2016trojan",
                        "content": "The description (**A word's abbreviation is unique if no other word from the dictionary has the same abbreviation**) is clear however a bit twisting. It took me a few \"Wrong Answer\"s to finally understand what it's asking for.  \\nWe are trying to search for a word in a dictionary. If this word (also this word\\u2019s abbreviation) is not in the dictionary OR this word and only it\\u2019s abbreviation in the dictionary. We call a word\\u2019s abbreviation unique.  \\nEX:  \\n\\n    1) [\\u201cdog\\u201d]; isUnique(\\u201cdig\\u201d);   \\n\\n//False, because \\u201cdig\\u201d has the same abbreviation with \\u201cdog\" and \\u201cdog\\u201d is already in the dictionary. It\\u2019s not unique.  \\n\\n    2) [\\u201cdog\\u201d, \\u201cdog\"]; isUnique(\\u201cdog\\u201d);  \\n\\n //True, because \\u201cdog\\u201d is the only word that has \\u201cd1g\\u201d abbreviation.  \\n\\n    3) [\\u201cdog\\u201d, \\u201cdig\\u201d]; isUnique(\\u201cdog\\u201d);   \\n\\n//False, because if we have more than one word match to the same abbreviation, this abbreviation will never be unique."
                    },
                    {
                        "username": "GaoLiaoLiao",
                        "content": "why should [\"hello\"],isUnique(\"hello\") return [true] ?\\n\\nbut in the case below\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\nisUnique(\"cane\") -> false"
                    },
                    {
                        "username": "user4276gm",
                        "content": "1. Either there is no word in dictionary with same abbreviation or\\n2. If word has same abbreviation with any word of the dictionary then there should be only one word with that abbreviation in dictionary and it has to be same as word (which is being evaluated as unique)."
                    },
                    {
                        "username": "Felomeng",
                        "content": "I\\'m confused by the statement as well. From the description, one cannot deduce this conclusion."
                    },
                    {
                        "username": "medivhsteve",
                        "content": "37 / 53 test cases passed.\\n\\n\\nInput:\\n\\n[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nOutput:\\n\\n[true,true,true,true,true]\\n\\nExpected:\\n\\n[false,false,false,true,true]\\n\\n\\n\\n\\nPlease google \"doge\"."
                    },
                    {
                        "username": "jpaunikar8",
                        "content": "[\"ValidWordAbbr\",\"isUnique\",\"isUnique\",\"isUnique\",\"isUnique\"]\\n[[[\"deer\",\"door\",\"cake\",\"card\"]],[\"dear\"],[\"door\"],[\"cart\"],[\"cake\"]]\\nOutput:\\n[null,false,true,true,true]\\nExpected:\\n[null,false,false,true,true]\\n\\nWhy is door false?"
                    },
                    {
                        "username": "dominion0331",
                        "content": "[@jsk9421](/jsk9421) \"door\" is in the original array\\noriginal array = [\"deer\",\"door\",\"cake\",\"card\"]\\nword = \"door\""
                    },
                    {
                        "username": "jsk9421",
                        "content": "It has to be the only word from the original array with the same abbr. \\nHere, deer and door have the same abbr.\\n\\n\"There\\'s no same abbr\" \\nor\\n1. Having the same word in the original array AND\\n2. No other words in the original array have the same abbr."
                    },
                    {
                        "username": "kai54",
                        "content": "[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nThis should return [true, true, true, true, true]. I don't understand why it will be [false, false, false,true,true]"
                    },
                    {
                        "username": "rainhacker",
                        "content": "Per the example provided in question:\\n\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\n\\nisUnique(\"dear\") -> false\\n\\nisUnique(\"cart\") -> true\\n\\nisUnique(\"cane\") -> false\\n\\nisUnique(\"make\") -> true\\n\\n\\n\\nisUnique(\"cane\") -> false because \"cane\" is not present in the dictionary.\\n\\n\\nHowever, the following test case with empty dictionary as input expects a true response. Seems like this test case is wrong ?\\n\\nInput:          [],isUnique(\"hello\")\\n\\nOutput:       [false]\\n\\nExpected:   [true]"
                    },
                    {
                        "username": "JJ_LL",
                        "content": "Hi everyone,\\n\\nCan anyone tell me what is the mistake and how to fix it?\\n\\nThanks a lot!!!!\\n\\n![image](https://assets.leetcode.com/users/images/d3649a1f-59f2-4c4c-8558-684dd99daa02_1620665080.1850584.png)\\n"
                    },
                    {
                        "username": "javac123",
                        "content": "For input array : {\"deer\",\"door\",\"cake\",\"card\"} why is false expected for the word \"door\"."
                    },
                    {
                        "username": "skywalk3r",
                        "content": "The qestion descrption is not making any sense to me. Can someone explain me in simpler words, in plain english what the author is tryig to convey ?"
                    }
                ]
            },
            {
                "id": 1576105,
                "content": [
                    {
                        "username": "2016trojan",
                        "content": "The description (**A word's abbreviation is unique if no other word from the dictionary has the same abbreviation**) is clear however a bit twisting. It took me a few \"Wrong Answer\"s to finally understand what it's asking for.  \\nWe are trying to search for a word in a dictionary. If this word (also this word\\u2019s abbreviation) is not in the dictionary OR this word and only it\\u2019s abbreviation in the dictionary. We call a word\\u2019s abbreviation unique.  \\nEX:  \\n\\n    1) [\\u201cdog\\u201d]; isUnique(\\u201cdig\\u201d);   \\n\\n//False, because \\u201cdig\\u201d has the same abbreviation with \\u201cdog\" and \\u201cdog\\u201d is already in the dictionary. It\\u2019s not unique.  \\n\\n    2) [\\u201cdog\\u201d, \\u201cdog\"]; isUnique(\\u201cdog\\u201d);  \\n\\n //True, because \\u201cdog\\u201d is the only word that has \\u201cd1g\\u201d abbreviation.  \\n\\n    3) [\\u201cdog\\u201d, \\u201cdig\\u201d]; isUnique(\\u201cdog\\u201d);   \\n\\n//False, because if we have more than one word match to the same abbreviation, this abbreviation will never be unique."
                    },
                    {
                        "username": "GaoLiaoLiao",
                        "content": "why should [\"hello\"],isUnique(\"hello\") return [true] ?\\n\\nbut in the case below\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\nisUnique(\"cane\") -> false"
                    },
                    {
                        "username": "user4276gm",
                        "content": "1. Either there is no word in dictionary with same abbreviation or\\n2. If word has same abbreviation with any word of the dictionary then there should be only one word with that abbreviation in dictionary and it has to be same as word (which is being evaluated as unique)."
                    },
                    {
                        "username": "Felomeng",
                        "content": "I\\'m confused by the statement as well. From the description, one cannot deduce this conclusion."
                    },
                    {
                        "username": "medivhsteve",
                        "content": "37 / 53 test cases passed.\\n\\n\\nInput:\\n\\n[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nOutput:\\n\\n[true,true,true,true,true]\\n\\nExpected:\\n\\n[false,false,false,true,true]\\n\\n\\n\\n\\nPlease google \"doge\"."
                    },
                    {
                        "username": "jpaunikar8",
                        "content": "[\"ValidWordAbbr\",\"isUnique\",\"isUnique\",\"isUnique\",\"isUnique\"]\\n[[[\"deer\",\"door\",\"cake\",\"card\"]],[\"dear\"],[\"door\"],[\"cart\"],[\"cake\"]]\\nOutput:\\n[null,false,true,true,true]\\nExpected:\\n[null,false,false,true,true]\\n\\nWhy is door false?"
                    },
                    {
                        "username": "dominion0331",
                        "content": "[@jsk9421](/jsk9421) \"door\" is in the original array\\noriginal array = [\"deer\",\"door\",\"cake\",\"card\"]\\nword = \"door\""
                    },
                    {
                        "username": "jsk9421",
                        "content": "It has to be the only word from the original array with the same abbr. \\nHere, deer and door have the same abbr.\\n\\n\"There\\'s no same abbr\" \\nor\\n1. Having the same word in the original array AND\\n2. No other words in the original array have the same abbr."
                    },
                    {
                        "username": "kai54",
                        "content": "[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nThis should return [true, true, true, true, true]. I don't understand why it will be [false, false, false,true,true]"
                    },
                    {
                        "username": "rainhacker",
                        "content": "Per the example provided in question:\\n\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\n\\nisUnique(\"dear\") -> false\\n\\nisUnique(\"cart\") -> true\\n\\nisUnique(\"cane\") -> false\\n\\nisUnique(\"make\") -> true\\n\\n\\n\\nisUnique(\"cane\") -> false because \"cane\" is not present in the dictionary.\\n\\n\\nHowever, the following test case with empty dictionary as input expects a true response. Seems like this test case is wrong ?\\n\\nInput:          [],isUnique(\"hello\")\\n\\nOutput:       [false]\\n\\nExpected:   [true]"
                    },
                    {
                        "username": "JJ_LL",
                        "content": "Hi everyone,\\n\\nCan anyone tell me what is the mistake and how to fix it?\\n\\nThanks a lot!!!!\\n\\n![image](https://assets.leetcode.com/users/images/d3649a1f-59f2-4c4c-8558-684dd99daa02_1620665080.1850584.png)\\n"
                    },
                    {
                        "username": "javac123",
                        "content": "For input array : {\"deer\",\"door\",\"cake\",\"card\"} why is false expected for the word \"door\"."
                    },
                    {
                        "username": "skywalk3r",
                        "content": "The qestion descrption is not making any sense to me. Can someone explain me in simpler words, in plain english what the author is tryig to convey ?"
                    }
                ]
            },
            {
                "id": 1569055,
                "content": [
                    {
                        "username": "2016trojan",
                        "content": "The description (**A word's abbreviation is unique if no other word from the dictionary has the same abbreviation**) is clear however a bit twisting. It took me a few \"Wrong Answer\"s to finally understand what it's asking for.  \\nWe are trying to search for a word in a dictionary. If this word (also this word\\u2019s abbreviation) is not in the dictionary OR this word and only it\\u2019s abbreviation in the dictionary. We call a word\\u2019s abbreviation unique.  \\nEX:  \\n\\n    1) [\\u201cdog\\u201d]; isUnique(\\u201cdig\\u201d);   \\n\\n//False, because \\u201cdig\\u201d has the same abbreviation with \\u201cdog\" and \\u201cdog\\u201d is already in the dictionary. It\\u2019s not unique.  \\n\\n    2) [\\u201cdog\\u201d, \\u201cdog\"]; isUnique(\\u201cdog\\u201d);  \\n\\n //True, because \\u201cdog\\u201d is the only word that has \\u201cd1g\\u201d abbreviation.  \\n\\n    3) [\\u201cdog\\u201d, \\u201cdig\\u201d]; isUnique(\\u201cdog\\u201d);   \\n\\n//False, because if we have more than one word match to the same abbreviation, this abbreviation will never be unique."
                    },
                    {
                        "username": "GaoLiaoLiao",
                        "content": "why should [\"hello\"],isUnique(\"hello\") return [true] ?\\n\\nbut in the case below\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\nisUnique(\"cane\") -> false"
                    },
                    {
                        "username": "user4276gm",
                        "content": "1. Either there is no word in dictionary with same abbreviation or\\n2. If word has same abbreviation with any word of the dictionary then there should be only one word with that abbreviation in dictionary and it has to be same as word (which is being evaluated as unique)."
                    },
                    {
                        "username": "Felomeng",
                        "content": "I\\'m confused by the statement as well. From the description, one cannot deduce this conclusion."
                    },
                    {
                        "username": "medivhsteve",
                        "content": "37 / 53 test cases passed.\\n\\n\\nInput:\\n\\n[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nOutput:\\n\\n[true,true,true,true,true]\\n\\nExpected:\\n\\n[false,false,false,true,true]\\n\\n\\n\\n\\nPlease google \"doge\"."
                    },
                    {
                        "username": "jpaunikar8",
                        "content": "[\"ValidWordAbbr\",\"isUnique\",\"isUnique\",\"isUnique\",\"isUnique\"]\\n[[[\"deer\",\"door\",\"cake\",\"card\"]],[\"dear\"],[\"door\"],[\"cart\"],[\"cake\"]]\\nOutput:\\n[null,false,true,true,true]\\nExpected:\\n[null,false,false,true,true]\\n\\nWhy is door false?"
                    },
                    {
                        "username": "dominion0331",
                        "content": "[@jsk9421](/jsk9421) \"door\" is in the original array\\noriginal array = [\"deer\",\"door\",\"cake\",\"card\"]\\nword = \"door\""
                    },
                    {
                        "username": "jsk9421",
                        "content": "It has to be the only word from the original array with the same abbr. \\nHere, deer and door have the same abbr.\\n\\n\"There\\'s no same abbr\" \\nor\\n1. Having the same word in the original array AND\\n2. No other words in the original array have the same abbr."
                    },
                    {
                        "username": "kai54",
                        "content": "[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nThis should return [true, true, true, true, true]. I don't understand why it will be [false, false, false,true,true]"
                    },
                    {
                        "username": "rainhacker",
                        "content": "Per the example provided in question:\\n\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\n\\nisUnique(\"dear\") -> false\\n\\nisUnique(\"cart\") -> true\\n\\nisUnique(\"cane\") -> false\\n\\nisUnique(\"make\") -> true\\n\\n\\n\\nisUnique(\"cane\") -> false because \"cane\" is not present in the dictionary.\\n\\n\\nHowever, the following test case with empty dictionary as input expects a true response. Seems like this test case is wrong ?\\n\\nInput:          [],isUnique(\"hello\")\\n\\nOutput:       [false]\\n\\nExpected:   [true]"
                    },
                    {
                        "username": "JJ_LL",
                        "content": "Hi everyone,\\n\\nCan anyone tell me what is the mistake and how to fix it?\\n\\nThanks a lot!!!!\\n\\n![image](https://assets.leetcode.com/users/images/d3649a1f-59f2-4c4c-8558-684dd99daa02_1620665080.1850584.png)\\n"
                    },
                    {
                        "username": "javac123",
                        "content": "For input array : {\"deer\",\"door\",\"cake\",\"card\"} why is false expected for the word \"door\"."
                    },
                    {
                        "username": "skywalk3r",
                        "content": "The qestion descrption is not making any sense to me. Can someone explain me in simpler words, in plain english what the author is tryig to convey ?"
                    }
                ]
            },
            {
                "id": 1569056,
                "content": [
                    {
                        "username": "2016trojan",
                        "content": "The description (**A word's abbreviation is unique if no other word from the dictionary has the same abbreviation**) is clear however a bit twisting. It took me a few \"Wrong Answer\"s to finally understand what it's asking for.  \\nWe are trying to search for a word in a dictionary. If this word (also this word\\u2019s abbreviation) is not in the dictionary OR this word and only it\\u2019s abbreviation in the dictionary. We call a word\\u2019s abbreviation unique.  \\nEX:  \\n\\n    1) [\\u201cdog\\u201d]; isUnique(\\u201cdig\\u201d);   \\n\\n//False, because \\u201cdig\\u201d has the same abbreviation with \\u201cdog\" and \\u201cdog\\u201d is already in the dictionary. It\\u2019s not unique.  \\n\\n    2) [\\u201cdog\\u201d, \\u201cdog\"]; isUnique(\\u201cdog\\u201d);  \\n\\n //True, because \\u201cdog\\u201d is the only word that has \\u201cd1g\\u201d abbreviation.  \\n\\n    3) [\\u201cdog\\u201d, \\u201cdig\\u201d]; isUnique(\\u201cdog\\u201d);   \\n\\n//False, because if we have more than one word match to the same abbreviation, this abbreviation will never be unique."
                    },
                    {
                        "username": "GaoLiaoLiao",
                        "content": "why should [\"hello\"],isUnique(\"hello\") return [true] ?\\n\\nbut in the case below\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\nisUnique(\"cane\") -> false"
                    },
                    {
                        "username": "user4276gm",
                        "content": "1. Either there is no word in dictionary with same abbreviation or\\n2. If word has same abbreviation with any word of the dictionary then there should be only one word with that abbreviation in dictionary and it has to be same as word (which is being evaluated as unique)."
                    },
                    {
                        "username": "Felomeng",
                        "content": "I\\'m confused by the statement as well. From the description, one cannot deduce this conclusion."
                    },
                    {
                        "username": "medivhsteve",
                        "content": "37 / 53 test cases passed.\\n\\n\\nInput:\\n\\n[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nOutput:\\n\\n[true,true,true,true,true]\\n\\nExpected:\\n\\n[false,false,false,true,true]\\n\\n\\n\\n\\nPlease google \"doge\"."
                    },
                    {
                        "username": "jpaunikar8",
                        "content": "[\"ValidWordAbbr\",\"isUnique\",\"isUnique\",\"isUnique\",\"isUnique\"]\\n[[[\"deer\",\"door\",\"cake\",\"card\"]],[\"dear\"],[\"door\"],[\"cart\"],[\"cake\"]]\\nOutput:\\n[null,false,true,true,true]\\nExpected:\\n[null,false,false,true,true]\\n\\nWhy is door false?"
                    },
                    {
                        "username": "dominion0331",
                        "content": "[@jsk9421](/jsk9421) \"door\" is in the original array\\noriginal array = [\"deer\",\"door\",\"cake\",\"card\"]\\nword = \"door\""
                    },
                    {
                        "username": "jsk9421",
                        "content": "It has to be the only word from the original array with the same abbr. \\nHere, deer and door have the same abbr.\\n\\n\"There\\'s no same abbr\" \\nor\\n1. Having the same word in the original array AND\\n2. No other words in the original array have the same abbr."
                    },
                    {
                        "username": "kai54",
                        "content": "[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nThis should return [true, true, true, true, true]. I don't understand why it will be [false, false, false,true,true]"
                    },
                    {
                        "username": "rainhacker",
                        "content": "Per the example provided in question:\\n\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\n\\nisUnique(\"dear\") -> false\\n\\nisUnique(\"cart\") -> true\\n\\nisUnique(\"cane\") -> false\\n\\nisUnique(\"make\") -> true\\n\\n\\n\\nisUnique(\"cane\") -> false because \"cane\" is not present in the dictionary.\\n\\n\\nHowever, the following test case with empty dictionary as input expects a true response. Seems like this test case is wrong ?\\n\\nInput:          [],isUnique(\"hello\")\\n\\nOutput:       [false]\\n\\nExpected:   [true]"
                    },
                    {
                        "username": "JJ_LL",
                        "content": "Hi everyone,\\n\\nCan anyone tell me what is the mistake and how to fix it?\\n\\nThanks a lot!!!!\\n\\n![image](https://assets.leetcode.com/users/images/d3649a1f-59f2-4c4c-8558-684dd99daa02_1620665080.1850584.png)\\n"
                    },
                    {
                        "username": "javac123",
                        "content": "For input array : {\"deer\",\"door\",\"cake\",\"card\"} why is false expected for the word \"door\"."
                    },
                    {
                        "username": "skywalk3r",
                        "content": "The qestion descrption is not making any sense to me. Can someone explain me in simpler words, in plain english what the author is tryig to convey ?"
                    }
                ]
            },
            {
                "id": 1575250,
                "content": [
                    {
                        "username": "2016trojan",
                        "content": "The description (**A word's abbreviation is unique if no other word from the dictionary has the same abbreviation**) is clear however a bit twisting. It took me a few \"Wrong Answer\"s to finally understand what it's asking for.  \\nWe are trying to search for a word in a dictionary. If this word (also this word\\u2019s abbreviation) is not in the dictionary OR this word and only it\\u2019s abbreviation in the dictionary. We call a word\\u2019s abbreviation unique.  \\nEX:  \\n\\n    1) [\\u201cdog\\u201d]; isUnique(\\u201cdig\\u201d);   \\n\\n//False, because \\u201cdig\\u201d has the same abbreviation with \\u201cdog\" and \\u201cdog\\u201d is already in the dictionary. It\\u2019s not unique.  \\n\\n    2) [\\u201cdog\\u201d, \\u201cdog\"]; isUnique(\\u201cdog\\u201d);  \\n\\n //True, because \\u201cdog\\u201d is the only word that has \\u201cd1g\\u201d abbreviation.  \\n\\n    3) [\\u201cdog\\u201d, \\u201cdig\\u201d]; isUnique(\\u201cdog\\u201d);   \\n\\n//False, because if we have more than one word match to the same abbreviation, this abbreviation will never be unique."
                    },
                    {
                        "username": "GaoLiaoLiao",
                        "content": "why should [\"hello\"],isUnique(\"hello\") return [true] ?\\n\\nbut in the case below\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\nisUnique(\"cane\") -> false"
                    },
                    {
                        "username": "user4276gm",
                        "content": "1. Either there is no word in dictionary with same abbreviation or\\n2. If word has same abbreviation with any word of the dictionary then there should be only one word with that abbreviation in dictionary and it has to be same as word (which is being evaluated as unique)."
                    },
                    {
                        "username": "Felomeng",
                        "content": "I\\'m confused by the statement as well. From the description, one cannot deduce this conclusion."
                    },
                    {
                        "username": "medivhsteve",
                        "content": "37 / 53 test cases passed.\\n\\n\\nInput:\\n\\n[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nOutput:\\n\\n[true,true,true,true,true]\\n\\nExpected:\\n\\n[false,false,false,true,true]\\n\\n\\n\\n\\nPlease google \"doge\"."
                    },
                    {
                        "username": "jpaunikar8",
                        "content": "[\"ValidWordAbbr\",\"isUnique\",\"isUnique\",\"isUnique\",\"isUnique\"]\\n[[[\"deer\",\"door\",\"cake\",\"card\"]],[\"dear\"],[\"door\"],[\"cart\"],[\"cake\"]]\\nOutput:\\n[null,false,true,true,true]\\nExpected:\\n[null,false,false,true,true]\\n\\nWhy is door false?"
                    },
                    {
                        "username": "dominion0331",
                        "content": "[@jsk9421](/jsk9421) \"door\" is in the original array\\noriginal array = [\"deer\",\"door\",\"cake\",\"card\"]\\nword = \"door\""
                    },
                    {
                        "username": "jsk9421",
                        "content": "It has to be the only word from the original array with the same abbr. \\nHere, deer and door have the same abbr.\\n\\n\"There\\'s no same abbr\" \\nor\\n1. Having the same word in the original array AND\\n2. No other words in the original array have the same abbr."
                    },
                    {
                        "username": "kai54",
                        "content": "[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nThis should return [true, true, true, true, true]. I don't understand why it will be [false, false, false,true,true]"
                    },
                    {
                        "username": "rainhacker",
                        "content": "Per the example provided in question:\\n\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\n\\nisUnique(\"dear\") -> false\\n\\nisUnique(\"cart\") -> true\\n\\nisUnique(\"cane\") -> false\\n\\nisUnique(\"make\") -> true\\n\\n\\n\\nisUnique(\"cane\") -> false because \"cane\" is not present in the dictionary.\\n\\n\\nHowever, the following test case with empty dictionary as input expects a true response. Seems like this test case is wrong ?\\n\\nInput:          [],isUnique(\"hello\")\\n\\nOutput:       [false]\\n\\nExpected:   [true]"
                    },
                    {
                        "username": "JJ_LL",
                        "content": "Hi everyone,\\n\\nCan anyone tell me what is the mistake and how to fix it?\\n\\nThanks a lot!!!!\\n\\n![image](https://assets.leetcode.com/users/images/d3649a1f-59f2-4c4c-8558-684dd99daa02_1620665080.1850584.png)\\n"
                    },
                    {
                        "username": "javac123",
                        "content": "For input array : {\"deer\",\"door\",\"cake\",\"card\"} why is false expected for the word \"door\"."
                    },
                    {
                        "username": "skywalk3r",
                        "content": "The qestion descrption is not making any sense to me. Can someone explain me in simpler words, in plain english what the author is tryig to convey ?"
                    }
                ]
            },
            {
                "id": 1575248,
                "content": [
                    {
                        "username": "2016trojan",
                        "content": "The description (**A word's abbreviation is unique if no other word from the dictionary has the same abbreviation**) is clear however a bit twisting. It took me a few \"Wrong Answer\"s to finally understand what it's asking for.  \\nWe are trying to search for a word in a dictionary. If this word (also this word\\u2019s abbreviation) is not in the dictionary OR this word and only it\\u2019s abbreviation in the dictionary. We call a word\\u2019s abbreviation unique.  \\nEX:  \\n\\n    1) [\\u201cdog\\u201d]; isUnique(\\u201cdig\\u201d);   \\n\\n//False, because \\u201cdig\\u201d has the same abbreviation with \\u201cdog\" and \\u201cdog\\u201d is already in the dictionary. It\\u2019s not unique.  \\n\\n    2) [\\u201cdog\\u201d, \\u201cdog\"]; isUnique(\\u201cdog\\u201d);  \\n\\n //True, because \\u201cdog\\u201d is the only word that has \\u201cd1g\\u201d abbreviation.  \\n\\n    3) [\\u201cdog\\u201d, \\u201cdig\\u201d]; isUnique(\\u201cdog\\u201d);   \\n\\n//False, because if we have more than one word match to the same abbreviation, this abbreviation will never be unique."
                    },
                    {
                        "username": "GaoLiaoLiao",
                        "content": "why should [\"hello\"],isUnique(\"hello\") return [true] ?\\n\\nbut in the case below\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\nisUnique(\"cane\") -> false"
                    },
                    {
                        "username": "user4276gm",
                        "content": "1. Either there is no word in dictionary with same abbreviation or\\n2. If word has same abbreviation with any word of the dictionary then there should be only one word with that abbreviation in dictionary and it has to be same as word (which is being evaluated as unique)."
                    },
                    {
                        "username": "Felomeng",
                        "content": "I\\'m confused by the statement as well. From the description, one cannot deduce this conclusion."
                    },
                    {
                        "username": "medivhsteve",
                        "content": "37 / 53 test cases passed.\\n\\n\\nInput:\\n\\n[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nOutput:\\n\\n[true,true,true,true,true]\\n\\nExpected:\\n\\n[false,false,false,true,true]\\n\\n\\n\\n\\nPlease google \"doge\"."
                    },
                    {
                        "username": "jpaunikar8",
                        "content": "[\"ValidWordAbbr\",\"isUnique\",\"isUnique\",\"isUnique\",\"isUnique\"]\\n[[[\"deer\",\"door\",\"cake\",\"card\"]],[\"dear\"],[\"door\"],[\"cart\"],[\"cake\"]]\\nOutput:\\n[null,false,true,true,true]\\nExpected:\\n[null,false,false,true,true]\\n\\nWhy is door false?"
                    },
                    {
                        "username": "dominion0331",
                        "content": "[@jsk9421](/jsk9421) \"door\" is in the original array\\noriginal array = [\"deer\",\"door\",\"cake\",\"card\"]\\nword = \"door\""
                    },
                    {
                        "username": "jsk9421",
                        "content": "It has to be the only word from the original array with the same abbr. \\nHere, deer and door have the same abbr.\\n\\n\"There\\'s no same abbr\" \\nor\\n1. Having the same word in the original array AND\\n2. No other words in the original array have the same abbr."
                    },
                    {
                        "username": "kai54",
                        "content": "[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nThis should return [true, true, true, true, true]. I don't understand why it will be [false, false, false,true,true]"
                    },
                    {
                        "username": "rainhacker",
                        "content": "Per the example provided in question:\\n\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\n\\nisUnique(\"dear\") -> false\\n\\nisUnique(\"cart\") -> true\\n\\nisUnique(\"cane\") -> false\\n\\nisUnique(\"make\") -> true\\n\\n\\n\\nisUnique(\"cane\") -> false because \"cane\" is not present in the dictionary.\\n\\n\\nHowever, the following test case with empty dictionary as input expects a true response. Seems like this test case is wrong ?\\n\\nInput:          [],isUnique(\"hello\")\\n\\nOutput:       [false]\\n\\nExpected:   [true]"
                    },
                    {
                        "username": "JJ_LL",
                        "content": "Hi everyone,\\n\\nCan anyone tell me what is the mistake and how to fix it?\\n\\nThanks a lot!!!!\\n\\n![image](https://assets.leetcode.com/users/images/d3649a1f-59f2-4c4c-8558-684dd99daa02_1620665080.1850584.png)\\n"
                    },
                    {
                        "username": "javac123",
                        "content": "For input array : {\"deer\",\"door\",\"cake\",\"card\"} why is false expected for the word \"door\"."
                    },
                    {
                        "username": "skywalk3r",
                        "content": "The qestion descrption is not making any sense to me. Can someone explain me in simpler words, in plain english what the author is tryig to convey ?"
                    }
                ]
            },
            {
                "id": 1573098,
                "content": [
                    {
                        "username": "2016trojan",
                        "content": "The description (**A word's abbreviation is unique if no other word from the dictionary has the same abbreviation**) is clear however a bit twisting. It took me a few \"Wrong Answer\"s to finally understand what it's asking for.  \\nWe are trying to search for a word in a dictionary. If this word (also this word\\u2019s abbreviation) is not in the dictionary OR this word and only it\\u2019s abbreviation in the dictionary. We call a word\\u2019s abbreviation unique.  \\nEX:  \\n\\n    1) [\\u201cdog\\u201d]; isUnique(\\u201cdig\\u201d);   \\n\\n//False, because \\u201cdig\\u201d has the same abbreviation with \\u201cdog\" and \\u201cdog\\u201d is already in the dictionary. It\\u2019s not unique.  \\n\\n    2) [\\u201cdog\\u201d, \\u201cdog\"]; isUnique(\\u201cdog\\u201d);  \\n\\n //True, because \\u201cdog\\u201d is the only word that has \\u201cd1g\\u201d abbreviation.  \\n\\n    3) [\\u201cdog\\u201d, \\u201cdig\\u201d]; isUnique(\\u201cdog\\u201d);   \\n\\n//False, because if we have more than one word match to the same abbreviation, this abbreviation will never be unique."
                    },
                    {
                        "username": "GaoLiaoLiao",
                        "content": "why should [\"hello\"],isUnique(\"hello\") return [true] ?\\n\\nbut in the case below\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\nisUnique(\"cane\") -> false"
                    },
                    {
                        "username": "user4276gm",
                        "content": "1. Either there is no word in dictionary with same abbreviation or\\n2. If word has same abbreviation with any word of the dictionary then there should be only one word with that abbreviation in dictionary and it has to be same as word (which is being evaluated as unique)."
                    },
                    {
                        "username": "Felomeng",
                        "content": "I\\'m confused by the statement as well. From the description, one cannot deduce this conclusion."
                    },
                    {
                        "username": "medivhsteve",
                        "content": "37 / 53 test cases passed.\\n\\n\\nInput:\\n\\n[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nOutput:\\n\\n[true,true,true,true,true]\\n\\nExpected:\\n\\n[false,false,false,true,true]\\n\\n\\n\\n\\nPlease google \"doge\"."
                    },
                    {
                        "username": "jpaunikar8",
                        "content": "[\"ValidWordAbbr\",\"isUnique\",\"isUnique\",\"isUnique\",\"isUnique\"]\\n[[[\"deer\",\"door\",\"cake\",\"card\"]],[\"dear\"],[\"door\"],[\"cart\"],[\"cake\"]]\\nOutput:\\n[null,false,true,true,true]\\nExpected:\\n[null,false,false,true,true]\\n\\nWhy is door false?"
                    },
                    {
                        "username": "dominion0331",
                        "content": "[@jsk9421](/jsk9421) \"door\" is in the original array\\noriginal array = [\"deer\",\"door\",\"cake\",\"card\"]\\nword = \"door\""
                    },
                    {
                        "username": "jsk9421",
                        "content": "It has to be the only word from the original array with the same abbr. \\nHere, deer and door have the same abbr.\\n\\n\"There\\'s no same abbr\" \\nor\\n1. Having the same word in the original array AND\\n2. No other words in the original array have the same abbr."
                    },
                    {
                        "username": "kai54",
                        "content": "[\"dog\"],isUnique(\"dig\"),isUnique(\"dug\"),isUnique(\"dag\"),isUnique(\"dog\"),isUnique(\"doge\")\\n\\nThis should return [true, true, true, true, true]. I don't understand why it will be [false, false, false,true,true]"
                    },
                    {
                        "username": "rainhacker",
                        "content": "Per the example provided in question:\\n\\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\\n\\nisUnique(\"dear\") -> false\\n\\nisUnique(\"cart\") -> true\\n\\nisUnique(\"cane\") -> false\\n\\nisUnique(\"make\") -> true\\n\\n\\n\\nisUnique(\"cane\") -> false because \"cane\" is not present in the dictionary.\\n\\n\\nHowever, the following test case with empty dictionary as input expects a true response. Seems like this test case is wrong ?\\n\\nInput:          [],isUnique(\"hello\")\\n\\nOutput:       [false]\\n\\nExpected:   [true]"
                    },
                    {
                        "username": "JJ_LL",
                        "content": "Hi everyone,\\n\\nCan anyone tell me what is the mistake and how to fix it?\\n\\nThanks a lot!!!!\\n\\n![image](https://assets.leetcode.com/users/images/d3649a1f-59f2-4c4c-8558-684dd99daa02_1620665080.1850584.png)\\n"
                    },
                    {
                        "username": "javac123",
                        "content": "For input array : {\"deer\",\"door\",\"cake\",\"card\"} why is false expected for the word \"door\"."
                    },
                    {
                        "username": "skywalk3r",
                        "content": "The qestion descrption is not making any sense to me. Can someone explain me in simpler words, in plain english what the author is tryig to convey ?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Longest Absolute File Path",
        "question_content": "<p>Suppose we have a file system that stores both files and directories. An example of one system is represented in the following picture:</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/mdir.jpg\" style=\"width: 681px; height: 322px;\" /></p>\n\n<p>Here, we have <code>dir</code> as the only directory in the root. <code>dir</code> contains two subdirectories, <code>subdir1</code> and <code>subdir2</code>. <code>subdir1</code> contains a file <code>file1.ext</code> and subdirectory <code>subsubdir1</code>. <code>subdir2</code> contains a subdirectory <code>subsubdir2</code>, which contains a file <code>file2.ext</code>.</p>\n\n<p>In text form, it looks like this (with  representing the tab character):</p>\n\n<pre>\ndir\n subdir1\n  file1.ext\n  subsubdir1\n subdir2\n  subsubdir2\n   file2.ext\n</pre>\n\n<p>If we were to write this representation in code, it will look like this: <code>&quot;dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext&quot;</code>. Note that the <code>&#39;\\n&#39;</code> and <code>&#39;\\t&#39;</code> are the new-line and tab characters.</p>\n\n<p>Every file and directory has a unique <strong>absolute path</strong> in the file system, which is the order of directories that must be opened to reach the file/directory itself, all concatenated by <code>&#39;/&#39;s</code>. Using the above example, the <strong>absolute path</strong> to <code>file2.ext</code> is <code>&quot;dir/subdir2/subsubdir2/file2.ext&quot;</code>. Each directory name consists of letters, digits, and/or spaces. Each file name is of the form <code>name.extension</code>, where <code>name</code> and <code>extension</code> consist of letters, digits, and/or spaces.</p>\n\n<p>Given a string <code>input</code> representing the file system in the explained format, return <em>the length of the <strong>longest absolute path</strong> to a <strong>file</strong> in the abstracted file system</em>. If there is no file in the system, return <code>0</code>.</p>\n\n<p><strong>Note</strong> that the testcases are generated such that the file system is valid and no file or directory name has length 0.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/dir1.jpg\" style=\"width: 401px; height: 202px;\" />\n<pre>\n<strong>Input:</strong> input = &quot;dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext&quot;\n<strong>Output:</strong> 20\n<strong>Explanation:</strong> We have only one file, and the absolute path is &quot;dir/subdir2/file.ext&quot; of length 20.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/dir2.jpg\" style=\"width: 641px; height: 322px;\" />\n<pre>\n<strong>Input:</strong> input = &quot;dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext&quot;\n<strong>Output:</strong> 32\n<strong>Explanation:</strong> We have two files:\n&quot;dir/subdir1/file1.ext&quot; of length 21\n&quot;dir/subdir2/subsubdir2/file2.ext&quot; of length 32.\nWe return 32 since it is the longest absolute path to a file.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> input = &quot;a&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> We do not have any files, just a single directory named &quot;a&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= input.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>input</code> may contain lowercase or uppercase English letters, a new line character <code>&#39;\\n&#39;</code>, a tab character <code>&#39;\\t&#39;</code>, a dot <code>&#39;.&#39;</code>, a space <code>&#39; &#39;</code>, and digits.</li>\n\t<li>All file and directory names have <strong>positive</strong> length.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 86619,
                "title": "simple-python-solution",
                "content": "The number of tabs is my `depth` and for each depth I store the current path length.\\n\\n    def lengthLongestPath(self, input):\\n        maxlen = 0\\n        pathlen = {0: 0}\\n        for line in input.splitlines():\\n            name = line.lstrip('\\\\t')\\n            depth = len(line) - len(name)\\n            if '.' in name:\\n                maxlen = max(maxlen, pathlen[depth] + len(name))\\n            else:\\n                pathlen[depth + 1] = pathlen[depth] + len(name) + 1\\n        return maxlen",
                "solutionTags": [],
                "code": "The number of tabs is my `depth` and for each depth I store the current path length.\\n\\n    def lengthLongestPath(self, input):\\n        maxlen = 0\\n        pathlen = {0: 0}\\n        for line in input.splitlines():\\n            name = line.lstrip('\\\\t')\\n            depth = len(line) - len(name)\\n            if '.' in name:\\n                maxlen = max(maxlen, pathlen[depth] + len(name))\\n            else:\\n                pathlen[depth + 1] = pathlen[depth] + len(name) + 1\\n        return maxlen",
                "codeTag": "Python3"
            },
            {
                "id": 86615,
                "title": "9-lines-4ms-java-solution",
                "content": "```\\npublic int lengthLongestPath(String input) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        stack.push(0); // \"dummy\" length\\n        int maxLen = 0;\\n        for(String s:input.split(\"\\\\n\")){\\n            int lev = s.lastIndexOf(\"\\\\t\")+1; // number of \"\\\\t\"\\n            while(lev+1<stack.size()) stack.pop(); // find parent\\n            int len = stack.peek()+s.length()-lev+1; // remove \"/t\", add\"/\"\\n            stack.push(len);\\n            // check if it is file\\n            if(s.contains(\".\")) maxLen = Math.max(maxLen, len-1); \\n        }\\n        return maxLen;\\n    }\\n```\\n\\nAn even shorter and faster solution using array instead of stack:\\n```\\npublic int lengthLongestPath(String input) {\\n    String[] paths = input.split(\"\\\\n\");\\n    int[] stack = new int[paths.length+1];\\n    int maxLen = 0;\\n    for(String s:paths){\\n        int lev = s.lastIndexOf(\"\\\\t\")+1, curLen = stack[lev+1] = stack[lev]+s.length()-lev+1;\\n        if(s.contains(\".\")) maxLen = Math.max(maxLen, curLen-1);\\n    }\\n    return maxLen;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\npublic int lengthLongestPath(String input) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        stack.push(0); // \"dummy\" length\\n        int maxLen = 0;\\n        for(String s:input.split(\"\\\\n\")){\\n            int lev = s.lastIndexOf(\"\\\\t\")+1; // number of \"\\\\t\"\\n            while(lev+1<stack.size()) stack.pop(); // find parent\\n            int len = stack.peek()+s.length()-lev+1; // remove \"/t\", add\"/\"\\n            stack.push(len);\\n            // check if it is file\\n            if(s.contains(\".\")) maxLen = Math.max(maxLen, len-1); \\n        }\\n        return maxLen;\\n    }\\n```\n```\\npublic int lengthLongestPath(String input) {\\n    String[] paths = input.split(\"\\\\n\");\\n    int[] stack = new int[paths.length+1];\\n    int maxLen = 0;\\n    for(String s:paths){\\n        int lev = s.lastIndexOf(\"\\\\t\")+1, curLen = stack[lev+1] = stack[lev]+s.length()-lev+1;\\n        if(s.contains(\".\")) maxLen = Math.max(maxLen, curLen-1);\\n    }\\n    return maxLen;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 86666,
                "title": "java-o-n-solution-using-stack",
                "content": "The depth of the directory/file is calculated by counting how many \"\\\\t\"s are there.\\nThe time complexity is O(n) because each substring in the input string only goes into the stack once, and pops out from the stack once.\\n```\\npublic class Solution {\\n    public int lengthLongestPath(String input) {\\n        String[] tokens = input.split(\"\\\\n\");\\n        int result = 0;\\n        int curLen = 0;\\n        Stack<Integer> stack = new Stack<>();\\n\\n        for (String s : tokens) {\\n            int level = countLevel(s);\\n\\n            // if current directory/file depth is lower that the top directory/file on the stack, pop from stack \\n            while (stack.size() > level) {\\n                curLen -= stack.pop();\\n            }\\n\\n            // +1 here because a \"/\" needs to be counted following each diretory\\n            int len = s.replaceAll(\"\\\\t\", \"\").length() + 1;\\n            curLen += len;\\n\\n            // if s contains \".\", we have found a file!\\n            if (s.contains(\".\")) {\\n                result = curLen - 1 > result ? curLen - 1 : result;\\n            }\\n            stack.add(len);\\n        }\\n        return result;\\n    }\\n    \\n    private int countLevel(String s) {\\n        String cur = s.replaceAll(\"\\\\t\", \"\");\\n        return s.length() - cur.length();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int lengthLongestPath(String input) {\\n        String[] tokens = input.split(\"\\\\n\");\\n        int result = 0;\\n        int curLen = 0;\\n        Stack<Integer> stack = new Stack<>();\\n\\n        for (String s : tokens) {\\n            int level = countLevel(s);\\n\\n            // if current directory/file depth is lower that the top directory/file on the stack, pop from stack \\n            while (stack.size() > level) {\\n                curLen -= stack.pop();\\n            }\\n\\n            // +1 here because a \"/\" needs to be counted following each diretory\\n            int len = s.replaceAll(\"\\\\t\", \"\").length() + 1;\\n            curLen += len;\\n\\n            // if s contains \".\", we have found a file!\\n            if (s.contains(\".\")) {\\n                result = curLen - 1 > result ? curLen - 1 : result;\\n            }\\n            stack.add(len);\\n        }\\n        return result;\\n    }\\n    \\n    private int countLevel(String s) {\\n        String cur = s.replaceAll(\"\\\\t\", \"\");\\n        return s.length() - cur.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86649,
                "title": "what-is-purpose-of-weird-test-cases",
                "content": "I am not sure if testing code against ```\"dir\\\\n    file.txt\"``` will imply any intelligence. What is the purpose of such cases? Do they really occur in tab organized directory structure file? Dear problem setters, think about it OR please clarify me here. Thanks.",
                "solutionTags": [],
                "code": "```\"dir\\\\n    file.txt\"```",
                "codeTag": "Unknown"
            },
            {
                "id": 86719,
                "title": "two-different-solutions-in-java-using-stack-and-hashmap",
                "content": "`\"dir\\\\n\\\\tsubdir1\\\\n\\\\t\\\\tfile1.ext\\\\n\\\\t\\\\tsubsubdir1\\\\n\\\\tsubdir2\\\\n\\\\t\\\\tsubsubdir2\\\\n\\\\t\\\\t\\\\tfile2.ext\"`\\nthe root dir `dir` is in level 1, we push a initial value `0` into stack first indicating a not existing file with length 0\\n```\\n    public int lengthLongestPath(String input) {\\n        ArrayDeque<Integer> stack = new ArrayDeque<>();\\n        stack.push(0);\\n        int result = 0;\\n        for (String s : input.split(\"\\\\n\")) {\\n            int level = s.lastIndexOf('\\\\t') + 1;\\n            int len = s.length() - level;\\n            while (stack.size() > level + 1) {\\n                stack.pop();\\n            }\\n            if (s.contains(\".\")) {\\n                result = Math.max(result, stack.peek() + len);\\n            } else {\\n                stack.push(stack.peek() + len + 1);\\n            }\\n        }\\n        return result;\\n    }\\n```\\nhashMap stores (level, the length of the path up to level `level`) pairs. By default, we use a (0,0) to initialize the hashmap. But for example `\"dir\\\\n\\\\tsubdir1\\\\n\\\\t\\\\tfile1.ext\\\\n\\\\t\\\\tsubsubdir1\\\\n\\\\tsubdir2\\\\n\\\\t\\\\tsubsubdir2\\\\n\\\\t\\\\t\\\\tfile2.ext\"`.\\ndir is in level 1, not 0. subdir1 is in level 2, so on...\\nwe update the hashMap using **hashMap.get(level) + len + 1** because the current level is level+1, previous level is level, we `+1` because the additional path separator char `\\\\` , if s contains `.` , we update the current max length\\nHope helps\\n\\n```\\n    public int lengthLongestPath(String input) {\\n        HashMap<Integer, Integer> hashMap = new HashMap<>();\\n        hashMap.put(0, 0);\\n        int result = 0;\\n        for (String s : input.split(\"\\\\n\")) {\\n            int level = s.lastIndexOf('\\\\t') + 1;\\n            int len = s.length() - level;\\n            if (s.contains(\".\")) {\\n                result = Math.max(result, hashMap.get(level) + len);\\n            } else {\\n                hashMap.put(level + 1, hashMap.get(level) + len + 1);\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int lengthLongestPath(String input) {\\n        ArrayDeque<Integer> stack = new ArrayDeque<>();\\n        stack.push(0);\\n        int result = 0;\\n        for (String s : input.split(\"\\\\n\")) {\\n            int level = s.lastIndexOf('\\\\t') + 1;\\n            int len = s.length() - level;\\n            while (stack.size() > level + 1) {\\n                stack.pop();\\n            }\\n            if (s.contains(\".\")) {\\n                result = Math.max(result, stack.peek() + len);\\n            } else {\\n                stack.push(stack.peek() + len + 1);\\n            }\\n        }\\n        return result;\\n    }\\n```\n```\\n    public int lengthLongestPath(String input) {\\n        HashMap<Integer, Integer> hashMap = new HashMap<>();\\n        hashMap.put(0, 0);\\n        int result = 0;\\n        for (String s : input.split(\"\\\\n\")) {\\n            int level = s.lastIndexOf('\\\\t') + 1;\\n            int len = s.length() - level;\\n            if (s.contains(\".\")) {\\n                result = Math.max(result, hashMap.get(level) + len);\\n            } else {\\n                hashMap.put(level + 1, hashMap.get(level) + len + 1);\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 290430,
                "title": "elegant-c-solution-without-stack",
                "content": "Sharing this elegant c++ soltuon without stack.\\n\\n```\\n        input.push_back(\\'\\\\n\\');\\n        vector<int> levels(300, 0);\\n        int level = 0;\\n        bool isFile = false;\\n        int ans = 0;\\n        int length = 0;\\n            \\n        for(char c: input){\\n            switch(c){\\n                case \\'\\\\n\\': { level = 0; length = 0; isFile=false; break; }\\n                case \\'\\\\t\\': { level++; break; }\\n                case \\'.\\' : isFile = true;\\n                    \\n                default:\\n                    length++;\\n                    levels[level] = length;\\n                    if(isFile){\\n                        ans = max(ans, accumulate(levels.begin(), levels.begin() + level + 1, 0) + level);\\n                    }\\n            }\\n        }\\n        \\n        return ans;\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n        input.push_back(\\'\\\\n\\');\\n        vector<int> levels(300, 0);\\n        int level = 0;\\n        bool isFile = false;\\n        int ans = 0;\\n        int length = 0;\\n            \\n        for(char c: input){\\n            switch(c){\\n                case \\'\\\\n\\': { level = 0; length = 0; isFile=false; break; }\\n                case \\'\\\\t\\': { level++; break; }\\n                case \\'.\\' : isFile = true;\\n                    \\n                default:\\n                    length++;\\n                    levels[level] = length;\\n                    if(isFile){\\n                        ans = max(ans, accumulate(levels.begin(), levels.begin() + level + 1, 0) + level);\\n                    }\\n            }\\n        }\\n        \\n        return ans;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 86640,
                "title": "python-solution-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n    def lengthLongestPath(self, input):\\n        \"\"\"\\n        :type input: str\\n        :rtype: int\\n        \"\"\"\\n\\n        dict={}\\n        longest=0\\n        fileList=input.split(\"\\\\n\")\\n        for i in fileList:\\n            if \".\" not in i:  #\\u662f\\u6587\\u4ef6\\u5939\\n                key = i.count(\"\\\\t\") #\\u662f\\u51e0\\u7ea7\\u6587\\u4ef6\\u5939\\n                value = len(i.replace(\"\\\\t\",\"\")) #\\u9664\\u53bb\\\\t\\u540e\\u7684\\u957f\\u5ea6\\uff0c\\u662f\\u5b9e\\u9645\\u957f\\u5ea6\\n                dict[key]=value\\n            else: #\\u662f\\u6587\\u4ef6\\u3002\\n                key=i.count(\"\\\\t\")\\n                #\\u3000\\u6587\\u4ef6\\u7684\\u957f\\u5ea6\\uff1a\\u6240\\u6709\\u76ee\\u5f55\\u7684\\u957f\\u5ea6\\uff0b\\u6587\\u4ef6\\u7684\\u957f\\u5ea6\\uff0b\\u201c\\\\\\u201d\\u7684\\u6570\\u91cf\\n                length = sum([dict[j] for j in dict.keys() if j<key]) + len(i.replace(\"\\\\t\",\"\")) + key\\n                longest=max(longest,length)\\n        return longest\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def lengthLongestPath(self, input):\\n        \"\"\"\\n        :type input: str\\n        :rtype: int\\n        \"\"\"\\n\\n        dict={}\\n        longest=0\\n        fileList=input.split(\"\\\\n\")\\n        for i in fileList:\\n            if \".\" not in i:  #\\u662f\\u6587\\u4ef6\\u5939\\n                key = i.count(\"\\\\t\") #\\u662f\\u51e0\\u7ea7\\u6587\\u4ef6\\u5939\\n                value = len(i.replace(\"\\\\t\",\"\")) #\\u9664\\u53bb\\\\t\\u540e\\u7684\\u957f\\u5ea6\\uff0c\\u662f\\u5b9e\\u9645\\u957f\\u5ea6\\n                dict[key]=value\\n            else: #\\u662f\\u6587\\u4ef6\\u3002\\n                key=i.count(\"\\\\t\")\\n                #\\u3000\\u6587\\u4ef6\\u7684\\u957f\\u5ea6\\uff1a\\u6240\\u6709\\u76ee\\u5f55\\u7684\\u957f\\u5ea6\\uff0b\\u6587\\u4ef6\\u7684\\u957f\\u5ea6\\uff0b\\u201c\\\\\\u201d\\u7684\\u6570\\u91cf\\n                length = sum([dict[j] for j in dict.keys() if j<key]) + len(i.replace(\"\\\\t\",\"\")) + key\\n                longest=max(longest,length)\\n        return longest\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241061,
                "title": "c-easiest-o-n-solution-with-explanation-beats-100-0ms",
                "content": "```\\nclass Solution{\\npublic:\\n\\tint lengthLongestPath(string input){\\n\\t\\t stringstream ss(input);\\n         string data;\\n\\t\\t // this map will store the len upto previous dir for the current explored path \\n         unordered_map<int,int>len;\\n         int res = 0;\\n\\t\\t \\n         while(getline(ss, data, \\'\\\\n\\'))\\n         {\\n\\t\\t    // data will contain string like dir, /tsubdir1, /tsubdir2....etc\\n             int numTabs  = 0;   //count no of tabs\\n\\t\\t\\t \\n             while(data[numTabs] == \\'\\\\t\\') numTabs++;\\n\\t\\t\\t \\n             if(numTabs == 0)\\n                 len[numTabs] = data.size(); //root directory\\n             else {\\n\\t\\t\\t    // length upto previous dir + len(\"/\") + no of chars after tabs for current filename/ dirname\\n                 len[numTabs] = len[numTabs - 1] + 1 + data.substr(numTabs).size();   // added 1 for \\'/\\'\\n\\t\\t\\t }\\n\\t\\t\\t \\n\\t\\t\\t // If it\\'s a file then update the res \\n             if(data.find(\\'.\\') != string :: npos)\\n                 res = max(res, len[numTabs]);\\n         }\\n\\t\\t \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n\\tint lengthLongestPath(string input){\\n\\t\\t stringstream ss(input);\\n         string data;\\n\\t\\t // this map will store the len upto previous dir for the current explored path \\n         unordered_map<int,int>len;\\n         int res = 0;\\n\\t\\t \\n         while(getline(ss, data, \\'\\\\n\\'))\\n         {\\n\\t\\t    // data will contain string like dir, /tsubdir1, /tsubdir2....etc\\n             int numTabs  = 0;   //count no of tabs\\n\\t\\t\\t \\n             while(data[numTabs] == \\'\\\\t\\') numTabs++;\\n\\t\\t\\t \\n             if(numTabs == 0)\\n                 len[numTabs] = data.size(); //root directory\\n             else {\\n\\t\\t\\t    // length upto previous dir + len(\"/\") + no of chars after tabs for current filename/ dirname\\n                 len[numTabs] = len[numTabs - 1] + 1 + data.substr(numTabs).size();   // added 1 for \\'/\\'\\n\\t\\t\\t }\\n\\t\\t\\t \\n\\t\\t\\t // If it\\'s a file then update the res \\n             if(data.find(\\'.\\') != string :: npos)\\n                 res = max(res, len[numTabs]);\\n         }\\n\\t\\t \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86821,
                "title": "c-o-n-solution-with-hashmap",
                "content": "This solution is C++ version of https://discuss.leetcode.com/topic/55097/simple-python-solution. Main idea is using hashmap to store the path length for each depth. The depth is the number of \"\\\\t\". For each filename, calculate the path length by the current depth.\\n\\n```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        istringstream ss(input);\\n        string token;\\n        size_t max_len = 0;\\n        unordered_map<int, int> path_len;\\n        path_len[0] = 0;\\n        while (getline(ss, token)) {\\n            auto pos = token.find_last_of(\"\\\\t\");\\n            string name = (pos != std::string::npos) ? token.substr(pos + 1) : token;\\n            \\n            int depth = token.size() - name.size();\\n            if (token.find(\".\") != std::string::npos) {\\n                max_len = max(max_len, path_len[depth] + name.size());\\n            } else {\\n                path_len[depth + 1] = path_len[depth] + name.size() + 1;\\n            }\\n        }\\n        return max_len;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        istringstream ss(input);\\n        string token;\\n        size_t max_len = 0;\\n        unordered_map<int, int> path_len;\\n        path_len[0] = 0;\\n        while (getline(ss, token)) {\\n            auto pos = token.find_last_of(\"\\\\t\");\\n            string name = (pos != std::string::npos) ? token.substr(pos + 1) : token;\\n            \\n            int depth = token.size() - name.size();\\n            if (token.find(\".\") != std::string::npos) {\\n                max_len = max(max_len, path_len[depth] + name.size());\\n            } else {\\n                path_len[depth + 1] = path_len[depth] + name.size() + 1;\\n            }\\n        }\\n        return max_len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812407,
                "title": "python-3-stack-explanation",
                "content": "### Intuition\\n- Directories has a hierarchy type of relation, so we can use stack to simulate the process.\\n### Explanations\\n- For each dir or file, we store 3 things in stack\\n\\t- current total length (including parent and \\'/\\'), depth (how many \\'\\\\t\\' to reach this subdir)\\n- If `stack` is empty, we add new tuple\\n- If deepest dir or file in stack (`stack[-1]`) is at the same or deeper depth of current `path`\\n\\t- pop stack until `stack[-1]` (or empty stack) is shallower than depth of `path`\\n- Add tuple and cumulate the total length\\n- If `name` has `.` then it\\'s a file path and we can compare it with `ans` to get the longest.\\n### Implementation\\n```\\nclass Solution:\\n    def lengthLongestPath(self, s: str) -> int:\\n        paths, stack, ans = s.split(\\'\\\\n\\'), [], 0\\n        for path in paths:\\n            p = path.split(\\'\\\\t\\')\\n            depth, name = len(p) - 1, p[-1]\\n            l = len(name)\\n            while stack and stack[-1][1] >= depth: stack.pop()\\n            if not stack: stack.append((l, depth))\\n            else: stack.append((l+stack[-1][0], depth))\\n            if \\'.\\' in name: ans = max(ans, stack[-1][0] + stack[-1][1])   \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def lengthLongestPath(self, s: str) -> int:\\n        paths, stack, ans = s.split(\\'\\\\n\\'), [], 0\\n        for path in paths:\\n            p = path.split(\\'\\\\t\\')\\n            depth, name = len(p) - 1, p[-1]\\n            l = len(name)\\n            while stack and stack[-1][1] >= depth: stack.pop()\\n            if not stack: stack.append((l, depth))\\n            else: stack.append((l+stack[-1][0], depth))\\n            if \\'.\\' in name: ans = max(ans, stack[-1][0] + stack[-1][1])   \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 389124,
                "title": "simple-easy-to-understand-with-explanation-java",
                "content": "\\nLets taken an example to find how to get the maximum length\\nThe string \"dir\\\\n\\\\tsubdir1\\\\n\\\\tsubdir2\\\\n\\\\t\\\\tfile.ext\"\\nrepresents:\\n```\\n dir\\n    subdir1\\n     subdir2\\n         file.ext\\n```\\n\\n\\'\\\\n\\' -> is being just a new line{to represent} and should not be counted in final string.\\n\\'\\\\t\\' -> is being used to indicate the file/subfolder is part of a directory. In above example \\'\\\\tsubdir1\\' is folder in \\'dir\\' and \\'\\\\t\\\\tfile.ext\\' is file under subdir2. Which mean we need to use\\n\\'\\\\t\\' for identify the level of directory.\\n\\nNow, in order to find deepest file, we need to find the deepest \\'\\\\t\\' such that it attached to a file. Two cases\\n```\\nCase 1: \\\\t is attached to a sub-dir\\n case 1.1: This sub-dir could be at the same level as the other sub-dir. In above example, subdire2 is on same level as subdir1. In this case, we just need to count length same for both {here its 3(dir) + 6(subdir2)}\\n case 1.2: This sub-dir could be at different level in its sub-dir of another sub-dir. In that case, we need to add length from top to bottom example { its 3(dir) + 6(subdir1) + 6(subdir2)} where sub-dir2 is sub-dir of sub-dir1\\n```\\n\\n`Case 2: \\\\t is attached to a file, to identify it we can check does it contain a \\'.\\' or not. In this case, we need to attach the length to highest correct sub-dir.`\\n\\nNow, Solving for Case 1 is trivial. But how to solve for case 2?\\nOne should notice that the string will be always forming \\'order\\' in the form of sub-dir contains the file. Example\\nThe string \"dir\\\\n\\\\tsubdir1\\\\n\\\\t\\\\tfile1.ext\\\\n\\\\t\\\\tsubsubdir1\\\\n\\\\tsubdir2\\\\n\\\\t\\\\tsubsubdir2\\\\n\\\\t\\\\t\\\\tfile2.ext\" represents:\\n ```\\ndir\\n     subdir1\\n         file1.ext <- This always comes first in string then file2.ext\\n         subsubdir1\\n     subdir2\\n         subsubdir2\\n             file2.ext <- This always comes later in string then file1.ext\\n```\\n\\nWhich means we can simply scan the string to find correct level of file.\\n\\n---------------\\n**Algorithm:** Keeping above things in mind\\n1. Split the string by \\'\\\\n\\'\\n2. Find the last index of \\'\\\\t\\' { last because a sub-string may contain multiple \\'\\\\t\\' but as above question they effectively a single sub-dir or file}\\n3. Compute the remaining length of string without \\'\\\\t\\'\\n4. Check does this is a file or not\\n a) if  a sub-dir, than append its length to just higher level sub-dir\\n b) if its a file, compute the length of string for this file. To compute, get the level at this file is and add the length of the file\\n---------------\\n\\nTime Complexity : O(n) where n is length of given string { lastIndexOf takes O(L) time and contains take O(L) time. In worst case, there is no \\\\n and we run both in O(n) time}\\nSpace: O(h) where h represent levels of string h~=n\\n\\nRuntime: 1 ms, faster than 97.28% of Java online submissions for Longest Absolute File Path.\\nMemory Usage: 34.4 MB, less than 100.00% of Java online submissions for Longest Absolute File Path.\\n \\n \\n ```\\n \\n    public int lengthLongestPath(String input) {\\n\\n        if (input == null || input.isEmpty())\\n            return 0;\\n\\n        int maxLength = 0; //if may possible the string does not contain any file at all hence 0\\n\\n        //to keep the length of every sub-dir at same level. It stores length of string at each level\\n        Map<Integer, Integer> levelVsLength = new HashMap<>();\\n\\n        levelVsLength.putIfAbsent(0, 0); //empty level will have 0 length string\\n\\n        //1. Split the string by \\'\\\\n\\'\\n        String[] string = input.split(\"\\\\n\");\\n\\n        for (String s : string) {\\n\\n            //2. Find the last index of \\'\\\\t\\' { last because a sub-string may contain multiple \\'\\\\t\\' but as above question they effectively a single sub-dir or file}\\n            int tabIndexLevel = s.lastIndexOf(\\'\\\\t\\') + 1; //this will return the index of \\'\\\\\\' if \\'\\\\t\\' present, to make index of \\'\\\\t\\' we add 1. It also play well when there is no \\'\\\\t\\' then it makes level 0\\n\\n            // 3. Compute the remaining length of string without \\'\\\\t\\'\\n            int len = s.length() - tabIndexLevel;\\n\\n\\n            //4. Check does this is a file or not\\n            if (!s.contains(\".\")) {\\n                // a) if  a sub-dir, than append its length to just higher level sub-dir\\n                levelVsLength.put(tabIndexLevel + 1, levelVsLength.get(tabIndexLevel) + len + 1);\\n            } else {\\n                //b) if its a file, compute the length of string for this file. To compute, get the level at this file is and add the length of the file\\n                maxLength = Math.max(maxLength, levelVsLength.get(tabIndexLevel) + len);\\n            }\\n        }\\n        return maxLength;\\n\\n\\n    }\\n ```\\n \\n \\n Using stack\\n \\n ```\\n  public int lengthLongestPath(String input) {\\n\\n        if (input == null || input.isEmpty())\\n            return 0;\\n\\n        int maxLength = 0; //if may possible the string does not contain any file at all hence 0\\n\\n        //to keep the length of every sub-dir at same level. It stores length of string at each level\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(0); //empty level will have 0 length string\\n\\n\\n        //1. Split the string by \\'\\\\n\\'\\n        String[] string = input.split(\"\\\\n\");\\n\\n        for (String s : string) {\\n\\n            //2. Find the last index of \\'\\\\t\\' { last because a sub-string may contain multiple \\'\\\\t\\' but as above question they effectively a single sub-dir or file}\\n            int tabIndexLevel = s.lastIndexOf(\\'\\\\t\\') + 1; //this will return the index of \\'\\\\\\' if \\'\\\\t\\' present, to make index of \\'\\\\t\\' we add 1. It also play well when there is no \\'\\\\t\\' then it makes level 0\\n\\n            // 3. Compute the remaining length of string without \\'\\\\t\\'\\n            int len = s.length() - tabIndexLevel;\\n\\n            //remove all the level which is bigger than this because we must have evaluate the sub-string size by them\\n            while (stack.size() > tabIndexLevel + 1)\\n                stack.pop();\\n\\n            //4. Check does this is a file or not\\n            if (!s.contains(\".\")) {\\n                // a) if  a sub-dir, than append its length to just higher level sub-dir\\n                stack.push(stack.peek() + len + 1);\\n            } else {\\n                //b) if its a file, compute the length of string for this file. To compute, get the level at this file is and add the length of the file\\n                maxLength = Math.max(maxLength, stack.peek() + len);\\n            }\\n        }\\n        return maxLength;\\n\\n\\n    }\\n ```",
                "solutionTags": [],
                "code": "```\\n dir\\n    subdir1\\n     subdir2\\n         file.ext\\n```\n```\\nCase 1: \\\\t is attached to a sub-dir\\n case 1.1: This sub-dir could be at the same level as the other sub-dir. In above example, subdire2 is on same level as subdir1. In this case, we just need to count length same for both {here its 3(dir) + 6(subdir2)}\\n case 1.2: This sub-dir could be at different level in its sub-dir of another sub-dir. In that case, we need to add length from top to bottom example { its 3(dir) + 6(subdir1) + 6(subdir2)} where sub-dir2 is sub-dir of sub-dir1\\n```\n```\\ndir\\n     subdir1\\n         file1.ext <- This always comes first in string then file2.ext\\n         subsubdir1\\n     subdir2\\n         subsubdir2\\n             file2.ext <- This always comes later in string then file1.ext\\n```\n```\\n \\n    public int lengthLongestPath(String input) {\\n\\n        if (input == null || input.isEmpty())\\n            return 0;\\n\\n        int maxLength = 0; //if may possible the string does not contain any file at all hence 0\\n\\n        //to keep the length of every sub-dir at same level. It stores length of string at each level\\n        Map<Integer, Integer> levelVsLength = new HashMap<>();\\n\\n        levelVsLength.putIfAbsent(0, 0); //empty level will have 0 length string\\n\\n        //1. Split the string by \\'\\\\n\\'\\n        String[] string = input.split(\"\\\\n\");\\n\\n        for (String s : string) {\\n\\n            //2. Find the last index of \\'\\\\t\\' { last because a sub-string may contain multiple \\'\\\\t\\' but as above question they effectively a single sub-dir or file}\\n            int tabIndexLevel = s.lastIndexOf(\\'\\\\t\\') + 1; //this will return the index of \\'\\\\\\' if \\'\\\\t\\' present, to make index of \\'\\\\t\\' we add 1. It also play well when there is no \\'\\\\t\\' then it makes level 0\\n\\n            // 3. Compute the remaining length of string without \\'\\\\t\\'\\n            int len = s.length() - tabIndexLevel;\\n\\n\\n            //4. Check does this is a file or not\\n            if (!s.contains(\".\")) {\\n                // a) if  a sub-dir, than append its length to just higher level sub-dir\\n                levelVsLength.put(tabIndexLevel + 1, levelVsLength.get(tabIndexLevel) + len + 1);\\n            } else {\\n                //b) if its a file, compute the length of string for this file. To compute, get the level at this file is and add the length of the file\\n                maxLength = Math.max(maxLength, levelVsLength.get(tabIndexLevel) + len);\\n            }\\n        }\\n        return maxLength;\\n\\n\\n    }\\n ```\n```\\n  public int lengthLongestPath(String input) {\\n\\n        if (input == null || input.isEmpty())\\n            return 0;\\n\\n        int maxLength = 0; //if may possible the string does not contain any file at all hence 0\\n\\n        //to keep the length of every sub-dir at same level. It stores length of string at each level\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(0); //empty level will have 0 length string\\n\\n\\n        //1. Split the string by \\'\\\\n\\'\\n        String[] string = input.split(\"\\\\n\");\\n\\n        for (String s : string) {\\n\\n            //2. Find the last index of \\'\\\\t\\' { last because a sub-string may contain multiple \\'\\\\t\\' but as above question they effectively a single sub-dir or file}\\n            int tabIndexLevel = s.lastIndexOf(\\'\\\\t\\') + 1; //this will return the index of \\'\\\\\\' if \\'\\\\t\\' present, to make index of \\'\\\\t\\' we add 1. It also play well when there is no \\'\\\\t\\' then it makes level 0\\n\\n            // 3. Compute the remaining length of string without \\'\\\\t\\'\\n            int len = s.length() - tabIndexLevel;\\n\\n            //remove all the level which is bigger than this because we must have evaluate the sub-string size by them\\n            while (stack.size() > tabIndexLevel + 1)\\n                stack.pop();\\n\\n            //4. Check does this is a file or not\\n            if (!s.contains(\".\")) {\\n                // a) if  a sub-dir, than append its length to just higher level sub-dir\\n                stack.push(stack.peek() + len + 1);\\n            } else {\\n                //b) if its a file, compute the length of string for this file. To compute, get the level at this file is and add the length of the file\\n                maxLength = Math.max(maxLength, stack.peek() + len);\\n            }\\n        }\\n        return maxLength;\\n\\n\\n    }\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 266896,
                "title": "simple-python-solution-with-detailed-explanation",
                "content": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        # return value\\n        maxlen = 0\\n        \\n        # map each level (0-indexed) to the current\\n        # maximum path length through that level;\\n        #\\n        # begin with a \"-1 level\" of 0 length, to simply\\n        # index the \"level before the 0th level\", which\\n        # is a common practice in dynamic programming\\n        levels = {-1:0}\\n        \\n        # split up the string so that each file/directory (token) is an\\n        # entry in the list; this preserves the tabs in each entry\\n        for token in input.split(\\'\\\\n\\'):\\n            # the 0-indexed level of this token is the number of tabs\\n\\t\\t\\t\\'\\'\\' only tabs contribute to the level; spaces are regular characters\\'\\'\\'\\n            level = token.count(\\'\\\\t\\')\\n            \\n            # update the current level to be the length of the path\\n            # through the previous level + length of this token;\\n            # subtracting the level removes the tabs from the count\\n            #\\n            # think of this like reading through the structure with your eyes\\n            # from top to bottom; for each token you look at on a new line,\\n            # you update the line\\'s level to be the path through the current token,\\n            # disregarding the remainder.  we never \"look back up\" when reading\\n            # the directory from top to bottom, and the string structure is\\n            # given to be consistent, so one pass updates the levels as deisred\\n            levels[level] = levels[level - 1] + len(token) - level\\n            \\n            # if we just processed a filename, overwrite the maximum length\\n            # if the current path + the number of backslashes is longer;\\n            # we store the raw token lengths without any separator,\\n            # so adding the 0-indexed level provides the correct number\\n            # of separators; if there is 1 item, the level is 0 (so no \\'/\\'),\\n            # if there are two items, the level is 1 (so one \\'/\\' between\\n            # the items) and so on\\n            if \\'.\\' in token:\\n                maxlen = max(maxlen, levels[level] + level)\\n\\n        return maxlen\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        # return value\\n        maxlen = 0\\n        \\n        # map each level (0-indexed) to the current\\n        # maximum path length through that level;\\n        #\\n        # begin with a \"-1 level\" of 0 length, to simply\\n        # index the \"level before the 0th level\", which\\n        # is a common practice in dynamic programming\\n        levels = {-1:0}\\n        \\n        # split up the string so that each file/directory (token) is an\\n        # entry in the list; this preserves the tabs in each entry\\n        for token in input.split(\\'\\\\n\\'):\\n            # the 0-indexed level of this token is the number of tabs\\n\\t\\t\\t\\'\\'\\' only tabs contribute to the level; spaces are regular characters\\'\\'\\'\\n            level = token.count(\\'\\\\t\\')\\n            \\n            # update the current level to be the length of the path\\n            # through the previous level + length of this token;\\n            # subtracting the level removes the tabs from the count\\n            #\\n            # think of this like reading through the structure with your eyes\\n            # from top to bottom; for each token you look at on a new line,\\n            # you update the line\\'s level to be the path through the current token,\\n            # disregarding the remainder.  we never \"look back up\" when reading\\n            # the directory from top to bottom, and the string structure is\\n            # given to be consistent, so one pass updates the levels as deisred\\n            levels[level] = levels[level - 1] + len(token) - level\\n            \\n            # if we just processed a filename, overwrite the maximum length\\n            # if the current path + the number of backslashes is longer;\\n            # we store the raw token lengths without any separator,\\n            # so adding the 0-indexed level provides the correct number\\n            # of separators; if there is 1 item, the level is 0 (so no \\'/\\'),\\n            # if there are two items, the level is 1 (so one \\'/\\' between\\n            # the items) and so on\\n            if \\'.\\' in token:\\n                maxlen = max(maxlen, levels[level] + level)\\n\\n        return maxlen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86793,
                "title": "very-concise-5-liner-in-python-52ms",
                "content": "Split the string using '\\\\n' to get all directories and files. For each item, the number of '\\\\t' is how deep the item is.\\n\\nList slice assignment is our good friend to build the whole path.\\n\\nThanks to @StefanPochmann , I have corrected the time complexity of the code. Here is the O(n) version:\\n```\\nclass Solution(object):\\n    def lengthLongestPath(self, input):\\n        path, maxLen = [], 0\\n        for s in input.split('\\\\n'):\\n            path[s.count('\\\\t'):] = [len(s.strip('\\\\t'))]\\n            maxLen = max(maxLen, sum(path)+len(path)-1 if '.' in s else 0)\\n        return maxLen\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def lengthLongestPath(self, input):\\n        path, maxLen = [], 0\\n        for s in input.split('\\\\n'):\\n            path[s.count('\\\\t'):] = [len(s.strip('\\\\t'))]\\n            maxLen = max(maxLen, sum(path)+len(path)-1 if '.' in s else 0)\\n        return maxLen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86729,
                "title": "very-concise-c-solution-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        if (input.empty()) return 0;\\n \\n        vector<int> depLen;\\n        int result = 0, count = 0, depth = 0, isDir = 1;\\n        \\n        for (int i = 0; i < input.length() + 1; ++i) {\\n            switch (input[i]) {\\n                /* No need for extra code after whole loop */\\n                case '\\\\0':\\n                case '\\\\n':\\n                    count = !depth ? count + isDir : depLen[depth - 1] + count + isDir;\\n                    if (depLen.size() > depth) depLen[depth] = count;\\n                    else depLen.push_back(count);\\n\\n                    if (!isDir) result = count > result ? count : result;\\n\\n                    depth = count = 0;\\n                    isDir = 1;\\n                    break;\\n                case '\\\\t':\\n                    ++depth;\\n                    break;\\n                case '.':\\n                    isDir = 0;\\n                default:\\n                    ++count;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        if (input.empty()) return 0;\\n \\n        vector<int> depLen;\\n        int result = 0, count = 0, depth = 0, isDir = 1;\\n        \\n        for (int i = 0; i < input.length() + 1; ++i) {\\n            switch (input[i]) {\\n                /* No need for extra code after whole loop */\\n                case '\\\\0':\\n                case '\\\\n':\\n                    count = !depth ? count + isDir : depLen[depth - 1] + count + isDir;\\n                    if (depLen.size() > depth) depLen[depth] = count;\\n                    else depLen.push_back(count);\\n\\n                    if (!isDir) result = count > result ? count : result;\\n\\n                    depth = count = 0;\\n                    isDir = 1;\\n                    break;\\n                case '\\\\t':\\n                    ++depth;\\n                    break;\\n                case '.':\\n                    isDir = 0;\\n                default:\\n                    ++count;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 444530,
                "title": "javascript-solution",
                "content": "I think this quesiton has one of worst, if not the worst, test sets across leetcode.\\n### The idea\\n1. The only things we care about are the depth/level of the current dir , and the length for current dir/file, we can store these information as an array\\n2. The depth can be calculated by counting `\\\\t` in the currendir/file\\n``` javascript\\n/**\\n * @param {string} input\\n * @return {number}\\n */\\nvar lengthLongestPath = function(input) {\\n    let dir = input.split(\\'\\\\n\\');\\n    let max = 0;\\n    let length = [];\\n    let depth= 0;\\n    for (let i=0;i<dir.length;i++) {\\n        depth = dir[i].lastIndexOf(\\'\\\\t\\')+1;\\n        if (dir[i].includes(\\'.\\')) {\\n            let fileLength = dir[i].length-depth;\\n            max = Math.max((length[depth-1]+1||0) + fileLength , max);\\n        } else {\\n            length[depth] = dir[i].length - depth + (length[depth-1]+1||0);\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {string} input\\n * @return {number}\\n */\\nvar lengthLongestPath = function(input) {\\n    let dir = input.split(\\'\\\\n\\');\\n    let max = 0;\\n    let length = [];\\n    let depth= 0;\\n    for (let i=0;i<dir.length;i++) {\\n        depth = dir[i].lastIndexOf(\\'\\\\t\\')+1;\\n        if (dir[i].includes(\\'.\\')) {\\n            let fileLength = dir[i].length-depth;\\n            max = Math.max((length[depth-1]+1||0) + fileLength , max);\\n        } else {\\n            length[depth] = dir[i].length - depth + (length[depth-1]+1||0);\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 86761,
                "title": "if-you-re-getting-valueerror-unterminated-string-here-s-why",
                "content": "If you're getting something like this\\n```\\nLine 42: ValueError: Unterminated string starting at: line 1 column 1 (char 0)\\n```\\nwhen clicking `Run Code`, LeetCode OJ has a problem.  Open up the the Custom Testcase, and you'll see that OJ has converted `\\\\n` and `\\\\t` into whitespace, which is mucking things up.  Copy-paste the strings in the statement of the problem in, and it'll work.",
                "solutionTags": [],
                "code": "```\\nLine 42: ValueError: Unterminated string starting at: line 1 column 1 (char 0)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1698271,
                "title": "java-o-n-d-solution-faster-than-90",
                "content": "```\\n    public int lengthLongestPath(String input) {\\n        String[] paths = input.split(\"\\\\n\");\\n        int[] levels = new int[paths.length + 1];\\n        levels[0] = -1;\\n        int maxLength = 0;\\n        for (String path : paths) {\\n            String name = path;\\n            int level = 1;\\n            while (name.startsWith(\"\\\\t\")) {\\n                name = name.substring(1);\\n                level++;\\n            }\\n            int newLength = levels[level - 1] + name.length() + 1;\\n            if (name.contains(\".\")) {\\n                maxLength = Math.max(maxLength, newLength);\\n            } else {\\n                levels[level] = newLength;\\n            }\\n        }\\n        return maxLength;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int lengthLongestPath(String input) {\\n        String[] paths = input.split(\"\\\\n\");\\n        int[] levels = new int[paths.length + 1];\\n        levels[0] = -1;\\n        int maxLength = 0;\\n        for (String path : paths) {\\n            String name = path;\\n            int level = 1;\\n            while (name.startsWith(\"\\\\t\")) {\\n                name = name.substring(1);\\n                level++;\\n            }\\n            int newLength = levels[level - 1] + name.length() + 1;\\n            if (name.contains(\".\")) {\\n                maxLength = Math.max(maxLength, newLength);\\n            } else {\\n                levels[level] = newLength;\\n            }\\n        }\\n        return maxLength;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 245601,
                "title": "java-beats-99-uses-array",
                "content": "Hi! When I read this problem the first thing that came to my mind was tree!\\nI thought we have to construct a tree, and do dfs, and calculate the length of each path and if its a leaf consider it to see if its a max path!\\nHowever, infact, there was an easier solution. because of the very specific form of this input we can use an array, and there\\'s no need of dfs.\\nAll we want for each directory or file is their length of path. We need it not just for files to consider the max, but for directories too, so that a dirs child-files can calculate their path lengths based on it!\\nMeanwhile we don\\'t have to save anything but the length of path of the last thing on each level! Why? if I am a file in level three, for example, my parent dir is the last seen parent in level two! because I come right after it, there is no way I might need the path length of things we have seen before on level two, their children have been processed already, because its a preorder traversal of the tree. :D\\nThats why array lens come into play! We are keeping the length of the current(most recent) parents on each level! so a child file/dir can calculate their path length based on them.\\nPlease consider \\\\t is tab and is considered as one character! I was totally confused by this fact \\':)\\n \\n```\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        String [] arr=input.split(\"\\\\n\");\\n        int [] lens= new int[arr.length];\\n       \\n        int max=0;\\n        for(String s:arr){\\n            int lastBackT= s.lastIndexOf(\"\\\\t\");\\n            int level = lastBackT+1; \\n            int parentLen = level==0? 0: lens[level-1]+1;\\n            int nameLen = s.length()-lastBackT-1;\\n            lens[level] = parentLen+nameLen;\\n            if(s.contains(\".\"))\\n            {\\n                max = Math.max(max,lens[level]);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int lengthLongestPath(String input) {\\n        String [] arr=input.split(\"\\\\n\");\\n        int [] lens= new int[arr.length];\\n       \\n        int max=0;\\n        for(String s:arr){\\n            int lastBackT= s.lastIndexOf(\"\\\\t\");\\n            int level = lastBackT+1; \\n            int parentLen = level==0? 0: lens[level-1]+1;\\n            int nameLen = s.length()-lastBackT-1;\\n            lens[level] = parentLen+nameLen;\\n            if(s.contains(\".\"))\\n            {\\n                max = Math.max(max,lens[level]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3254721,
                "title": "388-time-100-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. First, we split the input string s into individual paths using the newline character \\\\n as the delimiter. We store these paths in the paths list.\\n\\n2. Next, we initialize a stack with a single value of 0. We use this to keep track of the length of each directory path in the file system.\\n\\n3. We also initialize the variable ans to 0, which we will use to store the length of the longest absolute path to a file.\\n\\n4. For each path in the paths list, we split it into a list of directory and file names using the tab character \\\\t as the delimiter. The last element in this list is the name of the file or directory.\\n\\n5. We determine the depth of the current path by subtracting 1 from the length of the directory list.\\n\\n6. We then check if the current path is a file or a directory. If it\\'s a file (i.e., it contains a period), we update the ans variable by taking the maximum of its current value and the length of the current directory path in the stack (i.e., stack[-1]) plus the length of the file name.\\n\\n7. If the current path is a directory, we push its length onto the stack. We calculate this length by adding the length of the directory name plus 1 (for the forward slash separator).\\n\\n8. Before processing the next path, we check if there are any directories in the stack that are deeper than the current directory. If so, we pop them off the stack.\\n\\n9. Finally, we return the ans variable, which contains the length of the longest absolute path to a file in the file system.\\n\\n# Complexity\\n- Time complexity:\\n100%\\n\\n- Space complexity:\\n63.3%\\n\\n# Code\\n```\\nclass Solution:\\n    def lengthLongestPath(self, s: str) -> int:\\n        paths = s.split(\\'\\\\n\\')\\n        stack, ans = [0], 0 # initialize the stack with 0 to handle the case when there\\'s no directory\\n        for path in paths:\\n            p = path.split(\\'\\\\t\\')\\n            depth, name = len(p) - 1, p[-1]\\n            while len(stack) > depth + 1: # pop directories that are deeper than the current one\\n                stack.pop()\\n            if \\'.\\' in name: # if it\\'s a file, update the answer\\n                ans = max(ans, stack[-1] + len(name))\\n            else: # if it\\'s a directory, push its length to the stack\\n                stack.append(stack[-1] + len(name) + 1)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def lengthLongestPath(self, s: str) -> int:\\n        paths = s.split(\\'\\\\n\\')\\n        stack, ans = [0], 0 # initialize the stack with 0 to handle the case when there\\'s no directory\\n        for path in paths:\\n            p = path.split(\\'\\\\t\\')\\n            depth, name = len(p) - 1, p[-1]\\n            while len(stack) > depth + 1: # pop directories that are deeper than the current one\\n                stack.pop()\\n            if \\'.\\' in name: # if it\\'s a file, update the answer\\n                ans = max(ans, stack[-1] + len(name))\\n            else: # if it\\'s a directory, push its length to the stack\\n                stack.append(stack[-1] + len(name) + 1)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737090,
                "title": "a-fast-simple-and-detailed-solution-using-deque",
                "content": "`len` will keep track of the length of the directory or file name, `level` will track depth. \\n\\nWhenever we encounter a `\\\\n` character, we know the directory name has ended so we can push the length of the directory to our deque, it will only store the hierarchy we are working in so if `level` is less than size(depth) of deque we can pop the values as we no longer need them.\\n\\nFinally, when a `.` character is encountered, we know it\\'s a file so we can try it as result by summing all directory names from deque and we will add `level` to the final result to make up for `/` and `len` for the current file name.\\n```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        deque<int> dq;\\n        int len = 0, res = 0, level = 0;\\n        bool file = false;\\n        for(char c: input){\\n            if(c == \\'\\\\n\\'){\\n                dq.push_back(len);\\n                level = len = file = 0;\\n            }\\n            else if(c == \\'\\\\t\\') ++level;\\n            else if(c == \\'.\\') ++len, file = true;\\n            else{\\n                ++len;\\n                if(file) res = max(res, len + accumulate(dq.begin(), dq.end(), 0) + level);\\n                while(level < dq.size()){\\n                    dq.pop_back();\\n                }\\n            }\\n        }        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        deque<int> dq;\\n        int len = 0, res = 0, level = 0;\\n        bool file = false;\\n        for(char c: input){\\n            if(c == \\'\\\\n\\'){\\n                dq.push_back(len);\\n                level = len = file = 0;\\n            }\\n            else if(c == \\'\\\\t\\') ++level;\\n            else if(c == \\'.\\') ++len, file = true;\\n            else{\\n                ++len;\\n                if(file) res = max(res, len + accumulate(dq.begin(), dq.end(), 0) + level);\\n                while(level < dq.size()){\\n                    dq.pop_back();\\n                }\\n            }\\n        }        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511985,
                "title": "c-stack-faster-than-100-00",
                "content": "time: O(n), space: O(d)\\n* \\tn: the length of the input string\\n* \\td: the depth of the filesystem described in the input string\\n\\n```\\nstruct pathData {\\n    int totalLen;\\n    int depth;\\n    pathData(int t, int d) : totalLen(t), depth(d) {}\\n};\\n\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        \\n        // Because the filesystem is hierarchial structure in nature,\\n        // I decide to use a stack to help me traverse through every\\n        // subdirectory and file. \\n        // Once I decide to do push, I push two pieces of information.\\n        // 1. the total length of the absolute path to the current subdirectory, including the parent directory and \\'/\\'.\\n        //    In this question, the file names and directory names are not important, but their lengths.\\n        // 2. the depth of the current subdirectory (i.e. the number of \\'\\\\t\\' before each file or directory name).\\n        // I also defined the pathData structure to make my code more readable.\\n        stack<pathData> filesys;\\n        int i = 0, answer = 0;\\n        \\n        while (i < input.size()) {\\n            int fileDirLen = 0, depth = 0;\\n            bool isFile = false;\\n            \\n            // Based upon the description and constrains, \\'\\\\n\\' implies the end of the name of a file or directory.\\n            // Also, the number of \\'\\\\t\\' implies the depth of a file or subdirectory.\\n            // Other characters (\\'\\\\t\\', \\'.\\', \\' \\', and digits) are for the name of a file or directory.\\n            // Keep this idea in mind and this question becomes much more easier.\\n            \\n            // Count the number of \\'\\\\t\\' to know the depth of the following directory or file.\\n            while (i < input.size() && input[i] == \\'\\\\t\\') {\\n                ++depth;\\n                ++i;\\n            } // end of while-loop\\n            \\n            // At this moment, i points to the first character of a file name or directory name.\\n            \\n            // Count the length of file name or directory name.\\n            // Also decide whether this is a directory or a file.\\n            while (i < input.size() && input[i] != \\'\\\\n\\') {\\n                ++fileDirLen;\\n                if (input[i] == \\'.\\') {\\n                    // Becase I find a \\'.\\', this is a file.\\n                    isFile = true;\\n                }\\n                ++i;\\n            } // end of while-loop\\n            \\n            // At this moment, i points to the \\'\\\\n\\' right after the file or directory I have\\n            // parsed in the secnod inner while-loop.\\n            \\n            // Skip the \\'\\\\n\\' and let i point to \\'\\\\t\\'.\\n            // In next iteration of the outer while-loop, I can decide the depth of next directory or file\\n            // by counting the number of \\'\\\\t\\', which is the job of the first inner while-loop.\\n            ++i;\\n            \\n            // If the depth on the top of the stack (filesys) is greater than or equal to that of \\n            // current directory or file, do pop until the stack is empty or the top of the stack\\n            // have less depth.\\n            while (!filesys.empty() && filesys.top().depth >= depth) {\\n                filesys.pop();\\n            }\\n            \\n            if (isFile == false) {\\n                // This is a directory append a \\'/\\'. \\n                ++fileDirLen;\\n            }\\n            \\n            if (filesys.empty()) {\\n                // The stack (filesys) is empty.\\n                // Just push the two pieces of information.\\n                filesys.push({fileDirLen, depth});\\n            } else {\\n                // The stack (filesys) is not empty.\\n                // Accumulate the length of the absolute path and do push.\\n                filesys.push({filesys.top().totalLen + fileDirLen, depth});\\n            }\\n            \\n            if (isFile == true) {\\n                // This is a file.\\n                // Try to find the longest absolute file path.\\n                answer = max(answer, filesys.top().totalLen);\\n            }\\n        } // end of while-loop\\n        \\n        return answer;\\n    }\\n};\\n```\\n\\nI hope my solution and comment help you have a good understanding of this question. Good luck!",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nstruct pathData {\\n    int totalLen;\\n    int depth;\\n    pathData(int t, int d) : totalLen(t), depth(d) {}\\n};\\n\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        \\n        // Because the filesystem is hierarchial structure in nature,\\n        // I decide to use a stack to help me traverse through every\\n        // subdirectory and file. \\n        // Once I decide to do push, I push two pieces of information.\\n        // 1. the total length of the absolute path to the current subdirectory, including the parent directory and \\'/\\'.\\n        //    In this question, the file names and directory names are not important, but their lengths.\\n        // 2. the depth of the current subdirectory (i.e. the number of \\'\\\\t\\' before each file or directory name).\\n        // I also defined the pathData structure to make my code more readable.\\n        stack<pathData> filesys;\\n        int i = 0, answer = 0;\\n        \\n        while (i < input.size()) {\\n            int fileDirLen = 0, depth = 0;\\n            bool isFile = false;\\n            \\n            // Based upon the description and constrains, \\'\\\\n\\' implies the end of the name of a file or directory.\\n            // Also, the number of \\'\\\\t\\' implies the depth of a file or subdirectory.\\n            // Other characters (\\'\\\\t\\', \\'.\\', \\' \\', and digits) are for the name of a file or directory.\\n            // Keep this idea in mind and this question becomes much more easier.\\n            \\n            // Count the number of \\'\\\\t\\' to know the depth of the following directory or file.\\n            while (i < input.size() && input[i] == \\'\\\\t\\') {\\n                ++depth;\\n                ++i;\\n            } // end of while-loop\\n            \\n            // At this moment, i points to the first character of a file name or directory name.\\n            \\n            // Count the length of file name or directory name.\\n            // Also decide whether this is a directory or a file.\\n            while (i < input.size() && input[i] != \\'\\\\n\\') {\\n                ++fileDirLen;\\n                if (input[i] == \\'.\\') {\\n                    // Becase I find a \\'.\\', this is a file.\\n                    isFile = true;\\n                }\\n                ++i;\\n            } // end of while-loop\\n            \\n            // At this moment, i points to the \\'\\\\n\\' right after the file or directory I have\\n            // parsed in the secnod inner while-loop.\\n            \\n            // Skip the \\'\\\\n\\' and let i point to \\'\\\\t\\'.\\n            // In next iteration of the outer while-loop, I can decide the depth of next directory or file\\n            // by counting the number of \\'\\\\t\\', which is the job of the first inner while-loop.\\n            ++i;\\n            \\n            // If the depth on the top of the stack (filesys) is greater than or equal to that of \\n            // current directory or file, do pop until the stack is empty or the top of the stack\\n            // have less depth.\\n            while (!filesys.empty() && filesys.top().depth >= depth) {\\n                filesys.pop();\\n            }\\n            \\n            if (isFile == false) {\\n                // This is a directory append a \\'/\\'. \\n                ++fileDirLen;\\n            }\\n            \\n            if (filesys.empty()) {\\n                // The stack (filesys) is empty.\\n                // Just push the two pieces of information.\\n                filesys.push({fileDirLen, depth});\\n            } else {\\n                // The stack (filesys) is not empty.\\n                // Accumulate the length of the absolute path and do push.\\n                filesys.push({filesys.top().totalLen + fileDirLen, depth});\\n            }\\n            \\n            if (isFile == true) {\\n                // This is a file.\\n                // Try to find the longest absolute file path.\\n                answer = max(answer, filesys.top().totalLen);\\n            }\\n        } // end of while-loop\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143026,
                "title": "java-0ms-100-solution-use-a-list-to-record-levels-and-their-lengths",
                "content": "First we split the input with `\\'\\\\n\\'`, then for each line we use how many` \\'\\\\t\\'` in it as its level. \\n\\nUse a list to store the length of each level, if one line contains a` \\'.\\'`, that means its a file, we can easily comupter its absolute path because we have all the length of its directory.\\n\\n```\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        int res = 0;\\n        List<Integer> list = new ArrayList<>();\\n        String[] path = input.split(\"\\\\n\");\\n        for (String s : path) {\\n            if (s.isEmpty()) continue;\\n            int level = 0;\\n            while (s.charAt(level) == \\'\\\\t\\') level++;\\n            if (list.size() <= level) {\\n                list.add(s.substring(level).length());\\n            } else {\\n                list.set(level, s.substring(level).length()); \\n            }\\n            if (s.indexOf(\\'.\\') != -1) {\\n                int sum = 0;\\n                for (int i = 0; i <= level; i++) {\\n                    sum += list.get(i);\\n                }\\n                res = Math.max(res, sum + level);  // the number of backslashes == level \\n            }            \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        int res = 0;\\n        List<Integer> list = new ArrayList<>();\\n        String[] path = input.split(\"\\\\n\");\\n        for (String s : path) {\\n            if (s.isEmpty()) continue;\\n            int level = 0;\\n            while (s.charAt(level) == \\'\\\\t\\') level++;\\n            if (list.size() <= level) {\\n                list.add(s.substring(level).length());\\n            } else {\\n                list.set(level, s.substring(level).length()); \\n            }\\n            if (s.indexOf(\\'.\\') != -1) {\\n                int sum = 0;\\n                for (int i = 0; i <= level; i++) {\\n                    sum += list.get(i);\\n                }\\n                res = Math.max(res, sum + level);  // the number of backslashes == level \\n            }            \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030886,
                "title": "javascript-simple-hashmap",
                "content": "```javascript\\nvar lengthLongestPath = function(input) {\\n    const map = {};\\n    let maxLen = 0;\\n    \\n    for(let line of input.split(\\'\\\\n\\')) {\\n        const depth = (line.match(/\\\\t/g) || []).length;\\n        map[depth] = line.length - depth + (map[depth-1] || 0);\\n        if(/\\\\./.test(line)) maxLen = Math.max(maxLen, depth + map[depth]);\\n    }\\n    return maxLen;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar lengthLongestPath = function(input) {\\n    const map = {};\\n    let maxLen = 0;\\n    \\n    for(let line of input.split(\\'\\\\n\\')) {\\n        const depth = (line.match(/\\\\t/g) || []).length;\\n        map[depth] = line.length - depth + (map[depth-1] || 0);\\n        if(/\\\\./.test(line)) maxLen = Math.max(maxLen, depth + map[depth]);\\n    }\\n    return maxLen;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 86693,
                "title": "javascript-solution",
                "content": "```\\nvar lengthLongestPath = function(input) {\\n    let maxLength = 0;\\n    let pathLength = { 0: 0 }\\n    let lines = input.split(\"\\\\n\");\\n\\n    for (let i = 0; i < lines.length; i++) {\\n        let name = lines[i].replace(/\\\\t/g,\"\");\\n        let depth = lines[i].length - name.length;\\n\\n        if (name.includes(\".\")) {\\n            maxLength = Math.max(maxLength, pathLength[depth] + name.length);\\n        } else {\\n            pathLength[depth + 1] = pathLength[depth] + name.length + 1;\\n        }\\n    }\\n\\n    return maxLength;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar lengthLongestPath = function(input) {\\n    let maxLength = 0;\\n    let pathLength = { 0: 0 }\\n    let lines = input.split(\"\\\\n\");\\n\\n    for (let i = 0; i < lines.length; i++) {\\n        let name = lines[i].replace(/\\\\t/g,\"\");\\n        let depth = lines[i].length - name.length;\\n\\n        if (name.includes(\".\")) {\\n            maxLength = Math.max(maxLength, pathLength[depth] + name.length);\\n        } else {\\n            pathLength[depth + 1] = pathLength[depth] + name.length + 1;\\n        }\\n    }\\n\\n    return maxLength;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 489939,
                "title": "python3-easy-solution-using-a-dict",
                "content": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        max_len,ht = 0,{}\\n        for p in input.split(\"\\\\n\"):\\n            key=p.count(\"\\\\t\")\\n            if \".\" not in p:\\n                value = len(p.replace(\"\\\\t\",\"\"))\\n                ht[key]=value\\n            else:\\n                temp_len = key + len(p.replace(\"\\\\t\",\"\"))\\n                for ky in ht.keys():\\n                    if ky < key:\\n                        temp_len += ht[ky]\\n                max_len=max(max_len,temp_len)\\n        return max_len\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        max_len,ht = 0,{}\\n        for p in input.split(\"\\\\n\"):\\n            key=p.count(\"\\\\t\")\\n            if \".\" not in p:\\n                value = len(p.replace(\"\\\\t\",\"\"))\\n                ht[key]=value\\n            else:\\n                temp_len = key + len(p.replace(\"\\\\t\",\"\"))\\n                for ky in ht.keys():\\n                    if ky < key:\\n                        temp_len += ht[ky]\\n                max_len=max(max_len,temp_len)\\n        return max_len\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328592,
                "title": "python3-beats-99",
                "content": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        parts = input.split(\\'\\\\n\\')\\n        ans = 0\\n        stack = []\\n        L = 0\\n        for s in parts:\\n            cs = s.lstrip(\\'\\\\t\\')\\n            level = len(s) - len(cs)\\n            while stack and stack[-1][1] >= level:\\n                L -= len(stack.pop()[0])\\n            stack.append((cs, level))\\n            L += len(cs)\\n            if \".\" in cs:\\n                ans = max(ans, len(stack) + L - 1)\\n                \\n        return ans\\n                \\n            \\n            \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        parts = input.split(\\'\\\\n\\')\\n        ans = 0\\n        stack = []\\n        L = 0\\n        for s in parts:\\n            cs = s.lstrip(\\'\\\\t\\')\\n            level = len(s) - len(cs)\\n            while stack and stack[-1][1] >= level:\\n                L -= len(stack.pop()[0])\\n            stack.append((cs, level))\\n            L += len(cs)\\n            if \".\" in cs:\\n                ans = max(ans, len(stack) + L - 1)\\n                \\n        return ans\\n                \\n            \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 253936,
                "title": "explanation-and-comments-in-c-solution-100-beat-time",
                "content": "The idea is to break string \"dir\\\\n\\\\tsubdir1\\\\n\\\\t\\\\tfile1.ext\\\\n\\\\t\\\\tsubsubdir1\\\\n\\\\tsubdir2\\\\n\\\\t\\\\tsubsubdir2\\\\n\\\\t\\\\t\\\\tfile2.ext\" to:\\n\\ndir\\n->>>subdir1\\n->>>>>>file1.ext\\n->>>>>>subsubdir1\\n->>>subdir2\\n->>>>>>subsubdir2\\n->>>>>>>>>file2.ext\\n\\nAs you can see here is subdir1 and subdir2 is on same level. Subsubdir1 and subsubdir2 is on same level. We basically have to traverse it on level order to get to the max length. Now how do we detect level? Number of tabs can tell us the level. Subdir1 has one tab in front of it. So it is on level2. \\'dir\\' is on level1 and subdir2 is on level2 too. subsubdir1 and subsubdir2 has two tabs in front of it so it is on level3. \\n\\nNow when we will reach at subsubdir1 (level2) we will add the previous length which is level1 length and the character count in subsubdir. As soon as we detect \\'.\\' we know it is a file and hence we can update maximum length.\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    \\n\\tint lengthLongestPath(string input) {\\n       \\n        int len = input.size() ;            // Size of the input string\\n        int i = 0;                          // iterator to parse string\\n        bool is_file = false;                // If true then we detected a file, means a \\'.\\' has been seen\\n        int count_char = 0;                 // Count the \\'valid\\' character\\n        unordered_map<int, int> m;          // Keep track of the lengths on every level \\n                                        // Key is level and level length is value\\n        int level = 1;                      // level variable. Represents level.\\n        int maxlen = 0;                     // Keep track of final result;\\n        \\n        \\n        // Base condition (very obvious)\\n        if(len == 0){\\n            return 0;\\n        }\\n        \\n        \\n        while(i < len){\\n            \\n            // First we check the number of tabs encounter,\\n            // for each tab one level increases. Means dir is level 1, \\n            // after than one tab so subdir1 becomes level 2, subdir2 is also level2 but \\n            // subsubdir1 is level 3 as it has two tabs and so on.\\n            while(input[i] == \\'\\\\t\\'){\\n                level++;\\n                i++;\\n            }\\n            \\n            // Now check if the character is not \\'\\\\n\\', which means take all the valid character\\n            // as essentially it is giving you the directory or subdirectory name\\n            while(i < len && input[i] != \\'\\\\n\\'){\\n                \\n                // We gotta check if we encounter any \\'.\\' means any file.\\n                if(input[i] == \\'.\\'){\\n                    is_file = true;\\n                }\\n                \\n                count_char++;\\n                i++;\\n            }\\n            \\n            if(is_file){\\n                int t = m[level-1] + count_char;\\n               maxlen = max(maxlen, t);\\n            } else {\\n                m[level] = m[level-1] + count_char + 1;\\n            }\\n            \\n            is_file = false;\\n            count_char = 0;\\n            level = 1;\\n            \\n            i++;  // After we take care of \\\\t, this time i will be on \\\\n, so gotta increment by one\\n                \\n        }\\n        \\n        return maxlen;   \\n    }\\n};\\n\\'\\'\\'\\n\\t\\t\\t",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n\\tint lengthLongestPath(string input) {\\n       \\n        int len = input.size() ;            // Size of the input string\\n        int i = 0;                          // iterator to parse string\\n        bool is_file = false;                // If true then we detected a file, means a \\'.\\' has been seen\\n        int count_char = 0;                 // Count the \\'valid\\' character\\n        unordered_map<int, int> m;          // Keep track of the lengths on every level \\n                                        // Key is level and level length is value\\n        int level = 1;                      // level variable. Represents level.\\n        int maxlen = 0;                     // Keep track of final result;\\n        \\n        \\n        // Base condition (very obvious)\\n        if(len == 0){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 86712,
                "title": "4-line-10-line-concise-c-o-n-solution-with-stringstream-detailed-explanation",
                "content": "Many similar solutions with stack have been posted, and here I added mine with the basic idea and comments in code. As usual, I did not pursuit to solve the problem with fewest lines of code possible but make it as readable as possible.\\n\\nTo solve the problem, there are following observations which I think are the keys:\\n* Obviously, all entries (directories and files) in the file system can be identified by splitting the input string with delimiter ```'\\\\n'```, i.e., each line is the name of a new entry.\\n* The level of each entry can be identified by how many consecutive ```\\\\t``` are leading the entry's name, assuming root directors and files have level 0.\\n* Once an entry's level is smaller than previous entry's level, it means that any entries above the current entry with greater or equal value of levels have finished their content representation, i.e., any following entries will not be possible to belong to those entries above (so their path information won't be needed for following entries).\\n* For any valid input string, the level increment has to be consecutive while decrement could be arbitrary.\\n\\nWith these observations, a stack to keep the record of the path lengths of all nested parent directories leading to current entry will naturally come to play. Note that the size of the stack is exactly the level of the current entry.\\n\\nThe time complexity estimate is also interesting. Even though there is the outer loop for the input string `O(N)`, we have to break down into the time each time we enter the loop. Actually, each time we process an entry, the time cost is just `O(L)`, where L is the length of this particular entry. So overall time complexity will be just `O(N)`. `O(N^2)` is the wrong \"too conservative\" estimate if just naively looking at the loop.\\n```\\n    int lengthLongestPath(string input) {\\n      stringstream ss(input);\\n      stack<int> parentLen; // path length of parent folders to current entry\\n      int lev, maxL = 0;    // level, length of longest file path\\n      for (string s; getline(ss, s, '\\\\n');) \\n      {\\n        int curLen = s.length()-(lev = s.rfind('\\\\t')+1); // length and level of current entry\\n        while (parentLen.size() > lev) parentLen.pop(); // find length of parent directory\\n        if (!parentLen.empty()) curLen += 1+parentLen.top(); // attach parent path, 1 for '\\\\'\\n        if (s.rfind('.') < s.size()) maxL = max(maxL, curLen); // update path length if file\\n        else parentLen.push(curLen); // record current entry path length if directory\\n      }\\n      return maxL;\\n    }\\n```\\nWith the advantage of the random accessibility of `unordered_map` by key, here is a more compact 4-line solution: \\n```\\n    int lengthLongestPath(string input) {\\n      int lev, maxL = 0; stringstream ss(input); unordered_map<int,int> L;    \\n      for(string s; getline(ss,s,'\\\\n'); maxL = max(maxL,(s.find('.')<s.size())*L[lev+1]-1))\\n        L[(lev = s.rfind('\\\\t')+1)+1] = L[lev]+s.size()-lev+1;\\n      return maxL;      \\n    }\\n```\\nOne can also achieve this version using an array.",
                "solutionTags": [
                    "String",
                    "Stack"
                ],
                "code": "```'\\\\n'```\n```\\\\t```\n```\\n    int lengthLongestPath(string input) {\\n      stringstream ss(input);\\n      stack<int> parentLen; // path length of parent folders to current entry\\n      int lev, maxL = 0;    // level, length of longest file path\\n      for (string s; getline(ss, s, '\\\\n');) \\n      {\\n        int curLen = s.length()-(lev = s.rfind('\\\\t')+1); // length and level of current entry\\n        while (parentLen.size() > lev) parentLen.pop(); // find length of parent directory\\n        if (!parentLen.empty()) curLen += 1+parentLen.top(); // attach parent path, 1 for '\\\\'\\n        if (s.rfind('.') < s.size()) maxL = max(maxL, curLen); // update path length if file\\n        else parentLen.push(curLen); // record current entry path length if directory\\n      }\\n      return maxL;\\n    }\\n```\n```\\n    int lengthLongestPath(string input) {\\n      int lev, maxL = 0; stringstream ss(input); unordered_map<int,int> L;    \\n      for(string s; getline(ss,s,'\\\\n'); maxL = max(maxL,(s.find('.')<s.size())*L[lev+1]-1))\\n        L[(lev = s.rfind('\\\\t')+1)+1] = L[lev]+s.size()-lev+1;\\n      return maxL;      \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 86767,
                "title": "8-line-javascript-solution-with-stack",
                "content": "Basically keep length of each parent level in stack and only update result when there is a '.' in current level of path.\\n\\n```js\\nfunction lengthLongestPath(input) {\\n\\tvar stack = [];\\n\\n\\treturn input.split('\\\\n').reduce((max, p) => {\\n\\t\\tvar level = p.lastIndexOf('\\\\t') + 1;\\n\\t\\tstack[level] = p.length - level + (level ? stack[level - 1] : 0);\\n\\t\\treturn p.indexOf('.') === -1 ? max : Math.max(max, stack[level] + level);\\n\\t}, 0);\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction lengthLongestPath(input) {\\n\\tvar stack = [];\\n\\n\\treturn input.split('\\\\n').reduce((max, p) => {\\n\\t\\tvar level = p.lastIndexOf('\\\\t') + 1;\\n\\t\\tstack[level] = p.length - level + (level ? stack[level - 1] : 0);\\n\\t\\treturn p.indexOf('.') === -1 ? max : Math.max(max, stack[level] + level);\\n\\t}, 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3480427,
                "title": "runs-100-faster-c-stack-concise-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string str) {\\n        \\n        int maxi = 0;\\n        stack<pair<int,int>> st;\\n        int ind = 0;\\n        int n = str.size();\\n        stringstream data(str);\\n        string temp;\\n        while(getline(data,temp,\\'\\\\n\\')){\\n            int i = 0;\\n            while(temp[i]==\\'\\\\t\\'){\\n                i++;\\n            }\\n            int num = i;\\n            while(!st.empty() and st.top().first>=num){\\n                st.pop();\\n            }\\n            int prev = 0;\\n            if(!st.empty()) prev = st.top().second+1;\\n            int curr = temp.size()-num;\\n            auto found = temp.find(\\'.\\');\\n            if (found!=std::string::npos){\\n                maxi = max(maxi,prev+curr);\\n            }\\n            st.push({num,prev+curr});\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string str) {\\n        \\n        int maxi = 0;\\n        stack<pair<int,int>> st;\\n        int ind = 0;\\n        int n = str.size();\\n        stringstream data(str);\\n        string temp;\\n        while(getline(data,temp,\\'\\\\n\\')){\\n            int i = 0;\\n            while(temp[i]==\\'\\\\t\\'){\\n                i++;\\n            }\\n            int num = i;\\n            while(!st.empty() and st.top().first>=num){\\n                st.pop();\\n            }\\n            int prev = 0;\\n            if(!st.empty()) prev = st.top().second+1;\\n            int curr = temp.size()-num;\\n            auto found = temp.find(\\'.\\');\\n            if (found!=std::string::npos){\\n                maxi = max(maxi,prev+curr);\\n            }\\n            st.push({num,prev+curr});\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672250,
                "title": "c-easy-to-understand-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int lengthLongestPath(string input){\\n\\t\\t stringstream ss(input);\\n         string data;\\n         \\n         unordered_map<int,int>len;\\n         int res = 0;\\n\\t\\t \\n         while(getline(ss, data, \\'\\\\n\\'))\\n         {\\n             int numTabs  = 0; \\n\\t\\t\\t \\n             while(data[numTabs] == \\'\\\\t\\') numTabs++;\\n\\t\\t\\t \\n             if(numTabs == 0)\\n                 len[numTabs] = data.size(); \\n             else {\\n                 len[numTabs] = len[numTabs - 1] + 1 + data.substr(numTabs).size(); \\n\\t\\t\\t }\\n              if(data.find(\\'.\\') != string :: npos)\\n                 res = max(res, len[numTabs]);\\n         }\\n\\t\\t \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int lengthLongestPath(string input){\\n\\t\\t stringstream ss(input);\\n         string data;\\n         \\n         unordered_map<int,int>len;\\n         int res = 0;\\n\\t\\t \\n         while(getline(ss, data, \\'\\\\n\\'))\\n         {\\n             int numTabs  = 0; \\n\\t\\t\\t \\n             while(data[numTabs] == \\'\\\\t\\') numTabs++;\\n\\t\\t\\t \\n             if(numTabs == 0)\\n                 len[numTabs] = data.size(); \\n             else {\\n                 len[numTabs] = len[numTabs - 1] + 1 + data.substr(numTabs).size(); \\n\\t\\t\\t }\\n              if(data.find(\\'.\\') != string :: npos)\\n                 res = max(res, len[numTabs]);\\n         }\\n\\t\\t \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497769,
                "title": "simple-java-1ms-solution",
                "content": "Simple Java 1ms solution, taking inspiration from https://leetcode.com/problems/longest-absolute-file-path/discuss/86615/9-lines-4ms-Java-solution\\n\\n```\\npublic int lengthLongestPath(String input) {\\n        String[] paths = input.split(\"\\\\n\");\\n        int[] deque = new int[paths.length];\\n        int maxLen = 0;\\n        for(String path: paths){\\n            int lev = path.lastIndexOf(\"\\\\t\")+1;\\n            deque[lev] = (lev>0)?deque[lev-1]+1+path.length()-lev:path.length();\\n            if(path.contains(\".\")) maxLen = Math.max(maxLen, deque[lev]);\\n        }\\n        return maxLen;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int lengthLongestPath(String input) {\\n        String[] paths = input.split(\"\\\\n\");\\n        int[] deque = new int[paths.length];\\n        int maxLen = 0;\\n        for(String path: paths){\\n            int lev = path.lastIndexOf(\"\\\\t\")+1;\\n            deque[lev] = (lev>0)?deque[lev-1]+1+path.length()-lev:path.length();\\n            if(path.contains(\".\")) maxLen = Math.max(maxLen, deque[lev]);\\n        }\\n        return maxLen;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1158025,
                "title": "c-solution-easy-to-understand-hash-map-faster-than-100-submissions",
                "content": "\\n\\tint max(int a, int b){\\n        if(a > b){\\n            return a;\\n        }\\n        return b;\\n    }\\n    \\n    int lengthLongestPath(string input) {\\n        stringstream ss(input);\\n        \\n        string curr;\\n        int ans = 0;\\n        \\n        unordered_map<int,int> pathLength; //to store the path length of every level\\n\\t\\t\\n        //split the string at evert \"\\\\n\".\\n        while(getline(ss, curr, \\'\\\\n\\')){\\n            int level = curr.find_last_of(\"\\\\t\"); //find last occurence of \"\\\\t\" to knowing the current depth/level\\n            \\n            string currLevel = (level == string::npos) ? curr : curr.substr(level + 1); //eliminate \\'\\\\t\\' from the string\\n            //if a file exist in the current directory then calculate the length of the path\\n            if(currLevel.find(\\'.\\') != string::npos){\\n                ans = max(ans, pathLength[level - 1] + currLevel.length());\\n            }\\n\\t\\t\\t//else store the length up to the current level.\\n            else{\\n                pathLength[level] = pathLength[level - 1] + currLevel.length() + 1;//this plus one is for adding \"/\" after every directory.\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\tint max(int a, int b){\\n        if(a > b){\\n            return a;\\n        }\\n        return b;\\n    }\\n    \\n    int lengthLongestPath(string input) {\\n        stringstream ss(input);\\n        \\n        string curr;\\n        int ans = 0;\\n        \\n        unordered_map<int,int> pathLength; //to store the path length of every level\\n\\t\\t\\n        //split the string at evert \"\\\\n\".\\n        while(getline(ss, curr, \\'\\\\n\\')){\\n            int level = curr.find_last_of(\"\\\\t\"); //find last occurence of \"\\\\t\" to knowing the current depth/level\\n            \\n            string currLevel = (level == string::npos) ? curr : curr.substr(level + 1); //eliminate \\'\\\\t\\' from the string\\n            //if a file exist in the current directory then calculate the length of the path\\n            if(currLevel.find(\\'.\\') != string::npos){\\n                ans = max(ans, pathLength[level - 1] + currLevel.length());\\n            }\\n\\t\\t\\t//else store the length up to the current level.\\n            else{\\n                pathLength[level] = pathLength[level - 1] + currLevel.length() + 1;//this plus one is for adding \"/\" after every directory.\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1019781,
                "title": "java-stack-with-comment",
                "content": "```\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        //note: \\'\\\\t\\' counted as a single character in string\\n        \\n        Stack<Integer> stack = new Stack<>();               //stack containes cumulative lengths of every level\\n        stack.push(0);                                      // initial lenth of directory\\n        \\n        int maxLen = 0;\\n        for(String str: input.split(\"\\\\n\")) {\\n            int level = str.lastIndexOf(\"\\\\t\")+1;            //number of tab\\n            while(level+1 < stack.size()) {                 //go to previous directorry\\n                stack.pop();  \\n            }      \\n            \\n            int currLen = stack.peek()+str.length()-level+1;        //remove number of \\'\\\\t\\', add \\'/\\'\\n            stack.push(currLen);\\n            if(str.indexOf(\\'.\\') != -1) {                    //containes file with .extention\\n                maxLen = Math.max(maxLen, currLen-1);       //file level added an extra \\'/\\', thats why subtracted 1\\n            }\\n        }\\n        \\n        //System.out.println(\"\\\\t\".length());                  //length of tab(\\'\\\\t\\') is 1\\n        \\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        //note: \\'\\\\t\\' counted as a single character in string\\n        \\n        Stack<Integer> stack = new Stack<>();               //stack containes cumulative lengths of every level\\n        stack.push(0);                                      // initial lenth of directory\\n        \\n        int maxLen = 0;\\n        for(String str: input.split(\"\\\\n\")) {\\n            int level = str.lastIndexOf(\"\\\\t\")+1;            //number of tab\\n            while(level+1 < stack.size()) {                 //go to previous directorry\\n                stack.pop();  \\n            }      \\n            \\n            int currLen = stack.peek()+str.length()-level+1;        //remove number of \\'\\\\t\\', add \\'/\\'\\n            stack.push(currLen);\\n            if(str.indexOf(\\'.\\') != -1) {                    //containes file with .extention\\n                maxLen = Math.max(maxLen, currLen-1);       //file level added an extra \\'/\\', thats why subtracted 1\\n            }\\n        }\\n        \\n        //System.out.println(\"\\\\t\".length());                  //length of tab(\\'\\\\t\\') is 1\\n        \\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872796,
                "title": "python3-stack-solution",
                "content": "I think the important thing to note is that the filenames are given in *\\'sorted\\'* order so that if we go down a level, then all the next file/directories are going to be in the previous upper level - OR they will be at the same level as the previous node. And each separate path, can be extracted by splitting on `\\\\n`. \\n\\nThe stack is there to simulate the `cd` command basically. Whenever we see more tabs than the current stack depth, we `cd..` by doing `stack.pop()`. Then we add the current node name on stack, and if it is a file (contains `.`) then we take max of path length. Everything else should be self-explanatory:\\n\\n```\\nclass Solution:\\n    def lengthLongestPath(self, fs: str) -> int:\\n        stack = []\\n        ret = 0\\n        for path in fs.split(\\'\\\\n\\'):\\n            subs = len(path)-len(path.lstrip(\\'\\\\t\\'))\\n            while len(stack)>subs:\\n                stack.pop()\\n            stack.append(path.lstrip(\\'\\\\t\\'))\\n            if \\'.\\' in path:\\n                filename = \\'/\\'.join(stack)\\n                ret = max(ret,len(filename))\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lengthLongestPath(self, fs: str) -> int:\\n        stack = []\\n        ret = 0\\n        for path in fs.split(\\'\\\\n\\'):\\n            subs = len(path)-len(path.lstrip(\\'\\\\t\\'))\\n            while len(stack)>subs:\\n                stack.pop()\\n            stack.append(path.lstrip(\\'\\\\t\\'))\\n            if \\'.\\' in path:\\n                filename = \\'/\\'.join(stack)\\n                ret = max(ret,len(filename))\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 601155,
                "title": "python-o-n-solution-with-stack",
                "content": "It took me quite a while to figure out what this question really wants as people could easily get frustrated when comparing the question description with the terrible test cases.\\nSo I write down my solution here and hopefully it could help the others who are still stuck:\\n\\n```\\nclass Solution:\\n    def lengthLongestPath(self, inputStr: str) -> int:\\n        \"\"\"\\n        Clarifications:\\n        1. \\\\n means we are still at the same folder as the previous one.\\n        2. \\\\t means we are entering a sub folder of the previous one.\\n\\n        Example:\\n\\n        1. dir\\\\n(4-space) file.txt\\n\\n        The longest is \"    file.txt\", where the file is stored on \\n        the same level of dir.\\n\\n        2. dir\\\\n\\\\t(4-space) file.txt\\n\\n        The longest is \"dir/    file.text\", where the file is stored under\\n        dir. \\n        \"\"\"\\n        stack = [(-1, 0)]  # (current level, length of the current path)\\n        foundFile = False\\n        nextLevel = currLevel = currLen = maxLen = 0\\n        i, n = 0, len(inputStr)\\n        while i < n:\\n            c = inputStr[i]\\n            if c == \\'\\\\n\\':\\n                # Found a file in the previous item, calculate its path length.\\n                if foundFile:\\n                    maxLen = max(maxLen, currLen)\\n                    foundFile = False\\n\\n                # Check the level for the next item.\\n                nextLevel = 0\\n                while inputStr[i + 1] == \\'\\\\t\\':\\n                    nextLevel += 1\\n                    i += 1\\n\\n                if currLevel < nextLevel:  # Go down.\\n                    currLen += 1  # \\'/\\' takes one pisition in the path.\\n                    stack.append((currLevel, currLen))\\n                else:  # Stay on the same or go up.\\n                    while stack[-1][0] >= nextLevel:\\n                        stack.pop()\\n\\n                    currLen = stack[-1][-1]\\n\\n                currLevel = nextLevel\\n            else:\\n                if c == \\'.\\':\\n                    foundFile = True\\n\\n                currLen += 1\\n\\n            i += 1  # Process the next char.\\n\\n        if foundFile:  # Process the last file if any.\\n            maxLen = max(maxLen, currLen)\\n\\n        return maxLen\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lengthLongestPath(self, inputStr: str) -> int:\\n        \"\"\"\\n        Clarifications:\\n        1. \\\\n means we are still at the same folder as the previous one.\\n        2. \\\\t means we are entering a sub folder of the previous one.\\n\\n        Example:\\n\\n        1. dir\\\\n(4-space) file.txt\\n\\n        The longest is \"    file.txt\", where the file is stored on \\n        the same level of dir.\\n\\n        2. dir\\\\n\\\\t(4-space) file.txt\\n\\n        The longest is \"dir/    file.text\", where the file is stored under\\n        dir. \\n        \"\"\"\\n        stack = [(-1, 0)]  # (current level, length of the current path)\\n        foundFile = False\\n        nextLevel = currLevel = currLen = maxLen = 0\\n        i, n = 0, len(inputStr)\\n        while i < n:\\n            c = inputStr[i]\\n            if c == \\'\\\\n\\':\\n                # Found a file in the previous item, calculate its path length.\\n                if foundFile:\\n                    maxLen = max(maxLen, currLen)\\n                    foundFile = False\\n\\n                # Check the level for the next item.\\n                nextLevel = 0\\n                while inputStr[i + 1] == \\'\\\\t\\':\\n                    nextLevel += 1\\n                    i += 1\\n\\n                if currLevel < nextLevel:  # Go down.\\n                    currLen += 1  # \\'/\\' takes one pisition in the path.\\n                    stack.append((currLevel, currLen))\\n                else:  # Stay on the same or go up.\\n                    while stack[-1][0] >= nextLevel:\\n                        stack.pop()\\n\\n                    currLen = stack[-1][-1]\\n\\n                currLevel = nextLevel\\n            else:\\n                if c == \\'.\\':\\n                    foundFile = True\\n\\n                currLen += 1\\n\\n            i += 1  # Process the next char.\\n\\n        if foundFile:  # Process the last file if any.\\n            maxLen = max(maxLen, currLen)\\n\\n        return maxLen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 497358,
                "title": "simple-java-solution-using-a-stack",
                "content": "``` java\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        Stack<Integer> lengths = new Stack<Integer>();\\n        lengths.add(0);\\n        int maxPath = 0;\\n        for (String part : input.split(\"\\\\\\\\n\")) {\\n            String subparts[] = part.split(\"\\\\\\\\t\");\\n            String cur = subparts[subparts.length - 1];\\n            int depth = subparts.length;\\n            while (lengths.size() > depth){\\n                lengths.pop();\\n            }\\n            \\n            if (cur.indexOf(\\'.\\') != -1) {\\n                maxPath = Math.max(maxPath, lengths.peek() + cur.length() + lengths.size() - 1);\\n            } else {\\n                lengths.add(lengths.peek() + cur.length());\\n            }\\n        }\\n        return maxPath;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        Stack<Integer> lengths = new Stack<Integer>();\\n        lengths.add(0);\\n        int maxPath = 0;\\n        for (String part : input.split(\"\\\\\\\\n\")) {\\n            String subparts[] = part.split(\"\\\\\\\\t\");\\n            String cur = subparts[subparts.length - 1];\\n            int depth = subparts.length;\\n            while (lengths.size() > depth){\\n                lengths.pop();\\n            }\\n            \\n            if (cur.indexOf(\\'.\\') != -1) {\\n                maxPath = Math.max(maxPath, lengths.peek() + cur.length() + lengths.size() - 1);\\n            } else {\\n                lengths.add(lengths.peek() + cur.length());\\n            }\\n        }\\n        return maxPath;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 421102,
                "title": "python-hashmap-explanation-english-chinese-time-complexity",
                "content": "**Intuition:**\\nThe way to tackle this problems is:\\nwe keep track of the length of each level using a HashMap. The key of the HashMap is the current level (the depth of the path), and the value is the accumulated path length at the current level. Initially, this hashmap has one entry which is 0-th level and the length of 0-th level is 0. First, we need to split the input string by the newline chacter. After we split it, for the first input example, we would have an array like this [\\'dir\\', \\'\\\\tsubdir1\\', \\'\\\\tsubdir2\\', \\'\\\\t\\\\t\\\\file.ext\\'].\\n\\nThen for each element in this array, we count how many \\u2018\\\\t\\u2019 in it. If the number of tabs in the current element is greater than that of previous element, we incrememt the current level by 1. Next, we enter a new entry into the Hashmap where the key is previous level + 1, and the value is the accumulated length of previous level + number of characters at current level and one. The reason we add 1 is we need to add a forward slash between folders to indicate the increase of depth of the path, for example, the output for \\u2018x/y/z\\u2019 is 5.\\n\\nOne thing to note is that, when we encounter a file, instead of a subdirectory, it means that we have came to the very end of the current path. In other words, there is no more files or directories to be explored. So what we need to do now is, updating our maximum length variable when the current path length is greater than the maximum path length; otherwise, we go to the next iteration.\\n\\n**Complexity:**\\nThe time complexity of this algorithm is O(N) where N is the length of the input array. \\n* After we split the input array by the new line characters, we have K lines\\n* For each line, we need to determine if it is a file by using the build-in \\'in\\' function. The time complexity of function \\u2019in\\u2019 is O(M), where M is the average length of the name of a file and a directory. Since K * M == N, the time complexity is O(N). \\n\\nThe Space complexity is O(N) since we maintain a dictionary whose length is the number of levels in the input. In the worst case, for example, where \\'a/b/c/d/e\\' and a, b, c, d, e are all directories, the number of levels can grow up to 0(N/2). So the space complexity is 0(N/2) ~= O(N). \\n\\n---------------------------------------------------------------------------------------------------------\\n\\u89E3\\u51B3\\u8FD9\\u4E2A\\u95EE\\u9898\\u7684\\u65B9\\u6CD5\\u662F:\\n\\u6211\\u4EEC\\u4F7F\\u7528HashMap\\u8DDF\\u8E2A\\u6BCF\\u4E2A\\u7EA7\\u522B\\u7684\\u957F\\u5EA6\\u3002HashMap\\u7684\\u952E\\u662F\\u5F53\\u524D\\u7EA7\\u522B/\\u6216\\u8DEF\\u5F84\\u7684\\u6DF1\\u5EA6\\uFF0C\\u503C\\u662F\\u5F53\\u524D\\u7EA7\\u522B\\u7684\\u7D2F\\u8BA1\\u8DEF\\u5F84\\u957F\\u5EA6\\u3002\\u9996\\u5148\\uFF0C\\u6211\\u4EEC\\u9700\\u8981\\u6309\\u6362\\u884C\\u5B57\\u7B26\\u5206\\u5272\\u8F93\\u5165\\u5B57\\u7B26\\u4E32\\u3002\\u5728\\u6211\\u4EEC\\u5206\\u5272\\u5B83\\u4E4B\\u540E\\uFF0C\\u5BF9\\u4E8E\\u7B2C\\u4E00\\u4E2A\\u8F93\\u5165\\u793A\\u4F8B\\uFF0C\\u6211\\u4EEC\\u5C06\\u5F97\\u5230\\u8FD9\\u6837\\u4E00\\u4E2A\\u6570\\u7EC4[\\'dir\\'\\uFF0C \\'\\\\tsubdir1\\'\\uFF0C \\'\\\\tsubdir2\\'\\uFF0C \\'\\\\t\\\\t\\\\file.ext\\']\\u3002\\n\\n\\u7136\\u540E\\uFF0C\\u5BF9\\u4E8E\\u8FD9\\u4E2A\\u6570\\u7EC4\\u4E2D\\u7684\\u6BCF\\u4E2A\\u5143\\u7D20\\uFF0C\\u6211\\u4EEC\\u6570\\u4E00\\u6570\\u5176\\u4E2D\\u6709\\u591A\\u5C11\\u4E2A\\' \\\\t \\'\\u3002\\u5982\\u679C\\u5F53\\u524D\\u5143\\u7D20\\u4E2D\\u7684\\u5236\\u8868\\u7B26\\u6570\\u91CF\\u5927\\u4E8E\\u524D\\u4E00\\u4E2A\\u5143\\u7D20\\u7684\\u5236\\u8868\\u7B26\\u6570\\u91CF\\uFF0C\\u5219\\u5C06\\u5F53\\u524D\\u7EA7\\u522B\\u589E\\u52A01\\u3002\\u63A5\\u4E0B\\u6765\\uFF0C\\u6211\\u4EEC\\u5728Hashmap\\u4E2D\\u8F93\\u5165\\u4E00\\u4E2A\\u65B0\\u6761\\u76EE\\uFF0C\\u5176\\u4E2D\\u952E\\u662F\\u5F53\\u524D\\u7EA7\\u522B\\uFF0C\\u5373\\u524D\\u4E00\\u7EA7\\u522B+ 1\\uFF0C\\u503C\\u662F\\u524D\\u4E00\\u7EA7\\u522B\\u7684\\u7D2F\\u8BA1\\u957F\\u5EA6+\\u5F53\\u524D\\u7EA7\\u522B\\u7684\\u5B57\\u7B26\\u6570\\u548C1\\u3002\\u6211\\u4EEC\\u6DFB\\u52A01\\u7684\\u539F\\u56E0\\u662F\\u6211\\u4EEC\\u9700\\u8981\\u5728\\u6587\\u4EF6\\u5939\\u4E4B\\u95F4\\u6DFB\\u52A0\\u4E00\\u4E2A\\u659C\\u6760\\u6765\\u8868\\u793A\\u8DEF\\u5F84\\u6DF1\\u5EA6\\u7684\\u589E\\u52A0\\uFF0C\\u4F8B\\u5982\\uFF0C\\' x/y/z \\'\\u7684\\u8F93\\u51FA\\u662F5\\u3002\\n\\n\\u9700\\u8981\\u6CE8\\u610F\\u7684\\u4E00\\u70B9\\u662F\\uFF0C\\u5F53\\u6211\\u4EEC\\u9047\\u5230\\u4E00\\u4E2A\\u6587\\u4EF6\\u800C\\u4E0D\\u662F\\u5B50\\u76EE\\u5F55\\u65F6\\uFF0C\\u8FD9\\u610F\\u5473\\u7740\\u6211\\u4EEC\\u5DF2\\u7ECF\\u5230\\u8FBE\\u4E86\\u5F53\\u524D\\u8DEF\\u5F84\\u7684\\u672B\\u7AEF\\u3002\\u6362\\u53E5\\u8BDD\\u8BF4\\uFF0C\\u6CA1\\u6709\\u66F4\\u591A\\u7684\\u6587\\u4EF6\\u6216\\u76EE\\u5F55\\u8981\\u63A2\\u7D22\\u3002\\u6240\\u4EE5\\u6211\\u4EEC\\u73B0\\u5728\\u8981\\u505A\\u7684\\u662F\\uFF0C\\u5F53\\u5F53\\u524D\\u8DEF\\u5F84\\u957F\\u5EA6\\u5927\\u4E8E\\u6700\\u5927\\u8DEF\\u5F84\\u957F\\u5EA6\\u65F6\\u66F4\\u65B0\\u6700\\u5927\\u957F\\u5EA6\\u53D8\\u91CF;\\u5426\\u5219\\uFF0C\\u6211\\u4EEC\\u5C06\\u8FDB\\u5165\\u4E0B\\u4E00\\u4E2A\\u8FED\\u4EE3\\u3002\\n\\n\\u8BE5\\u7B97\\u6CD5\\u7684\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u4E3AO(N)\\uFF0C\\u5176\\u4E2DN\\u4E3A\\u8F93\\u5165\\u6570\\u7EC4\\u7684\\u957F\\u5EA6\\u3002\\n*\\u6211\\u4EEC\\u7528\\u65B0\\u884C\\u5B57\\u7B26\\u5206\\u5272\\u8F93\\u5165\\u6570\\u7EC4\\u540E\\uFF0C\\u6211\\u4EEC\\u6709K\\u884C\\n*\\u5BF9\\u4E8E\\u6BCF\\u4E00\\u884C\\uFF0C\\u6211\\u4EEC\\u9700\\u8981\\u4F7F\\u7528\\u5185\\u5EFA\\'in\\'\\u51FD\\u6570\\u6765\\u786E\\u5B9A\\u5B83\\u662F\\u5426\\u662F\\u4E00\\u4E2A\\u6587\\u4EF6\\u3002in\\u51FD\\u6570\\u7684\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u4E3AO(M)\\uFF0C\\u5176\\u4E2DM\\u4E3A\\u6587\\u4EF6\\u548C\\u76EE\\u5F55\\u540D\\u79F0\\u7684\\u5E73\\u5747\\u957F\\u5EA6\\u3002\\u7531\\u4E8EK * M == N\\uFF0C\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u4E3AO(N)\\u3002\\n\\n\\u7A7A\\u95F4\\u590D\\u6742\\u5EA6\\u4E3AO(N)\\uFF0C\\u56E0\\u4E3A\\u6211\\u4EEC\\u7EF4\\u62A4\\u4E86\\u4E00\\u4E2A\\u5B57\\u5178\\uFF0C\\u5B83\\u7684\\u957F\\u5EA6\\u662F\\u8F93\\u5165\\u7684\\u5C42\\u6570\\u3002\\u5728\\u6700\\u574F\\u7684\\u60C5\\u51B5\\u4E0B\\uFF0C\\u4F8B\\u5982\\uFF0C\\'a/b/c/d/e\\'\\u548Ca, b, c, d, e\\u90FD\\u662F\\u76EE\\u5F55\\uFF0C\\u7EA7\\u522B\\u7684\\u6570\\u91CF\\u53EF\\u4EE5\\u589E\\u957F\\u52300(N/2)\\u3002\\u6240\\u4EE5\\u7A7A\\u95F4\\u590D\\u6742\\u5EA6\\u662F0(N/2) ~= O(N)\\n\\n---------------------------------------------------------------------------------------------------------\\n\\n```\\ndef lengthLongestPath(self, input: str) -> int:\\n\\tmaxLength = 0\\n\\tlevel2length = {0:0}\\n\\tfor line in input.splitlines():\\n\\t\\tname = line.lstrip(\\'\\\\t\\')\\n\\t\\tnumOfTabs = len(line) - len(name)\\n\\t\\tif \\'.\\' in name: \\n\\t\\t    \\'\\'\\'if we encounter a file, then we reached the end of current path\\'\\'\\'\\n\\t\\t\\tmaxLength = max(maxLength, level2length[numOfTabs] + len(name))\\n\\t\\telse: \\n\\t\\t    \\'\\'\\'if we encounter a directory / folder\\'\\'\\'\\n\\t\\t\\tlevel2length[numOfTabs + 1] = level2length[numOfTabs] + len(name) + 1\\n\\treturn maxLength\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\ndef lengthLongestPath(self, input: str) -> int:\\n\\tmaxLength = 0\\n\\tlevel2length = {0:0}\\n\\tfor line in input.splitlines():\\n\\t\\tname = line.lstrip(\\'\\\\t\\')\\n\\t\\tnumOfTabs = len(line) - len(name)\\n\\t\\tif \\'.\\' in name: \\n\\t\\t    \\'\\'\\'if we encounter a file, then we reached the end of current path\\'\\'\\'\\n\\t\\t\\tmaxLength = max(maxLength, level2length[numOfTabs] + len(name))\\n\\t\\telse: \\n\\t\\t    \\'\\'\\'if we encounter a directory / folder\\'\\'\\'\\n\\t\\t\\tlevel2length[numOfTabs + 1] = level2length[numOfTabs] + len(name) + 1\\n\\treturn maxLength\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 333560,
                "title": "java-o-n-beats-98-runtime-100-memory",
                "content": "```\\nclass Solution {\\n        public int lengthLongestPath(String input) {\\n        String[]inputArray = input.split(\"\\\\n\");\\n        FileNode root = new FileNode(inputArray[0], 0, inputArray[0].length());\\n        Map<Integer, List<FileNode>>mapping = new HashMap<>();\\n        List<FileNode>list = new ArrayList<>();\\n        list.add(root);\\n        mapping.put(0, list);\\n        for (int i=1; i<inputArray.length; i++){\\n            String file = inputArray[i];\\n            int level = file.lastIndexOf(\\'\\\\t\\')+1;\\n            int length = file.length() - file.lastIndexOf(\\'\\\\t\\')-1;\\n            FileNode currentFile;\\n            if (level>0)\\n            {\\n                FileNode parent = mapping.get(level - 1).get(mapping.get(level - 1).size() - 1);\\n                currentFile = new FileNode(file.substring(file.indexOf(\\'\\\\t\\') + 1), level, parent.length + 1 + length);\\n                parent.children.add(currentFile);\\n            if (mapping.get(level)==null){\\n                List<FileNode>currentLevelList = new ArrayList<>();\\n                currentLevelList.add(currentFile);\\n                mapping.put(level, currentLevelList);\\n                }\\n            else mapping.get(level).add(currentFile);\\n            }\\n            else {\\n                currentFile = new FileNode(file.substring(file.indexOf(\\'\\\\t\\') + 1), 0, length);\\n                mapping.get(0).add(currentFile);\\n            }\\n        }\\n        int max = 0;\\n        for (FileNode fileNode: mapping.get(0)) max = Math.max(max, maxLength(fileNode));\\n        return max;\\n    }\\n\\n    public int maxLength(FileNode node){\\n         if (node.children.size()==0 && node.value.contains(\".\"))return node.length;\\n        else if (node.children.size()==0) return 0;\\n        else {\\n            int max = 0;\\n            for (FileNode child: node.children){\\n                max = Math.max(max, maxLength(child));\\n            }\\n            return max;\\n        }\\n    }\\n    \\n}\\n\\nclass FileNode{\\n    String value;\\n    List<FileNode>children;\\n    int level;\\n    int length;\\n\\n    public FileNode(String value, int level, int length) {\\n        this.value = value;\\n        this.children = new ArrayList<>();\\n        this.level = level;\\n        this.length = length;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        public int lengthLongestPath(String input) {\\n        String[]inputArray = input.split(\"\\\\n\");\\n        FileNode root = new FileNode(inputArray[0], 0, inputArray[0].length());\\n        Map<Integer, List<FileNode>>mapping = new HashMap<>();\\n        List<FileNode>list = new ArrayList<>();\\n        list.add(root);\\n        mapping.put(0, list);\\n        for (int i=1; i<inputArray.length; i++){\\n            String file = inputArray[i];\\n            int level = file.lastIndexOf(\\'\\\\t\\')+1;\\n            int length = file.length() - file.lastIndexOf(\\'\\\\t\\')-1;\\n            FileNode currentFile;\\n            if (level>0)\\n            {\\n                FileNode parent = mapping.get(level - 1).get(mapping.get(level - 1).size() - 1);\\n                currentFile = new FileNode(file.substring(file.indexOf(\\'\\\\t\\') + 1), level, parent.length + 1 + length);\\n                parent.children.add(currentFile);\\n            if (mapping.get(level)==null){\\n                List<FileNode>currentLevelList = new ArrayList<>();\\n                currentLevelList.add(currentFile);\\n                mapping.put(level, currentLevelList);\\n                }\\n            else mapping.get(level).add(currentFile);\\n            }\\n            else {\\n                currentFile = new FileNode(file.substring(file.indexOf(\\'\\\\t\\') + 1), 0, length);\\n                mapping.get(0).add(currentFile);\\n            }\\n        }\\n        int max = 0;\\n        for (FileNode fileNode: mapping.get(0)) max = Math.max(max, maxLength(fileNode));\\n        return max;\\n    }\\n\\n    public int maxLength(FileNode node){\\n         if (node.children.size()==0 && node.value.contains(\".\"))return node.length;\\n        else if (node.children.size()==0) return 0;\\n        else {\\n            int max = 0;\\n            for (FileNode child: node.children){\\n                max = Math.max(max, maxLength(child));\\n            }\\n            return max;\\n        }\\n    }\\n    \\n}\\n\\nclass FileNode{\\n    String value;\\n    List<FileNode>children;\\n    int level;\\n    int length;\\n\\n    public FileNode(String value, int level, int length) {\\n        this.value = value;\\n        this.children = new ArrayList<>();\\n        this.level = level;\\n        this.length = length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270697,
                "title": "c-100-simple-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        int depth = 0, sum = 0, token = 0, maxlen = 0;\\n        bool newline = true, isfile = false;\\n        stack<int> dirStack;\\n        \\n        for (int i = 0; i <= input.length(); ++i) {\\n            char c = input.c_str()[i];\\n            \\n            if (c == \\'\\\\n\\' || c == \\'\\\\0\\') {\\n                if (isfile) {\\n                    maxlen = max(maxlen, sum);\\n                    sum -= token; // remove filename from sum\\n                } else {\\n                    token++, sum++; // account for / at end of dir\\n                    dirStack.push(token);\\n                }\\n                token = 0;\\n                depth = 0;\\n                isfile = false;\\n                newline = true;\\n                continue;\\n            }\\n            \\n            if (c == \\'\\\\t\\') {\\n                depth++;\\n                continue;\\n            }\\n            \\n            // All characters past this point count towards the next line length, we\\'ve\\n            // counted the depth (tabs) leading up to this, if we aren\\'t as deep as our\\n            // stack was on the prior line, subtract & pop directory lengths from the  \\n            // stack until we are \\n            if (newline) {\\n                newline = false;\\n                while (depth < dirStack.size()) {\\n                    sum -= dirStack.top()\\n                    dirStack.pop();\\n                }\\n            }\\n            \\n            if (c == \\'.\\') isfile = true;\\n            token++;\\n            sum++;\\n        }\\n        \\n        return maxlen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        int depth = 0, sum = 0, token = 0, maxlen = 0;\\n        bool newline = true, isfile = false;\\n        stack<int> dirStack;\\n        \\n        for (int i = 0; i <= input.length(); ++i) {\\n            char c = input.c_str()[i];\\n            \\n            if (c == \\'\\\\n\\' || c == \\'\\\\0\\') {\\n                if (isfile) {\\n                    maxlen = max(maxlen, sum);\\n                    sum -= token; // remove filename from sum\\n                } else {\\n                    token++, sum++; // account for / at end of dir\\n                    dirStack.push(token);\\n                }\\n                token = 0;\\n                depth = 0;\\n                isfile = false;\\n                newline = true;\\n                continue;\\n            }\\n            \\n            if (c == \\'\\\\t\\') {\\n                depth++;\\n                continue;\\n            }\\n            \\n            // All characters past this point count towards the next line length, we\\'ve\\n            // counted the depth (tabs) leading up to this, if we aren\\'t as deep as our\\n            // stack was on the prior line, subtract & pop directory lengths from the  \\n            // stack until we are \\n            if (newline) {\\n                newline = false;\\n                while (depth < dirStack.size()) {\\n                    sum -= dirStack.top()\\n                    dirStack.pop();\\n                }\\n            }\\n            \\n            if (c == \\'.\\') isfile = true;\\n            token++;\\n            sum++;\\n        }\\n        \\n        return maxlen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86650,
                "title": "c-o-n-solution",
                "content": "The idea is to update length of subpath, and update `max-length` when a file name is included (`.` mark)\\n```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        vector<int> path_len(512, 0); // assume maximum depth of file path is 512\\n        stringstream ss(input);\\n        string tmp;\\n        \\n        int maxlen = 0;\\n        while (getline(ss, tmp, '\\\\n')) {\\n            int d = 0; // depth of current sub-path\\n            while (d < tmp.size() && tmp[d] == '\\\\t') ++d;\\n            string subpath = tmp.substr(d); // get length of sub-path or file name\\n            path_len[d] = subpath.size();\\n            if (subpath.find('.') != string::npos) {\\n                int clen = 0;\\n                for (int k = 0; k <= d; ++k) clen += path_len[k];\\n                maxlen = max(maxlen, clen + d); // don't forget slash mark\\n            }\\n        }\\n        return maxlen;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        vector<int> path_len(512, 0); // assume maximum depth of file path is 512\\n        stringstream ss(input);\\n        string tmp;\\n        \\n        int maxlen = 0;\\n        while (getline(ss, tmp, '\\\\n')) {\\n            int d = 0; // depth of current sub-path\\n            while (d < tmp.size() && tmp[d] == '\\\\t') ++d;\\n            string subpath = tmp.substr(d); // get length of sub-path or file name\\n            path_len[d] = subpath.size();\\n            if (subpath.find('.') != string::npos) {\\n                int clen = 0;\\n                for (int k = 0; k <= d; ++k) clen += path_len[k];\\n                maxlen = max(maxlen, clen + d); // don't forget slash mark\\n            }\\n        }\\n        return maxlen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86632,
                "title": "6ms-java-solution-using-wrapper-class-and-dfs",
                "content": "```\\npublic class Solution {\\n    public int lengthLongestPath(String input) {\\n        if(input == null || input.length() == 0) return 0;\\n        int[] res = new int[]{0};\\n        FileNode root = parseString(input);\\n        outputLongestPath(root, res);\\n        return res[0] == 0 ? 0 : res[0] - 1;\\n    }\\n\\n    private FileNode parseString(String input) {\\n        FileNode root = new FileNode(null, null, 0, -1, true), curr = root;\\n        String[] files = input.split(\"\\\\n\");\\n        for(String file: files) {\\n            int index = 0, level = 0;\\n            FileNode newFile;\\n\\n            // calculate the level\\n            while(index < file.length() && file.substring(index, index + 1).equals(\"\\\\t\")) {\\n                level++;\\n                index++;\\n            }\\n\\n            // decide if it is a file\\n            boolean isFile = file.contains(\".\");\\n\\n            // decide it is the children or brother\\n            if(level == curr.level) {       // brother\\n                newFile = new FileNode(file.substring(index, file.length()),\\n                        curr.parent, file.length() - index + 1, level, isFile);\\n                curr.parent.children.add(newFile);\\n            } else {                        // children\\n                while(level != curr.level + 1) curr = curr.parent;\\n                newFile = new FileNode(file.substring(index, file.length()),\\n                        curr, file.length() - index + 1, level, isFile);\\n                curr.children.add(newFile);\\n            }\\n            curr = newFile;\\n        }\\n        return root;\\n    }\\n\\n    private void outputLongestPath(FileNode root, int[] res) {\\n        if(!root.children.isEmpty()) {\\n            for(FileNode child: root.children) {\\n                outputLongestPath(child, res);\\n            }\\n        } else {\\n            if(!root.isFile) return;\\n            int count = root.count;\\n            while(root.parent != null) {\\n                count += root.parent.count;\\n                root = root.parent;\\n            }\\n            res[0] = Math.max(res[0], count);\\n        }\\n    }\\n\\n    class FileNode {\\n        String fileName;\\n        FileNode parent;\\n        List<FileNode> children;\\n        int count, level;\\n        boolean isFile;\\n\\n        public FileNode(String fileName, FileNode parent, int count, int level, boolean isFile) {\\n            this.fileName = fileName;\\n            this.parent = parent;\\n            this.children = new ArrayList<>();\\n            this.count = count;\\n            this.level = level;\\n            this.isFile = isFile;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int lengthLongestPath(String input) {\\n        if(input == null || input.length() == 0) return 0;\\n        int[] res = new int[]{0};\\n        FileNode root = parseString(input);\\n        outputLongestPath(root, res);\\n        return res[0] == 0 ? 0 : res[0] - 1;\\n    }\\n\\n    private FileNode parseString(String input) {\\n        FileNode root = new FileNode(null, null, 0, -1, true), curr = root;\\n        String[] files = input.split(\"\\\\n\");\\n        for(String file: files) {\\n            int index = 0, level = 0;\\n            FileNode newFile;\\n\\n            // calculate the level\\n            while(index < file.length() && file.substring(index, index + 1).equals(\"\\\\t\")) {\\n                level++;\\n                index++;\\n            }\\n\\n            // decide if it is a file\\n            boolean isFile = file.contains(\".\");\\n\\n            // decide it is the children or brother\\n            if(level == curr.level) {       // brother\\n                newFile = new FileNode(file.substring(index, file.length()),\\n                        curr.parent, file.length() - index + 1, level, isFile);\\n                curr.parent.children.add(newFile);\\n            } else {                        // children\\n                while(level != curr.level + 1) curr = curr.parent;\\n                newFile = new FileNode(file.substring(index, file.length()),\\n                        curr, file.length() - index + 1, level, isFile);\\n                curr.children.add(newFile);\\n            }\\n            curr = newFile;\\n        }\\n        return root;\\n    }\\n\\n    private void outputLongestPath(FileNode root, int[] res) {\\n        if(!root.children.isEmpty()) {\\n            for(FileNode child: root.children) {\\n                outputLongestPath(child, res);\\n            }\\n        } else {\\n            if(!root.isFile) return;\\n            int count = root.count;\\n            while(root.parent != null) {\\n                count += root.parent.count;\\n                root = root.parent;\\n            }\\n            res[0] = Math.max(res[0], count);\\n        }\\n    }\\n\\n    class FileNode {\\n        String fileName;\\n        FileNode parent;\\n        List<FileNode> children;\\n        int count, level;\\n        boolean isFile;\\n\\n        public FileNode(String fileName, FileNode parent, int count, int level, boolean isFile) {\\n            this.fileName = fileName;\\n            this.parent = parent;\\n            this.children = new ArrayList<>();\\n            this.count = count;\\n            this.level = level;\\n            this.isFile = isFile;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113781,
                "title": "javascript-stack-solution",
                "content": "```\\nfunction isFile(path) {\\n    return path.includes(\\'.\\')\\n}\\n\\nvar lengthLongestPath = function(input) {\\n    const segments = input.split(\\'\\\\n\\');\\n    \\n    let max = 0;\\n    let path = [];\\n    for (const segment of segments) {\\n        if (segment.startsWith(\\'\\\\t\\')) {\\n            const nesting = segment.match(/\\\\t/g).length;\\n            \\n            while (nesting < path.length) {\\n                path.pop();\\n            }\\n            \\n            path.push(segment.replace(/\\\\t/g, \\'\\'))\\n        } else {\\n            path = [segment]\\n        }\\n        \\n        if (isFile(path.at(-1))) {\\n            const filePath = path.join(\\'/\\');\\n            if (filePath.length > max) {\\n                max = filePath.length;\\n            }\\n        }\\n    }\\n    \\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction isFile(path) {\\n    return path.includes(\\'.\\')\\n}\\n\\nvar lengthLongestPath = function(input) {\\n    const segments = input.split(\\'\\\\n\\');\\n    \\n    let max = 0;\\n    let path = [];\\n    for (const segment of segments) {\\n        if (segment.startsWith(\\'\\\\t\\')) {\\n            const nesting = segment.match(/\\\\t/g).length;\\n            \\n            while (nesting < path.length) {\\n                path.pop();\\n            }\\n            \\n            path.push(segment.replace(/\\\\t/g, \\'\\'))\\n        } else {\\n            path = [segment]\\n        }\\n        \\n        if (isFile(path.at(-1))) {\\n            const filePath = path.join(\\'/\\');\\n            if (filePath.length > max) {\\n                max = filePath.length;\\n            }\\n        }\\n    }\\n    \\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1735029,
                "title": "simplest-c-solution-no-use-of-tokenizer-or-string-breaking-simple-for-loop-and-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        \\n        stack<int> st;\\n        \\n        int len = input.size();\\n        int tabs = 0;\\n        int curLen = 0;\\n        int maxLen = 0;\\n        bool hasDot = 0;\\n        \\n        for(int i = 0; i < len; i++)\\n        {\\n            if(input[i] == \\'\\\\t\\')\\n            {\\n                tabs++;\\n                curLen = 0;\\n            }\\n            else if(input[i] == \\'\\\\n\\')\\n            {\\n                int totalLen = curLen;\\n                \\n                if(!st.empty())\\n                {\\n                    totalLen += st.top();\\n                }\\n                \\n                if(hasDot)\\n                {\\n                    maxLen = max(maxLen, totalLen + (int)st.size());\\n                }\\n                \\n                st.push(totalLen);\\n                curLen = 0;\\n                hasDot = 0;\\n            }\\n            else\\n            {\\n                if(i && (input[i-1] == \\'\\\\t\\' || input[i-1] == \\'\\\\n\\'))\\n                {\\n                    while(st.size() > tabs)\\n                    {\\n                        st.pop();\\n                    }\\n                    tabs = 0;                    \\n                }\\n\\n                curLen++; \\n                \\n                if(input[i] == \\'.\\')\\n                {\\n                    hasDot = 1;\\n                }\\n            }\\n        }\\n        \\n        \\n        int totalLen = curLen;\\n\\n        if(!st.empty())\\n        {\\n            totalLen += st.top();\\n        }\\n        \\n        if(hasDot)\\n        {\\n            maxLen = max(maxLen, totalLen + (int)st.size());\\n        }\\n\\n        st.push(totalLen);\\n        curLen = 0;\\n        \\n        return maxLen;\\n    }\\n};\\n```\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\nFeel free to ask if there is any doubt or confusion. If you like or understand the solution, please do upvote it :-)",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        \\n        stack<int> st;\\n        \\n        int len = input.size();\\n        int tabs = 0;\\n        int curLen = 0;\\n        int maxLen = 0;\\n        bool hasDot = 0;\\n        \\n        for(int i = 0; i < len; i++)\\n        {\\n            if(input[i] == \\'\\\\t\\')\\n            {\\n                tabs++;\\n                curLen = 0;\\n            }\\n            else if(input[i] == \\'\\\\n\\')\\n            {\\n                int totalLen = curLen;\\n                \\n                if(!st.empty())\\n                {\\n                    totalLen += st.top();\\n                }\\n                \\n                if(hasDot)\\n                {\\n                    maxLen = max(maxLen, totalLen + (int)st.size());\\n                }\\n                \\n                st.push(totalLen);\\n                curLen = 0;\\n                hasDot = 0;\\n            }\\n            else\\n            {\\n                if(i && (input[i-1] == \\'\\\\t\\' || input[i-1] == \\'\\\\n\\'))\\n                {\\n                    while(st.size() > tabs)\\n                    {\\n                        st.pop();\\n                    }\\n                    tabs = 0;                    \\n                }\\n\\n                curLen++; \\n                \\n                if(input[i] == \\'.\\')\\n                {\\n                    hasDot = 1;\\n                }\\n            }\\n        }\\n        \\n        \\n        int totalLen = curLen;\\n\\n        if(!st.empty())\\n        {\\n            totalLen += st.top();\\n        }\\n        \\n        if(hasDot)\\n        {\\n            maxLen = max(maxLen, totalLen + (int)st.size());\\n        }\\n\\n        st.push(totalLen);\\n        curLen = 0;\\n        \\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618648,
                "title": "longest-absolute-file-path-hashmap-solution-python3-solution-time-complexity-analysis",
                "content": "\\'\\'\\'\\n\\n    def lengthLongestPath(self, input: str) -> int:\\n        # If the input is empty\\n        if not input: \\n            return 0\\n        \\n        #Initialzing HashMap for keep the account of the length of maximum file at each depth\\n        level = {-1:0}\\n        # Varianle for finding the longest absolute file path\\n        LongestFilePath = 0\\n        \\n        # Looping over each line\\n        for line in input.split(\\'\\\\n\\'):\\n            # Calculating the depth at which that file path exists using number of tab spaces\\n            depth = line.count(\\'\\\\t\\')\\n            # Calculating the length of file  at the particular depth\\n            # It\\'s possible there are multiple files at one particular depth\\n            # We have to take into consideration only the max file length\\n            # Note: \\\\t is counted as 1 while calculating the length of the file\\n            level[depth] = len(line) + level[depth-1] - depth\\n            \\n            # Calculating the longest file path\\n            if \\'.\\' in line:\\n                # Once the end is reached, calculate the total file path length as per the requirements given in the question\\n                LongestFilePath = max(LongestFilePath, level[depth]+depth)\\n        \\n        # Returning the absolute longest file path\\n        return LongestFilePath\\n\\'\\'\\'\\n\\nTime Complexity --> O(N)\\nHere, \\nN --> Total files and directories in the system\\n\\nHope this helps. Thanks!",
                "solutionTags": [
                    "String"
                ],
                "code": "\\'\\'\\'\\n\\n    def lengthLongestPath(self, input: str) -> int:\\n        # If the input is empty\\n        if not input: \\n            return 0\\n        \\n        #Initialzing HashMap for keep the account of the length of maximum file at each depth\\n        level = {-1:0}\\n        # Varianle for finding the longest absolute file path\\n        LongestFilePath = 0\\n        \\n        # Looping over each line\\n        for line in input.split(\\'\\\\n\\'):\\n            # Calculating the depth at which that file path exists using number of tab spaces\\n            depth = line.count(\\'\\\\t\\')\\n            # Calculating the length of file  at the particular depth\\n            # It\\'s possible there are multiple files at one particular depth\\n            # We have to take into consideration only the max file length\\n            # Note: \\\\t is counted as 1 while calculating the length of the file\\n            level[depth] = len(line) + level[depth-1] - depth\\n            \\n            # Calculating the longest file path\\n            if \\'.\\' in line:\\n                # Once the end is reached, calculate the total file path length as per the requirements given in the question\\n                LongestFilePath = max(LongestFilePath, level[depth]+depth)\\n        \\n        # Returning the absolute longest file path\\n        return LongestFilePath\\n\\'\\'\\'\\n\\nTime Complexity --> O(N)\\nHere, \\nN --> Total files and directories in the system\\n\\nHope this helps. Thanks!",
                "codeTag": "Python3"
            },
            {
                "id": 1156549,
                "title": "python-stack-ish-clean-short-solution",
                "content": "```class Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        max_so_far = 0\\n        \\n        # stack of file paths, dirs[i]: path_len of level i\\n        dirs = []\\n        for c in input.split(\\'\\\\n\\'):\\n            level = len(c) - len(c.lstrip(\\'\\\\t\\'))\\n            path_len = len(c) if level == 0 else (dirs[level-1] + len(\\'/\\') + len(c[level:]))\\n\\n            if \\'.\\' in c:\\n                max_so_far = max(max_so_far, path_len)\\n            else:\\n                # essentially popping values out\\n                dirs = dirs[:level]\\n                dirs.append(path_len)\\n\\n        return max_so_far```",
                "solutionTags": [],
                "code": "```class Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        max_so_far = 0\\n        \\n        # stack of file paths, dirs[i]: path_len of level i\\n        dirs = []\\n        for c in input.split(\\'\\\\n\\'):\\n            level = len(c) - len(c.lstrip(\\'\\\\t\\'))\\n            path_len = len(c) if level == 0 else (dirs[level-1] + len(\\'/\\') + len(c[level:]))\\n\\n            if \\'.\\' in c:\\n                max_so_far = max(max_so_far, path_len)\\n            else:\\n                # essentially popping values out\\n                dirs = dirs[:level]\\n                dirs.append(path_len)\\n\\n        return max_so_far```",
                "codeTag": "Java"
            },
            {
                "id": 614200,
                "title": "java-python-stack-vs-arraylist-using-t-to-calculate-level",
                "content": "Orig: https://leetcode.com/problems/longest-absolute-file-path/discuss/86615/9-lines-4ms-Java-solution\\n```\\npublic int lengthLongestPath(String input) {\\n        Deque<Integer> st = new ArrayDeque<>();\\n        st.push(0);\\n        int res = 0;\\n        for (String s : input.split(\"\\\\n\")) {\\n            int lvl = s.lastIndexOf(\"\\\\t\") + 1;   // level starts fr 0 = -1 + 1;\\n            while (lvl + 1 < st.size()) st.pop();\\n            int len = st.peek() + s.length() - lvl + 1;  // include \"\\\\\"\\n            if (s.contains(\".\")) res = Math.max(res, len - 1);\\n            st.push(len);\\n        }\\n        return res;\\n    }\\n```\\n\\nArrayList\\n\\n```\\npublic int lengthLongestPath(String input) {\\n        String[] ss = input.split(\"\\\\n\");\\n        List<String> arr = new ArrayList<>();\\n        int res = 0;\\n        for (String s : ss) {\\n            int l = 0;\\n            while (l < s.length() && s.charAt(l) == \\'\\\\t\\') l++;\\n            // must check: arr.size() > 0 && l >= 1, say \"dir\\\\n    file.txt\"\\n            String path = (arr.size() > 0 && l >= 1 ? arr.get(l - 1) : \"\") + \"/\" + s.substring(l);  //   /a/aa/aaa\\n            //must check l == 0 || arr.size() <= 1; say, root;\\n            //add arr.size() == 0 , say, \"a\\\\n\\\\tb.txt\\\\na2\\\\n\\\\tb2.txt\"\\n            if ((l == 0 && arr.size() == 0) || arr.size() <= l) arr.add(path);\\n            else arr.set(l, path);  \\n            // arr.set(l, path);  \\n            // System.out.println(path);\\n            if (s.split(\"\\\\\\\\.\").length >= 2) res = Math.max(res, path.length() - 1); // not inlude first \"/\";\\n        }\\n        return res;\\n    }\\n```\\n\\n```\\nclass Solution(object):\\n    def lengthLongestPath(self, input):\\n        \"\"\"\\n        :type input: str\\n        :rtype: int\\n        \"\"\"\\n        mxlen = 0\\n        prelen = {0:0}\\n        for ln in input.split(\"\\\\n\"):\\n            name = ln.lstrip(\"\\\\t\")\\n            depth = len(ln) - len(name)\\n            if \".\" in name:\\n                mxlen = max(mxlen, prelen[depth] + len(name))\\n            else:\\n                prelen[depth + 1] = prelen[depth] + len(name) + 1\\n        return mxlen  \\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic int lengthLongestPath(String input) {\\n        Deque<Integer> st = new ArrayDeque<>();\\n        st.push(0);\\n        int res = 0;\\n        for (String s : input.split(\"\\\\n\")) {\\n            int lvl = s.lastIndexOf(\"\\\\t\") + 1;   // level starts fr 0 = -1 + 1;\\n            while (lvl + 1 < st.size()) st.pop();\\n            int len = st.peek() + s.length() - lvl + 1;  // include \"\\\\\"\\n            if (s.contains(\".\")) res = Math.max(res, len - 1);\\n            st.push(len);\\n        }\\n        return res;\\n    }\\n```\n```\\npublic int lengthLongestPath(String input) {\\n        String[] ss = input.split(\"\\\\n\");\\n        List<String> arr = new ArrayList<>();\\n        int res = 0;\\n        for (String s : ss) {\\n            int l = 0;\\n            while (l < s.length() && s.charAt(l) == \\'\\\\t\\') l++;\\n            // must check: arr.size() > 0 && l >= 1, say \"dir\\\\n    file.txt\"\\n            String path = (arr.size() > 0 && l >= 1 ? arr.get(l - 1) : \"\") + \"/\" + s.substring(l);  //   /a/aa/aaa\\n            //must check l == 0 || arr.size() <= 1; say, root;\\n            //add arr.size() == 0 , say, \"a\\\\n\\\\tb.txt\\\\na2\\\\n\\\\tb2.txt\"\\n            if ((l == 0 && arr.size() == 0) || arr.size() <= l) arr.add(path);\\n            else arr.set(l, path);  \\n            // arr.set(l, path);  \\n            // System.out.println(path);\\n            if (s.split(\"\\\\\\\\.\").length >= 2) res = Math.max(res, path.length() - 1); // not inlude first \"/\";\\n        }\\n        return res;\\n    }\\n```\n```\\nclass Solution(object):\\n    def lengthLongestPath(self, input):\\n        \"\"\"\\n        :type input: str\\n        :rtype: int\\n        \"\"\"\\n        mxlen = 0\\n        prelen = {0:0}\\n        for ln in input.split(\"\\\\n\"):\\n            name = ln.lstrip(\"\\\\t\")\\n            depth = len(ln) - len(name)\\n            if \".\" in name:\\n                mxlen = max(mxlen, prelen[depth] + len(name))\\n            else:\\n                prelen[depth + 1] = prelen[depth] + len(name) + 1\\n        return mxlen  \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 147221,
                "title": "java-solution-using-stack-beats-99",
                "content": "The idea is straightforward:\\nWe identify the \"level\" (number of tabs) of each directory / file and keep a stack which traces the path to the current parent folder.\\n\\nWhenever we are exiting from one or more directories, we keep poping the stack (same idea as \"cd ..\") to the parent folder.\\n```\\npublic int lengthLongestPath(String input) {\\n        String[] names = input.split(\"\\\\n\");\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(0);\\n        int max = 0;\\n        for (String name: names){\\n            // Count the level by counting number of tabs\\n            int level = 0;\\n            while (name.startsWith(\"\\\\t\")){\\n                name = name.substring(1);\\n                level++;\\n            }\\n            \\n            // Exit to the current level\\n            while (stack.size() - 1 > level){\\n                stack.pop();\\n            }\\n            \\n            if (name.contains(\".\")){\\n                // Is a file\\n                max = Math.max(max, stack.peek() + name.length());\\n                \\n            } else{\\n                // Is a directory\\n                stack.push(stack.peek() + name.length() + 1);\\n            }\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int lengthLongestPath(String input) {\\n        String[] names = input.split(\"\\\\n\");\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(0);\\n        int max = 0;\\n        for (String name: names){\\n            // Count the level by counting number of tabs\\n            int level = 0;\\n            while (name.startsWith(\"\\\\t\")){\\n                name = name.substring(1);\\n                level++;\\n            }\\n            \\n            // Exit to the current level\\n            while (stack.size() - 1 > level){\\n                stack.pop();\\n            }\\n            \\n            if (name.contains(\".\")){\\n                // Is a file\\n                max = Math.max(max, stack.peek() + name.length());\\n                \\n            } else{\\n                // Is a directory\\n                stack.push(stack.peek() + name.length() + 1);\\n            }\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 86680,
                "title": "javascript-es6-solution-with-explanation",
                "content": "This problem has a few things to keep track of, most importantly the `maxLength`, the `depth` we are currently at, and the maximum `pathLength` at any given depth.  \\n\\nWe start the problem by splitting the input by `\\\\n` to give us a clean representation of each level of the file tree, and initialize a `maxLength` to keep track of our maximum length as well as a `pathLength` object to keep track of the length of the path to our current depth.\\n\\nWhen we loop over a string in our array, we produce a new string with all instances of `\\\\t` removed, and subtract the length of our new string from the length of our old string to get our current `depth`;\\n\\nIf the string contains a `.` we know that it is a filename and we compare `maxLength` to the length of our new string (without the `\\\\t`'s) added to the `pathLength` of our current depth, and set maxLength equal to that if it is higher.\\n\\nFinally, if the current string does not contain `.`, that means that it is a folder or subfolder, so we set `pathLength[depth + 1]` equal to the the current pathLength (since that is how many characters it took us to get to this level) added to the length of the current name + 1.  We need to add `+1` because the next path will have an additional tab character that we need to account for.\\n``` \\nconst lengthLongestPath = (input) => {\\n    input = input.split('\\\\n');\\n    let maxLength = 0;\\n    let pathLength = {0 : 0};\\n    for (let i = 0; i < input.length; i++) {\\n        const name = input[i].replace(/\\\\t/g, '');\\n        const depth = input[i].length - name.length\\n        if (name.indexOf('.') !== -1) {\\n            maxLength = Math.max(result, pathLength[depth] + name.length)\\n        }\\n        else {\\n            pathLength[depth + 1] = pathLength[depth] + (name.length + 1)\\n        }\\n    }\\n    return maxLength\\n};\\n```",
                "solutionTags": [],
                "code": "``` \\nconst lengthLongestPath = (input) => {\\n    input = input.split('\\\\n');\\n    let maxLength = 0;\\n    let pathLength = {0 : 0};\\n    for (let i = 0; i < input.length; i++) {\\n        const name = input[i].replace(/\\\\t/g, '');\\n        const depth = input[i].length - name.length\\n        if (name.indexOf('.') !== -1) {\\n            maxLength = Math.max(result, pathLength[depth] + name.length)\\n        }\\n        else {\\n            pathLength[depth + 1] = pathLength[depth] + (name.length + 1)\\n        }\\n    }\\n    return maxLength\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 86703,
                "title": "javascript-solution-o-n-time-using-a-simple-stack-w-detailed-explanation",
                "content": "\\n```\\n/**\\n * @param {string} input\\n * @return {number}\\n */\\nvar lengthLongestPath = function(input) {\\n    \\n    // Break each line into its own index in the array. This makes the string more manageable\\n    let lines = input.split('\\\\n');\\n    \\n    // We'll store our files (with full directories included) here\\n    let paths = [];\\n    \\n    // The current directory we're in is stored here. This is our stack\\n    let currentDirectory = [];\\n    \\n    // Iterate over every line\\n    for (let i = 0; i < lines.length; i++) {\\n        let p = lines[i];\\n        \\n        // We're going to find out the depth of our file/directory\\n        let tabs = p.match(/\\\\t/g);\\n        \\n        // p.match returns null for no matches. Default to 0\\n        tabs = tabs ? tabs.length : 0;\\n        \\n        // Remove all the tabs\\n        p = p.replace(/\\\\t/g, '');\\n        \\n        // If we decrease depth (i.e. go into a parent directory) then we'll need to know how many levels up we're going\\n        let depthdiff = currentDirectory.length-tabs;\\n        \\n        // For every level up we're going, go ahead and remove the child directories we're no longer in\\n        // Something that I didn't realize at first is that a file may be in no directory.\\n        // For instance: dir\\\\n    test.txt\\n        // Don't overthink it. \"    test.txt\" is a root file with no directory and 4 leading spaces, so its return length will be 12.\\n        // Leading spaces are counted as filename characters!\\n        if (depthdiff >= 0) currentDirectory.splice(tabs, currentDirectory.length);\\n        \\n        // matched a file\\n        if (p.match(/\\\\.\\\\w+$/) != null) {\\n            \\n            // We take our currentDirectory stack, which has every directory depth we're inside of\\n            // Then were appending our file onto the end of that directory\\n            // Finally, we'll join the array into a string, separating each index with a slash\\n            paths.push(currentDirectory.concat(p).join('/'));\\n        } else {\\n            // Matched a directory, add it to the current directory stack\\n            currentDirectory.push(p);\\n        }\\n    }\\n    \\n    // Here we'll iterate over all our files and update the longest length\\n    let longestlength = 0;\\n    for (let i = 0; i < paths.length; i++) {\\n        longestlength = Math.max(paths[i].length, longestlength);\\n    }\\n    \\n    // Done!\\n    return longestlength;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} input\\n * @return {number}\\n */\\nvar lengthLongestPath = function(input) {\\n    \\n    // Break each line into its own index in the array. This makes the string more manageable\\n    let lines = input.split('\\\\n');\\n    \\n    // We'll store our files (with full directories included) here\\n    let paths = [];\\n    \\n    // The current directory we're in is stored here. This is our stack\\n    let currentDirectory = [];\\n    \\n    // Iterate over every line\\n    for (let i = 0; i < lines.length; i++) {\\n        let p = lines[i];\\n        \\n        // We're going to find out the depth of our file/directory\\n        let tabs = p.match(/\\\\t/g);\\n        \\n        // p.match returns null for no matches. Default to 0\\n        tabs = tabs ? tabs.length : 0;\\n        \\n        // Remove all the tabs\\n        p = p.replace(/\\\\t/g, '');\\n        \\n        // If we decrease depth (i.e. go into a parent directory) then we'll need to know how many levels up we're going\\n        let depthdiff = currentDirectory.length-tabs;\\n        \\n        // For every level up we're going, go ahead and remove the child directories we're no longer in\\n        // Something that I didn't realize at first is that a file may be in no directory.\\n        // For instance: dir\\\\n    test.txt\\n        // Don't overthink it. \"    test.txt\" is a root file with no directory and 4 leading spaces, so its return length will be 12.\\n        // Leading spaces are counted as filename characters!\\n        if (depthdiff >= 0) currentDirectory.splice(tabs, currentDirectory.length);\\n        \\n        // matched a file\\n        if (p.match(/\\\\.\\\\w+$/) != null) {\\n            \\n            // We take our currentDirectory stack, which has every directory depth we're inside of\\n            // Then were appending our file onto the end of that directory\\n            // Finally, we'll join the array into a string, separating each index with a slash\\n            paths.push(currentDirectory.concat(p).join('/'));\\n        } else {\\n            // Matched a directory, add it to the current directory stack\\n            currentDirectory.push(p);\\n        }\\n    }\\n    \\n    // Here we'll iterate over all our files and update the longest length\\n    let longestlength = 0;\\n    for (let i = 0; i < paths.length; i++) {\\n        longestlength = Math.max(paths[i].length, longestlength);\\n    }\\n    \\n    // Done!\\n    return longestlength;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 86820,
                "title": "just-traversing-once-and-retrieving-the-longest-in-c-well-explained",
                "content": "### Solution\\nWe are to split the string by the `\\\\n` (distinguish the different directories or files); and then we will use a `stack` to record the traversed directory to retrieve the absolute directory for each file.\\n\\nTake the example: `\"dir\\\\n\\\\t    subdir1\\\\n\\\\tsubdir2\\\\n\\\\t\\\\tfile.ext\"`\\n\\nDetails as follows:\\n\\nSince we will traverse the string as less as possible and split the string by `\\\\n`. As a result, after each `\\\\n`, we are to handle the next level for the next directory or file and handle the current right away. There will be two levels around the `\\\\n`, current level will be the `before \\\\n` part, while the next level is the level after `\\\\n`.\\n\\nAs for the next level:\\n- First, swallow the `\\\\t` or `4' '` to determine the level for the next (directory or file).\\n- Second, white space `' ' ` should be carefully handled, since the next level cannot be deeper than the current level by more than `1`. So if we swallow too much - more than the next level requires. Then we have to pop the white space `' '` out by moving the pointer backwards\\n\\n> In the example mentioned, as to the `subdir1`,  if we swallow all the spaces, there will be too many white spaces and the next level will be `2` while the current level is 0 (dir). So we have to pop out the last four spaces to make the next level `1`, a valid value.\\n\\nAs for the current level which will be automatically updated by the next level each time:\\n- First, if the current level is too shallow, which means the current directory is not a child of the previous directory, then we have to pop out the previously stored (the `stack`) until the current level is okay with it.\\n\\n> In the example, if we encounter the `subdir2`, then the current level is `1` which is shallow (equal to its previous, not its children) then we have to pop out the `subdir1` from the `stack` and then push the `subdir2` into it.\\n\\n- Second, when we encounter the file (contains a `.`), we need then check and update the longest.\\n\\n> **Note** since we will split the string by `\\\\n` and each time encountering it, we will append the directory or file before it and then update the longest. So before everything, we can append a `\\\\n` to the end of the string to ensure the final path will also be properly handled.\\n```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string s) {\\n        s += '\\\\n';\\n        vector<string> paths;\\n        string t = \"\";\\n        int maxLen = 0;\\n        int i = 0, curLevel = 0, nextLevel = 0;\\n        while(i < s.length()) {\\n            if(s[i] == '\\\\n') {\\n                i++; //escape the '\\\\n';\\n                nextLevel = 0;\\n                while(s[i] == '\\\\t') nextLevel++, i++;\\n                int spaceCount = 0;\\n                while(s[i] == ' ') spaceCount++, i++;\\n                nextLevel += spaceCount/4;\\n                spaceCount -= spaceCount/4*4;\\n                if(nextLevel > curLevel+1) {\\n                    i -= (nextLevel - curLevel - 1) * 4+spaceCount;\\n                    nextLevel = curLevel+1;\\n                }\\n                while(paths.size() > curLevel) paths.pop_back();\\n                paths.push_back(t);\\n                if(find(t.begin(), t.end(), '.') != t.end()) {\\n                    int len = 0;\\n                    for(auto str: paths) len += 1+str.length();\\n                    len--;\\n                    maxLen = max(maxLen, len);\\n                }\\n                curLevel = nextLevel;\\n                t = \"\";\\n            }\\n            else t += s[i++];\\n        }\\n        return maxLen;\\n    }\\n};\\n```\\nAlways welcome new ideas and `practical` tricks, just leave them in the comments!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string s) {\\n        s += '\\\\n';\\n        vector<string> paths;\\n        string t = \"\";\\n        int maxLen = 0;\\n        int i = 0, curLevel = 0, nextLevel = 0;\\n        while(i < s.length()) {\\n            if(s[i] == '\\\\n') {\\n                i++; //escape the '\\\\n';\\n                nextLevel = 0;\\n                while(s[i] == '\\\\t') nextLevel++, i++;\\n                int spaceCount = 0;\\n                while(s[i] == ' ') spaceCount++, i++;\\n                nextLevel += spaceCount/4;\\n                spaceCount -= spaceCount/4*4;\\n                if(nextLevel > curLevel+1) {\\n                    i -= (nextLevel - curLevel - 1) * 4+spaceCount;\\n                    nextLevel = curLevel+1;\\n                }\\n                while(paths.size() > curLevel) paths.pop_back();\\n                paths.push_back(t);\\n                if(find(t.begin(), t.end(), '.') != t.end()) {\\n                    int len = 0;\\n                    for(auto str: paths) len += 1+str.length();\\n                    len--;\\n                    maxLen = max(maxLen, len);\\n                }\\n                curLevel = nextLevel;\\n                t = \"\";\\n            }\\n            else t += s[i++];\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126192,
                "title": "java-stack-solution",
                "content": "We can just use a stack to keep the total length of the current level we are on. \\n\\nWe can count the tabs to decide if the file belongs to the current directory we are in or we need to go back 1 or more steps.\\nThe filename is just the whole length of the line minus the amount of tab characters there are in the line.\\n\\nWe need to add 1 each time because the max length needs to account for the fact that directories are split by a / character.\\n\\n```\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        var stack = new ArrayDeque<Integer>();\\n        int max = 0;\\n        String[] lines = input.split(\"\\\\n\");\\n        for(var line: lines) {\\n            int tabs = countTabs(line);\\n            while(tabs < stack.size()) {\\n                stack.pop();\\n            }\\n            int current = stack.isEmpty() ? 0: stack.peek();\\n            int nameLength = line.length() - tabs;\\n            if(isFilename(line)) {\\n                max = Math.max(max, current + nameLength);\\n            } else {\\n                stack.push(current + nameLength + 1);\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    private int countTabs(String s) {\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) != \\'\\\\t\\') return i;\\n        }\\n        return 0;\\n    }\\n    \\n    private boolean isFilename(String s) {\\n        return s.lastIndexOf(\".\") != -1;\\n    }\\n    \\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        var stack = new ArrayDeque<Integer>();\\n        int max = 0;\\n        String[] lines = input.split(\"\\\\n\");\\n        for(var line: lines) {\\n            int tabs = countTabs(line);\\n            while(tabs < stack.size()) {\\n                stack.pop();\\n            }\\n            int current = stack.isEmpty() ? 0: stack.peek();\\n            int nameLength = line.length() - tabs;\\n            if(isFilename(line)) {\\n                max = Math.max(max, current + nameLength);\\n            } else {\\n                stack.push(current + nameLength + 1);\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    private int countTabs(String s) {\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) != \\'\\\\t\\') return i;\\n        }\\n        return 0;\\n    }\\n    \\n    private boolean isFilename(String s) {\\n        return s.lastIndexOf(\".\") != -1;\\n    }\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841512,
                "title": "clean-kotlin",
                "content": "```\\ndata class FSO(val filename: String, val level: Int) {\\n\\tval isFile: Boolean = filename.contains(\".\")\\n}\\n\\nfun lengthLongestPath(input: String): Int {\\n\\tval fsObjects = input.split(\\'\\\\n\\').map{it.toFSO()}\\n\\tval stack = ArrayDeque<FSO>()\\n\\tvar total = 0\\n\\tvar m = 0\\n\\tfor (fso in fsObjects) {\\n\\t\\twhile (stack.size > fso.level) total -= stack.pop().filename.length+1\\n\\t\\tstack.push(fso)\\n\\t\\ttotal += fso.filename.length+1\\n\\t\\tif (fso.isFile) m = maxOf(m,total-1)\\n\\t}\\n\\treturn m\\n}\\n\\nfun String.toFSO() : FSO {\\n\\tvar i = 0\\n\\tvar level = 0\\n\\twhile (this[i++] == \\'\\\\t\\') level++\\n\\treturn FSO(this.substring(--i), level)\\n}\\n```\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/3ea6017d-9699-49a8-bb66-d2a14b1cda8b_1647064050.4825816.png)\\n",
                "solutionTags": [
                    "Java",
                    "Kotlin"
                ],
                "code": "```\\ndata class FSO(val filename: String, val level: Int) {\\n\\tval isFile: Boolean = filename.contains(\".\")\\n}\\n\\nfun lengthLongestPath(input: String): Int {\\n\\tval fsObjects = input.split(\\'\\\\n\\').map{it.toFSO()}\\n\\tval stack = ArrayDeque<FSO>()\\n\\tvar total = 0\\n\\tvar m = 0\\n\\tfor (fso in fsObjects) {\\n\\t\\twhile (stack.size > fso.level) total -= stack.pop().filename.length+1\\n\\t\\tstack.push(fso)\\n\\t\\ttotal += fso.filename.length+1\\n\\t\\tif (fso.isFile) m = maxOf(m,total-1)\\n\\t}\\n\\treturn m\\n}\\n\\nfun String.toFSO() : FSO {\\n\\tvar i = 0\\n\\tvar level = 0\\n\\twhile (this[i++] == \\'\\\\t\\') level++\\n\\treturn FSO(this.substring(--i), level)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703911,
                "title": "python-stack-9-lines-simple",
                "content": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        input = input.split(\\'\\\\n\\')\\n        path, ans, total = [], 0, 0\\n        for line in input:\\n            tabs = line.count(\\'\\\\t\\')\\n            while len(path) > tabs: total -= path.pop()\\n            path.append(len(line) - tabs)\\n            total += path[-1]\\n            if \\'.\\' in line: ans = max(ans, total + len(path) - 1)\\n        return ans\\n```\\nThe basic idea is to create a stack containing the lengths of each of the path components along with a running total of the component lengths. Depth in the filepath is based on how many tab characters per line. \\n\\nTo traverse back up the file path, keep popping off the stack until the depth is same as the number of path components. The `.` in the line means a file was found. Take the total length of components and add the missing  `\\\\` characters (number of components - 1) to get the path length. `ans` is the maximum of these candidates.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        input = input.split(\\'\\\\n\\')\\n        path, ans, total = [], 0, 0\\n        for line in input:\\n            tabs = line.count(\\'\\\\t\\')\\n            while len(path) > tabs: total -= path.pop()\\n            path.append(len(line) - tabs)\\n            total += path[-1]\\n            if \\'.\\' in line: ans = max(ans, total + len(path) - 1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587486,
                "title": "c-solution-faster-than-100-00-of-c-online-submissions",
                "content": "Easy to understand but tedious to implement (atleast in C++) kind of problem. \\nSo start with an unordered map that stores the length of resultant string upto that level (level 1 contains home dir name), until that point [this note is important as we keep on going to update the length of strings until particular level in each traversal to the file]. Notice how we did level=0 when we are in if statement of i>=n || input[i]==\\'\\\\n\\'. This ensures that we count levels by counting the number of preceeding \\'\\\\t\\' characters (exactly what we have done in else case).\\nSo traverse through the string, increment the i counter until you encounter an delimeter. Remember that we can go over n in this loop, even in that case remember to account for the last file in path (hence condition i>=n || input[i]==\\'\\\\n\\').\\nWhen we encounter \\'\\\\t\\' just increase the level (as discussed earlier) else check if the current part of path contains \\'.\\'= meaning it is a file extension. If it is, update the answer. Else again, increase level and update the map.\\nA[level] = A[level-1] + t.length()+1 // A[level-1] = length until last level in current path we traversing; \\nt.length() = length of current part of path (some subdirectory name) ;\\n+1 for \\\\ character in between the path. Note no +1 in case of ans calculation as no \\\\ char after name name.\\n```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        int ans = 0, n = input.size(), level = 0;\\n        unordered_map<int, int> A;\\n        A[0] = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            int start = i;\\n            while(i<n && input[i]!=\\'\\\\n\\' && input[i]!=\\'\\\\t\\')\\n                i++;\\n            if(i>=n || input[i]==\\'\\\\n\\')\\n            {\\n                string t = input.substr(start, i-start);\\n                if(t.find(\\'.\\')!=string::npos)\\n                {\\n                    ans= max(ans, A[level]+(int)t.length());\\n                }\\n                else\\n                {\\n                    level++;\\n                    A[level] = A[level-1] + t.length()+1;\\n                }\\n                level = 0;\\n            }\\n            else\\n                level++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nTime complexity: O(N)\\nSpace complexity: O(N)",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        int ans = 0, n = input.size(), level = 0;\\n        unordered_map<int, int> A;\\n        A[0] = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            int start = i;\\n            while(i<n && input[i]!=\\'\\\\n\\' && input[i]!=\\'\\\\t\\')\\n                i++;\\n            if(i>=n || input[i]==\\'\\\\n\\')\\n            {\\n                string t = input.substr(start, i-start);\\n                if(t.find(\\'.\\')!=string::npos)\\n                {\\n                    ans= max(ans, A[level]+(int)t.length());\\n                }\\n                else\\n                {\\n                    level++;\\n                    A[level] = A[level-1] + t.length()+1;\\n                }\\n                level = 0;\\n            }\\n            else\\n                level++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567080,
                "title": "java-2-stack-versions-easy-readable-or-optimised-complex",
                "content": "### Easy and readable\\nThe idea is:\\n- Store each subdirectory in the stack as we move deeper.\\n- When we are processing a file, construct the fullpath and calculate its length.\\n\\n```\\npublic int lengthLongestPath(String input) {\\n    // Store each directory\\n    Stack<String> stack = new Stack<>();\\n    int max = 0;\\n\\n    for (String row : input.split(\"\\\\n\")) {\\n        // Store how deep is the current level\\n        // Root level is level 0 as row.lastIndexOf(\"\\\\t\") == - 1\\n        int level = row.lastIndexOf(\"\\\\t\") + 1;\\n\\n        // Go back to the right level getting out of subdirectories\\n        while(level < stack.size()) {\\n            stack.pop();\\n        }\\n\\n        // Remove \\\\t from line\\n        String basename = row.substring(level);\\n        \\n        if (basename.contains(\".\")) {\\n\\t\\t\\t// File case\\n            stack.push(basename);\\n            // Construct full path joining directories and filename with a \"/\"\\n            String fullPath = stack.stream().collect(Collectors.joining(\"/\"));\\n            max = Math.max(fullPath.length(), max);\\n            stack.pop();\\n        } else {\\n            // Directory case\\n            stack.push(basename);\\n        }\\n    }\\n\\n    return max;\\n}\\n```\\n\\n### Optimised\\n\\nThe idea is the same but it\\'s harder to understand IMO. Optimisations are:\\n- Don\\'t store the entire subdirectory `String` but only the length of that string in the stack.\\n- Keep a `currentLength` variable with the sum of all the values in the stack so we don\\'t need to iterate over the entire stack to compute the length of the path.\\n- `currentLength + len + level` means `lenght of subdirectores + length of file name + amount of \"/\"`\\n\\n\\n```\\npublic int lengthLongestPath(String input) {\\n    Stack<Integer> stack = new Stack<>();\\n    int max = 0;\\n    int currentLength = 0;\\n\\n    for (String row : input.split(\"\\\\n\")) {\\n        int level = row.lastIndexOf(\"\\\\t\") + 1;\\n\\n        while(level < stack.size()) {\\n            currentLength -= stack.pop();\\n        }\\n\\n        int len = row.length() - level;\\n\\n        if (row.contains(\".\")) {\\n            max = Math.max(currentLength + len + level, max);\\n        } else {\\n            stack.push(len);\\n            currentLength += len;\\n        }\\n    }\\n\\n    return max;\\n}\\n```\\n\\nHope you liked the explanation!\\n\\nSome shameless self-promotion: My blog where I also post explanations to LeetCode challenges https://pablomusumeci.github.io/",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\npublic int lengthLongestPath(String input) {\\n    // Store each directory\\n    Stack<String> stack = new Stack<>();\\n    int max = 0;\\n\\n    for (String row : input.split(\"\\\\n\")) {\\n        // Store how deep is the current level\\n        // Root level is level 0 as row.lastIndexOf(\"\\\\t\") == - 1\\n        int level = row.lastIndexOf(\"\\\\t\") + 1;\\n\\n        // Go back to the right level getting out of subdirectories\\n        while(level < stack.size()) {\\n            stack.pop();\\n        }\\n\\n        // Remove \\\\t from line\\n        String basename = row.substring(level);\\n        \\n        if (basename.contains(\".\")) {\\n\\t\\t\\t// File case\\n            stack.push(basename);\\n            // Construct full path joining directories and filename with a \"/\"\\n            String fullPath = stack.stream().collect(Collectors.joining(\"/\"));\\n            max = Math.max(fullPath.length(), max);\\n            stack.pop();\\n        } else {\\n            // Directory case\\n            stack.push(basename);\\n        }\\n    }\\n\\n    return max;\\n}\\n```\n```\\npublic int lengthLongestPath(String input) {\\n    Stack<Integer> stack = new Stack<>();\\n    int max = 0;\\n    int currentLength = 0;\\n\\n    for (String row : input.split(\"\\\\n\")) {\\n        int level = row.lastIndexOf(\"\\\\t\") + 1;\\n\\n        while(level < stack.size()) {\\n            currentLength -= stack.pop();\\n        }\\n\\n        int len = row.length() - level;\\n\\n        if (row.contains(\".\")) {\\n            max = Math.max(currentLength + len + level, max);\\n        } else {\\n            stack.push(len);\\n            currentLength += len;\\n        }\\n    }\\n\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1543600,
                "title": "java-dfs-recursion-solution",
                "content": "\\n```\\nclass Solution {\\n    \\n    int max = 0;\\n    \\n    public int lengthLongestPath(String input) {\\n        String[] pathes = input.split(\"\\\\n\");\\n        dfs(-1, pathes, 0, 0);\\n        return this.max;\\n    }\\n    \\n    public void dfs(int length, String[] arr, int ind, int level){\\n        for (int i = ind; i < arr.length; i++){\\n            int current = length;\\n            if (countTabs(arr[i]) == level) {\\n                current += arr[i].length() - level + 1;\\n                if (isFile(arr[i])){\\n                    max = Math.max(current, max);\\n                }\\n                dfs(current, arr, i + 1, level + 1);\\n            }\\n            if (countTabs(arr[i]) < level){\\n                break;\\n            }\\n        }\\n    }\\n    \\n    public int countTabs(String s){\\n        int count = 0; int i = 0;\\n        while (s.charAt(i++) == \\'\\\\t\\'){\\n            count++;\\n        }\\n        return count;\\n    }\\n    \\n    public boolean isFile(String s){\\n        for (int i = 0; i < s.length(); i++){\\n            if (s.charAt(i) == \\'.\\') return true;\\n        }\\n\\n        return false;\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int max = 0;\\n    \\n    public int lengthLongestPath(String input) {\\n        String[] pathes = input.split(\"\\\\n\");\\n        dfs(-1, pathes, 0, 0);\\n        return this.max;\\n    }\\n    \\n    public void dfs(int length, String[] arr, int ind, int level){\\n        for (int i = ind; i < arr.length; i++){\\n            int current = length;\\n            if (countTabs(arr[i]) == level) {\\n                current += arr[i].length() - level + 1;\\n                if (isFile(arr[i])){\\n                    max = Math.max(current, max);\\n                }\\n                dfs(current, arr, i + 1, level + 1);\\n            }\\n            if (countTabs(arr[i]) < level){\\n                break;\\n            }\\n        }\\n    }\\n    \\n    public int countTabs(String s){\\n        int count = 0; int i = 0;\\n        while (s.charAt(i++) == \\'\\\\t\\'){\\n            count++;\\n        }\\n        return count;\\n    }\\n    \\n    public boolean isFile(String s){\\n        for (int i = 0; i < s.length(); i++){\\n            if (s.charAt(i) == \\'.\\') return true;\\n        }\\n\\n        return false;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390857,
                "title": "java-solution-with-stack",
                "content": "```\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        \\n        if(input == null || input.isEmpty()) return 0;\\n        \\n        String dirsOrFiles[] = input.split(\"\\\\n\");\\n        \\n        int ans = 0;\\n        Stack<String> stk = new Stack<>();\\n\\n        int count = 0;\\n        for(int i = 0; i < dirsOrFiles.length ; i++){\\n            \\n                String dir[] = dirsOrFiles[i].split(\"\\\\t\");\\n                int depth = dir.length -1;\\n                \\n                // get back till parent foldet of current dir/file\\n                while(!stk.isEmpty() && stk.size() > depth){\\n                    String folder = stk.pop();\\n                    count = count - folder.length() - 1;\\n                }\\n            \\n                \\n                if(dirsOrFiles[i].contains(\".\")){\\n                    ans = Math.max( ans, count + dir[depth].length());\\n                }else{\\n                    //add folder to stack\\n                    count += dir[depth].length()+1;\\n                    stk.push(dir[depth]);\\n                }\\n                \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        \\n        if(input == null || input.isEmpty()) return 0;\\n        \\n        String dirsOrFiles[] = input.split(\"\\\\n\");\\n        \\n        int ans = 0;\\n        Stack<String> stk = new Stack<>();\\n\\n        int count = 0;\\n        for(int i = 0; i < dirsOrFiles.length ; i++){\\n            \\n                String dir[] = dirsOrFiles[i].split(\"\\\\t\");\\n                int depth = dir.length -1;\\n                \\n                // get back till parent foldet of current dir/file\\n                while(!stk.isEmpty() && stk.size() > depth){\\n                    String folder = stk.pop();\\n                    count = count - folder.length() - 1;\\n                }\\n            \\n                \\n                if(dirsOrFiles[i].contains(\".\")){\\n                    ans = Math.max( ans, count + dir[depth].length());\\n                }else{\\n                    //add folder to stack\\n                    count += dir[depth].length()+1;\\n                    stk.push(dir[depth]);\\n                }\\n                \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065857,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        unordered_map<int,int>map;\\n        stringstream ss(input);\\n        string directory;\\n        map[0]=0;\\n        int result{0};\\n        while(getline(ss,directory))\\n        {\\n            int level=directory.find_last_of(\\'\\\\t\\')+1;\\n            int length=directory.size()-level;\\n            if(directory.find(\\'.\\')!=string::npos)\\n            {\\n                result=max(result,map[level]+length);\\n            }\\n            else\\n            {\\n                map[level+1]=map[level]+length+1;\\n            }\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        unordered_map<int,int>map;\\n        stringstream ss(input);\\n        string directory;\\n        map[0]=0;\\n        int result{0}",
                "codeTag": "Java"
            },
            {
                "id": 864425,
                "title": "straightforward-java-solution-w-stack",
                "content": "```\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        String[] system = input.split(\"\\\\n\");\\n        Stack<Integer> stack = new Stack<>();\\n        int max_len = 0;\\n        for (int i=0; i<system.length; i++) {\\n            int name_len = system[i].replaceAll(\"\\\\t\",\"\").length(),\\n                level = system[i].length()-name_len;\\n            while (stack.size()!=level) stack.pop();\\n            int total_len = stack.isEmpty()?name_len:stack.peek()+name_len+1;\\n            if (system[i].contains(\".\"))\\n                max_len = Math.max(max_len,total_len);\\n            else stack.push(total_len);\\n        }\\n        return max_len;\\n    }\\n}\\n```\\n\\nOpen to suggestions on any optimizations! :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        String[] system = input.split(\"\\\\n\");\\n        Stack<Integer> stack = new Stack<>();\\n        int max_len = 0;\\n        for (int i=0; i<system.length; i++) {\\n            int name_len = system[i].replaceAll(\"\\\\t\",\"\").length(),\\n                level = system[i].length()-name_len;\\n            while (stack.size()!=level) stack.pop();\\n            int total_len = stack.isEmpty()?name_len:stack.peek()+name_len+1;\\n            if (system[i].contains(\".\"))\\n                max_len = Math.max(max_len,total_len);\\n            else stack.push(total_len);\\n        }\\n        return max_len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856079,
                "title": "modern-c-0ms-with-stack-and-string-view",
                "content": "Each subdirectory `depth` is recorded in a stack `depth_size`. \\nThe `depth` is then equal to the number of tabs in any given path. `string_view` is used for easily keeping track of ranges.\\n```c++\\nclass Solution {\\n    stack<int> depth_sizes;\\n    size_t longest = 0;\\npublic:\\n    bool is_file(string_view path) {\\n        return path.find(\\'.\\') != string::npos;\\n    }\\n    \\n    void process_path(string_view path) {\\n        auto indent = path.find_first_not_of(\\'\\\\t\\');\\n        while (depth_sizes.size() > indent) depth_sizes.pop();\\n        path = path.substr(indent);\\n        \\n        auto depth = depth_sizes.empty() ? 0 : depth_sizes.top();\\n        if (is_file(path)) {\\n            longest = max(longest, depth + path.size());\\n        } else {\\n            // plus 1 for the forward slash\\n            depth_sizes.push(depth + path.size() + 1);\\n        }\\n    }\\n    \\n    int lengthLongestPath(string_view input) {\\n        size_t start = 0, end = 0;\\n        // split by newline and process each path\\n        do {\\n            end = input.find(\\'\\\\n\\', start);\\n            process_path(input.substr(start, end - start));\\n            start = end + 1;\\n        } while (end != string::npos);\\n        return longest;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```c++\\nclass Solution {\\n    stack<int> depth_sizes;\\n    size_t longest = 0;\\npublic:\\n    bool is_file(string_view path) {\\n        return path.find(\\'.\\') != string::npos;\\n    }\\n    \\n    void process_path(string_view path) {\\n        auto indent = path.find_first_not_of(\\'\\\\t\\');\\n        while (depth_sizes.size() > indent) depth_sizes.pop();\\n        path = path.substr(indent);\\n        \\n        auto depth = depth_sizes.empty() ? 0 : depth_sizes.top();\\n        if (is_file(path)) {\\n            longest = max(longest, depth + path.size());\\n        } else {\\n            // plus 1 for the forward slash\\n            depth_sizes.push(depth + path.size() + 1);\\n        }\\n    }\\n    \\n    int lengthLongestPath(string_view input) {\\n        size_t start = 0, end = 0;\\n        // split by newline and process each path\\n        do {\\n            end = input.find(\\'\\\\n\\', start);\\n            process_path(input.substr(start, end - start));\\n            start = end + 1;\\n        } while (end != string::npos);\\n        return longest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 771978,
                "title": "standard-java-solution",
                "content": "### Theory\\nNotice how we need go down this file path almost recursivley, depth first. The problem really isn\\'t recursive by nature, (we certainly can implement it that way though), but its much easier to emulate DFS using a stack. We need to only consider the max length when we hit a file. Don\\'t forget to consider how `/` character will effect yoru count.\\n\\n### Solution\\n```\\n    public int lengthLongestPath(String input) {\\n        String[] tokenString = input.split(\"\\\\n\");\\n        Stack<Token> stack = new Stack<>();\\n        int count = 0, max = 0;\\n        \\n        for (int i = 0; i < tokenString.length; i++) {\\n            Token token = tokenize(tokenString[i]);\\n            while (!stack.isEmpty() && stack.peek().level >= token.level) \\n                count -= (stack.pop().word.length() + 1);\\n            \\n            stack.push(token);\\n            count += token.word.length() + 1;\\n            if (token.isFile) max = Math.max(max, count - 1);\\n        }\\n        \\n        return stack.peek().isFile ? Math.max(max, count - 1) :  0;\\n    }\\n    \\n    private Token tokenize(String token) {\\n        String s = token.replace(\"\\\\t\", \"\");\\n        int level = token.length() - s.length();\\n        return new Token(s, level, s.contains(\".\"));\\n    }\\n    \\n    private class Token {\\n        private String word;\\n        private int level;\\n        private boolean isFile;\\n        \\n        public Token(String word, int level, boolean isFile) {\\n            this.word = word;\\n            this.level = level;\\n            this.isFile = isFile;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int lengthLongestPath(String input) {\\n        String[] tokenString = input.split(\"\\\\n\");\\n        Stack<Token> stack = new Stack<>();\\n        int count = 0, max = 0;\\n        \\n        for (int i = 0; i < tokenString.length; i++) {\\n            Token token = tokenize(tokenString[i]);\\n            while (!stack.isEmpty() && stack.peek().level >= token.level) \\n                count -= (stack.pop().word.length() + 1);\\n            \\n            stack.push(token);\\n            count += token.word.length() + 1;\\n            if (token.isFile) max = Math.max(max, count - 1);\\n        }\\n        \\n        return stack.peek().isFile ? Math.max(max, count - 1) :  0;\\n    }\\n    \\n    private Token tokenize(String token) {\\n        String s = token.replace(\"\\\\t\", \"\");\\n        int level = token.length() - s.length();\\n        return new Token(s, level, s.contains(\".\"));\\n    }\\n    \\n    private class Token {\\n        private String word;\\n        private int level;\\n        private boolean isFile;\\n        \\n        public Token(String word, int level, boolean isFile) {\\n            this.word = word;\\n            this.level = level;\\n            this.isFile = isFile;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719591,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        unordered_map<int,int> m; // sum of \\n        int indent = 0;\\n        int ret = 0;\\n        string str;\\n        bool dir = true; \\n        for(int i = 0;i<input.size();i++) {\\n            if(input[i] == \\'\\\\n\\') {\\n                if(dir) {\\n                    m[indent] = str.size() + m[indent-1];\\n                } else {\\n                    ret = max(ret,m[indent-1]+(int)str.size()+indent);\\n                }\\n                dir = true; \\n                str.clear();\\n                indent = 0;\\n            } else if (input[i] == \\'\\\\t\\') {\\n                indent++;\\n            } else {\\n                if(input[i] == \\'.\\') {\\n                    dir = false; \\n                }\\n                str += input[i];\\n            }\\n        }\\n        if(!dir) {\\n            ret = max(ret,m[indent-1] + (int)str.size() + indent);\\n        }\\n        return ret; \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        unordered_map<int,int> m; // sum of \\n        int indent = 0;\\n        int ret = 0;\\n        string str;\\n        bool dir = true; \\n        for(int i = 0;i<input.size();i++) {\\n            if(input[i] == \\'\\\\n\\') {\\n                if(dir) {\\n                    m[indent] = str.size() + m[indent-1];\\n                } else {\\n                    ret = max(ret,m[indent-1]+(int)str.size()+indent);\\n                }\\n                dir = true; \\n                str.clear();\\n                indent = 0;\\n            } else if (input[i] == \\'\\\\t\\') {\\n                indent++;\\n            } else {\\n                if(input[i] == \\'.\\') {\\n                    dir = false; \\n                }\\n                str += input[i];\\n            }\\n        }\\n        if(!dir) {\\n            ret = max(ret,m[indent-1] + (int)str.size() + indent);\\n        }\\n        return ret; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702668,
                "title": "short-javascript-solution-o-n-o-n",
                "content": "`local` - has the length of the strings. Which is based on the current path length + the past one.\\nWe only compare it to `max` when there\\'s a file extension: `.` \\n\\n```js\\nfunction lengthLongestPath (input) {\\n  let max = 0;\\n  let local = [];\\n  \\n  for (let line of input.split(\\'\\\\n\\')) {\\n    const depth = [...line].lastIndexOf(\\'\\\\t\\') + 1;\\n    local[depth] = (local[depth - 1]||0) + line.length - depth;\\n    if (line.indexOf(\\'.\\') > -1) max = Math.max(max, local[depth] + depth);\\n  }\\n  \\n  return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nfunction lengthLongestPath (input) {\\n  let max = 0;\\n  let local = [];\\n  \\n  for (let line of input.split(\\'\\\\n\\')) {\\n    const depth = [...line].lastIndexOf(\\'\\\\t\\') + 1;\\n    local[depth] = (local[depth - 1]||0) + line.length - depth;\\n    if (line.indexOf(\\'.\\') > -1) max = Math.max(max, local[depth] + depth);\\n  }\\n  \\n  return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 552257,
                "title": "swift-hashmap-solution",
                "content": "```\\nclass Solution {\\n    func lengthLongestPath(_ input: String) -> Int {\\n        let lines = input.components(separatedBy: \"\\\\n\")\\n        var maxLen = 0\\n        var map:[Int:Int] = [0:0]\\n        for line in lines{\\n            let path = line.components(separatedBy: \"\\\\t\").last!\\n            let depth = line.count - path.count\\n            if path.contains(\".\"){\\n                maxLen = max(maxLen, map[depth]! + path.count)\\n            }else{\\n                map[depth+1] = map[depth]! + path.count + 1\\n            }\\n        }\\n        return maxLen\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func lengthLongestPath(_ input: String) -> Int {\\n        let lines = input.components(separatedBy: \"\\\\n\")\\n        var maxLen = 0\\n        var map:[Int:Int] = [0:0]\\n        for line in lines{\\n            let path = line.components(separatedBy: \"\\\\t\").last!\\n            let depth = line.count - path.count\\n            if path.contains(\".\"){\\n                maxLen = max(maxLen, map[depth]! + path.count)\\n            }else{\\n                map[depth+1] = map[depth]! + path.count + 1\\n            }\\n        }\\n        return maxLen\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427638,
                "title": "python-10-line-solution-no-magic",
                "content": "length==length for all tabs + number of \\'/\\'.\\n```\\nclass Solution(object):\\n    def lengthLongestPath(self, inputs):\\n        tabnum2leng={}#record each tab\\'s directory\\n        inputs=inputs.split(\"\\\\n\")\\n        res=0\\n        for s in inputs:\\n            tab_num=s.count(\"\\\\t\")\\n            s=s[tab_num:]\\n            if \\'.\\' not in s:#directory\\n                tabnum2leng[tab_num]=len(s)\\n            else:\\n                res=max(res,sum(tabnum2leng[num] for num in range(tab_num))+tab_num+len(s))  \\n        return res",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def lengthLongestPath(self, inputs):\\n        tabnum2leng={}",
                "codeTag": "Java"
            },
            {
                "id": 359421,
                "title": "simple-python-3-solution-faster-than-100",
                "content": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n\\t# Split the input by lines.\\n        input = input.split(\\'\\\\n\\')\\n        st = []\\n        res = 0\\n\\t\\t\\n        for i in input:\\n\\t\\t#  \\'\\\\t\\' will give the level at which this line input is.\\n            t = i.count(\\'\\\\t\\')\\n\\t\\t\\t\\n\\t\\t# Remove all the saved answers which have level equal or greater.\\n\\t\\t# In other words, Find the parent.\\n\\t\\t\\n            while st and st[-1][1] >=  t:\\n                st.pop()\\n                \\n\\t\\t# The absolute path till here will be  parent + \\'/\\' + the value of this line - \\'\\\\t\\' :\\n            newString = st[-1][0] + \\'/\\' +  i.lstrip(\\'\\\\t\\') if st else \\'\\' + i\\n\\t\\t\\t\\n\\t\\t# If this has \\'.\\' in it, note the length of the solution.\\n\\t\\t\\n            if \".\" in newString:\\n                res = max(res , len(newString))\\n\\t\\t# Add the newly created path to the stack.\\n\\t\\t\\n            st.append([ newString , t])\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n\\t# Split the input by lines.\\n        input = input.split(\\'\\\\n\\')\\n        st = []\\n        res = 0\\n\\t\\t\\n        for i in input:\\n\\t\\t#  \\'\\\\t\\' will give the level at which this line input is.\\n            t = i.count(\\'\\\\t\\')\\n\\t\\t\\t\\n\\t\\t# Remove all the saved answers which have level equal or greater.\\n\\t\\t# In other words, Find the parent.\\n\\t\\t\\n            while st and st[-1][1] >=  t:\\n                st.pop()\\n                \\n\\t\\t# The absolute path till here will be  parent + \\'/\\' + the value of this line - \\'\\\\t\\' :\\n            newString = st[-1][0] + \\'/\\' +  i.lstrip(\\'\\\\t\\') if st else \\'\\' + i\\n\\t\\t\\t\\n\\t\\t# If this has \\'.\\' in it, note the length of the solution.\\n\\t\\t\\n            if \".\" in newString:\\n                res = max(res , len(newString))\\n\\t\\t# Add the newly created path to the stack.\\n\\t\\t\\n            st.append([ newString , t])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354216,
                "title": "can-someone-tell-me-how-to-pass-this-case",
                "content": "I split the input first by \\'\\\\n\\': String[] arr = input.split(\"\\\\n\");\\nthen I count the number of indents of each line:\\n```\\n    private int indentOf(String s){\\n        int count = 0;\\n        while(s.charAt(count)==\\'\\\\t\\'){\\n            count++;\\n        }\\n        return count;\\n    }\\n```\\nthen I failed a test case: \\n\"dir\\\\n    file.txt\"\\nthe expected answer is 12\\n![image](https://assets.leetcode.com/users/ch_z/image_1565306658.png)\\n\\nbut my code shows that there are no \\'\\\\t\\' but only four leading spaces on the second line \"    file.txt\". why would this case be valid?\\n\\nThe more strange thing is, I changed my code to consider spaces as part of indent, then I failed a new case: \"dir\\\\n        file.txt\", where the middle blank part is combined by two spaces+indent+two spaces, the answer is 16.\\n![image](https://assets.leetcode.com/users/ch_z/image_1565307475.png)\\n\\nmy code works well for cases like \"dir\\\\n\\\\tfile.txt\" which uses \\'\\\\t\\' to represent indents, but failed for the above two cases.",
                "solutionTags": [],
                "code": "```\\n    private int indentOf(String s){\\n        int count = 0;\\n        while(s.charAt(count)==\\'\\\\t\\'){\\n            count++;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 292977,
                "title": "python-simple-solution-32ms",
                "content": "```\\n    def lengthLongestPath(self, input):\\n        \"\"\"\\n        :type input: str\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        lst = input.split(\\'\\\\n\\')\\n        path = []\\n        for s in lst:\\n            curr_level = 0\\n            while s[curr_level] == \\'\\\\t\\':\\n                curr_level += 1\\n            name = s[curr_level:]\\n            if \\'.\\' in name: # it is a file\\n                file_path = \\'/\\'.join(path[:curr_level] + [name])\\n                #print(file_path)\\n                res = max(res, len(file_path))\\n            else:\\n                if curr_level + 1 > len(path):\\n                    path.append(name)\\n                else:\\n                    path[curr_level] = name\\n                    path = path[:curr_level+1]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def lengthLongestPath(self, input):\\n        \"\"\"\\n        :type input: str\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        lst = input.split(\\'\\\\n\\')\\n        path = []\\n        for s in lst:\\n            curr_level = 0\\n            while s[curr_level] == \\'\\\\t\\':\\n                curr_level += 1\\n            name = s[curr_level:]\\n            if \\'.\\' in name: # it is a file\\n                file_path = \\'/\\'.join(path[:curr_level] + [name])\\n                #print(file_path)\\n                res = max(res, len(file_path))\\n            else:\\n                if curr_level + 1 > len(path):\\n                    path.append(name)\\n                else:\\n                    path[curr_level] = name\\n                    path = path[:curr_level+1]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 291639,
                "title": "ruby-hashmap-solution",
                "content": "````ruby\\n# @param {String} input\\n# @return {Integer}\\ndef length_longest_path(input)\\n    length_by_level = {-1 => 0}\\n    max_length = 0\\n    input.split(\"\\\\n\").each do |line|\\n        level = line.count(\"\\\\t\")\\n        line_length = line.length - level\\n        if line.include?(\\'.\\')\\n            max_length = [max_length, length_by_level[level - 1] + line_length].max\\n        else\\n            length_by_level[level] = length_by_level[level - 1] + line_length + 1 #add 1 for tab length\\n        end\\n    end\\n    \\n    return max_length\\nend\\n````",
                "solutionTags": [],
                "code": "````ruby\\n# @param {String} input\\n# @return {Integer}\\ndef length_longest_path(input)\\n    length_by_level = {-1 => 0}\\n    max_length = 0\\n    input.split(\"\\\\n\").each do |line|\\n        level = line.count(\"\\\\t\")\\n        line_length = line.length - level\\n        if line.include?(\\'.\\')\\n            max_length = [max_length, length_by_level[level - 1] + line_length].max\\n        else\\n            length_by_level[level] = length_by_level[level - 1] + line_length + 1 #add 1 for tab length\\n        end\\n    end\\n    \\n    return max_length\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 190504,
                "title": "easy-to-understand-beats-100-java-solution-using-map",
                "content": "* split the input string by newline character \\\\n.\\n* For each string, count the number of tabspaces \\'\\\\t\\' and retrieve the previous filepath from map for the key \"tabcount-1\" and append to current string and finally store the new string in a hashmap with count.\\n* In each iteration, if the newly formed absolute filepath string contains a \\'.\\', consider them to be one one of the answer by maintaining the max count.\\n```\\npublic int lengthLongestPath(String input) {\\n        HashMap<Integer,String> hMap = new HashMap<>();\\n        String[] inputs = input.split(\"\\\\n\");\\n        int max = 0;\\n        for(int i=0;i<inputs.length;i++)\\n        {\\n            String cur = inputs[i];\\n            int j=0;\\n            int tabCount = 0;\\n            while(j<cur.length())\\n            {\\n                if(cur.charAt(j)==\\'\\\\t\\')\\n                    ++tabCount;\\n                else\\n                    break;\\n                ++j;\\n            }\\n            \\n            String newString = \"\";\\n            \\n            if(tabCount==0)\\n            {\\n                newString = cur;            \\n            }\\n            else\\n                newString = hMap.getOrDefault(tabCount-1,\"\")+\"/\"+cur.substring(j);\\n\\n            if(cur.indexOf(\".\")>=0)\\n            {\\n                max = Math.max(max,newString.length());\\n            }\\n            hMap.put(tabCount,newString);\\n        }\\n        return max;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int lengthLongestPath(String input) {\\n        HashMap<Integer,String> hMap = new HashMap<>();\\n        String[] inputs = input.split(\"\\\\n\");\\n        int max = 0;\\n        for(int i=0;i<inputs.length;i++)\\n        {\\n            String cur = inputs[i];\\n            int j=0;\\n            int tabCount = 0;\\n            while(j<cur.length())\\n            {\\n                if(cur.charAt(j)==\\'\\\\t\\')\\n                    ++tabCount;\\n                else\\n                    break;\\n                ++j;\\n            }\\n            \\n            String newString = \"\";\\n            \\n            if(tabCount==0)\\n            {\\n                newString = cur;            \\n            }\\n            else\\n                newString = hMap.getOrDefault(tabCount-1,\"\")+\"/\"+cur.substring(j);\\n\\n            if(cur.indexOf(\".\")>=0)\\n            {\\n                max = Math.max(max,newString.length());\\n            }\\n            hMap.put(tabCount,newString);\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 168840,
                "title": "concise-c-solution-using-stack-with-explanation",
                "content": "Before diving into the solution, firstly, you should know that the given stirng is actually a **pre-order traversal** of a file tree. \\n(1) by counting the number of `\\\\t`, you can know which level of the tree the current file(directory) in.\\n(2) due to the fact it is a pre-order traversal, you can **use `stack` to simulate the traversal process**:\\nif the level of the current file(dir) is greater than that of  stack top, just push it to the stack. \\notherwise, keep `pop` operation until the level of stack\\'s top element  is smaller than the current level.(this is actually a simulation to the retreat action)\\nPS:\\nA trick used here: the stack\\'s size can represent the level of the level of stack\\'s top element.\\n\\n\\n```C++\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        vector<string> s; // use vector to simulate a stack\\n        string name; int level = 0, maxl = 0, flg = 0;\\n        for(int i = 0; i < input.size();){\\n            if(input[i] == \\'\\\\n\\'){\\n                for(level = 0, ++i; input[i] == \\'\\\\t\\'; ++i ) level++;\\n                for(name = \"\"; input[i] != \\'\\\\n\\'&& i < input.size(); i++) name += input[i];\\n                if(level >= s.size()) s.push_back(name);\\n                else{\\n                    if(!isDir(s.back())) maxl = max(maxl, sum(s) + (int)s.size() - 1);\\n                    while(s.size() > level) s.pop_back();\\n                    s.push_back(name);\\n                } \\n            }\\n            else{\\n                for(name = \"\"; input[i] != \\'\\\\n\\' && i < input.size(); i++) name += input[i];  \\n                s.push_back(name);\\n            }\\n        }\\n        return !isDir(s.back())? max(maxl,sum(s) + (int)s.size() - 1): maxl;\\n    }\\n    int sum(vector<string>& s){\\n        int ret = 0;\\n        for(auto i:s) ret += i.size();\\n        return ret;\\n    }\\n    int isDir(string& f){\\n        return find(f.begin(), f.end(), \\'.\\') == f.end() ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        vector<string> s; // use vector to simulate a stack\\n        string name; int level = 0, maxl = 0, flg = 0;\\n        for(int i = 0; i < input.size();){\\n            if(input[i] == \\'\\\\n\\'){\\n                for(level = 0, ++i; input[i] == \\'\\\\t\\'; ++i ) level++;\\n                for(name = \"\"; input[i] != \\'\\\\n\\'&& i < input.size(); i++) name += input[i];\\n                if(level >= s.size()) s.push_back(name);\\n                else{\\n                    if(!isDir(s.back())) maxl = max(maxl, sum(s) + (int)s.size() - 1);\\n                    while(s.size() > level) s.pop_back();\\n                    s.push_back(name);\\n                } \\n            }\\n            else{\\n                for(name = \"\"; input[i] != \\'\\\\n\\' && i < input.size(); i++) name += input[i];  \\n                s.push_back(name);\\n            }\\n        }\\n        return !isDir(s.back())? max(maxl,sum(s) + (int)s.size() - 1): maxl;\\n    }\\n    int sum(vector<string>& s){\\n        int ret = 0;\\n        for(auto i:s) ret += i.size();\\n        return ret;\\n    }\\n    int isDir(string& f){\\n        return find(f.begin(), f.end(), \\'.\\') == f.end() ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 140839,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        stringstream ss(input);\\n        string line;\\n\\n        vector<int> dirLen;\\n        int res = 0;\\n        \\n        while (getline(ss, line, \\'\\\\n\\')) {\\n            bool isDir = true;\\n            if (line.find(\".\") != string::npos) {\\n                isDir = false;\\n            }\\n            \\n            if (isDir) {\\n                int i = 0;\\n                for (; i<line.size() && line[i]==\\'\\\\t\\'; i++);\\n                if (i < dirLen.size()) {\\n                    dirLen[i] = line.substr(i).size();\\n                } else {\\n                    dirLen.push_back(line.substr(i).size());\\n                }\\n            } else {\\n                int i = 0;\\n                int len = 0;\\n                for (; i<line.size() && line[i]==\\'\\\\t\\'; i++) {\\n                    len += dirLen[i]+1;\\n                }\\n                len += line.substr(i).size();\\n                res = max(len, res);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        stringstream ss(input);\\n        string line;\\n\\n        vector<int> dirLen;\\n        int res = 0;\\n        \\n        while (getline(ss, line, \\'\\\\n\\')) {\\n            bool isDir = true;\\n            if (line.find(\".\") != string::npos) {\\n                isDir = false;\\n            }\\n            \\n            if (isDir) {\\n                int i = 0;\\n                for (; i<line.size() && line[i]==\\'\\\\t\\'; i++);\\n                if (i < dirLen.size()) {\\n                    dirLen[i] = line.substr(i).size();\\n                } else {\\n                    dirLen.push_back(line.substr(i).size());\\n                }\\n            } else {\\n                int i = 0;\\n                int len = 0;\\n                for (; i<line.size() && line[i]==\\'\\\\t\\'; i++) {\\n                    len += dirLen[i]+1;\\n                }\\n                len += line.substr(i).size();\\n                res = max(len, res);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86623,
                "title": "there-seems-to-be-a-wrong-test-case-in-the-code-submission-the-test-case-dir-n-file-txt-should-give-12-but-the-expected-output-is-given-16-can-someone-clarify-this",
                "content": "\\npublic class Solution {\\n    \\n    boolean isFileName(String input)\\n    {\\n        boolean result = false;\\n        if(input.length() < 4)\\n            return result;\\n        if('.' == input.charAt(input.length()-4))\\n            result = true;\\n        if('.' == input.charAt(input.length()-3) && input.endsWith(\"gz\"))\\n            result = true;\\n        return result;\\n    }\\n    \\n    public int lengthLongestPath(String input) {     \\n        \\n        String [] fileNames = input.split(\"\\\\\\\\n\");\\n        StringBuilder [] longestFiles = new StringBuilder[fileNames.length];\\n        int longestLength = 0;\\n        Node root = null ;\\n        \\n        Label: for (String s : fileNames)\\n        {\\n            int count = s.lastIndexOf('\\\\t');\\n            String name = s.substring(count+1);\\n            if (!isFileName(name))\\n            {\\n                Node dir = new Node(name);\\n                if( count == -1 )\\n                {\\n                  root = dir;\\n                  root.length = root.name.length();\\n                  continue;                \\n                }\\n              int length = root.traverse(count, dir, root);\\n            }\\n            else\\n            {\\n                name = name.trim();\\n                 Node file = new Node(name);\\n              int length = 0;\\n              if(root == null)\\n              {\\n                length = file.length = name.length();\\n \\n              }\\n              else\\n              {\\n                 length = root.traverse(count, file, root);\\n              }\\n                if(longestLength < length)\\n                  \\n                {\\n                    longestLength = length;\\n                }\\n            }\\n        }\\n        return longestLength;  \\n    }\\n  \\n  public static void main(String []args)\\n  {\\n    int length = new Solution().lengthLongestPath(\"dir\\\\n\\\\tsubdir1\\\\n\\\\tsubdir2\\\\n\\\\t\\\\tfile.ext\");\\n  }\\n}\\n\\nclass Node\\n{\\n    String name;\\n    int length;\\n    ArrayList<Node> child = new ArrayList<Node>();\\n    \\n    public Node()\\n    {\\n        \\n    }\\n    public Node(String name)\\n    {\\n        this.name = name;\\n    }\\n    public void addChild(Node childNode)\\n    {\\n        this.child.add(childNode);\\n    }\\n    \\n    public int traverse(int index, Node node, Node root)\\n    {\\n        Node current = root;\\n        int prevLength = root.length;\\n        while(index > 0)\\n        {\\n          if(current.child.size() > 0) {\\n            current = current.child.get((current.child.size())-1);\\n            prevLength = current.length;\\n          }\\n          else\\n          {\\n            prevLength = prevLength + 1;\\n          }      \\n            index--;\\n        }       \\n        node.length = prevLength + 1 + node.name.length();        \\n        current.addChild(node);\\n        return node.length;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    boolean isFileName(String input)\\n    {\\n        boolean result = false;\\n        if(input.length() < 4)\\n            return result;\\n        if('.' == input.charAt(input.length()-4))\\n            result = true;\\n        if('.' == input.charAt(input.length()-3) && input.endsWith(\"gz\"))\\n            result = true;\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 86696,
                "title": "python-with-stack",
                "content": "Not as cool as [this one](https://discuss.leetcode.com/topic/55097/simple-python-solution) but thought I'd post anyways.\\n```\\nclass Solution(object):\\n    def lengthLongestPath(self, input):\\n        stack,mx = collections.deque(),0\\n        for line in input.splitlines():\\n            tabCount = line.count('\\\\t')\\n            for _ in xrange(len(stack)-tabCount):\\n                stack.pop()\\n            length = (stack[-1]+1 if len(stack) > 0 else 0) + len(line) - tabCount\\n            if '.' in line:\\n                mx = max(mx,length)\\n            else:\\n                stack.append(length)\\n        return mx",
                "solutionTags": [],
                "code": "Not as cool as [this one](https://discuss.leetcode.com/topic/55097/simple-python-solution) but thought I'd post anyways.\\n```\\nclass Solution(object):\\n    def lengthLongestPath(self, input):\\n        stack,mx = collections.deque(),0\\n        for line in input.splitlines():\\n            tabCount = line.count('\\\\t')\\n            for _ in xrange(len(stack)-tabCount):\\n                stack.pop()\\n            length = (stack[-1]+1 if len(stack) > 0 else 0) + len(line) - tabCount\\n            if '.' in line:\\n                mx = max(mx,length)\\n            else:\\n                stack.append(length)\\n        return mx",
                "codeTag": "Java"
            },
            {
                "id": 86721,
                "title": "java-stack-and-dp-solution",
                "content": "Stack Solution\\n```\\n    public int lengthLongestPath(String input) {\\n        \\n        int max = 0;\\n        String[] dirs = input.split(\"\\\\n\");\\n        Deque<Integer> stack = new ArrayDeque<>(); // stores the length of dir/file till the current level\\n        \\n        for(int i = 0; i < dirs.length; i++) {\\n            \\n            int level = dirs[i].lastIndexOf('\\\\t')+1;\\n            int curLen = dirs[i].length()-level+1;// we treat it as dir/\\n            \\n            while(level < stack.size()) {\\n                stack.pop();\\n            }\\n            \\n            if(!stack.isEmpty()) {\\n                curLen += stack.peek();\\n            }\\n            stack.push(curLen);\\n            \\n            if(dirs[i].contains(\".\")) {\\n                max = Math.max(max, stack.pop()-1);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n```\\ndp solution\\n```\\n    public int lengthLongestPath(String input) {\\n        \\n        //dynamic programming\\n        \\n        int maxLen = 0;\\n        String[] dirs = input.split(\"\\\\n\");\\n        int[] dp = new int[dirs.length]; // length at each level, we can have dirs.length level at most\\n        \\n        for(int i = 0; i < dirs.length; i++) {\\n            \\n            String dir = dirs[i];\\n            int level = dir.lastIndexOf('\\\\t') + 1; //could it be '\\\\t'?\\n            \\n            dp[level] = dir.length() - level+1;\\n            if(level - 1 >= 0) {\\n                dp[level] += dp[level-1];\\n            }\\n            \\n            if(dir.contains(\".\")) {\\n                maxLen = Integer.max(maxLen, dp[level]-1);\\n            }\\n        }\\n        \\n        return maxLen;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int lengthLongestPath(String input) {\\n        \\n        int max = 0;\\n        String[] dirs = input.split(\"\\\\n\");\\n        Deque<Integer> stack = new ArrayDeque<>(); // stores the length of dir/file till the current level\\n        \\n        for(int i = 0; i < dirs.length; i++) {\\n            \\n            int level = dirs[i].lastIndexOf('\\\\t')+1;\\n            int curLen = dirs[i].length()-level+1;// we treat it as dir/\\n            \\n            while(level < stack.size()) {\\n                stack.pop();\\n            }\\n            \\n            if(!stack.isEmpty()) {\\n                curLen += stack.peek();\\n            }\\n            stack.push(curLen);\\n            \\n            if(dirs[i].contains(\".\")) {\\n                max = Math.max(max, stack.pop()-1);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n```\n```\\n    public int lengthLongestPath(String input) {\\n        \\n        //dynamic programming\\n        \\n        int maxLen = 0;\\n        String[] dirs = input.split(\"\\\\n\");\\n        int[] dp = new int[dirs.length]; // length at each level, we can have dirs.length level at most\\n        \\n        for(int i = 0; i < dirs.length; i++) {\\n            \\n            String dir = dirs[i];\\n            int level = dir.lastIndexOf('\\\\t') + 1; //could it be '\\\\t'?\\n            \\n            dp[level] = dir.length() - level+1;\\n            if(level - 1 >= 0) {\\n                dp[level] += dp[level-1];\\n            }\\n            \\n            if(dir.contains(\".\")) {\\n                maxLen = Integer.max(maxLen, dp[level]-1);\\n            }\\n        }\\n        \\n        return maxLen;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 86694,
                "title": "java-string-easy-some-commends-extensible-4ms",
                "content": "```\\npublic class Solution {\\n    public int lengthLongestPath(String input) {\\n        \\n        //split words\\n        String [] strs = input.split(\"\\\\n\");\\n        \\n        //save each folder name in a full path\\n        String [] path = new String[strs.length+1];\\n        int maxLength = 0;\\n        String maxPath = \"\";\\n        \\n        for(String str : strs){\\n            //check tab count. tab count means that deapth of the folder\\n            int tabCount = str.lastIndexOf(\"\\\\t\") + 1;\\n            \\n            //Get clear folder name by deleting \\\\t from the str. \\n            str=str.substring(tabCount, str.length());\\n            \\n            //If cur string is file\\n            if(str.contains(\".\")) {\\n                //build full path \\n                String currentFullPath = \"\";\\n                for(int i=0; i<tabCount; i++) currentFullPath+=path[i];\\n                currentFullPath+=str;\\n                    \\n                //update full path name. For extensibility purpose.\\n                //currentFullPath.length() > maxLength ? maxPath=currentFullPath : ;\\n            \\n                //update maxLength\\n                maxLength = Math.max(maxLength, currentFullPath.length());\\n            \\n            }else path[tabCount] = str+\"/\";\\n            \\n        }\\n        \\n        return maxLength;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int lengthLongestPath(String input) {\\n        \\n        //split words\\n        String [] strs = input.split(\"\\\\n\");\\n        \\n        //save each folder name in a full path\\n        String [] path = new String[strs.length+1];\\n        int maxLength = 0;\\n        String maxPath = \"\";\\n        \\n        for(String str : strs){\\n            //check tab count. tab count means that deapth of the folder\\n            int tabCount = str.lastIndexOf(\"\\\\t\") + 1;\\n            \\n            //Get clear folder name by deleting \\\\t from the str. \\n            str=str.substring(tabCount, str.length());\\n            \\n            //If cur string is file\\n            if(str.contains(\".\")) {\\n                //build full path \\n                String currentFullPath = \"\";\\n                for(int i=0; i<tabCount; i++) currentFullPath+=path[i];\\n                currentFullPath+=str;\\n                    \\n                //update full path name. For extensibility purpose.\\n                //currentFullPath.length() > maxLength ? maxPath=currentFullPath : ;\\n            \\n                //update maxLength\\n                maxLength = Math.max(maxLength, currentFullPath.length());\\n            \\n            }else path[tabCount] = str+\"/\";\\n            \\n        }\\n        \\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86736,
                "title": "c-solution",
                "content": "C# solution\\n```\\npublic class Solution {\\n    public int LengthLongestPath(string input) {\\n        var lines = input.Split('\\\\n');\\n        var max = 0;\\n        var pathLengthMap = new Dictionary<int, int>();\\n        pathLengthMap.Add(0, 0);\\n        for(int i = 0; i< lines.Length; i++){\\n            var line = lines[i];\\n            var name = line.TrimStart('\\\\t');\\n            var depth = line.Length - name.Length+1;\\n            var length = pathLengthMap[depth - 1];\\n            length += name.Length;\\n            // if is file\\n            if(name.Contains('.')){\\n                max = Math.Max(max, length);\\n            }\\n            else // if is not file\\n            {\\n                length++;        \\n                if(pathLengthMap.ContainsKey(depth)) pathLengthMap[depth] = length;\\n                else pathLengthMap.Add(depth, length);\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LengthLongestPath(string input) {\\n        var lines = input.Split('\\\\n');\\n        var max = 0;\\n        var pathLengthMap = new Dictionary<int, int>();\\n        pathLengthMap.Add(0, 0);\\n        for(int i = 0; i< lines.Length; i++){\\n            var line = lines[i];\\n            var name = line.TrimStart('\\\\t');\\n            var depth = line.Length - name.Length+1;\\n            var length = pathLengthMap[depth - 1];\\n            length += name.Length;\\n            // if is file\\n            if(name.Contains('.')){\\n                max = Math.Max(max, length);\\n            }\\n            else // if is not file\\n            {\\n                length++;        \\n                if(pathLengthMap.ContainsKey(depth)) pathLengthMap[depth] = length;\\n                else pathLengthMap.Add(depth, length);\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86751,
                "title": "java-simple-solution",
                "content": "```\\npublic int lengthLongestPath(String input) {\\n    int longest = 0;\\n    String[] lines = input.split(\"\\\\n\");\\n    int[] lens = new int[lines.length+1];\\n    for(String line: lines) {\\n        String[] subs = line.split(\"\\\\t\");\\n        String cur = subs[subs.length-1];\\n        int len = lens[subs.length-1] + cur.length() + 1;\\n        if(cur.contains(\".\")) longest = Math.max(longest, len-1);\\n        else lens[subs.length] = len;\\n    }\\n    return longest;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic int lengthLongestPath(String input) {\\n    int longest = 0;\\n    String[] lines = input.split(\"\\\\n\");\\n    int[] lens = new int[lines.length+1];\\n    for(String line: lines) {\\n        String[] subs = line.split(\"\\\\t\");\\n        String cur = subs[subs.length-1];\\n        int len = lens[subs.length-1] + cur.length() + 1;\\n        if(cur.contains(\".\")) longest = Math.max(longest, len-1);\\n        else lens[subs.length] = len;\\n    }\\n    return longest;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 86763,
                "title": "13-line-0ms-c-solution-using-string-stream",
                "content": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        vector<int> rec;\\n        int max_val = 0;\\n        stringstream ss(input);\\n        string cur;\\n        while(getline(ss, cur, '\\\\n')){\\n            int i = 0;\\n            while(cur[i] == '\\\\t')++i;\\n            if(i+1 > rec.size())\\n                rec.push_back(0);\\n            rec[i] = (i ? rec[i-1] : 0) + cur.size()-i+1;\\n            if(cur.find('.') != string::npos)max_val = max(max_val, rec[i]-1);\\n        }\\n        return max_val;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        vector<int> rec;\\n        int max_val = 0;\\n        stringstream ss(input);\\n        string cur;\\n        while(getline(ss, cur, '\\\\n')){\\n            int i = 0;\\n            while(cur[i] == '\\\\t')++i;\\n            if(i+1 > rec.size())\\n                rec.push_back(0);\\n            rec[i] = (i ? rec[i-1] : 0) + cur.size()-i+1;\\n            if(cur.find('.') != string::npos)max_val = max(max_val, rec[i]-1);\\n        }\\n        return max_val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86791,
                "title": "concise-java-o-n-solution-use-map",
                "content": "Map to store  the level and the length sum from root to current level.\\nlevel is calculated by how many 't' there.\\nlength is preLevelLengthSum + current path length  and  (  +  1\"/\" if level bigger than 0)\\n\\n\\n    public int lengthLongestPath(String input) {\\n        String[] strs = input.split(\"\\\\n\");\\n        int max = 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        map.put(-1, 0);\\n        for(int i = 0; i < strs.length; i++){\\n            int level =  strs[i].lastIndexOf('\\\\t')  + 1;\\n            int length = map.get(level - 1) + strs[i].length() - level + (level > 0 ? 1 : 0);\\n            if(strs[i].indexOf('.') == -1){\\n                map.put(level, length);\\n            }else{\\n                max = Math.max(length, max);\\n            }\\n        }\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "Map to store  the level and the length sum from root to current level.\\nlevel is calculated by how many 't' there.\\nlength is preLevelLengthSum + current path length  and  (  +  1\"/\" if level bigger than 0)\\n\\n\\n    public int lengthLongestPath(String input) {\\n        String[] strs = input.split(\"\\\\n\");\\n        int max = 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        map.put(-1, 0);\\n        for(int i = 0; i < strs.length; i++){\\n            int level =  strs[i].lastIndexOf('\\\\t')  + 1;\\n            int length = map.get(level - 1) + strs[i].length() - level + (level > 0 ? 1 : 0);\\n            if(strs[i].indexOf('.') == -1){\\n                map.put(level, length);\\n            }else{\\n                max = Math.max(length, max);\\n            }\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 86818,
                "title": "simple-13-line-3ms-java-solution-with-explanation",
                "content": "Basic idea: \\n1) use stack to maintain each layer's length by far\\n2) add up chars between '\\\\n\\\\t' to get file or direction's length (use '.' to distinguish them)\\n3) you either output a candidate pathLen if you got a file, or refresh your stack with the direction\\n4) to prepare for the next round, you have to count what's next file/direction's depth\\n\\nHere is a 4ms version with stack:\\n```\\npublic class Solution {\\n    public int lengthLongestPath(String input) {        \\n        int max = 0, len = input.length(), idx = 0, pathLen = 0, curDepth = 0;\\n        Stack<Integer> stk = new Stack<>(); \\n        while(idx < len){\\n            while(stk.size() > curDepth) pathLen -= stk.pop();\\n            int curLen = 0; curDepth = 0;\\n            boolean isFile = false;\\n\\n            for(;idx < len && input.charAt(idx)!='\\\\n';idx++, curLen++)\\n               if(input.charAt(idx)=='.') isFile = true;\\n            \\n            if(isFile) max = Math.max(max, curLen+pathLen); \\n            else pathLen += stk.push(curLen+1);    \\n\\n            idx++; \\n            for(;idx < len && input.charAt(idx)=='\\\\t'; idx++) curDepth++; \\n        }\\n        return max;        \\n    }    \\n}\\n```\\n\\nA 13-line 3ms version using lookup table rather than Stack, I've played a trick here by naively setting table size as input.length/2+1 so that I can use a more primitive typed structure. BTW It's more reasonable to use ArrayList for it's auto increasing nature, but the outcome is 5ms+ probably due to the feature of test cases and the inner cost of high level tools.\\n\\n```\\npublic class Solution {\\n    public int lengthLongestPath(String input) {\\n        int max = 0, len = input.length(), idx = 0, curDepth = 0;\\n        int[] table = new int[len/2 + 1];\\n        while(idx < len){\\n            int curLen = 0;\\n            boolean isFile = false;\\n            for(;idx < len && input.charAt(idx)!='\\\\n';idx++, curLen++) if(input.charAt(idx)=='.') isFile = true;\\n            \\n            table[curDepth] = (curDepth==0?0:table[curDepth-1]) + curLen + 1;\\n            \\n            if(isFile) max = Math.max(max, table[curDepth]-1);\\n            \\n            idx++; curDepth = 0;\\n            for(;idx < len && input.charAt(idx)=='\\\\t'; idx++) curDepth++;           \\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int lengthLongestPath(String input) {        \\n        int max = 0, len = input.length(), idx = 0, pathLen = 0, curDepth = 0;\\n        Stack<Integer> stk = new Stack<>(); \\n        while(idx < len){\\n            while(stk.size() > curDepth) pathLen -= stk.pop();\\n            int curLen = 0; curDepth = 0;\\n            boolean isFile = false;\\n\\n            for(;idx < len && input.charAt(idx)!='\\\\n';idx++, curLen++)\\n               if(input.charAt(idx)=='.') isFile = true;\\n            \\n            if(isFile) max = Math.max(max, curLen+pathLen); \\n            else pathLen += stk.push(curLen+1);    \\n\\n            idx++; \\n            for(;idx < len && input.charAt(idx)=='\\\\t'; idx++) curDepth++; \\n        }\\n        return max;        \\n    }    \\n}\\n```\n```\\npublic class Solution {\\n    public int lengthLongestPath(String input) {\\n        int max = 0, len = input.length(), idx = 0, curDepth = 0;\\n        int[] table = new int[len/2 + 1];\\n        while(idx < len){\\n            int curLen = 0;\\n            boolean isFile = false;\\n            for(;idx < len && input.charAt(idx)!='\\\\n';idx++, curLen++) if(input.charAt(idx)=='.') isFile = true;\\n            \\n            table[curDepth] = (curDepth==0?0:table[curDepth-1]) + curLen + 1;\\n            \\n            if(isFile) max = Math.max(max, table[curDepth]-1);\\n            \\n            idx++; curDepth = 0;\\n            for(;idx < len && input.charAt(idx)=='\\\\t'; idx++) curDepth++;           \\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034862,
                "title": "c-easy-solution-using-stack-runtime-0-ms-beats-100",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string a) {\\n        int n = a.size() , res =0 , tCount =0 , ans =0 ,i=0 , dot = 0, len =0, k;\\n        stack<pair<int,int>> s;\\n        while(i<n){\\n            if((a[i]>=65&&a[i]<=90)||(a[i]>=97&&a[i]<=122)||a[i]==\\' \\'||a[i]==\\'.\\'||(a[i]>=48&&a[i]<=57)){\\n                len++;\\n                if(a[i]==\\'.\\') dot =1;\\n                i++;\\n            }\\n            else{\\n                while(!s.empty()&&s.top().first>=tCount){\\n                    res -= s.top().second;\\n                    s.pop();\\n                }\\n                s.push({tCount,len});\\n                res += len;\\n                if(dot==1){\\n                    k = s.size();\\n                    ans= max(ans,res+k-1);\\n                }\\n                dot =0 ;\\n                tCount =0 ;\\n                len =0 ;\\n                i++;\\n                while(i<n&&a[i]==\\'\\\\t\\'){\\n                    i++;\\n                    tCount++;\\n                }\\n            }\\n        }\\n        while(!s.empty()&&s.top().first>=tCount){\\n            res -= s.top().second;\\n            s.pop();\\n        }\\n        s.push({tCount,len});\\n        res += len;\\n        if(dot==1){\\n            k = s.size();\\n            ans= max(ans,res+k-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string a) {\\n        int n = a.size() , res =0 , tCount =0 , ans =0 ,i=0 , dot = 0, len =0, k;\\n        stack<pair<int,int>> s;\\n        while(i<n){\\n            if((a[i]>=65&&a[i]<=90)||(a[i]>=97&&a[i]<=122)||a[i]==\\' \\'||a[i]==\\'.\\'||(a[i]>=48&&a[i]<=57)){\\n                len++;\\n                if(a[i]==\\'.\\') dot =1;\\n                i++;\\n            }\\n            else{\\n                while(!s.empty()&&s.top().first>=tCount){\\n                    res -= s.top().second;\\n                    s.pop();\\n                }\\n                s.push({tCount,len});\\n                res += len;\\n                if(dot==1){\\n                    k = s.size();\\n                    ans= max(ans,res+k-1);\\n                }\\n                dot =0 ;\\n                tCount =0 ;\\n                len =0 ;\\n                i++;\\n                while(i<n&&a[i]==\\'\\\\t\\'){\\n                    i++;\\n                    tCount++;\\n                }\\n            }\\n        }\\n        while(!s.empty()&&s.top().first>=tCount){\\n            res -= s.top().second;\\n            s.pop();\\n        }\\n        s.push({tCount,len});\\n        res += len;\\n        if(dot==1){\\n            k = s.size();\\n            ans= max(ans,res+k-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952353,
                "title": "python-easy-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nkeep track longest range\\nassume level = 1,2,3,1,2,3,5,1,1\\nex. 1 => 1,2 => 1,2,3 => 1 => 1,2 => 1,2,3 => 1,2,3,5 => 1 => 1\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        lines = input.split(\"\\\\n\")\\n        stack = [] # [level, cum_size]\\n        ans = 0\\n        for line in lines:\\n            if not stack:\\n                level = line.count(\"\\\\t\")\\n                stack.append([level, len(line) - level])\\n                \\n            else:\\n                level = line.count(\"\\\\t\")\\n                while stack and stack[-1][0] >= level:\\n                    stack.pop()\\n                    \\n                offset = stack[-1][1] + 1 if stack else 0\\n                stack.append([level, offset + len(line) - level])\\n            \\n            if \".\" in line:\\n                ans = max(ans, stack[-1][1])\\n                \\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        lines = input.split(\"\\\\n\")\\n        stack = [] # [level, cum_size]\\n        ans = 0\\n        for line in lines:\\n            if not stack:\\n                level = line.count(\"\\\\t\")\\n                stack.append([level, len(line) - level])\\n                \\n            else:\\n                level = line.count(\"\\\\t\")\\n                while stack and stack[-1][0] >= level:\\n                    stack.pop()\\n                    \\n                offset = stack[-1][1] + 1 if stack else 0\\n                stack.append([level, offset + len(line) - level])\\n            \\n            if \".\" in line:\\n                ans = max(ans, stack[-1][1])\\n                \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827815,
                "title": "c-solution-asked-by-the-google",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int LengthLongestPath(string input) {\\n        String[] paths = input.Split(\"\\\\n\");\\n        int[] stack = new int[paths.Length+1];\\n        int maxLen = 0;\\n        foreach(String s in paths){\\n            int lev = s.LastIndexOf(\"\\\\t\")+1;\\n            int curLen = stack[lev]+s.Length-lev+1;\\n            stack[lev+1]=curLen;\\n            if(s.Contains(\".\")) \\n                maxLen = Math.Max(maxLen, curLen-1);\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LengthLongestPath(string input) {\\n        String[] paths = input.Split(\"\\\\n\");\\n        int[] stack = new int[paths.Length+1];\\n        int maxLen = 0;\\n        foreach(String s in paths){\\n            int lev = s.LastIndexOf(\"\\\\t\")+1;\\n            int curLen = stack[lev]+s.Length-lev+1;\\n            stack[lev+1]=curLen;\\n            if(s.Contains(\".\")) \\n                maxLen = Math.Max(maxLen, curLen-1);\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666741,
                "title": "simple-solution-with-python3",
                "content": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        lines=input.split(\"\\\\n\")\\n        maxlength=0\\n        depth_map={0:0}\\n        for line in lines:\\n            path=line.split(\"\\\\t\")[-1]\\n            depth=len(line)-len(path)\\n            \\n            if \\'.\\' in path:\\n                maxlength=max(maxlength,depth_map[depth]+len(path))\\n                \\n            else:\\n                depth_map[depth+1]=depth_map[depth]+len(path)+1\\n                \\n        return maxlength        \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        lines=input.split(\"\\\\n\")\\n        maxlength=0\\n        depth_map={0:0}",
                "codeTag": "Java"
            },
            {
                "id": 2635164,
                "title": "java-simple-solution",
                "content": "```\\npublic int lengthLongestPath(String input) {\\n        if (input == null || input.length() == 0) {\\n            return 0;\\n        }\\n        \\n        String[] ar = input.split(\"\\\\n\");\\n        int maxLength = 0;\\n        int[] count = new int[10000];\\n        \\n        for (String s : ar) {\\n            int tabIndex = s.lastIndexOf(\"\\\\t\");\\n            count[tabIndex + 1] = s.substring(tabIndex + 1).length();  // length of the word at current line, but exclude \\\\t\\n            \\n            if (s.lastIndexOf(\".\") != -1) {   // If we found a file\\n                int length = 0;\\n                for (int i = 0; i <= tabIndex + 1; i++) {  // count length from root until current index in count\\n                    length += count[i];\\n                    length++;   // add 1 for forward slash\\n                }\\n                length--;   // subtract 1 for final slash\\n                \\n                maxLength = Math.max(length, maxLength);\\n            }\\n        }\\n        \\n        return maxLength;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int lengthLongestPath(String input) {\\n        if (input == null || input.length() == 0) {\\n            return 0;\\n        }\\n        \\n        String[] ar = input.split(\"\\\\n\");\\n        int maxLength = 0;\\n        int[] count = new int[10000];\\n        \\n        for (String s : ar) {\\n            int tabIndex = s.lastIndexOf(\"\\\\t\");\\n            count[tabIndex + 1] = s.substring(tabIndex + 1).length();  // length of the word at current line, but exclude \\\\t\\n            \\n            if (s.lastIndexOf(\".\") != -1) {   // If we found a file\\n                int length = 0;\\n                for (int i = 0; i <= tabIndex + 1; i++) {  // count length from root until current index in count\\n                    length += count[i];\\n                    length++;   // add 1 for forward slash\\n                }\\n                length--;   // subtract 1 for final slash\\n                \\n                maxLength = Math.max(length, maxLength);\\n            }\\n        }\\n        \\n        return maxLength;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2586784,
                "title": "longest-absolute-file-path-solution-java",
                "content": "class T {\\n  public int depth;\\n  public int length;\\n  public T(int depth, int length) {\\n    this.depth = depth;\\n    this.length = length;\\n  }\\n}\\n\\nclass Solution {\\n  public int lengthLongestPath(String input) {\\n    int ans = 0;\\n    Deque<T> stack = new ArrayDeque<>();\\n    stack.push(new T(-1, 0));\\n\\n    for (String token : input.split(\"\\\\n\")) {\\n      final int depth = getDepth(token);\\n      token = token.replace(\"\\\\t\", \"\");\\n      while (depth <= stack.peek().depth)\\n        stack.pop();\\n      if (token.contains(\".\")) // file\\n        ans = Math.max(ans, stack.peek().length + token.length());\\n      else // directory + \\'/\\'\\n        stack.push(new T(depth, stack.peek().length + token.length() + 1));\\n    }\\n\\n    return ans;\\n  }\\n\\n  private int getDepth(final String token) {\\n    return (int) token.chars().filter(c -> c == \\'\\\\t\\').count();\\n  }\\n}\\n",
                "solutionTags": [
                    "String",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n  public int lengthLongestPath(String input) {\\n    int ans = 0;\\n    Deque<T> stack = new ArrayDeque<>();\\n    stack.push(new T(-1, 0));\\n\\n    for (String token : input.split(\"\\\\n\")) {\\n      final int depth = getDepth(token);\\n      token = token.replace(\"\\\\t\", \"\");\\n      while (depth <= stack.peek().depth)\\n        stack.pop();\\n      if (token.contains(\".\")) // file\\n        ans = Math.max(ans, stack.peek().length + token.length());\\n      else // directory + \\'/\\'\\n        stack.push(new T(depth, stack.peek().length + token.length() + 1));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2582147,
                "title": "c-fast-comprehensible",
                "content": "Link to the submission stats:\\nhttps://leetcode.com/submissions/detail/801030214/\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int lengthLongestPath(string s) {\\n        stack<int> st;\\n        string temp;\\n        bool ok=0;\\n        int n=s.size();\\n        int ans=0;\\n        int f=1;\\n    \\n        for(int i=0;i<n;i++){\\n            char x=s[i];\\n            if(x==\\'.\\'){ok=1;}\\n            if(x==\\'\\\\n\\' || x==\\'\\\\t\\'){\\n                while(st.size()>=f){st.pop();}\\n                st.push((st.size()>0?st.top():0)+temp.size());\\n                temp.clear();\\n                if(ok){ans=max(ans,st.top()+(int)st.size()-1);}\\n                ok=0;\\n                f=0;\\n                while(i<n && s[i]==\\'\\\\n\\' || s[i]==\\'\\\\t\\'){i++;f++;}\\n                i--;\\n                temp.clear();\\n            }\\n            else{\\n                temp.push_back(x);\\n            }\\n            //cout<<temp<<endl;\\n        }\\n        while(st.size()>=f){st.pop();}\\n        st.push((st.size()>0?st.top():0)+temp.size());\\n        if(ok){\\n            ans=max(ans,st.top()+(int)st.size()-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int lengthLongestPath(string s) {\\n        stack<int> st;\\n        string temp;\\n        bool ok=0;\\n        int n=s.size();\\n        int ans=0;\\n        int f=1;\\n    \\n        for(int i=0;i<n;i++){\\n            char x=s[i];\\n            if(x==\\'.\\'){ok=1;}\\n            if(x==\\'\\\\n\\' || x==\\'\\\\t\\'){\\n                while(st.size()>=f){st.pop();}\\n                st.push((st.size()>0?st.top():0)+temp.size());\\n                temp.clear();\\n                if(ok){ans=max(ans,st.top()+(int)st.size()-1);}\\n                ok=0;\\n                f=0;\\n                while(i<n && s[i]==\\'\\\\n\\' || s[i]==\\'\\\\t\\'){i++;f++;}\\n                i--;\\n                temp.clear();\\n            }\\n            else{\\n                temp.push_back(x);\\n            }\\n            //cout<<temp<<endl;\\n        }\\n        while(st.size()>=f){st.pop();}\\n        st.push((st.size()>0?st.top():0)+temp.size());\\n        if(ok){\\n            ans=max(ans,st.top()+(int)st.size()-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2440287,
                "title": "clean-python-solution-using-dictionary",
                "content": "**Intuition**\\nSo the intuition is basically checking if current directory tree level has \".\" , then use hashmap to get length of previous level (level-1) + current length and compare it with current result.\\n\\n**Complexity**\\nO(n * len(s)) \\n\\n- We loop over each directory\\n- We do search of \".\" in the string ,  since len(\".\") is 1 , and usually substring search costs O(M * N) where m is string and n is substring, in this case it will be O(M) where m is len of directory string\\n\\n**Solution**\\n\\n```python\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        depth = {}\\n        dirs = input.split(\"\\\\n\")\\n        result = 0\\n        for i in range(len(dirs)):\\n            level = dirs[i].count(\"\\\\t\")\\n            if(level > 0):\\n                depth[level] = len(dirs[i]) + 1 - level + depth[level-1]\\n            else:\\n                depth[level] =  len(dirs[i]) + 1 - level\\n            \\n            # potentialy a room for improvement\\n            if(\".\" in dirs[i]):\\n                depth[level]-=1\\n                result = max(depth[level],result)\\n                \\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        depth = {}\\n        dirs = input.split(\"\\\\n\")\\n        result = 0\\n        for i in range(len(dirs)):\\n            level = dirs[i].count(\"\\\\t\")\\n            if(level > 0):\\n                depth[level] = len(dirs[i]) + 1 - level + depth[level-1]\\n            else:\\n                depth[level] =  len(dirs[i]) + 1 - level\\n            \\n            # potentialy a room for improvement\\n            if(\".\" in dirs[i]):\\n                depth[level]-=1\\n                result = max(depth[level],result)\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382451,
                "title": "python-solution-with-proper-explanation",
                "content": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        \"\"\"\\n        input = \"dir\\\\n\\\\tsubdir1\\\\n\\\\t\\\\tfile1.ext\\\\n\\\\t\\\\tsubsubdir1\\\\n\\\\tsubdir2\\\\n\\\\t\\\\tsubsubdir2\\\\n\\\\t\\\\t\\\\tfile2.ext\"\\n        \\n        step 1: we split the input on the basis of new line (\\\\n)\\n        [\"dir\", \"\\\\tsubdir1\", \"\\\\t\\\\tfile1.ext\", \"\\\\t\\\\tsubsubdir1\", \"\\\\tsubdir2\", \"\\\\t\\\\tsubsubdir2\", \"\\\\t\\\\t\\\\tfile2.ext\"]\\n        The no. of \\\\t represents the level of the file of folder\\n        \\n        step2: we define a dictionary level which will keep maximum level of a folder at each level\\n        dir\\n         |\\n         |-------> subdir1\\n         |   |\\n         |   |-------------> file1.ext\\n         |   |-------------> subsubdir1\\n         |\\n         |-------> subdir2\\n             |\\n             |-------------> subsubdir2\\n                  |\\n                  |-----------------------> file2.ext\\n         \\n         \\n         when v = \"dir\"\\n         . is not there in the name so this is a folder\\n         count(\\\\t) = 0\\n         \\n         so level[0] = 4 (len(dir) + 1 : 1 is for \"\\\\\")\\n         \\n         when we get a file (it has .)\\n         we will get the length of the file name (we are doing this by removing the \"/\") and after that\\n         we do the previous level length + file name length\\n         we have to get maximum of this\\n        \"\"\"\\n        files = input.splitlines()\\n        level = {}\\n        maxLen = 0\\n        for i, v in enumerate(files):\\n            l = v.count(\\'\\\\t\\') \\n            n = len(v)\\n            if \\'.\\' in v: \\n                maxLen = max(maxLen, level.get(l - 1, 0) + n - l)\\n            else: \\n                level[l] = (n - l) + level.get(l - 1, 0) + 1\\n        return maxLen\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        \"\"\"\\n        input = \"dir\\\\n\\\\tsubdir1\\\\n\\\\t\\\\tfile1.ext\\\\n\\\\t\\\\tsubsubdir1\\\\n\\\\tsubdir2\\\\n\\\\t\\\\tsubsubdir2\\\\n\\\\t\\\\t\\\\tfile2.ext\"\\n        \\n        step 1: we split the input on the basis of new line (\\\\n)\\n        [\"dir\", \"\\\\tsubdir1\", \"\\\\t\\\\tfile1.ext\", \"\\\\t\\\\tsubsubdir1\", \"\\\\tsubdir2\", \"\\\\t\\\\tsubsubdir2\", \"\\\\t\\\\t\\\\tfile2.ext\"]\\n        The no. of \\\\t represents the level of the file of folder\\n        \\n        step2: we define a dictionary level which will keep maximum level of a folder at each level\\n        dir\\n         |\\n         |-------> subdir1\\n         |   |\\n         |   |-------------> file1.ext\\n         |   |-------------> subsubdir1\\n         |\\n         |-------> subdir2\\n             |\\n             |-------------> subsubdir2\\n                  |\\n                  |-----------------------> file2.ext\\n         \\n         \\n         when v = \"dir\"\\n         . is not there in the name so this is a folder\\n         count(\\\\t) = 0\\n         \\n         so level[0] = 4 (len(dir) + 1 : 1 is for \"\\\\\")\\n         \\n         when we get a file (it has .)\\n         we will get the length of the file name (we are doing this by removing the \"/\") and after that\\n         we do the previous level length + file name length\\n         we have to get maximum of this\\n        \"\"\"\\n        files = input.splitlines()\\n        level = {}\\n        maxLen = 0\\n        for i, v in enumerate(files):\\n            l = v.count(\\'\\\\t\\') \\n            n = len(v)\\n            if \\'.\\' in v: \\n                maxLen = max(maxLen, level.get(l - 1, 0) + n - l)\\n            else: \\n                level[l] = (n - l) + level.get(l - 1, 0) + 1\\n        return maxLen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2344473,
                "title": "c-solution-time-o-n-memory-o-n-easy-to-understand-iterative",
                "content": "```C#\\npublic class Solution {\\n    public int LengthLongestPath(string input) {\\n        int max = 0, currentLength = 0, currentDepth = -1;\\n        Stack<int> stack = new Stack<int>(); // Store the length of each path segment.\\n        \\n        string[] segments = input.Split(\\'\\\\n\\', StringSplitOptions.RemoveEmptyEntries);\\n        for (int i = 0; i < segments.Length; i++) {\\n            int segmentDepth = CalculateDepth(segments[i]);\\n            while (segmentDepth <= currentDepth) {\\n                currentDepth--;\\n                currentLength -= stack.Pop();\\n            }\\n            \\n            int segmentLength = segments[i].Length - segmentDepth;\\n            if (segmentDepth > 0) segmentLength++; // There is a slash (directory separator).\\n            \\n            stack.Push(segmentLength);\\n            currentLength += segmentLength;\\n            currentDepth++;\\n            \\n            if (segments[i].Contains(\\'.\\')) max = Math.Max(max, currentLength); // We should re-evaluate `max` only if we have reached a file.\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public int CalculateDepth(string segment) {\\n        int depth = 0;\\n        while (depth < segment.Length && segment[depth] == \\'\\\\t\\') depth++;\\n        return depth;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack",
                    "Iterator"
                ],
                "code": "```C#\\npublic class Solution {\\n    public int LengthLongestPath(string input) {\\n        int max = 0, currentLength = 0, currentDepth = -1;\\n        Stack<int> stack = new Stack<int>(); // Store the length of each path segment.\\n        \\n        string[] segments = input.Split(\\'\\\\n\\', StringSplitOptions.RemoveEmptyEntries);\\n        for (int i = 0; i < segments.Length; i++) {\\n            int segmentDepth = CalculateDepth(segments[i]);\\n            while (segmentDepth <= currentDepth) {\\n                currentDepth--;\\n                currentLength -= stack.Pop();\\n            }\\n            \\n            int segmentLength = segments[i].Length - segmentDepth;\\n            if (segmentDepth > 0) segmentLength++; // There is a slash (directory separator).\\n            \\n            stack.Push(segmentLength);\\n            currentLength += segmentLength;\\n            currentDepth++;\\n            \\n            if (segments[i].Contains(\\'.\\')) max = Math.Max(max, currentLength); // We should re-evaluate `max` only if we have reached a file.\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public int CalculateDepth(string segment) {\\n        int depth = 0;\\n        while (depth < segment.Length && segment[depth] == \\'\\\\t\\') depth++;\\n        return depth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196167,
                "title": "100-faster-c",
                "content": "class Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        \\n        int tabCount=0;\\n        int lengthOfEntry=0;\\n        stack<int> previousCounts;\\n        bool isFile = false;\\n        int maxLen=0;\\n        \\n        for(int i=0; i<=input.length(); i++)\\n        {\\n            char c = input[i];\\n            if(c== \\'\\\\n\\' || i==input.length())\\n            {\\n                while(!previousCounts.empty() && previousCounts.size() > tabCount )\\n                {\\n                    previousCounts.pop();\\n                }\\n                \\n               int parentCount = previousCounts.empty() ? -1 : previousCounts.top();\\n               int currLen = parentCount + lengthOfEntry+1;\\n                \\n               if(isFile)\\n                    maxLen = max(maxLen, currLen);\\n                else\\n                    previousCounts.push(currLen); \\n                \\n               // reset all previous values\\n               tabCount=0;\\n               lengthOfEntry=0;\\n               isFile = false;\\n            }\\n            else if(c == \\'\\\\t\\')\\n            {\\n                tabCount++;\\n                lengthOfEntry=0;\\n            }\\n            else\\n            {   \\n                if(c == \\'.\\')\\n                    isFile = true;\\n                lengthOfEntry++;\\n            }\\n        }\\n        \\n        return maxLen;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        \\n        int tabCount=0;\\n        int lengthOfEntry=0;\\n        stack<int> previousCounts;\\n        bool isFile = false;\\n        int maxLen=0;\\n        \\n        for(int i=0; i<=input.length(); i++)\\n        {\\n            char c = input[i];\\n            if(c== \\'\\\\n\\' || i==input.length())\\n            {\\n                while(!previousCounts.empty() && previousCounts.size() > tabCount )\\n                {\\n                    previousCounts.pop();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2082181,
                "title": "solution-in-java-with-explainations",
                "content": "```\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        //Format Req: \"dir/subdir2/file.ext\"\\n        String[] paths = input.split(\"\\\\n\");\\n        int[] stack = new int[paths.length+1];\\n        Arrays.fill(stack,0);\\n        \\n        int maxLen=0,curLen=0;\\n        \\n        for(String path:paths){\\n            int level=path.lastIndexOf(\"\\\\t\")+1;\\n            //Remove tabs, append /\\n            stack[level+1]=stack[level]+path.length()-level+1;\\n            curLen=stack[level+1];\\n            //If file\\n            if(path.contains(\".\")){\\n                //CurLen -1 -> remove / from end\\n                maxLen=Math.max(maxLen,curLen-1);\\n            }\\n        }\\n        \\n        return maxLen;\\n    }\\n}\\n/*\\nSpace = O(N), N=len(paths)\\nTime = O(N)\\n*/\\n```\\nPlease **upvote**, if you like the solution:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        //Format Req: \"dir/subdir2/file.ext\"\\n        String[] paths = input.split(\"\\\\n\");\\n        int[] stack = new int[paths.length+1];\\n        Arrays.fill(stack,0);\\n        \\n        int maxLen=0,curLen=0;\\n        \\n        for(String path:paths){\\n            int level=path.lastIndexOf(\"\\\\t\")+1;\\n            //Remove tabs, append /\\n            stack[level+1]=stack[level]+path.length()-level+1;\\n            curLen=stack[level+1];\\n            //If file\\n            if(path.contains(\".\")){\\n                //CurLen -1 -> remove / from end\\n                maxLen=Math.max(maxLen,curLen-1);\\n            }\\n        }\\n        \\n        return maxLen;\\n    }\\n}\\n/*\\nSpace = O(N), N=len(paths)\\nTime = O(N)\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025989,
                "title": "tried-different-approach-using-stack-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n     pair<int,int> length(int &i,string input)\\n    {\\n        int count=0,flag=0;\\n        while(i<input.size()&&input[i]!=\\'*\\')\\n        {\\n            if(input[i]==\\'.\\')\\n                flag=1;\\n            i++; count++;\\n        }\\n         return make_pair(flag,count);\\n        \\n    }\\n    int lengthLongestPath(string input) {\\n        replace(input.begin(),input.end(),\\'\\\\n\\',\\'*\\');\\n        replace(input.begin(),input.end(),\\'\\\\t\\',\\'#\\');\\n        stack<pair<int,pair<int,int>>> s;\\n         int i=0,mx=0;\\n          s.push({0,length(i,input)});\\n          while(i<input.size())\\n          {\\n                  i++;\\n                  int countt=0;\\n                  while(i<input.size()&&input[i]==\\'#\\')\\n                    {\\n                        i++; countt++;\\n                    }\\n                      if(countt==0)\\n                      {\\n                         s.push({0,length(i,input)});\\n                          continue;\\n                      }\\n                      while(s.top().first+1>countt)\\n                      {\\n                          if(s.top().second.first)\\n                          mx=max(mx,s.top().second.second);\\n                          s.pop();\\n                      } \\n                 pair<int,int> p=length(i,input);\\n                s.push({countt,{p.first||s.top().second.first,1+p.second+s.top().second.second}});\\n          }\\n                 while(!s.empty())\\n                      {\\n                            if(s.top().second.first)\\n                          mx=max(mx,s.top().second.second);\\n                          s.pop();\\n                      } \\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     pair<int,int> length(int &i,string input)\\n    {\\n        int count=0,flag=0;\\n        while(i<input.size()&&input[i]!=\\'*\\')\\n        {\\n            if(input[i]==\\'.\\')\\n                flag=1;\\n            i++; count++;\\n        }\\n         return make_pair(flag,count);\\n        \\n    }\\n    int lengthLongestPath(string input) {\\n        replace(input.begin(),input.end(),\\'\\\\n\\',\\'*\\');\\n        replace(input.begin(),input.end(),\\'\\\\t\\',\\'#\\');\\n        stack<pair<int,pair<int,int>>> s;\\n         int i=0,mx=0;\\n          s.push({0,length(i,input)});\\n          while(i<input.size())\\n          {\\n                  i++;\\n                  int countt=0;\\n                  while(i<input.size()&&input[i]==\\'#\\')\\n                    {\\n                        i++; countt++;\\n                    }\\n                      if(countt==0)\\n                      {\\n                         s.push({0,length(i,input)});\\n                          continue;\\n                      }\\n                      while(s.top().first+1>countt)\\n                      {\\n                          if(s.top().second.first)\\n                          mx=max(mx,s.top().second.second);\\n                          s.pop();\\n                      } \\n                 pair<int,int> p=length(i,input);\\n                s.push({countt,{p.first||s.top().second.first,1+p.second+s.top().second.second}});\\n          }\\n                 while(!s.empty())\\n                      {\\n                            if(s.top().second.first)\\n                          mx=max(mx,s.top().second.second);\\n                          s.pop();\\n                      } \\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987918,
                "title": "c-dfs",
                "content": "Details in comments.\\n\\n```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        auto lines = getLines(input);\\n        int idx = 0, rtn = 0;\\n        dfs(lines, idx, 0, 0, rtn);\\n        return rtn;\\n    }\\n    \\n    void dfs(const vector<pair<string, int>>& lines, int& idx, int currLvl, int currCnt, int& rtn) {\\n        if(idx >= lines.size()) {\\n            return;\\n        }\\n        int cnt = currCnt;\\n        while(idx < lines.size()) {\\n            auto& [line, lvl] = lines[idx];\\n            // If line is at the next level, the current level must be a directory. \\n            // We go recursively to the next level.\\n            if(lvl > currLvl) {\\n                dfs(lines, idx, lvl, cnt + 1, rtn);\\n            } else if(lvl == currLvl) {\\n                // If line is at the same level, there could be two cases:\\n                // 1. line is a directory.\\n                // 2. line is a file, in this case, we need to update rtn.\\n                cnt = currCnt + line.size();\\n                if(isFile(line)) {\\n                    rtn = max(rtn, cnt);\\n                }                \\n                idx ++;\\n            } else {\\n                // If line is at a previous level, we return directly to go back to the previous call in the call stack.\\n                return;\\n            }\\n        }\\n    }\\n    \\n    bool isFile(const string& s) {\\n        return s.find(\\'.\\') != string::npos;\\n    }\\n    \\n    // Returns a vector of <line with out leading tabs, number of leading tabs>.\\n    vector<pair<string, int>> getLines(const string& input) {\\n        int startIdx = 0;\\n        vector<pair<string, int>> rtn;\\n        for(int i = 0; i <= input.size(); i ++) {\\n            if(i == input.size() || input[i] == \\'\\\\n\\') {\\n                auto currLine = input.substr(startIdx, i - startIdx);\\n                int lvl = 0;\\n                for(auto c : currLine) {\\n                    if(c == \\'\\\\t\\') {\\n                        lvl ++;\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                rtn.emplace_back(currLine.substr(lvl), lvl);\\n                startIdx = i + 1;\\n            }\\n        }\\n        return rtn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        auto lines = getLines(input);\\n        int idx = 0, rtn = 0;\\n        dfs(lines, idx, 0, 0, rtn);\\n        return rtn;\\n    }\\n    \\n    void dfs(const vector<pair<string, int>>& lines, int& idx, int currLvl, int currCnt, int& rtn) {\\n        if(idx >= lines.size()) {\\n            return;\\n        }\\n        int cnt = currCnt;\\n        while(idx < lines.size()) {\\n            auto& [line, lvl] = lines[idx];\\n            // If line is at the next level, the current level must be a directory. \\n            // We go recursively to the next level.\\n            if(lvl > currLvl) {\\n                dfs(lines, idx, lvl, cnt + 1, rtn);\\n            } else if(lvl == currLvl) {\\n                // If line is at the same level, there could be two cases:\\n                // 1. line is a directory.\\n                // 2. line is a file, in this case, we need to update rtn.\\n                cnt = currCnt + line.size();\\n                if(isFile(line)) {\\n                    rtn = max(rtn, cnt);\\n                }                \\n                idx ++;\\n            } else {\\n                // If line is at a previous level, we return directly to go back to the previous call in the call stack.\\n                return;\\n            }\\n        }\\n    }\\n    \\n    bool isFile(const string& s) {\\n        return s.find(\\'.\\') != string::npos;\\n    }\\n    \\n    // Returns a vector of <line with out leading tabs, number of leading tabs>.\\n    vector<pair<string, int>> getLines(const string& input) {\\n        int startIdx = 0;\\n        vector<pair<string, int>> rtn;\\n        for(int i = 0; i <= input.size(); i ++) {\\n            if(i == input.size() || input[i] == \\'\\\\n\\') {\\n                auto currLine = input.substr(startIdx, i - startIdx);\\n                int lvl = 0;\\n                for(auto c : currLine) {\\n                    if(c == \\'\\\\t\\') {\\n                        lvl ++;\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                rtn.emplace_back(currLine.substr(lvl), lvl);\\n                startIdx = i + 1;\\n            }\\n        }\\n        return rtn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1947860,
                "title": "java-0ms-prefix-sum",
                "content": "Notice that we care about prefix sum of the length of directories but each time we go back up some levels of directories, only the previous directories prior to that matter and their length do not change, so we can reuse the same prefix sum. \\n\\nAlso, we can only go down 1 directory at a time so there is nothing wrong with my approach above (i.e. we can\\'t accidentally access old data that was meant to be erased even if we try). \\n\\n```Java\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        int[] count = new int[input.length() + 2];\\n        String[] lines = input.split(\"\\\\n\");\\n        int ans = 0;\\n        for (int i = 0; i < lines.length; i++){\\n            int t = getTab(lines[i]);\\n            int sz = lines[i].length() - t;\\n            if (lines[i].indexOf(\".\") == -1){\\n                count[t + 1] = count[t] + sz;\\n            }else{\\n                ans = Math.max(ans, count[t] + sz + t);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int getTab(String s){\\n        int count = 0;\\n        while(count < s.length() && s.charAt(count) == \\'\\\\t\\'){\\n            ++count;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\nHere are some test cases:\\n```\\n\"                dir\\\\n\\\\n\\\\tsubdir1\\\\n\\\\tsubdir2\\\\n\\\\t\\\\tfile.ext\"\\n\"dir\\\\n\\\\tsu                     bdir1\\\\n\\\\t\\\\tfile1.ext\\\\n\\\\t\\\\tsubsubdir1\\\\n\\\\tsubdir2\\\\n\\\\t\\\\tsubsubdir2\\\\n\\\\t\\\\t\\\\tfile2.ext\"\\n\"a\"\\n\"a.txt\"\\n\"\\\\n\\\\n\\\\n\"\\n\"\\\\t\"\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        int[] count = new int[input.length() + 2];\\n        String[] lines = input.split(\"\\\\n\");\\n        int ans = 0;\\n        for (int i = 0; i < lines.length; i++){\\n            int t = getTab(lines[i]);\\n            int sz = lines[i].length() - t;\\n            if (lines[i].indexOf(\".\") == -1){\\n                count[t + 1] = count[t] + sz;\\n            }else{\\n                ans = Math.max(ans, count[t] + sz + t);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int getTab(String s){\\n        int count = 0;\\n        while(count < s.length() && s.charAt(count) == \\'\\\\t\\'){\\n            ++count;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\n\"                dir\\\\n\\\\n\\\\tsubdir1\\\\n\\\\tsubdir2\\\\n\\\\t\\\\tfile.ext\"\\n\"dir\\\\n\\\\tsu                     bdir1\\\\n\\\\t\\\\tfile1.ext\\\\n\\\\t\\\\tsubsubdir1\\\\n\\\\tsubdir2\\\\n\\\\t\\\\tsubsubdir2\\\\n\\\\t\\\\t\\\\tfile2.ext\"\\n\"a\"\\n\"a.txt\"\\n\"\\\\n\\\\n\\\\n\"\\n\"\\\\t\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829744,
                "title": "python-code-with-explanation-80-time-and-memory",
                "content": "```\\ndef lengthLongestPath(self, input: str) -> int:\\n        items = input.split(\"\\\\n\")\\n        # dirs store the path length (instead of the string)\\n\\t\\tdirs, res = [], 0\\n\\n        for item in items:\\n            s = item.lstrip(\"\\\\t\")\\n            depth = len(item) - len(s)\\n            # go folder up if necessary\\n            if depth < len(dirs):\\n                dirs = dirs[:depth]\\n            \\n            if \".\" not in s:\\n                # it is a directory\\n                if dirs:\\n                    dirs.append(dirs[-1] + len(s) + 1)\\n                else:\\n                    dirs.append(len(s) + 1)\\n            else:\\n                # it is a file\\n                if dirs:\\n                    res = max(res, dirs[-1] + len(s))\\n                else:\\n                    res = max(res, len(s))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef lengthLongestPath(self, input: str) -> int:\\n        items = input.split(\"\\\\n\")\\n        # dirs store the path length (instead of the string)\\n\\t\\tdirs, res = [], 0\\n\\n        for item in items:\\n            s = item.lstrip(\"\\\\t\")\\n            depth = len(item) - len(s)\\n            # go folder up if necessary\\n            if depth < len(dirs):\\n                dirs = dirs[:depth]\\n            \\n            if \".\" not in s:\\n                # it is a directory\\n                if dirs:\\n                    dirs.append(dirs[-1] + len(s) + 1)\\n                else:\\n                    dirs.append(len(s) + 1)\\n            else:\\n                # it is a file\\n                if dirs:\\n                    res = max(res, dirs[-1] + len(s))\\n                else:\\n                    res = max(res, len(s))\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1721031,
                "title": "stack-based-java-solution-1-ms",
                "content": "```\\nclass Solution {\\n    class Node {\\n        int size;\\n        int depth;\\n        \\n        Node(int s, int d) {\\n            size = s;\\n            depth = d;\\n        }\\n    }\\n    \\n    public int lengthLongestPath(String input) {\\n        String[] arr = input.split(\"\\\\n\");\\n        \\n        if(arr.length == 0) {\\n            return 0;\\n        }\\n        \\n        Deque<Node> stack = new ArrayDeque();\\n        int totalSize = 0;\\n        int maxFileLen = 0;\\n        \\n        for(int i = 0; i < arr.length; i++) {\\n            String[] ar = arr[i].split(\"\\\\t\");\\n            \\n            int depth = ar.length - 1;\\n            String fileName = ar[depth];\\n            \\n            \\n            Node thisNode = stack.peekFirst();\\n            while(thisNode != null && thisNode.depth > depth -1) {\\n                stack.pollFirst();\\n                totalSize -= (thisNode.size);\\n                thisNode = stack.peekFirst();\\n            }\\n            \\n            int thisLength = fileName.length();\\n            if(thisNode != null) {\\n                thisLength++;\\n            }\\n            \\n            stack.offerFirst(new Node(thisLength, depth));\\n            totalSize += thisLength;\\n        \\n            if(isFile(fileName)) {\\n                maxFileLen = Math.max(maxFileLen, totalSize);\\n            }\\n        }\\n        \\n        return maxFileLen;\\n    }\\n    \\n    private boolean isFile(String input) {\\n        return input.contains(\".\");\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    class Node {\\n        int size;\\n        int depth;\\n        \\n        Node(int s, int d) {\\n            size = s;\\n            depth = d;\\n        }\\n    }\\n    \\n    public int lengthLongestPath(String input) {\\n        String[] arr = input.split(\"\\\\n\");\\n        \\n        if(arr.length == 0) {\\n            return 0;\\n        }\\n        \\n        Deque<Node> stack = new ArrayDeque();\\n        int totalSize = 0;\\n        int maxFileLen = 0;\\n        \\n        for(int i = 0; i < arr.length; i++) {\\n            String[] ar = arr[i].split(\"\\\\t\");\\n            \\n            int depth = ar.length - 1;\\n            String fileName = ar[depth];\\n            \\n            \\n            Node thisNode = stack.peekFirst();\\n            while(thisNode != null && thisNode.depth > depth -1) {\\n                stack.pollFirst();\\n                totalSize -= (thisNode.size);\\n                thisNode = stack.peekFirst();\\n            }\\n            \\n            int thisLength = fileName.length();\\n            if(thisNode != null) {\\n                thisLength++;\\n            }\\n            \\n            stack.offerFirst(new Node(thisLength, depth));\\n            totalSize += thisLength;\\n        \\n            if(isFile(fileName)) {\\n                maxFileLen = Math.max(maxFileLen, totalSize);\\n            }\\n        }\\n        \\n        return maxFileLen;\\n    }\\n    \\n    private boolean isFile(String input) {\\n        return input.contains(\".\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658339,
                "title": "c-faster-than-100-super-simple-o-n-time-space",
                "content": "Solution steps:\\n1. Find next path segment (ex. \"dir/sub/file.c\" has 3 segments dir, sub, file.c)\\n2. Calculate depth of segment by counting tabs in prefix\\n3. Pop segments from stack if segments in stack are equal to depth\\n4. if current segment is a file then update max path size if greater\\n5. else push this directory to stack.\\n\\n```\\nclass Solution {\\npublic:\\n  int lengthLongestPath(string input) {\\n    int maxPathLen = 0;\\n    stack<string> dirsInPath;\\n    int dirsLen = 0;\\n    long start = 0;\\n    while (true) {\\n      auto segmentEndIndex = input.find(\\'\\\\n\\', start);\\n      string segmentWithTabs = input.substr(start, segmentEndIndex - start);\\n      \\n      auto tabEndIndex = segmentWithTabs.find_first_not_of(\\'\\\\t\\');\\n      string segment = segmentWithTabs.substr(tabEndIndex);\\n      \\n      int depth = count(segmentWithTabs.begin(), segmentWithTabs.end(), \\'\\\\t\\');\\n      bool isFile = segment.find(\\'.\\') != string::npos;\\n      \\n      while (dirsInPath.size() > depth) {\\n        string segmentPoped = dirsInPath.top();\\n        dirsInPath.pop();\\n        dirsLen -= segmentPoped.length();\\n      }\\n      if (isFile) {\\n        int currentFilePathLen = dirsLen + segment.length() + dirsInPath.size();\\n        maxPathLen = max(maxPathLen, currentFilePathLen);\\n      } else {\\n        dirsInPath.push(segment);\\n        dirsLen += segment.length();\\n      }\\n      \\n      if (segmentEndIndex == string::npos) break;\\n      start = segmentEndIndex + 1;\\n    }\\n    \\n    return maxPathLen;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int lengthLongestPath(string input) {\\n    int maxPathLen = 0;\\n    stack<string> dirsInPath;\\n    int dirsLen = 0;\\n    long start = 0;\\n    while (true) {\\n      auto segmentEndIndex = input.find(\\'\\\\n\\', start);\\n      string segmentWithTabs = input.substr(start, segmentEndIndex - start);\\n      \\n      auto tabEndIndex = segmentWithTabs.find_first_not_of(\\'\\\\t\\');\\n      string segment = segmentWithTabs.substr(tabEndIndex);\\n      \\n      int depth = count(segmentWithTabs.begin(), segmentWithTabs.end(), \\'\\\\t\\');\\n      bool isFile = segment.find(\\'.\\') != string::npos;\\n      \\n      while (dirsInPath.size() > depth) {\\n        string segmentPoped = dirsInPath.top();\\n        dirsInPath.pop();\\n        dirsLen -= segmentPoped.length();\\n      }\\n      if (isFile) {\\n        int currentFilePathLen = dirsLen + segment.length() + dirsInPath.size();\\n        maxPathLen = max(maxPathLen, currentFilePathLen);\\n      } else {\\n        dirsInPath.push(segment);\\n        dirsLen += segment.length();\\n      }\\n      \\n      if (segmentEndIndex == string::npos) break;\\n      start = segmentEndIndex + 1;\\n    }\\n    \\n    return maxPathLen;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646549,
                "title": "c-o-n-time-o-n-space",
                "content": "Time complexity : O(N) : visits total N letters in the input string only once.\\nSpace complexity : O(N) : stores at most (N-1) directories in the stack. \\n```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        \\n        \\n        // The stack stores the length of absolute path to the directories starting from the root directory to the current directory\\n        stack<int> s; \\n        \\n        int longest_path = 0;\\n        int dir_level = 0;\\n        int name_len = 0;\\n        bool isFile = false;\\n        for(size_t i = 0;i<=input.size();++i)\\n        {\\n            char c = i<input.size() ? input[i] : 0;\\n            \\n            if(c == \\'\\\\n\\' || i == input.size()) // A name is built. Process the new file/directory\\n            {\\n                // If the current dir level is lower than the directory level in the stack,\\n                // keep popping the stack until we get the stack to the same directory level as the current dir level.\\n                while(s.size() > dir_level)\\n                {\\n                    s.pop();\\n                }\\n                \\n                int parent_len = 0;\\n                if(s.empty() == false)\\n                {\\n                    parent_len = s.top()+1; // absolute length of the parent + 1 ( because of \\'/\\')\\n                }\\n                \\n                int absolute_path_len = parent_len + name_len; // absolute length of the current entry\\n                \\n                if(isFile)\\n                {\\n                    longest_path = std::max(longest_path, absolute_path_len); // Update the longest path\\n                }\\n                else\\n                {\\n                    s.push(absolute_path_len); // if this is a directory, push it to the stack\\n                }\\n                \\n                isFile = false;\\n                name_len = 0;\\n                dir_level = 0;\\n                continue;\\n            }\\n            if(c == \\'\\\\t\\')\\n            {\\n                ++dir_level; // increment current directory level\\n                name_len = 0;\\n                continue;\\n            }\\n            if(c == \\' \\' || isdigit(c) || isalpha(c))\\n            {\\n                ++name_len;\\n                continue;\\n            }\\n            if(c == \\'.\\')\\n            {\\n                isFile = true;\\n                ++name_len;\\n                continue;\\n            }\\n            \\n        }\\n        \\n        return longest_path;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        \\n        \\n        // The stack stores the length of absolute path to the directories starting from the root directory to the current directory\\n        stack<int> s; \\n        \\n        int longest_path = 0;\\n        int dir_level = 0;\\n        int name_len = 0;\\n        bool isFile = false;\\n        for(size_t i = 0;i<=input.size();++i)\\n        {\\n            char c = i<input.size() ? input[i] : 0;\\n            \\n            if(c == \\'\\\\n\\' || i == input.size()) // A name is built. Process the new file/directory\\n            {\\n                // If the current dir level is lower than the directory level in the stack,\\n                // keep popping the stack until we get the stack to the same directory level as the current dir level.\\n                while(s.size() > dir_level)\\n                {\\n                    s.pop();\\n                }\\n                \\n                int parent_len = 0;\\n                if(s.empty() == false)\\n                {\\n                    parent_len = s.top()+1; // absolute length of the parent + 1 ( because of \\'/\\')\\n                }\\n                \\n                int absolute_path_len = parent_len + name_len; // absolute length of the current entry\\n                \\n                if(isFile)\\n                {\\n                    longest_path = std::max(longest_path, absolute_path_len); // Update the longest path\\n                }\\n                else\\n                {\\n                    s.push(absolute_path_len); // if this is a directory, push it to the stack\\n                }\\n                \\n                isFile = false;\\n                name_len = 0;\\n                dir_level = 0;\\n                continue;\\n            }\\n            if(c == \\'\\\\t\\')\\n            {\\n                ++dir_level; // increment current directory level\\n                name_len = 0;\\n                continue;\\n            }\\n            if(c == \\' \\' || isdigit(c) || isalpha(c))\\n            {\\n                ++name_len;\\n                continue;\\n            }\\n            if(c == \\'.\\')\\n            {\\n                isFile = true;\\n                ++name_len;\\n                continue;\\n            }\\n            \\n        }\\n        \\n        return longest_path;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636084,
                "title": "simple-java-solution-1ms",
                "content": "```\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        int maxLength=0;\\n        String[] paths=input.split(\"\\\\n\");\\n        Stack<PathVal> st=new Stack<>();\\n        for(String path:paths){\\n            int count=0;\\n            for(int i=0;i<path.length();i++){\\n                char c=path.charAt(i);\\n                if(c==\\'\\\\t\\'){\\n                    count++;\\n                }\\n            }\\n             while(!st.empty()&&(st.peek().count>=count)){\\n                st.pop();\\n            }\\n            int length=path.length()+(st.empty()?0:st.peek().length);\\n            length=length-count;\\n            if(!st.empty())length++;\\n            PathVal pathVal=new PathVal(count,length);\\n            if(path.contains(\".\")){\\n                maxLength=Math.max(maxLength,pathVal.length);\\n            }\\n            st.push(pathVal);\\n        }\\n        return maxLength;\\n    }\\n}\\nclass PathVal{\\n    int count,length;\\n    public PathVal(int count,int length){\\n        this.count=count;\\n        this.length=length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        int maxLength=0;\\n        String[] paths=input.split(\"\\\\n\");\\n        Stack<PathVal> st=new Stack<>();\\n        for(String path:paths){\\n            int count=0;\\n            for(int i=0;i<path.length();i++){\\n                char c=path.charAt(i);\\n                if(c==\\'\\\\t\\'){\\n                    count++;\\n                }\\n            }\\n             while(!st.empty()&&(st.peek().count>=count)){\\n                st.pop();\\n            }\\n            int length=path.length()+(st.empty()?0:st.peek().length);\\n            length=length-count;\\n            if(!st.empty())length++;\\n            PathVal pathVal=new PathVal(count,length);\\n            if(path.contains(\".\")){\\n                maxLength=Math.max(maxLength,pathVal.length);\\n            }\\n            st.push(pathVal);\\n        }\\n        return maxLength;\\n    }\\n}\\nclass PathVal{\\n    int count,length;\\n    public PathVal(int count,int length){\\n        this.count=count;\\n        this.length=length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594066,
                "title": "java-o-n-1ms-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n\\n        input = input.replace(\"\\\\t\", \"#\").replace(\"\\\\n\", \"@\");\\n\\n        String[] str = input.split(\"@\");\\n\\n        map.put(-1, 0);\\n        int result = 0;\\n\\n        for (String s: str) {\\n            int count = countLevel(s); \\n            map.put(count, map.getOrDefault(count - 1, 0) + s.length() - count);\\n            if (s.contains(\".\")) result = Math.max(result, map.get(count) + count);\\n        }\\n\\n        return result;\\n    }\\n\\n    int countLevel(String s) {\\n        int count = 0;\\n        while (s.charAt(count) == \\'#\\') count++;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n\\n        input = input.replace(\"\\\\t\", \"#\").replace(\"\\\\n\", \"@\");\\n\\n        String[] str = input.split(\"@\");\\n\\n        map.put(-1, 0);\\n        int result = 0;\\n\\n        for (String s: str) {\\n            int count = countLevel(s); \\n            map.put(count, map.getOrDefault(count - 1, 0) + s.length() - count);\\n            if (s.contains(\".\")) result = Math.max(result, map.get(count) + count);\\n        }\\n\\n        return result;\\n    }\\n\\n    int countLevel(String s) {\\n        int count = 0;\\n        while (s.charAt(count) == \\'#\\') count++;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587396,
                "title": "python-stack-o-n-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        \\n        #Put a dummy root into stack. First & second elements of tuple represents level and length of current path.\\n        stack = [(-1, 0)]\\n        \\n        #Split path into relative file path\\n        path_arr = input.split(\"\\\\n\")\\n        max_length = 0\\n        \\n        ##Find hierarchy of the file\\n        def find_level(file_name):\\n            level = 0\\n            i = 0\\n            while file_name[i] == \"\\\\t\":\\n                level += 1\\n                i += 1\\n            return level\\n        \\n        for file_path in path_arr:\\n            file_level = find_level(file_path)\\n            \\n            #Current file/directory should be one level down compared to its parent, otherwise pop file in stack\\n            while stack[-1][0] != file_level - 1:\\n                stack.pop()\\n                \\n            file_name_length = len(file_path) - file_level + stack[-1][1]\\n            \\n            \\n            #Check if current path is file or directory\\n            \\n            #If it is file, we can compare it with max length so far\\n            if \".\" in file_path:\\n                max_length = max(max_length, file_name_length)\\n             \\n            #If it is directory, add it to stack. Need to add 1 to account for \"\\\\\"\\n            else:\\n                stack.append((file_level, file_name_length + 1))\\n                \\n        return max_length\\n            \\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        \\n        #Put a dummy root into stack. First & second elements of tuple represents level and length of current path.\\n        stack = [(-1, 0)]\\n        \\n        #Split path into relative file path\\n        path_arr = input.split(\"\\\\n\")\\n        max_length = 0\\n        \\n        ##Find hierarchy of the file\\n        def find_level(file_name):\\n            level = 0\\n            i = 0\\n            while file_name[i] == \"\\\\t\":\\n                level += 1\\n                i += 1\\n            return level\\n        \\n        for file_path in path_arr:\\n            file_level = find_level(file_path)\\n            \\n            #Current file/directory should be one level down compared to its parent, otherwise pop file in stack\\n            while stack[-1][0] != file_level - 1:\\n                stack.pop()\\n                \\n            file_name_length = len(file_path) - file_level + stack[-1][1]\\n            \\n            \\n            #Check if current path is file or directory\\n            \\n            #If it is file, we can compare it with max length so far\\n            if \".\" in file_path:\\n                max_length = max(max_length, file_name_length)\\n             \\n            #If it is directory, add it to stack. Need to add 1 to account for \"\\\\\"\\n            else:\\n                stack.append((file_level, file_name_length + 1))\\n                \\n        return max_length\\n            \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580743,
                "title": "very-concise-solution-using-a-stack",
                "content": "```\\npublic int lengthLongestPath(String input) {\\n        String[] inputArr = input.split(\"\\\\n\");\\n        \\n        int level = -1;\\n        int len = 0;\\n        int max = 0;\\n        Stack<String> stack = new Stack<>();\\n        for(int i = 0; i < inputArr.length; i++){\\n            int tabIdx = 0;\\n            while(inputArr[i].charAt(tabIdx) == \\'\\\\t\\'){\\n                tabIdx++;\\n            }\\n            while(level >= tabIdx){\\n                len -= stack.pop().length();\\n                level--;\\n            }\\n            \\n            String s = inputArr[i].substring(tabIdx)+\\'/\\';\\n            \\n            if(s.contains(\".\")){\\n\\t\\t\\t    // - 1 because we added \\'/\\' at the end\\n                max = Math.max(max, len+s.length() -1);\\n            }\\n            \\n            stack.push(s);\\n            len += s.length();\\n            level++;\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int lengthLongestPath(String input) {\\n        String[] inputArr = input.split(\"\\\\n\");\\n        \\n        int level = -1;\\n        int len = 0;\\n        int max = 0;\\n        Stack<String> stack = new Stack<>();\\n        for(int i = 0; i < inputArr.length; i++){\\n            int tabIdx = 0;\\n            while(inputArr[i].charAt(tabIdx) == \\'\\\\t\\'){\\n                tabIdx++;\\n            }\\n            while(level >= tabIdx){\\n                len -= stack.pop().length();\\n                level--;\\n            }\\n            \\n            String s = inputArr[i].substring(tabIdx)+\\'/\\';\\n            \\n            if(s.contains(\".\")){\\n\\t\\t\\t    // - 1 because we added \\'/\\' at the end\\n                max = Math.max(max, len+s.length() -1);\\n            }\\n            \\n            stack.push(s);\\n            len += s.length();\\n            level++;\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1547145,
                "title": "java-solution-longest-absolute-file-path",
                "content": "\\n```\\npublic int lengthLongestPath(String input) {\\n        Stack<Integer> st = new Stack<>();\\n        String str[] = input.split(\"\\\\n\"); // split based on \\\\n i.e how many paths\\n        int maxlen = 0; // maximum length\\n        st.push(0);//root\\n        for (String s : str) {\\n            \\n            int tabs = s.lastIndexOf(\"\\\\t\")+1; // number of tabs\\n            int level = tabs + 1; // no. of level\\n            while (level < st.size()) { // pop till reaches to the level\\n                st.pop();\\n            }\\n            int currlevel = s.length() + st.peek() - tabs + 1; // curr level is total length from dir(st.peek()+s.length()) - number of tabs\\n            if (s.contains(\".\")) { // if it is file then calculate maximum length\\n                maxlen = Math.max(maxlen, currlevel - 1);\\n            } else { // if dir then push to stack\\n                st.push(currlevel);\\n            }\\n            \\n        }\\n        return maxlen;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int lengthLongestPath(String input) {\\n        Stack<Integer> st = new Stack<>();\\n        String str[] = input.split(\"\\\\n\"); // split based on \\\\n i.e how many paths\\n        int maxlen = 0; // maximum length\\n        st.push(0);//root\\n        for (String s : str) {\\n            \\n            int tabs = s.lastIndexOf(\"\\\\t\")+1; // number of tabs\\n            int level = tabs + 1; // no. of level\\n            while (level < st.size()) { // pop till reaches to the level\\n                st.pop();\\n            }\\n            int currlevel = s.length() + st.peek() - tabs + 1; // curr level is total length from dir(st.peek()+s.length()) - number of tabs\\n            if (s.contains(\".\")) { // if it is file then calculate maximum length\\n                maxlen = Math.max(maxlen, currlevel - 1);\\n            } else { // if dir then push to stack\\n                st.push(currlevel);\\n            }\\n            \\n        }\\n        return maxlen;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1543272,
                "title": "python-very-clean-stack-solution",
                "content": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        mx, cur_len = 0, 0\\n        input = input.split(\"\\\\n\")\\n        stack = []\\n        for p in input:\\n            p = p.split(\"\\\\t\")\\n\\t\\t\\t# len(p) = p\\'s corresponding layer\\n\\t\\t\\t# we pop the stack until we reach p\\'s parent directory\\n            while len(stack) >= len(p):\\n                cur_len -= len(stack.pop())\\n            \\n            stack.append(p[-1])\\n            cur_len += len(p[-1])\\n            \\n            if len(p[-1].split(\".\")) > 1:\\n                mx = max(mx, len(stack) + cur_len - 1)\\n\\n        return mx\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        mx, cur_len = 0, 0\\n        input = input.split(\"\\\\n\")\\n        stack = []\\n        for p in input:\\n            p = p.split(\"\\\\t\")\\n\\t\\t\\t# len(p) = p\\'s corresponding layer\\n\\t\\t\\t# we pop the stack until we reach p\\'s parent directory\\n            while len(stack) >= len(p):\\n                cur_len -= len(stack.pop())\\n            \\n            stack.append(p[-1])\\n            cur_len += len(p[-1])\\n            \\n            if len(p[-1].split(\".\")) > 1:\\n                mx = max(mx, len(stack) + cur_len - 1)\\n\\n        return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480776,
                "title": "c-100-time-short",
                "content": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        vector<string>files;\\n        string str = \"\";\\n        for(int i = 0; i <= input.size(); ++i)\\n        {\\n            if(i == input.size()||input[i]==\\'\\\\n\\')\\n                files.push_back(str),str=\"\";\\n            else\\n                str += input[i];\\n        }\\n        int ans = 0;\\n        map<int,int>depth;\\n        for(string &str:files)\\n        {\\n            int i;\\n            for(i = 0; i < str.size() && str[i]==\\'\\\\t\\'; ++i);\\n            depth[i] = depth[i-1]+(int)str.size()-i;\\n            if(str.find(\\'.\\')!=string::npos)\\n            ans = max(ans,depth[i]+i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        vector<string>files;\\n        string str = \"\";\\n        for(int i = 0; i <= input.size(); ++i)\\n        {\\n            if(i == input.size()||input[i]==\\'\\\\n\\')\\n                files.push_back(str),str=\"\";\\n            else\\n                str += input[i];\\n        }\\n        int ans = 0;\\n        map<int,int>depth;\\n        for(string &str:files)\\n        {\\n            int i;\\n            for(i = 0; i < str.size() && str[i]==\\'\\\\t\\'; ++i);\\n            depth[i] = depth[i-1]+(int)str.size()-i;\\n            if(str.find(\\'.\\')!=string::npos)\\n            ans = max(ans,depth[i]+i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456751,
                "title": "python-stack-easy-to-understand-with-explanation",
                "content": "Using python\\'s famous `split()` method, we are able to transform the funky input format to desired information.\\n\\n- `input.split(\"\\\\n\")` gives us all the individual file/directory regardless of levels. I call each of them an entity.\\n- `entity.split(\"\\\\t\")` makes all the arrows (`\\\\t`) into empty string and the actual file/directory name is at end of the split list. So we can get the depth from the lenght of the split list `len(pathes)` (intentionally include the name as well to make it 1-based) and the name from the last entry of split list `pathes[-1]`.\\n\\nThe rest is straghitforward. We use a stack to keep track of the current path length at given depth. So `stack[i]` refers to the current path length at depth `i + 1`. \\n\\nThe number of `pop()` we need to do each steps might be a little bit tricky to figure out. Imaging we are steping out of the previous directory.  Each `pop()` is like a `cd ..` action we need to perform in an actual file system. \\n\\nWhenever we ran into a file, we check the current path and update result by taking maximum.\\n\\n```\\nclass Solution(object):\\n    def lengthLongestPath(self, input):\\n        result = 0\\n        length = 0\\n        stack = []\\n        \\n        for entity in input.split(\"\\\\n\"):\\n            paths = entity.split(\"\\\\t\")\\n            depth = len(paths)\\n            name = paths[-1]\\n            \\n\\t\\t\\t# Stepping out of previous directory to current depth\\n            for i in range(len(stack) - depth + 1):\\n                stack.pop()\\n\\n\\t\\t\\t# We found a file. Update result if necessary\\n            if \\'.\\' in name:\\n                result = max(result, sum(stack) + len(name))\\n            else:\\n\\t\\t\\t\\t# Add to stack to track length if it\\'s a directory (note +1 is for the \"/\" between depths)\\n                stack.append(len(name) + 1)\\n                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def lengthLongestPath(self, input):\\n        result = 0\\n        length = 0\\n        stack = []\\n        \\n        for entity in input.split(\"\\\\n\"):\\n            paths = entity.split(\"\\\\t\")\\n            depth = len(paths)\\n            name = paths[-1]\\n            \\n\\t\\t\\t# Stepping out of previous directory to current depth\\n            for i in range(len(stack) - depth + 1):\\n                stack.pop()\\n\\n\\t\\t\\t# We found a file. Update result if necessary\\n            if \\'.\\' in name:\\n                result = max(result, sum(stack) + len(name))\\n            else:\\n\\t\\t\\t\\t# Add to stack to track length if it\\'s a directory (note +1 is for the \"/\" between depths)\\n                stack.append(len(name) + 1)\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454519,
                "title": "java-straightforward-solution-using-stack-and-string-api",
                "content": "```\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        \\n        int maxFound=0;\\n        int currentLength =0;\\n        \\n        String segment[] = input.split(\"\\\\n\");\\n        \\n        for(String str: segment){\\n            \\n            int level = str.lastIndexOf(\"\\\\t\")+1;\\n            \\n            while(level<stack.size()){\\n                currentLength = currentLength-stack.pop();\\n            }\\n            int lengthOfSegment = str.length()-level;\\n            \\n            if(str.indexOf(\".\")==-1){\\n                stack.push(lengthOfSegment);\\n                currentLength+=lengthOfSegment;\\n            }else{\\n                maxFound = Math.max(maxFound,currentLength+lengthOfSegment+level);\\n            }\\n        }\\n        return maxFound;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        \\n        int maxFound=0;\\n        int currentLength =0;\\n        \\n        String segment[] = input.split(\"\\\\n\");\\n        \\n        for(String str: segment){\\n            \\n            int level = str.lastIndexOf(\"\\\\t\")+1;\\n            \\n            while(level<stack.size()){\\n                currentLength = currentLength-stack.pop();\\n            }\\n            int lengthOfSegment = str.length()-level;\\n            \\n            if(str.indexOf(\".\")==-1){\\n                stack.push(lengthOfSegment);\\n                currentLength+=lengthOfSegment;\\n            }else{\\n                maxFound = Math.max(maxFound,currentLength+lengthOfSegment+level);\\n            }\\n        }\\n        return maxFound;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448906,
                "title": "python-iterative-stack-solution",
                "content": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        lines = input.split(\\'\\\\n\\')\\n        \\n        path_elements = [] # [{tab_count, element}, ...] only contains a single path\\n        \"\"\"\\n        assumptions:\\n        - root can be dir or file\\n        - no trailing ws \\n        - all paths are valid, no invalid path like file.txt/invalid_path\\n        - here we call the / delimited parts in the path, elements. file and dir are elements.\\n        \"\"\"\\n        \\n        max_path_len = 0\\n        \\n        \\n        for line in lines:\\n            # Compute tab count and actual element name\\n            tab_count = line.count(\\'\\\\t\\')\\n            element = line.replace(\\'\\\\t\\', \\'\\')\\n            \\n\\t\\t\\t# pop out the last element, of which the current element is not a sub-element\\n            while len(path_elements) and path_elements[-1][\\'tab_count\\'] >= tab_count:\\n                path_elements.pop()\\n            \\n            path_elements.append({\\n                \\'tab_count\\': tab_count,\\n                \\'element\\': element\\n            })\\n           \\n            if \\'.\\' in element:\\n                # element is a file\\n                curr_path_len = len(\\'/\\'.join([e[\\'element\\'] for e in path_elements]))\\n                max_path_len = max(max_path_len, curr_path_len)\\n            \\n            \\n        return max_path_len\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        lines = input.split(\\'\\\\n\\')\\n        \\n        path_elements = [] # [{tab_count, element}, ...] only contains a single path\\n        \"\"\"\\n        assumptions:\\n        - root can be dir or file\\n        - no trailing ws \\n        - all paths are valid, no invalid path like file.txt/invalid_path\\n        - here we call the / delimited parts in the path, elements. file and dir are elements.\\n        \"\"\"\\n        \\n        max_path_len = 0\\n        \\n        \\n        for line in lines:\\n            # Compute tab count and actual element name\\n            tab_count = line.count(\\'\\\\t\\')\\n            element = line.replace(\\'\\\\t\\', \\'\\')\\n            \\n\\t\\t\\t# pop out the last element, of which the current element is not a sub-element\\n            while len(path_elements) and path_elements[-1][\\'tab_count\\'] >= tab_count:\\n                path_elements.pop()\\n            \\n            path_elements.append({\\n                \\'tab_count\\': tab_count,\\n                \\'element\\': element\\n            })\\n           \\n            if \\'.\\' in element:\\n                # element is a file\\n                curr_path_len = len(\\'/\\'.join([e[\\'element\\'] for e in path_elements]))\\n                max_path_len = max(max_path_len, curr_path_len)\\n            \\n            \\n        return max_path_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400386,
                "title": "simple-python-monotonic-stack-solution",
                "content": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        mono_stack = []\\n        ret = 0\\n        for entry in input.splitlines():\\n            name, depth = entry.lstrip(\\'\\\\t\\'), entry.count(\"\\\\t\")\\n            # standard monotonic template\\n            while mono_stack and mono_stack[-1][1] >= depth:\\n                mono_stack.pop()\\n            prefix = mono_stack[-1][0]+\\'/\\' if mono_stack else \"\"                \\n            mono_stack.append((prefix+name, depth))\\n            # if we have a file, update maximum length\\n            if mono_stack and \\'.\\' in mono_stack[-1][0]:\\n                ret = max(ret, len(mono_stack[-1][0]))\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        mono_stack = []\\n        ret = 0\\n        for entry in input.splitlines():\\n            name, depth = entry.lstrip(\\'\\\\t\\'), entry.count(\"\\\\t\")\\n            # standard monotonic template\\n            while mono_stack and mono_stack[-1][1] >= depth:\\n                mono_stack.pop()\\n            prefix = mono_stack[-1][0]+\\'/\\' if mono_stack else \"\"                \\n            mono_stack.append((prefix+name, depth))\\n            # if we have a file, update maximum length\\n            if mono_stack and \\'.\\' in mono_stack[-1][0]:\\n                ret = max(ret, len(mono_stack[-1][0]))\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340589,
                "title": "clean-python3-solution-using-prefix-sum",
                "content": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        strList = input.split(\\'\\\\n\\')\\n        presum = [0]\\n        maxLen = 0\\n        for line in strList:\\n            level = 0\\n            i = 0\\n            while i < len(line) and line[i] == \\'\\\\t\\':\\n                level += 1\\n                i += 1\\n            curLen = len(line) - i\\n            if \\'.\\' in line:\\n                maxLen = max(maxLen, presum[level] + curLen)\\n                continue\\n            if level + 1 >= len(presum):\\n                presum.append(presum[-1] + curLen + 1)\\n            else:\\n                presum[level+1] = presum[level] + curLen + 1\\n        return maxLen\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        strList = input.split(\\'\\\\n\\')\\n        presum = [0]\\n        maxLen = 0\\n        for line in strList:\\n            level = 0\\n            i = 0\\n            while i < len(line) and line[i] == \\'\\\\t\\':\\n                level += 1\\n                i += 1\\n            curLen = len(line) - i\\n            if \\'.\\' in line:\\n                maxLen = max(maxLen, presum[level] + curLen)\\n                continue\\n            if level + 1 >= len(presum):\\n                presum.append(presum[-1] + curLen + 1)\\n            else:\\n                presum[level+1] = presum[level] + curLen + 1\\n        return maxLen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1281721,
                "title": "10-lines-0ms-java-solution",
                "content": "```\\n    public int lengthLongestPath(String input) {\\n        int ans = 0;\\n        int[] sum = new int[input.length() + 1];\\n        for (String line : input.split(\"\\\\n\")) {\\n            int level = line.lastIndexOf(\\'\\\\t\\') + 2;\\n            int len = line.length() - (level - 1);\\n            if (line.contains(\".\")) {\\n                ans = Math.max(ans, sum[level - 1] + len);\\n            } else {\\n                sum[level] = sum[level - 1] + len + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int lengthLongestPath(String input) {\\n        int ans = 0;\\n        int[] sum = new int[input.length() + 1];\\n        for (String line : input.split(\"\\\\n\")) {\\n            int level = line.lastIndexOf(\\'\\\\t\\') + 2;\\n            int len = line.length() - (level - 1);\\n            if (line.contains(\".\")) {\\n                ans = Math.max(ans, sum[level - 1] + len);\\n            } else {\\n                sum[level] = sum[level - 1] + len + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1274745,
                "title": "388-stack-push-parentfolder-return-max-file-length",
                "content": "---\\n\\nAnother implementation wise difficult & due to edge cases\\n\\n---\\n\\n**Algo**\\n- Tab (\\\\t) means going to child/ sub folder\\n  - More tabs means going deeper folders, like child of child, etc.\\n  - Less tabs means going up to parent folders\\n- Divide input to lines\\n  - Then count number of tabs at the begin of each line\\n    - 1st line will not have tab\\n    - 2nd line may be at same level as 1st line, or deeper into a child folder\\n    - Similarly other levels may be at same level, deeper into a child folder, or they may go up to parent levels\\n  - Each time we go in to a child folder, add string to stack (start stack having 1 empty string for easy operations)\\n    - Every time we add, we need to concatinate previous stack/top element with \\'/\\' and then with new string we got\\n    - The new string we remove tab in the front for ease of calculating exact length\\n  - Delete previous on stack if at same level\\n  - Delete as many as requried from stack top based on levels (tabs) of current string\\n- Each time we add, after concatination, we take save it in max length if length is greater than previous max\\n- Return max\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar lengthLongestPath = function(S) {\\n    let max = 0;\\n    let stack = [\\'\\'];\\n\\n    let prev_level = -1;\\n    for (let s of S.split(\"\\\\n\")) {\\n\\n        let i = 0;\\n        let curr_level = 0\\n        let s2 = s;\\n        for (; i < s2.length && s2[i] === \\'\\\\t\\'; i++)\\n            curr_level++; //                number of tabs is number of levels\\n        if (curr_level) //                  if not 0 level, remove tabs (\\\\t s)\\n            s2 = \\'/\\' + s2.slice(i)\\n\\n        if (curr_level === prev_level) {\\n            stack.pop(); //                         same folder - remove last value at same level\\n        } else if (curr_level < prev_level) { //    parent folder - going up some levels\\n            let ups = 1 + prev_level - curr_level;\\n            while (ups--)\\n                stack.pop();\\n        }\\n        stack[stack.length] = stack[stack.length - 1] + s2; // add new string to stack\\n        if (s.indexOf(\\'.\\') !== -1) { //     if file, take max len\\n            max = Math.max(max, stack[stack.length - 1].length)\\n        }\\n\\n        prev_level = curr_level\\n    }\\n\\n    return max\\n};\\n```\\n\\n---\\n\\n> Optimize multiple times to get 100% speed:\\n\\n\\n![image](https://assets.leetcode.com/users/images/bfc2a444-c50d-4ddb-a136-0b9a02e5a527_1623774750.507812.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar lengthLongestPath = function(S) {\\n    let max = 0;\\n    let stack = [\\'\\'];\\n\\n    let prev_level = -1;\\n    for (let s of S.split(\"\\\\n\")) {\\n\\n        let i = 0;\\n        let curr_level = 0\\n        let s2 = s;\\n        for (; i < s2.length && s2[i] === \\'\\\\t\\'; i++)\\n            curr_level++; //                number of tabs is number of levels\\n        if (curr_level) //                  if not 0 level, remove tabs (\\\\t s)\\n            s2 = \\'/\\' + s2.slice(i)\\n\\n        if (curr_level === prev_level) {\\n            stack.pop(); //                         same folder - remove last value at same level\\n        } else if (curr_level < prev_level) { //    parent folder - going up some levels\\n            let ups = 1 + prev_level - curr_level;\\n            while (ups--)\\n                stack.pop();\\n        }\\n        stack[stack.length] = stack[stack.length - 1] + s2; // add new string to stack\\n        if (s.indexOf(\\'.\\') !== -1) { //     if file, take max len\\n            max = Math.max(max, stack[stack.length - 1].length)\\n        }\\n\\n        prev_level = curr_level\\n    }\\n\\n    return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1253682,
                "title": "c-o-n-using-stack",
                "content": "Will push the current length including `\\\\` into stack. So when we get a file, we just add the length of the file name with top of the stack.\\n\\n```\\npublic class Solution {\\n    public int LengthLongestPath(string input) {\\n        \\n        int ans = 0;\\n        \\n        Stack<int> st = new Stack<int>();\\n        \\n\\t\\t// splitting string by `\\\\n` so that we process one line at a time\\n        string[] splitted = input.Split(\\'\\\\n\\');\\n        \\n        for(int i=0; i<splitted.Length; i++)\\n        {\\n            int nt = 0;\\n            for(int j=0; j<splitted[i].Length; j++)\\n            {   \\n\\t\\t\\t   //calculating number of tabs to calculate the level\\n                if(splitted[i][j] != \\'\\\\t\\')\\n                {\\n                    break;\\n                }\\n                nt++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Popping stack if the stack has more levels the current level\\n            while(st.Count > (nt))\\n            {\\n                st.Pop();\\n            }\\n            \\n            int peek = 0;\\n            \\n            if (st.Count > 0)\\n            {\\n\\t\\t\\t    // if the stack as atleast one element, we need to add 1, so that we count \\'/\\' character\\n                peek = st.Peek() + 1;\\n            }\\n            \\n            if (splitted[i].Contains(\\'.\\'))\\n            {\\n                //file\\n                int cur = splitted[i].Length - nt + peek;\\n                if (cur > ans)\\n                {\\n                    ans = cur;\\n                }\\n            }\\n            else {\\n                //dir\\n                st.Push(splitted[i].Length - nt + peek);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LengthLongestPath(string input) {\\n        \\n        int ans = 0;\\n        \\n        Stack<int> st = new Stack<int>();\\n        \\n\\t\\t// splitting string by `\\\\n` so that we process one line at a time\\n        string[] splitted = input.Split(\\'\\\\n\\');\\n        \\n        for(int i=0; i<splitted.Length; i++)\\n        {\\n            int nt = 0;\\n            for(int j=0; j<splitted[i].Length; j++)\\n            {   \\n\\t\\t\\t   //calculating number of tabs to calculate the level\\n                if(splitted[i][j] != \\'\\\\t\\')\\n                {\\n                    break;\\n                }\\n                nt++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Popping stack if the stack has more levels the current level\\n            while(st.Count > (nt))\\n            {\\n                st.Pop();\\n            }\\n            \\n            int peek = 0;\\n            \\n            if (st.Count > 0)\\n            {\\n\\t\\t\\t    // if the stack as atleast one element, we need to add 1, so that we count \\'/\\' character\\n                peek = st.Peek() + 1;\\n            }\\n            \\n            if (splitted[i].Contains(\\'.\\'))\\n            {\\n                //file\\n                int cur = splitted[i].Length - nt + peek;\\n                if (cur > ans)\\n                {\\n                    ans = cur;\\n                }\\n            }\\n            else {\\n                //dir\\n                st.Push(splitted[i].Length - nt + peek);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243744,
                "title": "java-o-n-using-stack",
                "content": "* Stack to store the current path to the file. \\n* Count the number of tabs seen and pop from the stack until number of tabs matches size of the stack. \\n* Push new directory/file to stack.\\n* If a file, update the maxLength.\\n\\n```\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        String[] parts = input.split(\"\\\\n\");\\n        Stack<String> s = new Stack();\\n        int maxLength = 0, currLength = 0;\\n        for(String part : parts) {\\n            String[] parts2 = part.split(\"\\\\t\");\\n            while(s.size() != parts2.length - 1) { String val = s.pop(); currLength -= val.length()+1; }\\n            String pathSegment = parts2[parts2.length - 1]; \\n            currLength += pathSegment.length()+1;\\n            if(pathSegment.split(\"\\\\\\\\.\").length>=2) { maxLength = Math.max(currLength, maxLength); }\\n            s.push(pathSegment);\\n        }\\n        \\n        return Math.max(maxLength-1, 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        String[] parts = input.split(\"\\\\n\");\\n        Stack<String> s = new Stack();\\n        int maxLength = 0, currLength = 0;\\n        for(String part : parts) {\\n            String[] parts2 = part.split(\"\\\\t\");\\n            while(s.size() != parts2.length - 1) { String val = s.pop(); currLength -= val.length()+1; }\\n            String pathSegment = parts2[parts2.length - 1]; \\n            currLength += pathSegment.length()+1;\\n            if(pathSegment.split(\"\\\\\\\\.\").length>=2) { maxLength = Math.max(currLength, maxLength); }\\n            s.push(pathSegment);\\n        }\\n        \\n        return Math.max(maxLength-1, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230717,
                "title": "no-dfs-no-stack-simple-o-n-java",
                "content": "Idea is to calculate level of each file/folder. Level will be equal to number of \\\\t prefixed in file name.\\n\\nIf you know level for current file is L then level of its parent will be L-1(except for root).\\n\\nIf you know length of absolute path till parent then length of current file will be length of parent + 1 + currFileNameLength.\\n\\nAs input is given in inorder(DFS), then we can just use single array to keep track of path. \\n\\n```\\nclass Solution {\\n    public int lengthLongestPath(String s) {\\n        int[] arr = new int[s.length()];\\n        int ans = 0;\\n        \\n        for (int i = 0; i < s.length(); ) {\\n            if (s.charAt(i) == \\'\\\\n\\') i++;\\n            \\n            int level = 0;\\n            while (i < s.length() && s.charAt(i) == \\'\\\\t\\') {\\n                i++;\\n                level++;\\n            }\\n            \\n            int count = 0;\\n            boolean isFile = false;\\n            while (i < s.length() && s.charAt(i) != \\'\\\\n\\') {\\n                if (s.charAt(i) == \\'.\\') isFile = true;\\n                i++;\\n                count++;\\n            }\\n            \\n            arr[level] = (level == 0 ? count : arr[level-1] + 1 + count);\\n            \\n            if (isFile) {\\n                ans = Math.max(ans, arr[level]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lengthLongestPath(String s) {\\n        int[] arr = new int[s.length()];\\n        int ans = 0;\\n        \\n        for (int i = 0; i < s.length(); ) {\\n            if (s.charAt(i) == \\'\\\\n\\') i++;\\n            \\n            int level = 0;\\n            while (i < s.length() && s.charAt(i) == \\'\\\\t\\') {\\n                i++;\\n                level++;\\n            }\\n            \\n            int count = 0;\\n            boolean isFile = false;\\n            while (i < s.length() && s.charAt(i) != \\'\\\\n\\') {\\n                if (s.charAt(i) == \\'.\\') isFile = true;\\n                i++;\\n                count++;\\n            }\\n            \\n            arr[level] = (level == 0 ? count : arr[level-1] + 1 + count);\\n            \\n            if (isFile) {\\n                ans = Math.max(ans, arr[level]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230073,
                "title": "c-o-n-faster-than-100-0ms-using-stack",
                "content": "The solution is to use a stack to keep track of previous directories. If top of stack has directory with more `\\\\t` then keep popping to find parent directory of current file/directory.\\n```\\nclass Solution {\\npublic:\\n    string delimiter = \"\\\\n\";\\n    string dot = \".\";\\n    char tab = \\'\\\\t\\';\\n    int lengthLongestPath(string input) {\\n        int i = 0, len = input.size(), ans = 0;\\n        stack<vector<int>> parentLength;\\n        parentLength.push({0, 0});\\n        int maxNumTabs = 0;\\n        while(i < len) {\\n            size_t found = input.find(delimiter, i);\\n            string token = input.substr(i, found - i);\\n            size_t file = token.find(dot);\\n            int numTabs = 0;\\n            int j = 0;\\n            while(j < token.size() && token[j++] == tab)\\n                numTabs++;\\n            while(numTabs <= parentLength.top()[1] && parentLength.size() > 1) \\n                parentLength.pop();\\n            if(file != string::npos) {\\n                ans = max(ans, (int)(parentLength.top()[0] + token.size()));\\n                \\n            } else {\\n                parentLength.push({(int)(parentLength.top()[0] + token.size() - numTabs), numTabs});\\n            }\\n            if(found == string::npos)\\n                break;\\n            i = found + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string delimiter = \"\\\\n\";\\n    string dot = \".\";\\n    char tab = \\'\\\\t\\';\\n    int lengthLongestPath(string input) {\\n        int i = 0, len = input.size(), ans = 0;\\n        stack<vector<int>> parentLength;\\n        parentLength.push({0, 0});\\n        int maxNumTabs = 0;\\n        while(i < len) {\\n            size_t found = input.find(delimiter, i);\\n            string token = input.substr(i, found - i);\\n            size_t file = token.find(dot);\\n            int numTabs = 0;\\n            int j = 0;\\n            while(j < token.size() && token[j++] == tab)\\n                numTabs++;\\n            while(numTabs <= parentLength.top()[1] && parentLength.size() > 1) \\n                parentLength.pop();\\n            if(file != string::npos) {\\n                ans = max(ans, (int)(parentLength.top()[0] + token.size()));\\n                \\n            } else {\\n                parentLength.push({(int)(parentLength.top()[0] + token.size() - numTabs), numTabs});\\n            }\\n            if(found == string::npos)\\n                break;\\n            i = found + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226650,
                "title": "java-dfs-like-solution",
                "content": "```\\nclass Solution {\\n    \\n    private int maxPath;\\n    private int index;\\n    public int lengthLongestPath(String input) {\\n        // This will be a DFS like traversal\\n        // for every encountered file we should keep our current path\\n        // when we backtrack, we should remove one element from the path\\n        // the way the format looks like is - we will exhaust a path before we continue to paths\\n        // with the same prefix\\n        \\n        maxPath = 0;\\n        List<String> currentPath = new ArrayList<>();\\n        this.index = 0;\\n        dfs(input, currentPath);\\n        return maxPath;\\n    }\\n    \\n    \\n    private int getNumOfTabs(String input) {\\n        if (index >= input.length()) {\\n            return -1;\\n        }\\n        \\n        int result = 0;\\n        while (input.charAt(index) == \\'\\\\t\\') {\\n            result++;\\n            index++;\\n        }\\n        return result;\\n    }\\n    \\n    \\n    private void dfs(String input, List<String> currentPath) {\\n        while (true) {\\n             int tempIndex = index;\\n             int numOfTabs = getNumOfTabs(input);\\n             if (numOfTabs < currentPath.size()) {\\n                 index = tempIndex; //back tracking\\n                 return;\\n             }\\n           \\n            int endOfNodeIndex = input.indexOf(\\'\\\\n\\', index);\\n            if (endOfNodeIndex == -1) {\\n                endOfNodeIndex = input.length();\\n            }\\n            int dotIndex = input.indexOf(\".\", index);\\n            String node = input.substring(index, endOfNodeIndex);\\n            index = endOfNodeIndex+1;\\n            \\n            if (dotIndex > 0 && (dotIndex < endOfNodeIndex)) {\\n                handleFile(currentPath, node);\\n            }\\n            else {\\n                currentPath.add(node);\\n                dfs(input, currentPath);\\n                currentPath.remove(currentPath.size() -1); //back tracking\\n            }\\n        }\\n    }\\n    \\n    private void handleFile(List<String> currentPath, String file) {\\n        int pathLen = currentPath.stream().mapToInt(String::length).sum();\\n        int numOfSlashes = currentPath.size();\\n        //path len holds the path characters, we need also to add \"/\"\\n        maxPath = Math.max(maxPath, numOfSlashes +  pathLen  + file.length());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private int maxPath;\\n    private int index;\\n    public int lengthLongestPath(String input) {\\n        // This will be a DFS like traversal\\n        // for every encountered file we should keep our current path\\n        // when we backtrack, we should remove one element from the path\\n        // the way the format looks like is - we will exhaust a path before we continue to paths\\n        // with the same prefix\\n        \\n        maxPath = 0;\\n        List<String> currentPath = new ArrayList<>();\\n        this.index = 0;\\n        dfs(input, currentPath);\\n        return maxPath;\\n    }\\n    \\n    \\n    private int getNumOfTabs(String input) {\\n        if (index >= input.length()) {\\n            return -1;\\n        }\\n        \\n        int result = 0;\\n        while (input.charAt(index) == \\'\\\\t\\') {\\n            result++;\\n            index++;\\n        }\\n        return result;\\n    }\\n    \\n    \\n    private void dfs(String input, List<String> currentPath) {\\n        while (true) {\\n             int tempIndex = index;\\n             int numOfTabs = getNumOfTabs(input);\\n             if (numOfTabs < currentPath.size()) {\\n                 index = tempIndex; //back tracking\\n                 return;\\n             }\\n           \\n            int endOfNodeIndex = input.indexOf(\\'\\\\n\\', index);\\n            if (endOfNodeIndex == -1) {\\n                endOfNodeIndex = input.length();\\n            }\\n            int dotIndex = input.indexOf(\".\", index);\\n            String node = input.substring(index, endOfNodeIndex);\\n            index = endOfNodeIndex+1;\\n            \\n            if (dotIndex > 0 && (dotIndex < endOfNodeIndex)) {\\n                handleFile(currentPath, node);\\n            }\\n            else {\\n                currentPath.add(node);\\n                dfs(input, currentPath);\\n                currentPath.remove(currentPath.size() -1); //back tracking\\n            }\\n        }\\n    }\\n    \\n    private void handleFile(List<String> currentPath, String file) {\\n        int pathLen = currentPath.stream().mapToInt(String::length).sum();\\n        int numOfSlashes = currentPath.size();\\n        //path len holds the path characters, we need also to add \"/\"\\n        maxPath = Math.max(maxPath, numOfSlashes +  pathLen  + file.length());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223364,
                "title": "java-using-stack-easy-to-understand",
                "content": "```\\nclass Solution {\\n       \\n    public int lengthLongestPath(String input) {\\n        int idx = 0;\\n        int length = input.length();\\n        int max = 0;\\n        int pathLength = 0;\\n        int level=0;\\n        Stack<String> stack = new Stack<>();\\n        while(idx < length){\\n            \\n            if(input.charAt(idx) == \\'\\\\n\\'){\\n                idx++;\\n                continue;\\n            }\\n            \\n            if (input.charAt(idx) == \\'\\\\t\\'){\\n                level++;\\n                idx++;\\n                continue;\\n            }\\n            \\n            StringBuilder buffer = new StringBuilder();\\n            while (idx < length && !(input.charAt(idx) == \\'\\\\n\\' || input.charAt(idx) == \\'\\\\t\\')){\\n                buffer.append(input.charAt(idx));\\n                idx++;\\n            }\\n            \\n            while(level < stack.size()){\\n                String goBack = stack.pop();\\n                pathLength = pathLength - goBack.length();\\n            }\\n            \\n            if (buffer.indexOf(\".\") != -1){     \\n                //this is a file\\n                max = Math.max(max, pathLength+buffer.length());\\n            }else{\\n                //this is a directory\\n                buffer.append(\"/\");\\n                stack.add(buffer.toString());\\n                pathLength+=buffer.length();\\n            }\\n            \\n            level = 0;            \\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n       \\n    public int lengthLongestPath(String input) {\\n        int idx = 0;\\n        int length = input.length();\\n        int max = 0;\\n        int pathLength = 0;\\n        int level=0;\\n        Stack<String> stack = new Stack<>();\\n        while(idx < length){\\n            \\n            if(input.charAt(idx) == \\'\\\\n\\'){\\n                idx++;\\n                continue;\\n            }\\n            \\n            if (input.charAt(idx) == \\'\\\\t\\'){\\n                level++;\\n                idx++;\\n                continue;\\n            }\\n            \\n            StringBuilder buffer = new StringBuilder();\\n            while (idx < length && !(input.charAt(idx) == \\'\\\\n\\' || input.charAt(idx) == \\'\\\\t\\')){\\n                buffer.append(input.charAt(idx));\\n                idx++;\\n            }\\n            \\n            while(level < stack.size()){\\n                String goBack = stack.pop();\\n                pathLength = pathLength - goBack.length();\\n            }\\n            \\n            if (buffer.indexOf(\".\") != -1){     \\n                //this is a file\\n                max = Math.max(max, pathLength+buffer.length());\\n            }else{\\n                //this is a directory\\n                buffer.append(\"/\");\\n                stack.add(buffer.toString());\\n                pathLength+=buffer.length();\\n            }\\n            \\n            level = 0;            \\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191123,
                "title": "scala-tailrec-solution",
                "content": "```\\nobject Solution {\\n    def lengthLongestPath(input: String): Int = {\\n        val lines = input.split(\"\\\\n\").toList\\n        \\n        @scala.annotation.tailrec\\n        def lengthLongestPathTailRec(remaining: List[String], maxLength: Int, depth_map: Map[Int, Int]): Int = {\\n            if (remaining.isEmpty) maxLength\\n            else {\\n                val currentLine = remaining.head\\n                val path = currentLine.split(\"\\\\t\").toList.last\\n                val depth = currentLine.length - path.length\\n                \\n                if(path.contains(\\'.\\')) {\\n                    val newMax = Math.max(maxLength, depth_map(depth) + path.length)\\n                    lengthLongestPathTailRec(remaining.tail, newMax, depth_map)\\n                }\\n                else {\\n                    val newDepthMap = depth_map + ((depth + 1) -> (depth_map.getOrElse(depth,0) + path.length + 1))\\n                    lengthLongestPathTailRec(remaining.tail, maxLength, newDepthMap)\\n                }\\n            }\\n        }\\n        lengthLongestPathTailRec(lines, 0, Map(0 -> 0))\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n    def lengthLongestPath(input: String): Int = {\\n        val lines = input.split(\"\\\\n\").toList\\n        \\n        @scala.annotation.tailrec\\n        def lengthLongestPathTailRec(remaining: List[String], maxLength: Int, depth_map: Map[Int, Int]): Int = {\\n            if (remaining.isEmpty) maxLength\\n            else {\\n                val currentLine = remaining.head\\n                val path = currentLine.split(\"\\\\t\").toList.last\\n                val depth = currentLine.length - path.length\\n                \\n                if(path.contains(\\'.\\')) {\\n                    val newMax = Math.max(maxLength, depth_map(depth) + path.length)\\n                    lengthLongestPathTailRec(remaining.tail, newMax, depth_map)\\n                }\\n                else {\\n                    val newDepthMap = depth_map + ((depth + 1) -> (depth_map.getOrElse(depth,0) + path.length + 1))\\n                    lengthLongestPathTailRec(remaining.tail, maxLength, newDepthMap)\\n                }\\n            }\\n        }\\n        lengthLongestPathTailRec(lines, 0, Map(0 -> 0))\\n    }\\n}",
                "codeTag": "Python3"
            },
            {
                "id": 1156990,
                "title": "python-solution-with-stack-with-comments",
                "content": "```class Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        lines = input.split(\\'\\\\n\\')\\n        \\n        stack = []\\n        cur = 0\\n        \\n        ans = 0\\n        \\n        for ele in lines:\\n            \\n            count = ele.count(\\'\\\\t\\')    \\n            \\n            #If actual position of insertion for directory is not right\\n            while len(stack) > count:\\n                last = stack.pop()\\n                \\n                #Removing previous words and 1(for backslash)\\n                cur -= (len(last)+1)\\n                \\n            #Removing tabs\\n            ele = ele[count:]\\n\\n            #Adding element and 1(for backslash)\\n            cur += len(ele)+1\\n            stack.append(ele)\\n            \\n            if \\'.\\' in ele:\\n                ans = max(ans, cur-1)\\n        \\n        return ans",
                "solutionTags": [],
                "code": "```class Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        lines = input.split(\\'\\\\n\\')\\n        \\n        stack = []\\n        cur = 0\\n        \\n        ans = 0\\n        \\n        for ele in lines:\\n            \\n            count = ele.count(\\'\\\\t\\')    \\n            \\n            #If actual position of insertion for directory is not right\\n            while len(stack) > count:\\n                last = stack.pop()\\n                \\n                #Removing previous words and 1(for backslash)\\n                cur -= (len(last)+1)\\n                \\n            #Removing tabs\\n            ele = ele[count:]\\n\\n            #Adding element and 1(for backslash)\\n            cur += len(ele)+1\\n            stack.append(ele)\\n            \\n            if \\'.\\' in ele:\\n                ans = max(ans, cur-1)\\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1105723,
                "title": "python-stack-solution",
                "content": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        \"\"\"\\n        We split string by \\\\n and than check the level of each subdirectory/file.\\n        If level bigger than previus one we add to the stack tuple with it( cur_level, directory(file_name) ), else pop from it.\\n        Before pop we check if the current stack values contains filepath and compare with longest value.\\n        We put tuple (level_size, path_name) in the stack on each iteration.\\n        \"\"\"\\n        s = []\\n        longest = 0\\n        for dir in input.split(\"\\\\n\"):\\n            cur_level = dir.count(\\'\\\\t\\')\\n            while s and s[-1][0] >= cur_level:\\n                #Before pop element check if this a file path\\n                if \\'.\\' in s[-1][1]:\\n                    longest = max(longest, len(\"/\".join([dir_file_name for _, dir_file_name in s])))\\n                s.pop()\\n            s.append((cur_level, dir.replace(\\'\\\\t\\',\\'\\'))) #(level_size, path_name)\\n        if s and \\'.\\' in s[-1][1]:\\n            longest = max(longest, len(\"/\".join([dir_file_name for _, dir_file_name in s])))\\n        return longest\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        \"\"\"\\n        We split string by \\\\n and than check the level of each subdirectory/file.\\n        If level bigger than previus one we add to the stack tuple with it( cur_level, directory(file_name) ), else pop from it.\\n        Before pop we check if the current stack values contains filepath and compare with longest value.\\n        We put tuple (level_size, path_name) in the stack on each iteration.\\n        \"\"\"\\n        s = []\\n        longest = 0\\n        for dir in input.split(\"\\\\n\"):\\n            cur_level = dir.count(\\'\\\\t\\')\\n            while s and s[-1][0] >= cur_level:\\n                #Before pop element check if this a file path\\n                if \\'.\\' in s[-1][1]:\\n                    longest = max(longest, len(\"/\".join([dir_file_name for _, dir_file_name in s])))\\n                s.pop()\\n            s.append((cur_level, dir.replace(\\'\\\\t\\',\\'\\'))) #(level_size, path_name)\\n        if s and \\'.\\' in s[-1][1]:\\n            longest = max(longest, len(\"/\".join([dir_file_name for _, dir_file_name in s])))\\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1100556,
                "title": "simplest-and-most-intuitive-solution-python",
                "content": "```\\ndef lengthLongestPath(self, input: str) -> int:\\n\\tlevel = {-1:0}\\n\\tmax_len = 0\\n\\tfor line in input.split(\"\\\\n\"):\\n\\t\\tdepth = line.count(\"\\\\t\")\\n\\t\\tlevel[depth] = len(line) - depth + level[depth-1]\\n\\n\\t\\tif \\'.\\' in line:\\n\\t\\t\\tmax_len = max(max_len, level[depth]+depth)\\n\\treturn max_len\\n```",
                "solutionTags": [],
                "code": "```\\ndef lengthLongestPath(self, input: str) -> int:\\n\\tlevel = {-1:0}\\n\\tmax_len = 0\\n\\tfor line in input.split(\"\\\\n\"):\\n\\t\\tdepth = line.count(\"\\\\t\")\\n\\t\\tlevel[depth] = len(line) - depth + level[depth-1]\\n\\n\\t\\tif \\'.\\' in line:\\n\\t\\t\\tmax_len = max(max_len, level[depth]+depth)\\n\\treturn max_len\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1030554,
                "title": "simple-c-o-n",
                "content": "```\\nint lengthLongestPath(string input) {\\n    int maxLen = 0;\\n    vector<int> history;\\n    for (int i = 0 ; i < input.size() ; ++i) {\\n        int depth = 0;\\n        int length = 0;\\n        bool file = false;\\n        for (; i < input.size() && input[i] != \\'\\\\n\\' ; ++i) {\\n            if (input[i] == \\'\\\\t\\')\\n                ++depth;\\n            else {\\n                if (input[i] == \\'.\\')\\n                    file = true;\\n                ++length;\\n            }\\n        }\\n        history.resize(depth);\\n        history.push_back(history.empty() ? length : (history.back() + length + 1));\\n        if (file)\\n            maxLen = max(maxLen, history.back());\\n    }\\n    return maxLen;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint lengthLongestPath(string input) {\\n    int maxLen = 0;\\n    vector<int> history;\\n    for (int i = 0 ; i < input.size() ; ++i) {\\n        int depth = 0;\\n        int length = 0;\\n        bool file = false;\\n        for (; i < input.size() && input[i] != \\'\\\\n\\' ; ++i) {\\n            if (input[i] == \\'\\\\t\\')\\n                ++depth;\\n            else {\\n                if (input[i] == \\'.\\')\\n                    file = true;\\n                ++length;\\n            }\\n        }\\n        history.resize(depth);\\n        history.push_back(history.empty() ? length : (history.back() + length + 1));\\n        if (file)\\n            maxLen = max(maxLen, history.back());\\n    }\\n    return maxLen;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1003815,
                "title": "my-1ms-java-solution-with-list",
                "content": "```\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        int res = 0;\\n        List<Integer> l = new ArrayList<>();\\n        String[] paths = input.split(\"\\\\n\");\\n        \\n        for (String path : paths) {\\n            int i = 0, j = 0;\\n            for (j = 0; j < path.length(); j++) {\\n                if (l.size()-1 < j) l.add(0);\\n                if (path.charAt(j) == \\'\\\\t\\') continue;\\n                l.set(j, (j > 0 ? l.get(j-1) : 0) + path.length() - j);\\n                break;\\n            }\\n            if (path.contains(\".\"))\\n                res = Math.max(res, l.get(j) + j);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        int res = 0;\\n        List<Integer> l = new ArrayList<>();\\n        String[] paths = input.split(\"\\\\n\");\\n        \\n        for (String path : paths) {\\n            int i = 0, j = 0;\\n            for (j = 0; j < path.length(); j++) {\\n                if (l.size()-1 < j) l.add(0);\\n                if (path.charAt(j) == \\'\\\\t\\') continue;\\n                l.set(j, (j > 0 ? l.get(j-1) : 0) + path.length() - j);\\n                break;\\n            }\\n            if (path.contains(\".\"))\\n                res = Math.max(res, l.get(j) + j);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998151,
                "title": "c-faster-than-100-very-simplified-soln-using-strtok-and-vector-string-not-the-best-code",
                "content": "//uncomment the comments to get clear view of run\\n```\\nclass Solution {\\npublic:\\n    bool isfile(char* s)\\n    {\\n        while(*s)\\n        {\\n            if(*s == \\'.\\')\\n                return true;\\n            s++;\\n        }\\n        return false;\\n    }\\n    int calcdepth(char* s)\\n    {\\n        int count=0;\\n        while(*s==\\'\\\\t\\')\\n        {\\n            count++;\\n            s++;\\n        }\\n        return count;\\n    }\\n    int lengthLongestPath(string input) {\\n        if(input.empty())return 0;\\n        vector<string> result;\\n        int maxlen=0;\\n        char *str=strtok(&input[0],\"\\\\n\");\\n        while(NULL != str)\\n        {\\n            int depth = calcdepth(str);\\n            //cout<<\"str \"<<str+depth<<\" depth \"<<depth<<endl;\\n            result.resize(depth);\\n            result.push_back(string(str+depth));\\n            if(isfile(str))\\n            {\\n                int len =0;\\n                for(auto& s:result)\\n                {\\n                    //cout<<s<<\"/\";\\n                    len+=s.length();\\n                }\\n                len+=depth;\\n               // cout<<endl;\\n                if(len > maxlen)\\n                    maxlen = len;\\n            }\\n            str=strtok(NULL,\"\\\\n\");\\n        }\\n        return maxlen;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isfile(char* s)\\n    {\\n        while(*s)\\n        {\\n            if(*s == \\'.\\')\\n                return true;\\n            s++;\\n        }\\n        return false;\\n    }\\n    int calcdepth(char* s)\\n    {\\n        int count=0;\\n        while(*s==\\'\\\\t\\')\\n        {\\n            count++;\\n            s++;\\n        }\\n        return count;\\n    }\\n    int lengthLongestPath(string input) {\\n        if(input.empty())return 0;\\n        vector<string> result;\\n        int maxlen=0;\\n        char *str=strtok(&input[0],\"\\\\n\");\\n        while(NULL != str)\\n        {\\n            int depth = calcdepth(str);\\n            //cout<<\"str \"<<str+depth<<\" depth \"<<depth<<endl;\\n            result.resize(depth);\\n            result.push_back(string(str+depth));\\n            if(isfile(str))\\n            {\\n                int len =0;\\n                for(auto& s:result)\\n                {\\n                    //cout<<s<<\"/\";\\n                    len+=s.length();\\n                }\\n                len+=depth;\\n               // cout<<endl;\\n                if(len > maxlen)\\n                    maxlen = len;\\n            }\\n            str=strtok(NULL,\"\\\\n\");\\n        }\\n        return maxlen;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 976277,
                "title": "java-hashmap-solution-faster-than-84",
                "content": "```\\nclass Solution {    \\n    public int lengthLongestPath(String input) {\\n        String[] splits = input.split(\"\\\\n\");\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int level = 0;\\n        map.put(level, -1);\\n        int curLen = 0, maxL = 0;\\n        for (String s : splits) {\\n            String[] sp = s.split(\"\\\\t\");\\n            int len = sp.length;\\n            int parentLen = map.get(len-1);\\n            curLen = sp[len-1].length() + parentLen + 1;\\n            map.put(len, curLen);\\n            if (s.contains(\".\")) {\\n                maxL = Math.max(maxL, curLen);\\n            } \\n        }\\n        return maxL;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {    \\n    public int lengthLongestPath(String input) {\\n        String[] splits = input.split(\"\\\\n\");\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int level = 0;\\n        map.put(level, -1);\\n        int curLen = 0, maxL = 0;\\n        for (String s : splits) {\\n            String[] sp = s.split(\"\\\\t\");\\n            int len = sp.length;\\n            int parentLen = map.get(len-1);\\n            curLen = sp[len-1].length() + parentLen + 1;\\n            map.put(len, curLen);\\n            if (s.contains(\".\")) {\\n                maxL = Math.max(maxL, curLen);\\n            } \\n        }\\n        return maxL;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 970231,
                "title": "python-solutions-using-hashtable-or-stack",
                "content": "Using hash table\\n```\\n# N: length of input\\n# K: maximum depth of path\\n# Time O(N) and Space O(K)\\n\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        def isFile(elem):\\n            return len(elem.split(\\'.\\')) > 1\\n        def extract(elem):\\n            arr = elem.split(\\'\\\\t\\')\\n            # Return level and only dir or file w/o \\\\t\\n            return len(arr) - 1, arr[-1]\\n        \\n        elems = input.split(\\'\\\\n\\')\\n        latestPath = defaultdict(str)\\n        latestPath[0] = elems[0]\\n        longest, curLength = len(elems[0]) if isFile(elems[0]) else 0, len(elems[0])       \\n        for elem in elems[1:]:\\n            curLevel, curElem = extract(elem)\\n            latestPath[curLevel] = latestPath[curLevel - 1] + \\'/\\' + curElem if curLevel > 0 else curElem\\n            if isFile(curElem):\\n                # Depth of stack will be the depth of dirs, thus we need to append len(stack) - 1\\n                longest = max(longest, len(latestPath[curLevel]))\\n        return longest\\n```\\n\\nUsing stack\\n```\\n# Time O(N * K) and Space O(K)\\n\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        def isFile(elem):\\n            return len(elem.split(\\'.\\')) > 1\\n        def extract(elem):\\n            arr = elem.split(\\'\\\\t\\')\\n            # Return level and only dir or file w/o \\\\t\\n            return len(arr) - 1, arr[-1]\\n        \\n        elems = input.split(\\'\\\\n\\')\\n        stack = [(0, elems[0])]\\n        longest, curLength = len(elems[0]) if isFile(elems[0]) else 0, len(elems[0])       \\n        for elem in elems[1:]:\\n            curLevel, curElem = extract(elem)\\n            while len(stack) > 0 and stack[-1][0] >= curLevel:\\n                # Pop till last elem\\'s level is lower than curLevel\\n                lastLevel, lastElem = stack.pop(-1)\\n                curLength -= len(lastElem)            \\n            # Push\\n            curLength += len(curElem)\\n            stack.append((curLevel, curElem))\\n            if isFile(curElem):\\n                # Depth of stack will be the depth of dirs, thus we need to append len(stack) - 1\\n                longest = max(longest, curLength + len(stack) - 1)\\n        return longest\\n```",
                "solutionTags": [],
                "code": "```\\n# N: length of input\\n# K: maximum depth of path\\n# Time O(N) and Space O(K)\\n\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        def isFile(elem):\\n            return len(elem.split(\\'.\\')) > 1\\n        def extract(elem):\\n            arr = elem.split(\\'\\\\t\\')\\n            # Return level and only dir or file w/o \\\\t\\n            return len(arr) - 1, arr[-1]\\n        \\n        elems = input.split(\\'\\\\n\\')\\n        latestPath = defaultdict(str)\\n        latestPath[0] = elems[0]\\n        longest, curLength = len(elems[0]) if isFile(elems[0]) else 0, len(elems[0])       \\n        for elem in elems[1:]:\\n            curLevel, curElem = extract(elem)\\n            latestPath[curLevel] = latestPath[curLevel - 1] + \\'/\\' + curElem if curLevel > 0 else curElem\\n            if isFile(curElem):\\n                # Depth of stack will be the depth of dirs, thus we need to append len(stack) - 1\\n                longest = max(longest, len(latestPath[curLevel]))\\n        return longest\\n```\n```\\n# Time O(N * K) and Space O(K)\\n\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        def isFile(elem):\\n            return len(elem.split(\\'.\\')) > 1\\n        def extract(elem):\\n            arr = elem.split(\\'\\\\t\\')\\n            # Return level and only dir or file w/o \\\\t\\n            return len(arr) - 1, arr[-1]\\n        \\n        elems = input.split(\\'\\\\n\\')\\n        stack = [(0, elems[0])]\\n        longest, curLength = len(elems[0]) if isFile(elems[0]) else 0, len(elems[0])       \\n        for elem in elems[1:]:\\n            curLevel, curElem = extract(elem)\\n            while len(stack) > 0 and stack[-1][0] >= curLevel:\\n                # Pop till last elem\\'s level is lower than curLevel\\n                lastLevel, lastElem = stack.pop(-1)\\n                curLength -= len(lastElem)            \\n            # Push\\n            curLength += len(curElem)\\n            stack.append((curLevel, curElem))\\n            if isFile(curElem):\\n                # Depth of stack will be the depth of dirs, thus we need to append len(stack) - 1\\n                longest = max(longest, curLength + len(stack) - 1)\\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951086,
                "title": "java-simple-to-understand",
                "content": "```\\n\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        String paths[] = input.split(\"\\\\n\");\\n        \\n        int max = 0;\\n        int[] lengths = new int[paths.length + 1];\\n        for(String p : paths){\\n            int lev = p.lastIndexOf(\"\\\\t\") + 1;\\n            if(p.contains(\".\")){\\n                int curlength = p.length() - lev + (lev == 0 ? 0 : lengths[lev -1]);\\n                max = Math.max(max,curlength);\\n            }else{\\n                lengths[lev] = (lev == 0 ? 0 : lengths[lev - 1] ) + p.length() - lev + 1;\\n            }\\n        }        \\n        return max;\\n    }\\n}\\n\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        String paths[] = input.split(\"\\\\n\");\\n        \\n        int max = 0;\\n        int[] lengths = new int[paths.length + 1];\\n        for(String p : paths){\\n            int lev = p.lastIndexOf(\"\\\\t\") + 1;\\n            if(p.contains(\".\")){\\n                int curlength = p.length() - lev + (lev == 0 ? 0 : lengths[lev -1]);\\n                max = Math.max(max,curlength);\\n            }else{\\n                lengths[lev] = (lev == 0 ? 0 : lengths[lev - 1] ) + p.length() - lev + 1;\\n            }\\n        }        \\n        return max;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939846,
                "title": "c-solution-with-96-55-runtime",
                "content": "**Runtime:** 68 ms, faster than 96.55% of C# online submissions for Longest Absolute File Path.\\n**Memory Usage:** 22.5 MB, less than 65.52% of C# online submissions for Longest Absolute File Path.\\n\\n```\\npublic class Solution {\\n    public int LengthLongestPath(string input) {\\n            // get all the folders & file names in array\\n            // each name will also contain \\'\\\\t\\' with itself.\\n            // number of \\'\\\\t\\' in the name will denotes it\\'s level of heirarchy\\n            string[] names = input.Split(\\'\\\\n\\');\\n            // each index will save the length of the name at it\\'s level\\n            List<int> length = new List<int>();\\n            // maximum length of the path until the file.\\n            int maxLength = 0;\\n            // to calculate the path length of the current file.\\n            int pathLength;\\n            // level of the current name (file/folder) in the heirarchy\\n            int level;\\n            // to store the name of the current file/folder\\n            string name;\\n\\n            // traverse through each name in the array\\n            for(int n = 0; n < names.Length; n++)\\n            {\\n                // read current name\\n                name = names[n];\\n\\n                level = 0;\\n                // find the level of current name in the heirarchy\\n                while (name[level] == \\'\\\\t\\')\\n                {\\n                    level++;\\n                }\\n\\n                // if current level got decreased, \\n                // remove all the length equals to and above current heirarchy.\\n                // that are not required now. \\n                // if last name was file, we already have calculated the name.\\n                // or if it was a folder, we dont need the length\\n                while (length.Count > level)\\n                {\\n                    length.RemoveAt(length.Count - 1);\\n                }\\n\\n                // add current name length at the top of the list.\\n                length.Add(name.Length - level);\\n\\n                // if this name is a file\\n                if (name.IndexOf(\\'.\\') > -1)\\n                {\\n                    pathLength = 0;\\n\\n                    // sum the length of all the names in the list.\\n                    // that\\'s the path, to reach upto this file.\\n                    for (int i = 0; i < length.Count; i++)\\n                    {\\n                        pathLength += length[i];\\n                    }\\n\\n                    // path length will also contains \\'/\\'s\\n                    // total number of names - 1 \\n                    pathLength += length.Count - 1;\\n\\n                    // save the max length\\n                    maxLength = Math.Max(pathLength, maxLength);\\n                }\\n            }\\n\\n            return maxLength;\\n        }\\n}\\n```\\n\\nfull program:\\nhttps://www.knowsh.com/Notes/270541/Longest-Absolute-File-Path",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LengthLongestPath(string input) {\\n            // get all the folders & file names in array\\n            // each name will also contain \\'\\\\t\\' with itself.\\n            // number of \\'\\\\t\\' in the name will denotes it\\'s level of heirarchy\\n            string[] names = input.Split(\\'\\\\n\\');\\n            // each index will save the length of the name at it\\'s level\\n            List<int> length = new List<int>();\\n            // maximum length of the path until the file.\\n            int maxLength = 0;\\n            // to calculate the path length of the current file.\\n            int pathLength;\\n            // level of the current name (file/folder) in the heirarchy\\n            int level;\\n            // to store the name of the current file/folder\\n            string name;\\n\\n            // traverse through each name in the array\\n            for(int n = 0; n < names.Length; n++)\\n            {\\n                // read current name\\n                name = names[n];\\n\\n                level = 0;\\n                // find the level of current name in the heirarchy\\n                while (name[level] == \\'\\\\t\\')\\n                {\\n                    level++;\\n                }\\n\\n                // if current level got decreased, \\n                // remove all the length equals to and above current heirarchy.\\n                // that are not required now. \\n                // if last name was file, we already have calculated the name.\\n                // or if it was a folder, we dont need the length\\n                while (length.Count > level)\\n                {\\n                    length.RemoveAt(length.Count - 1);\\n                }\\n\\n                // add current name length at the top of the list.\\n                length.Add(name.Length - level);\\n\\n                // if this name is a file\\n                if (name.IndexOf(\\'.\\') > -1)\\n                {\\n                    pathLength = 0;\\n\\n                    // sum the length of all the names in the list.\\n                    // that\\'s the path, to reach upto this file.\\n                    for (int i = 0; i < length.Count; i++)\\n                    {\\n                        pathLength += length[i];\\n                    }\\n\\n                    // path length will also contains \\'/\\'s\\n                    // total number of names - 1 \\n                    pathLength += length.Count - 1;\\n\\n                    // save the max length\\n                    maxLength = Math.Max(pathLength, maxLength);\\n                }\\n            }\\n\\n            return maxLength;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 930653,
                "title": "c-solution-using-deque-stack-100-time-90-memory-with-comments",
                "content": "```\\n/* Approach - \\n   * Using a deque (as a stack - easy to traverse) add the directories to stack\\n   * When came across a file or directory with \\'\\\\t\\' less than current elements in stack\\n     pop the extra directories out of stack... \\n   * When came across a file form the absolute path and remember max absolute path of all\\n     files that are in the input string\\n   * Created individual functions to keep it clean \\n*/\\n  \\nclass Solution {\\npublic:\\n    bool isAFile(string& item) {\\n        return (item.find(\\'.\\', 0) != string::npos);\\n    }\\n    \\n    int getTabsCount(string& item) {\\n        int count = 0;\\n        int i = 0;\\n        while(i < item.size() && i != string::npos) {\\n            int nI = item.find(\"\\\\t\", i);\\n            if (nI == string::npos) {\\n                break;\\n            }\\n            \\n            count++; // count # of \\'\\\\t\\'s encountered\\n            item.erase(nI, 1); // erase \\'\\\\t\\' from string\\n            i = nI; // no change in next lookup index due to erase.\\n        }\\n        \\n        return count;\\n    }\\n    \\n    int lengthLongestPath(string input) {\\n        deque<string> dq;\\n        int result = 0;\\n        \\n        int i = 0;\\n        while (i < input.size()) {\\n            int nI = input.find(\"\\\\n\", i); // get index of next \\\\n char\\n            if (nI == string::npos) {\\n                // if not found, rest of the string is a single item.\\n                nI = (int)input.size();\\n            }\\n            string item = input.substr(i, nI-i); // get the next item\\n            int count = getTabsCount(item); // also modifies the item to only contain item name\\n            bool isFile = isAFile(item);    // check if the item is a file\\n            \\n            while (count < dq.size()) {\\n                // if count (\\'\\\\t\\'s) is > current stack size we need to pop\\n                // extra recent directories out of stack\\n                dq.pop_back();\\n            }\\n            \\n            if (isFile) {\\n                // if a file find the absolute path using directories on stack\\n                string fileWithPath = \"\";\\n                for (string ele : dq) {\\n                    fileWithPath += ele;\\n                }\\n                fileWithPath += item;\\n                // remember max of file name size that we came across so far\\n                result = max(result, (int) fileWithPath.size());\\n            } else {\\n                // add the directory to dq\\n                dq.push_back(item + \\'/\\');\\n            }\\n            // advance to next lookup index by moving ahead of current \\'\\\\n\\' index\\n            i = nI + 1;\\n        }\\n        \\n        return result;\\n    }\\n};\\n   ```",
                "solutionTags": [],
                "code": "```\\n/* Approach - \\n   * Using a deque (as a stack - easy to traverse) add the directories to stack\\n   * When came across a file or directory with \\'\\\\t\\' less than current elements in stack\\n     pop the extra directories out of stack... \\n   * When came across a file form the absolute path and remember max absolute path of all\\n     files that are in the input string\\n   * Created individual functions to keep it clean \\n*/\\n  \\nclass Solution {\\npublic:\\n    bool isAFile(string& item) {\\n        return (item.find(\\'.\\', 0) != string::npos);\\n    }\\n    \\n    int getTabsCount(string& item) {\\n        int count = 0;\\n        int i = 0;\\n        while(i < item.size() && i != string::npos) {\\n            int nI = item.find(\"\\\\t\", i);\\n            if (nI == string::npos) {\\n                break;\\n            }\\n            \\n            count++; // count # of \\'\\\\t\\'s encountered\\n            item.erase(nI, 1); // erase \\'\\\\t\\' from string\\n            i = nI; // no change in next lookup index due to erase.\\n        }\\n        \\n        return count;\\n    }\\n    \\n    int lengthLongestPath(string input) {\\n        deque<string> dq;\\n        int result = 0;\\n        \\n        int i = 0;\\n        while (i < input.size()) {\\n            int nI = input.find(\"\\\\n\", i); // get index of next \\\\n char\\n            if (nI == string::npos) {\\n                // if not found, rest of the string is a single item.\\n                nI = (int)input.size();\\n            }\\n            string item = input.substr(i, nI-i); // get the next item\\n            int count = getTabsCount(item); // also modifies the item to only contain item name\\n            bool isFile = isAFile(item);    // check if the item is a file\\n            \\n            while (count < dq.size()) {\\n                // if count (\\'\\\\t\\'s) is > current stack size we need to pop\\n                // extra recent directories out of stack\\n                dq.pop_back();\\n            }\\n            \\n            if (isFile) {\\n                // if a file find the absolute path using directories on stack\\n                string fileWithPath = \"\";\\n                for (string ele : dq) {\\n                    fileWithPath += ele;\\n                }\\n                fileWithPath += item;\\n                // remember max of file name size that we came across so far\\n                result = max(result, (int) fileWithPath.size());\\n            } else {\\n                // add the directory to dq\\n                dq.push_back(item + \\'/\\');\\n            }\\n            // advance to next lookup index by moving ahead of current \\'\\\\n\\' index\\n            i = nI + 1;\\n        }\\n        \\n        return result;\\n    }\\n};\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 922792,
                "title": "keep-track-of-last-level-length-python-3",
                "content": "\\tdef lengthLongestPath(self, input: str) -> int:\\n        li = input.split(\\'\\\\n\\')\\n        self.ans = 0\\n        d_last_level_len = {}\\n        \\n        for each in li:\\n            level = each.count(\"\\\\t\")\\n            if \".\" not in each:\\n                if level > 0:\\n                    d_last_level_len[level] = d_last_level_len[level-1] + len(each) - level\\n                else:\\n                    d_last_level_len[level] = len(each)\\n            else:\\n                if level == 0:\\n                    self.ans = max(self.ans, len(each))\\n                else:\\n                    self.ans = max(self.ans, d_last_level_len[level-1]+len(each))\\n                \\n        \\n        return self.ans",
                "solutionTags": [],
                "code": "\\tdef lengthLongestPath(self, input: str) -> int:\\n        li = input.split(\\'\\\\n\\')\\n        self.ans = 0\\n        d_last_level_len = {}\\n        \\n        for each in li:\\n            level = each.count(\"\\\\t\")\\n            if \".\" not in each:\\n                if level > 0:\\n                    d_last_level_len[level] = d_last_level_len[level-1] + len(each) - level\\n                else:\\n                    d_last_level_len[level] = len(each)\\n            else:\\n                if level == 0:\\n                    self.ans = max(self.ans, len(each))\\n                else:\\n                    self.ans = max(self.ans, d_last_level_len[level-1]+len(each))\\n                \\n        \\n        return self.ans",
                "codeTag": "Python3"
            },
            {
                "id": 911941,
                "title": "python-clean-solution",
                "content": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        \\n        tokens = input.split(\\'\\\\n\\')\\n        \\n        if not tokens :\\n            return 0\\n        \\n        d = collections.defaultdict(int)\\n        output = 0\\n        \\n        for t in tokens :\\n            depth = t.count(\\'\\\\t\\')\\n            d[depth] = d[depth-1] + len(t) - depth\\n            \\n            if \\'.\\' in t :\\n                output = max(output, d[depth]+depth)\\n        \\n        return output\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        \\n        tokens = input.split(\\'\\\\n\\')\\n        \\n        if not tokens :\\n            return 0\\n        \\n        d = collections.defaultdict(int)\\n        output = 0\\n        \\n        for t in tokens :\\n            depth = t.count(\\'\\\\t\\')\\n            d[depth] = d[depth-1] + len(t) - depth\\n            \\n            if \\'.\\' in t :\\n                output = max(output, d[depth]+depth)\\n        \\n        return output\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 885591,
                "title": "swift-o-n-time-solution-4-ms",
                "content": "Swift O(n) time solution (4 ms)\\n```\\nclass Solution {\\n    func lengthLongestPath(_ input: String) -> Int {\\n        var stack = [Int](), result = 0, lvl = 0, lastLen = 0, totalLen = 0, file = false\\n        func check() {\\n            while stack.count > lvl {\\n                totalLen -= stack.removeLast()\\n            }\\n            if file {\\n                result = max(result, totalLen + lastLen)\\n            } else {\\n                totalLen += lastLen + 1\\n                stack.append(lastLen + 1)\\n            }\\n        }\\n        for char in input {\\n            switch char {\\n            case \"\\\\n\": check(); lvl = 0; lastLen = 0; file = false\\n            case \"\\\\t\": lvl += 1\\n            case \".\": lastLen += 1; file = true\\n            default: lastLen += 1\\n            }\\n        }\\n        check()\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func lengthLongestPath(_ input: String) -> Int {\\n        var stack = [Int](), result = 0, lvl = 0, lastLen = 0, totalLen = 0, file = false\\n        func check() {\\n            while stack.count > lvl {\\n                totalLen -= stack.removeLast()\\n            }\\n            if file {\\n                result = max(result, totalLen + lastLen)\\n            } else {\\n                totalLen += lastLen + 1\\n                stack.append(lastLen + 1)\\n            }\\n        }\\n        for char in input {\\n            switch char {\\n            case \"\\\\n\": check(); lvl = 0; lastLen = 0; file = false\\n            case \"\\\\t\": lvl += 1\\n            case \".\": lastLen += 1; file = true\\n            default: lastLen += 1\\n            }\\n        }\\n        check()\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 849266,
                "title": "java-1ms-two-stack-to-track-level-length",
                "content": "```class Solution {\\n    int max = 0;\\n    public int lengthLongestPath(String input) {\\n        Stack<Integer> length = new Stack<>();\\n        Stack<Integer> level = new Stack<>();\\n        \\n\\t\\t// dummy for peeking\\n        length.push(0);\\n        level.push(-1);\\n        \\n        String[] strs = input.split(\"\\\\n\");\\n        for(String str : strs){\\n            helper(str, length, level);    \\n        }\\n        return max;\\n    }\\n    \\n    void helper(String name, Stack<Integer> length, Stack<Integer> level){\\n        int lv = 0;\\n        for(int i = 0; i < name.length(); i++){\\n            char c = name.charAt(i);\\n            if(c == \\'\\\\t\\')\\n                lv++;\\n        }\\n        \\n        while(level.peek() >= lv){\\n            level.pop();\\n            length.pop();\\n        }\\n        \\n        length.push(length.peek() + (name.length() - lv));\\n        level.push(lv);\\n        \\n        if(name.contains(\".\")) //check if this is a file name\\n            max = Math.max(max, length.peek() + level.peek()); //each level consist one \\'/\\' character\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    int max = 0;\\n    public int lengthLongestPath(String input) {\\n        Stack<Integer> length = new Stack<>();\\n        Stack<Integer> level = new Stack<>();\\n        \\n\\t\\t// dummy for peeking\\n        length.push(0);\\n        level.push(-1);\\n        \\n        String[] strs = input.split(\"\\\\n\");\\n        for(String str : strs){\\n            helper(str, length, level);    \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 823830,
                "title": "python3-via-prefix-sum",
                "content": "Here, define a prefix sum to indicate the length of the path up to the current subdirectory. \\n\\n```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        ans = 0\\n        prefix = [0]\\n        for x in input.split(\"\\\\n\"): # split string into sub-dirs\\n            k = x.count(\"\\\\t\")\\n            x = x.lstrip(\"\\\\t\")\\n            if \".\" in x: ans = max(ans, prefix[k] + len(x)) # x is file \\n            else: \\n                if len(prefix) == k+1: prefix.append(prefix[-1] + 1 + len(x))\\n                else: prefix[k+1] = prefix[k] + 1 + len(x)\\n        return ans  \\n```\\n\\nEdited on 10/18/2020\\n```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        ans = 0\\n        prefix = {-1: 0}\\n        for subd in input.split(\"\\\\n\"): # sub-directory\\n            depth = subd.count(\"\\\\t\")\\n            prefix[depth] = prefix[depth-1] + len(subd) - depth # not including delimiter\\n            if \".\" in subd: ans = max(ans, prefix[depth] + depth) # including delimiter\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        ans = 0\\n        prefix = [0]\\n        for x in input.split(\"\\\\n\"): # split string into sub-dirs\\n            k = x.count(\"\\\\t\")\\n            x = x.lstrip(\"\\\\t\")\\n            if \".\" in x: ans = max(ans, prefix[k] + len(x)) # x is file \\n            else: \\n                if len(prefix) == k+1: prefix.append(prefix[-1] + 1 + len(x))\\n                else: prefix[k+1] = prefix[k] + 1 + len(x)\\n        return ans  \\n```\n```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        ans = 0\\n        prefix = {-1: 0}\\n        for subd in input.split(\"\\\\n\"): # sub-directory\\n            depth = subd.count(\"\\\\t\")\\n            prefix[depth] = prefix[depth-1] + len(subd) - depth # not including delimiter\\n            if \".\" in subd: ans = max(ans, prefix[depth] + depth) # including delimiter\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823092,
                "title": "c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    \\n    \\n    int traverse(int prefixLength, int startIndex, int level, string & input) {\\n        // you are the start index of the string\\n        // move from here\\n        int tempIndex = startIndex;\\n        bool fileFound = false;\\n        \\n        while(input[tempIndex]!=\\'\\\\n\\' && tempIndex < input.length()) {\\n            if(input[tempIndex] ==\\'.\\' ) fileFound = true;\\n            tempIndex++, prefixLength++;\\n        } \\n        cout << input.substr(startIndex, tempIndex-startIndex+1) << endl;\\n        if(fileFound)ans = max(ans, prefixLength+level);\\n        if(tempIndex == input.length()) return input.length();\\n//here input[tempIndex] = \\\\n\\n        tempIndex++;\\n        //\\n        while(true) {\\n            int numOfTabs = 0;\\n            while(input[tempIndex] == \\'\\\\t\\'  && tempIndex < input.length()) tempIndex++, numOfTabs++;\\n            if(tempIndex == input.length()) return input.length();\\n            if(numOfTabs == level+1) {\\n                tempIndex = traverse(prefixLength, tempIndex, level+1, input);\\n            } else{\\n                //cout << \"returning \" << tempIndex-numOfTabs << \" \" << input[tempIndex-numOfTabs] << endl;\\n                return tempIndex-numOfTabs;\\n            }\\n        }\\n    }\\n    \\n    \\n    \\n    int lengthLongestPath(string input) {\\n        int k = 0;\\n        while(k!=input.length()) {\\n            k = traverse(0, k, 0, input);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    \\n    \\n    int traverse(int prefixLength, int startIndex, int level, string & input) {\\n        // you are the start index of the string\\n        // move from here\\n        int tempIndex = startIndex;\\n        bool fileFound = false;\\n        \\n        while(input[tempIndex]!=\\'\\\\n\\' && tempIndex < input.length()) {\\n            if(input[tempIndex] ==\\'.\\' ) fileFound = true;\\n            tempIndex++, prefixLength++;\\n        } \\n        cout << input.substr(startIndex, tempIndex-startIndex+1) << endl;\\n        if(fileFound)ans = max(ans, prefixLength+level);\\n        if(tempIndex == input.length()) return input.length();\\n//here input[tempIndex] = \\\\n\\n        tempIndex++;\\n        //\\n        while(true) {\\n            int numOfTabs = 0;\\n            while(input[tempIndex] == \\'\\\\t\\'  && tempIndex < input.length()) tempIndex++, numOfTabs++;\\n            if(tempIndex == input.length()) return input.length();\\n            if(numOfTabs == level+1) {\\n                tempIndex = traverse(prefixLength, tempIndex, level+1, input);\\n            } else{\\n                //cout << \"returning \" << tempIndex-numOfTabs << \" \" << input[tempIndex-numOfTabs] << endl;\\n                return tempIndex-numOfTabs;\\n            }\\n        }\\n    }\\n    \\n    \\n    \\n    int lengthLongestPath(string input) {\\n        int k = 0;\\n        while(k!=input.length()) {\\n            k = traverse(0, k, 0, input);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 801901,
                "title": "java-stack-solution-beats-100-runtime",
                "content": "```java\\n/*\\n* Problem: https://leetcode.com/problems/longest-absolute-file-path\\n*/\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        Stack<int[]> stack = new Stack<>(); // tabcount, path length\\n        int maxLength = 0;\\n        for (String str: input.split(\"\\\\n\")) {\\n            int tabs = str.lastIndexOf(\\'\\\\t\\') + 1;\\n            while(!stack.isEmpty() && tabs <= stack.peek()[0]) {\\n                stack.pop();\\n            }\\n            if (stack.isEmpty()) {\\n                stack.push(new int[]{tabs, str.length() - tabs});\\n            } else {\\n                stack.push(new int[]{tabs, stack.peek()[1] + 1 + str.length() - tabs});\\n            }\\n            if (str.indexOf(\".\") >= 0) {\\n                maxLength = Math.max(maxLength, stack.peek()[1]);\\n            }\\n        }\\n        return maxLength;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n/*\\n* Problem: https://leetcode.com/problems/longest-absolute-file-path\\n*/\\nclass Solution {\\n    public int lengthLongestPath(String input) {\\n        Stack<int[]> stack = new Stack<>(); // tabcount, path length\\n        int maxLength = 0;\\n        for (String str: input.split(\"\\\\n\")) {\\n            int tabs = str.lastIndexOf(\\'\\\\t\\') + 1;\\n            while(!stack.isEmpty() && tabs <= stack.peek()[0]) {\\n                stack.pop();\\n            }\\n            if (stack.isEmpty()) {\\n                stack.push(new int[]{tabs, str.length() - tabs});\\n            } else {\\n                stack.push(new int[]{tabs, stack.peek()[1] + 1 + str.length() - tabs});\\n            }\\n            if (str.indexOf(\".\") >= 0) {\\n                maxLength = Math.max(maxLength, stack.peek()[1]);\\n            }\\n        }\\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797253,
                "title": "go-0ms",
                "content": "```\\nfunc lengthLongestPath(input string) int {    \\n    i := 0\\n    \\n    res := 0\\n    \\n    stack := []int{}\\n    \\n    for i < len(input) {\\n        word_len := 0\\n        level := 0\\n        \\n        isfile := false\\n        for i < len(input) && input[i] != \\'\\\\n\\' {\\n            if input[i] == \\'.\\' {\\n                isfile = true\\n            }\\n            if input[i] == \\'\\\\t\\' {\\n                level++\\n                word_len--\\n            }\\n            i++\\n            word_len++\\n        }\\n        i++\\n\\n        if level >= len(stack)  {\\n            stack = append(stack, 0)\\n        }\\n\\n        if level == 0 {\\n            stack[level] = word_len\\n        } else {\\n            stack[level] = word_len + stack[level - 1]\\n        }\\n    \\n        if isfile {\\n            res = max(res, stack[level] + level)\\n        }      \\n        stack = stack[:level + 1]\\n    }\\n    return res\\n}\\n\\nfunc max(a int, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc lengthLongestPath(input string) int {    \\n    i := 0\\n    \\n    res := 0\\n    \\n    stack := []int{}\\n    \\n    for i < len(input) {\\n        word_len := 0\\n        level := 0\\n        \\n        isfile := false\\n        for i < len(input) && input[i] != \\'\\\\n\\' {\\n            if input[i] == \\'.\\' {\\n                isfile = true\\n            }\\n            if input[i] == \\'\\\\t\\' {\\n                level++\\n                word_len--\\n            }\\n            i++\\n            word_len++\\n        }\\n        i++\\n\\n        if level >= len(stack)  {\\n            stack = append(stack, 0)\\n        }\\n\\n        if level == 0 {\\n            stack[level] = word_len\\n        } else {\\n            stack[level] = word_len + stack[level - 1]\\n        }\\n    \\n        if isfile {\\n            res = max(res, stack[level] + level)\\n        }      \\n        stack = stack[:level + 1]\\n    }\\n    return res\\n}\\n\\nfunc max(a int, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 790369,
                "title": "c-faster-than-100-less-memory-usage-than-78-easy-to-read-and-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        int maxLen = 0;\\n        vector<int> levels;\\n        int n = input.size();\\n        for (int i = 0;i<n;i++) {\\n            int level = 0;\\n            while (input[i]==\\'\\\\t\\') {level++;i++;}\\n            if (level>=levels.size()) levels.resize(level+1,0);\\n            levels[level] = 0;\\n            bool isFile = false;\\n            while (i<n && input[i]!=\\'\\\\n\\') {\\n                levels[level]++;\\n                if (input[i]==\\'.\\') isFile = true;\\n                i++;\\n            }\\n            if (!isFile) continue;\\n            int sum = level;\\n            for (int j = 0;j<=level;j++) sum+=levels[j];\\n            if (maxLen<sum) maxLen = sum;\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        int maxLen = 0;\\n        vector<int> levels;\\n        int n = input.size();\\n        for (int i = 0;i<n;i++) {\\n            int level = 0;\\n            while (input[i]==\\'\\\\t\\') {level++;i++;}\\n            if (level>=levels.size()) levels.resize(level+1,0);\\n            levels[level] = 0;\\n            bool isFile = false;\\n            while (i<n && input[i]!=\\'\\\\n\\') {\\n                levels[level]++;\\n                if (input[i]==\\'.\\') isFile = true;\\n                i++;\\n            }\\n            if (!isFile) continue;\\n            int sum = level;\\n            for (int j = 0;j<=level;j++) sum+=levels[j];\\n            if (maxLen<sum) maxLen = sum;\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744881,
                "title": "very-simple-python",
                "content": "The key corner case happens when file is under same directory as root. In that case, squash first 4 empty chars.\\n```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n         \\n        inp = input.split(\"\\\\n\")\\n        stack = [] # will contain (dirname, level)\\n        op = [0] #for empty result like \"a\"\\n        \\n        for item in inp:\\n            \\n            subitems = item.split(\"\\\\t\")\\n            \\n            c = len(subitems)\\n            last = subitems[-1]\\n            \\n            if c == 1 and last[0:4] == \"    \": #squash first 4 spaces if the item is at the same level as root directory\\n                last = last[4:]\\n            else:\\n                while stack and stack[-1][1] >= c:\\n                    stack.pop()\\n            \\n            if \\'.\\' in last:\\n                \\n                tmp = \"\"\\n                for s in stack:\\n                    tmp += s[0] + \\'/\\'                \\n                tmp += last\\n                \\n                op.append(len(tmp))\\n                \\n            else:             \\n                stack.append((last, c))\\n                \\n               \\n        return max(op)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n         \\n        inp = input.split(\"\\\\n\")\\n        stack = [] # will contain (dirname, level)\\n        op = [0] #for empty result like \"a\"\\n        \\n        for item in inp:\\n            \\n            subitems = item.split(\"\\\\t\")\\n            \\n            c = len(subitems)\\n            last = subitems[-1]\\n            \\n            if c == 1 and last[0:4] == \"    \": #squash first 4 spaces if the item is at the same level as root directory\\n                last = last[4:]\\n            else:\\n                while stack and stack[-1][1] >= c:\\n                    stack.pop()\\n            \\n            if \\'.\\' in last:\\n                \\n                tmp = \"\"\\n                for s in stack:\\n                    tmp += s[0] + \\'/\\'                \\n                tmp += last\\n                \\n                op.append(len(tmp))\\n                \\n            else:             \\n                stack.append((last, c))\\n                \\n               \\n        return max(op)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695247,
                "title": "python-dp",
                "content": "```\\nclass Solution(object):\\n    def lengthLongestPath(self, input):\\n        \"\"\"\\n        :type input: str\\n        :rtype: int\\n        \"\"\"\\n        \\n        inputs=input.split(\\'\\\\n\\')\\n        inputs=list(map(lambda x: (x.count(\\'\\\\t\\'),x.replace(\\'\\\\t\\',\\'\\')),inputs))\\n        #[(0, u\\'dir\\'), (1, u\\'subdir1\\'), (1, u\\'subdir2\\'), (2, u\\'file.ext\\')]        \\n        dp=[] # accumulated path length\\n        ans=0        \\n        for lvl,drct in inputs:\\n            length=len(drct)\\n\\n            if lvl>=len(dp):\\n                if lvl==0:\\n                    dp.append(length)\\n                else:\\n                    dp.append(length+1+dp[lvl-1])\\n            else:\\n                if lvl==0:\\n                    dp[0]=length\\n                else:\\n                    dp[lvl]=length+1+dp[lvl-1]            \\n            if \\'.\\' in drct:\\n                ans=max(ans,dp[lvl])\\n\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def lengthLongestPath(self, input):\\n        \"\"\"\\n        :type input: str\\n        :rtype: int\\n        \"\"\"\\n        \\n        inputs=input.split(\\'\\\\n\\')\\n        inputs=list(map(lambda x: (x.count(\\'\\\\t\\'),x.replace(\\'\\\\t\\',\\'\\')),inputs))\\n        #[(0, u\\'dir\\'), (1, u\\'subdir1\\'), (1, u\\'subdir2\\'), (2, u\\'file.ext\\')]        \\n        dp=[] # accumulated path length\\n        ans=0        \\n        for lvl,drct in inputs:\\n            length=len(drct)\\n\\n            if lvl>=len(dp):\\n                if lvl==0:\\n                    dp.append(length)\\n                else:\\n                    dp.append(length+1+dp[lvl-1])\\n            else:\\n                if lvl==0:\\n                    dp[0]=length\\n                else:\\n                    dp[lvl]=length+1+dp[lvl-1]            \\n            if \\'.\\' in drct:\\n                ans=max(ans,dp[lvl])\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679610,
                "title": "c-0ms-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        stringstream ss(input);\\n        string c;\\n        int ans = 0;\\n        unordered_map<int,int> m;\\n        while(getline(ss,c,\\'\\\\n\\')){\\n            int d = c.rfind(\\'\\\\t\\');\\n            c = (d == -1) ? c : c.substr(d+1); \\n            if(c.find(\\'.\\') != -1) ans = max(ans,m[d-1]+(int)c.size());\\n            else m[d] = m[d-1] + c.size() + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthLongestPath(string input) {\\n        stringstream ss(input);\\n        string c;\\n        int ans = 0;\\n        unordered_map<int,int> m;\\n        while(getline(ss,c,\\'\\\\n\\')){\\n            int d = c.rfind(\\'\\\\t\\');\\n            c = (d == -1) ? c : c.substr(d+1); \\n            if(c.find(\\'.\\') != -1) ans = max(ans,m[d-1]+(int)c.size());\\n            else m[d] = m[d-1] + c.size() + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 676894,
                "title": "java-1ms",
                "content": "\\n\\n\\tclass Solution {\\n\\t public int lengthLongestPath(String input) {\\n\\t\\t\\tif(null == input || !input.contains(\".\")) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\tStack<Integer> stack = new Stack<>();\\n\\t\\t\\tString[] splits = input.split(\"\\\\n\");\\n\\n\\t\\t\\tint maxLen = 0;\\n\\t\\t\\tfor (String split : splits) {\\n\\t\\t\\t\\tmaxLen = Math.max(maxLen, operate(split, stack));\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn maxLen;\\n\\t\\t}\\n\\n\\n\\t\\tprivate int operate(String str, Stack<Integer> stack) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\twhile(count < str.length() && str.charAt(count) == \\'\\\\t\\') {\\n\\t\\t\\t\\tcount ++;\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (stack.size() > count) {\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t}\\n\\n\\t\\t\\tint fileLen = str.length() - count;\\n\\t\\t\\tint lastLen = 0;\\n\\t\\t\\tif (!stack.isEmpty()) {\\n\\t\\t\\t\\tlastLen = stack.peek();\\n\\t\\t\\t\\tfileLen ++;\\n\\t\\t\\t}\\n\\t\\t\\tif (isFile(str)) {\\n\\t\\t\\t\\treturn lastLen + fileLen;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t stack.push(lastLen + fileLen);\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate boolean isFile(String str) {\\n\\t\\t\\treturn null != str && str.contains(\".\");\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t public int lengthLongestPath(String input) {\\n\\t\\t\\tif(null == input || !input.contains(\".\")) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 652339,
                "title": "java-solution-based-on-array-o-n-100-faster-and-0ms",
                "content": "```\\n    public int lengthLongestPath(String input) {\\n        String [] paths  = input.split(\"\\\\n\");\\n        int [] pathLength = new int [paths.length];\\n        int res = 0;\\n        for(int i =0;i<paths.length;i++){\\n            int level = 0;\\n            boolean isFile = false;\\n            int lengthOfFileOrDir = 0;\\n            int finalLength = 0;\\n            String curr = paths[i];\\n            for(int j =0;j<curr.length();j++){\\n                char c = curr.charAt(j);\\n                if(c == \\'.\\')\\n                    isFile = true;\\n                if(c == \\'\\\\t\\')\\n                    level++;\\n                else\\n                    lengthOfFileOrDir++;\\n            }\\n            finalLength = (level == 0?0:(pathLength[level -1]+1)) + lengthOfFileOrDir;\\n            if(isFile)\\n               res = Math.max(res,finalLength ) ;\\n            else\\n                pathLength[level] = finalLength;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int lengthLongestPath(String input) {\\n        String [] paths  = input.split(\"\\\\n\");\\n        int [] pathLength = new int [paths.length];\\n        int res = 0;\\n        for(int i =0;i<paths.length;i++){\\n            int level = 0;\\n            boolean isFile = false;\\n            int lengthOfFileOrDir = 0;\\n            int finalLength = 0;\\n            String curr = paths[i];\\n            for(int j =0;j<curr.length();j++){\\n                char c = curr.charAt(j);\\n                if(c == \\'.\\')\\n                    isFile = true;\\n                if(c == \\'\\\\t\\')\\n                    level++;\\n                else\\n                    lengthOfFileOrDir++;\\n            }\\n            finalLength = (level == 0?0:(pathLength[level -1]+1)) + lengthOfFileOrDir;\\n            if(isFile)\\n               res = Math.max(res,finalLength ) ;\\n            else\\n                pathLength[level] = finalLength;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 630313,
                "title": "c-0msec-with-explanation",
                "content": "There is a sub-structure to the problem. Directory are defined in the following way:\\n\\n[entry1] [\\\\n] [\\\\t...] [entry2] [\\\\n] [\\\\t...] ...\\n\\n\\\\t --  tells the depth\\n\\\\n -- delimiter\\n\\nWe can recursively parse this sub-structure and count max-length at each layer.\\n\\nStep 1: Seek and skip for \\'\\\\n\\'\\nStep 2: Count \\'\\\\t\\' to find the current dept and return if we have exhausted all paths in that sub-directory.\\nStep 3: Else find the length of the current entry and update max path, then recursively repeat the above steps for that entry\\n\\n\\n```\\n/*\\n * Count \\'\\\\t\\' to identify the depth\\n */\\nint finddirlevel(char *d) {\\n    int i = 0;\\n    while (d[i] && d[i] == \\'\\\\t\\')\\n        i += 1;\\n    return i;\\n}\\n\\n/*\\n * Count length of the entry\\n */\\nint findentrylen(char *d, bool *isfile) {\\n    int i = 0;\\n    while (d[i] && d[i] != \\'\\\\n\\') {\\n        if (d[i] == \\'.\\') *isfile = true;\\n        i++;\\n    }\\n    return i;\\n}\\n\\nint pathfinder(char *in, int l, int *mlen, int clen) {\\n    int sz = 0, tclen, dl, dlen;\\n    bool isfile;\\n\\n    while (in[sz]) {\\n        /* Find the directory level. */\\n        tclen = clen;\\n        \\n        /* Skip \\\\n */\\n        if (in[sz] && in[sz] == \\'\\\\n\\') ++sz;\\n        \\n        /* Current level. */\\n        dl = finddirlevel(&in[sz]);\\n        if (dl != l) break;\\n        sz += dl;\\n        \\n        /* Find current dir entry length. */        \\n        isfile = false;\\n        dlen = findentrylen(&in[sz], &isfile);        \\n\\n        /* Update the length. \"/\" is not counted for files in root. */        \\n        tclen += dlen + (dl > 0 ? 1 : 0);\\n        /* Track path length only if it\\'s a file. */\\n        if (isfile && tclen > *mlen)\\n            *mlen = tclen;\\n        \\n        /* Recursively explore. */\\n        sz += dlen;\\n        sz += pathfinder(&in[sz], l + 1, mlen, tclen);        \\n    }\\n    return sz;\\n}\\n\\nint lengthLongestPath(char * in){\\n    int mlen = 0;    \\n    pathfinder(&in[0], 0, &mlen, 0);\\n    return mlen;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n/*\\n * Count \\'\\\\t\\' to identify the depth\\n */\\nint finddirlevel(char *d) {\\n    int i = 0;\\n    while (d[i] && d[i] == \\'\\\\t\\')\\n        i += 1;\\n    return i;\\n}\\n\\n/*\\n * Count length of the entry\\n */\\nint findentrylen(char *d, bool *isfile) {\\n    int i = 0;\\n    while (d[i] && d[i] != \\'\\\\n\\') {\\n        if (d[i] == \\'.\\') *isfile = true;\\n        i++;\\n    }\\n    return i;\\n}\\n\\nint pathfinder(char *in, int l, int *mlen, int clen) {\\n    int sz = 0, tclen, dl, dlen;\\n    bool isfile;\\n\\n    while (in[sz]) {\\n        /* Find the directory level. */\\n        tclen = clen;\\n        \\n        /* Skip \\\\n */\\n        if (in[sz] && in[sz] == \\'\\\\n\\') ++sz;\\n        \\n        /* Current level. */\\n        dl = finddirlevel(&in[sz]);\\n        if (dl != l) break;\\n        sz += dl;\\n        \\n        /* Find current dir entry length. */        \\n        isfile = false;\\n        dlen = findentrylen(&in[sz], &isfile);        \\n\\n        /* Update the length. \"/\" is not counted for files in root. */        \\n        tclen += dlen + (dl > 0 ? 1 : 0);\\n        /* Track path length only if it\\'s a file. */\\n        if (isfile && tclen > *mlen)\\n            *mlen = tclen;\\n        \\n        /* Recursively explore. */\\n        sz += dlen;\\n        sz += pathfinder(&in[sz], l + 1, mlen, tclen);        \\n    }\\n    return sz;\\n}\\n\\nint lengthLongestPath(char * in){\\n    int mlen = 0;    \\n    pathfinder(&in[0], 0, &mlen, 0);\\n    return mlen;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 620989,
                "title": "python3-yet-another-solution-using-a-directory",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        if len(input) == 0 or \\'.\\' not in input:\\n            return 0\\n        \\n        words_count = 0\\n        curr_t_count = 0  # count the directory depth\\n        track_dir = defaultdict(int)\\n        max_str = 0\\n        dot = False\\n\\n        i = 0\\n        while (i < len(input)):\\n            if input[i] == \\'.\\':\\n                dot = True\\n\\n            if input[i] == \\'\\\\n\\':\\n                track_dir[curr_t_count] = track_dir[curr_t_count-1] + words_count\\n\\n                if dot == True: # only if the current location has \".\"\\n                    curr_str = track_dir[curr_t_count] + curr_t_count  # sum the number of \"/\"\\n                    max_str = max(max_str, curr_str)\\n\\n                words_count = 0\\n                curr_t_count = 0\\n                dot = False\\n\\n            elif input[i] == \\'\\\\t\\':\\n                while input[i+curr_t_count] == \\'\\\\t\\':\\n                    curr_t_count += 1\\n\\n                i += (curr_t_count - 1)\\n                \\n            else:\\n                words_count += 1\\n            \\n            i+=1\\n\\n        track_dir[curr_t_count] = track_dir[curr_t_count-1] + words_count\\n\\n        if dot == True: # only if the current location has \".\"\\n            curr_str = track_dir[curr_t_count] + curr_t_count  # sum the number of \"/\"\\n            max_str = max(max_str, curr_str)\\n\\n        return max_str",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def lengthLongestPath(self, input: str) -> int:\\n        if len(input) == 0 or \\'.\\' not in input:\\n            return 0\\n        \\n        words_count = 0\\n        curr_t_count = 0  # count the directory depth\\n        track_dir = defaultdict(int)\\n        max_str = 0\\n        dot = False\\n\\n        i = 0\\n        while (i < len(input)):\\n            if input[i] == \\'.\\':\\n                dot = True\\n\\n            if input[i] == \\'\\\\n\\':\\n                track_dir[curr_t_count] = track_dir[curr_t_count-1] + words_count\\n\\n                if dot == True: # only if the current location has \".\"\\n                    curr_str = track_dir[curr_t_count] + curr_t_count  # sum the number of \"/\"\\n                    max_str = max(max_str, curr_str)\\n\\n                words_count = 0\\n                curr_t_count = 0\\n                dot = False\\n\\n            elif input[i] == \\'\\\\t\\':\\n                while input[i+curr_t_count] == \\'\\\\t\\':\\n                    curr_t_count += 1\\n\\n                i += (curr_t_count - 1)\\n                \\n            else:\\n                words_count += 1\\n            \\n            i+=1\\n\\n        track_dir[curr_t_count] = track_dir[curr_t_count-1] + words_count\\n\\n        if dot == True: # only if the current location has \".\"\\n            curr_str = track_dir[curr_t_count] + curr_t_count  # sum the number of \"/\"\\n            max_str = max(max_str, curr_str)\\n\\n        return max_str",
                "codeTag": "Java"
            },
            {
                "id": 594016,
                "title": "javascript-8-lines-using-reduce",
                "content": "- Time Complexity: O(n^2) `n = number of files + folders`\\n- Space Complexity: O(n)\\n```JavaScript\\n/**\\n * @param {string} input\\n * @return {number}\\n */\\nvar lengthLongestPath = (input) => input.split(\\'\\\\n\\').reduce(\\n    ([path, score], cur) => {\\n        const subPath = cur.split(\\'\\\\t\\');\\n        let depth = subPath.length - 1;\\n        path = path.slice(0, depth);\\n        path.push(subPath.pop());\\n        return [path, cur.includes(\\'.\\') ? Math.max(path.join(\\'/\\').length, score) : score];\\n    }, [[], 0]\\n)[1];\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JavaScript\\n/**\\n * @param {string} input\\n * @return {number}\\n */\\nvar lengthLongestPath = (input) => input.split(\\'\\\\n\\').reduce(\\n    ([path, score], cur) => {\\n        const subPath = cur.split(\\'\\\\t\\');\\n        let depth = subPath.length - 1;\\n        path = path.slice(0, depth);\\n        path.push(subPath.pop());\\n        return [path, cur.includes(\\'.\\') ? Math.max(path.join(\\'/\\').length, score) : score];\\n    }, [[], 0]\\n)[1];\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564625,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "After many try-and-error, I finally figured out the solution is required to handle the blank spaces in a special way. I think it should be stated in the problem statement, not just let people guess this from the expected answers. This will waste many people a lot of time...."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "then why the fuck didnt u mentioned here the special way instead of just leaving the  readers on a cliffhanger"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "In all the examples, Tab \"\\\\t\" is used instead of Spaces. Several of OJ test cases have spaces in them and you will have to treat spaces separately. When you see 4 spaces, it will count as a tab.\\n\\nAlso, in the problem and examples, every file is nested directly under a directory. However, not all the test cases have this format: \\n\\nFor example: Test Case #14:  \"dir\\\\n________file.txt\" <-- there are 8 spaces under file.txt and the answer is 16 (not 12).\\n\\nThe problem statement really should be more clear. This isn't a fun problem when you invest a lot of time into solving it, only to realize the problem statement and test cases are entirely different."
                    },
                    {
                        "username": "yummy_bloomy",
                        "content": "It was intuitive to us that \\'\\\\t\\' is the indicator of \\'level\\' for a certain line. For example, in the test case dir\\\\n\\\\tsub1\\\\n\\\\t\\\\tfile1.txt, dir = level 0, sub1 = level2, file1.txt = level3\\n\\nBut we got confused by weird test cases and thought that \\'[][][][]\\' four spaces can also be the level indicator. It\\'s not true. Please repeat with me: \\n**\\'\\\\t\\' is the ONE AND ONLY indicator of \\'level\\' for a certain line**.\\n\\nLet\\'s define lines = input.split(\\'\\\\n\\'). For any lines[i], we need to get the level of it to determine its depth in the file structure, and the length of the line (without \\'\\\\t\\') to determine the length of its absolute path. \\n\\nMethod 1\\n**level of line i = lines[i].count(\\'\\\\t\\')**\\n**real length of line i = len(lines[i]) - level of line i** (while it looks like \\'\\\\t\\' takes 2 or 4 spaces, Python only count it as 1 space)\\n\\nMethod 2\\n**real length of line i = len(lines[i].strip(\\'\\\\t\\'))\\nlevel of line i = len(lines[i]) - real length of line i** \\n\\nI guess many of you are making the same mistake as I did, where I used len(lines[i].strip()), which got rid of both tabs and spaces. That led to wrong results of the following test cases, where **spaces are part of the file names**. As they have no \\'\\\\t\\' before them, they are both of level 0, the same level as dir. Therefore, **the file names themselves are the abosulte paths**. \\n\\nExample 1: \"dir\\\\n[][][][]file.txt\", answer = 12\\nExample 2: \"dir\\\\n[][][][][][][][]file.txt\", answer = 16\\n\\nThink about the structures of those examples like (level -1 is fake but you get the idea):\\n\\nExample 1:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][]file.txt\\n\\nExample 2:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][][][][][]file.txt\\n\\t\\nAlso, don\\'t forget to add the count of slashes to your answer.\\n\\nThanks to [@StefanPochmann](https://leetcode.com/stefanpochmann) for clarification, although it took me a while to understand his statement....\\n\\nReference\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86636/This-problem-is-not-well-defined.-It-should-state-that-4-space-is-considered-as-a-TAB-under-certain-situation./91631\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86619/Simple-Python-solution"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The description of the problem gives solvers a false impression that there is only one top level node, and this node is named \"dir\". It is only after you start testing the code that we run into a testcase like \"dir\\\\nfile.txt\" where both dir and file.txt are at the top-level. Not specifying that something like this is possible in the problem description is not correct, because we have already designed and implemented a solution that does not account for this possiblity. We have to go back to the drawing board and re-design our solution to account for this case."
                    },
                    {
                        "username": "AbhishekBabuji",
                        "content": "Trying to practice BFS but, I bump into these weird test cases that involve tabs and space that have no explanation as to when to include space as a part of the file name and when not to"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "In the thread, you may find complaints on testcases:\\n\\n`dir\\\\n\\\\tfile.txt\\' should have different length from `dir\\\\n...file.txt\\' (here . stays for spaces)\\n(see, for example, https://leetcode.com/problems/longest-absolute-file-path/discuss/86649/What-is-purpose-of-weird-test-cases)\\n\\nBut what about **file system** `text.txt`? I always thought that file system MUST be a folder. Is my opinion wrong?\\n"
                    },
                    {
                        "username": "Gentlemanbug",
                        "content": "Shouldn't \"dir\\\\n        file.txt\" represent \"dir/file.txt\", which has the lenght 12? There are 8 white spaces in the string. It's not displayed properly in the subject."
                    },
                    {
                        "username": "sundarramr",
                        "content": "\"dir\\\\n        file.txt\"\\nexpected output: 16\\n\\nif so how?\\n\\nlook like it has 8 blank space. should we consider it for length?"
                    },
                    {
                        "username": "ahmed",
                        "content": "I know that a stack would solve the problem, but would someone explain the algorithm in plain english and write the code that he explains. I'm very interested to know how to solve that problem."
                    },
                    {
                        "username": "faangboy",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/nightfox21/image_1526685725.png)\\n"
                    }
                ]
            },
            {
                "id": 1569169,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "After many try-and-error, I finally figured out the solution is required to handle the blank spaces in a special way. I think it should be stated in the problem statement, not just let people guess this from the expected answers. This will waste many people a lot of time...."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "then why the fuck didnt u mentioned here the special way instead of just leaving the  readers on a cliffhanger"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "In all the examples, Tab \"\\\\t\" is used instead of Spaces. Several of OJ test cases have spaces in them and you will have to treat spaces separately. When you see 4 spaces, it will count as a tab.\\n\\nAlso, in the problem and examples, every file is nested directly under a directory. However, not all the test cases have this format: \\n\\nFor example: Test Case #14:  \"dir\\\\n________file.txt\" <-- there are 8 spaces under file.txt and the answer is 16 (not 12).\\n\\nThe problem statement really should be more clear. This isn't a fun problem when you invest a lot of time into solving it, only to realize the problem statement and test cases are entirely different."
                    },
                    {
                        "username": "yummy_bloomy",
                        "content": "It was intuitive to us that \\'\\\\t\\' is the indicator of \\'level\\' for a certain line. For example, in the test case dir\\\\n\\\\tsub1\\\\n\\\\t\\\\tfile1.txt, dir = level 0, sub1 = level2, file1.txt = level3\\n\\nBut we got confused by weird test cases and thought that \\'[][][][]\\' four spaces can also be the level indicator. It\\'s not true. Please repeat with me: \\n**\\'\\\\t\\' is the ONE AND ONLY indicator of \\'level\\' for a certain line**.\\n\\nLet\\'s define lines = input.split(\\'\\\\n\\'). For any lines[i], we need to get the level of it to determine its depth in the file structure, and the length of the line (without \\'\\\\t\\') to determine the length of its absolute path. \\n\\nMethod 1\\n**level of line i = lines[i].count(\\'\\\\t\\')**\\n**real length of line i = len(lines[i]) - level of line i** (while it looks like \\'\\\\t\\' takes 2 or 4 spaces, Python only count it as 1 space)\\n\\nMethod 2\\n**real length of line i = len(lines[i].strip(\\'\\\\t\\'))\\nlevel of line i = len(lines[i]) - real length of line i** \\n\\nI guess many of you are making the same mistake as I did, where I used len(lines[i].strip()), which got rid of both tabs and spaces. That led to wrong results of the following test cases, where **spaces are part of the file names**. As they have no \\'\\\\t\\' before them, they are both of level 0, the same level as dir. Therefore, **the file names themselves are the abosulte paths**. \\n\\nExample 1: \"dir\\\\n[][][][]file.txt\", answer = 12\\nExample 2: \"dir\\\\n[][][][][][][][]file.txt\", answer = 16\\n\\nThink about the structures of those examples like (level -1 is fake but you get the idea):\\n\\nExample 1:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][]file.txt\\n\\nExample 2:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][][][][][]file.txt\\n\\t\\nAlso, don\\'t forget to add the count of slashes to your answer.\\n\\nThanks to [@StefanPochmann](https://leetcode.com/stefanpochmann) for clarification, although it took me a while to understand his statement....\\n\\nReference\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86636/This-problem-is-not-well-defined.-It-should-state-that-4-space-is-considered-as-a-TAB-under-certain-situation./91631\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86619/Simple-Python-solution"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The description of the problem gives solvers a false impression that there is only one top level node, and this node is named \"dir\". It is only after you start testing the code that we run into a testcase like \"dir\\\\nfile.txt\" where both dir and file.txt are at the top-level. Not specifying that something like this is possible in the problem description is not correct, because we have already designed and implemented a solution that does not account for this possiblity. We have to go back to the drawing board and re-design our solution to account for this case."
                    },
                    {
                        "username": "AbhishekBabuji",
                        "content": "Trying to practice BFS but, I bump into these weird test cases that involve tabs and space that have no explanation as to when to include space as a part of the file name and when not to"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "In the thread, you may find complaints on testcases:\\n\\n`dir\\\\n\\\\tfile.txt\\' should have different length from `dir\\\\n...file.txt\\' (here . stays for spaces)\\n(see, for example, https://leetcode.com/problems/longest-absolute-file-path/discuss/86649/What-is-purpose-of-weird-test-cases)\\n\\nBut what about **file system** `text.txt`? I always thought that file system MUST be a folder. Is my opinion wrong?\\n"
                    },
                    {
                        "username": "Gentlemanbug",
                        "content": "Shouldn't \"dir\\\\n        file.txt\" represent \"dir/file.txt\", which has the lenght 12? There are 8 white spaces in the string. It's not displayed properly in the subject."
                    },
                    {
                        "username": "sundarramr",
                        "content": "\"dir\\\\n        file.txt\"\\nexpected output: 16\\n\\nif so how?\\n\\nlook like it has 8 blank space. should we consider it for length?"
                    },
                    {
                        "username": "ahmed",
                        "content": "I know that a stack would solve the problem, but would someone explain the algorithm in plain english and write the code that he explains. I'm very interested to know how to solve that problem."
                    },
                    {
                        "username": "faangboy",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/nightfox21/image_1526685725.png)\\n"
                    }
                ]
            },
            {
                "id": 1565994,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "After many try-and-error, I finally figured out the solution is required to handle the blank spaces in a special way. I think it should be stated in the problem statement, not just let people guess this from the expected answers. This will waste many people a lot of time...."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "then why the fuck didnt u mentioned here the special way instead of just leaving the  readers on a cliffhanger"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "In all the examples, Tab \"\\\\t\" is used instead of Spaces. Several of OJ test cases have spaces in them and you will have to treat spaces separately. When you see 4 spaces, it will count as a tab.\\n\\nAlso, in the problem and examples, every file is nested directly under a directory. However, not all the test cases have this format: \\n\\nFor example: Test Case #14:  \"dir\\\\n________file.txt\" <-- there are 8 spaces under file.txt and the answer is 16 (not 12).\\n\\nThe problem statement really should be more clear. This isn't a fun problem when you invest a lot of time into solving it, only to realize the problem statement and test cases are entirely different."
                    },
                    {
                        "username": "yummy_bloomy",
                        "content": "It was intuitive to us that \\'\\\\t\\' is the indicator of \\'level\\' for a certain line. For example, in the test case dir\\\\n\\\\tsub1\\\\n\\\\t\\\\tfile1.txt, dir = level 0, sub1 = level2, file1.txt = level3\\n\\nBut we got confused by weird test cases and thought that \\'[][][][]\\' four spaces can also be the level indicator. It\\'s not true. Please repeat with me: \\n**\\'\\\\t\\' is the ONE AND ONLY indicator of \\'level\\' for a certain line**.\\n\\nLet\\'s define lines = input.split(\\'\\\\n\\'). For any lines[i], we need to get the level of it to determine its depth in the file structure, and the length of the line (without \\'\\\\t\\') to determine the length of its absolute path. \\n\\nMethod 1\\n**level of line i = lines[i].count(\\'\\\\t\\')**\\n**real length of line i = len(lines[i]) - level of line i** (while it looks like \\'\\\\t\\' takes 2 or 4 spaces, Python only count it as 1 space)\\n\\nMethod 2\\n**real length of line i = len(lines[i].strip(\\'\\\\t\\'))\\nlevel of line i = len(lines[i]) - real length of line i** \\n\\nI guess many of you are making the same mistake as I did, where I used len(lines[i].strip()), which got rid of both tabs and spaces. That led to wrong results of the following test cases, where **spaces are part of the file names**. As they have no \\'\\\\t\\' before them, they are both of level 0, the same level as dir. Therefore, **the file names themselves are the abosulte paths**. \\n\\nExample 1: \"dir\\\\n[][][][]file.txt\", answer = 12\\nExample 2: \"dir\\\\n[][][][][][][][]file.txt\", answer = 16\\n\\nThink about the structures of those examples like (level -1 is fake but you get the idea):\\n\\nExample 1:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][]file.txt\\n\\nExample 2:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][][][][][]file.txt\\n\\t\\nAlso, don\\'t forget to add the count of slashes to your answer.\\n\\nThanks to [@StefanPochmann](https://leetcode.com/stefanpochmann) for clarification, although it took me a while to understand his statement....\\n\\nReference\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86636/This-problem-is-not-well-defined.-It-should-state-that-4-space-is-considered-as-a-TAB-under-certain-situation./91631\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86619/Simple-Python-solution"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The description of the problem gives solvers a false impression that there is only one top level node, and this node is named \"dir\". It is only after you start testing the code that we run into a testcase like \"dir\\\\nfile.txt\" where both dir and file.txt are at the top-level. Not specifying that something like this is possible in the problem description is not correct, because we have already designed and implemented a solution that does not account for this possiblity. We have to go back to the drawing board and re-design our solution to account for this case."
                    },
                    {
                        "username": "AbhishekBabuji",
                        "content": "Trying to practice BFS but, I bump into these weird test cases that involve tabs and space that have no explanation as to when to include space as a part of the file name and when not to"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "In the thread, you may find complaints on testcases:\\n\\n`dir\\\\n\\\\tfile.txt\\' should have different length from `dir\\\\n...file.txt\\' (here . stays for spaces)\\n(see, for example, https://leetcode.com/problems/longest-absolute-file-path/discuss/86649/What-is-purpose-of-weird-test-cases)\\n\\nBut what about **file system** `text.txt`? I always thought that file system MUST be a folder. Is my opinion wrong?\\n"
                    },
                    {
                        "username": "Gentlemanbug",
                        "content": "Shouldn't \"dir\\\\n        file.txt\" represent \"dir/file.txt\", which has the lenght 12? There are 8 white spaces in the string. It's not displayed properly in the subject."
                    },
                    {
                        "username": "sundarramr",
                        "content": "\"dir\\\\n        file.txt\"\\nexpected output: 16\\n\\nif so how?\\n\\nlook like it has 8 blank space. should we consider it for length?"
                    },
                    {
                        "username": "ahmed",
                        "content": "I know that a stack would solve the problem, but would someone explain the algorithm in plain english and write the code that he explains. I'm very interested to know how to solve that problem."
                    },
                    {
                        "username": "faangboy",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/nightfox21/image_1526685725.png)\\n"
                    }
                ]
            },
            {
                "id": 1569789,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "After many try-and-error, I finally figured out the solution is required to handle the blank spaces in a special way. I think it should be stated in the problem statement, not just let people guess this from the expected answers. This will waste many people a lot of time...."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "then why the fuck didnt u mentioned here the special way instead of just leaving the  readers on a cliffhanger"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "In all the examples, Tab \"\\\\t\" is used instead of Spaces. Several of OJ test cases have spaces in them and you will have to treat spaces separately. When you see 4 spaces, it will count as a tab.\\n\\nAlso, in the problem and examples, every file is nested directly under a directory. However, not all the test cases have this format: \\n\\nFor example: Test Case #14:  \"dir\\\\n________file.txt\" <-- there are 8 spaces under file.txt and the answer is 16 (not 12).\\n\\nThe problem statement really should be more clear. This isn't a fun problem when you invest a lot of time into solving it, only to realize the problem statement and test cases are entirely different."
                    },
                    {
                        "username": "yummy_bloomy",
                        "content": "It was intuitive to us that \\'\\\\t\\' is the indicator of \\'level\\' for a certain line. For example, in the test case dir\\\\n\\\\tsub1\\\\n\\\\t\\\\tfile1.txt, dir = level 0, sub1 = level2, file1.txt = level3\\n\\nBut we got confused by weird test cases and thought that \\'[][][][]\\' four spaces can also be the level indicator. It\\'s not true. Please repeat with me: \\n**\\'\\\\t\\' is the ONE AND ONLY indicator of \\'level\\' for a certain line**.\\n\\nLet\\'s define lines = input.split(\\'\\\\n\\'). For any lines[i], we need to get the level of it to determine its depth in the file structure, and the length of the line (without \\'\\\\t\\') to determine the length of its absolute path. \\n\\nMethod 1\\n**level of line i = lines[i].count(\\'\\\\t\\')**\\n**real length of line i = len(lines[i]) - level of line i** (while it looks like \\'\\\\t\\' takes 2 or 4 spaces, Python only count it as 1 space)\\n\\nMethod 2\\n**real length of line i = len(lines[i].strip(\\'\\\\t\\'))\\nlevel of line i = len(lines[i]) - real length of line i** \\n\\nI guess many of you are making the same mistake as I did, where I used len(lines[i].strip()), which got rid of both tabs and spaces. That led to wrong results of the following test cases, where **spaces are part of the file names**. As they have no \\'\\\\t\\' before them, they are both of level 0, the same level as dir. Therefore, **the file names themselves are the abosulte paths**. \\n\\nExample 1: \"dir\\\\n[][][][]file.txt\", answer = 12\\nExample 2: \"dir\\\\n[][][][][][][][]file.txt\", answer = 16\\n\\nThink about the structures of those examples like (level -1 is fake but you get the idea):\\n\\nExample 1:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][]file.txt\\n\\nExample 2:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][][][][][]file.txt\\n\\t\\nAlso, don\\'t forget to add the count of slashes to your answer.\\n\\nThanks to [@StefanPochmann](https://leetcode.com/stefanpochmann) for clarification, although it took me a while to understand his statement....\\n\\nReference\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86636/This-problem-is-not-well-defined.-It-should-state-that-4-space-is-considered-as-a-TAB-under-certain-situation./91631\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86619/Simple-Python-solution"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The description of the problem gives solvers a false impression that there is only one top level node, and this node is named \"dir\". It is only after you start testing the code that we run into a testcase like \"dir\\\\nfile.txt\" where both dir and file.txt are at the top-level. Not specifying that something like this is possible in the problem description is not correct, because we have already designed and implemented a solution that does not account for this possiblity. We have to go back to the drawing board and re-design our solution to account for this case."
                    },
                    {
                        "username": "AbhishekBabuji",
                        "content": "Trying to practice BFS but, I bump into these weird test cases that involve tabs and space that have no explanation as to when to include space as a part of the file name and when not to"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "In the thread, you may find complaints on testcases:\\n\\n`dir\\\\n\\\\tfile.txt\\' should have different length from `dir\\\\n...file.txt\\' (here . stays for spaces)\\n(see, for example, https://leetcode.com/problems/longest-absolute-file-path/discuss/86649/What-is-purpose-of-weird-test-cases)\\n\\nBut what about **file system** `text.txt`? I always thought that file system MUST be a folder. Is my opinion wrong?\\n"
                    },
                    {
                        "username": "Gentlemanbug",
                        "content": "Shouldn't \"dir\\\\n        file.txt\" represent \"dir/file.txt\", which has the lenght 12? There are 8 white spaces in the string. It's not displayed properly in the subject."
                    },
                    {
                        "username": "sundarramr",
                        "content": "\"dir\\\\n        file.txt\"\\nexpected output: 16\\n\\nif so how?\\n\\nlook like it has 8 blank space. should we consider it for length?"
                    },
                    {
                        "username": "ahmed",
                        "content": "I know that a stack would solve the problem, but would someone explain the algorithm in plain english and write the code that he explains. I'm very interested to know how to solve that problem."
                    },
                    {
                        "username": "faangboy",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/nightfox21/image_1526685725.png)\\n"
                    }
                ]
            },
            {
                "id": 1567374,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "After many try-and-error, I finally figured out the solution is required to handle the blank spaces in a special way. I think it should be stated in the problem statement, not just let people guess this from the expected answers. This will waste many people a lot of time...."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "then why the fuck didnt u mentioned here the special way instead of just leaving the  readers on a cliffhanger"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "In all the examples, Tab \"\\\\t\" is used instead of Spaces. Several of OJ test cases have spaces in them and you will have to treat spaces separately. When you see 4 spaces, it will count as a tab.\\n\\nAlso, in the problem and examples, every file is nested directly under a directory. However, not all the test cases have this format: \\n\\nFor example: Test Case #14:  \"dir\\\\n________file.txt\" <-- there are 8 spaces under file.txt and the answer is 16 (not 12).\\n\\nThe problem statement really should be more clear. This isn't a fun problem when you invest a lot of time into solving it, only to realize the problem statement and test cases are entirely different."
                    },
                    {
                        "username": "yummy_bloomy",
                        "content": "It was intuitive to us that \\'\\\\t\\' is the indicator of \\'level\\' for a certain line. For example, in the test case dir\\\\n\\\\tsub1\\\\n\\\\t\\\\tfile1.txt, dir = level 0, sub1 = level2, file1.txt = level3\\n\\nBut we got confused by weird test cases and thought that \\'[][][][]\\' four spaces can also be the level indicator. It\\'s not true. Please repeat with me: \\n**\\'\\\\t\\' is the ONE AND ONLY indicator of \\'level\\' for a certain line**.\\n\\nLet\\'s define lines = input.split(\\'\\\\n\\'). For any lines[i], we need to get the level of it to determine its depth in the file structure, and the length of the line (without \\'\\\\t\\') to determine the length of its absolute path. \\n\\nMethod 1\\n**level of line i = lines[i].count(\\'\\\\t\\')**\\n**real length of line i = len(lines[i]) - level of line i** (while it looks like \\'\\\\t\\' takes 2 or 4 spaces, Python only count it as 1 space)\\n\\nMethod 2\\n**real length of line i = len(lines[i].strip(\\'\\\\t\\'))\\nlevel of line i = len(lines[i]) - real length of line i** \\n\\nI guess many of you are making the same mistake as I did, where I used len(lines[i].strip()), which got rid of both tabs and spaces. That led to wrong results of the following test cases, where **spaces are part of the file names**. As they have no \\'\\\\t\\' before them, they are both of level 0, the same level as dir. Therefore, **the file names themselves are the abosulte paths**. \\n\\nExample 1: \"dir\\\\n[][][][]file.txt\", answer = 12\\nExample 2: \"dir\\\\n[][][][][][][][]file.txt\", answer = 16\\n\\nThink about the structures of those examples like (level -1 is fake but you get the idea):\\n\\nExample 1:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][]file.txt\\n\\nExample 2:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][][][][][]file.txt\\n\\t\\nAlso, don\\'t forget to add the count of slashes to your answer.\\n\\nThanks to [@StefanPochmann](https://leetcode.com/stefanpochmann) for clarification, although it took me a while to understand his statement....\\n\\nReference\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86636/This-problem-is-not-well-defined.-It-should-state-that-4-space-is-considered-as-a-TAB-under-certain-situation./91631\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86619/Simple-Python-solution"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The description of the problem gives solvers a false impression that there is only one top level node, and this node is named \"dir\". It is only after you start testing the code that we run into a testcase like \"dir\\\\nfile.txt\" where both dir and file.txt are at the top-level. Not specifying that something like this is possible in the problem description is not correct, because we have already designed and implemented a solution that does not account for this possiblity. We have to go back to the drawing board and re-design our solution to account for this case."
                    },
                    {
                        "username": "AbhishekBabuji",
                        "content": "Trying to practice BFS but, I bump into these weird test cases that involve tabs and space that have no explanation as to when to include space as a part of the file name and when not to"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "In the thread, you may find complaints on testcases:\\n\\n`dir\\\\n\\\\tfile.txt\\' should have different length from `dir\\\\n...file.txt\\' (here . stays for spaces)\\n(see, for example, https://leetcode.com/problems/longest-absolute-file-path/discuss/86649/What-is-purpose-of-weird-test-cases)\\n\\nBut what about **file system** `text.txt`? I always thought that file system MUST be a folder. Is my opinion wrong?\\n"
                    },
                    {
                        "username": "Gentlemanbug",
                        "content": "Shouldn't \"dir\\\\n        file.txt\" represent \"dir/file.txt\", which has the lenght 12? There are 8 white spaces in the string. It's not displayed properly in the subject."
                    },
                    {
                        "username": "sundarramr",
                        "content": "\"dir\\\\n        file.txt\"\\nexpected output: 16\\n\\nif so how?\\n\\nlook like it has 8 blank space. should we consider it for length?"
                    },
                    {
                        "username": "ahmed",
                        "content": "I know that a stack would solve the problem, but would someone explain the algorithm in plain english and write the code that he explains. I'm very interested to know how to solve that problem."
                    },
                    {
                        "username": "faangboy",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/nightfox21/image_1526685725.png)\\n"
                    }
                ]
            },
            {
                "id": 1569741,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "After many try-and-error, I finally figured out the solution is required to handle the blank spaces in a special way. I think it should be stated in the problem statement, not just let people guess this from the expected answers. This will waste many people a lot of time...."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "then why the fuck didnt u mentioned here the special way instead of just leaving the  readers on a cliffhanger"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "In all the examples, Tab \"\\\\t\" is used instead of Spaces. Several of OJ test cases have spaces in them and you will have to treat spaces separately. When you see 4 spaces, it will count as a tab.\\n\\nAlso, in the problem and examples, every file is nested directly under a directory. However, not all the test cases have this format: \\n\\nFor example: Test Case #14:  \"dir\\\\n________file.txt\" <-- there are 8 spaces under file.txt and the answer is 16 (not 12).\\n\\nThe problem statement really should be more clear. This isn't a fun problem when you invest a lot of time into solving it, only to realize the problem statement and test cases are entirely different."
                    },
                    {
                        "username": "yummy_bloomy",
                        "content": "It was intuitive to us that \\'\\\\t\\' is the indicator of \\'level\\' for a certain line. For example, in the test case dir\\\\n\\\\tsub1\\\\n\\\\t\\\\tfile1.txt, dir = level 0, sub1 = level2, file1.txt = level3\\n\\nBut we got confused by weird test cases and thought that \\'[][][][]\\' four spaces can also be the level indicator. It\\'s not true. Please repeat with me: \\n**\\'\\\\t\\' is the ONE AND ONLY indicator of \\'level\\' for a certain line**.\\n\\nLet\\'s define lines = input.split(\\'\\\\n\\'). For any lines[i], we need to get the level of it to determine its depth in the file structure, and the length of the line (without \\'\\\\t\\') to determine the length of its absolute path. \\n\\nMethod 1\\n**level of line i = lines[i].count(\\'\\\\t\\')**\\n**real length of line i = len(lines[i]) - level of line i** (while it looks like \\'\\\\t\\' takes 2 or 4 spaces, Python only count it as 1 space)\\n\\nMethod 2\\n**real length of line i = len(lines[i].strip(\\'\\\\t\\'))\\nlevel of line i = len(lines[i]) - real length of line i** \\n\\nI guess many of you are making the same mistake as I did, where I used len(lines[i].strip()), which got rid of both tabs and spaces. That led to wrong results of the following test cases, where **spaces are part of the file names**. As they have no \\'\\\\t\\' before them, they are both of level 0, the same level as dir. Therefore, **the file names themselves are the abosulte paths**. \\n\\nExample 1: \"dir\\\\n[][][][]file.txt\", answer = 12\\nExample 2: \"dir\\\\n[][][][][][][][]file.txt\", answer = 16\\n\\nThink about the structures of those examples like (level -1 is fake but you get the idea):\\n\\nExample 1:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][]file.txt\\n\\nExample 2:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][][][][][]file.txt\\n\\t\\nAlso, don\\'t forget to add the count of slashes to your answer.\\n\\nThanks to [@StefanPochmann](https://leetcode.com/stefanpochmann) for clarification, although it took me a while to understand his statement....\\n\\nReference\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86636/This-problem-is-not-well-defined.-It-should-state-that-4-space-is-considered-as-a-TAB-under-certain-situation./91631\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86619/Simple-Python-solution"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The description of the problem gives solvers a false impression that there is only one top level node, and this node is named \"dir\". It is only after you start testing the code that we run into a testcase like \"dir\\\\nfile.txt\" where both dir and file.txt are at the top-level. Not specifying that something like this is possible in the problem description is not correct, because we have already designed and implemented a solution that does not account for this possiblity. We have to go back to the drawing board and re-design our solution to account for this case."
                    },
                    {
                        "username": "AbhishekBabuji",
                        "content": "Trying to practice BFS but, I bump into these weird test cases that involve tabs and space that have no explanation as to when to include space as a part of the file name and when not to"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "In the thread, you may find complaints on testcases:\\n\\n`dir\\\\n\\\\tfile.txt\\' should have different length from `dir\\\\n...file.txt\\' (here . stays for spaces)\\n(see, for example, https://leetcode.com/problems/longest-absolute-file-path/discuss/86649/What-is-purpose-of-weird-test-cases)\\n\\nBut what about **file system** `text.txt`? I always thought that file system MUST be a folder. Is my opinion wrong?\\n"
                    },
                    {
                        "username": "Gentlemanbug",
                        "content": "Shouldn't \"dir\\\\n        file.txt\" represent \"dir/file.txt\", which has the lenght 12? There are 8 white spaces in the string. It's not displayed properly in the subject."
                    },
                    {
                        "username": "sundarramr",
                        "content": "\"dir\\\\n        file.txt\"\\nexpected output: 16\\n\\nif so how?\\n\\nlook like it has 8 blank space. should we consider it for length?"
                    },
                    {
                        "username": "ahmed",
                        "content": "I know that a stack would solve the problem, but would someone explain the algorithm in plain english and write the code that he explains. I'm very interested to know how to solve that problem."
                    },
                    {
                        "username": "faangboy",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/nightfox21/image_1526685725.png)\\n"
                    }
                ]
            },
            {
                "id": 1569108,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "After many try-and-error, I finally figured out the solution is required to handle the blank spaces in a special way. I think it should be stated in the problem statement, not just let people guess this from the expected answers. This will waste many people a lot of time...."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "then why the fuck didnt u mentioned here the special way instead of just leaving the  readers on a cliffhanger"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "In all the examples, Tab \"\\\\t\" is used instead of Spaces. Several of OJ test cases have spaces in them and you will have to treat spaces separately. When you see 4 spaces, it will count as a tab.\\n\\nAlso, in the problem and examples, every file is nested directly under a directory. However, not all the test cases have this format: \\n\\nFor example: Test Case #14:  \"dir\\\\n________file.txt\" <-- there are 8 spaces under file.txt and the answer is 16 (not 12).\\n\\nThe problem statement really should be more clear. This isn't a fun problem when you invest a lot of time into solving it, only to realize the problem statement and test cases are entirely different."
                    },
                    {
                        "username": "yummy_bloomy",
                        "content": "It was intuitive to us that \\'\\\\t\\' is the indicator of \\'level\\' for a certain line. For example, in the test case dir\\\\n\\\\tsub1\\\\n\\\\t\\\\tfile1.txt, dir = level 0, sub1 = level2, file1.txt = level3\\n\\nBut we got confused by weird test cases and thought that \\'[][][][]\\' four spaces can also be the level indicator. It\\'s not true. Please repeat with me: \\n**\\'\\\\t\\' is the ONE AND ONLY indicator of \\'level\\' for a certain line**.\\n\\nLet\\'s define lines = input.split(\\'\\\\n\\'). For any lines[i], we need to get the level of it to determine its depth in the file structure, and the length of the line (without \\'\\\\t\\') to determine the length of its absolute path. \\n\\nMethod 1\\n**level of line i = lines[i].count(\\'\\\\t\\')**\\n**real length of line i = len(lines[i]) - level of line i** (while it looks like \\'\\\\t\\' takes 2 or 4 spaces, Python only count it as 1 space)\\n\\nMethod 2\\n**real length of line i = len(lines[i].strip(\\'\\\\t\\'))\\nlevel of line i = len(lines[i]) - real length of line i** \\n\\nI guess many of you are making the same mistake as I did, where I used len(lines[i].strip()), which got rid of both tabs and spaces. That led to wrong results of the following test cases, where **spaces are part of the file names**. As they have no \\'\\\\t\\' before them, they are both of level 0, the same level as dir. Therefore, **the file names themselves are the abosulte paths**. \\n\\nExample 1: \"dir\\\\n[][][][]file.txt\", answer = 12\\nExample 2: \"dir\\\\n[][][][][][][][]file.txt\", answer = 16\\n\\nThink about the structures of those examples like (level -1 is fake but you get the idea):\\n\\nExample 1:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][]file.txt\\n\\nExample 2:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][][][][][]file.txt\\n\\t\\nAlso, don\\'t forget to add the count of slashes to your answer.\\n\\nThanks to [@StefanPochmann](https://leetcode.com/stefanpochmann) for clarification, although it took me a while to understand his statement....\\n\\nReference\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86636/This-problem-is-not-well-defined.-It-should-state-that-4-space-is-considered-as-a-TAB-under-certain-situation./91631\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86619/Simple-Python-solution"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The description of the problem gives solvers a false impression that there is only one top level node, and this node is named \"dir\". It is only after you start testing the code that we run into a testcase like \"dir\\\\nfile.txt\" where both dir and file.txt are at the top-level. Not specifying that something like this is possible in the problem description is not correct, because we have already designed and implemented a solution that does not account for this possiblity. We have to go back to the drawing board and re-design our solution to account for this case."
                    },
                    {
                        "username": "AbhishekBabuji",
                        "content": "Trying to practice BFS but, I bump into these weird test cases that involve tabs and space that have no explanation as to when to include space as a part of the file name and when not to"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "In the thread, you may find complaints on testcases:\\n\\n`dir\\\\n\\\\tfile.txt\\' should have different length from `dir\\\\n...file.txt\\' (here . stays for spaces)\\n(see, for example, https://leetcode.com/problems/longest-absolute-file-path/discuss/86649/What-is-purpose-of-weird-test-cases)\\n\\nBut what about **file system** `text.txt`? I always thought that file system MUST be a folder. Is my opinion wrong?\\n"
                    },
                    {
                        "username": "Gentlemanbug",
                        "content": "Shouldn't \"dir\\\\n        file.txt\" represent \"dir/file.txt\", which has the lenght 12? There are 8 white spaces in the string. It's not displayed properly in the subject."
                    },
                    {
                        "username": "sundarramr",
                        "content": "\"dir\\\\n        file.txt\"\\nexpected output: 16\\n\\nif so how?\\n\\nlook like it has 8 blank space. should we consider it for length?"
                    },
                    {
                        "username": "ahmed",
                        "content": "I know that a stack would solve the problem, but would someone explain the algorithm in plain english and write the code that he explains. I'm very interested to know how to solve that problem."
                    },
                    {
                        "username": "faangboy",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/nightfox21/image_1526685725.png)\\n"
                    }
                ]
            },
            {
                "id": 1574163,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "After many try-and-error, I finally figured out the solution is required to handle the blank spaces in a special way. I think it should be stated in the problem statement, not just let people guess this from the expected answers. This will waste many people a lot of time...."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "then why the fuck didnt u mentioned here the special way instead of just leaving the  readers on a cliffhanger"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "In all the examples, Tab \"\\\\t\" is used instead of Spaces. Several of OJ test cases have spaces in them and you will have to treat spaces separately. When you see 4 spaces, it will count as a tab.\\n\\nAlso, in the problem and examples, every file is nested directly under a directory. However, not all the test cases have this format: \\n\\nFor example: Test Case #14:  \"dir\\\\n________file.txt\" <-- there are 8 spaces under file.txt and the answer is 16 (not 12).\\n\\nThe problem statement really should be more clear. This isn't a fun problem when you invest a lot of time into solving it, only to realize the problem statement and test cases are entirely different."
                    },
                    {
                        "username": "yummy_bloomy",
                        "content": "It was intuitive to us that \\'\\\\t\\' is the indicator of \\'level\\' for a certain line. For example, in the test case dir\\\\n\\\\tsub1\\\\n\\\\t\\\\tfile1.txt, dir = level 0, sub1 = level2, file1.txt = level3\\n\\nBut we got confused by weird test cases and thought that \\'[][][][]\\' four spaces can also be the level indicator. It\\'s not true. Please repeat with me: \\n**\\'\\\\t\\' is the ONE AND ONLY indicator of \\'level\\' for a certain line**.\\n\\nLet\\'s define lines = input.split(\\'\\\\n\\'). For any lines[i], we need to get the level of it to determine its depth in the file structure, and the length of the line (without \\'\\\\t\\') to determine the length of its absolute path. \\n\\nMethod 1\\n**level of line i = lines[i].count(\\'\\\\t\\')**\\n**real length of line i = len(lines[i]) - level of line i** (while it looks like \\'\\\\t\\' takes 2 or 4 spaces, Python only count it as 1 space)\\n\\nMethod 2\\n**real length of line i = len(lines[i].strip(\\'\\\\t\\'))\\nlevel of line i = len(lines[i]) - real length of line i** \\n\\nI guess many of you are making the same mistake as I did, where I used len(lines[i].strip()), which got rid of both tabs and spaces. That led to wrong results of the following test cases, where **spaces are part of the file names**. As they have no \\'\\\\t\\' before them, they are both of level 0, the same level as dir. Therefore, **the file names themselves are the abosulte paths**. \\n\\nExample 1: \"dir\\\\n[][][][]file.txt\", answer = 12\\nExample 2: \"dir\\\\n[][][][][][][][]file.txt\", answer = 16\\n\\nThink about the structures of those examples like (level -1 is fake but you get the idea):\\n\\nExample 1:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][]file.txt\\n\\nExample 2:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][][][][][]file.txt\\n\\t\\nAlso, don\\'t forget to add the count of slashes to your answer.\\n\\nThanks to [@StefanPochmann](https://leetcode.com/stefanpochmann) for clarification, although it took me a while to understand his statement....\\n\\nReference\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86636/This-problem-is-not-well-defined.-It-should-state-that-4-space-is-considered-as-a-TAB-under-certain-situation./91631\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86619/Simple-Python-solution"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The description of the problem gives solvers a false impression that there is only one top level node, and this node is named \"dir\". It is only after you start testing the code that we run into a testcase like \"dir\\\\nfile.txt\" where both dir and file.txt are at the top-level. Not specifying that something like this is possible in the problem description is not correct, because we have already designed and implemented a solution that does not account for this possiblity. We have to go back to the drawing board and re-design our solution to account for this case."
                    },
                    {
                        "username": "AbhishekBabuji",
                        "content": "Trying to practice BFS but, I bump into these weird test cases that involve tabs and space that have no explanation as to when to include space as a part of the file name and when not to"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "In the thread, you may find complaints on testcases:\\n\\n`dir\\\\n\\\\tfile.txt\\' should have different length from `dir\\\\n...file.txt\\' (here . stays for spaces)\\n(see, for example, https://leetcode.com/problems/longest-absolute-file-path/discuss/86649/What-is-purpose-of-weird-test-cases)\\n\\nBut what about **file system** `text.txt`? I always thought that file system MUST be a folder. Is my opinion wrong?\\n"
                    },
                    {
                        "username": "Gentlemanbug",
                        "content": "Shouldn't \"dir\\\\n        file.txt\" represent \"dir/file.txt\", which has the lenght 12? There are 8 white spaces in the string. It's not displayed properly in the subject."
                    },
                    {
                        "username": "sundarramr",
                        "content": "\"dir\\\\n        file.txt\"\\nexpected output: 16\\n\\nif so how?\\n\\nlook like it has 8 blank space. should we consider it for length?"
                    },
                    {
                        "username": "ahmed",
                        "content": "I know that a stack would solve the problem, but would someone explain the algorithm in plain english and write the code that he explains. I'm very interested to know how to solve that problem."
                    },
                    {
                        "username": "faangboy",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/nightfox21/image_1526685725.png)\\n"
                    }
                ]
            },
            {
                "id": 1571662,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "After many try-and-error, I finally figured out the solution is required to handle the blank spaces in a special way. I think it should be stated in the problem statement, not just let people guess this from the expected answers. This will waste many people a lot of time...."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "then why the fuck didnt u mentioned here the special way instead of just leaving the  readers on a cliffhanger"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "In all the examples, Tab \"\\\\t\" is used instead of Spaces. Several of OJ test cases have spaces in them and you will have to treat spaces separately. When you see 4 spaces, it will count as a tab.\\n\\nAlso, in the problem and examples, every file is nested directly under a directory. However, not all the test cases have this format: \\n\\nFor example: Test Case #14:  \"dir\\\\n________file.txt\" <-- there are 8 spaces under file.txt and the answer is 16 (not 12).\\n\\nThe problem statement really should be more clear. This isn't a fun problem when you invest a lot of time into solving it, only to realize the problem statement and test cases are entirely different."
                    },
                    {
                        "username": "yummy_bloomy",
                        "content": "It was intuitive to us that \\'\\\\t\\' is the indicator of \\'level\\' for a certain line. For example, in the test case dir\\\\n\\\\tsub1\\\\n\\\\t\\\\tfile1.txt, dir = level 0, sub1 = level2, file1.txt = level3\\n\\nBut we got confused by weird test cases and thought that \\'[][][][]\\' four spaces can also be the level indicator. It\\'s not true. Please repeat with me: \\n**\\'\\\\t\\' is the ONE AND ONLY indicator of \\'level\\' for a certain line**.\\n\\nLet\\'s define lines = input.split(\\'\\\\n\\'). For any lines[i], we need to get the level of it to determine its depth in the file structure, and the length of the line (without \\'\\\\t\\') to determine the length of its absolute path. \\n\\nMethod 1\\n**level of line i = lines[i].count(\\'\\\\t\\')**\\n**real length of line i = len(lines[i]) - level of line i** (while it looks like \\'\\\\t\\' takes 2 or 4 spaces, Python only count it as 1 space)\\n\\nMethod 2\\n**real length of line i = len(lines[i].strip(\\'\\\\t\\'))\\nlevel of line i = len(lines[i]) - real length of line i** \\n\\nI guess many of you are making the same mistake as I did, where I used len(lines[i].strip()), which got rid of both tabs and spaces. That led to wrong results of the following test cases, where **spaces are part of the file names**. As they have no \\'\\\\t\\' before them, they are both of level 0, the same level as dir. Therefore, **the file names themselves are the abosulte paths**. \\n\\nExample 1: \"dir\\\\n[][][][]file.txt\", answer = 12\\nExample 2: \"dir\\\\n[][][][][][][][]file.txt\", answer = 16\\n\\nThink about the structures of those examples like (level -1 is fake but you get the idea):\\n\\nExample 1:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][]file.txt\\n\\nExample 2:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][][][][][]file.txt\\n\\t\\nAlso, don\\'t forget to add the count of slashes to your answer.\\n\\nThanks to [@StefanPochmann](https://leetcode.com/stefanpochmann) for clarification, although it took me a while to understand his statement....\\n\\nReference\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86636/This-problem-is-not-well-defined.-It-should-state-that-4-space-is-considered-as-a-TAB-under-certain-situation./91631\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86619/Simple-Python-solution"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The description of the problem gives solvers a false impression that there is only one top level node, and this node is named \"dir\". It is only after you start testing the code that we run into a testcase like \"dir\\\\nfile.txt\" where both dir and file.txt are at the top-level. Not specifying that something like this is possible in the problem description is not correct, because we have already designed and implemented a solution that does not account for this possiblity. We have to go back to the drawing board and re-design our solution to account for this case."
                    },
                    {
                        "username": "AbhishekBabuji",
                        "content": "Trying to practice BFS but, I bump into these weird test cases that involve tabs and space that have no explanation as to when to include space as a part of the file name and when not to"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "In the thread, you may find complaints on testcases:\\n\\n`dir\\\\n\\\\tfile.txt\\' should have different length from `dir\\\\n...file.txt\\' (here . stays for spaces)\\n(see, for example, https://leetcode.com/problems/longest-absolute-file-path/discuss/86649/What-is-purpose-of-weird-test-cases)\\n\\nBut what about **file system** `text.txt`? I always thought that file system MUST be a folder. Is my opinion wrong?\\n"
                    },
                    {
                        "username": "Gentlemanbug",
                        "content": "Shouldn't \"dir\\\\n        file.txt\" represent \"dir/file.txt\", which has the lenght 12? There are 8 white spaces in the string. It's not displayed properly in the subject."
                    },
                    {
                        "username": "sundarramr",
                        "content": "\"dir\\\\n        file.txt\"\\nexpected output: 16\\n\\nif so how?\\n\\nlook like it has 8 blank space. should we consider it for length?"
                    },
                    {
                        "username": "ahmed",
                        "content": "I know that a stack would solve the problem, but would someone explain the algorithm in plain english and write the code that he explains. I'm very interested to know how to solve that problem."
                    },
                    {
                        "username": "faangboy",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/nightfox21/image_1526685725.png)\\n"
                    }
                ]
            },
            {
                "id": 1569219,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "After many try-and-error, I finally figured out the solution is required to handle the blank spaces in a special way. I think it should be stated in the problem statement, not just let people guess this from the expected answers. This will waste many people a lot of time...."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "then why the fuck didnt u mentioned here the special way instead of just leaving the  readers on a cliffhanger"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "In all the examples, Tab \"\\\\t\" is used instead of Spaces. Several of OJ test cases have spaces in them and you will have to treat spaces separately. When you see 4 spaces, it will count as a tab.\\n\\nAlso, in the problem and examples, every file is nested directly under a directory. However, not all the test cases have this format: \\n\\nFor example: Test Case #14:  \"dir\\\\n________file.txt\" <-- there are 8 spaces under file.txt and the answer is 16 (not 12).\\n\\nThe problem statement really should be more clear. This isn't a fun problem when you invest a lot of time into solving it, only to realize the problem statement and test cases are entirely different."
                    },
                    {
                        "username": "yummy_bloomy",
                        "content": "It was intuitive to us that \\'\\\\t\\' is the indicator of \\'level\\' for a certain line. For example, in the test case dir\\\\n\\\\tsub1\\\\n\\\\t\\\\tfile1.txt, dir = level 0, sub1 = level2, file1.txt = level3\\n\\nBut we got confused by weird test cases and thought that \\'[][][][]\\' four spaces can also be the level indicator. It\\'s not true. Please repeat with me: \\n**\\'\\\\t\\' is the ONE AND ONLY indicator of \\'level\\' for a certain line**.\\n\\nLet\\'s define lines = input.split(\\'\\\\n\\'). For any lines[i], we need to get the level of it to determine its depth in the file structure, and the length of the line (without \\'\\\\t\\') to determine the length of its absolute path. \\n\\nMethod 1\\n**level of line i = lines[i].count(\\'\\\\t\\')**\\n**real length of line i = len(lines[i]) - level of line i** (while it looks like \\'\\\\t\\' takes 2 or 4 spaces, Python only count it as 1 space)\\n\\nMethod 2\\n**real length of line i = len(lines[i].strip(\\'\\\\t\\'))\\nlevel of line i = len(lines[i]) - real length of line i** \\n\\nI guess many of you are making the same mistake as I did, where I used len(lines[i].strip()), which got rid of both tabs and spaces. That led to wrong results of the following test cases, where **spaces are part of the file names**. As they have no \\'\\\\t\\' before them, they are both of level 0, the same level as dir. Therefore, **the file names themselves are the abosulte paths**. \\n\\nExample 1: \"dir\\\\n[][][][]file.txt\", answer = 12\\nExample 2: \"dir\\\\n[][][][][][][][]file.txt\", answer = 16\\n\\nThink about the structures of those examples like (level -1 is fake but you get the idea):\\n\\nExample 1:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][]file.txt\\n\\nExample 2:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][][][][][]file.txt\\n\\t\\nAlso, don\\'t forget to add the count of slashes to your answer.\\n\\nThanks to [@StefanPochmann](https://leetcode.com/stefanpochmann) for clarification, although it took me a while to understand his statement....\\n\\nReference\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86636/This-problem-is-not-well-defined.-It-should-state-that-4-space-is-considered-as-a-TAB-under-certain-situation./91631\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86619/Simple-Python-solution"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The description of the problem gives solvers a false impression that there is only one top level node, and this node is named \"dir\". It is only after you start testing the code that we run into a testcase like \"dir\\\\nfile.txt\" where both dir and file.txt are at the top-level. Not specifying that something like this is possible in the problem description is not correct, because we have already designed and implemented a solution that does not account for this possiblity. We have to go back to the drawing board and re-design our solution to account for this case."
                    },
                    {
                        "username": "AbhishekBabuji",
                        "content": "Trying to practice BFS but, I bump into these weird test cases that involve tabs and space that have no explanation as to when to include space as a part of the file name and when not to"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "In the thread, you may find complaints on testcases:\\n\\n`dir\\\\n\\\\tfile.txt\\' should have different length from `dir\\\\n...file.txt\\' (here . stays for spaces)\\n(see, for example, https://leetcode.com/problems/longest-absolute-file-path/discuss/86649/What-is-purpose-of-weird-test-cases)\\n\\nBut what about **file system** `text.txt`? I always thought that file system MUST be a folder. Is my opinion wrong?\\n"
                    },
                    {
                        "username": "Gentlemanbug",
                        "content": "Shouldn't \"dir\\\\n        file.txt\" represent \"dir/file.txt\", which has the lenght 12? There are 8 white spaces in the string. It's not displayed properly in the subject."
                    },
                    {
                        "username": "sundarramr",
                        "content": "\"dir\\\\n        file.txt\"\\nexpected output: 16\\n\\nif so how?\\n\\nlook like it has 8 blank space. should we consider it for length?"
                    },
                    {
                        "username": "ahmed",
                        "content": "I know that a stack would solve the problem, but would someone explain the algorithm in plain english and write the code that he explains. I'm very interested to know how to solve that problem."
                    },
                    {
                        "username": "faangboy",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/nightfox21/image_1526685725.png)\\n"
                    }
                ]
            },
            {
                "id": 1564625,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "After many try-and-error, I finally figured out the solution is required to handle the blank spaces in a special way. I think it should be stated in the problem statement, not just let people guess this from the expected answers. This will waste many people a lot of time...."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "then why the fuck didnt u mentioned here the special way instead of just leaving the  readers on a cliffhanger"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "In all the examples, Tab \"\\\\t\" is used instead of Spaces. Several of OJ test cases have spaces in them and you will have to treat spaces separately. When you see 4 spaces, it will count as a tab.\\n\\nAlso, in the problem and examples, every file is nested directly under a directory. However, not all the test cases have this format: \\n\\nFor example: Test Case #14:  \"dir\\\\n________file.txt\" <-- there are 8 spaces under file.txt and the answer is 16 (not 12).\\n\\nThe problem statement really should be more clear. This isn't a fun problem when you invest a lot of time into solving it, only to realize the problem statement and test cases are entirely different."
                    },
                    {
                        "username": "yummy_bloomy",
                        "content": "It was intuitive to us that \\'\\\\t\\' is the indicator of \\'level\\' for a certain line. For example, in the test case dir\\\\n\\\\tsub1\\\\n\\\\t\\\\tfile1.txt, dir = level 0, sub1 = level2, file1.txt = level3\\n\\nBut we got confused by weird test cases and thought that \\'[][][][]\\' four spaces can also be the level indicator. It\\'s not true. Please repeat with me: \\n**\\'\\\\t\\' is the ONE AND ONLY indicator of \\'level\\' for a certain line**.\\n\\nLet\\'s define lines = input.split(\\'\\\\n\\'). For any lines[i], we need to get the level of it to determine its depth in the file structure, and the length of the line (without \\'\\\\t\\') to determine the length of its absolute path. \\n\\nMethod 1\\n**level of line i = lines[i].count(\\'\\\\t\\')**\\n**real length of line i = len(lines[i]) - level of line i** (while it looks like \\'\\\\t\\' takes 2 or 4 spaces, Python only count it as 1 space)\\n\\nMethod 2\\n**real length of line i = len(lines[i].strip(\\'\\\\t\\'))\\nlevel of line i = len(lines[i]) - real length of line i** \\n\\nI guess many of you are making the same mistake as I did, where I used len(lines[i].strip()), which got rid of both tabs and spaces. That led to wrong results of the following test cases, where **spaces are part of the file names**. As they have no \\'\\\\t\\' before them, they are both of level 0, the same level as dir. Therefore, **the file names themselves are the abosulte paths**. \\n\\nExample 1: \"dir\\\\n[][][][]file.txt\", answer = 12\\nExample 2: \"dir\\\\n[][][][][][][][]file.txt\", answer = 16\\n\\nThink about the structures of those examples like (level -1 is fake but you get the idea):\\n\\nExample 1:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][]file.txt\\n\\nExample 2:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][][][][][]file.txt\\n\\t\\nAlso, don\\'t forget to add the count of slashes to your answer.\\n\\nThanks to [@StefanPochmann](https://leetcode.com/stefanpochmann) for clarification, although it took me a while to understand his statement....\\n\\nReference\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86636/This-problem-is-not-well-defined.-It-should-state-that-4-space-is-considered-as-a-TAB-under-certain-situation./91631\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86619/Simple-Python-solution"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The description of the problem gives solvers a false impression that there is only one top level node, and this node is named \"dir\". It is only after you start testing the code that we run into a testcase like \"dir\\\\nfile.txt\" where both dir and file.txt are at the top-level. Not specifying that something like this is possible in the problem description is not correct, because we have already designed and implemented a solution that does not account for this possiblity. We have to go back to the drawing board and re-design our solution to account for this case."
                    },
                    {
                        "username": "AbhishekBabuji",
                        "content": "Trying to practice BFS but, I bump into these weird test cases that involve tabs and space that have no explanation as to when to include space as a part of the file name and when not to"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "In the thread, you may find complaints on testcases:\\n\\n`dir\\\\n\\\\tfile.txt\\' should have different length from `dir\\\\n...file.txt\\' (here . stays for spaces)\\n(see, for example, https://leetcode.com/problems/longest-absolute-file-path/discuss/86649/What-is-purpose-of-weird-test-cases)\\n\\nBut what about **file system** `text.txt`? I always thought that file system MUST be a folder. Is my opinion wrong?\\n"
                    },
                    {
                        "username": "Gentlemanbug",
                        "content": "Shouldn't \"dir\\\\n        file.txt\" represent \"dir/file.txt\", which has the lenght 12? There are 8 white spaces in the string. It's not displayed properly in the subject."
                    },
                    {
                        "username": "sundarramr",
                        "content": "\"dir\\\\n        file.txt\"\\nexpected output: 16\\n\\nif so how?\\n\\nlook like it has 8 blank space. should we consider it for length?"
                    },
                    {
                        "username": "ahmed",
                        "content": "I know that a stack would solve the problem, but would someone explain the algorithm in plain english and write the code that he explains. I'm very interested to know how to solve that problem."
                    },
                    {
                        "username": "faangboy",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/nightfox21/image_1526685725.png)\\n"
                    }
                ]
            },
            {
                "id": 1569169,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "After many try-and-error, I finally figured out the solution is required to handle the blank spaces in a special way. I think it should be stated in the problem statement, not just let people guess this from the expected answers. This will waste many people a lot of time...."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "then why the fuck didnt u mentioned here the special way instead of just leaving the  readers on a cliffhanger"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "In all the examples, Tab \"\\\\t\" is used instead of Spaces. Several of OJ test cases have spaces in them and you will have to treat spaces separately. When you see 4 spaces, it will count as a tab.\\n\\nAlso, in the problem and examples, every file is nested directly under a directory. However, not all the test cases have this format: \\n\\nFor example: Test Case #14:  \"dir\\\\n________file.txt\" <-- there are 8 spaces under file.txt and the answer is 16 (not 12).\\n\\nThe problem statement really should be more clear. This isn't a fun problem when you invest a lot of time into solving it, only to realize the problem statement and test cases are entirely different."
                    },
                    {
                        "username": "yummy_bloomy",
                        "content": "It was intuitive to us that \\'\\\\t\\' is the indicator of \\'level\\' for a certain line. For example, in the test case dir\\\\n\\\\tsub1\\\\n\\\\t\\\\tfile1.txt, dir = level 0, sub1 = level2, file1.txt = level3\\n\\nBut we got confused by weird test cases and thought that \\'[][][][]\\' four spaces can also be the level indicator. It\\'s not true. Please repeat with me: \\n**\\'\\\\t\\' is the ONE AND ONLY indicator of \\'level\\' for a certain line**.\\n\\nLet\\'s define lines = input.split(\\'\\\\n\\'). For any lines[i], we need to get the level of it to determine its depth in the file structure, and the length of the line (without \\'\\\\t\\') to determine the length of its absolute path. \\n\\nMethod 1\\n**level of line i = lines[i].count(\\'\\\\t\\')**\\n**real length of line i = len(lines[i]) - level of line i** (while it looks like \\'\\\\t\\' takes 2 or 4 spaces, Python only count it as 1 space)\\n\\nMethod 2\\n**real length of line i = len(lines[i].strip(\\'\\\\t\\'))\\nlevel of line i = len(lines[i]) - real length of line i** \\n\\nI guess many of you are making the same mistake as I did, where I used len(lines[i].strip()), which got rid of both tabs and spaces. That led to wrong results of the following test cases, where **spaces are part of the file names**. As they have no \\'\\\\t\\' before them, they are both of level 0, the same level as dir. Therefore, **the file names themselves are the abosulte paths**. \\n\\nExample 1: \"dir\\\\n[][][][]file.txt\", answer = 12\\nExample 2: \"dir\\\\n[][][][][][][][]file.txt\", answer = 16\\n\\nThink about the structures of those examples like (level -1 is fake but you get the idea):\\n\\nExample 1:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][]file.txt\\n\\nExample 2:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][][][][][]file.txt\\n\\t\\nAlso, don\\'t forget to add the count of slashes to your answer.\\n\\nThanks to [@StefanPochmann](https://leetcode.com/stefanpochmann) for clarification, although it took me a while to understand his statement....\\n\\nReference\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86636/This-problem-is-not-well-defined.-It-should-state-that-4-space-is-considered-as-a-TAB-under-certain-situation./91631\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86619/Simple-Python-solution"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The description of the problem gives solvers a false impression that there is only one top level node, and this node is named \"dir\". It is only after you start testing the code that we run into a testcase like \"dir\\\\nfile.txt\" where both dir and file.txt are at the top-level. Not specifying that something like this is possible in the problem description is not correct, because we have already designed and implemented a solution that does not account for this possiblity. We have to go back to the drawing board and re-design our solution to account for this case."
                    },
                    {
                        "username": "AbhishekBabuji",
                        "content": "Trying to practice BFS but, I bump into these weird test cases that involve tabs and space that have no explanation as to when to include space as a part of the file name and when not to"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "In the thread, you may find complaints on testcases:\\n\\n`dir\\\\n\\\\tfile.txt\\' should have different length from `dir\\\\n...file.txt\\' (here . stays for spaces)\\n(see, for example, https://leetcode.com/problems/longest-absolute-file-path/discuss/86649/What-is-purpose-of-weird-test-cases)\\n\\nBut what about **file system** `text.txt`? I always thought that file system MUST be a folder. Is my opinion wrong?\\n"
                    },
                    {
                        "username": "Gentlemanbug",
                        "content": "Shouldn't \"dir\\\\n        file.txt\" represent \"dir/file.txt\", which has the lenght 12? There are 8 white spaces in the string. It's not displayed properly in the subject."
                    },
                    {
                        "username": "sundarramr",
                        "content": "\"dir\\\\n        file.txt\"\\nexpected output: 16\\n\\nif so how?\\n\\nlook like it has 8 blank space. should we consider it for length?"
                    },
                    {
                        "username": "ahmed",
                        "content": "I know that a stack would solve the problem, but would someone explain the algorithm in plain english and write the code that he explains. I'm very interested to know how to solve that problem."
                    },
                    {
                        "username": "faangboy",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/nightfox21/image_1526685725.png)\\n"
                    }
                ]
            },
            {
                "id": 1565994,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "After many try-and-error, I finally figured out the solution is required to handle the blank spaces in a special way. I think it should be stated in the problem statement, not just let people guess this from the expected answers. This will waste many people a lot of time...."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "then why the fuck didnt u mentioned here the special way instead of just leaving the  readers on a cliffhanger"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "In all the examples, Tab \"\\\\t\" is used instead of Spaces. Several of OJ test cases have spaces in them and you will have to treat spaces separately. When you see 4 spaces, it will count as a tab.\\n\\nAlso, in the problem and examples, every file is nested directly under a directory. However, not all the test cases have this format: \\n\\nFor example: Test Case #14:  \"dir\\\\n________file.txt\" <-- there are 8 spaces under file.txt and the answer is 16 (not 12).\\n\\nThe problem statement really should be more clear. This isn't a fun problem when you invest a lot of time into solving it, only to realize the problem statement and test cases are entirely different."
                    },
                    {
                        "username": "yummy_bloomy",
                        "content": "It was intuitive to us that \\'\\\\t\\' is the indicator of \\'level\\' for a certain line. For example, in the test case dir\\\\n\\\\tsub1\\\\n\\\\t\\\\tfile1.txt, dir = level 0, sub1 = level2, file1.txt = level3\\n\\nBut we got confused by weird test cases and thought that \\'[][][][]\\' four spaces can also be the level indicator. It\\'s not true. Please repeat with me: \\n**\\'\\\\t\\' is the ONE AND ONLY indicator of \\'level\\' for a certain line**.\\n\\nLet\\'s define lines = input.split(\\'\\\\n\\'). For any lines[i], we need to get the level of it to determine its depth in the file structure, and the length of the line (without \\'\\\\t\\') to determine the length of its absolute path. \\n\\nMethod 1\\n**level of line i = lines[i].count(\\'\\\\t\\')**\\n**real length of line i = len(lines[i]) - level of line i** (while it looks like \\'\\\\t\\' takes 2 or 4 spaces, Python only count it as 1 space)\\n\\nMethod 2\\n**real length of line i = len(lines[i].strip(\\'\\\\t\\'))\\nlevel of line i = len(lines[i]) - real length of line i** \\n\\nI guess many of you are making the same mistake as I did, where I used len(lines[i].strip()), which got rid of both tabs and spaces. That led to wrong results of the following test cases, where **spaces are part of the file names**. As they have no \\'\\\\t\\' before them, they are both of level 0, the same level as dir. Therefore, **the file names themselves are the abosulte paths**. \\n\\nExample 1: \"dir\\\\n[][][][]file.txt\", answer = 12\\nExample 2: \"dir\\\\n[][][][][][][][]file.txt\", answer = 16\\n\\nThink about the structures of those examples like (level -1 is fake but you get the idea):\\n\\nExample 1:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][]file.txt\\n\\nExample 2:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][][][][][]file.txt\\n\\t\\nAlso, don\\'t forget to add the count of slashes to your answer.\\n\\nThanks to [@StefanPochmann](https://leetcode.com/stefanpochmann) for clarification, although it took me a while to understand his statement....\\n\\nReference\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86636/This-problem-is-not-well-defined.-It-should-state-that-4-space-is-considered-as-a-TAB-under-certain-situation./91631\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86619/Simple-Python-solution"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The description of the problem gives solvers a false impression that there is only one top level node, and this node is named \"dir\". It is only after you start testing the code that we run into a testcase like \"dir\\\\nfile.txt\" where both dir and file.txt are at the top-level. Not specifying that something like this is possible in the problem description is not correct, because we have already designed and implemented a solution that does not account for this possiblity. We have to go back to the drawing board and re-design our solution to account for this case."
                    },
                    {
                        "username": "AbhishekBabuji",
                        "content": "Trying to practice BFS but, I bump into these weird test cases that involve tabs and space that have no explanation as to when to include space as a part of the file name and when not to"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "In the thread, you may find complaints on testcases:\\n\\n`dir\\\\n\\\\tfile.txt\\' should have different length from `dir\\\\n...file.txt\\' (here . stays for spaces)\\n(see, for example, https://leetcode.com/problems/longest-absolute-file-path/discuss/86649/What-is-purpose-of-weird-test-cases)\\n\\nBut what about **file system** `text.txt`? I always thought that file system MUST be a folder. Is my opinion wrong?\\n"
                    },
                    {
                        "username": "Gentlemanbug",
                        "content": "Shouldn't \"dir\\\\n        file.txt\" represent \"dir/file.txt\", which has the lenght 12? There are 8 white spaces in the string. It's not displayed properly in the subject."
                    },
                    {
                        "username": "sundarramr",
                        "content": "\"dir\\\\n        file.txt\"\\nexpected output: 16\\n\\nif so how?\\n\\nlook like it has 8 blank space. should we consider it for length?"
                    },
                    {
                        "username": "ahmed",
                        "content": "I know that a stack would solve the problem, but would someone explain the algorithm in plain english and write the code that he explains. I'm very interested to know how to solve that problem."
                    },
                    {
                        "username": "faangboy",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/nightfox21/image_1526685725.png)\\n"
                    }
                ]
            },
            {
                "id": 1569789,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "After many try-and-error, I finally figured out the solution is required to handle the blank spaces in a special way. I think it should be stated in the problem statement, not just let people guess this from the expected answers. This will waste many people a lot of time...."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "then why the fuck didnt u mentioned here the special way instead of just leaving the  readers on a cliffhanger"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "In all the examples, Tab \"\\\\t\" is used instead of Spaces. Several of OJ test cases have spaces in them and you will have to treat spaces separately. When you see 4 spaces, it will count as a tab.\\n\\nAlso, in the problem and examples, every file is nested directly under a directory. However, not all the test cases have this format: \\n\\nFor example: Test Case #14:  \"dir\\\\n________file.txt\" <-- there are 8 spaces under file.txt and the answer is 16 (not 12).\\n\\nThe problem statement really should be more clear. This isn't a fun problem when you invest a lot of time into solving it, only to realize the problem statement and test cases are entirely different."
                    },
                    {
                        "username": "yummy_bloomy",
                        "content": "It was intuitive to us that \\'\\\\t\\' is the indicator of \\'level\\' for a certain line. For example, in the test case dir\\\\n\\\\tsub1\\\\n\\\\t\\\\tfile1.txt, dir = level 0, sub1 = level2, file1.txt = level3\\n\\nBut we got confused by weird test cases and thought that \\'[][][][]\\' four spaces can also be the level indicator. It\\'s not true. Please repeat with me: \\n**\\'\\\\t\\' is the ONE AND ONLY indicator of \\'level\\' for a certain line**.\\n\\nLet\\'s define lines = input.split(\\'\\\\n\\'). For any lines[i], we need to get the level of it to determine its depth in the file structure, and the length of the line (without \\'\\\\t\\') to determine the length of its absolute path. \\n\\nMethod 1\\n**level of line i = lines[i].count(\\'\\\\t\\')**\\n**real length of line i = len(lines[i]) - level of line i** (while it looks like \\'\\\\t\\' takes 2 or 4 spaces, Python only count it as 1 space)\\n\\nMethod 2\\n**real length of line i = len(lines[i].strip(\\'\\\\t\\'))\\nlevel of line i = len(lines[i]) - real length of line i** \\n\\nI guess many of you are making the same mistake as I did, where I used len(lines[i].strip()), which got rid of both tabs and spaces. That led to wrong results of the following test cases, where **spaces are part of the file names**. As they have no \\'\\\\t\\' before them, they are both of level 0, the same level as dir. Therefore, **the file names themselves are the abosulte paths**. \\n\\nExample 1: \"dir\\\\n[][][][]file.txt\", answer = 12\\nExample 2: \"dir\\\\n[][][][][][][][]file.txt\", answer = 16\\n\\nThink about the structures of those examples like (level -1 is fake but you get the idea):\\n\\nExample 1:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][]file.txt\\n\\nExample 2:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][][][][][]file.txt\\n\\t\\nAlso, don\\'t forget to add the count of slashes to your answer.\\n\\nThanks to [@StefanPochmann](https://leetcode.com/stefanpochmann) for clarification, although it took me a while to understand his statement....\\n\\nReference\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86636/This-problem-is-not-well-defined.-It-should-state-that-4-space-is-considered-as-a-TAB-under-certain-situation./91631\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86619/Simple-Python-solution"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The description of the problem gives solvers a false impression that there is only one top level node, and this node is named \"dir\". It is only after you start testing the code that we run into a testcase like \"dir\\\\nfile.txt\" where both dir and file.txt are at the top-level. Not specifying that something like this is possible in the problem description is not correct, because we have already designed and implemented a solution that does not account for this possiblity. We have to go back to the drawing board and re-design our solution to account for this case."
                    },
                    {
                        "username": "AbhishekBabuji",
                        "content": "Trying to practice BFS but, I bump into these weird test cases that involve tabs and space that have no explanation as to when to include space as a part of the file name and when not to"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "In the thread, you may find complaints on testcases:\\n\\n`dir\\\\n\\\\tfile.txt\\' should have different length from `dir\\\\n...file.txt\\' (here . stays for spaces)\\n(see, for example, https://leetcode.com/problems/longest-absolute-file-path/discuss/86649/What-is-purpose-of-weird-test-cases)\\n\\nBut what about **file system** `text.txt`? I always thought that file system MUST be a folder. Is my opinion wrong?\\n"
                    },
                    {
                        "username": "Gentlemanbug",
                        "content": "Shouldn't \"dir\\\\n        file.txt\" represent \"dir/file.txt\", which has the lenght 12? There are 8 white spaces in the string. It's not displayed properly in the subject."
                    },
                    {
                        "username": "sundarramr",
                        "content": "\"dir\\\\n        file.txt\"\\nexpected output: 16\\n\\nif so how?\\n\\nlook like it has 8 blank space. should we consider it for length?"
                    },
                    {
                        "username": "ahmed",
                        "content": "I know that a stack would solve the problem, but would someone explain the algorithm in plain english and write the code that he explains. I'm very interested to know how to solve that problem."
                    },
                    {
                        "username": "faangboy",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/nightfox21/image_1526685725.png)\\n"
                    }
                ]
            },
            {
                "id": 1567374,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "After many try-and-error, I finally figured out the solution is required to handle the blank spaces in a special way. I think it should be stated in the problem statement, not just let people guess this from the expected answers. This will waste many people a lot of time...."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "then why the fuck didnt u mentioned here the special way instead of just leaving the  readers on a cliffhanger"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "In all the examples, Tab \"\\\\t\" is used instead of Spaces. Several of OJ test cases have spaces in them and you will have to treat spaces separately. When you see 4 spaces, it will count as a tab.\\n\\nAlso, in the problem and examples, every file is nested directly under a directory. However, not all the test cases have this format: \\n\\nFor example: Test Case #14:  \"dir\\\\n________file.txt\" <-- there are 8 spaces under file.txt and the answer is 16 (not 12).\\n\\nThe problem statement really should be more clear. This isn't a fun problem when you invest a lot of time into solving it, only to realize the problem statement and test cases are entirely different."
                    },
                    {
                        "username": "yummy_bloomy",
                        "content": "It was intuitive to us that \\'\\\\t\\' is the indicator of \\'level\\' for a certain line. For example, in the test case dir\\\\n\\\\tsub1\\\\n\\\\t\\\\tfile1.txt, dir = level 0, sub1 = level2, file1.txt = level3\\n\\nBut we got confused by weird test cases and thought that \\'[][][][]\\' four spaces can also be the level indicator. It\\'s not true. Please repeat with me: \\n**\\'\\\\t\\' is the ONE AND ONLY indicator of \\'level\\' for a certain line**.\\n\\nLet\\'s define lines = input.split(\\'\\\\n\\'). For any lines[i], we need to get the level of it to determine its depth in the file structure, and the length of the line (without \\'\\\\t\\') to determine the length of its absolute path. \\n\\nMethod 1\\n**level of line i = lines[i].count(\\'\\\\t\\')**\\n**real length of line i = len(lines[i]) - level of line i** (while it looks like \\'\\\\t\\' takes 2 or 4 spaces, Python only count it as 1 space)\\n\\nMethod 2\\n**real length of line i = len(lines[i].strip(\\'\\\\t\\'))\\nlevel of line i = len(lines[i]) - real length of line i** \\n\\nI guess many of you are making the same mistake as I did, where I used len(lines[i].strip()), which got rid of both tabs and spaces. That led to wrong results of the following test cases, where **spaces are part of the file names**. As they have no \\'\\\\t\\' before them, they are both of level 0, the same level as dir. Therefore, **the file names themselves are the abosulte paths**. \\n\\nExample 1: \"dir\\\\n[][][][]file.txt\", answer = 12\\nExample 2: \"dir\\\\n[][][][][][][][]file.txt\", answer = 16\\n\\nThink about the structures of those examples like (level -1 is fake but you get the idea):\\n\\nExample 1:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][]file.txt\\n\\nExample 2:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][][][][][]file.txt\\n\\t\\nAlso, don\\'t forget to add the count of slashes to your answer.\\n\\nThanks to [@StefanPochmann](https://leetcode.com/stefanpochmann) for clarification, although it took me a while to understand his statement....\\n\\nReference\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86636/This-problem-is-not-well-defined.-It-should-state-that-4-space-is-considered-as-a-TAB-under-certain-situation./91631\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86619/Simple-Python-solution"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The description of the problem gives solvers a false impression that there is only one top level node, and this node is named \"dir\". It is only after you start testing the code that we run into a testcase like \"dir\\\\nfile.txt\" where both dir and file.txt are at the top-level. Not specifying that something like this is possible in the problem description is not correct, because we have already designed and implemented a solution that does not account for this possiblity. We have to go back to the drawing board and re-design our solution to account for this case."
                    },
                    {
                        "username": "AbhishekBabuji",
                        "content": "Trying to practice BFS but, I bump into these weird test cases that involve tabs and space that have no explanation as to when to include space as a part of the file name and when not to"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "In the thread, you may find complaints on testcases:\\n\\n`dir\\\\n\\\\tfile.txt\\' should have different length from `dir\\\\n...file.txt\\' (here . stays for spaces)\\n(see, for example, https://leetcode.com/problems/longest-absolute-file-path/discuss/86649/What-is-purpose-of-weird-test-cases)\\n\\nBut what about **file system** `text.txt`? I always thought that file system MUST be a folder. Is my opinion wrong?\\n"
                    },
                    {
                        "username": "Gentlemanbug",
                        "content": "Shouldn't \"dir\\\\n        file.txt\" represent \"dir/file.txt\", which has the lenght 12? There are 8 white spaces in the string. It's not displayed properly in the subject."
                    },
                    {
                        "username": "sundarramr",
                        "content": "\"dir\\\\n        file.txt\"\\nexpected output: 16\\n\\nif so how?\\n\\nlook like it has 8 blank space. should we consider it for length?"
                    },
                    {
                        "username": "ahmed",
                        "content": "I know that a stack would solve the problem, but would someone explain the algorithm in plain english and write the code that he explains. I'm very interested to know how to solve that problem."
                    },
                    {
                        "username": "faangboy",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/nightfox21/image_1526685725.png)\\n"
                    }
                ]
            },
            {
                "id": 1569741,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "After many try-and-error, I finally figured out the solution is required to handle the blank spaces in a special way. I think it should be stated in the problem statement, not just let people guess this from the expected answers. This will waste many people a lot of time...."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "then why the fuck didnt u mentioned here the special way instead of just leaving the  readers on a cliffhanger"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "In all the examples, Tab \"\\\\t\" is used instead of Spaces. Several of OJ test cases have spaces in them and you will have to treat spaces separately. When you see 4 spaces, it will count as a tab.\\n\\nAlso, in the problem and examples, every file is nested directly under a directory. However, not all the test cases have this format: \\n\\nFor example: Test Case #14:  \"dir\\\\n________file.txt\" <-- there are 8 spaces under file.txt and the answer is 16 (not 12).\\n\\nThe problem statement really should be more clear. This isn't a fun problem when you invest a lot of time into solving it, only to realize the problem statement and test cases are entirely different."
                    },
                    {
                        "username": "yummy_bloomy",
                        "content": "It was intuitive to us that \\'\\\\t\\' is the indicator of \\'level\\' for a certain line. For example, in the test case dir\\\\n\\\\tsub1\\\\n\\\\t\\\\tfile1.txt, dir = level 0, sub1 = level2, file1.txt = level3\\n\\nBut we got confused by weird test cases and thought that \\'[][][][]\\' four spaces can also be the level indicator. It\\'s not true. Please repeat with me: \\n**\\'\\\\t\\' is the ONE AND ONLY indicator of \\'level\\' for a certain line**.\\n\\nLet\\'s define lines = input.split(\\'\\\\n\\'). For any lines[i], we need to get the level of it to determine its depth in the file structure, and the length of the line (without \\'\\\\t\\') to determine the length of its absolute path. \\n\\nMethod 1\\n**level of line i = lines[i].count(\\'\\\\t\\')**\\n**real length of line i = len(lines[i]) - level of line i** (while it looks like \\'\\\\t\\' takes 2 or 4 spaces, Python only count it as 1 space)\\n\\nMethod 2\\n**real length of line i = len(lines[i].strip(\\'\\\\t\\'))\\nlevel of line i = len(lines[i]) - real length of line i** \\n\\nI guess many of you are making the same mistake as I did, where I used len(lines[i].strip()), which got rid of both tabs and spaces. That led to wrong results of the following test cases, where **spaces are part of the file names**. As they have no \\'\\\\t\\' before them, they are both of level 0, the same level as dir. Therefore, **the file names themselves are the abosulte paths**. \\n\\nExample 1: \"dir\\\\n[][][][]file.txt\", answer = 12\\nExample 2: \"dir\\\\n[][][][][][][][]file.txt\", answer = 16\\n\\nThink about the structures of those examples like (level -1 is fake but you get the idea):\\n\\nExample 1:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][]file.txt\\n\\nExample 2:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][][][][][]file.txt\\n\\t\\nAlso, don\\'t forget to add the count of slashes to your answer.\\n\\nThanks to [@StefanPochmann](https://leetcode.com/stefanpochmann) for clarification, although it took me a while to understand his statement....\\n\\nReference\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86636/This-problem-is-not-well-defined.-It-should-state-that-4-space-is-considered-as-a-TAB-under-certain-situation./91631\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86619/Simple-Python-solution"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The description of the problem gives solvers a false impression that there is only one top level node, and this node is named \"dir\". It is only after you start testing the code that we run into a testcase like \"dir\\\\nfile.txt\" where both dir and file.txt are at the top-level. Not specifying that something like this is possible in the problem description is not correct, because we have already designed and implemented a solution that does not account for this possiblity. We have to go back to the drawing board and re-design our solution to account for this case."
                    },
                    {
                        "username": "AbhishekBabuji",
                        "content": "Trying to practice BFS but, I bump into these weird test cases that involve tabs and space that have no explanation as to when to include space as a part of the file name and when not to"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "In the thread, you may find complaints on testcases:\\n\\n`dir\\\\n\\\\tfile.txt\\' should have different length from `dir\\\\n...file.txt\\' (here . stays for spaces)\\n(see, for example, https://leetcode.com/problems/longest-absolute-file-path/discuss/86649/What-is-purpose-of-weird-test-cases)\\n\\nBut what about **file system** `text.txt`? I always thought that file system MUST be a folder. Is my opinion wrong?\\n"
                    },
                    {
                        "username": "Gentlemanbug",
                        "content": "Shouldn't \"dir\\\\n        file.txt\" represent \"dir/file.txt\", which has the lenght 12? There are 8 white spaces in the string. It's not displayed properly in the subject."
                    },
                    {
                        "username": "sundarramr",
                        "content": "\"dir\\\\n        file.txt\"\\nexpected output: 16\\n\\nif so how?\\n\\nlook like it has 8 blank space. should we consider it for length?"
                    },
                    {
                        "username": "ahmed",
                        "content": "I know that a stack would solve the problem, but would someone explain the algorithm in plain english and write the code that he explains. I'm very interested to know how to solve that problem."
                    },
                    {
                        "username": "faangboy",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/nightfox21/image_1526685725.png)\\n"
                    }
                ]
            },
            {
                "id": 1569108,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "After many try-and-error, I finally figured out the solution is required to handle the blank spaces in a special way. I think it should be stated in the problem statement, not just let people guess this from the expected answers. This will waste many people a lot of time...."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "then why the fuck didnt u mentioned here the special way instead of just leaving the  readers on a cliffhanger"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "In all the examples, Tab \"\\\\t\" is used instead of Spaces. Several of OJ test cases have spaces in them and you will have to treat spaces separately. When you see 4 spaces, it will count as a tab.\\n\\nAlso, in the problem and examples, every file is nested directly under a directory. However, not all the test cases have this format: \\n\\nFor example: Test Case #14:  \"dir\\\\n________file.txt\" <-- there are 8 spaces under file.txt and the answer is 16 (not 12).\\n\\nThe problem statement really should be more clear. This isn't a fun problem when you invest a lot of time into solving it, only to realize the problem statement and test cases are entirely different."
                    },
                    {
                        "username": "yummy_bloomy",
                        "content": "It was intuitive to us that \\'\\\\t\\' is the indicator of \\'level\\' for a certain line. For example, in the test case dir\\\\n\\\\tsub1\\\\n\\\\t\\\\tfile1.txt, dir = level 0, sub1 = level2, file1.txt = level3\\n\\nBut we got confused by weird test cases and thought that \\'[][][][]\\' four spaces can also be the level indicator. It\\'s not true. Please repeat with me: \\n**\\'\\\\t\\' is the ONE AND ONLY indicator of \\'level\\' for a certain line**.\\n\\nLet\\'s define lines = input.split(\\'\\\\n\\'). For any lines[i], we need to get the level of it to determine its depth in the file structure, and the length of the line (without \\'\\\\t\\') to determine the length of its absolute path. \\n\\nMethod 1\\n**level of line i = lines[i].count(\\'\\\\t\\')**\\n**real length of line i = len(lines[i]) - level of line i** (while it looks like \\'\\\\t\\' takes 2 or 4 spaces, Python only count it as 1 space)\\n\\nMethod 2\\n**real length of line i = len(lines[i].strip(\\'\\\\t\\'))\\nlevel of line i = len(lines[i]) - real length of line i** \\n\\nI guess many of you are making the same mistake as I did, where I used len(lines[i].strip()), which got rid of both tabs and spaces. That led to wrong results of the following test cases, where **spaces are part of the file names**. As they have no \\'\\\\t\\' before them, they are both of level 0, the same level as dir. Therefore, **the file names themselves are the abosulte paths**. \\n\\nExample 1: \"dir\\\\n[][][][]file.txt\", answer = 12\\nExample 2: \"dir\\\\n[][][][][][][][]file.txt\", answer = 16\\n\\nThink about the structures of those examples like (level -1 is fake but you get the idea):\\n\\nExample 1:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][]file.txt\\n\\nExample 2:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][][][][][]file.txt\\n\\t\\nAlso, don\\'t forget to add the count of slashes to your answer.\\n\\nThanks to [@StefanPochmann](https://leetcode.com/stefanpochmann) for clarification, although it took me a while to understand his statement....\\n\\nReference\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86636/This-problem-is-not-well-defined.-It-should-state-that-4-space-is-considered-as-a-TAB-under-certain-situation./91631\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86619/Simple-Python-solution"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The description of the problem gives solvers a false impression that there is only one top level node, and this node is named \"dir\". It is only after you start testing the code that we run into a testcase like \"dir\\\\nfile.txt\" where both dir and file.txt are at the top-level. Not specifying that something like this is possible in the problem description is not correct, because we have already designed and implemented a solution that does not account for this possiblity. We have to go back to the drawing board and re-design our solution to account for this case."
                    },
                    {
                        "username": "AbhishekBabuji",
                        "content": "Trying to practice BFS but, I bump into these weird test cases that involve tabs and space that have no explanation as to when to include space as a part of the file name and when not to"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "In the thread, you may find complaints on testcases:\\n\\n`dir\\\\n\\\\tfile.txt\\' should have different length from `dir\\\\n...file.txt\\' (here . stays for spaces)\\n(see, for example, https://leetcode.com/problems/longest-absolute-file-path/discuss/86649/What-is-purpose-of-weird-test-cases)\\n\\nBut what about **file system** `text.txt`? I always thought that file system MUST be a folder. Is my opinion wrong?\\n"
                    },
                    {
                        "username": "Gentlemanbug",
                        "content": "Shouldn't \"dir\\\\n        file.txt\" represent \"dir/file.txt\", which has the lenght 12? There are 8 white spaces in the string. It's not displayed properly in the subject."
                    },
                    {
                        "username": "sundarramr",
                        "content": "\"dir\\\\n        file.txt\"\\nexpected output: 16\\n\\nif so how?\\n\\nlook like it has 8 blank space. should we consider it for length?"
                    },
                    {
                        "username": "ahmed",
                        "content": "I know that a stack would solve the problem, but would someone explain the algorithm in plain english and write the code that he explains. I'm very interested to know how to solve that problem."
                    },
                    {
                        "username": "faangboy",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/nightfox21/image_1526685725.png)\\n"
                    }
                ]
            },
            {
                "id": 1574163,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "After many try-and-error, I finally figured out the solution is required to handle the blank spaces in a special way. I think it should be stated in the problem statement, not just let people guess this from the expected answers. This will waste many people a lot of time...."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "then why the fuck didnt u mentioned here the special way instead of just leaving the  readers on a cliffhanger"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "In all the examples, Tab \"\\\\t\" is used instead of Spaces. Several of OJ test cases have spaces in them and you will have to treat spaces separately. When you see 4 spaces, it will count as a tab.\\n\\nAlso, in the problem and examples, every file is nested directly under a directory. However, not all the test cases have this format: \\n\\nFor example: Test Case #14:  \"dir\\\\n________file.txt\" <-- there are 8 spaces under file.txt and the answer is 16 (not 12).\\n\\nThe problem statement really should be more clear. This isn't a fun problem when you invest a lot of time into solving it, only to realize the problem statement and test cases are entirely different."
                    },
                    {
                        "username": "yummy_bloomy",
                        "content": "It was intuitive to us that \\'\\\\t\\' is the indicator of \\'level\\' for a certain line. For example, in the test case dir\\\\n\\\\tsub1\\\\n\\\\t\\\\tfile1.txt, dir = level 0, sub1 = level2, file1.txt = level3\\n\\nBut we got confused by weird test cases and thought that \\'[][][][]\\' four spaces can also be the level indicator. It\\'s not true. Please repeat with me: \\n**\\'\\\\t\\' is the ONE AND ONLY indicator of \\'level\\' for a certain line**.\\n\\nLet\\'s define lines = input.split(\\'\\\\n\\'). For any lines[i], we need to get the level of it to determine its depth in the file structure, and the length of the line (without \\'\\\\t\\') to determine the length of its absolute path. \\n\\nMethod 1\\n**level of line i = lines[i].count(\\'\\\\t\\')**\\n**real length of line i = len(lines[i]) - level of line i** (while it looks like \\'\\\\t\\' takes 2 or 4 spaces, Python only count it as 1 space)\\n\\nMethod 2\\n**real length of line i = len(lines[i].strip(\\'\\\\t\\'))\\nlevel of line i = len(lines[i]) - real length of line i** \\n\\nI guess many of you are making the same mistake as I did, where I used len(lines[i].strip()), which got rid of both tabs and spaces. That led to wrong results of the following test cases, where **spaces are part of the file names**. As they have no \\'\\\\t\\' before them, they are both of level 0, the same level as dir. Therefore, **the file names themselves are the abosulte paths**. \\n\\nExample 1: \"dir\\\\n[][][][]file.txt\", answer = 12\\nExample 2: \"dir\\\\n[][][][][][][][]file.txt\", answer = 16\\n\\nThink about the structures of those examples like (level -1 is fake but you get the idea):\\n\\nExample 1:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][]file.txt\\n\\nExample 2:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][][][][][]file.txt\\n\\t\\nAlso, don\\'t forget to add the count of slashes to your answer.\\n\\nThanks to [@StefanPochmann](https://leetcode.com/stefanpochmann) for clarification, although it took me a while to understand his statement....\\n\\nReference\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86636/This-problem-is-not-well-defined.-It-should-state-that-4-space-is-considered-as-a-TAB-under-certain-situation./91631\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86619/Simple-Python-solution"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The description of the problem gives solvers a false impression that there is only one top level node, and this node is named \"dir\". It is only after you start testing the code that we run into a testcase like \"dir\\\\nfile.txt\" where both dir and file.txt are at the top-level. Not specifying that something like this is possible in the problem description is not correct, because we have already designed and implemented a solution that does not account for this possiblity. We have to go back to the drawing board and re-design our solution to account for this case."
                    },
                    {
                        "username": "AbhishekBabuji",
                        "content": "Trying to practice BFS but, I bump into these weird test cases that involve tabs and space that have no explanation as to when to include space as a part of the file name and when not to"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "In the thread, you may find complaints on testcases:\\n\\n`dir\\\\n\\\\tfile.txt\\' should have different length from `dir\\\\n...file.txt\\' (here . stays for spaces)\\n(see, for example, https://leetcode.com/problems/longest-absolute-file-path/discuss/86649/What-is-purpose-of-weird-test-cases)\\n\\nBut what about **file system** `text.txt`? I always thought that file system MUST be a folder. Is my opinion wrong?\\n"
                    },
                    {
                        "username": "Gentlemanbug",
                        "content": "Shouldn't \"dir\\\\n        file.txt\" represent \"dir/file.txt\", which has the lenght 12? There are 8 white spaces in the string. It's not displayed properly in the subject."
                    },
                    {
                        "username": "sundarramr",
                        "content": "\"dir\\\\n        file.txt\"\\nexpected output: 16\\n\\nif so how?\\n\\nlook like it has 8 blank space. should we consider it for length?"
                    },
                    {
                        "username": "ahmed",
                        "content": "I know that a stack would solve the problem, but would someone explain the algorithm in plain english and write the code that he explains. I'm very interested to know how to solve that problem."
                    },
                    {
                        "username": "faangboy",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/nightfox21/image_1526685725.png)\\n"
                    }
                ]
            },
            {
                "id": 1571662,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "After many try-and-error, I finally figured out the solution is required to handle the blank spaces in a special way. I think it should be stated in the problem statement, not just let people guess this from the expected answers. This will waste many people a lot of time...."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "then why the fuck didnt u mentioned here the special way instead of just leaving the  readers on a cliffhanger"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "In all the examples, Tab \"\\\\t\" is used instead of Spaces. Several of OJ test cases have spaces in them and you will have to treat spaces separately. When you see 4 spaces, it will count as a tab.\\n\\nAlso, in the problem and examples, every file is nested directly under a directory. However, not all the test cases have this format: \\n\\nFor example: Test Case #14:  \"dir\\\\n________file.txt\" <-- there are 8 spaces under file.txt and the answer is 16 (not 12).\\n\\nThe problem statement really should be more clear. This isn't a fun problem when you invest a lot of time into solving it, only to realize the problem statement and test cases are entirely different."
                    },
                    {
                        "username": "yummy_bloomy",
                        "content": "It was intuitive to us that \\'\\\\t\\' is the indicator of \\'level\\' for a certain line. For example, in the test case dir\\\\n\\\\tsub1\\\\n\\\\t\\\\tfile1.txt, dir = level 0, sub1 = level2, file1.txt = level3\\n\\nBut we got confused by weird test cases and thought that \\'[][][][]\\' four spaces can also be the level indicator. It\\'s not true. Please repeat with me: \\n**\\'\\\\t\\' is the ONE AND ONLY indicator of \\'level\\' for a certain line**.\\n\\nLet\\'s define lines = input.split(\\'\\\\n\\'). For any lines[i], we need to get the level of it to determine its depth in the file structure, and the length of the line (without \\'\\\\t\\') to determine the length of its absolute path. \\n\\nMethod 1\\n**level of line i = lines[i].count(\\'\\\\t\\')**\\n**real length of line i = len(lines[i]) - level of line i** (while it looks like \\'\\\\t\\' takes 2 or 4 spaces, Python only count it as 1 space)\\n\\nMethod 2\\n**real length of line i = len(lines[i].strip(\\'\\\\t\\'))\\nlevel of line i = len(lines[i]) - real length of line i** \\n\\nI guess many of you are making the same mistake as I did, where I used len(lines[i].strip()), which got rid of both tabs and spaces. That led to wrong results of the following test cases, where **spaces are part of the file names**. As they have no \\'\\\\t\\' before them, they are both of level 0, the same level as dir. Therefore, **the file names themselves are the abosulte paths**. \\n\\nExample 1: \"dir\\\\n[][][][]file.txt\", answer = 12\\nExample 2: \"dir\\\\n[][][][][][][][]file.txt\", answer = 16\\n\\nThink about the structures of those examples like (level -1 is fake but you get the idea):\\n\\nExample 1:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][]file.txt\\n\\nExample 2:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][][][][][]file.txt\\n\\t\\nAlso, don\\'t forget to add the count of slashes to your answer.\\n\\nThanks to [@StefanPochmann](https://leetcode.com/stefanpochmann) for clarification, although it took me a while to understand his statement....\\n\\nReference\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86636/This-problem-is-not-well-defined.-It-should-state-that-4-space-is-considered-as-a-TAB-under-certain-situation./91631\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86619/Simple-Python-solution"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The description of the problem gives solvers a false impression that there is only one top level node, and this node is named \"dir\". It is only after you start testing the code that we run into a testcase like \"dir\\\\nfile.txt\" where both dir and file.txt are at the top-level. Not specifying that something like this is possible in the problem description is not correct, because we have already designed and implemented a solution that does not account for this possiblity. We have to go back to the drawing board and re-design our solution to account for this case."
                    },
                    {
                        "username": "AbhishekBabuji",
                        "content": "Trying to practice BFS but, I bump into these weird test cases that involve tabs and space that have no explanation as to when to include space as a part of the file name and when not to"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "In the thread, you may find complaints on testcases:\\n\\n`dir\\\\n\\\\tfile.txt\\' should have different length from `dir\\\\n...file.txt\\' (here . stays for spaces)\\n(see, for example, https://leetcode.com/problems/longest-absolute-file-path/discuss/86649/What-is-purpose-of-weird-test-cases)\\n\\nBut what about **file system** `text.txt`? I always thought that file system MUST be a folder. Is my opinion wrong?\\n"
                    },
                    {
                        "username": "Gentlemanbug",
                        "content": "Shouldn't \"dir\\\\n        file.txt\" represent \"dir/file.txt\", which has the lenght 12? There are 8 white spaces in the string. It's not displayed properly in the subject."
                    },
                    {
                        "username": "sundarramr",
                        "content": "\"dir\\\\n        file.txt\"\\nexpected output: 16\\n\\nif so how?\\n\\nlook like it has 8 blank space. should we consider it for length?"
                    },
                    {
                        "username": "ahmed",
                        "content": "I know that a stack would solve the problem, but would someone explain the algorithm in plain english and write the code that he explains. I'm very interested to know how to solve that problem."
                    },
                    {
                        "username": "faangboy",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/nightfox21/image_1526685725.png)\\n"
                    }
                ]
            },
            {
                "id": 1569219,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "After many try-and-error, I finally figured out the solution is required to handle the blank spaces in a special way. I think it should be stated in the problem statement, not just let people guess this from the expected answers. This will waste many people a lot of time...."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "then why the fuck didnt u mentioned here the special way instead of just leaving the  readers on a cliffhanger"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "In all the examples, Tab \"\\\\t\" is used instead of Spaces. Several of OJ test cases have spaces in them and you will have to treat spaces separately. When you see 4 spaces, it will count as a tab.\\n\\nAlso, in the problem and examples, every file is nested directly under a directory. However, not all the test cases have this format: \\n\\nFor example: Test Case #14:  \"dir\\\\n________file.txt\" <-- there are 8 spaces under file.txt and the answer is 16 (not 12).\\n\\nThe problem statement really should be more clear. This isn't a fun problem when you invest a lot of time into solving it, only to realize the problem statement and test cases are entirely different."
                    },
                    {
                        "username": "yummy_bloomy",
                        "content": "It was intuitive to us that \\'\\\\t\\' is the indicator of \\'level\\' for a certain line. For example, in the test case dir\\\\n\\\\tsub1\\\\n\\\\t\\\\tfile1.txt, dir = level 0, sub1 = level2, file1.txt = level3\\n\\nBut we got confused by weird test cases and thought that \\'[][][][]\\' four spaces can also be the level indicator. It\\'s not true. Please repeat with me: \\n**\\'\\\\t\\' is the ONE AND ONLY indicator of \\'level\\' for a certain line**.\\n\\nLet\\'s define lines = input.split(\\'\\\\n\\'). For any lines[i], we need to get the level of it to determine its depth in the file structure, and the length of the line (without \\'\\\\t\\') to determine the length of its absolute path. \\n\\nMethod 1\\n**level of line i = lines[i].count(\\'\\\\t\\')**\\n**real length of line i = len(lines[i]) - level of line i** (while it looks like \\'\\\\t\\' takes 2 or 4 spaces, Python only count it as 1 space)\\n\\nMethod 2\\n**real length of line i = len(lines[i].strip(\\'\\\\t\\'))\\nlevel of line i = len(lines[i]) - real length of line i** \\n\\nI guess many of you are making the same mistake as I did, where I used len(lines[i].strip()), which got rid of both tabs and spaces. That led to wrong results of the following test cases, where **spaces are part of the file names**. As they have no \\'\\\\t\\' before them, they are both of level 0, the same level as dir. Therefore, **the file names themselves are the abosulte paths**. \\n\\nExample 1: \"dir\\\\n[][][][]file.txt\", answer = 12\\nExample 2: \"dir\\\\n[][][][][][][][]file.txt\", answer = 16\\n\\nThink about the structures of those examples like (level -1 is fake but you get the idea):\\n\\nExample 1:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][]file.txt\\n\\nExample 2:\\n. (some root of level -1)\\n[TAB] dir\\n[TAB] [][][][][][][][]file.txt\\n\\t\\nAlso, don\\'t forget to add the count of slashes to your answer.\\n\\nThanks to [@StefanPochmann](https://leetcode.com/stefanpochmann) for clarification, although it took me a while to understand his statement....\\n\\nReference\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86636/This-problem-is-not-well-defined.-It-should-state-that-4-space-is-considered-as-a-TAB-under-certain-situation./91631\\nhttps://leetcode.com/problems/longest-absolute-file-path/discuss/86619/Simple-Python-solution"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The description of the problem gives solvers a false impression that there is only one top level node, and this node is named \"dir\". It is only after you start testing the code that we run into a testcase like \"dir\\\\nfile.txt\" where both dir and file.txt are at the top-level. Not specifying that something like this is possible in the problem description is not correct, because we have already designed and implemented a solution that does not account for this possiblity. We have to go back to the drawing board and re-design our solution to account for this case."
                    },
                    {
                        "username": "AbhishekBabuji",
                        "content": "Trying to practice BFS but, I bump into these weird test cases that involve tabs and space that have no explanation as to when to include space as a part of the file name and when not to"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "In the thread, you may find complaints on testcases:\\n\\n`dir\\\\n\\\\tfile.txt\\' should have different length from `dir\\\\n...file.txt\\' (here . stays for spaces)\\n(see, for example, https://leetcode.com/problems/longest-absolute-file-path/discuss/86649/What-is-purpose-of-weird-test-cases)\\n\\nBut what about **file system** `text.txt`? I always thought that file system MUST be a folder. Is my opinion wrong?\\n"
                    },
                    {
                        "username": "Gentlemanbug",
                        "content": "Shouldn't \"dir\\\\n        file.txt\" represent \"dir/file.txt\", which has the lenght 12? There are 8 white spaces in the string. It's not displayed properly in the subject."
                    },
                    {
                        "username": "sundarramr",
                        "content": "\"dir\\\\n        file.txt\"\\nexpected output: 16\\n\\nif so how?\\n\\nlook like it has 8 blank space. should we consider it for length?"
                    },
                    {
                        "username": "ahmed",
                        "content": "I know that a stack would solve the problem, but would someone explain the algorithm in plain english and write the code that he explains. I'm very interested to know how to solve that problem."
                    },
                    {
                        "username": "faangboy",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/nightfox21/image_1526685725.png)\\n"
                    }
                ]
            }
        ]
    }
]