[
    {
        "title": "Rotting Oranges",
        "question_content": "You are given an m x n grid where each cell can have one of three values:\n\n\t0 representing an empty cell,\n\t1 representing a fresh orange, or\n\t2 representing a rotten orange.\n\nEvery minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.\n&nbsp;\nExample 1:\n\nInput: grid = [[2,1,1],[1,1,0],[0,1,1]]\nOutput: 4\n\nExample 2:\n\nInput: grid = [[2,1,1],[0,1,1],[1,0,1]]\nOutput: -1\nExplanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.\n\nExample 3:\n\nInput: grid = [[0,2]]\nOutput: 0\nExplanation: Since there are already no fresh oranges at minute 0, the answer is just 0.\n\n&nbsp;\nConstraints:\n\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 10\n\tgrid[i][j] is 0, 1, or 2.",
        "solutions": [
            {
                "id": 563686,
                "title": "python-clean-well-explained-faster-than-90",
                "content": "```\\nfrom collections import deque\\n\\n# Time complexity: O(rows * cols) -> each cell is visited at least once\\n# Space complexity: O(rows * cols) -> in the worst case if all the oranges are rotten they will be added to the queue\\n\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        # number of rows\\n        rows = len(grid)\\n        if rows == 0:  # check if grid is empty\\n            return -1\\n        \\n        # number of columns\\n        cols = len(grid[0])\\n        \\n        # keep track of fresh oranges\\n        fresh_cnt = 0\\n        \\n        # queue with rotten oranges (for BFS)\\n        rotten = deque()\\n        \\n        # visit each cell in the grid\\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == 2:\\n                    # add the rotten orange coordinates to the queue\\n                    rotten.append((r, c))\\n                elif grid[r][c] == 1:\\n                    # update fresh oranges count\\n                    fresh_cnt += 1\\n        \\n        # keep track of minutes passed.\\n        minutes_passed = 0\\n        \\n        # If there are rotten oranges in the queue and there are still fresh oranges in the grid keep looping\\n        while rotten and fresh_cnt > 0:\\n\\n            # update the number of minutes passed\\n            # it is safe to update the minutes by 1, since we visit oranges level by level in BFS traversal.\\n            minutes_passed += 1\\n            \\n            # process rotten oranges on the current level\\n            for _ in range(len(rotten)):\\n                x, y = rotten.popleft()\\n                \\n                # visit all the adjacent cells\\n                for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:\\n                    # calculate the coordinates of the adjacent cell\\n                    xx, yy = x + dx, y + dy\\n                    # ignore the cell if it is out of the grid boundary\\n                    if xx < 0 or xx == rows or yy < 0 or yy == cols:\\n                        continue\\n                    # ignore the cell if it is empty \\'0\\' or visited before \\'2\\'\\n                    if grid[xx][yy] == 0 or grid[xx][yy] == 2:\\n                        continue\\n                        \\n                    # update the fresh oranges count\\n                    fresh_cnt -= 1\\n                    \\n                    # mark the current fresh orange as rotten\\n                    grid[xx][yy] = 2\\n                    \\n                    # add the current rotten to the queue\\n                    rotten.append((xx, yy))\\n\\n        \\n        # return the number of minutes taken to make all the fresh oranges to be rotten\\n        # return -1 if there are fresh oranges left in the grid (there were no adjacent rotten oranges to make them rotten)\\n        return minutes_passed if fresh_cnt == 0 else -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\n\\n# Time complexity: O(rows * cols) -> each cell is visited at least once\\n# Space complexity: O(rows * cols) -> in the worst case if all the oranges are rotten they will be added to the queue\\n\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        # number of rows\\n        rows = len(grid)\\n        if rows == 0:  # check if grid is empty\\n            return -1\\n        \\n        # number of columns\\n        cols = len(grid[0])\\n        \\n        # keep track of fresh oranges\\n        fresh_cnt = 0\\n        \\n        # queue with rotten oranges (for BFS)\\n        rotten = deque()\\n        \\n        # visit each cell in the grid\\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == 2:\\n                    # add the rotten orange coordinates to the queue\\n                    rotten.append((r, c))\\n                elif grid[r][c] == 1:\\n                    # update fresh oranges count\\n                    fresh_cnt += 1\\n        \\n        # keep track of minutes passed.\\n        minutes_passed = 0\\n        \\n        # If there are rotten oranges in the queue and there are still fresh oranges in the grid keep looping\\n        while rotten and fresh_cnt > 0:\\n\\n            # update the number of minutes passed\\n            # it is safe to update the minutes by 1, since we visit oranges level by level in BFS traversal.\\n            minutes_passed += 1\\n            \\n            # process rotten oranges on the current level\\n            for _ in range(len(rotten)):\\n                x, y = rotten.popleft()\\n                \\n                # visit all the adjacent cells\\n                for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:\\n                    # calculate the coordinates of the adjacent cell\\n                    xx, yy = x + dx, y + dy\\n                    # ignore the cell if it is out of the grid boundary\\n                    if xx < 0 or xx == rows or yy < 0 or yy == cols:\\n                        continue\\n                    # ignore the cell if it is empty \\'0\\' or visited before \\'2\\'\\n                    if grid[xx][yy] == 0 or grid[xx][yy] == 2:\\n                        continue\\n                        \\n                    # update the fresh oranges count\\n                    fresh_cnt -= 1\\n                    \\n                    # mark the current fresh orange as rotten\\n                    grid[xx][yy] = 2\\n                    \\n                    # add the current rotten to the queue\\n                    rotten.append((xx, yy))\\n\\n        \\n        # return the number of minutes taken to make all the fresh oranges to be rotten\\n        # return -1 if there are fresh oranges left in the grid (there were no adjacent rotten oranges to make them rotten)\\n        return minutes_passed if fresh_cnt == 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238681,
                "title": "java-clean-bfs-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        if(grid == null || grid.length == 0) return 0;\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        Queue<int[]> queue = new LinkedList<>();\\n        int count_fresh = 0;\\n        //Put the position of all rotten oranges in queue\\n        //count the number of fresh oranges\\n        for(int i = 0 ; i < rows ; i++) {\\n            for(int j = 0 ; j < cols ; j++) {\\n                if(grid[i][j] == 2) {\\n                    queue.offer(new int[]{i , j});\\n                }\\n                else if(grid[i][j] == 1) {\\n                    count_fresh++;\\n                }\\n            }\\n        }\\n        //if count of fresh oranges is zero --> return 0 \\n        if(count_fresh == 0) return 0;\\n        int count = 0;\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n        //bfs starting from initially rotten oranges\\n        while(!queue.isEmpty()) {\\n            ++count;\\n            int size = queue.size();\\n            for(int i = 0 ; i < size ; i++) {\\n                int[] point = queue.poll();\\n                for(int dir[] : dirs) {\\n                    int x = point[0] + dir[0];\\n                    int y = point[1] + dir[1];\\n                    //if x or y is out of bound\\n                    //or the orange at (x , y) is already rotten\\n                    //or the cell at (x , y) is empty\\n                        //we do nothing\\n                    if(x < 0 || y < 0 || x >= rows || y >= cols || grid[x][y] == 0 || grid[x][y] == 2) continue;\\n                    //mark the orange at (x , y) as rotten\\n                    grid[x][y] = 2;\\n                    //put the new rotten orange at (x , y) in queue\\n                    queue.offer(new int[]{x , y});\\n                    //decrease the count of fresh oranges by 1\\n                    count_fresh--;\\n                }\\n            }\\n        }\\n        return count_fresh == 0 ? count-1 : -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        if(grid == null || grid.length == 0) return 0;\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        Queue<int[]> queue = new LinkedList<>();\\n        int count_fresh = 0;\\n        //Put the position of all rotten oranges in queue\\n        //count the number of fresh oranges\\n        for(int i = 0 ; i < rows ; i++) {\\n            for(int j = 0 ; j < cols ; j++) {\\n                if(grid[i][j] == 2) {\\n                    queue.offer(new int[]{i , j});\\n                }\\n                else if(grid[i][j] == 1) {\\n                    count_fresh++;\\n                }\\n            }\\n        }\\n        //if count of fresh oranges is zero --> return 0 \\n        if(count_fresh == 0) return 0;\\n        int count = 0;\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n        //bfs starting from initially rotten oranges\\n        while(!queue.isEmpty()) {\\n            ++count;\\n            int size = queue.size();\\n            for(int i = 0 ; i < size ; i++) {\\n                int[] point = queue.poll();\\n                for(int dir[] : dirs) {\\n                    int x = point[0] + dir[0];\\n                    int y = point[1] + dir[1];\\n                    //if x or y is out of bound\\n                    //or the orange at (x , y) is already rotten\\n                    //or the cell at (x , y) is empty\\n                        //we do nothing\\n                    if(x < 0 || y < 0 || x >= rows || y >= cols || grid[x][y] == 0 || grid[x][y] == 2) continue;\\n                    //mark the orange at (x , y) as rotten\\n                    grid[x][y] = 2;\\n                    //put the new rotten orange at (x , y) in queue\\n                    queue.offer(new int[]{x , y});\\n                    //decrease the count of fresh oranges by 1\\n                    count_fresh--;\\n                }\\n            }\\n        }\\n        return count_fresh == 0 ? count-1 : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588024,
                "title": "c-bfs-100-space-95-time-explanation-of-logic",
                "content": "The trick is to start bfs from all initial rotten oranges simultaneously to get minimum time, this way any oranges that can get rotten due to more than 1 initially rotten oranges will be covered by the nearest one.\\n\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) \\n    {\\n        \\n        vector<int> dir={-1,0,1,0,-1}; //used for finding all 4 adjacent coordinates\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        queue<pair<int,int>> q;\\n        int fresh=0; //To keep track of all fresh oranges left\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==2)\\n                    q.push({i,j});\\n                if(grid[i][j]==1)\\n                    fresh++;\\n            }\\n        int ans=-1; //initialised to -1 since after each step we increment the time by 1 and initially all rotten oranges started at 0.\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                pair<int,int> p=q.front();\\n                q.pop();\\n                for(int i=0;i<4;i++)\\n                {\\n                    int r=p.first+dir[i];\\n                    int c=p.second+dir[i+1];\\n                    if(r>=0 && r<m && c>=0 && c<n &&grid[r][c]==1)\\n                    {\\n                        grid[r][c]=2;\\n                        q.push({r,c});\\n                        fresh--; // decrement by 1 foreach fresh orange that now is rotten\\n                    }\\n                    \\n                }\\n            }\\n            ans++; //incremented after each minute passes\\n        }\\n        if(fresh>0) return -1; //if fresh>0 that means there are fresh oranges left\\n        if(ans==-1) return 0; //we initialised with -1, so if there were no oranges it\\'d take 0 mins.\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nPlease upvote if you like the solution and explanation.",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) \\n    {\\n        \\n        vector<int> dir={-1,0,1,0,-1}; //used for finding all 4 adjacent coordinates\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        queue<pair<int,int>> q;\\n        int fresh=0; //To keep track of all fresh oranges left\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==2)\\n                    q.push({i,j});\\n                if(grid[i][j]==1)\\n                    fresh++;\\n            }\\n        int ans=-1; //initialised to -1 since after each step we increment the time by 1 and initially all rotten oranges started at 0.\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                pair<int,int> p=q.front();\\n                q.pop();\\n                for(int i=0;i<4;i++)\\n                {\\n                    int r=p.first+dir[i];\\n                    int c=p.second+dir[i+1];\\n                    if(r>=0 && r<m && c>=0 && c<n &&grid[r][c]==1)\\n                    {\\n                        grid[r][c]=2;\\n                        q.push({r,c});\\n                        fresh--; // decrement by 1 foreach fresh orange that now is rotten\\n                    }\\n                    \\n                }\\n            }\\n            ans++; //incremented after each minute passes\\n        }\\n        if(fresh>0) return -1; //if fresh>0 that means there are fresh oranges left\\n        if(ans==-1) return 0; //we initialised with -1, so if there were no oranges it\\'d take 0 mins.\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 602284,
                "title": "java-dfs-beats-100",
                "content": "Posting this here since I couldn\\'t find a DFS solution in discussions\\n\\n```\\nclass Solution {\\n    \\n    public int orangesRotting(int[][] grid) {\\n        if(grid == null || grid.length == 0) return -1;\\n        \\n        for(int i=0; i<grid.length; i++) {\\n            for(int j=0; j<grid[0].length; j++) {\\n                if(grid[i][j] == 2) rotAdjacent(grid, i, j, 2);\\n            }\\n        }\\n        \\n        int minutes = 2;\\n        for(int[] row : grid) {\\n            for(int cell : row) {\\n                if(cell == 1) return -1;\\n                minutes = Math.max(minutes, cell);\\n            }\\n        }\\n        \\n        return minutes - 2;\\n    }\\n    \\n    private void rotAdjacent(int[][] grid, int i, int j, int minutes) {\\n        if(i < 0 || i >= grid.length /* out of bounds */\\n          || j < 0 || j >= grid[0].length /* out of bounds */\\n          || grid[i][j] == 0 /* empty cell */\\n          || (1 < grid[i][j] && grid[i][j] < minutes) /* this orange is already rotten by another rotten orange */\\n          ) return;\\n        else {\\n            grid[i][j] = minutes;\\n            rotAdjacent(grid, i - 1, j, minutes + 1);\\n            rotAdjacent(grid, i + 1, j, minutes + 1);\\n            rotAdjacent(grid, i, j - 1, minutes + 1);\\n            rotAdjacent(grid, i, j + 1, minutes + 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int orangesRotting(int[][] grid) {\\n        if(grid == null || grid.length == 0) return -1;\\n        \\n        for(int i=0; i<grid.length; i++) {\\n            for(int j=0; j<grid[0].length; j++) {\\n                if(grid[i][j] == 2) rotAdjacent(grid, i, j, 2);\\n            }\\n        }\\n        \\n        int minutes = 2;\\n        for(int[] row : grid) {\\n            for(int cell : row) {\\n                if(cell == 1) return -1;\\n                minutes = Math.max(minutes, cell);\\n            }\\n        }\\n        \\n        return minutes - 2;\\n    }\\n    \\n    private void rotAdjacent(int[][] grid, int i, int j, int minutes) {\\n        if(i < 0 || i >= grid.length /* out of bounds */\\n          || j < 0 || j >= grid[0].length /* out of bounds */\\n          || grid[i][j] == 0 /* empty cell */\\n          || (1 < grid[i][j] && grid[i][j] < minutes) /* this orange is already rotten by another rotten orange */\\n          ) return;\\n        else {\\n            grid[i][j] = minutes;\\n            rotAdjacent(grid, i - 1, j, minutes + 1);\\n            rotAdjacent(grid, i + 1, j, minutes + 1);\\n            rotAdjacent(grid, i, j - 1, minutes + 1);\\n            rotAdjacent(grid, i, j + 1, minutes + 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238579,
                "title": "c-java-with-picture-bfs",
                "content": "First, count ```fresh``` oranges. Then, until ```fresh``` is non-zero, perform BFS to rot oranges, decreasing ```fresh```. Count days (```d```) and return it in the end. If, after another day, ```fresh``` does not change, return ```-1```.\\n\\nFor BFS, we can use the day counter (```d + 2```) to only process oranges that rotted yesterday.\\n\\n![image](https://assets.leetcode.com/users/votrubac/image_1550377228.png)\\n```\\nint rot(vector<vector<int>>& g, int i, int j, int d) {\\n  if (i < 0 || j < 0 || i >= g.size() || j >= g[i].size() || g[i][j] != 1) return 0;\\n  g[i][j] = d + 3;\\n  return 1;\\n}\\nint orangesRotting(vector<vector<int>>& g, int d = 0, int fresh = 0) {\\n  for (auto i = 0; i < g.size(); ++i) \\n    fresh += count_if(begin(g[i]), end(g[i]), [](int j) { return j == 1; });\\n  for (auto old_fresh = fresh; fresh > 0; ++d) {\\n    for (auto i = 0; i < g.size(); ++i)\\n      for (auto j = 0; j < g[i].size(); ++j)\\n        if (g[i][j] == d + 2)\\n          fresh -= rot(g,i+1,j,d) + rot(g,i-1,j,d) + rot(g,i,j+1,d) + rot(g,i,j-1,d);\\n    if (fresh == exchange(old_fresh, fresh)) return -1;\\n  }\\n  return d;\\n}\\n```\\nJava version:\\n```\\nprivate int rot(int[][] g, int i, int j, int d) {\\n  if (i < 0 || j < 0 || i >= g.length || j >= g[i].length || g[i][j] != 1) return 0;\\n  g[i][j] = d + 3;\\n  return 1;\\n}\\npublic int orangesRotting(int[][] g) {\\n  int fresh = 0, d = 0;\\n  for (int i = 0; i < g.length; ++i)\\n    for (int j = 0; j < g[i].length; ++j)\\n      if (g[i][j] == 1) ++fresh;\\n  for (int old_fresh = fresh; fresh > 0; ++d, old_fresh = fresh) {\\n    for (int i = 0; i < g.length; ++i)\\n      for (int j = 0; j < g[i].length; ++j)\\n        if (g[i][j] == d + 2)\\n          fresh -= rot(g, i + 1, j, d) + rot(g, i - 1, j, d) + rot(g, i, j + 1, d) + rot(g, i, j - 1, d);\\n    if (fresh == old_fresh) return -1;\\n  }\\n  return d;\\n}\\n```\\n## Complexity Analysis\\n**Time**: *O(h * w * (h + w))*, where ```h``` and ```w``` are the dimension of the grid. We are scanning *h + w* times (maximum distance between two cells) through all grid cells.\\n**Memory:** O(1).",
                "solutionTags": [],
                "code": "```fresh```\n```fresh```\n```fresh```\n```d```\n```fresh```\n```-1```\n```d + 2```\n```\\nint rot(vector<vector<int>>& g, int i, int j, int d) {\\n  if (i < 0 || j < 0 || i >= g.size() || j >= g[i].size() || g[i][j] != 1) return 0;\\n  g[i][j] = d + 3;\\n  return 1;\\n}\\nint orangesRotting(vector<vector<int>>& g, int d = 0, int fresh = 0) {\\n  for (auto i = 0; i < g.size(); ++i) \\n    fresh += count_if(begin(g[i]), end(g[i]), [](int j) { return j == 1; });\\n  for (auto old_fresh = fresh; fresh > 0; ++d) {\\n    for (auto i = 0; i < g.size(); ++i)\\n      for (auto j = 0; j < g[i].size(); ++j)\\n        if (g[i][j] == d + 2)\\n          fresh -= rot(g,i+1,j,d) + rot(g,i-1,j,d) + rot(g,i,j+1,d) + rot(g,i,j-1,d);\\n    if (fresh == exchange(old_fresh, fresh)) return -1;\\n  }\\n  return d;\\n}\\n```\n```\\nprivate int rot(int[][] g, int i, int j, int d) {\\n  if (i < 0 || j < 0 || i >= g.length || j >= g[i].length || g[i][j] != 1) return 0;\\n  g[i][j] = d + 3;\\n  return 1;\\n}\\npublic int orangesRotting(int[][] g) {\\n  int fresh = 0, d = 0;\\n  for (int i = 0; i < g.length; ++i)\\n    for (int j = 0; j < g[i].length; ++j)\\n      if (g[i][j] == 1) ++fresh;\\n  for (int old_fresh = fresh; fresh > 0; ++d, old_fresh = fresh) {\\n    for (int i = 0; i < g.length; ++i)\\n      for (int j = 0; j < g[i].length; ++j)\\n        if (g[i][j] == d + 2)\\n          fresh -= rot(g, i + 1, j, d) + rot(g, i - 1, j, d) + rot(g, i, j + 1, d) + rot(g, i, j - 1, d);\\n    if (fresh == old_fresh) return -1;\\n  }\\n  return d;\\n}\\n```\n```h```\n```w```",
                "codeTag": "Unknown"
            },
            {
                "id": 388104,
                "title": "python-10-lines-bfs-beat-97",
                "content": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        row, col = len(grid), len(grid[0])\\n        rotting = {(i, j) for i in range(row) for j in range(col) if grid[i][j] == 2}\\n        fresh = {(i, j) for i in range(row) for j in range(col) if grid[i][j] == 1}\\n        timer = 0\\n        while fresh:\\n            if not rotting: return -1\\n            rotting = {(i+di, j+dj) for i, j in rotting for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)] if (i+di, j+dj) in fresh}\\n            fresh -= rotting\\n            timer += 1\\n        return timer\\n```\\nThis is why I love coding in Python ;)",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        row, col = len(grid), len(grid[0])\\n        rotting = {(i, j) for i in range(row) for j in range(col) if grid[i][j] == 2}\\n        fresh = {(i, j) for i in range(row) for j in range(col) if grid[i][j] == 1}\\n        timer = 0\\n        while fresh:\\n            if not rotting: return -1\\n            rotting = {(i+di, j+dj) for i, j in rotting for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)] if (i+di, j+dj) in fresh}\\n            fresh -= rotting\\n            timer += 1\\n        return timer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166554,
                "title": "c-bfs-easiest-beginner-friendly-sol-o-n-2-time-and-o-n-2-space",
                "content": "# Intuition of this Problem:\\nSame type of bfs approach will work as shown in below picture.\\n![image.png](https://assets.leetcode.com/users/images/07344800-1fe0-437c-9914-35050cbc7646_1676003575.8403783.png)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Create a visited grid to store the state of the cell (fresh, rotten, or empty).\\n2. Initialize a queue to store the rotten oranges and count the number of fresh oranges.\\n3. Check if there are no fresh oranges, return 0, or if there are no rotten oranges, return -1.\\n4. Loop while the queue is not empty.\\n    - a. Store the size of the queue.\\n    - b. Loop through the size of the queue.\\n        - i. Get the front cell of the queue.\\n        - ii. Check all four directions of the cell to see if there are any fresh oranges.\\n        - iii. If there is a fresh orange, change its state to rotten and decrement the count of fresh oranges, and push the cell into the queue.\\n    - c. Increment the minutes.\\n1. If there are no fresh oranges, return the minutes.\\n2. If there are still fresh oranges, return -1.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> visited = grid;\\n        //making queue in which we will fill rotten oranges\\n        queue<pair<int, int>> q;\\n        int countFreshOrange = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (visited[i][j] == 2) {\\n                    q.push({i, j});\\n                }\\n                if (visited[i][j] == 1) {\\n                    countFreshOrange++;\\n                }\\n            }\\n        }\\n        //q.empty() means there is no rotten orange in the grid and countFreshOrange = 0 means we will rotten the freshoranges in 0 mins\\n        if (countFreshOrange == 0)\\n            return 0;\\n        if (q.empty())\\n            return -1;\\n        \\n        int minutes = -1;\\n        // we will cover four directions i.e. up, down, left, right\\n        vector<pair<int, int>> dirs = {{1, 0},{-1, 0},{0, -1},{0, 1}};\\n        while (!q.empty()) {\\n            int size = q.size();\\n            while (size--) {\\n                auto [x, y] = q.front();\\n                q.pop();\\n                for (auto [dx, dy] : dirs) {\\n                    int i = x + dx;\\n                    int j = y + dy;\\n                    if (i >= 0 && i < m && j >= 0 && j < n && visited[i][j] == 1) {\\n                        visited[i][j] = 2;\\n                        countFreshOrange--;\\n                        q.push({i, j});\\n                    }\\n                }\\n            }\\n            minutes++;\\n        }\\n        \\n        if (countFreshOrange == 0)\\n            return minutes;\\n        return -1;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] visited = grid;\\n        Queue<int[]> q = new LinkedList<>();\\n        int countFreshOrange = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (visited[i][j] == 2) {\\n                    q.offer(new int[] {i, j});\\n                }\\n                if (visited[i][j] == 1) {\\n                    countFreshOrange++;\\n                }\\n            }\\n        }\\n        if (countFreshOrange == 0)\\n            return 0;\\n        if (q.isEmpty())\\n            return -1;\\n        \\n        int minutes = -1;\\n        int[][] dirs = {{1, 0},{-1, 0},{0, -1},{0, 1}};\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            while (size-- > 0) {\\n                int[] cell = q.poll();\\n                int x = cell[0];\\n                int y = cell[1];\\n                for (int[] dir : dirs) {\\n                    int i = x + dir[0];\\n                    int j = y + dir[1];\\n                    if (i >= 0 && i < m && j >= 0 && j < n && visited[i][j] == 1) {\\n                        visited[i][j] = 2;\\n                        countFreshOrange--;\\n                        q.offer(new int[] {i, j});\\n                    }\\n                }\\n            }\\n            minutes++;\\n        }\\n        \\n        if (countFreshOrange == 0)\\n            return minutes;\\n        return -1;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        visited = grid\\n        q = collections.deque()\\n        countFreshOrange = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if visited[i][j] == 2:\\n                    q.append((i, j))\\n                if visited[i][j] == 1:\\n                    countFreshOrange += 1\\n        if countFreshOrange == 0:\\n            return 0\\n        if not q:\\n            return -1\\n        \\n        minutes = -1\\n        dirs = [(1, 0), (-1, 0), (0, -1), (0, 1)]\\n        while q:\\n            size = len(q)\\n            while size > 0:\\n                x, y = q.popleft()\\n                size -= 1\\n                for dx, dy in dirs:\\n                    i, j = x + dx, y + dy\\n                    if 0 <= i < m and 0 <= j < n and visited[i][j] == 1:\\n                        visited[i][j] = 2\\n                        countFreshOrange -= 1\\n                        q.append((i, j))\\n            minutes += 1\\n        \\n        if countFreshOrange == 0:\\n            return minutes\\n        return -1\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(m*n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(m*n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Similar Pattern Problems:\\n1162. As Far from Land as Possible - https://leetcode.com/problems/as-far-from-land-as-possible/description/\\n317. Shortest Distance from All Buildings - https://leetcode.com/problems/shortest-distance-from-all-buildings/description/",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> visited = grid;\\n        //making queue in which we will fill rotten oranges\\n        queue<pair<int, int>> q;\\n        int countFreshOrange = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (visited[i][j] == 2) {\\n                    q.push({i, j});\\n                }\\n                if (visited[i][j] == 1) {\\n                    countFreshOrange++;\\n                }\\n            }\\n        }\\n        //q.empty() means there is no rotten orange in the grid and countFreshOrange = 0 means we will rotten the freshoranges in 0 mins\\n        if (countFreshOrange == 0)\\n            return 0;\\n        if (q.empty())\\n            return -1;\\n        \\n        int minutes = -1;\\n        // we will cover four directions i.e. up, down, left, right\\n        vector<pair<int, int>> dirs = {{1, 0},{-1, 0},{0, -1},{0, 1}};\\n        while (!q.empty()) {\\n            int size = q.size();\\n            while (size--) {\\n                auto [x, y] = q.front();\\n                q.pop();\\n                for (auto [dx, dy] : dirs) {\\n                    int i = x + dx;\\n                    int j = y + dy;\\n                    if (i >= 0 && i < m && j >= 0 && j < n && visited[i][j] == 1) {\\n                        visited[i][j] = 2;\\n                        countFreshOrange--;\\n                        q.push({i, j});\\n                    }\\n                }\\n            }\\n            minutes++;\\n        }\\n        \\n        if (countFreshOrange == 0)\\n            return minutes;\\n        return -1;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] visited = grid;\\n        Queue<int[]> q = new LinkedList<>();\\n        int countFreshOrange = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (visited[i][j] == 2) {\\n                    q.offer(new int[] {i, j});\\n                }\\n                if (visited[i][j] == 1) {\\n                    countFreshOrange++;\\n                }\\n            }\\n        }\\n        if (countFreshOrange == 0)\\n            return 0;\\n        if (q.isEmpty())\\n            return -1;\\n        \\n        int minutes = -1;\\n        int[][] dirs = {{1, 0},{-1, 0},{0, -1},{0, 1}};\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            while (size-- > 0) {\\n                int[] cell = q.poll();\\n                int x = cell[0];\\n                int y = cell[1];\\n                for (int[] dir : dirs) {\\n                    int i = x + dir[0];\\n                    int j = y + dir[1];\\n                    if (i >= 0 && i < m && j >= 0 && j < n && visited[i][j] == 1) {\\n                        visited[i][j] = 2;\\n                        countFreshOrange--;\\n                        q.offer(new int[] {i, j});\\n                    }\\n                }\\n            }\\n            minutes++;\\n        }\\n        \\n        if (countFreshOrange == 0)\\n            return minutes;\\n        return -1;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        visited = grid\\n        q = collections.deque()\\n        countFreshOrange = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if visited[i][j] == 2:\\n                    q.append((i, j))\\n                if visited[i][j] == 1:\\n                    countFreshOrange += 1\\n        if countFreshOrange == 0:\\n            return 0\\n        if not q:\\n            return -1\\n        \\n        minutes = -1\\n        dirs = [(1, 0), (-1, 0), (0, -1), (0, 1)]\\n        while q:\\n            size = len(q)\\n            while size > 0:\\n                x, y = q.popleft()\\n                size -= 1\\n                for dx, dy in dirs:\\n                    i, j = x + dx, y + dy\\n                    if 0 <= i < m and 0 <= j < n and visited[i][j] == 1:\\n                        visited[i][j] = 2\\n                        countFreshOrange -= 1\\n                        q.append((i, j))\\n            minutes += 1\\n        \\n        if countFreshOrange == 0:\\n            return minutes\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781642,
                "title": "python-clean-bfs-solution-explained",
                "content": "This is graph traversal problem, so here we have a choise: to use `dfs` or to use `bfs`. What is asked: minimum number of minutes passed until there is no fresh orange. In graphs it means to find the greatest distance from rotten oranges to any other orange. Usually, if we need to find the distances, we use `bfs`. So, let me define my variables:\\n\\n1. `m` and `n` are dimensions of our `grid`, also we have `queue` to run our `bfs` and also we want to count number of fresh oranges: we need this to check in the end if all oranges become rotten or not.\\n2. We put all rotten oranges coordinates to our `queue`, so we are going to start from all of them. Also we count number of fresh oranges.\\n3. Define directions we can go: four of them and put `levels = 0`.\\n\\nNow, we traverse our `grid`, using `bfs`, using level by level traversal: it means, that each time, when we have some elements in `queue`, we popleft all of them and put new neighbours to the end. In this way each time we reach line `levels += 1`, we have nodes with distance which is `1` bigger than previous level. In the end `levels - 1` will be our answer, because one time in the end when we do not have anythin to add, `levels` still be incremented by one.\\n\\nFinally, we check if we still have fresh oranges, and if yes, return `-1`. If not, we need to return `max(levels-1, 0)`, because it can happen, that our queue was empty in the beginning and we do not need to subtract `1`.\\n\\n**Complexity**: time complexity is `O(mn)`, because we first traverse our grid to fill `queue` and found number of fresh oranges. Then we use classical `bfs`, so each node will be added and removed from `queue` at most `1` time. Space complexity is also can be `O(mn)`, we can have for example `O(mn)` rotten oranges in the very beginnig.\\n\\n```\\nclass Solution:\\n    def orangesRotting(self, grid):\\n        m, n, queue, fresh = len(grid), len(grid[0]), deque(), 0\\n        for i,j in product(range(m), range(n)):\\n            if grid[i][j] == 2: queue.append((i,j))\\n            if grid[i][j] == 1: fresh += 1\\n        dirs = [[1,0],[-1,0],[0,1],[0,-1]]\\n        levels = 0\\n        \\n        while queue:\\n            levels += 1\\n            for _ in range(len(queue)):\\n                x, y = queue.popleft()\\n                for dx, dy in dirs:\\n                    if 0<=x+dx<m and 0<=y+dy<n and grid[x+dx][y+dy] == 1:\\n                        fresh -= 1\\n                        grid[x+dx][y+dy] = 2\\n                        queue.append((x+dx, y+dy))\\n                        \\n        return -1 if fresh != 0 else max(levels-1, 0)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def orangesRotting(self, grid):\\n        m, n, queue, fresh = len(grid), len(grid[0]), deque(), 0\\n        for i,j in product(range(m), range(n)):\\n            if grid[i][j] == 2: queue.append((i,j))\\n            if grid[i][j] == 1: fresh += 1\\n        dirs = [[1,0],[-1,0],[0,1],[0,-1]]\\n        levels = 0\\n        \\n        while queue:\\n            levels += 1\\n            for _ in range(len(queue)):\\n                x, y = queue.popleft()\\n                for dx, dy in dirs:\\n                    if 0<=x+dx<m and 0<=y+dy<n and grid[x+dx][y+dy] == 1:\\n                        fresh -= 1\\n                        grid[x+dx][y+dy] = 2\\n                        queue.append((x+dx, y+dy))\\n                        \\n        return -1 if fresh != 0 else max(levels-1, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238540,
                "title": "python-simple-bfs-solution",
                "content": "simple bfs solution use `all` rotten orange as start position\\n\\nmoreover, I use `cnt` to count the number of `1`, when one fresh orange become rotten orange, `cnt -= 1` ,and once bfs over, the `cnt` should be `0`.\\n\\n```python\\nclass Solution(object):\\n    def orangesRotting(self, grid):\\n        n,m = len(grid), len(grid[0])\\n        Q = collections.deque([])\\n        cnt = 0\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == 1: cnt += 1\\n                if grid[i][j] == 2: Q.append((i,j))\\n        res = 0\\n        while Q:\\n            for _ in range(len(Q)):\\n                i,j = Q.popleft()\\n                for x, y in [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]:\\n                    if 0<=x<n and 0<=y<m and grid[x][y] == 1:\\n                        grid[x][y] = 2\\n                        cnt -= 1\\n                        Q.append((x,y))\\n            res += 1\\n        return max(0, res-1) if cnt == 0 else -1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def orangesRotting(self, grid):\\n        n,m = len(grid), len(grid[0])\\n        Q = collections.deque([])\\n        cnt = 0\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == 1: cnt += 1\\n                if grid[i][j] == 2: Q.append((i,j))\\n        res = 0\\n        while Q:\\n            for _ in range(len(Q)):\\n                i,j = Q.popleft()\\n                for x, y in [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]:\\n                    if 0<=x<n and 0<=y<m and grid[x][y] == 1:\\n                        grid[x][y] = 2\\n                        cnt -= 1\\n                        Q.append((x,y))\\n            res += 1\\n        return max(0, res-1) if cnt == 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304875,
                "title": "java-awesome-bfs-solution-very-easy-to-understand",
                "content": "Firstly, we traverse the whole grid to find out the positions of rotten oranges and compute the total num of orange as well, enqueue the positions of rotten oranges into a queue;\\nSecondly, dequeue to get the position of a rotten orange. Due to the infection, the fresh oranges near the rotten orange become rotten. So we check the cell in the left/right/top/down of the rotten orange, if it is a fresh orange, enqueue it. Continue to dequeue until all rotten oranges of last round are removed from the queue\\n\\nHere are the code\\n```java\\nclass Solution {\\n    // store the position of rotten orange\\n    static class Position {\\n        int x;\\n        int y;\\n        Position(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n\\t\\n    public int orangesRotting(int[][] grid) {\\n        Queue<Position> q = new LinkedList<>();\\n        int total = 0, rotten = 0, time = 0;\\n\\t\\t\\n\\t\\t// traverse the grid, offer position of rotten orange into queue, and count the total num of orange\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1 || grid[i][j] == 2) total++;\\n                if (grid[i][j] == 2) q.offer(new Position(i, j));\\n            }\\n        }\\n\\t\\t\\n\\t\\t// if there is no orange, return 0;\\n        if (total == 0) return 0;\\n\\t\\t\\n        while (! q.isEmpty() && rotten < total) {\\n\\t\\t\\t// size is the num of rotten oranges of the last round\\n            int size = q.size();\\n\\t\\t\\t\\n\\t\\t\\t// count the num of rotten oranges, if it equals to total num, return time;\\n            rotten += size;\\n            if (rotten == total) return time;\\n\\t\\t\\t\\n\\t\\t\\t// every round, time ++\\n            time++;\\n\\t\\t\\t\\n\\t\\t\\t// Continue to dequeue until all rotten oranges of last round are removed from the queue\\n            for (int i = 0; i < size; i++) {\\n                Position p = q.peek();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// check the cell in the left/right/top/down of the rotten orange, if it is a fresh orange, enqueue it.\\n                if (p.x + 1 < grid.length && grid[p.x + 1][p.y] == 1) {\\n                    grid[p.x + 1][p.y] = 2;\\n                    q.offer(new Position(p.x + 1, p.y));\\n                }\\n                if (p.x - 1 >= 0 && grid[p.x - 1][p.y] == 1) {\\n                    grid[p.x - 1][p.y] = 2;\\n                    q.offer(new Position(p.x - 1, p.y));\\n                }\\n                if (p.y + 1 < grid[0].length && grid[p.x][p.y + 1] == 1) {\\n                    grid[p.x][p.y + 1] = 2;\\n                    q.offer(new Position(p.x, p.y + 1));\\n                }\\n                if (p.y - 1 >= 0 && grid[p.x][p.y - 1] == 1) {\\n                    grid[p.x][p.y - 1] = 2;\\n                    q.offer(new Position(p.x, p.y - 1));\\n                }\\n                q.poll();\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```java\\nclass Solution {\\n    // store the position of rotten orange\\n    static class Position {\\n        int x;\\n        int y;\\n        Position(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n\\t\\n    public int orangesRotting(int[][] grid) {\\n        Queue<Position> q = new LinkedList<>();\\n        int total = 0, rotten = 0, time = 0;\\n\\t\\t\\n\\t\\t// traverse the grid, offer position of rotten orange into queue, and count the total num of orange\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1 || grid[i][j] == 2) total++;\\n                if (grid[i][j] == 2) q.offer(new Position(i, j));\\n            }\\n        }\\n\\t\\t\\n\\t\\t// if there is no orange, return 0;\\n        if (total == 0) return 0;\\n\\t\\t\\n        while (! q.isEmpty() && rotten < total) {\\n\\t\\t\\t// size is the num of rotten oranges of the last round\\n            int size = q.size();\\n\\t\\t\\t\\n\\t\\t\\t// count the num of rotten oranges, if it equals to total num, return time;\\n            rotten += size;\\n            if (rotten == total) return time;\\n\\t\\t\\t\\n\\t\\t\\t// every round, time ++\\n            time++;\\n\\t\\t\\t\\n\\t\\t\\t// Continue to dequeue until all rotten oranges of last round are removed from the queue\\n            for (int i = 0; i < size; i++) {\\n                Position p = q.peek();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// check the cell in the left/right/top/down of the rotten orange, if it is a fresh orange, enqueue it.\\n                if (p.x + 1 < grid.length && grid[p.x + 1][p.y] == 1) {\\n                    grid[p.x + 1][p.y] = 2;\\n                    q.offer(new Position(p.x + 1, p.y));\\n                }\\n                if (p.x - 1 >= 0 && grid[p.x - 1][p.y] == 1) {\\n                    grid[p.x - 1][p.y] = 2;\\n                    q.offer(new Position(p.x - 1, p.y));\\n                }\\n                if (p.y + 1 < grid[0].length && grid[p.x][p.y + 1] == 1) {\\n                    grid[p.x][p.y + 1] = 2;\\n                    q.offer(new Position(p.x, p.y + 1));\\n                }\\n                if (p.y - 1 >= 0 && grid[p.x][p.y - 1] == 1) {\\n                    grid[p.x][p.y - 1] = 2;\\n                    q.offer(new Position(p.x, p.y - 1));\\n                }\\n                q.poll();\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546489,
                "title": "python-bfs-easy-to-understand-with-explanation",
                "content": "### Preamble\\n\\nI\\'ve posted a solution about a similar problem before: [#980 Uinque Paths III](https://leetcode.com/problems/unique-paths-iii/). In my opinion, the solution to this problem follows a similar train of thought, albeit using a different recursive method (BFS instead of DFS). You can read my post for problem #980 [here](https://leetcode.com/problems/unique-paths-iii/discuss/1535158/Python-Backtracking:-Easy-to-understand-with-Explanation) to understand the thought process better before continuing with this post.\\n\\n---\\n\\n### Introduction\\n\\nThe goal is to traverse from every rotting orange (`grid[x][y] == 2`) through every fresh orange (`grid[x][y] == 1`) until all fresh oranges have been visited once (i.e. all fresh oranges have rotten) or no more traversion is possible (i.e. no adjacent fresh oranges are found).\\n\\nSince, for each passing minute, all adjacent fresh oranges become rotten, we need to recursively check for the coordinates of rotting oranges after each iteration. More specifically, we only need to keep track of the oranges that have rotten in that iteration, since 1) that particular coordinate has never been reached before and thus needs to be checked for adjacent oranges; and 2) all previous coordinates have been checked previously and need not be checked again. For this purpose, we can implement a queue:\\n\\n```python\\nfrom collections import deque\\nqueue = deque()\\n# populate with coordinates of rotten oranges\\nfor _ in range(len(queue)):\\n\\tx, y = queue.popleft()  # remove coordinate to check for adjacent fresh oranges\\n\\t# check for fresh oranges...\\n\\tqueue.append((i, j))  # add new rotten orange coordinate\\n```\\n\\nWe also need to keep track of all fresh oranges, since this is our success condition. Fresh oranges are: 1) to be visited, otherwise we should return `-1` if the orange stays fresh, and 2) visited only once, since upon visiting it becomes rotten. To perform `(x, y) in lst` checks and the deletion of `(x, y)` in O(1) time, we can utilise a set:\\n\\n```python\\nvisit = set()\\n# populate with coordinates of fresh oranges\\nwhile visit:\\n\\t# check if adjacent coordinates are rotten oranges...\\n\\tvisit.remove((x, y))  # remove new rotten orange\\n```\\n\\nThis leaves us with the initial population of the data structures, and the actual BFS. We can thus derive the following implementation:\\n\\n1. Loop through `grid` and find the fresh and rotten oranges.\\n2. While there are fresh and rotten oranges to loop through, determine if any fresh oranges will become rotten in that iteration. Repeat for as many iterations as needed (BFS style).\\n3. Return the number of iterations, checking if there are fresh oranges remaining.\\n\\n---\\n\\n### Code\\n\\n```python\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        visit, curr = set(), deque()\\n\\t\\t# find all fresh and rotten oranges\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    visit.add((i, j))\\n                elif grid[i][j] == 2:\\n                    curr.append((i, j))\\n        result = 0\\n        while visit and curr:\\n\\t\\t\\t# BFS iteration\\n            for _ in range(len(curr)):\\n                i, j = curr.popleft()  # obtain recent rotten orange\\n                for coord in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\\n                    if coord in visit:  # check if adjacent orange is fresh\\n                        visit.remove(coord)\\n                        curr.append(coord)\\n            result += 1\\n\\t\\t# check if fresh oranges remain and return accordingly\\n        return -1 if visit else result\\n```\\n\\n---\\n\\n### Final Result\\n\\n![image](https://assets.leetcode.com/users/images/22554cf6-69a9-4982-99c1-dab6c0dad0f5_1635479399.4226873.png)\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```python\\nfrom collections import deque\\nqueue = deque()\\n# populate with coordinates of rotten oranges\\nfor _ in range(len(queue)):\\n\\tx, y = queue.popleft()  # remove coordinate to check for adjacent fresh oranges\\n\\t# check for fresh oranges...\\n\\tqueue.append((i, j))  # add new rotten orange coordinate\\n```\n```python\\nvisit = set()\\n# populate with coordinates of fresh oranges\\nwhile visit:\\n\\t# check if adjacent coordinates are rotten oranges...\\n\\tvisit.remove((x, y))  # remove new rotten orange\\n```\n```python\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        visit, curr = set(), deque()\\n\\t\\t# find all fresh and rotten oranges\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    visit.add((i, j))\\n                elif grid[i][j] == 2:\\n                    curr.append((i, j))\\n        result = 0\\n        while visit and curr:\\n\\t\\t\\t# BFS iteration\\n            for _ in range(len(curr)):\\n                i, j = curr.popleft()  # obtain recent rotten orange\\n                for coord in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\\n                    if coord in visit:  # check if adjacent orange is fresh\\n                        visit.remove(coord)\\n                        curr.append(coord)\\n            result += 1\\n\\t\\t# check if fresh oranges remain and return accordingly\\n        return -1 if visit else result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241139,
                "title": "c-super-easy-and-clean-solution-beats-100-time-and-100-space",
                "content": "```\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int ct=0, res=-1;\\n        queue<vector<int>> q;\\n        vector<vector<int>> dir={{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        for(int i=0;i<grid.size();i++) {\\n            for(int j=0;j<grid[0].size();j++) {\\n                if(grid[i][j]>0) ct++;\\n                if(grid[i][j]==2) q.push({i, j});\\n            }\\n        }\\n        while(!q.empty()) {\\n            res++;\\n            int size=q.size();\\n            for(int k=0;k<size;k++) {\\n                vector<int> cur=q.front();\\n                ct--;\\n                q.pop();\\n                for(int i=0;i<4;i++) {\\n                    int x=cur[0]+dir[i][0], y=cur[1]+dir[i][1];\\n                    if(x>=grid.size()||x<0||y>=grid[0].size()||y<0||grid[x][y]!=1) continue;\\n                    grid[x][y]=2;\\n                    q.push({x, y});\\n                }\\n            }\\n        }\\n        if(ct==0) return max(0, res);\\n        return -1;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int ct=0, res=-1;\\n        queue<vector<int>> q;\\n        vector<vector<int>> dir={{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        for(int i=0;i<grid.size();i++) {\\n            for(int j=0;j<grid[0].size();j++) {\\n                if(grid[i][j]>0) ct++;\\n                if(grid[i][j]==2) q.push({i, j});\\n            }\\n        }\\n        while(!q.empty()) {\\n            res++;\\n            int size=q.size();\\n            for(int k=0;k<size;k++) {\\n                vector<int> cur=q.front();\\n                ct--;\\n                q.pop();\\n                for(int i=0;i<4;i++) {\\n                    int x=cur[0]+dir[i][0], y=cur[1]+dir[i][1];\\n                    if(x>=grid.size()||x<0||y>=grid[0].size()||y<0||grid[x][y]!=1) continue;\\n                    grid[x][y]=2;\\n                    q.push({x, y});\\n                }\\n            }\\n        }\\n        if(ct==0) return max(0, res);\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 782041,
                "title": "c-with-comments-very-easy-to-read-and-understand-covers-pitfalls-no-prerequisites",
                "content": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        \\n        // initialize a queue which will help us find answer\\n        \\n        queue<pair<int,int> > q; \\n        \\n        int n=grid.size(),m=grid[0].size(),ans=0,ones=0,twos=0;\\n        \\n        // n is the number of columns and m is the number of rows\\n        // \\'ans\\' stands for \\'answer\\' which we will return at the end ;) .\\n        \\n        \\n        //  now lets traverse through the grid\\n        //  Observe that, here we are not using \\'auto\\' because we need to store positions of \\'2\\'s\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==2){\\n                    twos++;// here we count the number of \\'2\\'s in the grid\\n                    \\n                    q.push(make_pair(i,j));\\n                    \\n                    // here we collect all positions of \\'2\\'s in our queue \\n                    // so that our search can be initialised fron them\\n                    \\n                }\\n                else if(grid[i][j]==1)ones++; // here we count the number of \\'1\\'s in the grid\\n            }\\n        }\\n        \\n        // Observe that, in this loop we have visited each cell, so time complexity has reached O(n*m) .  \\n        \\n        \\n        // ******************* Actual Solution Starts Here, Have Fun :)  ************* .\\n        \\n        // if there are no fresh oranges (ones) present, time required is zero\\n        if(ones==0)return 0; \\n        \\n        // Now as the control has passed the above conditions, it means it has some fresh oranes. \\n        // Hence, If there are no rotten oranges, fresh oranges will not rot and we will have to return (-1) . \\n        \\n        else if(twos==0)return -1;\\n        \\n        // Now we will have to do Breadth-First-Search to find the minimum time\\n        \\n        int cnt1=twos,cnt2=0;\\n        // cnt1 stores the number of unvisited nodes or oranges which are \\n        // going to affect its neighbours at the current moment\\n        \\n        // cnt2 is going to store number of childs of the oranges in the current level\\n        // Don\\'t worry if you didn\\'t get that line, I got you covered below ;) .\\n        \\n        **// Observe that, The first level is already rotten, \\n        // still we are counting it and hence at the end we return (ans-1) instead of ans . **\\n        \\n        while(!q.empty()){\\n            pair<int,int> p=q.front();\\n            q.pop();\\n            int y=p.first,x=p.second;\\n            // Everytime we pop, unvisited oranges in current level decreases by one, hence cnt1-- .\\n            cnt1--;\\n            \\n            // Now we put forward four conditions to check in four directions of the current orange\\n            // But for that to work, the position should exist , \\n            // i.e.  it should not cross the bounds of the grid\\n            \\n            if(y>0){\\n                if(grid[y-1][x]==1){\\n                    cnt2++;\\n                    grid[y-1][x]=2;\\n                    ones--; \\n                    // one became two \\n                    // and number of childs i.e. cnt2 increased by one\\n                    // and lets add it to the queue to check if it has any children later\\n                    q.push(make_pair(y-1,x));\\n                }\\n            }\\n            if(y<n-1){\\n                if(grid[y+1][x]==1){\\n                    cnt2++;\\n                    grid[y+1][x]=2;\\n                    ones--;\\n                    q.push(make_pair(y+1,x));\\n                }\\n            }\\n            if(x>0){\\n                if(grid[y][x-1]==1){\\n                    cnt2++;\\n                    grid[y][x-1]=2;\\n                    ones--;\\n                    q.push(make_pair(y,x-1));\\n                }\\n            }\\n            if(x<m-1){\\n                if(grid[y][x+1]==1){\\n                    cnt2++;\\n                    ones--;\\n                    grid[y][x+1]=2;\\n                    q.push(make_pair(y,x+1));\\n                }\\n            }\\n            if(cnt1==0){\\n                // cnt1 is zero means we have completed traversing the current level of the graph\\n                // and hence one unit of time is passed. Hence we increrment ans\\n                // lets go to next level, for that cnt2 becomes cnt1 and cnt2 becomes zero, \\n                // i.e. children are upgraded to current generation and child count start again from zero.\\n                ans++;\\n                cnt1=cnt2;\\n                cnt2=0;\\n            }\\n        }\\n        \\n        // if there are some ones\\' which are  still not visited, then they will never get rotten, \\n\\t\\t// Good for them xD .\\n        if(ones>0)return -1; \\n        \\n        // else\\n        return ans-1;\\n        \\n    }\\n\\t\\n// We have traversed the graph level-by-level, hence this technique is called as\\n// Breadth First Search or BFS.\\n    \\n    // I am sure you have understood the solution :) .\\n    // If Not, Feel free to comment.    \\n    \\n    // Don\\'t hesitate in Upvoting and sharing this solution if you like it ;)) .\\n\\t// Happy Coding :) .\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        \\n        // initialize a queue which will help us find answer\\n        \\n        queue<pair<int,int> > q; \\n        \\n        int n=grid.size(),m=grid[0].size(),ans=0,ones=0,twos=0;\\n        \\n        // n is the number of columns and m is the number of rows\\n        // \\'ans\\' stands for \\'answer\\' which we will return at the end ;) .\\n        \\n        \\n        //  now lets traverse through the grid\\n        //  Observe that, here we are not using \\'auto\\' because we need to store positions of \\'2\\'s\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==2){\\n                    twos++;// here we count the number of \\'2\\'s in the grid\\n                    \\n                    q.push(make_pair(i,j));\\n                    \\n                    // here we collect all positions of \\'2\\'s in our queue \\n                    // so that our search can be initialised fron them\\n                    \\n                }\\n                else if(grid[i][j]==1)ones++; // here we count the number of \\'1\\'s in the grid\\n            }\\n        }\\n        \\n        // Observe that, in this loop we have visited each cell, so time complexity has reached O(n*m) .  \\n        \\n        \\n        // ******************* Actual Solution Starts Here, Have Fun :)  ************* .\\n        \\n        // if there are no fresh oranges (ones) present, time required is zero\\n        if(ones==0)return 0; \\n        \\n        // Now as the control has passed the above conditions, it means it has some fresh oranes. \\n        // Hence, If there are no rotten oranges, fresh oranges will not rot and we will have to return (-1) . \\n        \\n        else if(twos==0)return -1;\\n        \\n        // Now we will have to do Breadth-First-Search to find the minimum time\\n        \\n        int cnt1=twos,cnt2=0;\\n        // cnt1 stores the number of unvisited nodes or oranges which are \\n        // going to affect its neighbours at the current moment\\n        \\n        // cnt2 is going to store number of childs of the oranges in the current level\\n        // Don\\'t worry if you didn\\'t get that line, I got you covered below ;) .\\n        \\n        **// Observe that, The first level is already rotten, \\n        // still we are counting it and hence at the end we return (ans-1) instead of ans . **\\n        \\n        while(!q.empty()){\\n            pair<int,int> p=q.front();\\n            q.pop();\\n            int y=p.first,x=p.second;\\n            // Everytime we pop, unvisited oranges in current level decreases by one, hence cnt1-- .\\n            cnt1--;\\n            \\n            // Now we put forward four conditions to check in four directions of the current orange\\n            // But for that to work, the position should exist , \\n            // i.e.  it should not cross the bounds of the grid\\n            \\n            if(y>0){\\n                if(grid[y-1][x]==1){\\n                    cnt2++;\\n                    grid[y-1][x]=2;\\n                    ones--; \\n                    // one became two \\n                    // and number of childs i.e. cnt2 increased by one\\n                    // and lets add it to the queue to check if it has any children later\\n                    q.push(make_pair(y-1,x));\\n                }\\n            }\\n            if(y<n-1){\\n                if(grid[y+1][x]==1){\\n                    cnt2++;\\n                    grid[y+1][x]=2;\\n                    ones--;\\n                    q.push(make_pair(y+1,x));\\n                }\\n            }\\n            if(x>0){\\n                if(grid[y][x-1]==1){\\n                    cnt2++;\\n                    grid[y][x-1]=2;\\n                    ones--;\\n                    q.push(make_pair(y,x-1));\\n                }\\n            }\\n            if(x<m-1){\\n                if(grid[y][x+1]==1){\\n                    cnt2++;\\n                    ones--;\\n                    grid[y][x+1]=2;\\n                    q.push(make_pair(y,x+1));\\n                }\\n            }\\n            if(cnt1==0){\\n                // cnt1 is zero means we have completed traversing the current level of the graph\\n                // and hence one unit of time is passed. Hence we increrment ans\\n                // lets go to next level, for that cnt2 becomes cnt1 and cnt2 becomes zero, \\n                // i.e. children are upgraded to current generation and child count start again from zero.\\n                ans++;\\n                cnt1=cnt2;\\n                cnt2=0;\\n            }\\n        }\\n        \\n        // if there are some ones\\' which are  still not visited, then they will never get rotten, \\n\\t\\t// Good for them xD .\\n        if(ones>0)return -1; \\n        \\n        // else\\n        return ans-1;\\n        \\n    }\\n\\t\\n// We have traversed the graph level-by-level, hence this technique is called as\\n// Breadth First Search or BFS.\\n    \\n    // I am sure you have understood the solution :) .\\n    // If Not, Feel free to comment.    \\n    \\n    // Don\\'t hesitate in Upvoting and sharing this solution if you like it ;)) .\\n\\t// Happy Coding :) .\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 892106,
                "title": "easy-c-bfs-solution-well-explained",
                "content": "```\\n/* (https://leetcode.com/problems/rotting-oranges/submissions/)\\n\\nSolution based on BFS.\\n*/\\nclass Solution\\n{\\npublic:\\n    int orangesRotting(vector<vector<int>> &grid)\\n    {\\n        if (grid.empty()) // if there is no orange.\\n            return 0;\\n\\n        int countFreshOranges = 0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        queue<pair<int, int>> q; // queue to store the index of the cell where rotten oranges are placed.\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 1)\\n                    countFreshOranges++;\\n                else if (grid[i][j] == 2)\\n                    q.push({i, j});\\n            }\\n        }\\n\\n        int time = 0;\\n        // four adjacent positions at which the oranged placed will get rotten.\\n        vector<pair<int, int>> dirs = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n\\n        while (countFreshOranges != 0 && !q.empty())\\n        {\\n            int qsize = q.size();\\n\\n            for (int i = 0; i < qsize; i++)\\n            {\\n                int rottenI = q.front().first;\\n                int rottenJ = q.front().second;\\n                q.pop();\\n\\n                for (auto d : dirs)\\n                {\\n                    int newX = rottenI + d.first;\\n                    int newY = rottenJ + d.second;\\n                    // if we got any fresh orange adjacent to the rotten orange then it will get rotten and\\n                    // count of fresh oranges will reduce and we will push the new index of rotten orange in \\n                    // the queue.\\n                    if (newX >= 0 && newX < m && newY >= 0 && newY < n && grid[newX][newY] == 1)\\n                    {\\n                        grid[newX][newY] = 2;\\n                        countFreshOranges--;\\n                        q.push({newX, newY});\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        return countFreshOranges == 0 ? time : -1;\\n    }\\n};\\n```\\n**If you like the solution then please upvote :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/* (https://leetcode.com/problems/rotting-oranges/submissions/)\\n\\nSolution based on BFS.\\n*/\\nclass Solution\\n{\\npublic:\\n    int orangesRotting(vector<vector<int>> &grid)\\n    {\\n        if (grid.empty()) // if there is no orange.\\n            return 0;\\n\\n        int countFreshOranges = 0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        queue<pair<int, int>> q; // queue to store the index of the cell where rotten oranges are placed.\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 1)\\n                    countFreshOranges++;\\n                else if (grid[i][j] == 2)\\n                    q.push({i, j});\\n            }\\n        }\\n\\n        int time = 0;\\n        // four adjacent positions at which the oranged placed will get rotten.\\n        vector<pair<int, int>> dirs = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n\\n        while (countFreshOranges != 0 && !q.empty())\\n        {\\n            int qsize = q.size();\\n\\n            for (int i = 0; i < qsize; i++)\\n            {\\n                int rottenI = q.front().first;\\n                int rottenJ = q.front().second;\\n                q.pop();\\n\\n                for (auto d : dirs)\\n                {\\n                    int newX = rottenI + d.first;\\n                    int newY = rottenJ + d.second;\\n                    // if we got any fresh orange adjacent to the rotten orange then it will get rotten and\\n                    // count of fresh oranges will reduce and we will push the new index of rotten orange in \\n                    // the queue.\\n                    if (newX >= 0 && newX < m && newY >= 0 && newY < n && grid[newX][newY] == 1)\\n                    {\\n                        grid[newX][newY] = 2;\\n                        countFreshOranges--;\\n                        q.push({newX, newY});\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        return countFreshOranges == 0 ? time : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858396,
                "title": "javascript-clean-bfs-w-explanation-99-5",
                "content": "![image](https://assets.leetcode.com/users/images/41c78fd9-b93d-4cd0-9fcb-f49d94318d25_1647533000.361992.png)\\n\\nVersion w/o Explanation: (Commented version below)\\n```\\nvar orangesRotting = function(grid) {\\n  let queue = [], oranges = 0, time = 0;\\n  \\n  for (let r = 0; r < grid.length; r++) {\\n    for (let c = 0; c < grid[r].length; c++) {\\n      if (grid[r][c] === 1) oranges++\\n      else if (grid[r][c] === 2) queue.push([r,c,0]);\\n    }\\n  }\\n    \\n  const dirs = [[0,1], [1,0], [0,-1], [-1,0]];\\n  const endR = grid.length - 1, endC = grid[0].length - 1;\\n  \\n  while (queue.length && oranges) {\\n    const [curR, curC, mins] = queue.shift();\\n    \\n    if (grid[curR][curC] === 1) {\\n      grid[curR][curC] = 2;\\n      oranges--;\\n      time = mins;\\n    }\\n\\n    for (let [addR, addC] of dirs) {\\n      const [newR, newC] = [curR + addR, curC + addC];\\n      if (newR < 0 || newR > endR || newC < 0 || newC > endC) continue;\\n      if (grid[newR][newC] === 1) {\\n        queue.push([newR, newC, mins + 1])\\n      }\\n    }\\n  }\\n  \\n  return oranges ? -1 : time;\\n};\\n```\\n\\nVersion w/ Explanation:\\n```\\nvar orangesRotting = function(grid) {\\n  //Initialize queue for our BFS, Number of fresh oranges, and time to be returned.\\n  let queue = [], oranges = 0, time = 0;\\n  \\n  //Traverse matrix.  If we find a fresh orange, increment orange count.\\n  //If we find a rotten one, add it to the queue.\\n  for (let r = 0; r < grid.length; r++) {\\n    for (let c = 0; c < grid[r].length; c++) {\\n      if (grid[r][c] === 1) oranges++\\n      else if (grid[r][c] === 2) queue.push([r,c,0]);\\n    }\\n  }\\n    \\n  //Dirs will help us check neighbors during our BFS.  Adding these coordinates\\n  //to a point just gets right, left, up and down.  endR and endC are used later\\n  //to make sure neighbor coords are within grid.\\n  const dirs = [[0,1], [1,0], [0,-1], [-1,0]];\\n  const endR = grid.length - 1, endC = grid[0].length - 1;\\n  \\n  //Loop while queue is not empty and there are still fresh oranges.\\n  while (queue.length && oranges) {\\n  \\n\\t//Entry within queue can be destructured to make it easier to work with.\\n\\t//Each queue entry has a row, column and number of minutes taken for\\n\\t//infection to reach.\\n    const [curR, curC, mins] = queue.shift();\\n    \\n\\t//If orange is still fresh, we mark it as rotten, decrement our fresh oranges\\n\\t//count and set time to = mins.  Since we BFSing, the time it takes to infect\\n\\t//the last orange will be the time to infect all.  Once all oranges have\\n\\t//been infected, our orange count will = 0 and our condition in while loop\\n\\t//will stop the loop.  Time can then be returned.\\n    if (grid[curR][curC] === 1) {\\n      grid[curR][curC] = 2;\\n      oranges--;\\n      time = mins;\\n    }\\n\\n    //Here\\'s where our dir array above comes in handy.  We destructure\\n\\t//each entry and add it to our current to get neighbor coords below.\\n    for (let [addR, addC] of dirs) {\\n\\t\\n\\t  //Here we obtain our new or neighbor coordinates by adding currentRow\\n\\t  //and addRow of dir.  Same for col.\\n      const [newR, newC] = [curR + addR, curC + addC];\\n\\t  \\n\\t  //Here we check to make sure new coordinates lie within the grid.\\n      if (newR < 0 || newR > endR || newC < 0 || newC > endC) continue;\\n\\t  \\n\\t  //If neighbor coord is valid, and there is a fresh orange at those coordinates\\n\\t  //we push coordinates to our BFS to be infected next.  We also increment the\\n\\t  //mins count to track time taken to spread to that orange.\\n      if (grid[newR][newC] === 1) {\\n        queue.push([newR, newC, mins + 1])\\n      }\\n    }\\n  }\\n  \\n  //If we still have uninfected oranges, we return -1 because it won\\'t spread\\n  //to all.  Otherwise, we simply return the time from initial infected to last\\n  //infected orange.\\n  return oranges ? -1 : time;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar orangesRotting = function(grid) {\\n  let queue = [], oranges = 0, time = 0;\\n  \\n  for (let r = 0; r < grid.length; r++) {\\n    for (let c = 0; c < grid[r].length; c++) {\\n      if (grid[r][c] === 1) oranges++\\n      else if (grid[r][c] === 2) queue.push([r,c,0]);\\n    }\\n  }\\n    \\n  const dirs = [[0,1], [1,0], [0,-1], [-1,0]];\\n  const endR = grid.length - 1, endC = grid[0].length - 1;\\n  \\n  while (queue.length && oranges) {\\n    const [curR, curC, mins] = queue.shift();\\n    \\n    if (grid[curR][curC] === 1) {\\n      grid[curR][curC] = 2;\\n      oranges--;\\n      time = mins;\\n    }\\n\\n    for (let [addR, addC] of dirs) {\\n      const [newR, newC] = [curR + addR, curC + addC];\\n      if (newR < 0 || newR > endR || newC < 0 || newC > endC) continue;\\n      if (grid[newR][newC] === 1) {\\n        queue.push([newR, newC, mins + 1])\\n      }\\n    }\\n  }\\n  \\n  return oranges ? -1 : time;\\n};\\n```\n```\\nvar orangesRotting = function(grid) {\\n  //Initialize queue for our BFS, Number of fresh oranges, and time to be returned.\\n  let queue = [], oranges = 0, time = 0;\\n  \\n  //Traverse matrix.  If we find a fresh orange, increment orange count.\\n  //If we find a rotten one, add it to the queue.\\n  for (let r = 0; r < grid.length; r++) {\\n    for (let c = 0; c < grid[r].length; c++) {\\n      if (grid[r][c] === 1) oranges++\\n      else if (grid[r][c] === 2) queue.push([r,c,0]);\\n    }\\n  }\\n    \\n  //Dirs will help us check neighbors during our BFS.  Adding these coordinates\\n  //to a point just gets right, left, up and down.  endR and endC are used later\\n  //to make sure neighbor coords are within grid.\\n  const dirs = [[0,1], [1,0], [0,-1], [-1,0]];\\n  const endR = grid.length - 1, endC = grid[0].length - 1;\\n  \\n  //Loop while queue is not empty and there are still fresh oranges.\\n  while (queue.length && oranges) {\\n  \\n\\t//Entry within queue can be destructured to make it easier to work with.\\n\\t//Each queue entry has a row, column and number of minutes taken for\\n\\t//infection to reach.\\n    const [curR, curC, mins] = queue.shift();\\n    \\n\\t//If orange is still fresh, we mark it as rotten, decrement our fresh oranges\\n\\t//count and set time to = mins.  Since we BFSing, the time it takes to infect\\n\\t//the last orange will be the time to infect all.  Once all oranges have\\n\\t//been infected, our orange count will = 0 and our condition in while loop\\n\\t//will stop the loop.  Time can then be returned.\\n    if (grid[curR][curC] === 1) {\\n      grid[curR][curC] = 2;\\n      oranges--;\\n      time = mins;\\n    }\\n\\n    //Here\\'s where our dir array above comes in handy.  We destructure\\n\\t//each entry and add it to our current to get neighbor coords below.\\n    for (let [addR, addC] of dirs) {\\n\\t\\n\\t  //Here we obtain our new or neighbor coordinates by adding currentRow\\n\\t  //and addRow of dir.  Same for col.\\n      const [newR, newC] = [curR + addR, curC + addC];\\n\\t  \\n\\t  //Here we check to make sure new coordinates lie within the grid.\\n      if (newR < 0 || newR > endR || newC < 0 || newC > endC) continue;\\n\\t  \\n\\t  //If neighbor coord is valid, and there is a fresh orange at those coordinates\\n\\t  //we push coordinates to our BFS to be infected next.  We also increment the\\n\\t  //mins count to track time taken to spread to that orange.\\n      if (grid[newR][newC] === 1) {\\n        queue.push([newR, newC, mins + 1])\\n      }\\n    }\\n  }\\n  \\n  //If we still have uninfected oranges, we return -1 because it won\\'t spread\\n  //to all.  Otherwise, we simply return the time from initial infected to last\\n  //infected orange.\\n  return oranges ? -1 : time;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 515257,
                "title": "javascript-bfs-solution",
                "content": "```javascript\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar orangesRotting = function(grid) {\\n  const height = grid.length;\\n  const width = grid[0].length;\\n  let fresh = 0;\\n  const queue = [];\\n  for (let i = 0; i < height; i++) {\\n    for (let j = 0; j < width; j++) {\\n      if (grid[i][j] === 2) queue.push([i, j]);\\n      if (grid[i][j] === 1) fresh++;\\n    }\\n  }\\n  let minute = 0;\\n  while (queue.length) {\\n    const size = queue.length;\\n    for (let i = 0; i < size; i++) {\\n      const [x, y] = queue.shift();\\n      if (x - 1 >= 0 && grid[x - 1][y] === 1) {\\n        grid[x - 1][y] = 2;\\n        fresh--;\\n        queue.push([x - 1, y]);\\n      }\\n      if (x + 1 < height && grid[x + 1][y] === 1) {\\n        grid[x + 1][y] = 2;\\n        fresh--;\\n        queue.push([x + 1, y]);\\n      }\\n      if (y - 1 >= 0 && grid[x][y - 1] === 1) {\\n        grid[x][y - 1] = 2;\\n        fresh--;\\n        queue.push([x, y - 1]);\\n      }\\n      if (y + 1 < width && grid[x][y + 1] === 1) {\\n        grid[x][y + 1] = 2;\\n        fresh--;\\n        queue.push([x, y + 1]);\\n      }\\n    }\\n    if (queue.length > 0) minute++;\\n  }\\n  return fresh === 0 ? minute : -1;\\n};\\n```\\n\\n* 303/303 cases passed (64 ms)\\n* Your runtime beats 88.77 % of javascript submissions\\n* Your memory usage beats 50 % of javascript submissions (36.8 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar orangesRotting = function(grid) {\\n  const height = grid.length;\\n  const width = grid[0].length;\\n  let fresh = 0;\\n  const queue = [];\\n  for (let i = 0; i < height; i++) {\\n    for (let j = 0; j < width; j++) {\\n      if (grid[i][j] === 2) queue.push([i, j]);\\n      if (grid[i][j] === 1) fresh++;\\n    }\\n  }\\n  let minute = 0;\\n  while (queue.length) {\\n    const size = queue.length;\\n    for (let i = 0; i < size; i++) {\\n      const [x, y] = queue.shift();\\n      if (x - 1 >= 0 && grid[x - 1][y] === 1) {\\n        grid[x - 1][y] = 2;\\n        fresh--;\\n        queue.push([x - 1, y]);\\n      }\\n      if (x + 1 < height && grid[x + 1][y] === 1) {\\n        grid[x + 1][y] = 2;\\n        fresh--;\\n        queue.push([x + 1, y]);\\n      }\\n      if (y - 1 >= 0 && grid[x][y - 1] === 1) {\\n        grid[x][y - 1] = 2;\\n        fresh--;\\n        queue.push([x, y - 1]);\\n      }\\n      if (y + 1 < width && grid[x][y + 1] === 1) {\\n        grid[x][y + 1] = 2;\\n        fresh--;\\n        queue.push([x, y + 1]);\\n      }\\n    }\\n    if (queue.length > 0) minute++;\\n  }\\n  return fresh === 0 ? minute : -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1517522,
                "title": "java-tc-o-m-n-sc-o-m-n-optimized-bfs-solution",
                "content": "```java\\n/**\\n * Optimized BFS Solution. Find all rotten oranges and add them to a queue.\\n * Start the BFS from this level and rot all the neighboring oranges. Continue\\n * till all levels are exhausted or all oranges have become rotten.\\n *\\n * Time Complexity: O(2 * M * N) --> Each cell in the grid is visited maximum\\n * twice.\\n *\\n * Space Complexity: O(M * N) --> Queue Size\\n *\\n * M = Number of rows. N = Number of columns\\n */\\nclass Solution {\\n    private static final int[][] DIRS = { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } };\\n\\n    public int orangesRotting(int[][] grid) {\\n        if (grid == null) {\\n            throw new IllegalArgumentException(\"Input grid is null\");\\n        }\\n        if (grid.length == 0 || grid[0].length == 0) {\\n            return 0;\\n        }\\n\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        if (rows == 1 && cols == 1) {\\n            return grid[0][0] == 1 ? -1 : 0;\\n        }\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n        int freshOrangesCount = 0;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == 2) {\\n                    queue.offer(i * cols + j);\\n                } else if (grid[i][j] == 1) {\\n                    freshOrangesCount++;\\n                }\\n            }\\n        }\\n\\n        int time = 0;\\n        // freshOrangesCount != 0 ==> This check ensure we are not continuing once all\\n        // fresh oranges have become rotten.\\n        while (freshOrangesCount != 0 && !queue.isEmpty()) {\\n            int levelSize = queue.size();\\n            time++; // Time elapsed after neighbors of this level have become rotten.\\n            for (int i = 0; i < levelSize && freshOrangesCount != 0; i++) {\\n                int cur = queue.poll();\\n                int row = cur / cols;\\n                int col = cur % cols;\\n                for (int[] d : DIRS) {\\n                    int x = row + d[0];\\n                    int y = col + d[1];\\n                    if (x < 0 || x >= rows || y < 0 || y >= cols || grid[x][y] != 1) {\\n                        continue;\\n                    }\\n                    grid[x][y] = 2;\\n                    freshOrangesCount--;\\n                    if (freshOrangesCount == 0) {\\n                        break;\\n                    }\\n                    queue.offer(x * cols + y);\\n                }\\n            }\\n        }\\n\\n        return freshOrangesCount == 0 ? time : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Breadth-First Search",
                    "Queue",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Optimized BFS Solution. Find all rotten oranges and add them to a queue.\\n * Start the BFS from this level and rot all the neighboring oranges. Continue\\n * till all levels are exhausted or all oranges have become rotten.\\n *\\n * Time Complexity: O(2 * M * N) --> Each cell in the grid is visited maximum\\n * twice.\\n *\\n * Space Complexity: O(M * N) --> Queue Size\\n *\\n * M = Number of rows. N = Number of columns\\n */\\nclass Solution {\\n    private static final int[][] DIRS = { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } };\\n\\n    public int orangesRotting(int[][] grid) {\\n        if (grid == null) {\\n            throw new IllegalArgumentException(\"Input grid is null\");\\n        }\\n        if (grid.length == 0 || grid[0].length == 0) {\\n            return 0;\\n        }\\n\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        if (rows == 1 && cols == 1) {\\n            return grid[0][0] == 1 ? -1 : 0;\\n        }\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n        int freshOrangesCount = 0;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == 2) {\\n                    queue.offer(i * cols + j);\\n                } else if (grid[i][j] == 1) {\\n                    freshOrangesCount++;\\n                }\\n            }\\n        }\\n\\n        int time = 0;\\n        // freshOrangesCount != 0 ==> This check ensure we are not continuing once all\\n        // fresh oranges have become rotten.\\n        while (freshOrangesCount != 0 && !queue.isEmpty()) {\\n            int levelSize = queue.size();\\n            time++; // Time elapsed after neighbors of this level have become rotten.\\n            for (int i = 0; i < levelSize && freshOrangesCount != 0; i++) {\\n                int cur = queue.poll();\\n                int row = cur / cols;\\n                int col = cur % cols;\\n                for (int[] d : DIRS) {\\n                    int x = row + d[0];\\n                    int y = col + d[1];\\n                    if (x < 0 || x >= rows || y < 0 || y >= cols || grid[x][y] != 1) {\\n                        continue;\\n                    }\\n                    grid[x][y] = 2;\\n                    freshOrangesCount--;\\n                    if (freshOrangesCount == 0) {\\n                        break;\\n                    }\\n                    queue.offer(x * cols + y);\\n                }\\n            }\\n        }\\n\\n        return freshOrangesCount == 0 ? time : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248472,
                "title": "javascript-bfs-100-simple",
                "content": "```\\nvar orangesRotting = function(grid) {\\n    let q = [];\\n    let numFresh = 0;\\n    let minutes = 0;\\n    // Push rotten oranges to the stack and count fresh oranges\\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if (grid[i][j] === 2)\\n                q.push([i,j]);\\n            if (grid[i][j] === 1)\\n                numFresh++;\\n        }\\n    }\\n\\t\\n    while (q.length && numFresh) {\\n\\t\\tlet newQ = []; // queue for next minute\\n        while (q.length) {\\n            let badOrange = q.shift();\\n            let newRottens = infectOthers(grid, badOrange[0], badOrange[1], newQ);\\n            numFresh -= newRottens;\\n        }\\n        \\n        minutes++;\\n        q = newQ;\\n    }\\n    if (numFresh !== 0)\\n\\t\\treturn -1;\\n\\treturn minutes;\\n};\\n\\n// Infect surrounding oranges\\n// Return the number of newly infected oranges\\nvar infectOthers = function(grid, i, j, q) {\\n    let infected = 0;\\n    if (i > 0 && grid[i-1][j] === 1) {\\n        grid[i-1][j]++;\\n        infected++;\\n        q.push([i-1,j]);\\n    }\\n    if (j > 0 && grid[i][j-1] === 1) {\\n        grid[i][j-1]++;\\n        infected++;\\n        q.push([i,j-1]);\\n    }\\n    if (i < grid.length-1 && grid[i+1][j] === 1) {\\n        grid[i+1][j]++;\\n        infected++;\\n        q.push([i+1,j]);\\n    } \\n    if (j < grid[0].length-1 && grid[i][j+1] === 1) {\\n        grid[i][j+1]++;\\n        infected++;\\n        q.push([i,j+1]);\\n    }\\n    \\n    return infected;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar orangesRotting = function(grid) {\\n    let q = [];\\n    let numFresh = 0;\\n    let minutes = 0;\\n    // Push rotten oranges to the stack and count fresh oranges\\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if (grid[i][j] === 2)\\n                q.push([i,j]);\\n            if (grid[i][j] === 1)\\n                numFresh++;\\n        }\\n    }\\n\\t\\n    while (q.length && numFresh) {\\n\\t\\tlet newQ = []; // queue for next minute\\n        while (q.length) {\\n            let badOrange = q.shift();\\n            let newRottens = infectOthers(grid, badOrange[0], badOrange[1], newQ);\\n            numFresh -= newRottens;\\n        }\\n        \\n        minutes++;\\n        q = newQ;\\n    }\\n    if (numFresh !== 0)\\n\\t\\treturn -1;\\n\\treturn minutes;\\n};\\n\\n// Infect surrounding oranges\\n// Return the number of newly infected oranges\\nvar infectOthers = function(grid, i, j, q) {\\n    let infected = 0;\\n    if (i > 0 && grid[i-1][j] === 1) {\\n        grid[i-1][j]++;\\n        infected++;\\n        q.push([i-1,j]);\\n    }\\n    if (j > 0 && grid[i][j-1] === 1) {\\n        grid[i][j-1]++;\\n        infected++;\\n        q.push([i,j-1]);\\n    }\\n    if (i < grid.length-1 && grid[i+1][j] === 1) {\\n        grid[i+1][j]++;\\n        infected++;\\n        q.push([i+1,j]);\\n    } \\n    if (j < grid[0].length-1 && grid[i][j+1] === 1) {\\n        grid[i][j+1]++;\\n        infected++;\\n        q.push([i,j+1]);\\n    }\\n    \\n    return infected;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1546757,
                "title": "c-clean-code-100-faster",
                "content": "<br>\\n\\n**Approach:** \\n* Store position of all initially rotten oranges\\n* Count all fresh oranges at start\\n* Start traversing from rotten oranges, go to it\\'s 4 adjacent positions and if the orange is fresh, then rot it, decrease the count of fresh oranges\\n* Increase the time after repeating above step for all currently rotten oranges\\n* At last, if any fresh orange is remaining then return -1, if time is -1 (Didn\\'t start trsversing) then return 0, else return time taken to rot all oranges\\n\\n<br>\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int fresh = 0, time = -1;\\n        \\n        vector<pair<int, int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        queue<pair<int, int>> q;\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == 1) fresh++;\\n                else if(grid[i][j] == 2) q.push({i, j});\\n            }\\n        }\\n        \\n        while(!q.empty()) {\\n            int sz = q.size();\\n            for(int i = 0; i < sz; i++) {\\n                auto cur = q.front();\\n                q.pop();\\n                for(auto dir: dirs) {\\n                    int x = cur.first + dir.first;\\n                    int y = cur.second + dir.second;\\n                    if(x >= 0 and x < m and y >= 0 and y < n and grid[x][y] == 1) {\\n                        grid[x][y] = 2;\\n                        q.push({x, y});\\n                        fresh--;\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        \\n        return (fresh > 0) ? -1 : ((time == -1) ? 0 : time);\\n    }\\n};\\n```\\n\\n<br>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int fresh = 0, time = -1;\\n        \\n        vector<pair<int, int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        queue<pair<int, int>> q;\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == 1) fresh++;\\n                else if(grid[i][j] == 2) q.push({i, j});\\n            }\\n        }\\n        \\n        while(!q.empty()) {\\n            int sz = q.size();\\n            for(int i = 0; i < sz; i++) {\\n                auto cur = q.front();\\n                q.pop();\\n                for(auto dir: dirs) {\\n                    int x = cur.first + dir.first;\\n                    int y = cur.second + dir.second;\\n                    if(x >= 0 and x < m and y >= 0 and y < n and grid[x][y] == 1) {\\n                        grid[x][y] = 2;\\n                        q.push({x, y});\\n                        fresh--;\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        \\n        return (fresh > 0) ? -1 : ((time == -1) ? 0 : time);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502466,
                "title": "java-bfs-easy-solution",
                "content": "```\\nclass Solution {\\n    public static int orangesRotting(int[][] grid) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        int minutes = -1;\\n        int freshCount = 0;\\n\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] == 2) queue.offer(new int[]{i, j}); //gathering rotten oranges to queue\\n                else if(grid[i][j] == 1) freshCount++;\\n            }\\n        }\\n\\n        if(freshCount == 0) return 0; //there is no fresh orange.\\n        if(queue.size() == 0) return -1; //there is noting to rotten.\\n\\n        while (!queue.isEmpty()) {\\n            minutes++;\\n            int size = queue.size(); //Rotten oranges simultaneously affect adjacent fresh oranges.\\n            for(int i = 0; i < size; i++) {\\n                //if using queue.size() instead of size, it will be not working properly, beacuse queue is changeable.\\n                int[] now = queue.poll();\\n                for (int[] dir : dirs) { //find fresh oragnes from adjacent directions.\\n                    int x = now[0] + dir[0];\\n                    int y = now[1] + dir[1];\\n\\n                    if (x > grid.length - 1 || x < 0 || y > grid[0].length - 1 || y < 0) continue;\\n                    if (grid[x][y] == 1) {\\n                        queue.offer(new int[]{x, y});\\n                        grid[x][y] = 2; //rotten..!!\\n                        freshCount--;\\n                    }\\n                }\\n            }\\n        }\\n        //if freshCount is not 0, it means that all fresh orange couldn\\'t be rotten.\\n        return freshCount != 0 ? -1 : minutes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public static int orangesRotting(int[][] grid) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        int minutes = -1;\\n        int freshCount = 0;\\n\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] == 2) queue.offer(new int[]{i, j}); //gathering rotten oranges to queue\\n                else if(grid[i][j] == 1) freshCount++;\\n            }\\n        }\\n\\n        if(freshCount == 0) return 0; //there is no fresh orange.\\n        if(queue.size() == 0) return -1; //there is noting to rotten.\\n\\n        while (!queue.isEmpty()) {\\n            minutes++;\\n            int size = queue.size(); //Rotten oranges simultaneously affect adjacent fresh oranges.\\n            for(int i = 0; i < size; i++) {\\n                //if using queue.size() instead of size, it will be not working properly, beacuse queue is changeable.\\n                int[] now = queue.poll();\\n                for (int[] dir : dirs) { //find fresh oragnes from adjacent directions.\\n                    int x = now[0] + dir[0];\\n                    int y = now[1] + dir[1];\\n\\n                    if (x > grid.length - 1 || x < 0 || y > grid[0].length - 1 || y < 0) continue;\\n                    if (grid[x][y] == 1) {\\n                        queue.offer(new int[]{x, y});\\n                        grid[x][y] = 2; //rotten..!!\\n                        freshCount--;\\n                    }\\n                }\\n            }\\n        }\\n        //if freshCount is not 0, it means that all fresh orange couldn\\'t be rotten.\\n        return freshCount != 0 ? -1 : minutes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452718,
                "title": "python3-breadth-first-search-time",
                "content": "* flip the rotten orange \\'2\\' to \\'0\\' then you don\\'t need a visited set to avoid duplicate caculation.\\n```\\nfrom collections import deque\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n        queue = ((0,0))\\n        [2,2,0]\\n        [2,1,0]\\n        [0,1,1]\\n        \\n        \"\"\"\\n        # put all the rotten orange into our tast queue.\\n        l = 0\\n        queue = deque([])\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 2:\\n                    queue.append((i,j,l))\\n                    grid[i][j] = 0\\n        \\n\\n        while queue:\\n            I,J,l = queue.popleft()\\n            print(I,J)\\n            for i,j in [I -1,J],[I+1,J],[I,J-1],[I,J+1]:\\n                if 0 <= i < len(grid) and 0<=j<len(grid[0]) and grid[i][j] == 1:\\n                    queue.append((i,j,l+1))\\n                    grid[i][j] = 0\\n        #print(grid)\\n        if any(1 in row for row in grid):\\n            return -1\\n        else:\\n            return l\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n        queue = ((0,0))\\n        [2,2,0]\\n        [2,1,0]\\n        [0,1,1]\\n        \\n        \"\"\"\\n        # put all the rotten orange into our tast queue.\\n        l = 0\\n        queue = deque([])\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 2:\\n                    queue.append((i,j,l))\\n                    grid[i][j] = 0\\n        \\n\\n        while queue:\\n            I,J,l = queue.popleft()\\n            print(I,J)\\n            for i,j in [I -1,J],[I+1,J],[I,J-1],[I,J+1]:\\n                if 0 <= i < len(grid) and 0<=j<len(grid[0]) and grid[i][j] == 1:\\n                    queue.append((i,j,l+1))\\n                    grid[i][j] = 0\\n        #print(grid)\\n        if any(1 in row for row in grid):\\n            return -1\\n        else:\\n            return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 551658,
                "title": "python-readable-bfs-solution-beat-94",
                "content": "![image](https://assets.leetcode.com/users/jefferyzzy/image_1585196075.png)\\n\\n* Add all fresh oranges to fresh_set and append all rotten oranges to rotten_queue.\\n* Use BFS to find all fresh oranges that adjacent to the current rotten orange, turn these fresh oranges to rotten and remove these from fresh_set. In the meantime, track the steps of turning. \\n* After we finish the turning, if there is still a fresh orange in fresh_set, return -1 otherwist return the step.\\n\\nTime complexity is O(mn) where m is size of row and n is size of columns\\n\\n```\\ndef orangesRotting(self, grid: List[List[int]]) -> int:\\n        row, col = len(grid), len(grid[0])\\n        dirs = [(-1,0),(0,1),(1,0),(0,-1)]\\n        fresh_set=set()\\n        rotten = collections.deque()\\n        step = 0\\n        for x in range(row):\\n            for y in range(col):\\n                if grid[x][y]==1:\\n                    fresh_set.add((x,y))\\n                elif grid[x][y]==2:\\n                    rotten.append([x,y,step])\\n        while rotten:\\n            x,y,step = rotten.popleft()\\n            for dx, dy in dirs:\\n                if 0<=x+dx<row and 0<=y+dy<col and grid[x+dx][y+dy] == 1:\\n                    grid[x+dx][y+dy]=2\\n                    fresh_set.remove((x+dx,y+dy))\\n                    rotten.append([x+dx,y+dy,step+1])\\n        return step if not fresh_set else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef orangesRotting(self, grid: List[List[int]]) -> int:\\n        row, col = len(grid), len(grid[0])\\n        dirs = [(-1,0),(0,1),(1,0),(0,-1)]\\n        fresh_set=set()\\n        rotten = collections.deque()\\n        step = 0\\n        for x in range(row):\\n            for y in range(col):\\n                if grid[x][y]==1:\\n                    fresh_set.add((x,y))\\n                elif grid[x][y]==2:\\n                    rotten.append([x,y,step])\\n        while rotten:\\n            x,y,step = rotten.popleft()\\n            for dx, dy in dirs:\\n                if 0<=x+dx<row and 0<=y+dy<col and grid[x+dx][y+dy] == 1:\\n                    grid[x+dx][y+dy]=2\\n                    fresh_set.remove((x+dx,y+dy))\\n                    rotten.append([x+dx,y+dy,step+1])\\n        return step if not fresh_set else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1362979,
                "title": "python-bfs-the-most-standard-answer-template-for-bfs-question",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        \"\"\"\\n        Step 1: recogonise this is a BFS problem with 4 direction finding neighbor\\n        Step 2: before we go into BFS, we need to do some preparation steps\\n        Step 3: run BFS\\n        \\n        When should we run BFS? It has 2 cases:\\n        One is after finding all the initial elements,\\n        the other is after finding exactly one initial element\\n        In this question, we should note that if we have 2 rotten orange in the beginning, they will infect at the same time. \\n\\t\\t\\n\\t\\tFor example, if the other one has fresh neighbor, the 2nd rotten orange will infect also in the beginning. \\n\\t\\tSo we can not write BFS after finding exactly one rotten orange, we need to put them into the same level at the initial.\\n        put all the initial elements into the queue. for example, we have rotten orange in position 1 and 3. So the level is\\n        1  3\\n        2  4\\n        5\\n        8\\n        9\\n        \"\"\"\\n        \\n        # Step 1: Some standard preparation work\\n        # (1). Define a row and col. (note, it depends on the question. We do not need to define\\n        # this on some questions which does not have the coordinates. This is problem is actually\\n        # array, so we need to create this.)\\n        # this is the standard writing form to define the row and col for 2-dim array\\n        row = len(grid)\\n        col = len(grid[0])\\n        \\n        # we should always think if it is a 0 matrix. In this question, we do not need to judge\\n        # since row and col is >= 1. Otherwise, we judge it like\\n        # if row == 0:\\n        #   return -1\\n        \\n        # In this question, when we return the steps after finishing?\\n        # What is the judging standard for finishing?\\n        # That is, if all the fresh oranges disappear, it means finishing\\n        # So we need to set a count for fresh orange\\n        # Do we need to also set a count for rotten orange? It seems not necessary, since\\n        # it will not act any role on the question\\n        fresh_orange = 0\\n        \\n        # (2). Define the queue and put the initial positions into the queue.\\n        # here is also depended on the proble on if we need to put coordinate into the queue\\n        # or the object itself into the queue. For example, should we put grid[0][0]\\n        # or (0, 0) into the queue? I can not say definitely on the standard, but if we meet\\n        # an array problem, we usually use coordinate.\\n        # this is the standard process to create a queue\\n        # Note here, if we come across some problems that let us solve the \\n        # symmetric problem on tree, we may need to put two root into the queue as a pair\\n        queue = deque()\\n        \\n        # to put the initial elements into the queue, we need to decide whether we let the\\n        # BFS be righ after the first one element, or we choose all the initial coordinate into the queue\\n        # first we choose all the initial elements into the queue\\n        # the standard process to find the initial elements by traversing the array\\n        # row = 3, so range(3) will be 0, 1, 2; col = 3, range(3) will be 0, 1, 2.\\n        # So we can traverse the whole coordinates\\n        for i in range(row):\\n            for j in range(col):\\n                # put what into the queue first? that is, the rotten one, grid[i][j] = 2\\n                if grid[i][j] == 2:\\n                    queue.append((i, j))\\n                # also we update the number of fresh orange\\n                elif grid[i][j] == 1:\\n                    fresh_orange += 1\\n        \\n        # Now it is time for BFS. The rule is first in, first out.\\n        # Our queue now has all the rotten oranges. For example, if 1, 3 is the rotten orange\\n        # the queue now is\\n        # ------------------------------------------------\\n        # 1  3 |\\n        # ------------------------------------------------\\n        # Now we do BFS to take out the 1st element\\n        \\n        count = 0\\n        # When is the situation to go into this BFS?\\n        # first, we need to assure our queue is not empty, that is, it must have rotten orange.\\n        # if rotten orange is 0, then it will not go into this while loop.\\n        # and when all the oranges are rotten, also not go into this while loop.\\n        while queue and fresh_orange > 0:\\n            # we need to take out the 1st element\\n            # how to do this? a standard process is below\\n            # len(queue) = 2 now, range(2) is 0, 1\\n            # this shows that, in this level, it will traverse all the elements in this level\\n            # while control the traversal from level to level\\n            for _ in range(len(queue)):\\n                x, y = queue.popleft()\\n            \\n                # after finding the first element, we need to think if we should judge something\\n                # the judge is depending on the question requirement\\n                # In this question, looks nothing needs to be judged. So we safely find the neighbor\\n                # a standard process for finding the neighbor is regularly 4 directions below\\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                    \\n                    # the candidate neighbor is here\\n                    # In other question, we may find the neighbor for example like this\\n                    # node.left; 0 -> 9, 1; a -> z, b... depending on the question\\n                    xx, yy = x + dx, y + dy\\n                    \\n                    # we first consider if this neighbor is out of the border\\n                    if xx < 0 or xx == row or yy < 0 or yy == col:\\n                        continue\\n                    \\n                    # we also need to consider, if this neighbor is fresh or empty, we continue\\n                    # note, some problems need us to judge on the 1st element, not neighbor\\n                    # so judging the 1st element or its neighbor, depending on the question\\n                    # grid[xx][yy] == 0 assures we skip the empty cell\\n                    # grid[xx][yy] == 2 assures we skip the rotten orange. This rotten orange\\n                    # may already exist, or it is the one that we marked before\\n                    # If we do not skip, then the rotten orange that we mark before will\\n                    # be added again into the queue. That is chaotic\\n                    if grid[xx][yy] == 0 or grid[xx][yy] == 2:\\n                        continue\\n                        \\n                    # so the left coordinates are the expected fresh orange\\n                    # we have found our expected neighbor, now we put them into the queue\\n                    queue.append((xx, yy))\\n                    \\n                    # we mark the neighbor as rotten\\n                    grid[xx][yy] = 2\\n                    \\n                    # we subtract our fresh orange with -1\\n                    fresh_orange -= 1\\n                \\n                    # after this cycle of finding, the queue will be\\n                    # ------------------------------------------------\\n                    #   3  |  2  4  |\\n                    # ------------------------------------------------\\n                    \\n                # this level of for loop to connitue to execute 3, after that, the queue will be\\n                # ------------------------------------------------\\n                #      |  2  4  |\\n                # ------------------------------------------------\\n            \\n            # while loop assures we do this level by level\\n            # ------------------------------------------------\\n            #      |  2  4  |\\n            # ------------------------------------------------\\n        \\n            # after finishing each level, we count + 1\\n            # here if we write count + 1 in the beginning of the while loop  \\n            # the number will not right\\n            # the difference is that, we count before finding neighbor or after finding neighbor\\n            # In this case, when we find a neighbor, the minute will add 1, so we write in the end\\n            count += 1\\n            \\n        # Finally, we show the final result\\n        # Note, this is a simple writing method\\n        return count if fresh_orange == 0 else -1\\n        \\n        # if we write in standard, it will be\\n        \"\"\"\\n        if fresh_orange == 0:\\n            return count\\n        else:\\n            return -1\\n        \"\"\"\\n\\n        \\n\"\"\"\\nThe whole process is: ( note I assume rotten is 1, 3 initially, not the example 1)\\n------------------------------------------------\\n1  3  |\\n------------------------------------------------\\n------------------------------------------------\\n   3  |  2  4  |\\n------------------------------------------------\\n------------------------------------------------\\n      |  2  4  |\\n------------------------------------------------\\n------------------------------------------------\\n      |     4  |  5\\n------------------------------------------------\\n------------------------------------------------\\n      |        |  5  |\\n------------------------------------------------\\n------------------------------------------------\\n      |        |     |  8  |\\n------------------------------------------------\\n------------------------------------------------\\n      |        |     |     |  9\\n------------------------------------------------\\nthe level is \\n1  3\\n2  4\\n5\\n8\\n9\\n\"\"\"   \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        \"\"\"\\n        Step 1: recogonise this is a BFS problem with 4 direction finding neighbor\\n        Step 2: before we go into BFS, we need to do some preparation steps\\n        Step 3: run BFS\\n        \\n        When should we run BFS? It has 2 cases:\\n        One is after finding all the initial elements,\\n        the other is after finding exactly one initial element\\n        In this question, we should note that if we have 2 rotten orange in the beginning, they will infect at the same time. \\n\\t\\t\\n\\t\\tFor example, if the other one has fresh neighbor, the 2nd rotten orange will infect also in the beginning. \\n\\t\\tSo we can not write BFS after finding exactly one rotten orange, we need to put them into the same level at the initial.\\n        put all the initial elements into the queue. for example, we have rotten orange in position 1 and 3. So the level is\\n        1  3\\n        2  4\\n        5\\n        8\\n        9\\n        \"\"\"\\n        \\n        # Step 1: Some standard preparation work\\n        # (1). Define a row and col. (note, it depends on the question. We do not need to define\\n        # this on some questions which does not have the coordinates. This is problem is actually\\n        # array, so we need to create this.)\\n        # this is the standard writing form to define the row and col for 2-dim array\\n        row = len(grid)\\n        col = len(grid[0])\\n        \\n        # we should always think if it is a 0 matrix. In this question, we do not need to judge\\n        # since row and col is >= 1. Otherwise, we judge it like\\n        # if row == 0:\\n        #   return -1\\n        \\n        # In this question, when we return the steps after finishing?\\n        # What is the judging standard for finishing?\\n        # That is, if all the fresh oranges disappear, it means finishing\\n        # So we need to set a count for fresh orange\\n        # Do we need to also set a count for rotten orange? It seems not necessary, since\\n        # it will not act any role on the question\\n        fresh_orange = 0\\n        \\n        # (2). Define the queue and put the initial positions into the queue.\\n        # here is also depended on the proble on if we need to put coordinate into the queue\\n        # or the object itself into the queue. For example, should we put grid[0][0]\\n        # or (0, 0) into the queue? I can not say definitely on the standard, but if we meet\\n        # an array problem, we usually use coordinate.\\n        # this is the standard process to create a queue\\n        # Note here, if we come across some problems that let us solve the \\n        # symmetric problem on tree, we may need to put two root into the queue as a pair\\n        queue = deque()\\n        \\n        # to put the initial elements into the queue, we need to decide whether we let the\\n        # BFS be righ after the first one element, or we choose all the initial coordinate into the queue\\n        # first we choose all the initial elements into the queue\\n        # the standard process to find the initial elements by traversing the array\\n        # row = 3, so range(3) will be 0, 1, 2; col = 3, range(3) will be 0, 1, 2.\\n        # So we can traverse the whole coordinates\\n        for i in range(row):\\n            for j in range(col):\\n                # put what into the queue first? that is, the rotten one, grid[i][j] = 2\\n                if grid[i][j] == 2:\\n                    queue.append((i, j))\\n                # also we update the number of fresh orange\\n                elif grid[i][j] == 1:\\n                    fresh_orange += 1\\n        \\n        # Now it is time for BFS. The rule is first in, first out.\\n        # Our queue now has all the rotten oranges. For example, if 1, 3 is the rotten orange\\n        # the queue now is\\n        # ------------------------------------------------\\n        # 1  3 |\\n        # ------------------------------------------------\\n        # Now we do BFS to take out the 1st element\\n        \\n        count = 0\\n        # When is the situation to go into this BFS?\\n        # first, we need to assure our queue is not empty, that is, it must have rotten orange.\\n        # if rotten orange is 0, then it will not go into this while loop.\\n        # and when all the oranges are rotten, also not go into this while loop.\\n        while queue and fresh_orange > 0:\\n            # we need to take out the 1st element\\n            # how to do this? a standard process is below\\n            # len(queue) = 2 now, range(2) is 0, 1\\n            # this shows that, in this level, it will traverse all the elements in this level\\n            # while control the traversal from level to level\\n            for _ in range(len(queue)):\\n                x, y = queue.popleft()\\n            \\n                # after finding the first element, we need to think if we should judge something\\n                # the judge is depending on the question requirement\\n                # In this question, looks nothing needs to be judged. So we safely find the neighbor\\n                # a standard process for finding the neighbor is regularly 4 directions below\\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                    \\n                    # the candidate neighbor is here\\n                    # In other question, we may find the neighbor for example like this\\n                    # node.left; 0 -> 9, 1; a -> z, b... depending on the question\\n                    xx, yy = x + dx, y + dy\\n                    \\n                    # we first consider if this neighbor is out of the border\\n                    if xx < 0 or xx == row or yy < 0 or yy == col:\\n                        continue\\n                    \\n                    # we also need to consider, if this neighbor is fresh or empty, we continue\\n                    # note, some problems need us to judge on the 1st element, not neighbor\\n                    # so judging the 1st element or its neighbor, depending on the question\\n                    # grid[xx][yy] == 0 assures we skip the empty cell\\n                    # grid[xx][yy] == 2 assures we skip the rotten orange. This rotten orange\\n                    # may already exist, or it is the one that we marked before\\n                    # If we do not skip, then the rotten orange that we mark before will\\n                    # be added again into the queue. That is chaotic\\n                    if grid[xx][yy] == 0 or grid[xx][yy] == 2:\\n                        continue\\n                        \\n                    # so the left coordinates are the expected fresh orange\\n                    # we have found our expected neighbor, now we put them into the queue\\n                    queue.append((xx, yy))\\n                    \\n                    # we mark the neighbor as rotten\\n                    grid[xx][yy] = 2\\n                    \\n                    # we subtract our fresh orange with -1\\n                    fresh_orange -= 1\\n                \\n                    # after this cycle of finding, the queue will be\\n                    # ------------------------------------------------\\n                    #   3  |  2  4  |\\n                    # ------------------------------------------------\\n                    \\n                # this level of for loop to connitue to execute 3, after that, the queue will be\\n                # ------------------------------------------------\\n                #      |  2  4  |\\n                # ------------------------------------------------\\n            \\n            # while loop assures we do this level by level\\n            # ------------------------------------------------\\n            #      |  2  4  |\\n            # ------------------------------------------------\\n        \\n            # after finishing each level, we count + 1\\n            # here if we write count + 1 in the beginning of the while loop  \\n            # the number will not right\\n            # the difference is that, we count before finding neighbor or after finding neighbor\\n            # In this case, when we find a neighbor, the minute will add 1, so we write in the end\\n            count += 1\\n            \\n        # Finally, we show the final result\\n        # Note, this is a simple writing method\\n        return count if fresh_orange == 0 else -1\\n        \\n        # if we write in standard, it will be\\n        \"\"\"\\n        if fresh_orange == 0:\\n            return count\\n        else:\\n            return -1\\n        \"\"\"\\n\\n        \\n\"\"\"\\nThe whole process is: ( note I assume rotten is 1, 3 initially, not the example 1)\\n------------------------------------------------\\n1  3  |\\n------------------------------------------------\\n------------------------------------------------\\n   3  |  2  4  |\\n------------------------------------------------\\n------------------------------------------------\\n      |  2  4  |\\n------------------------------------------------\\n------------------------------------------------\\n      |     4  |  5\\n------------------------------------------------\\n------------------------------------------------\\n      |        |  5  |\\n------------------------------------------------\\n------------------------------------------------\\n      |        |     |  8  |\\n------------------------------------------------\\n------------------------------------------------\\n      |        |     |     |  9\\n------------------------------------------------\\nthe level is \\n1  3\\n2  4\\n5\\n8\\n9\\n\"\"\"   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 518991,
                "title": "simple-java-with-detailed-explanation",
                "content": "```\\n\\t // classic BFS: keep adding rotten oranges at each level and for every rotten orange, modify its adjacent fresh oranges to rotten and keep adding them to queue till there are no more rotten oranges\\n    // TC: O(n) - where N is the number of cells in the grid. SC: O(N) - for queue space\\n    private static int orangesRotting(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\\n            return 0;\\n        }\\n        int rows = grid.length;\\n        int columns = grid[0].length;\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        int freshOranges = 0;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < columns; j++) {\\n                if (grid[i][j] == 2) {\\n                    queue.offer(new int[]{i, j});   // add rotten oranges to queue in the first level\\n                }\\n                if (grid[i][j] == 1) {\\n                    freshOranges++;    // count of fresh oranges. this is useful for us (in the end) to check if all the fresh oranges have rotten or not and return the value accordingly  \\n                }\\n            }\\n        }\\n\\n        int days = 0;   // this is basically number of levels in BFS / level order traversal\\n        int[][] directions = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  // all the possible adjacent directions of a grid value \\n        while (!queue.isEmpty() && freshOranges > 0) {    // continue the BFS till there are no more valid fresh oranges that can rotten \\n            int queueSize = queue.size();\\n            for (int i = 0; i < queueSize; i++) {\\n                int[] node = queue.poll();\\n                for (int[] dir : directions) {\\n                    int x = node[0] + dir[0];\\n                    int y = node[1] + dir[1];\\n\\n                    if (x < 0 || y < 0 || x >= rows || y >= columns || grid[x][y] == 0 || grid[x][y] == 2) {   // exceeded the boundary or the grid value is not a fresh orange, in that case just continue the loop\\n                        continue;\\n                    }\\n                    grid[x][y] = 2;    // mark the orange from fresh -> rotten\\n                    queue.offer(new int[]{x, y});  // add the rotten orange to queue \\n                    freshOranges--;\\n                }\\n            }\\n            days++;   // increment the level \\n        }\\n        return freshOranges == 0 ? days : -1;  // fact that there are no fresh oranges in the grid means all the fresh oranges in the grid have been rotten  \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t // classic BFS: keep adding rotten oranges at each level and for every rotten orange, modify its adjacent fresh oranges to rotten and keep adding them to queue till there are no more rotten oranges\\n    // TC: O(n) - where N is the number of cells in the grid. SC: O(N) - for queue space\\n    private static int orangesRotting(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\\n            return 0;\\n        }\\n        int rows = grid.length;\\n        int columns = grid[0].length;\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        int freshOranges = 0;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < columns; j++) {\\n                if (grid[i][j] == 2) {\\n                    queue.offer(new int[]{i, j});   // add rotten oranges to queue in the first level\\n                }\\n                if (grid[i][j] == 1) {\\n                    freshOranges++;    // count of fresh oranges. this is useful for us (in the end) to check if all the fresh oranges have rotten or not and return the value accordingly  \\n                }\\n            }\\n        }\\n\\n        int days = 0;   // this is basically number of levels in BFS / level order traversal\\n        int[][] directions = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  // all the possible adjacent directions of a grid value \\n        while (!queue.isEmpty() && freshOranges > 0) {    // continue the BFS till there are no more valid fresh oranges that can rotten \\n            int queueSize = queue.size();\\n            for (int i = 0; i < queueSize; i++) {\\n                int[] node = queue.poll();\\n                for (int[] dir : directions) {\\n                    int x = node[0] + dir[0];\\n                    int y = node[1] + dir[1];\\n\\n                    if (x < 0 || y < 0 || x >= rows || y >= columns || grid[x][y] == 0 || grid[x][y] == 2) {   // exceeded the boundary or the grid value is not a fresh orange, in that case just continue the loop\\n                        continue;\\n                    }\\n                    grid[x][y] = 2;    // mark the orange from fresh -> rotten\\n                    queue.offer(new int[]{x, y});  // add the rotten orange to queue \\n                    freshOranges--;\\n                }\\n            }\\n            days++;   // increment the level \\n        }\\n        return freshOranges == 0 ? days : -1;  // fact that there are no fresh oranges in the grid means all the fresh oranges in the grid have been rotten  \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978015,
                "title": "read-this-if-you-are-a-noob-like-me-dfs-full-commentary",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid,int i,int j,int time) {\\n        if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size() || grid[i][j]==0 \\n|| 1 < grid[i][j] && grid[i][j]<time) /*THIS LAST CONDITION DENOTES THAT IF THE ORANGE IS ALREADY ROTTEN BY SOME OTHER ORANGE ALREADY, IMAGEINE grid[i][j]=3 (WHICH MEANS THAT THIS GRID WAS ALREADY CHANGED BY SOME OTHER ORANGE,OTHERWISE, IT WOULD HAVE BEEN 2 )AND TIME IS 4 , NOW  1 < grid[i][j](which is 3) && grid[i][j] < 4  */ return; \\n        grid[i][j]=time; // Assign the current time to the grid\\n        dfs(grid,i-1,j,grid[i][j]+1); // Recursive call to all 4 sides one by one and by incrementing tine by +1\\n        dfs(grid,i+1,j,grid[i][j]+1);\\n        dfs(grid,i,j-1,grid[i][j]+1);\\n        dfs(grid,i,j+1,grid[i][j]+1);\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n         for(int i=0; i<grid.size(); i++) {\\n            for(int j=0; j<grid[0].size(); j++) {\\n                if(grid[i][j] == 2) dfs(grid, i, j,grid[i][j]);  // We have to proceed on those orananges which are rotten already and start a recursive call AND THE REASON WHY WE ARE SENDING 2 IS BECAUSE WE CANNOT MARK TIME AS 0,1,2 SINCE THEY ARE ALREADY BEING USED BY THE QUESION(empty cell, fresh orange,rotten orange) ITSELF\\n            }\\n        }\\n        int totalTime=2;// WE PICKED ToTAL TIME 2 BECAUSE AFTER THE COMPLETION OF THE DFS CALLS, THE MATRIX WILL BE FILLED WITH VALUES>=2.\\n        for(int i=0;i<grid.size();i++) {\\n            for(int j=0;j<grid[0].size();j++) {\\n                cout<<grid[i][j]<<\" \";\\n                if(grid[i][j]==1) return -1; // AND IF BY ANY MEANS, ANY VALUE IS 1, THAT MEANS WE WERE NOT ABLE TO ROT THAT ORANGE\\n                totalTime=max(grid[i][j],totalTime);// OTHERWISE, SELECT THE MAX TIME TO ROT\\n            }\\n            cout<<endl;\\n        }\\n        return totalTime-2;// THIS IS IMPORTANT, REMEMBER HOW WE SET TOTALTIME AS 2 ABOVE, WE ARE GONNA SUBTRACT 2 FROM THE TOTAL TIME, SO IF TOTALTIME WAS 2, ACTUAL TIME WILL BE 2-2=0 THAT MEANS, NO ORANGES TO ROT, similarly IF THE TOTAL TIME WAS 8, THAT MEANS THE ACTUAL TIME WAS 8-2=6 SECS/MINS/HRS TO ROT ALL THE ORANGES\\n    }\\n};\\n```\\n\\n\\n`For N rows and columns, I guess TC will be O(N^2)?.` **Please comment if I\\'m wrong with the complexity.**\\n\\n```\\nRuntime: 4 ms, faster than 90.04% of C++ online submissions for Rotting Oranges.\\nMemory Usage: 13 MB, less than 99.45% of C++ online submissions for Rotting Oranges.\\n```\\n\\nFeel free to ask any questions below!.",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid,int i,int j,int time) {\\n        if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size() || grid[i][j]==0 \\n|| 1 < grid[i][j] && grid[i][j]<time) /*THIS LAST CONDITION DENOTES THAT IF THE ORANGE IS ALREADY ROTTEN BY SOME OTHER ORANGE ALREADY, IMAGEINE grid[i][j]=3 (WHICH MEANS THAT THIS GRID WAS ALREADY CHANGED BY SOME OTHER ORANGE,OTHERWISE, IT WOULD HAVE BEEN 2 )AND TIME IS 4 , NOW  1 < grid[i][j](which is 3) && grid[i][j] < 4  */ return; \\n        grid[i][j]=time; // Assign the current time to the grid\\n        dfs(grid,i-1,j,grid[i][j]+1); // Recursive call to all 4 sides one by one and by incrementing tine by +1\\n        dfs(grid,i+1,j,grid[i][j]+1);\\n        dfs(grid,i,j-1,grid[i][j]+1);\\n        dfs(grid,i,j+1,grid[i][j]+1);\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n         for(int i=0; i<grid.size(); i++) {\\n            for(int j=0; j<grid[0].size(); j++) {\\n                if(grid[i][j] == 2) dfs(grid, i, j,grid[i][j]);  // We have to proceed on those orananges which are rotten already and start a recursive call AND THE REASON WHY WE ARE SENDING 2 IS BECAUSE WE CANNOT MARK TIME AS 0,1,2 SINCE THEY ARE ALREADY BEING USED BY THE QUESION(empty cell, fresh orange,rotten orange) ITSELF\\n            }\\n        }\\n        int totalTime=2;// WE PICKED ToTAL TIME 2 BECAUSE AFTER THE COMPLETION OF THE DFS CALLS, THE MATRIX WILL BE FILLED WITH VALUES>=2.\\n        for(int i=0;i<grid.size();i++) {\\n            for(int j=0;j<grid[0].size();j++) {\\n                cout<<grid[i][j]<<\" \";\\n                if(grid[i][j]==1) return -1; // AND IF BY ANY MEANS, ANY VALUE IS 1, THAT MEANS WE WERE NOT ABLE TO ROT THAT ORANGE\\n                totalTime=max(grid[i][j],totalTime);// OTHERWISE, SELECT THE MAX TIME TO ROT\\n            }\\n            cout<<endl;\\n        }\\n        return totalTime-2;// THIS IS IMPORTANT, REMEMBER HOW WE SET TOTALTIME AS 2 ABOVE, WE ARE GONNA SUBTRACT 2 FROM THE TOTAL TIME, SO IF TOTALTIME WAS 2, ACTUAL TIME WILL BE 2-2=0 THAT MEANS, NO ORANGES TO ROT, similarly IF THE TOTAL TIME WAS 8, THAT MEANS THE ACTUAL TIME WAS 8-2=6 SECS/MINS/HRS TO ROT ALL THE ORANGES\\n    }\\n};\\n```\n```\\nRuntime: 4 ms, faster than 90.04% of C++ online submissions for Rotting Oranges.\\nMemory Usage: 13 MB, less than 99.45% of C++ online submissions for Rotting Oranges.\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1807141,
                "title": "full-explanation-c-bfs-well-explained",
                "content": "**Strategy:** \\nThe idea is to count fresh oranges and store indices of all rotten oranges given in the starting. Then traverse through these stored indices and if any fresh orange is found in all the four directions of these indices, we will make it rotten orange and reduce the fresh oranges count by one. At last, if fresh oranges count is 0, we will return total time elapsed till now. Else return -1. \\n\\n*So, how we should store and traverse through the rotten orange indices and count time elapsed?* \\nAnswer is to use **BFS(Breadth First Search)** technique. The key observation to use this technique is that assume all the initial rotten oranges are at level 0. Then the adjacent fresh oranges to these rotten oranges are in level 1 and are rotten on day 1 and the next in level 2 and rotten on day 2 and so on.  This is similar to level order traversal and therefore, the time required to rot all the possible fresh oranges will be equal to the number of levels.\\nAs we will be using BFS, so we will store indices of rotten oranges in queue.\\n\\n**Approach:**\\n1. Initialize a queue for breadth first search in which we will store indices of rotten oranges and freshOranges variable to count number of fresh oranges present in the grid initially. Also initialize our answer variable time.\\n\\t```\\n\\tint freshOranges = 0, time = 0;\\n\\tqueue<pair<int, int>> q; \\n\\t```\\n2. Iterate over the entire grid and add indices of all the rotten oranges in the queue and also keep counting the number of fresh oranges.\\n\\t```\\n\\tfor(int i = 0; i < grid.size(); i++) {\\n\\t\\tfor(int j = 0; j < grid[0].size(); j++) {\\n\\t\\t\\tif(grid[i][j] == 1)\\n\\t\\t\\t\\tfreshOranges++;\\n\\t\\t\\telse if(grid[i][j] == 2)\\n\\t\\t\\t\\tq.push({i, j});\\n\\t\\t}\\n\\t}\\n\\t```\\n* *Here we can simply return 0 if fresh oranges count is still 0 after traversing the entire gird as all the oranges given in the grid are already rotten, so 0 time will be taken to rot them.*\\n3. Now traverse the queue in level order fashion.\\n\\t```\\n\\twhile(!q.empty()) {\\n\\t\\tint n = q.size();\\n        while(n--) {\\n               //code\\n\\t\\t }\\n    }\\n\\t```\\n\\t\\n\\tAt every level, take out front of queue and check in its all four directions, whether a fresh orange is present or not, taking care of boundary conditions. If a fresh orange is found, make it rotten, push its index in the queue and decrement fresh oranges count by one.\\n\\t```cpp\\n\\tint x = q.front().first;\\n\\tint y = q.front().second;\\n\\tq.pop();\\n\\t//top\\n\\tif(x - 1 >= 0 && grid[x-1][y] == 1) {\\n\\t\\tgrid[x-1][y] = 2;\\n\\t\\tq.push({x-1, y});\\n\\t\\tfreshOranges--;\\n\\t}\\n\\t//left\\n\\tif(y - 1 >= 0 && grid[x][y-1] == 1) {\\n\\t\\tgrid[x][y-1] = 2;\\n\\t\\tq.push({x, y-1});\\n\\t\\tfreshOranges--;\\n\\t}\\n\\t//down\\n\\tif(x + 1 < grid.size() && grid[x+1][y] == 1) {\\n\\t\\tgrid[x+1][y] = 2;\\n\\t\\tq.push({x+1, y});\\n\\t\\tfreshOranges--;\\n\\t}\\n\\t//right\\n\\tif(y + 1 < grid[0].size() && grid[x][[y+1] == 1) {\\n\\t\\tgrid[x][y+1] = 2;\\n\\t\\tq.push({x, y+1});\\n\\t\\tfreshOranges--;\\n\\t}\\n\\t```\\n\\t* *Here we can make our code more readable by changing the instructions, like make an array of dx and dy for the adjacent indices i.e.,*\\n\\t\\t```\\n\\t\\tint dx[] = {0, 0, 1, -1};\\n\\t\\tint dy[] = {1, -1, 0, 0};\\n\\t\\t```\\n\\t\\t*and check for adjacent oranges as*\\n\\t\\t```\\n\\t\\tfor(int i = 0; i < 4; ++i) {\\n\\t\\t\\tint nx = x + dx[i], ny = y + dy[i];\\n            if(nx >= 0 && nx < grid.size() && ny >= 0 && ny < grid[0].size() && grid[nx][ny] == 1) {\\n\\t\\t\\t\\tgrid[nx][ny] = 2;\\n                q.push({nx, ny});\\n                freshOranges--;\\n\\t\\t\\t}\\n\\t\\t }\\n\\t\\t```\\n\\tAfter traversal of one complete level, we will increment time by one if the queue is not empty. We are incrementing time by checking this conditions as in the last level all oranges will be already rotten. So we don\\'t want to increment our time in that situation.\\n\\t\\n\\t\\n\\tSo, we ended with:\\n\\t```cpp\\n\\twhile(!q.empty()) {\\n\\t\\tint n = q.size();\\n\\t\\twhile(n--) {\\n\\t\\t\\tint x = q.front().first, y = q.front().second;\\n\\t\\t\\tq.pop();\\n\\t\\t\\tfor(int i = 0; i < 4; ++i) {\\n\\t\\t\\t\\tint nx = x + dx[i], ny = y + dy[i];\\n\\t\\t\\t\\tif(nx >= 0 && nx < grid.size() && ny >= 0 && ny < grid[0].size() && grid[nx][ny] == 1) {\\n\\t\\t\\t\\t\\tgrid[nx][ny] = 2;\\n\\t\\t\\t\\t\\tq.push({nx, ny});\\n\\t\\t\\t\\t\\tfreshOranges--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(!q.empty())\\n\\t\\t\\ttime++;\\n\\t}\\n\\t```\\n4.\\tAt last, If the number of fresh oranges after the entire process is zero, then return the time elapsed till now. Else return -1 indicating that it\\u2019s impossible to rot all the oranges.\\n\\t```\\n\\tif(freshOranges == 0)\\n\\t\\treturn time;\\n\\telse\\n\\t\\treturn -1;\\n\\t```\\n\\n**Dry Run:**\\nLets\\' take an example, grid = [[2,1,1],[1,1,0],[0,1,1]]\\n![image](https://assets.leetcode.com/users/images/65b22705-0cc9-4afb-93d1-3b6d0ce91b85_1646064148.1020083.jpeg)\\n![image](https://assets.leetcode.com/users/images/7454109f-fa58-409f-8a4a-618f6ea605c1_1646064162.615776.jpeg)\\n![image](https://assets.leetcode.com/users/images/8ae4ec0f-f5eb-4505-8932-a0f00ead3f77_1646064173.1493309.jpeg)\\n![image](https://assets.leetcode.com/users/images/f0122139-e1cf-49fe-8125-cfc8848cf244_1646064181.6202948.jpeg)\\n\\n\\n**Complete Code:**\\n```\\nint orangesRotting(vector<vector<int>>& grid) {        \\n\\tint freshOranges = 0, time = 0;\\n    queue<pair<int, int>> q;\\n        \\n    for(int i = 0; i < grid.size(); i++) {\\n\\t\\tfor(int j = 0; j < grid[0].size(); j++) {\\n\\t\\t\\tif(grid[i][j] == 1)\\n\\t\\t\\t\\tfreshOranges++;\\n            else if(grid[i][j] == 2)\\n\\t\\t\\t\\tq.push({i, j});\\n        }\\n    }\\n        \\n\\tint dx[] = {0, 0, 1, -1};\\n    int dy[] = {1, -1, 0, 0};\\n        \\n    while(!q.empty()) {\\n\\t\\tint n = q.size();\\n        while(n--) {\\n\\t\\t\\tint x = q.front().first, y = q.front().second;\\n            q.pop();\\n            for(int i = 0; i < 4; ++i) {\\n\\t\\t\\t\\tint nx = x + dx[i], ny = y + dy[i];\\n                if(nx >= 0 && nx < grid.size() && ny >= 0 && ny < grid[0].size() && grid[nx][ny] == 1) {\\n\\t\\t\\t\\t\\tgrid[nx][ny] = 2;\\n                    q.push({nx, ny});\\n                    freshOranges--;\\n                }\\n            }\\n        }\\n        if(!q.empty())\\n            time++;\\n    }\\n        \\n    if(freshOranges == 0)\\n        return time;\\n    else\\n        return -1;\\n}\\n```\\n\\t\\n\\n\\t\\n\\t\\n\\t\\n\\n**Complexity Analysis:**\\n* *Time Complexity -* `O(n x m) + O(n x m)`  =>  `O(n x m)`\\n\\t* `O(n x m)` for first traversal \\n\\t* `O(n x m)` for queue traversal (*Worst Case when there is only one fresh orange and that too in last*)\\n* *Space Complexity -* `O(n x m)`\\n\\tExtra space for queue (*Worst Case: when all given oranges are rotten*)\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\tint freshOranges = 0, time = 0;\\n\\tqueue<pair<int, int>> q; \\n\\t```\n```\\n\\tfor(int i = 0; i < grid.size(); i++) {\\n\\t\\tfor(int j = 0; j < grid[0].size(); j++) {\\n\\t\\t\\tif(grid[i][j] == 1)\\n\\t\\t\\t\\tfreshOranges++;\\n\\t\\t\\telse if(grid[i][j] == 2)\\n\\t\\t\\t\\tq.push({i, j});\\n\\t\\t}\\n\\t}\\n\\t```\n```\\n\\twhile(!q.empty()) {\\n\\t\\tint n = q.size();\\n        while(n--) {\\n               //code\\n\\t\\t }\\n    }\\n\\t```\n```cpp\\n\\tint x = q.front().first;\\n\\tint y = q.front().second;\\n\\tq.pop();\\n\\t//top\\n\\tif(x - 1 >= 0 && grid[x-1][y] == 1) {\\n\\t\\tgrid[x-1][y] = 2;\\n\\t\\tq.push({x-1, y});\\n\\t\\tfreshOranges--;\\n\\t}\\n\\t//left\\n\\tif(y - 1 >= 0 && grid[x][y-1] == 1) {\\n\\t\\tgrid[x][y-1] = 2;\\n\\t\\tq.push({x, y-1});\\n\\t\\tfreshOranges--;\\n\\t}\\n\\t//down\\n\\tif(x + 1 < grid.size() && grid[x+1][y] == 1) {\\n\\t\\tgrid[x+1][y] = 2;\\n\\t\\tq.push({x+1, y});\\n\\t\\tfreshOranges--;\\n\\t}\\n\\t//right\\n\\tif(y + 1 < grid[0].size() && grid[x][[y+1] == 1) {\\n\\t\\tgrid[x][y+1] = 2;\\n\\t\\tq.push({x, y+1});\\n\\t\\tfreshOranges--;\\n\\t}\\n\\t```\n```\\n\\t\\tint dx[] = {0, 0, 1, -1};\\n\\t\\tint dy[] = {1, -1, 0, 0};\\n\\t\\t```\n```\\n\\t\\tfor(int i = 0; i < 4; ++i) {\\n\\t\\t\\tint nx = x + dx[i], ny = y + dy[i];\\n            if(nx >= 0 && nx < grid.size() && ny >= 0 && ny < grid[0].size() && grid[nx][ny] == 1) {\\n\\t\\t\\t\\tgrid[nx][ny] = 2;\\n                q.push({nx, ny});\\n                freshOranges--;\\n\\t\\t\\t}\\n\\t\\t }\\n\\t\\t```\n```cpp\\n\\twhile(!q.empty()) {\\n\\t\\tint n = q.size();\\n\\t\\twhile(n--) {\\n\\t\\t\\tint x = q.front().first, y = q.front().second;\\n\\t\\t\\tq.pop();\\n\\t\\t\\tfor(int i = 0; i < 4; ++i) {\\n\\t\\t\\t\\tint nx = x + dx[i], ny = y + dy[i];\\n\\t\\t\\t\\tif(nx >= 0 && nx < grid.size() && ny >= 0 && ny < grid[0].size() && grid[nx][ny] == 1) {\\n\\t\\t\\t\\t\\tgrid[nx][ny] = 2;\\n\\t\\t\\t\\t\\tq.push({nx, ny});\\n\\t\\t\\t\\t\\tfreshOranges--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(!q.empty())\\n\\t\\t\\ttime++;\\n\\t}\\n\\t```\n```\\n\\tif(freshOranges == 0)\\n\\t\\treturn time;\\n\\telse\\n\\t\\treturn -1;\\n\\t```\n```\\nint orangesRotting(vector<vector<int>>& grid) {        \\n\\tint freshOranges = 0, time = 0;\\n    queue<pair<int, int>> q;\\n        \\n    for(int i = 0; i < grid.size(); i++) {\\n\\t\\tfor(int j = 0; j < grid[0].size(); j++) {\\n\\t\\t\\tif(grid[i][j] == 1)\\n\\t\\t\\t\\tfreshOranges++;\\n            else if(grid[i][j] == 2)\\n\\t\\t\\t\\tq.push({i, j});\\n        }\\n    }\\n        \\n\\tint dx[] = {0, 0, 1, -1};\\n    int dy[] = {1, -1, 0, 0};\\n        \\n    while(!q.empty()) {\\n\\t\\tint n = q.size();\\n        while(n--) {\\n\\t\\t\\tint x = q.front().first, y = q.front().second;\\n            q.pop();\\n            for(int i = 0; i < 4; ++i) {\\n\\t\\t\\t\\tint nx = x + dx[i], ny = y + dy[i];\\n                if(nx >= 0 && nx < grid.size() && ny >= 0 && ny < grid[0].size() && grid[nx][ny] == 1) {\\n\\t\\t\\t\\t\\tgrid[nx][ny] = 2;\\n                    q.push({nx, ny});\\n                    freshOranges--;\\n                }\\n            }\\n        }\\n        if(!q.empty())\\n            time++;\\n    }\\n        \\n    if(freshOranges == 0)\\n        return time;\\n    else\\n        return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 485756,
                "title": "bfs-with-no-map-visited-and-no-loop-after-the-bfs-to-count-with-some-explanation",
                "content": "It\\'s a pretty standard, simple BFS. We count total number of fresh oranges and push all rotten oranges to queue.\\nThen for every rotten orange at this level, we run a loop numer of items in this level times, have a counter if this level turned any fresh orange to rotten. The process continues until queue is empty. We subtract every time we turn a fresh to rotten, and push the new rotten orange and in the end if we still have fresh oranges left, we couldn\\'t infect(or reach) them all, otherwise we did!\\nUsing visited as predecessor for finding the path is a good idea though, except we don\\'t need that in this question.\\n```\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int min = 0, fresh = 0;\\n        queue<pair<int, int>> q;\\n        for(int i = 0; i < grid.size(); i++) {\\n            for(int j = 0; j < grid[0].size(); j++)\\n                if(grid[i][j] == 1) fresh++;\\n                else if(grid[i][j] == 2) q.push({i, j});\\n        }\\n        vector<pair<int, int>> dirs = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };\\n        while(!q.empty()) {\\n            int n = q.size();\\n            bool rotten = false;\\n            for(int i = 0; i < n; i++) {\\n                auto x = q.front();\\n                q.pop();\\n                for(auto cur: dirs) {\\n                    int i = x.first + cur.first;\\n                    int j = x.second + cur.second;\\n                    if(i >= 0 && i < grid.size() && j >= 0 && j < grid[0].size() && grid[i][j] == 1) {\\n                        grid[i][j] = 2;\\n                        q.push({i, j});\\n                        fresh--;\\n                        rotten = true;\\n                    }\\n                }\\n            }\\n            if(rotten) min++;\\n        } \\n        return fresh ? -1 : min;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int min = 0, fresh = 0;\\n        queue<pair<int, int>> q;\\n        for(int i = 0; i < grid.size(); i++) {\\n            for(int j = 0; j < grid[0].size(); j++)\\n                if(grid[i][j] == 1) fresh++;\\n                else if(grid[i][j] == 2) q.push({i, j});\\n        }\\n        vector<pair<int, int>> dirs = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };\\n        while(!q.empty()) {\\n            int n = q.size();\\n            bool rotten = false;\\n            for(int i = 0; i < n; i++) {\\n                auto x = q.front();\\n                q.pop();\\n                for(auto cur: dirs) {\\n                    int i = x.first + cur.first;\\n                    int j = x.second + cur.second;\\n                    if(i >= 0 && i < grid.size() && j >= 0 && j < grid[0].size() && grid[i][j] == 1) {\\n                        grid[i][j] = 2;\\n                        q.push({i, j});\\n                        fresh--;\\n                        rotten = true;\\n                    }\\n                }\\n            }\\n            if(rotten) min++;\\n        } \\n        return fresh ? -1 : min;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 239032,
                "title": "python-solution",
                "content": "Idea: We do BFS simultaneously from all rotten oranges, while using a counter to keep track of the number of fresh oranges that has become rotten. Once the counter is equal to the total number of fresh oranges, we return the number of days elapsed. If after the BFS, the counter is less than the total number of fresh oranges, we return `-1`.\\n\\nTime complexity: `O(n)`, space complexity: `O(n)`, where `n` is the total number of cells.\\n\\n```\\nclass Solution(object):\\n    def orangesRotting(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(grid)\\n        m = len(grid[0])\\n        count = 0\\n        q = collections.deque()\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == 1:\\n                    count += 1\\n                elif grid[i][j] == 2:\\n                    q.append((i,j,0))\\n        seen = set()\\n        while q:\\n            y, x, d = q.popleft()\\n            dirs = {(y-1,x),(y+1,x),(y,x+1),(y,x-1)}\\n            for y1,x1 in dirs:\\n                if 0 <= y1 < n and 0 <= x1 < m and (y1, x1) not in seen and grid[y1][x1] == 1:\\n                    seen.add((y1,x1))\\n                    count -= 1\\n                    if count == 0:\\n                        return d+1\\n                    q.append((y1, x1, d+1))\\n        return 0 if count == 0 else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def orangesRotting(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(grid)\\n        m = len(grid[0])\\n        count = 0\\n        q = collections.deque()\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == 1:\\n                    count += 1\\n                elif grid[i][j] == 2:\\n                    q.append((i,j,0))\\n        seen = set()\\n        while q:\\n            y, x, d = q.popleft()\\n            dirs = {(y-1,x),(y+1,x),(y,x+1),(y,x-1)}\\n            for y1,x1 in dirs:\\n                if 0 <= y1 < n and 0 <= x1 < m and (y1, x1) not in seen and grid[y1][x1] == 1:\\n                    seen.add((y1,x1))\\n                    count -= 1\\n                    if count == 0:\\n                        return d+1\\n                    q.append((y1, x1, d+1))\\n        return 0 if count == 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 239659,
                "title": "dfs-bfs-clean-code",
                "content": "If we regard initially rotten oranges to start nodes, and perform **DFS** traversal, then newly rotten oranges will be \"new\" start nodes, etc.\\n\\n**How shall we tell whether all fresh oranges are able to be rotten?**\\nWe can keep track of number of fresh oranges left during the DFS traversal.\\nIf no newly rotten oranges invovled (thus not able to keep traversing), but there are still fresh oranges, we simply return -1.\\n\\n> DFS\\n```\\nclass Solution {\\n    private static final int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    \\n    public int orangesRotting(int[][] grid) {\\n        int numFreshOranges = 0;\\n        Set<Integer> curRotten = new HashSet<>();\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++) \\n                if (grid[i][j] == 1)\\n                    numFreshOranges++;\\n                else if (grid[i][j] == 2)\\n                    curRotten.add(i * grid[0].length + j);\\n        return rottenFrom(grid, numFreshOranges, curRotten);\\n    }\\n            \\n    private int rottenFrom(int[][] grid, int numFreshOranges, Set<Integer> curRotten) {\\n        if (0 == numFreshOranges) {\\n            return 0;\\n        } else if (curRotten.isEmpty()) {\\n            return -1;\\n        } else {\\n            Set<Integer> nextRotten = new HashSet<>();\\n            \\n            for (int rottenMark : curRotten) {\\n                int x = rottenMark / grid[0].length, y = rottenMark % grid[0].length;\\n                for (int[] direction : directions) {\\n                    int nx = x + direction[0], ny = y + direction[1];\\n                    if (nx < grid.length && nx >= 0 && ny < grid[0].length && ny >= 0 && grid[nx][ny] == 1) { // grid[nx][ny] is rotten.\\n                        numFreshOranges--;\\n                        grid[nx][ny] = 2;\\n                        nextRotten.add(nx * grid[0].length + ny);\\n                    }\\n                }\\n            }\\n\\n            int minutes = rottenFrom(grid, numFreshOranges, nextRotten);\\n            return minutes == -1 ? minutes : minutes + 1;\\n        }\\n    }\\n\\n}\\n```\\n\\n> BFS\\n```\\n    private static final int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    private int rows, cols;\\n\\n    public int orangesRotting(int[][] grid) {\\n        rows = grid.length;\\n        cols = grid[0].length;\\n        int numEmpty = 0, minutes = 0;\\n        Deque<Integer> queue = new LinkedList<>();\\n        Set<Integer> rottenSet = new HashSet<>();\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == 0) { // empty\\n                    numEmpty++;\\n                } else if (grid[i][j] == 2) { // rotten\\n                    rottenSet.add(i * cols + j);\\n                    queue.offer(i * cols + j);\\n                }\\n            }\\n        }\\n        \\n        // Breadth first search.\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int toRot = queue.poll();\\n                int x = toRot / cols;\\n                int y = toRot % cols;\\n                rottenAround(grid, queue, x, y, rottenSet);\\n            }\\n            minutes++;\\n        }\\n        \\n        if (rottenSet.size() != rows * cols - numEmpty)\\n            return -1;\\n        else\\n            return (minutes > 0) ? minutes - 1 : minutes;\\n    }\\n\\n    private void rottenAround(int[][] grid, Deque<Integer> queue, int x, int y, Set<Integer> rottenSet) {\\n        for (int[] direction : directions) {\\n            int nx = x + direction[0];\\n            int ny = y + direction[1];\\n            int nmark = nx * cols + ny;\\n            if (nx < rows && nx >= 0 && ny < cols && ny >= 0 && grid[nx][ny] == 1 && !rottenSet.contains(nmark)) {\\n                rottenSet.add(nmark);\\n                queue.add(nmark);\\n            }\\n        }\\n    }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private static final int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    \\n    public int orangesRotting(int[][] grid) {\\n        int numFreshOranges = 0;\\n        Set<Integer> curRotten = new HashSet<>();\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++) \\n                if (grid[i][j] == 1)\\n                    numFreshOranges++;\\n                else if (grid[i][j] == 2)\\n                    curRotten.add(i * grid[0].length + j);\\n        return rottenFrom(grid, numFreshOranges, curRotten);\\n    }\\n            \\n    private int rottenFrom(int[][] grid, int numFreshOranges, Set<Integer> curRotten) {\\n        if (0 == numFreshOranges) {\\n            return 0;\\n        } else if (curRotten.isEmpty()) {\\n            return -1;\\n        } else {\\n            Set<Integer> nextRotten = new HashSet<>();\\n            \\n            for (int rottenMark : curRotten) {\\n                int x = rottenMark / grid[0].length, y = rottenMark % grid[0].length;\\n                for (int[] direction : directions) {\\n                    int nx = x + direction[0], ny = y + direction[1];\\n                    if (nx < grid.length && nx >= 0 && ny < grid[0].length && ny >= 0 && grid[nx][ny] == 1) { // grid[nx][ny] is rotten.\\n                        numFreshOranges--;\\n                        grid[nx][ny] = 2;\\n                        nextRotten.add(nx * grid[0].length + ny);\\n                    }\\n                }\\n            }\\n\\n            int minutes = rottenFrom(grid, numFreshOranges, nextRotten);\\n            return minutes == -1 ? minutes : minutes + 1;\\n        }\\n    }\\n\\n}\\n```\n```\\n    private static final int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    private int rows, cols;\\n\\n    public int orangesRotting(int[][] grid) {\\n        rows = grid.length;\\n        cols = grid[0].length;\\n        int numEmpty = 0, minutes = 0;\\n        Deque<Integer> queue = new LinkedList<>();\\n        Set<Integer> rottenSet = new HashSet<>();\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == 0) { // empty\\n                    numEmpty++;\\n                } else if (grid[i][j] == 2) { // rotten\\n                    rottenSet.add(i * cols + j);\\n                    queue.offer(i * cols + j);\\n                }\\n            }\\n        }\\n        \\n        // Breadth first search.\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int toRot = queue.poll();\\n                int x = toRot / cols;\\n                int y = toRot % cols;\\n                rottenAround(grid, queue, x, y, rottenSet);\\n            }\\n            minutes++;\\n        }\\n        \\n        if (rottenSet.size() != rows * cols - numEmpty)\\n            return -1;\\n        else\\n            return (minutes > 0) ? minutes - 1 : minutes;\\n    }\\n\\n    private void rottenAround(int[][] grid, Deque<Integer> queue, int x, int y, Set<Integer> rottenSet) {\\n        for (int[] direction : directions) {\\n            int nx = x + direction[0];\\n            int ny = y + direction[1];\\n            int nmark = nx * cols + ny;\\n            if (nx < rows && nx >= 0 && ny < cols && ny >= 0 && grid[nx][ny] == 1 && !rottenSet.contains(nmark)) {\\n                rottenSet.add(nmark);\\n                queue.add(nmark);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 280964,
                "title": "python-44-ms-faster-than-99-87",
                "content": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        rotten = []\\n        # build initial array of rotten oranges\\n        rows = len(grid)\\n        columns = len(grid[0])\\n        for i in range(rows):\\n            for j in range(columns):\\n                if grid[i][j] == 2:\\n                    rotten.append((i, j))\\n\\n        # get unvisited neighbors of all rotten oranges\\n        def add_neighbors(rotten):\\n            neighbors = []\\n            for i, j in rotten:\\n                if i > 0 and grid[i - 1][j] == 1:\\n                    neighbors.append((i - 1, j))\\n                    grid[i-1][j] = 2\\n                if j > 0 and grid[i][j - 1] == 1:\\n                    neighbors.append((i, j - 1))\\n                    grid[i][j-1] = 2\\n                if i < rows - 1 and grid[i + 1][j] == 1:\\n                    neighbors.append((i + 1, j))\\n                    grid[i + 1][j] = 2\\n                if j < columns - 1 and grid[i][j + 1] == 1:\\n                    neighbors.append((i, j + 1))\\n                    grid[i][j+1] = 2\\n            return neighbors\\n\\n        minutes = 0\\n        while (1):\\n            rotten = add_neighbors(rotten)\\n            if len(rotten) == 0:\\n                break\\n            minutes += 1\\n\\n        for i in range(rows):\\n            for j in range(columns):\\n                if grid[i][j] == 1:\\n                    return -1\\n\\n        return minutes\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        rotten = []\\n        # build initial array of rotten oranges\\n        rows = len(grid)\\n        columns = len(grid[0])\\n        for i in range(rows):\\n            for j in range(columns):\\n                if grid[i][j] == 2:\\n                    rotten.append((i, j))\\n\\n        # get unvisited neighbors of all rotten oranges\\n        def add_neighbors(rotten):\\n            neighbors = []\\n            for i, j in rotten:\\n                if i > 0 and grid[i - 1][j] == 1:\\n                    neighbors.append((i - 1, j))\\n                    grid[i-1][j] = 2\\n                if j > 0 and grid[i][j - 1] == 1:\\n                    neighbors.append((i, j - 1))\\n                    grid[i][j-1] = 2\\n                if i < rows - 1 and grid[i + 1][j] == 1:\\n                    neighbors.append((i + 1, j))\\n                    grid[i + 1][j] = 2\\n                if j < columns - 1 and grid[i][j + 1] == 1:\\n                    neighbors.append((i, j + 1))\\n                    grid[i][j+1] = 2\\n            return neighbors\\n\\n        minutes = 0\\n        while (1):\\n            rotten = add_neighbors(rotten)\\n            if len(rotten) == 0:\\n                break\\n            minutes += 1\\n\\n        for i in range(rows):\\n            for j in range(columns):\\n                if grid[i][j] == 1:\\n                    return -1\\n\\n        return minutes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395202,
                "title": "c-bfs-each-line-clearly-explained-4ms",
                "content": "# Feel free to post your doubts in comment\\n **Give a like if it helped you**\\n\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        // Question involves BFS\\n        // there can be multiple rotten oranges, so its a multi source BFS\\n        // since we need to get the time also when the orange is rotting\\n        // and for any orange that will be time(parent)+1\\n        // so we can take queue of  ( vector of size 3 ) \\n        // v[0]:row , v[1]:column , v[2]:time\\n        int time = 0; // to get the max time\\n        queue<vector<int>> q;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        // insert all the rotten oranges as source in queue\\n        for( int i=0; i<n; i++ ){\\n            for( int j=0; j<m; j++ ){\\n                if( grid[i][j]==2 )\\n                    q.push( {i,j,0} );\\n            }\\n        }     \\n        \\n        int x[]={0,0,1,-1};\\n        int y[]={1,-1,0,0};\\n        \\n        while( !q.empty() ){\\n            \\n            auto f = q.front(); // rotten orange at the front of queue\\n            \\n            // now check all its adjacent cells\\n            for( int i=0; i<4; i++){\\n                int r=f[0]+x[i] ,c=f[1]+y[i];\\n                if( r<0 || r>=n || c<0 || c>=m || grid[r][c]!=1 ) continue; // check if it is valid fresh orange cell\\n                grid[r][c]=2; // make the fresh orange as rotten\\n                int t = f[2] + 1; // time at which this orange became rotten\\n                time = max( time, t ); // update the max time to return ans answer\\n                q.push( {r,c,t} ); // push this rotten orange to queue\\n            }\\n            \\n            q.pop();\\n        }\\n        \\n        // now the max time is stored in \"time\"\\n        // but before returning this we need to check if there is any fresh orange left\\n        for( int i=0; i<n; i++ ){\\n            for( int j=0; j<m; j++ ){\\n                if( grid[i][j]==1 )\\n                    return -1;\\n            }\\n        } \\n        \\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        // Question involves BFS\\n        // there can be multiple rotten oranges, so its a multi source BFS\\n        // since we need to get the time also when the orange is rotting\\n        // and for any orange that will be time(parent)+1\\n        // so we can take queue of  ( vector of size 3 ) \\n        // v[0]:row , v[1]:column , v[2]:time\\n        int time = 0; // to get the max time\\n        queue<vector<int>> q;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        // insert all the rotten oranges as source in queue\\n        for( int i=0; i<n; i++ ){\\n            for( int j=0; j<m; j++ ){\\n                if( grid[i][j]==2 )\\n                    q.push( {i,j,0} );\\n            }\\n        }     \\n        \\n        int x[]={0,0,1,-1};\\n        int y[]={1,-1,0,0};\\n        \\n        while( !q.empty() ){\\n            \\n            auto f = q.front(); // rotten orange at the front of queue\\n            \\n            // now check all its adjacent cells\\n            for( int i=0; i<4; i++){\\n                int r=f[0]+x[i] ,c=f[1]+y[i];\\n                if( r<0 || r>=n || c<0 || c>=m || grid[r][c]!=1 ) continue; // check if it is valid fresh orange cell\\n                grid[r][c]=2; // make the fresh orange as rotten\\n                int t = f[2] + 1; // time at which this orange became rotten\\n                time = max( time, t ); // update the max time to return ans answer\\n                q.push( {r,c,t} ); // push this rotten orange to queue\\n            }\\n            \\n            q.pop();\\n        }\\n        \\n        // now the max time is stored in \"time\"\\n        // but before returning this we need to check if there is any fresh orange left\\n        for( int i=0; i<n; i++ ){\\n            for( int j=0; j<m; j++ ){\\n                if( grid[i][j]==1 )\\n                    return -1;\\n            }\\n        } \\n        \\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782483,
                "title": "easy-to-understand-fastest-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        if (grid.empty())\\n\\t\\t{\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tint countFreshOranges = 0;\\n\\t\\tsize_t m = grid.size();\\n\\t\\tsize_t n = grid[0].size();\\n\\t\\tqueue<pair<int, int>> q;\\n\\n\\t\\tfor (size_t i = 0; i < m; ++i)\\n\\t\\t{\\n\\t\\t\\tfor (size_t j = 0; j < n; ++j)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (grid[i][j] == 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t++countFreshOranges;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (grid[i][j] == 2)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tq.push({ i, j });\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint time = 0;\\n\\t\\tvector<pair<int, int>> dirs = { {0, 1}, {1, 0}, {-1, 0}, {0, -1} };\\n\\n\\t\\twhile (countFreshOranges != 0 && !q.empty())\\n\\t\\t{\\n\\t\\t\\tsize_t qsize = q.size();\\n\\n\\t\\t\\tfor (size_t i = 0; i < qsize; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tauto [rottenI, rottenJ] = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\n\\t\\t\\t\\tfor (const auto& d : dirs)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint newX = rottenI + d.first;\\n\\t\\t\\t\\t\\tint newY = rottenJ + d.second;\\n\\t\\t\\t\\t\\tif (newX >= 0 && newX < m && newY >= 0 && newY < n && grid[newX][newY] == 1)\\n\\t\\t\\t\\t\\t{\\n                        grid[newX][newY] = 2;\\n\\t\\t\\t\\t\\t\\t--countFreshOranges;\\n\\t\\t\\t\\t\\t\\tq.push({ newX, newY });\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t++time;\\n\\t\\t}\\n\\t\\treturn countFreshOranges == 0 ? time : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        if (grid.empty())\\n\\t\\t{\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tint countFreshOranges = 0;\\n\\t\\tsize_t m = grid.size();\\n\\t\\tsize_t n = grid[0].size();\\n\\t\\tqueue<pair<int, int>> q;\\n\\n\\t\\tfor (size_t i = 0; i < m; ++i)\\n\\t\\t{\\n\\t\\t\\tfor (size_t j = 0; j < n; ++j)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (grid[i][j] == 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t++countFreshOranges;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (grid[i][j] == 2)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tq.push({ i, j });\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint time = 0;\\n\\t\\tvector<pair<int, int>> dirs = { {0, 1}, {1, 0}, {-1, 0}, {0, -1} };\\n\\n\\t\\twhile (countFreshOranges != 0 && !q.empty())\\n\\t\\t{\\n\\t\\t\\tsize_t qsize = q.size();\\n\\n\\t\\t\\tfor (size_t i = 0; i < qsize; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tauto [rottenI, rottenJ] = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\n\\t\\t\\t\\tfor (const auto& d : dirs)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint newX = rottenI + d.first;\\n\\t\\t\\t\\t\\tint newY = rottenJ + d.second;\\n\\t\\t\\t\\t\\tif (newX >= 0 && newX < m && newY >= 0 && newY < n && grid[newX][newY] == 1)\\n\\t\\t\\t\\t\\t{\\n                        grid[newX][newY] = 2;\\n\\t\\t\\t\\t\\t\\t--countFreshOranges;\\n\\t\\t\\t\\t\\t\\tq.push({ newX, newY });\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t++time;\\n\\t\\t}\\n\\t\\treturn countFreshOranges == 0 ? time : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781882,
                "title": "python-by-bfs-timestamp-w-demo",
                "content": "Python by BFS + timestamp\\n\\n---\\n\\n**Demo**\\n\\n![image](https://assets.leetcode.com/users/images/5290c275-c04e-42b8-9fe5-29930811a80d_1597835250.418689.png)\\n\\nInitial State\\n\\n![image](https://assets.leetcode.com/users/images/ee379b21-3755-494d-aa27-9d9fc2dca7f9_1597835275.0473213.png)\\n\\nStart BFS to infect oranges\\n\\n![image](https://assets.leetcode.com/users/images/59633ce4-b149-46cd-bc76-1d7f0aa7594f_1597835297.3446114.png)\\n\\n![image](https://assets.leetcode.com/users/images/fb3617b6-5813-4e57-9897-e611e17cf39d_1597835308.5351524.png)\\n\\n![image](https://assets.leetcode.com/users/images/c5ac7438-6bc3-4f2c-b109-a5097c398b55_1597835319.6775134.png)\\n\\n![image](https://assets.leetcode.com/users/images/067ea220-c6a3-4225-b64f-85ff78966eb0_1597835333.6524165.png)\\n\\n\\n\\n\\n---\\n\\n```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        # Constant for grid state\\n        VISITED = -1\\n        EMPTY = 0\\n        FRESH = 1\\n        ROTTEN = 2\\n        \\n        # Get dimension of grid\\n        h, w = len(grid), len(grid[0])\\n        \\n        # record for fresh oranges\\n        fresh_count = 0\\n        \\n        # record for position of initial rotten oranges\\n        rotten_grid = []       \\n        \\n        # board prescan for parameter initialization\\n        for y in range(h):\\n            for x in range(w):\\n                \\n                if grid[y][x] == FRESH:\\n                    fresh_count += 1\\n                    \\n                elif grid[y][x] == ROTTEN:\\n                    rotten_grid.append( (x, y, 0) )\\n                    \\n        traversal_queue = deque(rotten_grid)\\n        \\n        time_record = 0\\n        \\n        # BFS to rotting oranges\\n        while traversal_queue and fresh_count:\\n            \\n            x, y, time_stamp = traversal_queue.popleft()\\n            \\n            for dx, dy in ( (-1, 0), (+1, 0), (0, -1), (0, +1) ):\\n                \\n                next_x, next_y = x + dx, y + dy\\n                \\n                if 0 <= next_x < w and 0 <= next_y < h and grid[next_y][next_x] == FRESH:\\n                    \\n                    fresh_count -= 1\\n                    grid[next_y][next_x] = VISITED\\n                    \\n                    # update time record\\n                    time_record = time_stamp + 1 \\n                    \\n                    # adding current rotten orange to traversal queue\\n                    traversal_queue.append( (next_x, next_y, time_stamp + 1) )\\n        \\n        \\n        # ================================\\n        # All oranges are infected\\n        if fresh_count == 0:\\n            return time_record\\n        \\n        # Some orange remains finally\\n        return -1\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about deque](https://docs.python.org/3/library/collections.html#collections.deque)\\n\\n[2] [Wiki: BFS](https://en.wikipedia.org/wiki/Breadth-first_search)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        # Constant for grid state\\n        VISITED = -1\\n        EMPTY = 0\\n        FRESH = 1\\n        ROTTEN = 2\\n        \\n        # Get dimension of grid\\n        h, w = len(grid), len(grid[0])\\n        \\n        # record for fresh oranges\\n        fresh_count = 0\\n        \\n        # record for position of initial rotten oranges\\n        rotten_grid = []       \\n        \\n        # board prescan for parameter initialization\\n        for y in range(h):\\n            for x in range(w):\\n                \\n                if grid[y][x] == FRESH:\\n                    fresh_count += 1\\n                    \\n                elif grid[y][x] == ROTTEN:\\n                    rotten_grid.append( (x, y, 0) )\\n                    \\n        traversal_queue = deque(rotten_grid)\\n        \\n        time_record = 0\\n        \\n        # BFS to rotting oranges\\n        while traversal_queue and fresh_count:\\n            \\n            x, y, time_stamp = traversal_queue.popleft()\\n            \\n            for dx, dy in ( (-1, 0), (+1, 0), (0, -1), (0, +1) ):\\n                \\n                next_x, next_y = x + dx, y + dy\\n                \\n                if 0 <= next_x < w and 0 <= next_y < h and grid[next_y][next_x] == FRESH:\\n                    \\n                    fresh_count -= 1\\n                    grid[next_y][next_x] = VISITED\\n                    \\n                    # update time record\\n                    time_record = time_stamp + 1 \\n                    \\n                    # adding current rotten orange to traversal queue\\n                    traversal_queue.append( (next_x, next_y, time_stamp + 1) )\\n        \\n        \\n        # ================================\\n        # All oranges are infected\\n        if fresh_count == 0:\\n            return time_record\\n        \\n        # Some orange remains finally\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781550,
                "title": "c-3-solutions-compared-and-explained-trading-space-for-time-90-time-100-space",
                "content": "Ah, nothing beats stretching your mind in the morning with a nice finite state machine - I guess?\\n\\nAnyway, the problem is pretty straightforward to understand, but not so trivial to execute properly: first of all I declare at class level 2 variables, `maxX` and `maxY`, that I initialised respectively as the number of columns `- 1` and the number of rowss `- 1` first thing when I start my main function.\\n\\nI then declare my usual accumulator `res` to keep track of how many ticks I go with my machine and `freshCount`, that will tell me if there are still fresh oranges around.\\n\\nA convenient vector `toRot` will then store the oranges that I found need to change state to rotten (`2`) in the next tick, avoding me the expensive functional approach of cloning the grid at each step: thanks, but no thanks.\\n\\nOkay, now we are ready to go - first time I used a `do {} while ()` loop in a while, but I think it is the most appropriate here, since we need to run it at least once, to know if there are still fresh oranges and optionally gather other info on the grid.\\n\\nAt each tick (ie: each iteration of the loop), we also start with a nice reset of `freshCount`, `hasRotted`, and `toRot`, then we have the typical nested `for` loop you always do when navigating grid (and always remember you need to use the `y` first when accessing elements with the `[]` operator).\\n\\nIf we find a fresh (`1`) orange, two things can happen (*tertium non datur* in boolean logic):\\n* it has rotten neighbours and if so, we add its coordinates to `toRot` and set `hasRotted` to `true`;\\n* it does not have rotten neighbours, so we increment `freshCount` by `1`.\\n\\nWe shamelessly ignore empty (`0`) or already rotten (`2`) cells, as they are inconsequential while looping; we check the rotten ones only as neighbours, using our handy and pretty straightforward `hasRottenNeighbour` helper that, as the name implies, returns a `true` value if any of the adjacent cells is rotten.\\n\\nOnce done with the 2 nested loops, we can safely update the grid, taking all the coordinates we collected into `toRot` and setting them to `2`; `res` is increased everytime `hasRotted` is `true`.\\n\\nIf a loop goes by without `hasRotted` being set to `true`, we exit and we are ready to return `-1` is there are still fresh oranges as represented by a truthy (ie: `!0`) value of `freshCount` or `res` otherwise.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // declaring grid max coordinates here, not to have to pass them down as parameters\\n    int maxX, maxY;\\n    bool hasRottenNeighbour(vector<vector<int>>& grid, int x, int y) {\\n        // checking for for rotten neighbours left, up, right and down\\n        return (x && grid[y][x - 1] == 2) + (y && grid[y - 1][x] == 2) + (x < maxX && grid[y][x + 1] == 2) + (y < maxY && grid[y + 1][x] == 2);\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        maxY = grid.size() - 1, maxX = grid[0].size() - 1;\\n        int res = 0, freshCount;\\n        bool hasRotted;\\n        vector<pair<int, int>> toRot;\\n        do {\\n            // resetting tracking variables\\n            freshCount = 0;\\n            hasRotted = false;\\n            toRot.clear();\\n            // looping through the grid\\n            for (int y = 0; y <= maxY; y++) {\\n                for (int x = 0; x <= maxX; x++) {\\n                    if (grid[y][x] == 1) {\\n                        if (hasRottenNeighbour(grid, x, y)) {\\n                            toRot.push_back({x, y});\\n                            hasRotted = true;\\n                        }\\n                        else freshCount++;\\n                    }\\n                }\\n            }\\n            // updating the grid with the oranges that should rot at this tick\\n            for (auto e: toRot) grid[e.second][e.first] = 2;\\n            res += hasRotted;\\n        } while (hasRotted);\\n        return freshCount ? -1 : res;\\n    }\\n};\\n```\\n\\nVariant tracking and looping only through fresh oranges stored in `currFresh`, which basically equates trading some space to get a faster execution (~96% Time, ~70% Space). The rest of the logic is mostly the same:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // declaring grid max coordinates here, not to have to pass them down as parameters\\n    int maxX, maxY;\\n    bool hasRottenNeighbour(vector<vector<int>>& grid, int x, int y) {\\n        // checking for for rotten neighbours left, up, right and down\\n        return (x && grid[y][x - 1] == 2) + (y && grid[y - 1][x] == 2) + (x < maxX && grid[y][x + 1] == 2) + (y < maxY && grid[y + 1][x] == 2);\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        maxY = grid.size() - 1, maxX = grid[0].size() - 1;\\n        int res = 0, x, y;\\n        bool hasRotten;\\n        vector<pair<int, int>> toRot, prevFresh, currFresh;\\n        // looping through the grid to find the fresh ones\\n        for (int y = 0; y <= maxY; y++) {\\n            for (int x = 0; x <= maxX; x++) {\\n                if (grid[y][x] == 1) currFresh.push_back({x, y});\\n            }\\n        }\\n        do {\\n            prevFresh = currFresh;\\n            // resetting tracking variables\\n            hasRotten = false;\\n            toRot.clear();\\n            currFresh.clear();\\n            // looping only through all the fresh oranges from the previous tick\\n            for (auto e: prevFresh) {\\n                x = e.first;\\n                y = e.second;\\n                if (hasRottenNeighbour(grid, x, y)) {\\n                    toRot.push_back({x, y});\\n                    hasRotten = true;\\n                }\\n                else currFresh.push_back({x, y});\\n            }\\n            // updating the grid with the oranges that should rot at this tick\\n            for (auto e: toRot) grid[e.second][e.first] = 2;\\n            res += hasRotten;\\n        } while (hasRotten);\\n        return currFresh.size() ? -1 : res;\\n    }\\n};\\n```\\n\\nYou might think `queue`s would work much better, but I guess unless you have a significantly bigger grid, that is hardly the case, giving me more or less the same performance of the one above with 2 vectors to keep track of the fresh ones:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // declaring grid max coordinates here, not to have to pass them down as parameters\\n    int maxX, maxY;\\n    bool hasRottenNeighbour(vector<vector<int>>& grid, int x, int y) {\\n        // checking for for rotten neighbours left, up, right and down\\n        return (x && grid[y][x - 1] == 2) + (y && grid[y - 1][x] == 2) + (x < maxX && grid[y][x + 1] == 2) + (y < maxY && grid[y + 1][x] == 2);\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        maxY = grid.size() - 1, maxX = grid[0].size() - 1;\\n        int res = 0, x, y, qLen;\\n        bool hasRotten;\\n        vector<pair<int, int>> toRot;\\n        queue<pair<int, int>> currFresh;\\n        // looping through the grid to find the fresh ones\\n        for (int y = 0; y <= maxY; y++) {\\n            for (int x = 0; x <= maxX; x++) {\\n                if (grid[y][x] == 1) currFresh.push({x, y});\\n            }\\n        }\\n        do {\\n            // resetting tracking variables\\n            hasRotten = false;\\n            toRot.clear();\\n            qLen = currFresh.size();\\n            // looping only through all the fresh oranges from the previous tick\\n            for (int i = 0; i < qLen; i++) {\\n                x = currFresh.front().first;\\n                y = currFresh.front().second;\\n                currFresh.pop();\\n                if (hasRottenNeighbour(grid, x, y)) {\\n                    toRot.push_back({x, y});\\n                    hasRotten = true;\\n                }\\n                else currFresh.push({x, y});\\n            }\\n            // updating the grid with the oranges that should rot at this tick\\n            for (auto e: toRot) grid[e.second][e.first] = 2;\\n            res += hasRotten;\\n        } while (hasRotten);\\n        return qLen ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // declaring grid max coordinates here, not to have to pass them down as parameters\\n    int maxX, maxY;\\n    bool hasRottenNeighbour(vector<vector<int>>& grid, int x, int y) {\\n        // checking for for rotten neighbours left, up, right and down\\n        return (x && grid[y][x - 1] == 2) + (y && grid[y - 1][x] == 2) + (x < maxX && grid[y][x + 1] == 2) + (y < maxY && grid[y + 1][x] == 2);\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        maxY = grid.size() - 1, maxX = grid[0].size() - 1;\\n        int res = 0, freshCount;\\n        bool hasRotted;\\n        vector<pair<int, int>> toRot;\\n        do {\\n            // resetting tracking variables\\n            freshCount = 0;\\n            hasRotted = false;\\n            toRot.clear();\\n            // looping through the grid\\n            for (int y = 0; y <= maxY; y++) {\\n                for (int x = 0; x <= maxX; x++) {\\n                    if (grid[y][x] == 1) {\\n                        if (hasRottenNeighbour(grid, x, y)) {\\n                            toRot.push_back({x, y});\\n                            hasRotted = true;\\n                        }\\n                        else freshCount++;\\n                    }\\n                }\\n            }\\n            // updating the grid with the oranges that should rot at this tick\\n            for (auto e: toRot) grid[e.second][e.first] = 2;\\n            res += hasRotted;\\n        } while (hasRotted);\\n        return freshCount ? -1 : res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    // declaring grid max coordinates here, not to have to pass them down as parameters\\n    int maxX, maxY;\\n    bool hasRottenNeighbour(vector<vector<int>>& grid, int x, int y) {\\n        // checking for for rotten neighbours left, up, right and down\\n        return (x && grid[y][x - 1] == 2) + (y && grid[y - 1][x] == 2) + (x < maxX && grid[y][x + 1] == 2) + (y < maxY && grid[y + 1][x] == 2);\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        maxY = grid.size() - 1, maxX = grid[0].size() - 1;\\n        int res = 0, x, y;\\n        bool hasRotten;\\n        vector<pair<int, int>> toRot, prevFresh, currFresh;\\n        // looping through the grid to find the fresh ones\\n        for (int y = 0; y <= maxY; y++) {\\n            for (int x = 0; x <= maxX; x++) {\\n                if (grid[y][x] == 1) currFresh.push_back({x, y});\\n            }\\n        }\\n        do {\\n            prevFresh = currFresh;\\n            // resetting tracking variables\\n            hasRotten = false;\\n            toRot.clear();\\n            currFresh.clear();\\n            // looping only through all the fresh oranges from the previous tick\\n            for (auto e: prevFresh) {\\n                x = e.first;\\n                y = e.second;\\n                if (hasRottenNeighbour(grid, x, y)) {\\n                    toRot.push_back({x, y});\\n                    hasRotten = true;\\n                }\\n                else currFresh.push_back({x, y});\\n            }\\n            // updating the grid with the oranges that should rot at this tick\\n            for (auto e: toRot) grid[e.second][e.first] = 2;\\n            res += hasRotten;\\n        } while (hasRotten);\\n        return currFresh.size() ? -1 : res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    // declaring grid max coordinates here, not to have to pass them down as parameters\\n    int maxX, maxY;\\n    bool hasRottenNeighbour(vector<vector<int>>& grid, int x, int y) {\\n        // checking for for rotten neighbours left, up, right and down\\n        return (x && grid[y][x - 1] == 2) + (y && grid[y - 1][x] == 2) + (x < maxX && grid[y][x + 1] == 2) + (y < maxY && grid[y + 1][x] == 2);\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        maxY = grid.size() - 1, maxX = grid[0].size() - 1;\\n        int res = 0, x, y, qLen;\\n        bool hasRotten;\\n        vector<pair<int, int>> toRot;\\n        queue<pair<int, int>> currFresh;\\n        // looping through the grid to find the fresh ones\\n        for (int y = 0; y <= maxY; y++) {\\n            for (int x = 0; x <= maxX; x++) {\\n                if (grid[y][x] == 1) currFresh.push({x, y});\\n            }\\n        }\\n        do {\\n            // resetting tracking variables\\n            hasRotten = false;\\n            toRot.clear();\\n            qLen = currFresh.size();\\n            // looping only through all the fresh oranges from the previous tick\\n            for (int i = 0; i < qLen; i++) {\\n                x = currFresh.front().first;\\n                y = currFresh.front().second;\\n                currFresh.pop();\\n                if (hasRottenNeighbour(grid, x, y)) {\\n                    toRot.push_back({x, y});\\n                    hasRotten = true;\\n                }\\n                else currFresh.push({x, y});\\n            }\\n            // updating the grid with the oranges that should rot at this tick\\n            for (auto e: toRot) grid[e.second][e.first] = 2;\\n            res += hasRotten;\\n        } while (hasRotten);\\n        return qLen ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 444291,
                "title": "javascript-solution",
                "content": "### The idea\\n1. Use BFS - search level by level, each level = another minute\\n2. Get the original rotten oranges, and start bfs from them\\n``` javascript\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar orangesRotting = function(grid) {\\n    let queue = [];\\n    let minutes = 0;\\n    let fresh = 0;\\n    for (let i=0;i<grid.length;i++) {\\n        for (let j=0;j<grid[0].length;j++) {\\n            if (grid[i][j]==1) fresh++;\\n            if (grid[i][j]==2) queue.push([i, j]);\\n        }\\n    }\\n\\n    while (queue.length!=0 && fresh) {\\n        let dR = [0,-1,0,1];\\n        let dC = [-1,0,1,0];\\n        \\n        let next = [];\\n        while (queue.length!=0 ) {\\n            let current = queue.shift();\\n            for (let i=0;i<dR.length;i++) {\\n                let nR = current[0]+dR[i];\\n                let nC = current[1]+dC[i];\\n                if (nR>=0 && nC>=0 && nR<grid.length && nC<grid[0].length) {\\n                    if (grid[nR][nC]==1) {\\n                        grid[nR][nC]=2;\\n                        fresh--;\\n                        next.push([nR,nC]);\\n                    }\\n                }\\n            }\\n        }\\n        minutes++;\\n        queue = next;\\n    }\\n\\n    return fresh==0?minutes:-1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar orangesRotting = function(grid) {\\n    let queue = [];\\n    let minutes = 0;\\n    let fresh = 0;\\n    for (let i=0;i<grid.length;i++) {\\n        for (let j=0;j<grid[0].length;j++) {\\n            if (grid[i][j]==1) fresh++;\\n            if (grid[i][j]==2) queue.push([i, j]);\\n        }\\n    }\\n\\n    while (queue.length!=0 && fresh) {\\n        let dR = [0,-1,0,1];\\n        let dC = [-1,0,1,0];\\n        \\n        let next = [];\\n        while (queue.length!=0 ) {\\n            let current = queue.shift();\\n            for (let i=0;i<dR.length;i++) {\\n                let nR = current[0]+dR[i];\\n                let nC = current[1]+dC[i];\\n                if (nR>=0 && nC>=0 && nR<grid.length && nC<grid[0].length) {\\n                    if (grid[nR][nC]==1) {\\n                        grid[nR][nC]=2;\\n                        fresh--;\\n                        next.push([nR,nC]);\\n                    }\\n                }\\n            }\\n        }\\n        minutes++;\\n        queue = next;\\n    }\\n\\n    return fresh==0?minutes:-1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 243995,
                "title": "the-marker-technique-and-a-trick-to-avoid-corner-cases",
                "content": "**Note**--- This code is not as compact and short as other codes posted here. I\\'m just posting it here to introduce the concept of ***Marker*** during level order traversal, which essentially avoids using another queue to denote the end of a level. Moreover, a lot of questions on matrices often require checking for boundary cases, (which can lead to Segmentation fault if not done properly). Below, I\\'ve included a simple trick to get rid of this problem. \\n\\n* We create a boolean function **legal()** which takes 2 parameters as input, the row and the column number of a particular cell and returns **True** if that cell is within bounds, else it returns **False**. This way we can stop worrying about corner cases if we use the **legal()** function before accessing any cell.\\n* We create a **Marker**, namely the pair **(-1,-1)** and push it into the queue whenever a level finishes. Whenever we pop a marker, it denotes the completion of another level, so any popping of a marker would immediately be followed by pushing of another marker. \\n\\n\\n**Credits** ---- Both the **Marker** technique and the **legal()** technique is inspired by the general coding style of **GeekForGeeks**.\\n```\\nclass Solution\\n{\\n    int ROW, COL;\\n    vector<vector<bool>> visited;\\n    queue<pair<int,int>> myQueue;\\npublic:\\n    bool legal(int row, int col);\\n    void visitTheCell(int i, int j, vector<vector<int>> &mat);\\n    int orangesRotting(vector<vector<int>>& grid);\\n};\\n\\n/* Utility function to check if the index is in bounds or not */\\nbool Solution :: legal(int row, int col)\\n{\\n    if(row>=0 && row<ROW && col>=0 && col<COL) return true;\\n    else return false;\\n}\\n\\n/* This function visits the cell (i,j) given the constraints */\\nvoid Solution :: visitTheCell(int i, int j, vector<vector<int>> &mat)\\n{\\n    // In bounds and not visited and should contain fresh oranges\\n    if(legal(i,j) && !visited[i][j] && mat[i][j]==1)\\n    {\\n        // Push it on the queue to rot other oranges, and visit it\\n        myQueue.push(make_pair(i,j));\\n        visited[i][j] = true;\\n    }\\n}\\n\\nint Solution :: orangesRotting(vector<vector<int>> &mat)\\n{\\n    ROW = mat.size();\\n    COL = mat[0].size();\\n    \\n    // Set the delimiter to record time\\n    auto deLimiter = make_pair(-1,-1);\\n\\n    // Resize the viisted matrix and set it to false\\n    visited.resize(ROW);\\n    for(auto &row_vec : visited)\\n        row_vec.resize(COL);\\n    \\n    // Traverse the matrix and store the cells with rotten oranges\\n    for(int i=0; i<ROW; i++)\\n        for(int j=0; j<COL; j++)\\n            if(mat[i][j] == 2) myQueue.push(make_pair(i,j));\\n            \\n    // Now that all the rottten oranges are stored, Push the deLimiter\\n    myQueue.push(deLimiter);\\n    \\n    // Create the counter from -1 as the first deLimiter is misleading, the first set of oranges\\n    // take no time to rot as they are already rotted\\n    int __time=-1;\\n    \\n    // Apply BFS\\n    while(!myQueue.empty())\\n    {\\n        while(myQueue.front()!=deLimiter)\\n        {\\n            // Extract the current element and rot all the neighbours\\n            auto current = myQueue.front();\\n            myQueue.pop();\\n            \\n            // Store the location of cells\\n            int i, j;\\n            i = current.first;\\n            j = current.second;\\n            \\n            // Visit all the neighbours\\n            \\n            // Up \\n            visitTheCell(i-1,j,mat);\\n            \\n            // Down\\n            visitTheCell(i+1,j,mat);\\n            \\n            // Left\\n            visitTheCell(i,j-1,mat);\\n            \\n            // Right\\n            visitTheCell(i,j+1,mat);\\n        }\\n        \\n        // So now we have a deLimiter, pop it and see if the queue is empty\\n        // If it is not, insert a new deLimiter\\n        \\n        myQueue.pop();\\n        \\n        // Increase the time as delimiter has been popped \\n        __time++;\\n        \\n        // Check if deLimiter has to be pushed\\n        if(!myQueue.empty()) myQueue.push(deLimiter);\\n    }\\n    \\n    bool isFreshOrangeLeft = false;\\n    \\n    // Traverse and check if all the oranges have been rotted or not\\n    for(int i=0; i<ROW; i++)\\n        for(int j=0; j<COL; j++)\\n            if(mat[i][j]==1 && !visited[i][j]) isFreshOrangeLeft = true;\\n    \\n    if(isFreshOrangeLeft) return -1;\\n    else return __time;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    int ROW, COL;\\n    vector<vector<bool>> visited;\\n    queue<pair<int,int>> myQueue;\\npublic:\\n    bool legal(int row, int col);\\n    void visitTheCell(int i, int j, vector<vector<int>> &mat);\\n    int orangesRotting(vector<vector<int>>& grid);\\n};\\n\\n/* Utility function to check if the index is in bounds or not */\\nbool Solution :: legal(int row, int col)\\n{\\n    if(row>=0 && row<ROW && col>=0 && col<COL) return true;\\n    else return false;\\n}\\n\\n/* This function visits the cell (i,j) given the constraints */\\nvoid Solution :: visitTheCell(int i, int j, vector<vector<int>> &mat)\\n{\\n    // In bounds and not visited and should contain fresh oranges\\n    if(legal(i,j) && !visited[i][j] && mat[i][j]==1)\\n    {\\n        // Push it on the queue to rot other oranges, and visit it\\n        myQueue.push(make_pair(i,j));\\n        visited[i][j] = true;\\n    }\\n}\\n\\nint Solution :: orangesRotting(vector<vector<int>> &mat)\\n{\\n    ROW = mat.size();\\n    COL = mat[0].size();\\n    \\n    // Set the delimiter to record time\\n    auto deLimiter = make_pair(-1,-1);\\n\\n    // Resize the viisted matrix and set it to false\\n    visited.resize(ROW);\\n    for(auto &row_vec : visited)\\n        row_vec.resize(COL);\\n    \\n    // Traverse the matrix and store the cells with rotten oranges\\n    for(int i=0; i<ROW; i++)\\n        for(int j=0; j<COL; j++)\\n            if(mat[i][j] == 2) myQueue.push(make_pair(i,j));\\n            \\n    // Now that all the rottten oranges are stored, Push the deLimiter\\n    myQueue.push(deLimiter);\\n    \\n    // Create the counter from -1 as the first deLimiter is misleading, the first set of oranges\\n    // take no time to rot as they are already rotted\\n    int __time=-1;\\n    \\n    // Apply BFS\\n    while(!myQueue.empty())\\n    {\\n        while(myQueue.front()!=deLimiter)\\n        {\\n            // Extract the current element and rot all the neighbours\\n            auto current = myQueue.front();\\n            myQueue.pop();\\n            \\n            // Store the location of cells\\n            int i, j;\\n            i = current.first;\\n            j = current.second;\\n            \\n            // Visit all the neighbours\\n            \\n            // Up \\n            visitTheCell(i-1,j,mat);\\n            \\n            // Down\\n            visitTheCell(i+1,j,mat);\\n            \\n            // Left\\n            visitTheCell(i,j-1,mat);\\n            \\n            // Right\\n            visitTheCell(i,j+1,mat);\\n        }\\n        \\n        // So now we have a deLimiter, pop it and see if the queue is empty\\n        // If it is not, insert a new deLimiter\\n        \\n        myQueue.pop();\\n        \\n        // Increase the time as delimiter has been popped \\n        __time++;\\n        \\n        // Check if deLimiter has to be pushed\\n        if(!myQueue.empty()) myQueue.push(deLimiter);\\n    }\\n    \\n    bool isFreshOrangeLeft = false;\\n    \\n    // Traverse and check if all the oranges have been rotted or not\\n    for(int i=0; i<ROW; i++)\\n        for(int j=0; j<COL; j++)\\n            if(mat[i][j]==1 && !visited[i][j]) isFreshOrangeLeft = true;\\n    \\n    if(isFreshOrangeLeft) return -1;\\n    else return __time;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781863,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        Queue<int[]> queue = new LinkedList();\\n        int freshCount = 0;\\n        for (int i = 0; i < grid.length; i++){\\n            for (int j = 0; j < grid[0].length; j++){\\n                if (grid[i][j] == 2)\\n                    queue.add(new int[]{i, j});\\n                if (grid[i][j] == 1)\\n                    freshCount ++;\\n            }\\n        }\\n        int time = 0;\\n        int [][] directions = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        while(!queue.isEmpty() && freshCount > 0){\\n            time ++;\\n            int size = queue.size();\\n            while(size > 0){\\n                int [] xy = queue.poll();\\n                for(int [] d : directions){\\n                    int x = xy[0] + d[0];\\n                    int y = xy[1] + d[1];\\n                    if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == 0 || grid[x][y] == 2)\\n                        continue;\\n                    queue.add(new int []{x, y});\\n                    grid[x][y] = 2;\\n                    freshCount --;\\n                } \\n                size --;\\n            }\\n        }\\n        return freshCount == 0 ? time : -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        Queue<int[]> queue = new LinkedList();\\n        int freshCount = 0;\\n        for (int i = 0; i < grid.length; i++){\\n            for (int j = 0; j < grid[0].length; j++){\\n                if (grid[i][j] == 2)\\n                    queue.add(new int[]{i, j});\\n                if (grid[i][j] == 1)\\n                    freshCount ++;\\n            }\\n        }\\n        int time = 0;\\n        int [][] directions = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        while(!queue.isEmpty() && freshCount > 0){\\n            time ++;\\n            int size = queue.size();\\n            while(size > 0){\\n                int [] xy = queue.poll();\\n                for(int [] d : directions){\\n                    int x = xy[0] + d[0];\\n                    int y = xy[1] + d[1];\\n                    if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == 0 || grid[x][y] == 2)\\n                        continue;\\n                    queue.add(new int []{x, y});\\n                    grid[x][y] = 2;\\n                    freshCount --;\\n                } \\n                size --;\\n            }\\n        }\\n        return freshCount == 0 ? time : -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734240,
                "title": "python3-solution-using-two-sets-beats-99-with-explanation",
                "content": "We don\\'t need to traverse the whole grid in every iteration. Specially if the oranges are scarse in the grid, traversing the whole grid will waste a lot of time. What I do, is that I use two sets to save the coordinates of the fresh and rotten oranges. So in my code fresh_coords is the set of the coordinates for the fresh oranges and rotten_coords is the set of coordinates for the rotten ones.\\n\\nAt every iteration, I check the neigbors of the fresh oranges, if there is a rotten orange in the 4 directional neighbors, I add that coordinate to the newly_rotten set. At the end, if the newly_rotten set is empty, it means that there is no way to rotten all of the oragnes. If it is not empty, I just remove those coordinates from the fresh_coords and add them to the rotten_coords, without changing anything in the grid. \\n\\nThis solution runs very fast, because number of fresh oranges will be decreasing over time, and as a result the outer most loop which is ```for fresh in fresh_coords: ```  will become shorter.\\n\\n```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        if not grid:\\n            return 0\\n        fresh_coords = set()\\n        rotten_coords = set()\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if grid[i][j] == 1:\\n                    fresh_coords.add((i, j))\\n                elif grid[i][j] == 2:\\n                    rotten_coords.add((i, j))\\n                    \\n        return self.recursive(fresh_coords, rotten_coords, rows, cols)\\n        \\n    \\n    def recursive(self, fresh_coords, rotten_coords, rows, cols):\\n        if not fresh_coords:\\n            return 0\\n        if not rotten_coords:\\n            return -1\\n        newly_rotten = set()\\n        \\n        # start finding newly rotten oranges\\n        for fresh in fresh_coords:\\n            for neighbor in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\\n                x = fresh[0] + neighbor[0]\\n                y = fresh[1] + neighbor[1]\\n                if x >= 0 and x < rows and y >= 0 and y < cols and (x, y) in rotten_coords:\\n                    newly_rotten.add(fresh)\\n                            \\n        \\'\\'\\'\\n\\t\\tif there is no newly_rotten orange, it means there is no way to \\n\\t\\treach the fresh ones; remember that we have already made \\n\\t\\tsure that there are fresh oranges in the grid by checking the \\n\\t\\tnumber of fresh ones at the start of the recursive function.\\n\\t\\t\\'\\'\\'\\n        if not newly_rotten:\\n            return -1\\n        else:\\n            for coords in newly_rotten:\\n                fresh_coords.remove(coords)\\n                rotten_coords.add(coords)\\n                \\n            temp = self.recursive(fresh_coords, rotten_coords, rows, cols)\\n            if temp == -1:\\n                return -1\\n            else:\\n                return 1 + temp\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```for fresh in fresh_coords: ```\n```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        if not grid:\\n            return 0\\n        fresh_coords = set()\\n        rotten_coords = set()\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if grid[i][j] == 1:\\n                    fresh_coords.add((i, j))\\n                elif grid[i][j] == 2:\\n                    rotten_coords.add((i, j))\\n                    \\n        return self.recursive(fresh_coords, rotten_coords, rows, cols)\\n        \\n    \\n    def recursive(self, fresh_coords, rotten_coords, rows, cols):\\n        if not fresh_coords:\\n            return 0\\n        if not rotten_coords:\\n            return -1\\n        newly_rotten = set()\\n        \\n        # start finding newly rotten oranges\\n        for fresh in fresh_coords:\\n            for neighbor in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\\n                x = fresh[0] + neighbor[0]\\n                y = fresh[1] + neighbor[1]\\n                if x >= 0 and x < rows and y >= 0 and y < cols and (x, y) in rotten_coords:\\n                    newly_rotten.add(fresh)\\n                            \\n        \\'\\'\\'\\n\\t\\tif there is no newly_rotten orange, it means there is no way to \\n\\t\\treach the fresh ones; remember that we have already made \\n\\t\\tsure that there are fresh oranges in the grid by checking the \\n\\t\\tnumber of fresh ones at the start of the recursive function.\\n\\t\\t\\'\\'\\'\\n        if not newly_rotten:\\n            return -1\\n        else:\\n            for coords in newly_rotten:\\n                fresh_coords.remove(coords)\\n                rotten_coords.add(coords)\\n                \\n            temp = self.recursive(fresh_coords, rotten_coords, rows, cols)\\n            if temp == -1:\\n                return -1\\n            else:\\n                return 1 + temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531264,
                "title": "easy-java-not-much-to-say-about-this",
                "content": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int m=grid.length,n=grid[0].length,i,j,k=0,fresh=0,fr;\\n        for(i=0;i<m;i++)\\n            for(j=0;j<n;j++)\\n                if(grid[i][j]==1) fresh++;\\n        while(fresh>0){\\n            fr=fresh;\\n            for(i=0;i<m;i++){\\n                for(j=0;j<n;j++){\\n                    if(grid[i][j]==2){\\n                        if(i+1<m && grid[i+1][j]==1) {grid[i+1][j]=3;fresh--;}\\n                        if(i-1>=0 && grid[i-1][j]==1) {grid[i-1][j]=3;fresh--;}\\n                        if(j-1>=0 && grid[i][j-1]==1) {grid[i][j-1]=3;fresh--;}\\n                        if(j+1<n && grid[i][j+1]==1) {grid[i][j+1]=3;fresh--;}\\n                    }\\n                }\\n            }\\n            for(i=0;i<m;i++)\\n                for(j=0;j<n;j++)\\n                    if(grid[i][j]==3) grid[i][j]=2;\\n            if(fr==fresh) return -1;\\n            k++;\\n        }\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int m=grid.length,n=grid[0].length,i,j,k=0,fresh=0,fr;\\n        for(i=0;i<m;i++)\\n            for(j=0;j<n;j++)\\n                if(grid[i][j]==1) fresh++;\\n        while(fresh>0){\\n            fr=fresh;\\n            for(i=0;i<m;i++){\\n                for(j=0;j<n;j++){\\n                    if(grid[i][j]==2){\\n                        if(i+1<m && grid[i+1][j]==1) {grid[i+1][j]=3;fresh--;}\\n                        if(i-1>=0 && grid[i-1][j]==1) {grid[i-1][j]=3;fresh--;}\\n                        if(j-1>=0 && grid[i][j-1]==1) {grid[i][j-1]=3;fresh--;}\\n                        if(j+1<n && grid[i][j+1]==1) {grid[i][j+1]=3;fresh--;}\\n                    }\\n                }\\n            }\\n            for(i=0;i<m;i++)\\n                for(j=0;j<n;j++)\\n                    if(grid[i][j]==3) grid[i][j]=2;\\n            if(fr==fresh) return -1;\\n            k++;\\n        }\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278351,
                "title": "c-dfs-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&grid, int i, int j, int min=2)\\n    {\\n        if(i<0 or j<0 or i>=grid.size() or j>=grid[0].size() or  grid[i][j]==0 or (1 < grid[i][j] and grid[i][j] < min))return ;\\n        grid[i][j]=min; // Assign the current minute to the grid\\n        dfs(grid,i+1,j,min+1);  // Recursive call to all 4 sides one by one and by incrementing tine by +1\\n         dfs(grid,i-1,j,min+1);\\n         dfs(grid,i,j+1,min+1);\\n         dfs(grid,i,j-1,min+1);\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==2) dfs(grid,i,j); // We have to proceed on those orananges which are rotten already and start a recursive call and the reason why we are sending 2 is because we cannot mark time as 0,1,2 Since they are being used in the question (empty cell, fresh orange,rotten orange) \\n            }\\n        }\\n        int min=2;\\n        for(auto &i:grid)\\n        {\\n            for(auto &j:i)\\n            {\\n                if(j==1) return -1; // if by any means, any value is 1, that means we weren\\'t able to rot that orange, Here min= Total time (minutes)\\n                min=max(min,j);  // otherwise, maximum time to rot.\\n            }\\n        }\\n        return min-2;\\n    }\\n};\\n```\\n**Kindly upvote, if you like the solution :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&grid, int i, int j, int min=2)\\n    {\\n        if(i<0 or j<0 or i>=grid.size() or j>=grid[0].size() or  grid[i][j]==0 or (1 < grid[i][j] and grid[i][j] < min))return ;\\n        grid[i][j]=min; // Assign the current minute to the grid\\n        dfs(grid,i+1,j,min+1);  // Recursive call to all 4 sides one by one and by incrementing tine by +1\\n         dfs(grid,i-1,j,min+1);\\n         dfs(grid,i,j+1,min+1);\\n         dfs(grid,i,j-1,min+1);\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==2) dfs(grid,i,j); // We have to proceed on those orananges which are rotten already and start a recursive call and the reason why we are sending 2 is because we cannot mark time as 0,1,2 Since they are being used in the question (empty cell, fresh orange,rotten orange) \\n            }\\n        }\\n        int min=2;\\n        for(auto &i:grid)\\n        {\\n            for(auto &j:i)\\n            {\\n                if(j==1) return -1; // if by any means, any value is 1, that means we weren\\'t able to rot that orange, Here min= Total time (minutes)\\n                min=max(min,j);  // otherwise, maximum time to rot.\\n            }\\n        }\\n        return min-2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755398,
                "title": "java-with-comments-100-accepted",
                "content": "**Upvote if you like**\\n\\n```\\nclass Solution {\\n    \\n    class indexies{\\n        int x;\\n        int y;\\n        \\n        indexies(int x,int y){\\n            this.x=x;\\n            this.y=y;\\n        }\\n        \\n    }\\n    \\n    public int orangesRotting(int[][] grid) {\\n        \\n        Queue<indexies> q=new LinkedList<>();\\n        int ones=0;\\n        int m=grid.length,n=grid[0].length;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n\\t\\t\\t\\t//rotton oranges positions\\n                if(grid[i][j]==2){\\n                    q.add(new indexies(i,j));\\n                }\\n\\t\\t\\t\\t//count the fresh oranges\\n                else if(grid[i][j]==1){\\n                    ones++;\\n                }\\n            }\\n        }\\n        \\n\\t\\t//if no rotton but we have fresh oranges so 0 time taken\\n        if(q.size()==0 && ones>0) \\n            return -1;\\n\\t\\t//we don\\'t have any fresh oranges\\n        if(ones==0)\\n            return 0;\\n        \\n        int ans=0;\\n        \\n        int dir[][]={{0,1},{0,-1},{-1,0},{1,0}};\\n        \\n        while(!q.isEmpty()){\\n            \\n\\t\\t\\t//add and travel\\n            int size=q.size();\\n            boolean f=false;              \\n            \\n\\t\\t\\t//moves to add rotton vertices\\n            for(int ii=0;ii<size;ii++){\\n                indexies temp=q.poll();\\n            \\n                //move to all the adjacent vertices\\n                for(int i=0;i<4;i++){\\n                    int new_x=temp.x+dir[i][0];\\n                    int new_y=temp.y+dir[i][1];\\n                \\n                    //if we find fresh anywhere in the grid\\n                    if(new_x>=0 && new_y>=0 && new_x<m && new_y<n && grid[new_x][new_y]==1){\\n                        \\n\\t\\t\\t\\t\\t\\t//make it rotton and add position\\n                        grid[new_x][new_y]=2;\\n                        q.add(new indexies(new_x,new_y));\\n                        ones--;\\n                        \\n                        //we take the time to make all the adjacent fresh to rotton\\n                        //means we found the fresh oranges and make it rotton\\n                        f=true;\\n                        \\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n            //if we found fresh and make it rotton means we consume time so increase it\\n            if(f){\\n                ans++;\\n            }\\n            \\n        }\\n        \\n        //somwhere in the grid fresh is present means no possible way\\n        if(ones>0)\\n            return -1;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class indexies{\\n        int x;\\n        int y;\\n        \\n        indexies(int x,int y){\\n            this.x=x;\\n            this.y=y;\\n        }\\n        \\n    }\\n    \\n    public int orangesRotting(int[][] grid) {\\n        \\n        Queue<indexies> q=new LinkedList<>();\\n        int ones=0;\\n        int m=grid.length,n=grid[0].length;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n\\t\\t\\t\\t//rotton oranges positions\\n                if(grid[i][j]==2){\\n                    q.add(new indexies(i,j));\\n                }\\n\\t\\t\\t\\t//count the fresh oranges\\n                else if(grid[i][j]==1){\\n                    ones++;\\n                }\\n            }\\n        }\\n        \\n\\t\\t//if no rotton but we have fresh oranges so 0 time taken\\n        if(q.size()==0 && ones>0) \\n            return -1;\\n\\t\\t//we don\\'t have any fresh oranges\\n        if(ones==0)\\n            return 0;\\n        \\n        int ans=0;\\n        \\n        int dir[][]={{0,1},{0,-1},{-1,0},{1,0}};\\n        \\n        while(!q.isEmpty()){\\n            \\n\\t\\t\\t//add and travel\\n            int size=q.size();\\n            boolean f=false;              \\n            \\n\\t\\t\\t//moves to add rotton vertices\\n            for(int ii=0;ii<size;ii++){\\n                indexies temp=q.poll();\\n            \\n                //move to all the adjacent vertices\\n                for(int i=0;i<4;i++){\\n                    int new_x=temp.x+dir[i][0];\\n                    int new_y=temp.y+dir[i][1];\\n                \\n                    //if we find fresh anywhere in the grid\\n                    if(new_x>=0 && new_y>=0 && new_x<m && new_y<n && grid[new_x][new_y]==1){\\n                        \\n\\t\\t\\t\\t\\t\\t//make it rotton and add position\\n                        grid[new_x][new_y]=2;\\n                        q.add(new indexies(new_x,new_y));\\n                        ones--;\\n                        \\n                        //we take the time to make all the adjacent fresh to rotton\\n                        //means we found the fresh oranges and make it rotton\\n                        f=true;\\n                        \\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n            //if we found fresh and make it rotton means we consume time so increase it\\n            if(f){\\n                ans++;\\n            }\\n            \\n        }\\n        \\n        //somwhere in the grid fresh is present means no possible way\\n        if(ones>0)\\n            return -1;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641680,
                "title": "java-bfs-detailed-explanation",
                "content": "```\\nclass Solution {\\n    \\n      public class Pair {\\n    int row;\\n    int col;\\n\\n    Pair(int row, int col) {\\n      this.row = row;\\n      this.col = col;\\n    }\\n\\n  }\\n\\n    public int orangesRotting(int[][] grid) {\\n            \\n    //   Step1:- we are going to add those element index in the queue whose value is 2 and along with that we are also going to the value on how many times 1 is present and we will use it further to see if it is possible to rotten all the oranges or not\\n    \\n    ArrayDeque <Pair> q=new ArrayDeque<>();\\n    int fone=0;//frequency of one\\n    \\n    for(int i =0;i<grid.length;i++){\\n        for(int j=0;j<grid[0].length;j++){\\n            if(grid[i][j]==2){\\n                q.add(new Pair(i,j));\\n            }\\n            else if(grid[i][j]==1){\\n                fone++;\\n            }\\n        }\\n    }\\n    \\n    if(fone==0){\\n        return 0; //no one i.e nothing is fresh so nothing will got rotten\\n    }\\n    \\n    // here we have used 2 loops first loop is just used to find level and in 2nd loop we are applying BFS algo levelwise\\n    \\n    int level=-1;\\n\\n    int [][] dirs={{1,0},{0,1},{-1,0},{0,-1}};\\n    while(q.size()!=0){\\n        int size=q.size();\\n        level++;\\n        \\n        // Inner loop\\n        while(size>0){\\n            Pair rem=q.removeFirst();\\n            \\n            // Now we will travel in all 4 direction\\n            \\n            for(int i =0;i<dirs.length;i++){\\n                int newrow=rem.row+dirs[i][0];\\n                int newcoloum=rem.col+dirs[i][1];\\n                \\n                if(newrow>=0 && newcoloum>=0 && newrow<grid.length && newcoloum<grid[0].length && grid[newrow][newcoloum]==1){\\n                    // whose value is 1 we will change its value 0 to as now they would be rotted\\n                q.add(new Pair(newrow,newcoloum));\\n                fone--;//as if(fone==0) then all fresh would be rottened so we are decreasing its value\\n                grid[newrow][newcoloum]=0;\\n                    \\n                }\\n            }\\n            size--;\\n        }\\n    }\\n    \\n    if(fone!=0){\\n        return -1;\\n    }\\n    return level;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n      public class Pair {\\n    int row;\\n    int col;\\n\\n    Pair(int row, int col) {\\n      this.row = row;\\n      this.col = col;\\n    }\\n\\n  }\\n\\n    public int orangesRotting(int[][] grid) {\\n            \\n    //   Step1:- we are going to add those element index in the queue whose value is 2 and along with that we are also going to the value on how many times 1 is present and we will use it further to see if it is possible to rotten all the oranges or not\\n    \\n    ArrayDeque <Pair> q=new ArrayDeque<>();\\n    int fone=0;//frequency of one\\n    \\n    for(int i =0;i<grid.length;i++){\\n        for(int j=0;j<grid[0].length;j++){\\n            if(grid[i][j]==2){\\n                q.add(new Pair(i,j));\\n            }\\n            else if(grid[i][j]==1){\\n                fone++;\\n            }\\n        }\\n    }\\n    \\n    if(fone==0){\\n        return 0; //no one i.e nothing is fresh so nothing will got rotten\\n    }\\n    \\n    // here we have used 2 loops first loop is just used to find level and in 2nd loop we are applying BFS algo levelwise\\n    \\n    int level=-1;\\n\\n    int [][] dirs={{1,0},{0,1},{-1,0},{0,-1}};\\n    while(q.size()!=0){\\n        int size=q.size();\\n        level++;\\n        \\n        // Inner loop\\n        while(size>0){\\n            Pair rem=q.removeFirst();\\n            \\n            // Now we will travel in all 4 direction\\n            \\n            for(int i =0;i<dirs.length;i++){\\n                int newrow=rem.row+dirs[i][0];\\n                int newcoloum=rem.col+dirs[i][1];\\n                \\n                if(newrow>=0 && newcoloum>=0 && newrow<grid.length && newcoloum<grid[0].length && grid[newrow][newcoloum]==1){\\n                    // whose value is 1 we will change its value 0 to as now they would be rotted\\n                q.add(new Pair(newrow,newcoloum));\\n                fone--;//as if(fone==0) then all fresh would be rottened so we are decreasing its value\\n                grid[newrow][newcoloum]=0;\\n                    \\n                }\\n            }\\n            size--;\\n        }\\n    }\\n    \\n    if(fone!=0){\\n        return -1;\\n    }\\n    return level;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1547456,
                "title": "clean-go-solution-using-bfs-beats-100",
                "content": "```\\nvar directions = [4][2]int{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}\\n\\nconst (\\n\\tFresh  = 1\\n\\tRotten = 2\\n)\\n\\nfunc orangesRotting(grid [][]int) int {\\n\\tm, n := len(grid), len(grid[0])\\n\\tvar rotten [][2]int\\n\\n\\tfresh := 0\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tswitch grid[i][j] {\\n\\t\\t\\tcase Fresh:\\n\\t\\t\\t\\tfresh++\\n\\t\\t\\tcase Rotten:\\n\\t\\t\\t\\trotten = append(rotten, [2]int{i, j})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif fresh == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tminutes := 0\\n\\tfor len(rotten) > 0 {\\n\\t\\tfor _, o := range rotten {\\n\\t\\t\\tfor _, dir := range directions {\\n\\t\\t\\t\\tx, y := o[0]+dir[0], o[1]+dir[1]\\n\\t\\t\\t\\tif x >= 0 && x < m && y >= 0 && y < n && grid[x][y] == Fresh {\\n\\t\\t\\t\\t\\tgrid[x][y] = Rotten\\n\\t\\t\\t\\t\\trotten = append(rotten, [2]int{x, y})\\n\\t\\t\\t\\t\\tfresh--\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\trotten = rotten[1:]\\n\\t\\t}\\n\\n\\t\\tminutes++\\n\\t\\tif fresh == 0 {\\n\\t\\t\\treturn minutes\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar directions = [4][2]int{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}\\n\\nconst (\\n\\tFresh  = 1\\n\\tRotten = 2\\n)\\n\\nfunc orangesRotting(grid [][]int) int {\\n\\tm, n := len(grid), len(grid[0])\\n\\tvar rotten [][2]int\\n\\n\\tfresh := 0\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tswitch grid[i][j] {\\n\\t\\t\\tcase Fresh:\\n\\t\\t\\t\\tfresh++\\n\\t\\t\\tcase Rotten:\\n\\t\\t\\t\\trotten = append(rotten, [2]int{i, j})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif fresh == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tminutes := 0\\n\\tfor len(rotten) > 0 {\\n\\t\\tfor _, o := range rotten {\\n\\t\\t\\tfor _, dir := range directions {\\n\\t\\t\\t\\tx, y := o[0]+dir[0], o[1]+dir[1]\\n\\t\\t\\t\\tif x >= 0 && x < m && y >= 0 && y < n && grid[x][y] == Fresh {\\n\\t\\t\\t\\t\\tgrid[x][y] = Rotten\\n\\t\\t\\t\\t\\trotten = append(rotten, [2]int{x, y})\\n\\t\\t\\t\\t\\tfresh--\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\trotten = rotten[1:]\\n\\t\\t}\\n\\n\\t\\tminutes++\\n\\t\\tif fresh == 0 {\\n\\t\\t\\treturn minutes\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1519411,
                "title": "c-bfs-solution-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        if(grid.empty())return 0; //this is base case.. if we don\\'t have any orange to rotten then it will take 0 days\\n        \\n        int count=0,days=0,total=0;\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 2){ //this is done to push all the rotten oranges to the queue\\n                    q.push({i,j});\\n                }\\n                if(grid[i][j] != 0){ //this is helpful when we have to check that all the oranges are rotten or not in future\\n                    total++;\\n                }\\n            }\\n        }\\n        //this are the only directions in which our bfs will go.. so i used arrays for x and y coordinate\\n        int dx[4] = {0,0,1,-1};\\n        int dy[4] = {1,-1,0,0};\\n        \\n        while(!q.empty()){\\n            int k = q.size(); // at one day we can rot this many oranges\\n            count += k;\\n            while(k--){\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                q.pop();\\n                \\n                for(int i=0;i<4;i++){ // by using this loop we may go in four possible directions..\\n                    int nx = x + dx[i];\\n                    int ny = y + dy[i];\\n                    //now we have check the conditions for bounds and if there is blank space or already rotten orange then we will simply ignore\\n                    if(nx<0 || nx>=m || ny>=n || ny<0 || grid[nx][ny] != 1)continue;\\n                    grid[nx][ny] = 2; //after that we will mark the orange as rotten and push it into our queue data structure\\n                    q.push({nx,ny});\\n                }\\n            }\\n            if(!q.empty())days++; //this is used to check how many days are required to rotten all the oranges\\n        }\\n        return total == count ? days : -1; //if the total elements leaving blank space is equal to the elements pushed inside the queue then we can say our all oranges are rottened and we will simply return days otherwise we will return -1..\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        if(grid.empty())return 0; //this is base case.. if we don\\'t have any orange to rotten then it will take 0 days\\n        \\n        int count=0,days=0,total=0;\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 2){ //this is done to push all the rotten oranges to the queue\\n                    q.push({i,j});\\n                }\\n                if(grid[i][j] != 0){ //this is helpful when we have to check that all the oranges are rotten or not in future\\n                    total++;\\n                }\\n            }\\n        }\\n        //this are the only directions in which our bfs will go.. so i used arrays for x and y coordinate\\n        int dx[4] = {0,0,1,-1};\\n        int dy[4] = {1,-1,0,0};\\n        \\n        while(!q.empty()){\\n            int k = q.size(); // at one day we can rot this many oranges\\n            count += k;\\n            while(k--){\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                q.pop();\\n                \\n                for(int i=0;i<4;i++){ // by using this loop we may go in four possible directions..\\n                    int nx = x + dx[i];\\n                    int ny = y + dy[i];\\n                    //now we have check the conditions for bounds and if there is blank space or already rotten orange then we will simply ignore\\n                    if(nx<0 || nx>=m || ny>=n || ny<0 || grid[nx][ny] != 1)continue;\\n                    grid[nx][ny] = 2; //after that we will mark the orange as rotten and push it into our queue data structure\\n                    q.push({nx,ny});\\n                }\\n            }\\n            if(!q.empty())days++; //this is used to check how many days are required to rotten all the oranges\\n        }\\n        return total == count ? days : -1; //if the total elements leaving blank space is equal to the elements pushed inside the queue then we can say our all oranges are rottened and we will simply return days otherwise we will return -1..\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458694,
                "title": "javascript-simple-solution-w-comments",
                "content": "```\\n/**\\n * BFS\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 100 ms, faster than 29.24% of JavaScript online submissions for Rotting Oranges.\\n// Memory Usage: 42.2 MB, less than 23.98% of JavaScript online submissions for Rotting Oranges.\\nconst orangesRotting = grid => {\\n\\t// there can be multiple rotten fruits\\n\\tconst getRotten = () => {\\n\\t\\tlet [start, fresh] = [[], 0];\\n\\n\\t\\tfor (let i = 0; i < grid.length; i++) {\\n\\t\\t\\tfor (let j = 0; j < grid[0].length; j++) {\\n\\t\\t\\t\\tif (grid[i][j] === 2) start.push([i, j]);\\n\\t\\t\\t\\telse if (grid[i][j] === 1) fresh++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn [start, fresh];\\n\\t};\\n\\n\\tconst directions = [\\n\\t\\t[-1, 0],\\n\\t\\t[0, 1],\\n\\t\\t[1, 0],\\n\\t\\t[0, -1],\\n\\t];\\n\\tlet [start, fresh] = getRotten();\\n\\tlet queue = [...start]; // there can be mutiple rotten\\n\\tlet output = 0;\\n\\t\\n\\t// while fresh fruits are left && queue\\n\\twhile (fresh && queue.length) {\\n\\t\\tconst len = queue.length;\\n\\n\\t\\tfor (let i = 0; i < len; i++) {\\n\\t\\t\\tconst [row, col] = queue.shift();\\n\\n\\t\\t\\tfor (const [dx, dy] of directions) {\\n\\t\\t\\t\\tconst x = row + dx;\\n\\t\\t\\t\\tconst y = col + dy;\\n\\n\\t\\t\\t\\t// if invaid continue\\n\\t\\t\\t\\tif (x < 0 || x >= grid.length) continue;\\n\\t\\t\\t\\tif (y < 0 || y >= grid[0].length) continue;\\n\\t\\t\\t\\tif (grid[x][y] === 0 || grid[x][y] === 2) continue;\\n\\n\\t\\t\\t\\tqueue.push([x, y]);\\n\\t\\t\\t\\tgrid[x][y] = 2;\\n\\t\\t\\t\\tfresh--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\toutput++;\\n\\t}\\n\\n\\treturn fresh === 0 ? output : -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * BFS\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 100 ms, faster than 29.24% of JavaScript online submissions for Rotting Oranges.\\n// Memory Usage: 42.2 MB, less than 23.98% of JavaScript online submissions for Rotting Oranges.\\nconst orangesRotting = grid => {\\n\\t// there can be multiple rotten fruits\\n\\tconst getRotten = () => {\\n\\t\\tlet [start, fresh] = [[], 0];\\n\\n\\t\\tfor (let i = 0; i < grid.length; i++) {\\n\\t\\t\\tfor (let j = 0; j < grid[0].length; j++) {\\n\\t\\t\\t\\tif (grid[i][j] === 2) start.push([i, j]);\\n\\t\\t\\t\\telse if (grid[i][j] === 1) fresh++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn [start, fresh];\\n\\t};\\n\\n\\tconst directions = [\\n\\t\\t[-1, 0],\\n\\t\\t[0, 1],\\n\\t\\t[1, 0],\\n\\t\\t[0, -1],\\n\\t];\\n\\tlet [start, fresh] = getRotten();\\n\\tlet queue = [...start]; // there can be mutiple rotten\\n\\tlet output = 0;\\n\\t\\n\\t// while fresh fruits are left && queue\\n\\twhile (fresh && queue.length) {\\n\\t\\tconst len = queue.length;\\n\\n\\t\\tfor (let i = 0; i < len; i++) {\\n\\t\\t\\tconst [row, col] = queue.shift();\\n\\n\\t\\t\\tfor (const [dx, dy] of directions) {\\n\\t\\t\\t\\tconst x = row + dx;\\n\\t\\t\\t\\tconst y = col + dy;\\n\\n\\t\\t\\t\\t// if invaid continue\\n\\t\\t\\t\\tif (x < 0 || x >= grid.length) continue;\\n\\t\\t\\t\\tif (y < 0 || y >= grid[0].length) continue;\\n\\t\\t\\t\\tif (grid[x][y] === 0 || grid[x][y] === 2) continue;\\n\\n\\t\\t\\t\\tqueue.push([x, y]);\\n\\t\\t\\t\\tgrid[x][y] = 2;\\n\\t\\t\\t\\tfresh--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\toutput++;\\n\\t}\\n\\n\\treturn fresh === 0 ? output : -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 476286,
                "title": "python-simplest-bfs-solution-ever",
                "content": "Most intuitive Python solution among all. \\nSimply count all \\'good\\' oranges to make sure all are rot at the end.\\nAdd rotten oranges to deque: row, col, level. Level represents depth of tree.\\n\\nEach new BFS itteration, append to queue level+1. \\n\\n```\\nclass Solution(object):\\n    def orangesRotting(self, grid):\\n        N = len(grid)\\n        M = len(grid[0])\\n        Q = collections.deque()\\n        totalGood = 0\\n        #Find all good and append all rotten to queue\\n        for i in range(N):\\n            for j in range(M):\\n                if grid[i][j] == 1:\\n                    totalGood += 1\\n                if grid[i][j] == 2:\\n                    Q.appendleft((i,j,0))\\n        \\n        maxLevel = 0\\n        while Q:\\n            r, c, level = Q.pop()\\n            #Check all neighboors\\n            for x, y in [(r+1,c), (r-1,c), (r,c+1), (r,c-1)]:\\n                if (0 <= x < N) and (0 <= y < M) and grid[x][y] == 1:\\n                    grid[x][y] = 2 #Set to 2 - mark rotten or visited\\n                    totalGood -= 1\\n                    Q.appendleft((x,y, level+1))\\n                    if level+1 > maxLevel:\\n                        maxLevel = level+1   \\n        \\n        if totalGood > 0:\\n            return -1\\n        return maxLevel\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def orangesRotting(self, grid):\\n        N = len(grid)\\n        M = len(grid[0])\\n        Q = collections.deque()\\n        totalGood = 0\\n        #Find all good and append all rotten to queue\\n        for i in range(N):\\n            for j in range(M):\\n                if grid[i][j] == 1:\\n                    totalGood += 1\\n                if grid[i][j] == 2:\\n                    Q.appendleft((i,j,0))\\n        \\n        maxLevel = 0\\n        while Q:\\n            r, c, level = Q.pop()\\n            #Check all neighboors\\n            for x, y in [(r+1,c), (r-1,c), (r,c+1), (r,c-1)]:\\n                if (0 <= x < N) and (0 <= y < M) and grid[x][y] == 1:\\n                    grid[x][y] = 2 #Set to 2 - mark rotten or visited\\n                    totalGood -= 1\\n                    Q.appendleft((x,y, level+1))\\n                    if level+1 > maxLevel:\\n                        maxLevel = level+1   \\n        \\n        if totalGood > 0:\\n            return -1\\n        return maxLevel\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839084,
                "title": "c-rotting-oranges-with-queue",
                "content": "**Description**\\n\\nFind the minimum number of units of time that must elapse until no cell has a fresh orange.\\n\\n**Program**\\n\\n```cpp []\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        queue<pair<int, int>> queue;\\n        int fresh = 0;\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                // count total fresh oranges\\n                if (grid[r][c] == 1) {\\n                    fresh++;\\n                }\\n                // add rotten orange to queue\\n                if (grid[r][c] == 2) {\\n                    queue.push({r, c});\\n                }\\n            }\\n        }\\n        int result = 0;\\n        vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        // now queue should have all initial rotten oranges\\n        while (!queue.empty() && fresh > 0) {\\n            int size = queue.size();\\n            // the rotting process should be done by all rotten oranges in a unit time\\n            for (int i = 0; i < size; i++) {\\n                // get row and col of rotten orange\\n                auto [r, c] = queue.front();\\n                queue.pop();\\n                // check all four directions for fresh orange\\n                for (int j = 0; j < 4; j++) {\\n                    int x = r + dirs[j][0];\\n                    int y = c + dirs[j][1];\\n                    if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] != 1) {\\n                        continue;\\n                    }\\n                    // make fresh orange rotten and add to queue\\n                    grid[x][y] = 2;\\n                    queue.push({x, y});\\n                    // decrement count of fresh oranges\\n                    fresh--;\\n                }\\n            }\\n            // increment unit of time when rotting is done by all oranges in the queue\\n            result++;\\n        }\\n        return fresh == 0 ? result : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        queue<pair<int, int>> queue;\\n        int fresh = 0;\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                // count total fresh oranges\\n                if (grid[r][c] == 1) {\\n                    fresh++;\\n                }\\n                // add rotten orange to queue\\n                if (grid[r][c] == 2) {\\n                    queue.push({r, c});\\n                }\\n            }\\n        }\\n        int result = 0;\\n        vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        // now queue should have all initial rotten oranges\\n        while (!queue.empty() && fresh > 0) {\\n            int size = queue.size();\\n            // the rotting process should be done by all rotten oranges in a unit time\\n            for (int i = 0; i < size; i++) {\\n                // get row and col of rotten orange\\n                auto [r, c] = queue.front();\\n                queue.pop();\\n                // check all four directions for fresh orange\\n                for (int j = 0; j < 4; j++) {\\n                    int x = r + dirs[j][0];\\n                    int y = c + dirs[j][1];\\n                    if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] != 1) {\\n                        continue;\\n                    }\\n                    // make fresh orange rotten and add to queue\\n                    grid[x][y] = 2;\\n                    queue.push({x, y});\\n                    // decrement count of fresh oranges\\n                    fresh--;\\n                }\\n            }\\n            // increment unit of time when rotting is done by all oranges in the queue\\n            result++;\\n        }\\n        return fresh == 0 ? result : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2412389,
                "title": "simple-bfs-soultion-with-easy-understanding",
                "content": "This is a very good question for people learning graphs and its traversal .Here we have to simultaneously start our bfs from multiple points ,and also mark visited according to the time of traversal from a particular point . So, a point or node could appear in bfs from a point ,but may have already been visited from any other point. \\n\\nSo, here first we store all the rotten oranges in a queue and also store our time as 0, then call the bfs . Bfs starts firstly from all nodes already in queue and then when we are changing the fresh oranges to rotten , we increase our timer by 1, in this way we traverse to all the nodes or cells level order wise and keep increasing time . Our answer will be maximum time by any bfs traversal as our goal is to make all oranges rotten . \\n\\nIf even after bfs we could not rot all fresh oranges we return -1.\\n```\\n    int bfs(vector<vector<int>>& grid,queue<pair<pair<int,int>,int>>& q,vector<vector<int>> &vis,int n,int m){\\n        int ans=0;\\n        \\n        while(!q.empty()){\\n            pair<pair<int,int>,int> p=q.front();q.pop();\\n            int r=p.first.first,c=p.first.second,t=p.second;\\n            ans=max(ans,t);\\n            // cout<<r<<\" \"<<c<<\" \"<<grid[r][c]<<\" \"<<ans<<endl;\\n            if(r>0){\\n                if(grid[r-1][c]==1 && vis[r-1][c]==0){\\n                    vis[r-1][c]=1;q.push({{r-1,c},t+1});grid[r-1][c]=2;}\\n            }\\n            if(r<n-1){\\n                if(grid[r+1][c]==1 && vis[r+1][c]==0){vis[r+1][c]=1;q.push({{r+1,c},t+1});grid[r+1][c]=2;}\\n            }\\n            if(c<m-1){\\n                if(grid[r][c+1]==1 && vis[r][c+1]==0){vis[r][c+1]=1;q.push({{r,c+1},t+1});grid[r][c+1]=2;}\\n            }\\n             if(c>0){\\n                if(grid[r][c-1]==1 && vis[r][c-1]==0){vis[r][c-1]=1;q.push({{r,c-1},t+1});grid[r][c-1]=2;}\\n            }\\n            \\n        }\\n         return ans;\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n=grid.size();int m=grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        queue<pair<pair<int,int>,int>> q;bool done=false;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==2 && vis[i][j]==0){\\n                    done=true;q.push({{i,j},0});\\n                }\\n            }\\n        }\\n        int ans=bfs(grid,q,vis,n,m);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1) return -1;\\n            }}\\n      \\n        return done?ans:0;\\n    }\\n```\\n\\nIt would be a pleasure if you upvote this and appreciate my effort put in ....",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n    int bfs(vector<vector<int>>& grid,queue<pair<pair<int,int>,int>>& q,vector<vector<int>> &vis,int n,int m){\\n        int ans=0;\\n        \\n        while(!q.empty()){\\n            pair<pair<int,int>,int> p=q.front();q.pop();\\n            int r=p.first.first,c=p.first.second,t=p.second;\\n            ans=max(ans,t);\\n            // cout<<r<<\" \"<<c<<\" \"<<grid[r][c]<<\" \"<<ans<<endl;\\n            if(r>0){\\n                if(grid[r-1][c]==1 && vis[r-1][c]==0){\\n                    vis[r-1][c]=1;q.push({{r-1,c},t+1});grid[r-1][c]=2;}\\n            }\\n            if(r<n-1){\\n                if(grid[r+1][c]==1 && vis[r+1][c]==0){vis[r+1][c]=1;q.push({{r+1,c},t+1});grid[r+1][c]=2;}\\n            }\\n            if(c<m-1){\\n                if(grid[r][c+1]==1 && vis[r][c+1]==0){vis[r][c+1]=1;q.push({{r,c+1},t+1});grid[r][c+1]=2;}\\n            }\\n             if(c>0){\\n                if(grid[r][c-1]==1 && vis[r][c-1]==0){vis[r][c-1]=1;q.push({{r,c-1},t+1});grid[r][c-1]=2;}\\n            }\\n            \\n        }\\n         return ans;\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n=grid.size();int m=grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        queue<pair<pair<int,int>,int>> q;bool done=false;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==2 && vis[i][j]==0){\\n                    done=true;q.push({{i,j},0});\\n                }\\n            }\\n        }\\n        int ans=bfs(grid,q,vis,n,m);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1) return -1;\\n            }}\\n      \\n        return done?ans:0;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2053319,
                "title": "javascript-clean-and-easy-to-understand-bfs-solution",
                "content": "first count how many cells are fresh and push rottens direction to a queue,\\nthen while we have fresh maintain rotten queue:\\n\\t* update grid with new rottens\\n\\t* add new rottens to torrens queue\\n\\t* decrease from remain fresh cell\\n\\tand repeat these step till fresh ends.\\n\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar orangesRotting = function(grid) {\\n    \\n    const rows = grid.length, cols = grid[0].length, UpDown = [1, -1, 0, 0], LeftRight = [0, 0, 1, -1]; \\n    let queueRotten = [], minute = 0, fresh = 0;\\n    \\n    for(let r = 0; r < rows; r++) {\\n        for(let c = 0; c < cols; c++) {\\n            if(grid[r][c] === 2) queueRotten.push([r, c])\\n            else if(grid[r][c] === 1) fresh++;\\n        }\\n    }\\n    \\n    while(fresh && queueRotten.length) {\\n        const next = [];\\n        minute++;\\n        \\n        for(let [r, c] of queueRotten) {\\n            \\n            for(let i = 0; i < 4; i++) {\\n                const x = r + UpDown[i], y = c + LeftRight[i];\\n                \\n                if(x < rows && x >= 0 && \\n                   y < cols && y >= 0 && \\n                   grid[x][y] === 1) {\\n                    fresh--;\\n                    grid[x][y] = 2;\\n                    next.push([x, y]);\\n                }\\n            }\\n        }\\n        queueRotten = next;\\n    }\\n    return !fresh ? minute : -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar orangesRotting = function(grid) {\\n    \\n    const rows = grid.length, cols = grid[0].length, UpDown = [1, -1, 0, 0], LeftRight = [0, 0, 1, -1]; \\n    let queueRotten = [], minute = 0, fresh = 0;\\n    \\n    for(let r = 0; r < rows; r++) {\\n        for(let c = 0; c < cols; c++) {\\n            if(grid[r][c] === 2) queueRotten.push([r, c])\\n            else if(grid[r][c] === 1) fresh++;\\n        }\\n    }\\n    \\n    while(fresh && queueRotten.length) {\\n        const next = [];\\n        minute++;\\n        \\n        for(let [r, c] of queueRotten) {\\n            \\n            for(let i = 0; i < 4; i++) {\\n                const x = r + UpDown[i], y = c + LeftRight[i];\\n                \\n                if(x < rows && x >= 0 && \\n                   y < cols && y >= 0 && \\n                   grid[x][y] === 1) {\\n                    fresh--;\\n                    grid[x][y] = 2;\\n                    next.push([x, y]);\\n                }\\n            }\\n        }\\n        queueRotten = next;\\n    }\\n    return !fresh ? minute : -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1741380,
                "title": "java-bfs-1ms",
                "content": "- Since adjacent nodes of 2 will get rotten first, and it speards on, we can use BFS(Travels adjacent nodes first). \\n- There may be multiple 2\\'s so, we can store all the 2\\'s pos in queue first and \\nperform BFS.\\n- while Performing bfs mark 1\\'s as 2\\'s and maintain the time when it got rotten\\n- Then check if any 1\\'s are left after bfs traversal if so, return -1 else return time\\n\\n\\n#### BFS\\n```\\nclass Pair{\\n    int row;\\n    int col;\\n    int time;\\n    \\n    Pair(int row,int col,int time){\\n        this.row=row;\\n        this.col=col;\\n        this.time=time;\\n    }\\n}\\n\\nclass Solution {\\n    int dir[][] = {{-1,0},{1,0},{0,1},{0,-1}};\\n\\n    public int orangesRotting(int[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int count=0,max=0;\\n        \\n        Queue<Pair> queue = new LinkedList<>();\\n        boolean[][] visited = new boolean[row][col];\\n        \\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(grid[i][j]==2){\\n                    queue.add(new Pair(i,j,0));\\n                }\\n            }\\n        }\\n        \\n        while(!queue.isEmpty()){\\n            Pair p = queue.remove();\\n            visited[p.row][p.col]=true;\\n            \\n            for(int dr[] : dir){\\n                int i = p.row+dr[0];\\n                int j = p.col+dr[1];\\n                \\n                if(isValidDir(i,j,grid) && grid[i][j]==1 && !visited[i][j]){\\n                    grid[i][j]=2;\\n                    queue.add(new Pair(i,j,p.time+1));\\n                }\\n            }\\n            max=Math.max(max,p.time);\\n        }\\n        \\n        for(int rows[] : grid){\\n            for(int cols : rows){\\n                if(cols==1) count++;\\n            }\\n        }\\n        \\n        return count>0 ? -1 : max;\\n    }\\n    \\n    private boolean isValidDir(int i,int j,int grid[][]){\\n        if(i<0 || i>=grid.length||\\n           j<0 || j>=grid[0].length){\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Pair{\\n    int row;\\n    int col;\\n    int time;\\n    \\n    Pair(int row,int col,int time){\\n        this.row=row;\\n        this.col=col;\\n        this.time=time;\\n    }\\n}\\n\\nclass Solution {\\n    int dir[][] = {{-1,0},{1,0},{0,1},{0,-1}};\\n\\n    public int orangesRotting(int[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int count=0,max=0;\\n        \\n        Queue<Pair> queue = new LinkedList<>();\\n        boolean[][] visited = new boolean[row][col];\\n        \\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(grid[i][j]==2){\\n                    queue.add(new Pair(i,j,0));\\n                }\\n            }\\n        }\\n        \\n        while(!queue.isEmpty()){\\n            Pair p = queue.remove();\\n            visited[p.row][p.col]=true;\\n            \\n            for(int dr[] : dir){\\n                int i = p.row+dr[0];\\n                int j = p.col+dr[1];\\n                \\n                if(isValidDir(i,j,grid) && grid[i][j]==1 && !visited[i][j]){\\n                    grid[i][j]=2;\\n                    queue.add(new Pair(i,j,p.time+1));\\n                }\\n            }\\n            max=Math.max(max,p.time);\\n        }\\n        \\n        for(int rows[] : grid){\\n            for(int cols : rows){\\n                if(cols==1) count++;\\n            }\\n        }\\n        \\n        return count>0 ? -1 : max;\\n    }\\n    \\n    private boolean isValidDir(int i,int j,int grid[][]){\\n        if(i<0 || i>=grid.length||\\n           j<0 || j>=grid[0].length){\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541505,
                "title": "simple-and-concise-c-to-understand-using-dfs-4ms",
                "content": "```\\nvoid dfs(int ** grid, int row, int col, int x, int y, int minutes)\\n{\\n    if(x<0 || x>=row || y<0 || y>=col || grid[x][y] == 0)\\n        return;\\n    if(grid[x][y] == 1 || grid[x][y] >= minutes)\\n    {\\n        grid[x][y] = minutes;\\n        dfs(grid, row, col, x+1, y, minutes+1);\\n        dfs(grid, row, col, x-1, y, minutes+1);\\n        dfs(grid, row, col, x, y-1, minutes+1);\\n        dfs(grid, row, col, x, y+1, minutes+1);\\n    }\\n}\\n\\nint orangesRotting(int** grid, int gridSize, int* gridColSize){\\n    for(int i=0; i<gridSize; i++)\\n        for(int j=0; j<*gridColSize; j++)\\n            if(grid[i][j] == 2)\\n                dfs(grid, gridSize, *gridColSize, i, j, 2);\\n    int min = 2;\\n    for(int i=0; i<gridSize; i++)\\n        for(int j=0; j<*gridColSize; j++)\\n            if(grid[i][j] == 1)\\n                return -1;\\n            else\\n                min = min < grid[i][j] ? grid[i][j] : min;\\n    return min-2;   \\n}\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nvoid dfs(int ** grid, int row, int col, int x, int y, int minutes)\\n{\\n    if(x<0 || x>=row || y<0 || y>=col || grid[x][y] == 0)\\n        return;\\n    if(grid[x][y] == 1 || grid[x][y] >= minutes)\\n    {\\n        grid[x][y] = minutes;\\n        dfs(grid, row, col, x+1, y, minutes+1);\\n        dfs(grid, row, col, x-1, y, minutes+1);\\n        dfs(grid, row, col, x, y-1, minutes+1);\\n        dfs(grid, row, col, x, y+1, minutes+1);\\n    }\\n}\\n\\nint orangesRotting(int** grid, int gridSize, int* gridColSize){\\n    for(int i=0; i<gridSize; i++)\\n        for(int j=0; j<*gridColSize; j++)\\n            if(grid[i][j] == 2)\\n                dfs(grid, gridSize, *gridColSize, i, j, 2);\\n    int min = 2;\\n    for(int i=0; i<gridSize; i++)\\n        for(int j=0; j<*gridColSize; j++)\\n            if(grid[i][j] == 1)\\n                return -1;\\n            else\\n                min = min < grid[i][j] ? grid[i][j] : min;\\n    return min-2;   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1375583,
                "title": "java-bfs-dfs-solution-with-explanation-in-comments",
                "content": "BFS Solution \\n```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        //BFS Solution\\n        \\n        //Base case\\n        if(grid == null || grid.length == 0)\\n            return -1;\\n        \\n        //First thing is we need a source in BFS. So we take the ones where values are 2 ie rotten\\n        Queue<int []> q = new LinkedList<>();\\n        \\n        int rowLen = grid.length;\\n        int colLen = grid[0].length;\\n        \\n        int freshCount = 0;\\n        for(int i = 0; i<rowLen; i++){\\n            for(int j =0; j<colLen; j++){\\n                if(grid[i][j] == 1)\\n                    freshCount++;\\n                else if(grid[i][j] == 2)\\n                    q.offer(new int[] {i,j}); // adding the rotten one to queue for being the source\\n            }\\n        }\\n        \\n        if(freshCount == 0) // No fresh oranges originally in grid \\n            return 0;\\n        \\n        int[][] directions = {{-1,0},{1,0},{0,-1} ,{0,1}}; //top, bottom, left, right\\n        int time = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i =0; i<size; i++){\\n                int[] rotten = q.poll();\\n                //Move in 4 direction around the rotten to make fresh oranges rotten\\n                for(int [] dir : directions){\\n                    int r = dir[0] + rotten[0];\\n                    int c = dir[1] + rotten[1];\\n                    \\n                    //Checking boundary conditions along with the if fresh\\n                    if(r>=0 && r<rowLen && c>=0 && c<colLen && grid[r][c] == 1 ){\\n                        grid[r][c] = 2; // rot it first\\n                        q.add(new int[] {r,c}); // add it in the queue for next process\\n                        freshCount--; // Reduce the fresh orange count as we rotted one\\n                    }\\n                }\\n            }\\n            time++; // After subesquent level count is increased.\\n        }\\n        if(freshCount!=0)  return -1; // Means fresh orange still there and impossible to rot;\\n        \\n        if(time>0)\\n            return time-1; // as after last level we still increase the count. So we decrease 1.\\n        else\\n            return 0; // No fresh oranges originally in grid \\n    }\\n}\\n```\\n----------------------------\\nDFS Solution :\\n```\\nclass Solution {\\n    int rowLen;\\n    int colLen;\\n    public int orangesRotting(int[][] grid) {\\n        \\n        //Base case\\n        if(grid == null || grid.length ==0)\\n            return -1;\\n        rowLen = grid.length;\\n        colLen = grid[0].length;\\n        int time = 0;\\n        for(int i = 0; i<rowLen; i++){\\n            for(int j =0; j<colLen; j++){\\n                if(grid[i][j] == 2 ){// if rotten\\n                    makeRotten(grid,i,j,2);\\n                }\\n            }\\n        }\\n        \\n        \\n        int minutes = 2;\\n        for(int[] row : grid) {\\n            for(int cell : row) {\\n                if(cell == 1)  // could not rot completely\\n                    return -1;\\n                else\\n                    minutes = Math.max(minutes, cell);\\n            }\\n        }\\n        return minutes - 2;\\n    }\\n    \\n    public void makeRotten(int[][] grid, int row, int col, int time){\\n        \\n         //Base Case\\n        if(row < 0 || row >= rowLen || col < 0 || col >= colLen || grid[row][col] == 0) \\n            //grid[row][col] == 0 : Empty Cell\\n            return;\\n        \\n        //Action\\n        //grid[row][col]< time ; grid[row][col] >1 : Already rotten as any value >= 2 is rotten\\n        //As sometimes time>2 and grid[i][j] == 2 ie >1 so it is already rotten so return simply\\n        if(grid[row][col] < time && grid[row][col] > 1) \\n            return ;\\n       \\n        //Recursion Logic\\n        int[][] directions ={{1,0},{-1,0},{0,-1},{0,1}};  //bottom,top,left,right\\n        grid[row][col] = time; // making it rotten as we have initially passed 2 for this function\\n        for(int[] dir : directions){\\n            int r = dir[0] + row;\\n            int c = dir[1] + col;\\n            makeRotten(grid,r,c,time+1);\\n                \\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        //BFS Solution\\n        \\n        //Base case\\n        if(grid == null || grid.length == 0)\\n            return -1;\\n        \\n        //First thing is we need a source in BFS. So we take the ones where values are 2 ie rotten\\n        Queue<int []> q = new LinkedList<>();\\n        \\n        int rowLen = grid.length;\\n        int colLen = grid[0].length;\\n        \\n        int freshCount = 0;\\n        for(int i = 0; i<rowLen; i++){\\n            for(int j =0; j<colLen; j++){\\n                if(grid[i][j] == 1)\\n                    freshCount++;\\n                else if(grid[i][j] == 2)\\n                    q.offer(new int[] {i,j}); // adding the rotten one to queue for being the source\\n            }\\n        }\\n        \\n        if(freshCount == 0) // No fresh oranges originally in grid \\n            return 0;\\n        \\n        int[][] directions = {{-1,0},{1,0},{0,-1} ,{0,1}}; //top, bottom, left, right\\n        int time = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i =0; i<size; i++){\\n                int[] rotten = q.poll();\\n                //Move in 4 direction around the rotten to make fresh oranges rotten\\n                for(int [] dir : directions){\\n                    int r = dir[0] + rotten[0];\\n                    int c = dir[1] + rotten[1];\\n                    \\n                    //Checking boundary conditions along with the if fresh\\n                    if(r>=0 && r<rowLen && c>=0 && c<colLen && grid[r][c] == 1 ){\\n                        grid[r][c] = 2; // rot it first\\n                        q.add(new int[] {r,c}); // add it in the queue for next process\\n                        freshCount--; // Reduce the fresh orange count as we rotted one\\n                    }\\n                }\\n            }\\n            time++; // After subesquent level count is increased.\\n        }\\n        if(freshCount!=0)  return -1; // Means fresh orange still there and impossible to rot;\\n        \\n        if(time>0)\\n            return time-1; // as after last level we still increase the count. So we decrease 1.\\n        else\\n            return 0; // No fresh oranges originally in grid \\n    }\\n}\\n```\n```\\nclass Solution {\\n    int rowLen;\\n    int colLen;\\n    public int orangesRotting(int[][] grid) {\\n        \\n        //Base case\\n        if(grid == null || grid.length ==0)\\n            return -1;\\n        rowLen = grid.length;\\n        colLen = grid[0].length;\\n        int time = 0;\\n        for(int i = 0; i<rowLen; i++){\\n            for(int j =0; j<colLen; j++){\\n                if(grid[i][j] == 2 ){// if rotten\\n                    makeRotten(grid,i,j,2);\\n                }\\n            }\\n        }\\n        \\n        \\n        int minutes = 2;\\n        for(int[] row : grid) {\\n            for(int cell : row) {\\n                if(cell == 1)  // could not rot completely\\n                    return -1;\\n                else\\n                    minutes = Math.max(minutes, cell);\\n            }\\n        }\\n        return minutes - 2;\\n    }\\n    \\n    public void makeRotten(int[][] grid, int row, int col, int time){\\n        \\n         //Base Case\\n        if(row < 0 || row >= rowLen || col < 0 || col >= colLen || grid[row][col] == 0) \\n            //grid[row][col] == 0 : Empty Cell\\n            return;\\n        \\n        //Action\\n        //grid[row][col]< time ; grid[row][col] >1 : Already rotten as any value >= 2 is rotten\\n        //As sometimes time>2 and grid[i][j] == 2 ie >1 so it is already rotten so return simply\\n        if(grid[row][col] < time && grid[row][col] > 1) \\n            return ;\\n       \\n        //Recursion Logic\\n        int[][] directions ={{1,0},{-1,0},{0,-1},{0,1}};  //bottom,top,left,right\\n        grid[row][col] = time; // making it rotten as we have initially passed 2 for this function\\n        for(int[] dir : directions){\\n            int r = dir[0] + row;\\n            int c = dir[1] + col;\\n            makeRotten(grid,r,c,time+1);\\n                \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343055,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        if(grid == null || grid.length == 0) return 0;\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        Queue<int[]> queue = new LinkedList<>();\\n        int count_fresh = 0;\\n        for(int i = 0 ; i < rows ; i++) {\\n            for(int j = 0 ; j < cols ; j++) {\\n                if(grid[i][j] == 2) {\\n                    queue.offer(new int[]{i , j});\\n                }\\n                else if(grid[i][j] == 1) {\\n                    count_fresh++;\\n                }\\n            }\\n        }\\n\\n        if(count_fresh == 0) return 0;\\n        int count = 0;\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n\\n        while(!queue.isEmpty()) {\\n            ++count;\\n            int size = queue.size();\\n            for(int i = 0 ; i < size ; i++) {\\n                int[] point = queue.poll();\\n                for(int dir[] : dirs) {\\n                    int x = point[0] + dir[0];\\n                    int y = point[1] + dir[1];\\n                    if(x < 0 || y < 0 || x >= rows || \\n                       y >= cols || grid[x][y] == 0 || grid[x][y] == 2) \\n                        continue;\\n\\n                    grid[x][y] = 2;\\n                    queue.offer(new int[]{x , y});\\n                    count_fresh--;\\n                }\\n            }\\n        }\\n        return count_fresh == 0 ? count-1 : -1;\\n    }\\n}\\n```\\n\\nRuntime: 2 ms, faster than 90.53% of Java online submissions for Rotting Oranges.\\nMemory Usage: 41 MB, less than 46.21% of Java online submissions for Rotting Oranges.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        if(grid == null || grid.length == 0) return 0;\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        Queue<int[]> queue = new LinkedList<>();\\n        int count_fresh = 0;\\n        for(int i = 0 ; i < rows ; i++) {\\n            for(int j = 0 ; j < cols ; j++) {\\n                if(grid[i][j] == 2) {\\n                    queue.offer(new int[]{i , j});\\n                }\\n                else if(grid[i][j] == 1) {\\n                    count_fresh++;\\n                }\\n            }\\n        }\\n\\n        if(count_fresh == 0) return 0;\\n        int count = 0;\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n\\n        while(!queue.isEmpty()) {\\n            ++count;\\n            int size = queue.size();\\n            for(int i = 0 ; i < size ; i++) {\\n                int[] point = queue.poll();\\n                for(int dir[] : dirs) {\\n                    int x = point[0] + dir[0];\\n                    int y = point[1] + dir[1];\\n                    if(x < 0 || y < 0 || x >= rows || \\n                       y >= cols || grid[x][y] == 0 || grid[x][y] == 2) \\n                        continue;\\n\\n                    grid[x][y] = 2;\\n                    queue.offer(new int[]{x , y});\\n                    count_fresh--;\\n                }\\n            }\\n        }\\n        return count_fresh == 0 ? count-1 : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249889,
                "title": "simple-java-easy-to-understand-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int min = 2;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 2) {\\n                    spread(i, j, grid, 2);\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    return -1;\\n                }\\n                min = Math.max(min, grid[i][j]);\\n            }\\n        }\\n\\n        return min - 2;\\n    }\\n\\n    private void spread(int i, int j, int[][] grid, int t) {\\n        int count = 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if (j < 0 || i < 0 || i >= m || j >= n || grid[i][j] == 0 || (grid[i][j] > 1 && grid[i][j] < t)) {\\n            return;\\n        } \\n        grid[i][j] = t;  \\n        spread(i + 1, j, grid, t + 1);\\n        spread(i - 1, j, grid, t + 1);\\n        spread(i, j + 1, grid, t + 1);\\n        spread(i, j - 1, grid, t + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int min = 2;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 2) {\\n                    spread(i, j, grid, 2);\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    return -1;\\n                }\\n                min = Math.max(min, grid[i][j]);\\n            }\\n        }\\n\\n        return min - 2;\\n    }\\n\\n    private void spread(int i, int j, int[][] grid, int t) {\\n        int count = 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if (j < 0 || i < 0 || i >= m || j >= n || grid[i][j] == 0 || (grid[i][j] > 1 && grid[i][j] < t)) {\\n            return;\\n        } \\n        grid[i][j] = t;  \\n        spread(i + 1, j, grid, t + 1);\\n        spread(i - 1, j, grid, t + 1);\\n        spread(i, j + 1, grid, t + 1);\\n        spread(i, j - 1, grid, t + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108765,
                "title": "bfs-easy-to-understand-explained-c",
                "content": "# Approach\\nUsing, bfs traversal as we do it at a same time and level wise. Not, dfs bcs it doesn\\'t ensures min time to rotten oranges.\\n\\n# Complexity\\n- Time complexity:\\nO(n*m + 4nm)  --> O(n*m)\\n\\n- Space complexity:\\nO(nm) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n = grid.size() , m = grid[0].size() ; \\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int maxTime=0,freshOrange=0;\\n           //{{row,col},time}\\n        queue<pair<pair<int,int>,int>>q;\\n        //find rotten orange and push in queue as doing bfs traversal \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==2){\\n                    q.push({{i,j},0});\\n                    vis[i][j]=2;\\n                }\\n                 if(grid[i][j]==1) freshOrange++;\\n            }\\n        }\\n    //traverse all 4 neighbours\\n      vector<int>delRow={-1,0,+1,0};\\n      vector<int>delCol={0,-1,0,+1};\\n\\n\\n    while(!q.empty()){\\n        int row = q.front().first.first;\\n        int col = q.front().first.second;\\n        int time = q.front().second;\\n        q.pop();\\n        maxTime=max(maxTime,time);\\n\\n        for(int i=0;i<4;i++){\\n            int nrow = row+delRow[i];\\n            int ncol = col+delCol[i];\\n\\n            //check valid \\n            if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && vis[nrow][ncol]==0 && grid[nrow][ncol]==1){\\n                //mark visited \\n                vis[nrow][ncol]=2;\\n                q.push({{nrow,ncol},time+1});\\n                freshOrange--;//freshOrange that are pushed in queue\\n            }\\n        }\\n    }\\n\\n     if(freshOrange!=0) return -1; //as freshOrange still left \\n         return maxTime;\\n    }\\n};\\n```\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n = grid.size() , m = grid[0].size() ; \\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int maxTime=0,freshOrange=0;\\n           //{{row,col},time}\\n        queue<pair<pair<int,int>,int>>q;\\n        //find rotten orange and push in queue as doing bfs traversal \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==2){\\n                    q.push({{i,j},0});\\n                    vis[i][j]=2;\\n                }\\n                 if(grid[i][j]==1) freshOrange++;\\n            }\\n        }\\n    //traverse all 4 neighbours\\n      vector<int>delRow={-1,0,+1,0};\\n      vector<int>delCol={0,-1,0,+1};\\n\\n\\n    while(!q.empty()){\\n        int row = q.front().first.first;\\n        int col = q.front().first.second;\\n        int time = q.front().second;\\n        q.pop();\\n        maxTime=max(maxTime,time);\\n\\n        for(int i=0;i<4;i++){\\n            int nrow = row+delRow[i];\\n            int ncol = col+delCol[i];\\n\\n            //check valid \\n            if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && vis[nrow][ncol]==0 && grid[nrow][ncol]==1){\\n                //mark visited \\n                vis[nrow][ncol]=2;\\n                q.push({{nrow,ncol},time+1});\\n                freshOrange--;//freshOrange that are pushed in queue\\n            }\\n        }\\n    }\\n\\n     if(freshOrange!=0) return -1; //as freshOrange still left \\n         return maxTime;\\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935122,
                "title": "simple-bfs-striver-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        queue<pair<pair<int,int>,int>> q;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int vis[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j =0; j<n;j++){\\n                if(grid[i][j]==2){\\n                    vis[i][j]=1;\\n                    q.push({{i,j},0});\\n                }\\n                else{\\n                    vis[i][j]=0; // Fresh oranges marked with \\n                }\\n            }\\n        }\\n              int delrow[] = {-1,0,1,0}; //Left right up down traversal\\n              int delcol[] = {0,-1,0,1};\\n                //Simple bfs\\n              int tm=0;\\n              while(!q.empty()){\\n                  int r = q.front().first.first;\\n                  int c = q.front().first.second;\\n                  int t = q.front().second;\\n                  tm = max(tm,t);\\n                  q.pop();\\n                  //Checking in its all adjacent directions\\n                     for(int i=0;i<4;i++){\\n                   int nrow = r+delrow[i];\\n                   int ncol = c+delcol[i];  \\n                   if(nrow>=0 && ncol>=0 && nrow<m && ncol<n && \\n                   grid[nrow][ncol] == 1 && vis[nrow][ncol] != 2){ //If Fresh and not visited\\n                       q.push({{nrow,ncol},t+1});\\n                       vis[nrow][ncol]=2; //Visited marked with 2\\n                   }\\n              }\\n            \\n              }\\n              //Checking if there is still a fresh orange left in the grid\\n              for(int i=0;i<m;i++){\\n                  for(int j=0;j<n;j++){\\n                      if(vis[i][j] !=2 && grid[i][j]== 1){\\n                         return -1;\\n                      }\\n                  }\\n              }\\n     return tm;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        queue<pair<pair<int,int>,int>> q;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int vis[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j =0; j<n;j++){\\n                if(grid[i][j]==2){\\n                    vis[i][j]=1;\\n                    q.push({{i,j},0});\\n                }\\n                else{\\n                    vis[i][j]=0; // Fresh oranges marked with \\n                }\\n            }\\n        }\\n              int delrow[] = {-1,0,1,0}; //Left right up down traversal\\n              int delcol[] = {0,-1,0,1};\\n                //Simple bfs\\n              int tm=0;\\n              while(!q.empty()){\\n                  int r = q.front().first.first;\\n                  int c = q.front().first.second;\\n                  int t = q.front().second;\\n                  tm = max(tm,t);\\n                  q.pop();\\n                  //Checking in its all adjacent directions\\n                     for(int i=0;i<4;i++){\\n                   int nrow = r+delrow[i];\\n                   int ncol = c+delcol[i];  \\n                   if(nrow>=0 && ncol>=0 && nrow<m && ncol<n && \\n                   grid[nrow][ncol] == 1 && vis[nrow][ncol] != 2){ //If Fresh and not visited\\n                       q.push({{nrow,ncol},t+1});\\n                       vis[nrow][ncol]=2; //Visited marked with 2\\n                   }\\n              }\\n            \\n              }\\n              //Checking if there is still a fresh orange left in the grid\\n              for(int i=0;i<m;i++){\\n                  for(int j=0;j<n;j++){\\n                      if(vis[i][j] !=2 && grid[i][j]== 1){\\n                         return -1;\\n                      }\\n                  }\\n              }\\n     return tm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2255751,
                "title": "c-simple-bfs-clean-code-fully-commented-edge-cases-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // Using BFS : \\n    int orangesRotting(vector<vector<int>>& grid) \\n    {\\n        vector<int> dir={-1,0,1,0,-1}; // used for finding all 4 adjacent coordinates\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        queue<pair<int,int>> q;\\n        int fresh=0;              // To keep track of all fresh oranges left\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==2)\\n                    q.push({i,j}); // push all rotten oranges\\n                if(grid[i][j]==1)\\n                    fresh++;\\n            }\\n        \\n        int ans=-1; // initialised to -1 since after each step we increment the time by 1 and initially all rotten oranges started at 0.\\n        \\n        // BFS \\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                auto p=q.front();\\n                q.pop();\\n                for(int i=0;i<4;i++)\\n                {\\n                    int r = p.first + dir[i];\\n                    int c = p.second + dir[i+1];\\n                    if(r>=0 && r<m && c>=0 && c<n && grid[r][c]==1)\\n                    {\\n                        grid[r][c]=2;\\n                        q.push({r,c}); // push that rotten orange that becomes rotten from fresh\\n                        fresh--;       // decrement by 1 for each fresh orange that now is rotten\\n                    }\\n                    \\n                }\\n            }\\n            ans++; // incremented after each minute passes\\n        }\\n        \\n        if(fresh>0) return -1; //if fresh>0 that means there are fresh oranges left\\n        if(ans==-1) return 0; //we initialised with -1, so if there were no oranges it\\'d take 0 mins.\\n        return ans;\\n    }\\n};\\n```\\n*Thanks for upvoting !*\\n\\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Using BFS : \\n    int orangesRotting(vector<vector<int>>& grid) \\n    {\\n        vector<int> dir={-1,0,1,0,-1}; // used for finding all 4 adjacent coordinates\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        queue<pair<int,int>> q;\\n        int fresh=0;              // To keep track of all fresh oranges left\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==2)\\n                    q.push({i,j}); // push all rotten oranges\\n                if(grid[i][j]==1)\\n                    fresh++;\\n            }\\n        \\n        int ans=-1; // initialised to -1 since after each step we increment the time by 1 and initially all rotten oranges started at 0.\\n        \\n        // BFS \\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                auto p=q.front();\\n                q.pop();\\n                for(int i=0;i<4;i++)\\n                {\\n                    int r = p.first + dir[i];\\n                    int c = p.second + dir[i+1];\\n                    if(r>=0 && r<m && c>=0 && c<n && grid[r][c]==1)\\n                    {\\n                        grid[r][c]=2;\\n                        q.push({r,c}); // push that rotten orange that becomes rotten from fresh\\n                        fresh--;       // decrement by 1 for each fresh orange that now is rotten\\n                    }\\n                    \\n                }\\n            }\\n            ans++; // incremented after each minute passes\\n        }\\n        \\n        if(fresh>0) return -1; //if fresh>0 that means there are fresh oranges left\\n        if(ans==-1) return 0; //we initialised with -1, so if there were no oranges it\\'d take 0 mins.\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546608,
                "title": "python-simple-intuitive-faster-than-99-9-does-not-modify-input-set-ops-bfs",
                "content": "Please feel free to ask questions or give suggestions. **Upvote** if you like the solution.\\n**Idea**: \\n1. Figure out initial fresh and rotten. \\n2. At the end of every minute, find out all fresh oranges that were neighbouring some rotten. All of these will now become our rotten. Remove from fresh any such oranges.\\n3. Repeat step 2 until we have no more fresh oranges or unexplored rotten\\n```\\ndef orangesRotting(self, grid: List[List[int]]) -> int:\\n\\t# One pass to fill up initial fresh and rotten\\n\\tfresh = set()\\n\\tunvisited_rotten = set()\\n\\tfor i, row in enumerate(grid):\\n\\t\\tfor j, cell in enumerate(row):\\n\\t\\t\\tif cell==2:\\n\\t\\t\\t\\tunvisited_rotten.add((i, j))\\n\\t\\t\\telif cell: # not 0 or 2\\n\\t\\t\\t\\tfresh.add((i, j))\\n\\t\\t\\t\\t\\n\\tminutes = 0\\n\\t# While there\\'s still fresh oranges and unexplored rotten oranges\\n\\twhile fresh and unvisited_rotten:\\n\\t\\t# Fresh oranges adjacent to any last rotten become rotten now \\n\\t\\tunvisited_rotten = set().union(*[fresh & {(i, j+1), (i+1, j), (i-1, j), (i, j-1)} for i, j in unvisited_rotten])\\n\\t\\tfresh -= unvisited_rotten\\n\\n\\t\\tminutes += 1\\n\\n\\t# Impossible if all rotten were exhausted but fresh still left, otherwise it took minutes time\\n\\treturn -1 if fresh else minutes\\n\\n```\\n**FAQ**:\\n**Q.**: Don\\'t you think, checking for isolated oranges and returning -1 straight away will be faster?\\n**A**: That is worth trying, when filling up fresh and unvisted_rotten in the first half, in the case of fresh oranges, we could instead do:\\n```\\nelif cell: # not 0 or 2\\n\\t# Has an adjacent orange\\n\\tif any(0<=ni<len(grid) and 0<=nj<len(grid[0]) and grid[ni][nj] for ni, nj in [(i, j+1), (i+1, j), (i-1, j), (i, j-1)]):\\n\\t\\tfresh.add((i, j))\\n\\telse:\\n\\t\\treturn -1\\n```\\nThis does not seem to improve performance for the leetcode tests.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\ndef orangesRotting(self, grid: List[List[int]]) -> int:\\n\\t# One pass to fill up initial fresh and rotten\\n\\tfresh = set()\\n\\tunvisited_rotten = set()\\n\\tfor i, row in enumerate(grid):\\n\\t\\tfor j, cell in enumerate(row):\\n\\t\\t\\tif cell==2:\\n\\t\\t\\t\\tunvisited_rotten.add((i, j))\\n\\t\\t\\telif cell: # not 0 or 2\\n\\t\\t\\t\\tfresh.add((i, j))\\n\\t\\t\\t\\t\\n\\tminutes = 0\\n\\t# While there\\'s still fresh oranges and unexplored rotten oranges\\n\\twhile fresh and unvisited_rotten:\\n\\t\\t# Fresh oranges adjacent to any last rotten become rotten now \\n\\t\\tunvisited_rotten = set().union(*[fresh & {(i, j+1), (i+1, j), (i-1, j), (i, j-1)} for i, j in unvisited_rotten])\\n\\t\\tfresh -= unvisited_rotten\\n\\n\\t\\tminutes += 1\\n\\n\\t# Impossible if all rotten were exhausted but fresh still left, otherwise it took minutes time\\n\\treturn -1 if fresh else minutes\\n\\n```\n```\\nelif cell: # not 0 or 2\\n\\t# Has an adjacent orange\\n\\tif any(0<=ni<len(grid) and 0<=nj<len(grid[0]) and grid[ni][nj] for ni, nj in [(i, j+1), (i+1, j), (i-1, j), (i, j-1)]):\\n\\t\\tfresh.add((i, j))\\n\\telse:\\n\\t\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1546311,
                "title": "java-simple-standard-bfs-clean-and-concise",
                "content": "**Idea**\\nJust use QUEUE to store all rotten oranges index and count of the number of fresh oranges initially then,\\nWhile travelling through those rotten oranges index store the index of it\\'s adjacent fresh oranges which now become the rotten one and iterate until all fresh oranges become rotten.\\nMake the index of the rotten one empty i.e assign 0 to it as we dont want to store their index again!\\n\\nAfter all that process still we left with fresh oranges then returned -1.\\n\\n````\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n     \\n        int i,j,n=grid.length,m=grid[0].length,ans=0,frsh=0;\\n        Queue<int[]> queue=new LinkedList();\\n        \\n        for(i=0;i<n;i++)\\n            for(j=0;j<m;j++) {\\n                if(grid[i][j]==2) {\\n\\n                    queue.add(new int[]{i,j});  grid[i][j]=0;\\n                }\\n                else if(grid[i][j]==1)\\n                    frsh++;\\n\\t\\t\\t}\\n        \\n        while(!queue.isEmpty())  {\\n            \\n            int size=queue.size();\\n            while(size-->0)\\n            {\\n                int tm[]=queue.poll();\\n                i=tm[0];\\n                j=tm[1];\\n                if(i+1<n&&grid[i+1][j]==1) {\\n                    \\n                    queue.add(new int[]{i+1,j});  grid[i+1][j]=0; frsh--;\\n                }\\n                if(j+1<m&&grid[i][j+1]==1) {\\n                    \\n                    queue.add(new int[]{i,j+1});  grid[i][j+1]=0; frsh--;\\n                }\\n                if(i-1>=0&&grid[i-1][j]==1) {\\n                    \\n                    queue.add(new int[]{i-1,j});  grid[i-1][j]=0;  frsh--;\\n                }\\n                if(j-1>=0&&grid[i][j-1]==1) {\\n                    \\n                    queue.add(new int[]{i,j-1});  grid[i][j-1]=0;  frsh--;\\n                }\\n            }\\n            if(queue.size()>0)\\n                ans++; \\n        }\\n        \\n        if(frsh>0)\\n            return -1;\\n        return ans;\\n    }\\n}\\n````\\n\\nIf this post was helpful then please upvote it :))",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "````\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n     \\n        int i,j,n=grid.length,m=grid[0].length,ans=0,frsh=0;\\n        Queue<int[]> queue=new LinkedList();\\n        \\n        for(i=0;i<n;i++)\\n            for(j=0;j<m;j++) {\\n                if(grid[i][j]==2) {\\n\\n                    queue.add(new int[]{i,j});  grid[i][j]=0;\\n                }\\n                else if(grid[i][j]==1)\\n                    frsh++;\\n\\t\\t\\t}\\n        \\n        while(!queue.isEmpty())  {\\n            \\n            int size=queue.size();\\n            while(size-->0)\\n            {\\n                int tm[]=queue.poll();\\n                i=tm[0];\\n                j=tm[1];\\n                if(i+1<n&&grid[i+1][j]==1) {\\n                    \\n                    queue.add(new int[]{i+1,j});  grid[i+1][j]=0; frsh--;\\n                }\\n                if(j+1<m&&grid[i][j+1]==1) {\\n                    \\n                    queue.add(new int[]{i,j+1});  grid[i][j+1]=0; frsh--;\\n                }\\n                if(i-1>=0&&grid[i-1][j]==1) {\\n                    \\n                    queue.add(new int[]{i-1,j});  grid[i-1][j]=0;  frsh--;\\n                }\\n                if(j-1>=0&&grid[i][j-1]==1) {\\n                    \\n                    queue.add(new int[]{i,j-1});  grid[i][j-1]=0;  frsh--;\\n                }\\n            }\\n            if(queue.size()>0)\\n                ans++; \\n        }\\n        \\n        if(frsh>0)\\n            return -1;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492830,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int mnts = 2;\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(grid[i][j] == 2)     mark(grid, i, j, mnts);\\n            }\\n        }\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(grid[i][j] == 1) return -1;\\n                mnts = Math.max(mnts, grid[i][j]);\\n            }\\n        }\\n        return mnts-2;\\n    }\\n    private void mark(int[][] grid, int i, int j, int mnts){\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0 || (grid[i][j] > 1 && grid[i][j] < mnts))\\n            return;\\n        grid[i][j] = mnts;\\n        mark(grid, i+1, j, mnts+1);\\n        mark(grid, i-1, j, mnts+1);\\n        mark(grid, i, j+1, mnts+1);\\n        mark(grid, i, j-1, mnts+1);\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar orangesRotting = function(grid) {\\n    let mnts = 2\\n    for(let i=0; i<grid.length; i++){\\n        for(let j=0; j<grid[0].length; j++){\\n            if(grid[i][j] == 2)     mark(grid, i, j, mnts)\\n        }\\n    }\\n    for(let i=0; i<grid.length; i++){\\n        for(let j=0; j<grid[0].length; j++){\\n            if(grid[i][j] == 1) return -1\\n            mnts = Math.max(mnts, grid[i][j])\\n        }\\n    }\\n    return mnts-2\\n};\\n\\nfunction mark(grid, i, j, mnts){\\n    if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0 || (grid[i][j] > 1 && grid[i][j] < mnts))\\n        return\\n    grid[i][j] = mnts\\n    mark(grid, i+1, j, mnts+1)\\n    mark(grid, i-1, j, mnts+1)\\n    mark(grid, i, j+1, mnts+1)\\n    mark(grid, i, j-1, mnts+1)\\n}\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def orangesRotting(self, grid):\\n        mnts = 2\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 2:\\n                    self.mark(grid, i, j, mnts)\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    return -1\\n                mnts = max(mnts, grid[i][j])\\n        return mnts-2\\n    def mark(self, grid, i, j, mnts):\\n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == 0 or (grid[i][j] > 1 and grid[i][j] < mnts):\\n            return\\n        grid[i][j] = mnts\\n        self.mark(grid, i+1, j, mnts+1)\\n        self.mark(grid, i-1, j, mnts+1)\\n        self.mark(grid, i, j+1, mnts+1)\\n        self.mark(grid, i, j-1, mnts+1)\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int mnts = 2;\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(grid[i][j] == 2)     mark(grid, i, j, mnts);\\n            }\\n        }\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(grid[i][j] == 1) return -1;\\n                mnts = Math.max(mnts, grid[i][j]);\\n            }\\n        }\\n        return mnts-2;\\n    }\\n    private void mark(int[][] grid, int i, int j, int mnts){\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0 || (grid[i][j] > 1 && grid[i][j] < mnts))\\n            return;\\n        grid[i][j] = mnts;\\n        mark(grid, i+1, j, mnts+1);\\n        mark(grid, i-1, j, mnts+1);\\n        mark(grid, i, j+1, mnts+1);\\n        mark(grid, i, j-1, mnts+1);\\n    }\\n}\\n```\n```\\nvar orangesRotting = function(grid) {\\n    let mnts = 2\\n    for(let i=0; i<grid.length; i++){\\n        for(let j=0; j<grid[0].length; j++){\\n            if(grid[i][j] == 2)     mark(grid, i, j, mnts)\\n        }\\n    }\\n    for(let i=0; i<grid.length; i++){\\n        for(let j=0; j<grid[0].length; j++){\\n            if(grid[i][j] == 1) return -1\\n            mnts = Math.max(mnts, grid[i][j])\\n        }\\n    }\\n    return mnts-2\\n};\\n\\nfunction mark(grid, i, j, mnts){\\n    if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0 || (grid[i][j] > 1 && grid[i][j] < mnts))\\n        return\\n    grid[i][j] = mnts\\n    mark(grid, i+1, j, mnts+1)\\n    mark(grid, i-1, j, mnts+1)\\n    mark(grid, i, j+1, mnts+1)\\n    mark(grid, i, j-1, mnts+1)\\n}\\n```\n```\\nclass Solution(object):\\n    def orangesRotting(self, grid):\\n        mnts = 2\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 2:\\n                    self.mark(grid, i, j, mnts)\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    return -1\\n                mnts = max(mnts, grid[i][j])\\n        return mnts-2\\n    def mark(self, grid, i, j, mnts):\\n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == 0 or (grid[i][j] > 1 and grid[i][j] < mnts):\\n            return\\n        grid[i][j] = mnts\\n        self.mark(grid, i+1, j, mnts+1)\\n        self.mark(grid, i-1, j, mnts+1)\\n        self.mark(grid, i, j+1, mnts+1)\\n        self.mark(grid, i, j-1, mnts+1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120339,
                "title": "two-sets-solution-99-speed",
                "content": "Runtime: 40 ms, faster than 99.05% of Python3 online submissions for Rotting Oranges.\\nMemory Usage: 13.9 MB, less than 99.71% of Python3 online submissions for Rotting Oranges.\\n\\nI got lucky with the servers!:)))))\\n```\\nclass Solution:\\n    def orangesRotting(self, grid) -> int:\\n        fresh = set()\\n        rotten = set()\\n        minute = 0\\n        for r, row in enumerate(grid):\\n            for c, v in enumerate(row):\\n                if v == 1:\\n                    fresh.add((r, c))\\n                elif v == 2:\\n                    rotten.add((r, c))\\n        while rotten and fresh:\\n            new_rot = set()\\n            for r, c in rotten:\\n                for i, j in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\\n                    new_tpl = (r + i, c + j)\\n                    if new_tpl in fresh:\\n                        fresh.remove(new_tpl)\\n                        new_rot.add(new_tpl)\\n            rotten = new_rot\\n            minute += 1\\n        return minute if not fresh else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orangesRotting(self, grid) -> int:\\n        fresh = set()\\n        rotten = set()\\n        minute = 0\\n        for r, row in enumerate(grid):\\n            for c, v in enumerate(row):\\n                if v == 1:\\n                    fresh.add((r, c))\\n                elif v == 2:\\n                    rotten.add((r, c))\\n        while rotten and fresh:\\n            new_rot = set()\\n            for r, c in rotten:\\n                for i, j in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\\n                    new_tpl = (r + i, c + j)\\n                    if new_tpl in fresh:\\n                        fresh.remove(new_tpl)\\n                        new_rot.add(new_tpl)\\n            rotten = new_rot\\n            minute += 1\\n        return minute if not fresh else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858666,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        Queue<int[]> Q = new LinkedList<>();\\n        int fresh=0;     \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 1) fresh++; //fresh count\\n                else if(grid[i][j]==2) Q.offer(new int[]{i,j}); // add rotton oranges to the queue\\n            }\\n        }\\n        \\n        if(fresh==0) return 0; \\n        \\n        int moves[][] = new int[][]{{0,1},{1,0},{-1,0},{0,-1}}; // 4 directions to moves\\n        int minute=-1; //here minute represents bfs level\\n        \\n        while(!Q.isEmpty()){\\n            int size = Q.size(); // to keep track of the current level elements \\n            minute++; \\n            while(size-- > 0){\\n                int[] d = Q.poll(); // poll the rotten orange\\n                for(int[] dir : moves){ //visit all 4 directions\\n                    int x = d[0]+dir[0];\\n                    int y = d[1]+dir[1];\\n                    if(x<0 || y<0 || x>= m || y>=n || grid[x][y]==0 || grid[x][y]==2) continue; //already rotten or invalid coordinate\\n                    grid[x][y] = 2; // mark the adjacent orange as visited( rotten)\\n                    fresh--; // decrease the fresh count\\n                    Q.offer(new int[]{x,y}); // add this rotten orange for next minute(level)\\n                }\\n            }\\n        }\\n             \\n        return fresh==0 ? minute : -1;        \\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        Queue<int[]> Q = new LinkedList<>();\\n        int fresh=0;     \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 1) fresh++; //fresh count\\n                else if(grid[i][j]==2) Q.offer(new int[]{i,j}); // add rotton oranges to the queue\\n            }\\n        }\\n        \\n        if(fresh==0) return 0; \\n        \\n        int moves[][] = new int[][]{{0,1},{1,0},{-1,0},{0,-1}}; // 4 directions to moves\\n        int minute=-1; //here minute represents bfs level\\n        \\n        while(!Q.isEmpty()){\\n            int size = Q.size(); // to keep track of the current level elements \\n            minute++; \\n            while(size-- > 0){\\n                int[] d = Q.poll(); // poll the rotten orange\\n                for(int[] dir : moves){ //visit all 4 directions\\n                    int x = d[0]+dir[0];\\n                    int y = d[1]+dir[1];\\n                    if(x<0 || y<0 || x>= m || y>=n || grid[x][y]==0 || grid[x][y]==2) continue; //already rotten or invalid coordinate\\n                    grid[x][y] = 2; // mark the adjacent orange as visited( rotten)\\n                    fresh--; // decrease the fresh count\\n                    Q.offer(new int[]{x,y}); // add this rotten orange for next minute(level)\\n                }\\n            }\\n        }\\n             \\n        return fresh==0 ? minute : -1;        \\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843694,
                "title": "python-dfs-solution",
                "content": "Similar to number of Islands problem, use a recursive function to count the time it takes to affect each orange. traverse through grid again to ensure there is no untouched fresh orange. return largest number which represents the total minutes to reach the last fresh fruit and make it rotten.\\n```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int: \\n        maxx = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                if grid[i][j] == 2:\\n                    self.dfs(grid, i, j, 0, True)\\n\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                if grid[i][j] == 1:\\n                    return -1\\n                maxx = max(abs(grid[i][j]), maxx)\\n\\n        return maxx\\n    \\n    def dfs(self, grid, i, j, counter, start):\\n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[i]) or grid[i][j] == 0 or (grid[i][j] < 0 and -grid[i][j] < counter):\\n            return \\n        if start is False and grid[i][j] == 2:\\n            return \\n        \\n        grid[i][j] = -counter\\n            \\n        self.dfs(grid, i+1, j, counter + 1, False)\\n        self.dfs(grid, i-1, j, counter + 1, False)\\n        self.dfs(grid, i, j+1, counter + 1, False)\\n        self.dfs(grid, i, j-1, counter + 1, False)",
                "solutionTags": [],
                "code": "Similar to number of Islands problem, use a recursive function to count the time it takes to affect each orange. traverse through grid again to ensure there is no untouched fresh orange. return largest number which represents the total minutes to reach the last fresh fruit and make it rotten.\\n```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int: \\n        maxx = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                if grid[i][j] == 2:\\n                    self.dfs(grid, i, j, 0, True)\\n\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                if grid[i][j] == 1:\\n                    return -1\\n                maxx = max(abs(grid[i][j]), maxx)\\n\\n        return maxx\\n    \\n    def dfs(self, grid, i, j, counter, start):\\n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[i]) or grid[i][j] == 0 or (grid[i][j] < 0 and -grid[i][j] < counter):\\n            return \\n        if start is False and grid[i][j] == 2:\\n            return \\n        \\n        grid[i][j] = -counter\\n            \\n        self.dfs(grid, i+1, j, counter + 1, False)\\n        self.dfs(grid, i-1, j, counter + 1, False)\\n        self.dfs(grid, i, j+1, counter + 1, False)\\n        self.dfs(grid, i, j-1, counter + 1, False)",
                "codeTag": "Java"
            },
            {
                "id": 783122,
                "title": "easy-to-understand-c-bfs-solution-code-commented",
                "content": "##### Observations:\\n- If we look the problem closely we get the intuition same as when we do a BFS traversal on a 2D plane.\\n- The only thing is we should keep track of the number of levels we traversed.\\n- And also we should make sure that : for one traversal **atleast** one cell is affected by the current cell.\\n- If we affect atleast one cell in the current timestamp we can increment our global time.\\n\\nHope you understand. Below is the C++ implementation of the same idea.\\n\\n```c++\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        auto isValid = [m, n](int i, int j){\\n            if (i >= 0 && i < m && j >= 0 && j < n)\\n                return true;\\n            return false;\\n\\t\\t\\t};    // simple function to check whether a cell is valid or not\\n\\t\\t\\t// this is a lambda function : you can create your own normal function by passing m and n parameters\\n        \\n        int time = 0;    // we keep track of the time elapsed\\n\\t\\t\\n        std::queue<std::pair<int, int>> q;\\n        \\n        vector<vector<int>> dir = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};   // 4 directions for each cell\\n        \\n        // First Fill the rotten co-ordinates\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                if (grid[i][j] == 2)\\n                    q.push({i, j});\\n            }\\n        }\\n        \\n        while (!q.empty())\\n        {\\n            int size = q.size();\\n            int affected = 0;\\n\\t\\t\\t// Here is the trick\\n\\t\\t\\t// Imagine there are two rotten oranges at first : then both consitute for a single unit of time\\n\\t\\t\\t// so we take the queue size and pop that many elements in the queue\\n\\t\\t\\t// Uncomment the below cout statements to get a clear understanding\\n            for (int i = 0; i < size; ++i) \\n            {\\n                auto f = q.front();\\n                q.pop();\\n                // cout << \"from \" << f.first << \" \" << f.second << endl;\\n                for (auto &d : dir)\\n                {\\n                    int xx = f.first + d[0];\\n                    int yy = f.second + d[1];\\n                    if (isValid(xx, yy) && grid[xx][yy] == 1)\\n                    {\\n                        ++affected;\\n                        // cout << \"    affected \" << xx << \" \" << yy << endl;\\n                        grid[xx][yy] = 2;\\n                        q.push({xx, yy});\\n                    }\\n                }\\n            }\\n            if (affected > 0)\\n                    ++time;\\n        }\\n        \\n        // Now confirming all are affected\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                if (grid[i][j] == 1)\\n                    return -1; // if not affected return -1 :)\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```\\nIf you like the solution please upvote :)\\nThank You",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        auto isValid = [m, n](int i, int j){\\n            if (i >= 0 && i < m && j >= 0 && j < n)\\n                return true;\\n            return false;\\n\\t\\t\\t};    // simple function to check whether a cell is valid or not\\n\\t\\t\\t// this is a lambda function : you can create your own normal function by passing m and n parameters\\n        \\n        int time = 0;    // we keep track of the time elapsed\\n\\t\\t\\n        std::queue<std::pair<int, int>> q;\\n        \\n        vector<vector<int>> dir = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};   // 4 directions for each cell\\n        \\n        // First Fill the rotten co-ordinates\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                if (grid[i][j] == 2)\\n                    q.push({i, j});\\n            }\\n        }\\n        \\n        while (!q.empty())\\n        {\\n            int size = q.size();\\n            int affected = 0;\\n\\t\\t\\t// Here is the trick\\n\\t\\t\\t// Imagine there are two rotten oranges at first : then both consitute for a single unit of time\\n\\t\\t\\t// so we take the queue size and pop that many elements in the queue\\n\\t\\t\\t// Uncomment the below cout statements to get a clear understanding\\n            for (int i = 0; i < size; ++i) \\n            {\\n                auto f = q.front();\\n                q.pop();\\n                // cout << \"from \" << f.first << \" \" << f.second << endl;\\n                for (auto &d : dir)\\n                {\\n                    int xx = f.first + d[0];\\n                    int yy = f.second + d[1];\\n                    if (isValid(xx, yy) && grid[xx][yy] == 1)\\n                    {\\n                        ++affected;\\n                        // cout << \"    affected \" << xx << \" \" << yy << endl;\\n                        grid[xx][yy] = 2;\\n                        q.push({xx, yy});\\n                    }\\n                }\\n            }\\n            if (affected > 0)\\n                    ++time;\\n        }\\n        \\n        // Now confirming all are affected\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                if (grid[i][j] == 1)\\n                    return -1; // if not affected return -1 :)\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 781944,
                "title": "python-simple-and-easy-to-understand-no-bfs",
                "content": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        # store in dictionary all coordinations of oranges, sorted by rotten/fresh/empty\\n        my_dict = defaultdict(list)\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                my_dict[grid[i][j]].append([i, j])\\n                \\n        count = 0\\n        while len(my_dict[1]) > 0:\\n            count += 1\\n            prev_len = len(my_dict[1])\\n            add_list = []\\n            # if there are no rotten oranges\\n            if len(my_dict[2]) == 0: \\n                # and there are no fresh ones\\n                if len(my_dict[1]) == 0:\\n                    return 0\\n                # there are fresh ones but no rotten\\n                else:\\n                    return -1\\n                \\n            # check all four sides of each rotten orange\\n            for x, y in my_dict[2]:\\n\\t\\t\\t\\t# top:\\n                if x > 0 and [x - 1, y] in my_dict[1]:\\n                    my_dict[1].remove([x - 1, y])\\n                    add_list.append([x - 1, y])\\n            \\n\\t\\t\\t\\t# right:\\n                if y < len(grid[0]) and [x, y + 1] in my_dict[1]:\\n                    my_dict[1].remove([x, y + 1])\\n                    add_list.append([x, y + 1])\\n                    \\n\\t\\t\\t\\t# down:\\n                if x < len(grid) and [x + 1, y] in my_dict[1]:\\n                    my_dict[1].remove([x + 1, y])\\n                    add_list.append([x + 1, y])\\n                    \\n\\t\\t\\t\\t# left:\\n                if y > 0 and [x, y - 1] in my_dict[1]:\\n                    my_dict[1].remove([x, y - 1])\\n                    add_list.append([x, y - 1])\\n                    \\n            my_dict[2].remove([x,y])\\n            my_dict[2] += add_list\\n            if prev_len == len(my_dict[1]):\\n                return -1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        # store in dictionary all coordinations of oranges, sorted by rotten/fresh/empty\\n        my_dict = defaultdict(list)\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                my_dict[grid[i][j]].append([i, j])\\n                \\n        count = 0\\n        while len(my_dict[1]) > 0:\\n            count += 1\\n            prev_len = len(my_dict[1])\\n            add_list = []\\n            # if there are no rotten oranges\\n            if len(my_dict[2]) == 0: \\n                # and there are no fresh ones\\n                if len(my_dict[1]) == 0:\\n                    return 0\\n                # there are fresh ones but no rotten\\n                else:\\n                    return -1\\n                \\n            # check all four sides of each rotten orange\\n            for x, y in my_dict[2]:\\n\\t\\t\\t\\t# top:\\n                if x > 0 and [x - 1, y] in my_dict[1]:\\n                    my_dict[1].remove([x - 1, y])\\n                    add_list.append([x - 1, y])\\n            \\n\\t\\t\\t\\t# right:\\n                if y < len(grid[0]) and [x, y + 1] in my_dict[1]:\\n                    my_dict[1].remove([x, y + 1])\\n                    add_list.append([x, y + 1])\\n                    \\n\\t\\t\\t\\t# down:\\n                if x < len(grid) and [x + 1, y] in my_dict[1]:\\n                    my_dict[1].remove([x + 1, y])\\n                    add_list.append([x + 1, y])\\n                    \\n\\t\\t\\t\\t# left:\\n                if y > 0 and [x, y - 1] in my_dict[1]:\\n                    my_dict[1].remove([x, y - 1])\\n                    add_list.append([x, y - 1])\\n                    \\n            my_dict[2].remove([x,y])\\n            my_dict[2] += add_list\\n            if prev_len == len(my_dict[1]):\\n                return -1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570014,
                "title": "very-straightforward-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    //T(n) = O(m*n*lg(m*n))\\n    //S(n) = O(m*n*lg(m*n))\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        if(grid.empty()){\\n            return -1;\\n        }\\n        set<pair<int,int>> fresh;\\n        set<pair<int,int>> rotten;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size(); j++){\\n                if(grid[i][j] == 1){\\n                    fresh.insert({i,j});\\n                }\\n                if(grid[i][j] == 2){\\n                    rotten.insert({i,j});\\n                }\\n            }\\n        }\\n        int move = 0;\\n        vector<vector<int>> directions = {{1,0},{-1,0},{0,1},{0,-1}};\\n        while(fresh.size() > 0){\\n            set<pair<int,int>> temprot;\\n            for(auto v : rotten){\\n                int row = v.first;\\n                int col = v.second;\\n                //check\\n                \\n                for(auto d : directions){\\n                    int x = row + d[0];\\n                    int y = col + d[1];\\n                    if(fresh.find({x,y}) != fresh.end()){\\n                        fresh.erase({x,y});\\n                        temprot.insert({x,y});\\n                    }\\n                }\\n            }\\n            if(temprot.size() == 0){\\n                return -1;\\n            }\\n            for(auto v : temprot){\\n                rotten.insert(v);\\n            }\\n            move++;\\n        }\\n        return move;    \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    //T(n) = O(m*n*lg(m*n))\\n    //S(n) = O(m*n*lg(m*n))\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        if(grid.empty()){\\n            return -1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 563875,
                "title": "c-solution",
                "content": "**Solution: BFS**\\n\\nStarting from all rotten oranges, use BFS to traverse the graph. Each rotten orange will rot its adjacent fresh oranges during each recursion. Time complexity and space complexity are both O(m * n).\\n\\nNote: why return  ```time - 1```? \\n\\nwhile loop logic traverses the graph and rot the fresh oranges. For the last group of rotten orange(s), ```time``` will increment by 1 even though they won\\'t rot fresh oranges, so we need time - 1. An alternative way is to ensure ```fresh > 0``` before starting BFS.\\n\\n\\n\\n```\\npublic class Solution {\\n    public int OrangesRotting(int[][] grid) {\\n        \\n        if(grid == null || grid[0].Length == 0)\\n            return 0;\\n        \\n        int m = grid.Length, n = grid[0].Length;\\n        int fresh = 0;\\n        \\n        Queue<(int,int)> queue = new Queue<(int,int)>();\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                    fresh++;\\n                else if(grid[i][j] == 2)\\n                    queue.Enqueue((i,j));\\n            }\\n        }\\n        \\n        if(fresh == 0)\\n            return 0;\\n        \\n        int time = 0;\\n        int[,] dir = new int[,]{{-1,0}, {1,0}, {0,-1}, {0,1}};\\n        while(queue.Count > 0)\\n        {\\n            time++;\\n            int size = queue.Count;\\n            for(int i = 0; i < size; i++)\\n            {\\n                var curr = queue.Dequeue();\\n                for(int j = 0; j < 4; j++)\\n                {\\n                    int newRow = curr.Item1 + dir[j,0];\\n                    int newCol = curr.Item2 + dir[j,1];\\n                    \\n                    if(newRow >= 0 && newRow < m && newCol >=0 && newCol < n && grid[newRow][newCol] == 1)\\n                    {\\n                        grid[newRow][newCol] = 2;\\n                        queue.Enqueue((newRow,newCol));\\n                        fresh--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return fresh == 0? time - 1: -1;\\n    }\\n}\\n```\\n\\n**Solution: BFS + check fresh before BFS**\\n```\\npublic class Solution {\\n    public int OrangesRotting(int[][] grid) {\\n        \\n        if(grid == null || grid[0].Length == 0)\\n            return 0;\\n        \\n        int m = grid.Length, n = grid[0].Length;\\n        int fresh = 0;\\n        \\n        Queue<(int,int)> queue = new Queue<(int,int)>();\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                    fresh++;\\n                else if(grid[i][j] == 2)\\n                    queue.Enqueue((i,j));\\n            }\\n        }\\n        \\n        if(fresh == 0)\\n            return 0;\\n        \\n        int time = 0;\\n        int[,] dir = new int[,]{{-1,0}, {1,0}, {0,-1}, {0,1}};\\n\\t\\t\\n\\t\\t// check fresh before BFS traverse the graph\\n        while(queue.Count > 0 && fresh > 0)\\n        {\\n            time++;\\n            int size = queue.Count;\\n            for(int i = 0; i < size; i++)\\n            {\\n                var curr = queue.Dequeue();\\n                for(int j = 0; j < 4; j++)\\n                {\\n                    int newRow = curr.Item1 + dir[j,0];\\n                    int newCol = curr.Item2 + dir[j,1];\\n                    \\n                    if(newRow >= 0 && newRow < m && newCol >=0 && newCol < n && grid[newRow][newCol] == 1)\\n                    {\\n                        grid[newRow][newCol] = 2;\\n                        queue.Enqueue((newRow,newCol));\\n                        fresh--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return fresh == 0? time: -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```time - 1```\n```time```\n```fresh > 0```\n```\\npublic class Solution {\\n    public int OrangesRotting(int[][] grid) {\\n        \\n        if(grid == null || grid[0].Length == 0)\\n            return 0;\\n        \\n        int m = grid.Length, n = grid[0].Length;\\n        int fresh = 0;\\n        \\n        Queue<(int,int)> queue = new Queue<(int,int)>();\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                    fresh++;\\n                else if(grid[i][j] == 2)\\n                    queue.Enqueue((i,j));\\n            }\\n        }\\n        \\n        if(fresh == 0)\\n            return 0;\\n        \\n        int time = 0;\\n        int[,] dir = new int[,]{{-1,0}, {1,0}, {0,-1}, {0,1}};\\n        while(queue.Count > 0)\\n        {\\n            time++;\\n            int size = queue.Count;\\n            for(int i = 0; i < size; i++)\\n            {\\n                var curr = queue.Dequeue();\\n                for(int j = 0; j < 4; j++)\\n                {\\n                    int newRow = curr.Item1 + dir[j,0];\\n                    int newCol = curr.Item2 + dir[j,1];\\n                    \\n                    if(newRow >= 0 && newRow < m && newCol >=0 && newCol < n && grid[newRow][newCol] == 1)\\n                    {\\n                        grid[newRow][newCol] = 2;\\n                        queue.Enqueue((newRow,newCol));\\n                        fresh--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return fresh == 0? time - 1: -1;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int OrangesRotting(int[][] grid) {\\n        \\n        if(grid == null || grid[0].Length == 0)\\n            return 0;\\n        \\n        int m = grid.Length, n = grid[0].Length;\\n        int fresh = 0;\\n        \\n        Queue<(int,int)> queue = new Queue<(int,int)>();\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                    fresh++;\\n                else if(grid[i][j] == 2)\\n                    queue.Enqueue((i,j));\\n            }\\n        }\\n        \\n        if(fresh == 0)\\n            return 0;\\n        \\n        int time = 0;\\n        int[,] dir = new int[,]{{-1,0}, {1,0}, {0,-1}, {0,1}};\\n\\t\\t\\n\\t\\t// check fresh before BFS traverse the graph\\n        while(queue.Count > 0 && fresh > 0)\\n        {\\n            time++;\\n            int size = queue.Count;\\n            for(int i = 0; i < size; i++)\\n            {\\n                var curr = queue.Dequeue();\\n                for(int j = 0; j < 4; j++)\\n                {\\n                    int newRow = curr.Item1 + dir[j,0];\\n                    int newCol = curr.Item2 + dir[j,1];\\n                    \\n                    if(newRow >= 0 && newRow < m && newCol >=0 && newCol < n && grid[newRow][newCol] == 1)\\n                    {\\n                        grid[newRow][newCol] = 2;\\n                        queue.Enqueue((newRow,newCol));\\n                        fresh--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return fresh == 0? time: -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529492,
                "title": "clean-understandable-professional-code",
                "content": "What do i mean by CUPC(clean understandable professional code)\\nNo hacks that make the code run faster.\\nNo Weird assumptions that may fool the system.\\nNo shit variable or random data structures that if used in real life woul mean being fired from job.\\n```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        //Build a list of all the rotten apples\\n\\t\\t// This will be used for the BFS\\n        Queue<Identifier> queue = new LinkedList<>();\\n        for(int i =0; i < grid.length; i++){\\n            for(int j =0; j < grid[0].length; j++){\\n                if(2==grid[i][j]){\\n                    queue.add(new Identifier(i,j,0));\\n                }\\n            }\\n        }\\n        //depth = day\\n        int day=0;\\n        while(!queue.isEmpty()){\\n            Identifier badOrange = queue.remove();\\n            if(day<=badOrange.day){\\n                day=badOrange.day;\\n            }\\n\\t\\t\\t// look at all the adjecent cells for good oranges. \\n\\t\\t\\t//Add the newly spoilt oranges to the list and update the value so that we don\\'t end up in a cycle\\n            //up\\n            if(badOrange.row -1>=0 && grid[badOrange.row-1][badOrange.column]==1){\\n                grid[badOrange.row-1][badOrange.column]=2;\\n                queue.add(new Identifier(badOrange.row-1,badOrange.column, day+1));\\n            }\\n            //down\\n            if(badOrange.row+1< grid.length && grid[badOrange.row+1][badOrange.column]==1){\\n                grid[badOrange.row+1][badOrange.column]=2;\\n                queue.add(new Identifier(badOrange.row+1,badOrange.column, day+1));\\n            }\\n            //left\\n            if(badOrange.column-1>=0 && grid[badOrange.row][badOrange.column-1]==1){\\n                grid[badOrange.row][badOrange.column-1]=2;\\n                queue.add(new Identifier(badOrange.row,badOrange.column-1, day+1));\\n            }\\n            //right\\n            if(badOrange.column+1<grid[0].length && grid[badOrange.row][badOrange.column+1]==1){\\n                grid[badOrange.row][badOrange.column+1]=2;\\n                queue.add(new Identifier(badOrange.row,badOrange.column+1, day+1));\\n            }\\n        }\\n        //final check to see if any straggling oranges remain\\n        for(int i =0; i < grid.length; i++){\\n            for(int j =0; j < grid[0].length; j++){\\n                int val = grid[i][j];\\n                if(val!=2 && val !=0){\\n                    return -1;\\n                }\\n            }\\n        }\\n        return day;\\n    }\\n}\\nclass Identifier{\\n    int row, column, day;\\n    public Identifier(int row, int column, int day){\\n        this.row = row;\\n        this.column = column;\\n        this.day = day;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        //Build a list of all the rotten apples\\n\\t\\t// This will be used for the BFS\\n        Queue<Identifier> queue = new LinkedList<>();\\n        for(int i =0; i < grid.length; i++){\\n            for(int j =0; j < grid[0].length; j++){\\n                if(2==grid[i][j]){\\n                    queue.add(new Identifier(i,j,0));\\n                }\\n            }\\n        }\\n        //depth = day\\n        int day=0;\\n        while(!queue.isEmpty()){\\n            Identifier badOrange = queue.remove();\\n            if(day<=badOrange.day){\\n                day=badOrange.day;\\n            }\\n\\t\\t\\t// look at all the adjecent cells for good oranges. \\n\\t\\t\\t//Add the newly spoilt oranges to the list and update the value so that we don\\'t end up in a cycle\\n            //up\\n            if(badOrange.row -1>=0 && grid[badOrange.row-1][badOrange.column]==1){\\n                grid[badOrange.row-1][badOrange.column]=2;\\n                queue.add(new Identifier(badOrange.row-1,badOrange.column, day+1));\\n            }\\n            //down\\n            if(badOrange.row+1< grid.length && grid[badOrange.row+1][badOrange.column]==1){\\n                grid[badOrange.row+1][badOrange.column]=2;\\n                queue.add(new Identifier(badOrange.row+1,badOrange.column, day+1));\\n            }\\n            //left\\n            if(badOrange.column-1>=0 && grid[badOrange.row][badOrange.column-1]==1){\\n                grid[badOrange.row][badOrange.column-1]=2;\\n                queue.add(new Identifier(badOrange.row,badOrange.column-1, day+1));\\n            }\\n            //right\\n            if(badOrange.column+1<grid[0].length && grid[badOrange.row][badOrange.column+1]==1){\\n                grid[badOrange.row][badOrange.column+1]=2;\\n                queue.add(new Identifier(badOrange.row,badOrange.column+1, day+1));\\n            }\\n        }\\n        //final check to see if any straggling oranges remain\\n        for(int i =0; i < grid.length; i++){\\n            for(int j =0; j < grid[0].length; j++){\\n                int val = grid[i][j];\\n                if(val!=2 && val !=0){\\n                    return -1;\\n                }\\n            }\\n        }\\n        return day;\\n    }\\n}\\nclass Identifier{\\n    int row, column, day;\\n    public Identifier(int row, int column, int day){\\n        this.row = row;\\n        this.column = column;\\n        this.day = day;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 305746,
                "title": "java-95",
                "content": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int m = grid.length, n = m == 0 ? 0 : grid[0].length;\\n        Queue<int[]> q = new LinkedList<>();\\n        int cnt = 0;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == 2)\\n                    q.add(new int[]{i, j});\\n                else if(grid[i][j] == 1)\\n                    cnt++;\\n            }\\n        }\\n        if(cnt == 0) return 0;\\n        \\n        int min = 0;\\n        int[][] dir = {{0, 1}, {1,0}, {-1, 0}, {0,-1}};\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++) {\\n                int[] cur = q.poll();\\n                for(int[] d : dir) {\\n                    int x = cur[0] + d[0], y = cur[1] + d[1];\\n                    if(x < 0 || y < 0 || x >= m || y >= n || grid[x][y] != 1)\\n                        continue;\\n                    grid[x][y] = 2;\\n                    cnt--;\\n                    q.add(new int[]{x, y});\\n                }\\n            }\\n            min++;\\n        }\\n        return cnt == 0 ? min - 1: -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int m = grid.length, n = m == 0 ? 0 : grid[0].length;\\n        Queue<int[]> q = new LinkedList<>();\\n        int cnt = 0;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == 2)\\n                    q.add(new int[]{i, j}",
                "codeTag": "Java"
            },
            {
                "id": 238890,
                "title": "java-o-n-2-time-o-1-space-accepted-simple-approach-simulate-the-rotting",
                "content": "This was a contest question, so I justed quickly coded up the first thing that came to mind, instead of trying to come up with something optimal.  Obviously the O(n) BFS solutions are faster, but this is easier to come up with and understand.  It also has the advantage of being O(1) space instead of O(n) space.\\n```\\n    public int orangesRotting(int[][] grid) {\\n        int minutes=-1;\\n\\n        // brute-force propagation of rotten-ness.\\n        for( boolean changed=true; changed; minutes++ ) {\\n            changed=false;\\n            \\n            // mark all fresh oranges with rotten neighbors\\n            for( int i=0; i<grid.length; i++ )\\n                for( int j=0; j<grid[i].length; j++ )\\n                    if( grid[i][j]==1 && rottenNeighbor( grid, i, j ) ) {\\n                        grid[i][j]=-2;\\n                        changed=true;\\n                    }\\n            \\n            // flip marked oranges to now be rotten\\n            if( changed ) for( int i=0; i<grid.length; i++ )\\n                for( int j=0; j<grid[i].length; j++ )\\n                    if( grid[i][j]==-2 ) grid[i][j]=2;\\n        }\\n\\n        // Check if there\\'s any fresh oranges left:\\n        for( int i=0; i<grid.length; i++ )\\n            for( int j=0; j<grid[i].length; j++ )\\n                if( grid[i][j]==1 ) return -1;\\n        \\n        return minutes;\\n    }\\n    \\n    private static boolean rottenNeighbor( int[][] grid, int x, int y ) {\\n        if( x>0 && grid[x-1][y]==2 ) return true;\\n        if( y>0 && grid[x][y-1]==2 ) return true;\\n        if( (x+1)<grid.length && grid[x+1][y]==2 ) return true;\\n        if( (y+1)<grid[x].length && grid[x][y+1]==2 ) return true;\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int orangesRotting(int[][] grid) {\\n        int minutes=-1;\\n\\n        // brute-force propagation of rotten-ness.\\n        for( boolean changed=true; changed; minutes++ ) {\\n            changed=false;\\n            \\n            // mark all fresh oranges with rotten neighbors\\n            for( int i=0; i<grid.length; i++ )\\n                for( int j=0; j<grid[i].length; j++ )\\n                    if( grid[i][j]==1 && rottenNeighbor( grid, i, j ) ) {\\n                        grid[i][j]=-2;\\n                        changed=true;\\n                    }\\n            \\n            // flip marked oranges to now be rotten\\n            if( changed ) for( int i=0; i<grid.length; i++ )\\n                for( int j=0; j<grid[i].length; j++ )\\n                    if( grid[i][j]==-2 ) grid[i][j]=2;\\n        }\\n\\n        // Check if there\\'s any fresh oranges left:\\n        for( int i=0; i<grid.length; i++ )\\n            for( int j=0; j<grid[i].length; j++ )\\n                if( grid[i][j]==1 ) return -1;\\n        \\n        return minutes;\\n    }\\n    \\n    private static boolean rottenNeighbor( int[][] grid, int x, int y ) {\\n        if( x>0 && grid[x-1][y]==2 ) return true;\\n        if( y>0 && grid[x][y-1]==2 ) return true;\\n        if( (x+1)<grid.length && grid[x+1][y]==2 ) return true;\\n        if( (y+1)<grid[x].length && grid[x][y+1]==2 ) return true;\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3650187,
                "title": "most-optimized-c-bfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int i,j,a=grid.size(),b=grid[0].size();\\n        int x = 0;\\n        queue<vector<int>> q;\\n        vector<int> v;\\n        for(i = 0; i < a; i++){\\n            for(j = 0; j < b; j++){\\n                if(grid[i][j]==2){\\n                    q.push({i,j});\\n                    grid[i][j] = 0;\\n                }\\n                x += (grid[i][j]==1);\\n            }\\n        }\\n        if(x==0)return 0;\\n        int ans = -1,n;\\n        while(!q.empty()){\\n            ans++;\\n            n = q.size();\\n            while(n--){v = q.front();\\n            q.pop();\\n            if(v[0]+1<a&&grid[v[0]+1][v[1]]==1){\\n                q.push({v[0]+1,v[1]});\\n                x--;\\n                grid[v[0]+1][v[1]]=0;\\n            }\\n            if(v[1]+1<b&&grid[v[0]][v[1]+1]==1){\\n                q.push({v[0],v[1]+1});\\n                x--;\\n                grid[v[0]][v[1]+1]=0;\\n            }\\n            if(v[0]-1>=0&&grid[v[0]-1][v[1]]==1){\\n                q.push({v[0]-1,v[1]});\\n                x--;\\n                grid[v[0]-1][v[1]]=0;\\n            }\\n            if(v[1]-1>=0&&grid[v[0]][v[1]-1]==1){\\n                q.push({v[0],v[1]-1});\\n                x--;\\n                grid[v[0]][v[1]-1]=0;\\n            }}\\n        }\\n        return (x==0)?ans:-1;;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int i,j,a=grid.size(),b=grid[0].size();\\n        int x = 0;\\n        queue<vector<int>> q;\\n        vector<int> v;\\n        for(i = 0; i < a; i++){\\n            for(j = 0; j < b; j++){\\n                if(grid[i][j]==2){\\n                    q.push({i,j});\\n                    grid[i][j] = 0;\\n                }\\n                x += (grid[i][j]==1);\\n            }\\n        }\\n        if(x==0)return 0;\\n        int ans = -1,n;\\n        while(!q.empty()){\\n            ans++;\\n            n = q.size();\\n            while(n--){v = q.front();\\n            q.pop();\\n            if(v[0]+1<a&&grid[v[0]+1][v[1]]==1){\\n                q.push({v[0]+1,v[1]});\\n                x--;\\n                grid[v[0]+1][v[1]]=0;\\n            }\\n            if(v[1]+1<b&&grid[v[0]][v[1]+1]==1){\\n                q.push({v[0],v[1]+1});\\n                x--;\\n                grid[v[0]][v[1]+1]=0;\\n            }\\n            if(v[0]-1>=0&&grid[v[0]-1][v[1]]==1){\\n                q.push({v[0]-1,v[1]});\\n                x--;\\n                grid[v[0]-1][v[1]]=0;\\n            }\\n            if(v[1]-1>=0&&grid[v[0]][v[1]-1]==1){\\n                q.push({v[0],v[1]-1});\\n                x--;\\n                grid[v[0]][v[1]-1]=0;\\n            }}\\n        }\\n        return (x==0)?ans:-1;;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450905,
                "title": "iterative-bfs-solution-explanation-commentaries",
                "content": "# Intuition\\nThe approach used is a Breadth-First Search (BFS) algorithm, implemented with a Queue data structure, to traverse the grid of oranges, track rotten oranges and count fresh oranges.\\n\\n# Approach\\nThe algorithm starts by initializing a queue to store the coordinates of rotten oranges found in the grid. Then, the grid is traversed to count the number of fresh oranges and add the rotten oranges\\' coordinates to the queue. If there are no fresh oranges, the function returns 0 because there is no need for any minute to elapse.\\n\\nThe while loop iterates until the queue is empty. In each iteration, the size of the queue is obtained to process all the elements currently in the queue, which are the rotten oranges found in the previous minute.\\n\\nFor each rotten orange, its adjacent cells are checked, and if they are fresh oranges, they are marked as rotten, added to the queue, and the counter of fresh oranges is decremented. The BFS algorithm continues to the next level by processing all the fresh oranges found in the previous level.\\n\\nAt each iteration of the while loop, the time variable is incremented to keep track of the minutes that have elapsed since the first rotten orange was found.\\n\\nFinally, if there are no fresh oranges left, the function returns the elapsed time. Otherwise, it returns -1 to indicate that there are still fresh oranges left that cannot be rotten.\\n\\n# Complexity\\n- Time complexity:\\nO(n * m), where n and m are the dimensions of the grid because the BFS algorithm must visit every cell in the grid\\n\\n- Space complexity:\\nO(n * m), the queue can store up to all the fresh oranges in the worst-case scenario.\\n\\n# Code\\n```\\nclass Solution {\\n    // initialize time variable to 0\\n    private int time = 0;\\n\\n    public int orangesRotting(int[][] grid) {\\n        // get dimensions of grid\\n        int y = grid.length;\\n        int x = grid[0].length;\\n\\n        // create queue to store rotten oranges\\n        Queue<int[]> rotten = new LinkedList<>();\\n\\n        // count number of fresh oranges\\n        int freshOranges = 0;\\n\\n        // traverse grid to find rotten and fresh oranges\\n        for (int i = 0; i < y; i++) {\\n            for (int j = 0; j < x; j++) {\\n                if (grid[i][j] == 2) { // if cell contains a rotten orange\\n                    rotten.offer(new int[]{i, j}); // add its coordinates to the queue\\n                } else if (grid[i][j] == 1) { // if cell contains a fresh orange\\n                    freshOranges++; // increment counter of fresh oranges\\n                }\\n            }\\n        }\\n\\n        // if there are no fresh oranges, return 0\\n        if (freshOranges == 0) {\\n            return 0;\\n        }\\n\\n        // use BFS algorithm to find minimum time to rot all fresh oranges\\n        while (!rotten.isEmpty()) { // while there are still rotten oranges to process\\n            int size = rotten.size(); // get size of current level of BFS tree\\n\\n            // process all rotten oranges in current level of BFS tree\\n            for (int i = 0; i < size; i++) {\\n                int[] temp = rotten.poll(); // get coordinates of next rotten orange\\n                assert temp != null; // make sure coordinates are not null\\n                int row = temp[0]; // get row coordinate\\n                int col = temp[1]; // get column coordinate\\n\\n                // check adjacent cells to see if they are fresh oranges\\n                // if so, mark them as rotten, add to queue, and decrement counter of fresh oranges\\n                if (row > 0 && grid[row - 1][col] == 1) {\\n                    rotten.offer(new int[]{row - 1, col});\\n                    grid[row - 1][col] = 2;\\n                    freshOranges--;\\n                }\\n                if (row < y - 1 && grid[row + 1][col] == 1) {\\n                    rotten.offer(new int[]{row + 1, col});\\n                    grid[row + 1][col] = 2;\\n                    freshOranges--;\\n                }\\n                if (col > 0 && grid[row][col - 1] == 1) {\\n                    rotten.offer(new int[]{row, col - 1});\\n                    grid[row][col - 1] = 2;\\n                    freshOranges--;\\n                }\\n                if (col < x - 1 && grid[row][col + 1] == 1) {\\n                    rotten.offer(new int[]{row, col + 1});\\n                    grid[row][col + 1] = 2;\\n                    freshOranges--;\\n                }\\n            }\\n\\n            time++; // increment time counter for each level of BFS tree\\n        }\\n\\n        // if there are still fresh oranges, return -1 to indicate it is impossible to rot all of them\\n        // otherwise, return elapsed time\\n        return freshOranges == 0 ? time - 1 : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Breadth-First Search",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    // initialize time variable to 0\\n    private int time = 0;\\n\\n    public int orangesRotting(int[][] grid) {\\n        // get dimensions of grid\\n        int y = grid.length;\\n        int x = grid[0].length;\\n\\n        // create queue to store rotten oranges\\n        Queue<int[]> rotten = new LinkedList<>();\\n\\n        // count number of fresh oranges\\n        int freshOranges = 0;\\n\\n        // traverse grid to find rotten and fresh oranges\\n        for (int i = 0; i < y; i++) {\\n            for (int j = 0; j < x; j++) {\\n                if (grid[i][j] == 2) { // if cell contains a rotten orange\\n                    rotten.offer(new int[]{i, j}); // add its coordinates to the queue\\n                } else if (grid[i][j] == 1) { // if cell contains a fresh orange\\n                    freshOranges++; // increment counter of fresh oranges\\n                }\\n            }\\n        }\\n\\n        // if there are no fresh oranges, return 0\\n        if (freshOranges == 0) {\\n            return 0;\\n        }\\n\\n        // use BFS algorithm to find minimum time to rot all fresh oranges\\n        while (!rotten.isEmpty()) { // while there are still rotten oranges to process\\n            int size = rotten.size(); // get size of current level of BFS tree\\n\\n            // process all rotten oranges in current level of BFS tree\\n            for (int i = 0; i < size; i++) {\\n                int[] temp = rotten.poll(); // get coordinates of next rotten orange\\n                assert temp != null; // make sure coordinates are not null\\n                int row = temp[0]; // get row coordinate\\n                int col = temp[1]; // get column coordinate\\n\\n                // check adjacent cells to see if they are fresh oranges\\n                // if so, mark them as rotten, add to queue, and decrement counter of fresh oranges\\n                if (row > 0 && grid[row - 1][col] == 1) {\\n                    rotten.offer(new int[]{row - 1, col});\\n                    grid[row - 1][col] = 2;\\n                    freshOranges--;\\n                }\\n                if (row < y - 1 && grid[row + 1][col] == 1) {\\n                    rotten.offer(new int[]{row + 1, col});\\n                    grid[row + 1][col] = 2;\\n                    freshOranges--;\\n                }\\n                if (col > 0 && grid[row][col - 1] == 1) {\\n                    rotten.offer(new int[]{row, col - 1});\\n                    grid[row][col - 1] = 2;\\n                    freshOranges--;\\n                }\\n                if (col < x - 1 && grid[row][col + 1] == 1) {\\n                    rotten.offer(new int[]{row, col + 1});\\n                    grid[row][col + 1] = 2;\\n                    freshOranges--;\\n                }\\n            }\\n\\n            time++; // increment time counter for each level of BFS tree\\n        }\\n\\n        // if there are still fresh oranges, return -1 to indicate it is impossible to rot all of them\\n        // otherwise, return elapsed time\\n        return freshOranges == 0 ? time - 1 : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284695,
                "title": "best-o-n-m-solution",
                "content": "# Approach\\nUsing BFS Traversal\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*m)$$\\n\\n- Space complexity:\\n$$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        queue <pair<pair<int, int>, int>> q;\\n        int cntFresh = 0;\\n        int visited[row][col];\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (grid[i][j] == 2) {\\n                    q.push({{i, j}, 0});\\n                    visited[i][j] = 2;\\n                } else {\\n                    visited[i][j] = 0;\\n                }\\n                if (grid[i][j] == 1)\\n                    cntFresh++;\\n            }\\n        }\\n        int time = 0;\\n        int drow[] = {-1, 0, +1, 0};\\n        int dcol[] = {0, +1, 0, -1};\\n        int cnt = 0;\\n        while (!q.empty()) {\\n            int r = q.front().first.first;\\n            int c = q.front().first.second;\\n            int t = q.front().second;\\n            q.pop();\\n            time = max(time, t);\\n            for (int i = 0; i < 4; i++) {\\n                int nrow = r + drow[i];\\n                int ncol = c + dcol[i];\\n                if (nrow >= 0 && nrow < row && ncol >= 0 && ncol < col &&\\n                    visited[nrow][ncol] == 0 && grid[nrow][ncol] == 1) {\\n                        q.push({{nrow, ncol}, t + 1});\\n                        visited[nrow][ncol] = 2;\\n                        cnt++;\\n                    }\\n            }\\n        }\\n        if (cntFresh != cnt)\\n            return -1;\\n        return time;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        queue <pair<pair<int, int>, int>> q;\\n        int cntFresh = 0;\\n        int visited[row][col];\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (grid[i][j] == 2) {\\n                    q.push({{i, j}, 0});\\n                    visited[i][j] = 2;\\n                } else {\\n                    visited[i][j] = 0;\\n                }\\n                if (grid[i][j] == 1)\\n                    cntFresh++;\\n            }\\n        }\\n        int time = 0;\\n        int drow[] = {-1, 0, +1, 0};\\n        int dcol[] = {0, +1, 0, -1};\\n        int cnt = 0;\\n        while (!q.empty()) {\\n            int r = q.front().first.first;\\n            int c = q.front().first.second;\\n            int t = q.front().second;\\n            q.pop();\\n            time = max(time, t);\\n            for (int i = 0; i < 4; i++) {\\n                int nrow = r + drow[i];\\n                int ncol = c + dcol[i];\\n                if (nrow >= 0 && nrow < row && ncol >= 0 && ncol < col &&\\n                    visited[nrow][ncol] == 0 && grid[nrow][ncol] == 1) {\\n                        q.push({{nrow, ncol}, t + 1});\\n                        visited[nrow][ncol] = 2;\\n                        cnt++;\\n                    }\\n            }\\n        }\\n        if (cntFresh != cnt)\\n            return -1;\\n        return time;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251088,
                "title": "bfs-approach-96-7-beats",
                "content": "# Intuition\\n![download (1).jfif](https://assets.leetcode.com/users/images/be6b9763-87cd-40de-9a17-f820422fbc87_1678376852.3238225.jpeg)\\nBFS approach\\n# Complexity\\n- Time complexity:\\nO(N*M)\\n\\n- Space complexity:\\nO(N*M)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        // {{row,col},time}\\n        queue<pair<pair<int,int>, int> >q;\\n        int vis[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==2){\\n                    q.push({{i,j},0});\\n                    vis[i][j]=2; //mark vis as 2\\n                }\\n                else{\\n                    vis[i][j]=0;  //mark vis as 0\\n                }\\n            }\\n        }\\n        int time=0;\\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,1,0,-1};\\n        while(!q.empty()){\\n        int r=q.front().first.first;\\n        int c=q.front().first.second;\\n        int t=q.front().second;\\n        tm=max(tm,t);\\n        q.pop();\\n       \\n\\n        for(int i=0;i<4;i++){\\n//to check in all direction up,left,right,down\\n            int nrow=r+drow[i];\\n            int ncol=c+dcol[i];\\n            if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && vis[nrow][ncol]!=2 &&\\n            grid[nrow][ncol]==1){\\n                q.push({{nrow,ncol},t+1});\\n                vis[nrow][ncol]=2;\\n\\n        }\\n        \\n        }\\n\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]!=2 && grid[i][j]==1){\\n                    return -1;\\n                }\\n            }\\n        }\\n        return time;\\n        \\n    }\\n};\\n\\n//please upvote!!\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        // {{row,col},time}\\n        queue<pair<pair<int,int>, int> >q;\\n        int vis[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==2){\\n                    q.push({{i,j},0});\\n                    vis[i][j]=2; //mark vis as 2\\n                }\\n                else{\\n                    vis[i][j]=0;  //mark vis as 0\\n                }\\n            }\\n        }\\n        int time=0;\\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,1,0,-1};\\n        while(!q.empty()){\\n        int r=q.front().first.first;\\n        int c=q.front().first.second;\\n        int t=q.front().second;\\n        tm=max(tm,t);\\n        q.pop();\\n       \\n\\n        for(int i=0;i<4;i++){\\n//to check in all direction up,left,right,down\\n            int nrow=r+drow[i];\\n            int ncol=c+dcol[i];\\n            if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && vis[nrow][ncol]!=2 &&\\n            grid[nrow][ncol]==1){\\n                q.push({{nrow,ncol},t+1});\\n                vis[nrow][ncol]=2;\\n\\n        }\\n        \\n        }\\n\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]!=2 && grid[i][j]==1){\\n                    return -1;\\n                }\\n            }\\n        }\\n        return time;\\n        \\n    }\\n};\\n\\n//please upvote!!\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110427,
                "title": "c-0-ms-100-faster-bfs",
                "content": "# Intuition\\nBFS\\n\\n# Approach\\nGraph BFS\\n\\n# Complexity\\n- Time complexity:\\nO(n * m) + O(n * m)*4\\n\\n- Space complexity:\\nO(node)\\n\\n# Code\\n```\\nstruct node{\\n  int x , y , time;\\n    node(int _x,int _y,int _time){\\n        x = _x;\\n        y = _y;\\n        time = _time;\\n        \\n    }\\n};\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        queue<node> q;\\n        int cntoranges = 0;\\n        for(int i  =0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(grid[i][j] == 2){\\n                    q.push(node(i,j,0));\\n                }\\n                if(grid[i][j] != 0) cntoranges++;\\n                \\n            }\\n            \\n        }\\n        int ans = 0;\\n        int cnt =0;\\n        while(!q.empty()){\\n            int x = q.front().x;\\n            int y = q.front().y;\\n            int time = q.front().time;\\n            q.pop();\\n            ans = max(ans , time);\\n            cnt++;\\n            int dx[] = {-1, 0 ,1 , 0};\\n            int dy[] = {0 , -1, 0,1};\\n            for(int i =0;i<4;i++){\\n                int newx  = x + dx[i];\\n                int newy = y + dy[i];\\n                if(newx >=0 && newy >=0 && newx<n && newy<m && grid[newx][newy] == 1){\\n                    grid[newx][newy] = 2;\\n                    q.push(node(newx , newy , time+1));\\n                    \\n                }\\n            }\\n        }\\n        if(cnt == cntoranges) return ans;\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct node{\\n  int x , y , time;\\n    node(int _x,int _y,int _time){\\n        x = _x;\\n        y = _y;\\n        time = _time;\\n        \\n    }\\n};\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        queue<node> q;\\n        int cntoranges = 0;\\n        for(int i  =0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(grid[i][j] == 2){\\n                    q.push(node(i,j,0));\\n                }\\n                if(grid[i][j] != 0) cntoranges++;\\n                \\n            }\\n            \\n        }\\n        int ans = 0;\\n        int cnt =0;\\n        while(!q.empty()){\\n            int x = q.front().x;\\n            int y = q.front().y;\\n            int time = q.front().time;\\n            q.pop();\\n            ans = max(ans , time);\\n            cnt++;\\n            int dx[] = {-1, 0 ,1 , 0};\\n            int dy[] = {0 , -1, 0,1};\\n            for(int i =0;i<4;i++){\\n                int newx  = x + dx[i];\\n                int newy = y + dy[i];\\n                if(newx >=0 && newy >=0 && newx<n && newy<m && grid[newx][newy] == 1){\\n                    grid[newx][newy] = 2;\\n                    q.push(node(newx , newy , time+1));\\n                    \\n                }\\n            }\\n        }\\n        if(cnt == cntoranges) return ans;\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935767,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int ans=-1;\\n        int fresh=0;\\n        \\n        queue<pair<int,int>> q;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                if(grid[i][j]==1)\\n                fresh++;\\n                if(grid[i][j]==2)\\n                    q.push({i,j});\\n            }\\n        }\\n        // int d[5]={0, -1, 0, 1, 0};\\n        vector<int> d={-1,0,1,0,-1};\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++)\\n            {\\n                pair<int,int> p=q.front();\\n                q.pop();\\n                for(int j=0;j<4;j++)\\n                {\\n                    int r=p.first+d[j];\\n                    int c=p.second+d[j+1];\\n                    if(r>=0 && c>=0 && r<grid.size() && c<grid[0].size() && grid[r][c]==1)\\n                    {\\n                        fresh--;\\n                        grid[r][c]=2;\\n                        q.push({r,c});\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        if(fresh>0)\\n            return -1;\\n        if(ans==-1)\\n            return 0;\\n\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int ans=-1;\\n        int fresh=0;\\n        \\n        queue<pair<int,int>> q;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                if(grid[i][j]==1)\\n                fresh++;\\n                if(grid[i][j]==2)\\n                    q.push({i,j});\\n            }\\n        }\\n        // int d[5]={0, -1, 0, 1, 0};\\n        vector<int> d={-1,0,1,0,-1};\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++)\\n            {\\n                pair<int,int> p=q.front();\\n                q.pop();\\n                for(int j=0;j<4;j++)\\n                {\\n                    int r=p.first+d[j];\\n                    int c=p.second+d[j+1];\\n                    if(r>=0 && c>=0 && r<grid.size() && c<grid[0].size() && grid[r][c]==1)\\n                    {\\n                        fresh--;\\n                        grid[r][c]=2;\\n                        q.push({r,c});\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        if(fresh>0)\\n            return -1;\\n        if(ans==-1)\\n            return 0;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813476,
                "title": "java-solution-using-bfs",
                "content": "Similar to question 01-Matrix. for explaination refer below page\\nhttps://leetcode.com/problems/01-matrix/discuss/1715389/SImple-java-solution-with-comments-or-bfs\\n\\nApproach 1\\n```\\n    public int orangesRotting(int[][] grid) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        init(grid,queue);\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int level=0;\\n        int[][] dirs={{-1,0},{1,0},{0,-1},{0,1}};\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            level++;\\n            while(size-->0) {\\n                int[] rc = queue.poll();\\n                for(int[] dir:dirs) {\\n                    int r=rc[0]+dir[0];\\n                    int c=rc[1]+dir[1];\\n                    if(r<0||c<0||r>=m||c>=n||grid[r][c]!=1) {\\n                        continue;\\n                    }\\n                    grid[r][c]=2;\\n                    queue.add(new int[]{r,c});\\n                    \\n                }\\n            }\\n        }\\n\\t\\t//check if 1 still exists\\n        for(int i=0;i<grid.length;i++) {\\n            for(int j=0;j<grid[i].length;j++) {\\n                if(grid[i][j]==1) {\\n                    return -1;\\n                }\\n            }\\n        }\\n        return level==0?0:level-1;\\n    }\\n    \\n    private void init(int[][] grid,Queue<int[]> queue) {\\n        \\n        for(int i=0;i<grid.length;i++) {\\n            for(int j=0;j<grid[i].length;j++) {\\n                if(grid[i][j]==2) {\\n                    queue.add(new int[]{i,j});\\n                }\\n            }\\n        }\\n        \\n    }\\n```\\nApproach 2\\n```\\npublic int orangesRotting(int[][] grid) {\\n\\t\\tQueue<int[]> queue = new LinkedList<>();\\n\\t\\tint fresh = init(grid, queue);\\n\\t\\tif (fresh == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint m = grid.length;\\n\\t\\tint n = grid[0].length;\\n\\t\\tint level = 0;\\n\\t\\tint[][] dirs = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tint size = queue.size();\\n\\t\\t\\tlevel++;\\n\\t\\t\\twhile (size-- > 0) {\\n\\t\\t\\t\\tint[] rc = queue.poll();\\n\\t\\t\\t\\tfor (int[] dir : dirs) {\\n\\t\\t\\t\\t\\tint r = rc[0] + dir[0];\\n\\t\\t\\t\\t\\tint c = rc[1] + dir[1];\\n\\t\\t\\t\\t\\tif (r < 0 || c < 0 || r >= m || c >= n || grid[r][c] != 1) {\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tgrid[r][c] = 2;\\n\\t\\t\\t\\t\\tqueue.add(new int[] { r, c });\\n\\t\\t\\t\\t\\tfresh--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn fresh == 0 ? level - 1 : -1;\\n\\t}\\n\\n\\tprivate int init(int[][] grid, Queue<int[]> queue) {\\n\\t\\tint c = 0;\\n\\t\\tfor (int i = 0; i < grid.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < grid[i].length; j++) {\\n\\t\\t\\t\\tif (grid[i][j] == 2) {\\n\\t\\t\\t\\t\\tqueue.add(new int[] { i, j });\\n\\t\\t\\t\\t} else if (grid[i][j] == 1) {\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn c;\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue",
                    "Iterator"
                ],
                "code": "```\\n    public int orangesRotting(int[][] grid) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        init(grid,queue);\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int level=0;\\n        int[][] dirs={{-1,0},{1,0},{0,-1},{0,1}};\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            level++;\\n            while(size-->0) {\\n                int[] rc = queue.poll();\\n                for(int[] dir:dirs) {\\n                    int r=rc[0]+dir[0];\\n                    int c=rc[1]+dir[1];\\n                    if(r<0||c<0||r>=m||c>=n||grid[r][c]!=1) {\\n                        continue;\\n                    }\\n                    grid[r][c]=2;\\n                    queue.add(new int[]{r,c});\\n                    \\n                }\\n            }\\n        }\\n\\t\\t//check if 1 still exists\\n        for(int i=0;i<grid.length;i++) {\\n            for(int j=0;j<grid[i].length;j++) {\\n                if(grid[i][j]==1) {\\n                    return -1;\\n                }\\n            }\\n        }\\n        return level==0?0:level-1;\\n    }\\n    \\n    private void init(int[][] grid,Queue<int[]> queue) {\\n        \\n        for(int i=0;i<grid.length;i++) {\\n            for(int j=0;j<grid[i].length;j++) {\\n                if(grid[i][j]==2) {\\n                    queue.add(new int[]{i,j});\\n                }\\n            }\\n        }\\n        \\n    }\\n```\n```\\npublic int orangesRotting(int[][] grid) {\\n\\t\\tQueue<int[]> queue = new LinkedList<>();\\n\\t\\tint fresh = init(grid, queue);\\n\\t\\tif (fresh == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint m = grid.length;\\n\\t\\tint n = grid[0].length;\\n\\t\\tint level = 0;\\n\\t\\tint[][] dirs = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tint size = queue.size();\\n\\t\\t\\tlevel++;\\n\\t\\t\\twhile (size-- > 0) {\\n\\t\\t\\t\\tint[] rc = queue.poll();\\n\\t\\t\\t\\tfor (int[] dir : dirs) {\\n\\t\\t\\t\\t\\tint r = rc[0] + dir[0];\\n\\t\\t\\t\\t\\tint c = rc[1] + dir[1];\\n\\t\\t\\t\\t\\tif (r < 0 || c < 0 || r >= m || c >= n || grid[r][c] != 1) {\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tgrid[r][c] = 2;\\n\\t\\t\\t\\t\\tqueue.add(new int[] { r, c });\\n\\t\\t\\t\\t\\tfresh--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn fresh == 0 ? level - 1 : -1;\\n\\t}\\n\\n\\tprivate int init(int[][] grid, Queue<int[]> queue) {\\n\\t\\tint c = 0;\\n\\t\\tfor (int i = 0; i < grid.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < grid[i].length; j++) {\\n\\t\\t\\t\\tif (grid[i][j] == 2) {\\n\\t\\t\\t\\t\\tqueue.add(new int[] { i, j });\\n\\t\\t\\t\\t} else if (grid[i][j] == 1) {\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn c;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2778560,
                "title": "java-bfs-a-bit-oop-clean",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n\\n        Queue<Orange> q = new LinkedList<>();\\n        int[][] visited = new int[m][n];\\n\\n        int fresh = 0;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 2) {\\n                    q.offer(new Orange(i, j, 0));\\n                    visited[i][j] = 2;\\n                }\\n\\n                if (grid[i][j] == 1) fresh++;\\n            }\\n        }\\n\\n        int time = 0;\\n        int spoiled = 0;\\n\\n        int[] rowDir = {1, -1, 0, 0};\\n        int[] colDir = {0, 0, 1, -1};\\n\\n        while (!q.isEmpty()) {\\n            Orange o = q.poll();\\n            int r = o.row;\\n            int c = o.col;\\n            int t = o.time;\\n\\n            time = Math.max(time, t);\\n\\n            for (int i = 0; i < 4; i++) {\\n                int nRow = r + rowDir[i];\\n                int nCol = c + colDir[i];\\n\\n                if (nRow >= 0 && nRow < m && nCol >= 0 && nCol < n &&\\n                    visited[nRow][nCol] != 2 && grid[nRow][nCol] == 1) {\\n                    q.offer(new Orange(nRow, nCol, t + 1));\\n                    visited[nRow][nCol] = 2;\\n                    spoiled++;\\n                }\\n            }\\n\\n        }\\n\\n        return spoiled == fresh ? time : -1;\\n    }\\n\\n    class Orange {\\n        int row;\\n        int col;\\n        int time;\\n\\n        public Orange(int row, int col, int time) {\\n            this.row = row;\\n            this.col = col;\\n            this.time = time;\\n        }\\n    }\\n}\\n\\n// TC: O(m * n), SC: O(m * n)\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n\\n        Queue<Orange> q = new LinkedList<>();\\n        int[][] visited = new int[m][n];\\n\\n        int fresh = 0;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 2) {\\n                    q.offer(new Orange(i, j, 0));\\n                    visited[i][j] = 2;\\n                }\\n\\n                if (grid[i][j] == 1) fresh++;\\n            }\\n        }\\n\\n        int time = 0;\\n        int spoiled = 0;\\n\\n        int[] rowDir = {1, -1, 0, 0};\\n        int[] colDir = {0, 0, 1, -1};\\n\\n        while (!q.isEmpty()) {\\n            Orange o = q.poll();\\n            int r = o.row;\\n            int c = o.col;\\n            int t = o.time;\\n\\n            time = Math.max(time, t);\\n\\n            for (int i = 0; i < 4; i++) {\\n                int nRow = r + rowDir[i];\\n                int nCol = c + colDir[i];\\n\\n                if (nRow >= 0 && nRow < m && nCol >= 0 && nCol < n &&\\n                    visited[nRow][nCol] != 2 && grid[nRow][nCol] == 1) {\\n                    q.offer(new Orange(nRow, nCol, t + 1));\\n                    visited[nRow][nCol] = 2;\\n                    spoiled++;\\n                }\\n            }\\n\\n        }\\n\\n        return spoiled == fresh ? time : -1;\\n    }\\n\\n    class Orange {\\n        int row;\\n        int col;\\n        int time;\\n\\n        public Orange(int row, int col, int time) {\\n            this.row = row;\\n            this.col = col;\\n            this.time = time;\\n        }\\n    }\\n}\\n\\n// TC: O(m * n), SC: O(m * n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755528,
                "title": "java-easy-and-fast-explained-dfs-solution-100-97-fastest",
                "content": "It is not difficult to come up with a solution using **DFS** for the cases specified in the description of the problem. The point is that we start with an element with a value of 2 and go up, down, left, and right, changing the value to a negative minute value in `nextMin`. We store the value in an array `memo` so that our number of minutes has a reference.\\n\\n**BUT!** The difficulty is that, for example, ***there will be a rotten orange on the top left and bottom right, and they are combined with fresh ones***. In this case, there is a risk of calculating the maximum value once, giving 4 and forgetting, but this is not true! We have to return not 4, but 2, because the rot comes from two sides.\\nTherefore, when we return to the orange with a value of 2, and look up, down, left and right - we need to pay attention so that the value of minutes is greater than what we plan to set. If so, we set the updated, smaller value.\\n\\n*Then we will first write 1, 2, 3, 4, and then rewrite it to 1, 2, 2, 1. Number of minutes: 2.* We do not change old values that are only minutes or less, so there will be no unnecessary actions.\\n\\n```\\nclass Solution {\\n    public static int orangesRotting(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == 2) dfs(grid, i, j, -1, new int[1]);\\n            }\\n        }\\n\\n        int maxMinutes = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                int elem = grid[i][j];\\n                if (elem == 1) return -1;\\n                else if (elem < 0) maxMinutes = Math.min(elem, maxMinutes);\\n            }\\n        }\\n\\n        return maxMinutes == 0 ? 0 : -maxMinutes - 1;\\n    }\\n\\n    private static int dfs(int[][] grid, int i, int j, int nextMin, int[] memo) {\\n        grid[i][j] = nextMin; // rotten-stepped\\n        if (memo[0] > nextMin) memo[0] = nextMin;\\n\\n        nextMin--;\\n        if (i < grid.length - 1 && (grid[i + 1][j] == 1 || grid[i + 1][j] < nextMin))\\n            dfs(grid, i + 1, j, nextMin, memo);\\n\\n        if (i > 0 && (grid[i - 1][j] == 1 || grid[i - 1][j] < nextMin))\\n            dfs(grid, i - 1, j, nextMin, memo);\\n\\n        if (j < grid[i].length - 1 && (grid[i][j + 1] == 1 || grid[i][j + 1] < nextMin))\\n            dfs(grid, i, j + 1, nextMin, memo);\\n\\n        if (j > 0 && (grid[i][j - 1] == 1 || grid[i][j - 1] < nextMin))\\n            dfs(grid, i, j - 1, nextMin, memo);\\n\\n        return memo[0];\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/0f84a950-ca45-4866-ace8-1e850a152b50_1667041210.8465068.png)\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public static int orangesRotting(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == 2) dfs(grid, i, j, -1, new int[1]);\\n            }\\n        }\\n\\n        int maxMinutes = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                int elem = grid[i][j];\\n                if (elem == 1) return -1;\\n                else if (elem < 0) maxMinutes = Math.min(elem, maxMinutes);\\n            }\\n        }\\n\\n        return maxMinutes == 0 ? 0 : -maxMinutes - 1;\\n    }\\n\\n    private static int dfs(int[][] grid, int i, int j, int nextMin, int[] memo) {\\n        grid[i][j] = nextMin; // rotten-stepped\\n        if (memo[0] > nextMin) memo[0] = nextMin;\\n\\n        nextMin--;\\n        if (i < grid.length - 1 && (grid[i + 1][j] == 1 || grid[i + 1][j] < nextMin))\\n            dfs(grid, i + 1, j, nextMin, memo);\\n\\n        if (i > 0 && (grid[i - 1][j] == 1 || grid[i - 1][j] < nextMin))\\n            dfs(grid, i - 1, j, nextMin, memo);\\n\\n        if (j < grid[i].length - 1 && (grid[i][j + 1] == 1 || grid[i][j + 1] < nextMin))\\n            dfs(grid, i, j + 1, nextMin, memo);\\n\\n        if (j > 0 && (grid[i][j - 1] == 1 || grid[i][j - 1] < nextMin))\\n            dfs(grid, i, j - 1, nextMin, memo);\\n\\n        return memo[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720672,
                "title": "fully-xplained-python-code",
                "content": "```\\nfrom collections import deque\\n\\n# Time complexity: O(rows * cols) -> each cell is visited at least once\\n# Space complexity: O(rows * cols) -> in the worst case if all the oranges are rotten they will be added to the queue\\n\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        # number of rows\\n        rows = len(grid)\\n        if rows == 0:  # check if grid is empty\\n            return -1\\n        \\n        # number of columns\\n        cols = len(grid[0])\\n        \\n        # keep track of fresh oranges\\n        fresh_cnt = 0\\n        \\n        # queue with rotten oranges (for BFS)\\n        rotten = deque()\\n        \\n        # visit each cell in the grid\\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == 2:\\n                    # add the rotten orange coordinates to the queue\\n                    rotten.append((r, c))\\n                elif grid[r][c] == 1:\\n                    # update fresh oranges count\\n                    fresh_cnt += 1\\n        \\n        # keep track of minutes passed.\\n        minutes_passed = 0\\n        \\n        # If there are rotten oranges in the queue and there are still fresh oranges in the grid keep looping\\n        while rotten and fresh_cnt > 0:\\n\\n            # update the number of minutes passed\\n            # it is safe to update the minutes by 1, since we visit oranges level by level in BFS traversal.\\n            minutes_passed += 1\\n            \\n            # process rotten oranges on the current level\\n            for _ in range(len(rotten)):\\n                x, y = rotten.popleft()\\n                \\n                # visit all the adjacent cells\\n                for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:\\n                    # calculate the coordinates of the adjacent cell\\n                    xx, yy = x + dx, y + dy\\n                    # ignore the cell if it is out of the grid boundary\\n                    if xx < 0 or xx == rows or yy < 0 or yy == cols:\\n                        continue\\n                    # ignore the cell if it is empty \\'0\\' or visited before \\'2\\'\\n                    if grid[xx][yy] == 0 or grid[xx][yy] == 2:\\n                        continue\\n                        \\n                    # update the fresh oranges count\\n                    fresh_cnt -= 1\\n                    \\n                    # mark the current fresh orange as rotten\\n                    grid[xx][yy] = 2\\n                    \\n                    # add the current rotten to the queue\\n                    rotten.append((xx, yy))\\n\\n        \\n        # return the number of minutes taken to make all the fresh oranges to be rotten\\n        # return -1 if there are fresh oranges left in the grid (there were no adjacent rotten oranges to make them rotten)\\n        return minutes_passed if fresh_cnt == 0 else -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import deque\\n\\n# Time complexity: O(rows * cols) -> each cell is visited at least once\\n# Space complexity: O(rows * cols) -> in the worst case if all the oranges are rotten they will be added to the queue\\n\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        # number of rows\\n        rows = len(grid)\\n        if rows == 0:  # check if grid is empty\\n            return -1\\n        \\n        # number of columns\\n        cols = len(grid[0])\\n        \\n        # keep track of fresh oranges\\n        fresh_cnt = 0\\n        \\n        # queue with rotten oranges (for BFS)\\n        rotten = deque()\\n        \\n        # visit each cell in the grid\\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == 2:\\n                    # add the rotten orange coordinates to the queue\\n                    rotten.append((r, c))\\n                elif grid[r][c] == 1:\\n                    # update fresh oranges count\\n                    fresh_cnt += 1\\n        \\n        # keep track of minutes passed.\\n        minutes_passed = 0\\n        \\n        # If there are rotten oranges in the queue and there are still fresh oranges in the grid keep looping\\n        while rotten and fresh_cnt > 0:\\n\\n            # update the number of minutes passed\\n            # it is safe to update the minutes by 1, since we visit oranges level by level in BFS traversal.\\n            minutes_passed += 1\\n            \\n            # process rotten oranges on the current level\\n            for _ in range(len(rotten)):\\n                x, y = rotten.popleft()\\n                \\n                # visit all the adjacent cells\\n                for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:\\n                    # calculate the coordinates of the adjacent cell\\n                    xx, yy = x + dx, y + dy\\n                    # ignore the cell if it is out of the grid boundary\\n                    if xx < 0 or xx == rows or yy < 0 or yy == cols:\\n                        continue\\n                    # ignore the cell if it is empty \\'0\\' or visited before \\'2\\'\\n                    if grid[xx][yy] == 0 or grid[xx][yy] == 2:\\n                        continue\\n                        \\n                    # update the fresh oranges count\\n                    fresh_cnt -= 1\\n                    \\n                    # mark the current fresh orange as rotten\\n                    grid[xx][yy] = 2\\n                    \\n                    # add the current rotten to the queue\\n                    rotten.append((xx, yy))\\n\\n        \\n        # return the number of minutes taken to make all the fresh oranges to be rotten\\n        # return -1 if there are fresh oranges left in the grid (there were no adjacent rotten oranges to make them rotten)\\n        return minutes_passed if fresh_cnt == 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666987,
                "title": "java-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int time = 0;\\n        int[][] visited = new int[n][m];\\n        Queue<int[]> q = new LinkedList<int[]>();\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j] == 2 && visited[i][j] == 0) {\\n                    q.add(new int[]{i,j});\\n                }\\n                  \\n            }\\n        }\\n        time = bfs(grid, visited, q);\\n        for(int i=0; i<n; i++) {\\n                    for(int j=0; j<m; j++) {\\n                        if(grid[i][j] == 1 ) {\\n                         return -1;\\n                        }\\n                       \\n                    }\\n                }\\n\\n        return Math.max(time-1, 0);\\n    }\\n\\n    public int bfs(int[][] grid, int[][] visited, Queue<int[]> q) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int count = 0;\\n        int[][] dir = {{-1,0}, {0,-1}, {1,0}, {0,1}};\\n\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            count++;\\n            while(size-- >0) {\\n            int[] temp = q.poll();\\n            visited[temp[0]][temp[1]] = 1;\\n            for(int[] k: dir) {\\n                int x = temp[0]+k[0];\\n                int y = temp[1]+k[1];\\n                if(x>=0 && x<n && y>=0 && y<m && visited[x][y] == 0 && grid[x][y] == 1) {\\n                    grid[x][y] = 2;\\n                    q.add(new int[]{x,y});\\n                }\\n            }\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int time = 0;\\n        int[][] visited = new int[n][m];\\n        Queue<int[]> q = new LinkedList<int[]>();\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j] == 2 && visited[i][j] == 0) {\\n                    q.add(new int[]{i,j});\\n                }\\n                  \\n            }\\n        }\\n        time = bfs(grid, visited, q);\\n        for(int i=0; i<n; i++) {\\n                    for(int j=0; j<m; j++) {\\n                        if(grid[i][j] == 1 ) {\\n                         return -1;\\n                        }\\n                       \\n                    }\\n                }\\n\\n        return Math.max(time-1, 0);\\n    }\\n\\n    public int bfs(int[][] grid, int[][] visited, Queue<int[]> q) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int count = 0;\\n        int[][] dir = {{-1,0}, {0,-1}, {1,0}, {0,1}};\\n\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            count++;\\n            while(size-- >0) {\\n            int[] temp = q.poll();\\n            visited[temp[0]][temp[1]] = 1;\\n            for(int[] k: dir) {\\n                int x = temp[0]+k[0];\\n                int y = temp[1]+k[1];\\n                if(x>=0 && x<n && y>=0 && y<m && visited[x][y] == 0 && grid[x][y] == 1) {\\n                    grid[x][y] = 2;\\n                    q.add(new int[]{x,y});\\n                }\\n            }\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423956,
                "title": "simple-c-explanation-using-bfs-traversal-striver-explanation",
                "content": "int orangesRotting(vector<vector<int>> &grid)\\n{\\n    queue<pair<pair<int, int>, int>> q;\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    int cnt=0;\\n    for (int i = 0; i < n; i++)\\n    {\\n        for (int j = 0; j < m; j++)\\n        {\\n            if (grid[i][j] == 2)\\n                q.push({{i, j}, 0});\\n            else if (grid[i][j] == 1)\\n                cnt++;\\n        }\\n    }\\n    if(cnt==0)\\n    return 0;\\n        \\n    int time = 0;\\n    while (q.size())\\n    {\\n        pair<int, int> idx = q.front().first;\\n        int x = idx.first;\\n        int y = idx.second;\\n            time = q.front().second;\\n        q.pop();\\n        if (x - 1 >= 0 && grid[x - 1][y] == 1)\\n        { // left\\n            grid[x - 1][y] = 2;\\n            q.push({{x - 1, y}, time + 1});\\n            cnt--;\\n        }\\n        if (x + 1 < n && grid[x + 1][y] == 1)\\n        { // right\\n            grid[x + 1][y] = 2;\\n            q.push({{x + 1, y}, time + 1});\\n            cnt--;\\n        }\\n        if (y - 1 >= 0 && grid[x][y-1] == 1)\\n        { // bottom\\n            grid[x][y-1] = 2;\\n            q.push({{x, y-1}, time + 1});cnt--;\\n        }\\n        if (y+ 1 < m && grid[x][y+1] == 1)\\n        { // top\\n            grid[x][y+1] = 2;\\n            q.push({{x, y+1}, time + 1});cnt--;\\n        }\\n    }\\n    return (cnt==0)?time:-1;\\n}",
                "solutionTags": [
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "int orangesRotting(vector<vector<int>> &grid)\\n{\\n    queue<pair<pair<int, int>, int>> q;\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    int cnt=0;\\n    for (int i = 0; i < n; i++)\\n    {\\n        for (int j = 0; j < m; j++)\\n        {\\n            if (grid[i][j] == 2)\\n                q.push({{i, j}, 0});\\n            else if (grid[i][j] == 1)\\n                cnt++;\\n        }\\n    }\\n    if(cnt==0)\\n    return 0;\\n        \\n    int time = 0;\\n    while (q.size())\\n    {\\n        pair<int, int> idx = q.front().first;\\n        int x = idx.first;\\n        int y = idx.second;\\n            time = q.front().second;\\n        q.pop();\\n        if (x - 1 >= 0 && grid[x - 1][y] == 1)\\n        { // left\\n            grid[x - 1][y] = 2;\\n            q.push({{x - 1, y}, time + 1});\\n            cnt--;\\n        }\\n        if (x + 1 < n && grid[x + 1][y] == 1)\\n        { // right\\n            grid[x + 1][y] = 2;\\n            q.push({{x + 1, y}, time + 1});\\n            cnt--;\\n        }\\n        if (y - 1 >= 0 && grid[x][y-1] == 1)\\n        { // bottom\\n            grid[x][y-1] = 2;\\n            q.push({{x, y-1}, time + 1});cnt--;\\n        }\\n        if (y+ 1 < m && grid[x][y+1] == 1)\\n        { // top\\n            grid[x][y+1] = 2;\\n            q.push({{x, y+1}, time + 1});cnt--;\\n        }\\n    }\\n    return (cnt==0)?time:-1;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2321090,
                "title": "line-to-line-explaination-bfs-easy-java-code",
                "content": "class Solution {\\n\\n    public int orangesRotting(int[][] grid) {\\n        \\n        if(grid.length == 0)\\n            return 0;\\n        \\n        int row = grid.length;\\n        int col = grid[0].length;\\n        \\n        Queue<int[]> q = new LinkedList<>();        //to store the rotten oranges of the grid\\n        int TotalOranges=0;                         //to get count of total oranges (rotten + Fresh)\\n        \\n        for(int i=0;i<row;i++){                     //to traverse row\\n            for(int j=0;j<col;j++){                 //to traverse each column\\n                \\n                if(grid[i][j] == 2){                //if that orange is rotten, store it into the queue\\n                    q.add(new int[]{i,j});\\n                }\\n                \\n                if(grid[i][j]!=0)                   //if that cell is not empty, then definitly have rotten or fresh orange\\n                    TotalOranges++;                 //count increase by 1\\n                \\n            }\\n        }\\n        \\n        if(TotalOranges==0) return 0;               //if there is no orange in grid, then there is no need to count how much time require!\\n        \\n        //bfs\\n        int min=0, rottedOranges=0;                 \\n        int[] xAxis = {0,0,-1,1};                   // xAxis and yAxis array are use to move in adjacent cells that are one step up, down, left and right\\n        int[] yAxis = {-1,1,0,0};                   // when the xAxis value is 0 and yAxis value is -1 then it means we move one step towards left\\n        \\n        while(!q.isEmpty()){                        //while queue is not empty\\n            int rottenSize = q.size();              //size of queue gives us the idea of rotten oranges(fresh conv. into rotten oranges, add into the queue)\\n            rottedOranges += q.size();              //so how much amount of rotten oranges are present (or added into) the queue, keep count of it.\\n            \\n            while(rottenSize>0){                    //in each pass we pop all the rotten oranges currently present in the queue & make adjacent fresh into\\n                int[] rotten = q.poll();            //rotten and add into the queue in this while loop\\n                for(int i=0; i<4; i++){             //According to problem statement, we to move one step in each directiom(up,down,left,right)\\n                    int x = rotten[0] + xAxis[i];   //on whatever cell we are just add the xAxis & yAxis accordinly in row & col to move in all 4 direction\\n                    int y = rotten[1] + yAxis[i];\\n\\n                    if(x<0 || x>=row || y<0 || y>=col || grid[x][y] == 0 || grid[x][y] == 2)        //Our boundary Condition, if we come out from the grid\\n                        continue;\\n\\n                    grid[x][y] = 2;             //mark that orange as rotten\\n                    q.add(new int[]{x,y});      //add into the queue\\n\\n                }\\n                rottenSize--;                   //decrease the size of rottenOranges in the queue, because one is popped out from the queue\\n            }\\n            \\n            min++;                              //after each pass increase a minute\\n        }\\n        \\n        return (rottedOranges==TotalOranges )? min-1:-1;            //if rottedOranges are equal to TotalOranges then it means no fresh orange left, so return min else -1\\n        \\n    }\\n}\\n\\n***Note: Kindly Upvote this article, if you found it helpful. Thanks For Reading!!***",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\n    public int orangesRotting(int[][] grid) {\\n        \\n        if(grid.length == 0)\\n            return 0;\\n        \\n        int row = grid.length;\\n        int col = grid[0].length;\\n        \\n        Queue<int[]> q = new LinkedList<>();        //to store the rotten oranges of the grid\\n        int TotalOranges=0;                         //to get count of total oranges (rotten + Fresh)\\n        \\n        for(int i=0;i<row;i++){                     //to traverse row\\n            for(int j=0;j<col;j++){                 //to traverse each column\\n                \\n                if(grid[i][j] == 2){                //if that orange is rotten, store it into the queue\\n                    q.add(new int[]{i,j}",
                "codeTag": "Java"
            },
            {
                "id": 2082234,
                "title": "simple-bfs-solution-in-cpp-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n\\t\\tint x[] = {-1, 1, 0, 0};\\n        int y[] = {0, 0, -1, 1};\\n        queue<pair<int, int>>q;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++){\\n                if(grid[i][j] == 2)q.push({i, j});         //pushing all the (possibilities where we need to start)\\n            }\\n        }\\n        int ans = 0;\\n        while(!q.empty()){\\n            int n = q.size();\\n            int flag = 0;\\n            while(n--){                  //all rotted oranges will spoil near by oranges which is fresh in unit time \\n                auto curr = q.front();\\n                q.pop();\\n                for(int i = 0; i < 4; i++){\\n                    int new_x = curr.first + x[i];\\n                    int new_y = curr.second + y[i];\\n                    if(new_x >= 0 and new_x < grid.size() and new_y >= 0 and new_y < grid[0].size() and grid[new_x][new_y] == 1){\\n                        q.push({new_x, new_y});\\n                        grid[new_x][new_y] = 2;\\n                        flag = 1;           //for checking that we rotted or not\\n                    }\\n                }\\n            }\\n            if(flag == 1)ans++;         //if we go from 2 to 1, then it is unit time (how many doesn\\'t matter) thats y we keep flag above\\n        }\\n        for(int i = 0; i < grid.size(); i++){         //checking for unrotten oranges which can\\'t be reached\\n            for(int j = 0; j < grid[0].size(); j++){\\n                if(grid[i][j] == 1)return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n***For Advanced DSA Solutions refer to README file***\\nhttps://github.com/teja963/Advanced-DSA\\n***Find Helpful Upvote it***\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n\\t\\tint x[] = {-1, 1, 0, 0};\\n        int y[] = {0, 0, -1, 1};\\n        queue<pair<int, int>>q;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++){\\n                if(grid[i][j] == 2)q.push({i, j});         //pushing all the (possibilities where we need to start)\\n            }\\n        }\\n        int ans = 0;\\n        while(!q.empty()){\\n            int n = q.size();\\n            int flag = 0;\\n            while(n--){                  //all rotted oranges will spoil near by oranges which is fresh in unit time \\n                auto curr = q.front();\\n                q.pop();\\n                for(int i = 0; i < 4; i++){\\n                    int new_x = curr.first + x[i];\\n                    int new_y = curr.second + y[i];\\n                    if(new_x >= 0 and new_x < grid.size() and new_y >= 0 and new_y < grid[0].size() and grid[new_x][new_y] == 1){\\n                        q.push({new_x, new_y});\\n                        grid[new_x][new_y] = 2;\\n                        flag = 1;           //for checking that we rotted or not\\n                    }\\n                }\\n            }\\n            if(flag == 1)ans++;         //if we go from 2 to 1, then it is unit time (how many doesn\\'t matter) thats y we keep flag above\\n        }\\n        for(int i = 0; i < grid.size(); i++){         //checking for unrotten oranges which can\\'t be reached\\n            for(int j = 0; j < grid[0].size(); j++){\\n                if(grid[i][j] == 1)return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786056,
                "title": "python-3-70ms-bfs-solution",
                "content": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        visit, curr = set(), deque()\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    visit.add((i, j))\\n                elif grid[i][j] == 2:\\n                    curr.append((i, j))\\n        result = 0\\n        while visit and curr:\\n            for _ in range(len(curr)):\\n                i, j = curr.popleft()\\n                for coord in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\\n                    if coord in visit:\\n                        visit.remove(coord)\\n                        curr.append(coord)\\n            result += 1\\n        return -1 if visit else result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Graph",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        visit, curr = set(), deque()\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    visit.add((i, j))\\n                elif grid[i][j] == 2:\\n                    curr.append((i, j))\\n        result = 0\\n        while visit and curr:\\n            for _ in range(len(curr)):\\n                i, j = curr.popleft()\\n                for coord in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\\n                    if coord in visit:\\n                        visit.remove(coord)\\n                        curr.append(coord)\\n            result += 1\\n        return -1 if visit else result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1780023,
                "title": "easy-c-solution-using-bfs-explained-with-comments-t-c-o-m-n",
                "content": "**Please upvote if it helped you : ) !!!\\n*Thanks :)***\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& mat) {\\n        int m=mat[0].size();\\n        int n=mat.size();\\n        int tot=0;\\n        \\n       queue<pair<int,int>>q;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(mat[i][j]!=0){tot++;}    // maintaining count of number of total oranges\\n                if(mat[i][j]==2)\\n                {\\n                    q.push({i,j}); // pushing rotten oranges inside queue for out approach\\n                }\\n            }\\n        }\\n        int cn=0;\\n        \\n        int dir[4][2] = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } }; // directions \\n        int days=0;\\n        \\n        while(q.empty()==false)\\n        {\\n            int si=q.size(); // looping till its size\\n            \\n            cn+=si; // updating all rotten oranges\\n            while(si--)\\n            {\\n                auto it=q.front();\\n                q.pop();\\n                int r=it.first;\\n                int c=it.second;\\n                // getting row and col of rotten oranges \\n                \\n                for(int i=0;i<4;i++)  // iterating in all 4 directions \\n                {\\n                    int fir=r+dir[i][0];\\n                    int sec=c+dir[i][1];\\n                        \\n                    // Boundary condition checks\\n                    \\n                    if(fir>=0 and fir<n and sec<m and sec>=0 and mat[fir][sec]==1)\\n                    {\\n                        mat[fir][sec]=2;\\n                        q.push({fir,sec});\\n                    }\\n                }\\n            }\\n            if(!q.empty()){\\n                \\n                 days++;            // if size of queue is greater than 0 it means that \\n                                    // it still has some oranges to be processed\\n            } \\n        }     \\n     \\n        if(cn!=tot) // if not then it means we have still some oranges left\\n        {\\n            return -1;\\n        }\\n            \\n        return days;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& mat) {\\n        int m=mat[0].size();\\n        int n=mat.size();\\n        int tot=0;\\n        \\n       queue<pair<int,int>>q;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(mat[i][j]!=0){tot++;}    // maintaining count of number of total oranges\\n                if(mat[i][j]==2)\\n                {\\n                    q.push({i,j}); // pushing rotten oranges inside queue for out approach\\n                }\\n            }\\n        }\\n        int cn=0;\\n        \\n        int dir[4][2] = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } }; // directions \\n        int days=0;\\n        \\n        while(q.empty()==false)\\n        {\\n            int si=q.size(); // looping till its size\\n            \\n            cn+=si; // updating all rotten oranges\\n            while(si--)\\n            {\\n                auto it=q.front();\\n                q.pop();\\n                int r=it.first;\\n                int c=it.second;\\n                // getting row and col of rotten oranges \\n                \\n                for(int i=0;i<4;i++)  // iterating in all 4 directions \\n                {\\n                    int fir=r+dir[i][0];\\n                    int sec=c+dir[i][1];\\n                        \\n                    // Boundary condition checks\\n                    \\n                    if(fir>=0 and fir<n and sec<m and sec>=0 and mat[fir][sec]==1)\\n                    {\\n                        mat[fir][sec]=2;\\n                        q.push({fir,sec});\\n                    }\\n                }\\n            }\\n            if(!q.empty()){\\n                \\n                 days++;            // if size of queue is greater than 0 it means that \\n                                    // it still has some oranges to be processed\\n            } \\n        }     \\n     \\n        if(cn!=tot) // if not then it means we have still some oranges left\\n        {\\n            return -1;\\n        }\\n            \\n        return days;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546770,
                "title": "3-different-ways-recursion-iterative-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\n**1. Iterative**\\n\\n```\\npublic class Solution {\\n    public int OrangesRotting(int[][] grid) {  \\n        var EMPTY = 0;\\n        var FRESH = 1;\\n        var ROTTEN = 2;\\n        \\n        var elapsed = 0;\\n        var freshCount = 0;\\n        var queue = new Queue<KeyValuePair<int, int>>();\\n        \\n        // Get fresh cell count and rotten cell coordinates\\n        for (int row = 0; row < grid.Length; ++row) {\\n            for (int col = 0; col < grid[row].Length; ++col) {\\n                if (grid[row][col] == FRESH) {\\n                    ++freshCount;\\n                } else if (grid[row][col] == ROTTEN) {\\n                    queue.Enqueue(new KeyValuePair<int, int>(row, col));\\n                }                \\n            }          \\n        }\\n        \\n        // Search directions\\n        var directions = new List<KeyValuePair<int, int>>() {\\n            // Right\\n            new KeyValuePair<int, int>(0, 1),\\n            // Left\\n            new KeyValuePair<int, int>(0, -1),\\n            // Top\\n            new KeyValuePair<int, int>(-1, 0),\\n            // Bottom\\n            new KeyValuePair<int, int>(1, 0),\\n        };\\n        \\n        // Look for fresh cells to turn rotten\\t\\t\\n        while (queue.Count > 0) {            \\n            for (int itemCount = queue.Count; itemCount > 0; --itemCount) {\\n                var current = queue.Peek();\\n                queue.Dequeue();\\n                \\n                // Get the coordinates of the rotten cell\\n                var row = current.Key;\\n                var col = current.Value;\\n                \\n                // Search right, left, top, bottom to see if a fresh cell can become rotton\\n                foreach (var direction in directions) {\\n                    var newRow = row + direction.Key;\\n                    var newCol = col + direction.Value;\\n                    \\n                    // If the cell is fresh in this direction, make it rotten\\n                    if (IsValidCell(grid, newRow, newCol) && grid[newRow][newCol] == FRESH) {\\n                        grid[newRow][newCol] = ROTTEN;\\n                        queue.Enqueue(new KeyValuePair<int, int>(newRow, newCol));\\n                        --freshCount;                        \\n                    }\\n                }       \\n            }\\n            \\n            // Increment elapsed time\\n            if (queue.Count > 0) {\\n                ++elapsed;\\n            }\\n        }\\n        \\n        return freshCount > 0 ? -1 : elapsed;\\n    }\\n    \\n    private bool IsValidCell(int[][] grid, int row, int col) {\\n        return row >= 0 && row < grid.Length && col >= 0 && col < grid[row].Length;\\n    }\\n}\\n```\\n\\nThe following are 2 different solutions using recursion.\\n\\nThe general idea for both solutions are the same. For any given fresh orange, we try to compute the shortest path to a rotten orange (as this would be the one responsible for rotting the orange in question in the minimum time steps, before any other rotten orange). \\n\\nWe compute the max of all these shortest paths to rot all the fresh oranges.\\n\\n**2. Keeping Track Rows Visited**\\n\\nIn this solution, we compute the max of all these shortest paths from a fresh to a rotten cell\\n\\n```\\npublic class Solution {\\n    public int OrangesRotting(int[][] grid) {    \\n        var result = 0;\\n        \\n        // 2D array to keep track of paths visited\\n        var visited = new bool[grid.Length][];\\n        for (int row = 0; row < grid.Length; ++row) {\\n            visited[row] = new bool[grid[row].Length];\\n        } \\n        \\n        // The Answer is the max of all shortest distances to a rotten cell\\n        for (int row = 0; row < grid.Length; ++row) {\\n            for (int col = 0; col < grid[row].Length; ++col) {\\n                // Cell is fresh, get distance to rotten\\n                if (grid[row][col] == 1) {\\n                    result = Math.Max(result, ShortestPath(grid, row, col, 0, visited));\\n                }                \\n            }          \\n        }        \\n        return result == int.MaxValue ? -1 : result;\\n    }\\n    \\n    // Compute shortest distance to a rotten cell\\n    private int ShortestPath(int[][] grid, int row, int col, int depth, bool[][] visited) {\\n        // Make sure parameters are in bounds\\n        if (row < 0 || row >= grid.Length || col < 0 || col >= grid[row].Length) {\\n            return int.MaxValue;\\n        }    \\n                    \\n        // Cell is rotten\\n        if (grid[row][col] == 2) {\\n            return depth;\\n        }\\n        \\n        // Path been visited\\n        if (visited[row][col]) {\\n            return int.MaxValue;\\n        }       \\n        \\n        var distance = int.MaxValue;\\n        \\n        // Set path as visited\\n        visited[row][col] = true;\\n        \\n        // Cell is fresh, keep searching\\n        if (grid[row][col] == 1) {\\n            // Search right\\n            distance = Math.Min(distance, ShortestPath(grid, row, col + 1, depth + 1, visited));\\n\\n            // Search left\\n            distance = Math.Min(distance, ShortestPath(grid, row, col - 1, depth + 1, visited)); \\n\\n            // Search top\\n            distance = Math.Min(distance, ShortestPath(grid, row + 1, col, depth + 1, visited));\\n\\n            // Search bottom\\n            distance = Math.Min(distance, ShortestPath(grid, row - 1, col, depth + 1, visited)); \\n        }\\n        \\n        // Set path as un visited\\n        visited[row][col] = false;\\n        \\n        return distance;\\n    }\\n}\\n```\\n\\n**3. Timestamp Difference**\\n\\nIn this solution, we set a timestamp when a fresh cell becomes rotten, and use that to compute the result\\n\\n```\\npublic class Solution {\\n    public int OrangesRotting(int[][] grid) {    \\n        // Set a value other than 0,1,2 as the initial timestamp offset\\n        // when a cell becomes rotten\\n        var offset = 1987;\\n        \\n        for (int row = 0; row < grid.Length; ++row) {\\n            for (int col = 0; col < grid[row].Length; ++col) {\\n                // Cell is rotten, try to infect fresh cells\\n                if (grid[row][col] == 2) {\\n                    grid[row][col] = offset;\\n                    Search(grid, row, col, offset);\\n                }                \\n            }          \\n        }\\n        \\n        var result = 0;        \\n        for (int row = 0; row < grid.Length; ++row) {\\n            for (int col = 0; col < grid[row].Length; ++col) {\\n                // Cell was unable to be turned rotten\\n                if (grid[row][col] == 1) {\\n                    return -1;\\n                }\\n                // Get the timestamp when this cell became rotten, minus offset\\n                result = Math.Max(result, grid[row][col] - offset);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private void Search(int[][] grid, int row, int col, int timestamp) {\\n        // Make sure parameters are in bounds\\n        if (row < 0 || row >= grid.Length || col < 0 || col >= grid[row].Length) {\\n            return;\\n        }       \\n        \\n        // Cell is empty\\n        if (grid[row][col] == 0) {\\n            return;\\n        }     \\n        \\n        // Cell is already rotten\\n        if (grid[row][col] == 2) {\\n            return;\\n        }         \\n        \\n        // Cell was made rotten by another rotten cell\\n        if (grid[row][col] > 2 && grid[row][col] < timestamp) {         \\n            return;\\n        }\\n        \\n        // Set the timestamp when this cell becomes rotten\\n        grid[row][col] = timestamp;\\n                \\n        // Search right\\n        Search(grid, row, col + 1, timestamp + 1);\\n        \\n        // Search left\\n        Search(grid, row, col - 1, timestamp + 1); \\n        \\n        // Search top\\n        Search(grid, row + 1, col, timestamp + 1);\\n        \\n        // Search bottom\\n        Search(grid, row - 1, col, timestamp + 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int OrangesRotting(int[][] grid) {  \\n        var EMPTY = 0;\\n        var FRESH = 1;\\n        var ROTTEN = 2;\\n        \\n        var elapsed = 0;\\n        var freshCount = 0;\\n        var queue = new Queue<KeyValuePair<int, int>>();\\n        \\n        // Get fresh cell count and rotten cell coordinates\\n        for (int row = 0; row < grid.Length; ++row) {\\n            for (int col = 0; col < grid[row].Length; ++col) {\\n                if (grid[row][col] == FRESH) {\\n                    ++freshCount;\\n                } else if (grid[row][col] == ROTTEN) {\\n                    queue.Enqueue(new KeyValuePair<int, int>(row, col));\\n                }                \\n            }          \\n        }\\n        \\n        // Search directions\\n        var directions = new List<KeyValuePair<int, int>>() {\\n            // Right\\n            new KeyValuePair<int, int>(0, 1),\\n            // Left\\n            new KeyValuePair<int, int>(0, -1),\\n            // Top\\n            new KeyValuePair<int, int>(-1, 0),\\n            // Bottom\\n            new KeyValuePair<int, int>(1, 0),\\n        };\\n        \\n        // Look for fresh cells to turn rotten\\t\\t\\n        while (queue.Count > 0) {            \\n            for (int itemCount = queue.Count; itemCount > 0; --itemCount) {\\n                var current = queue.Peek();\\n                queue.Dequeue();\\n                \\n                // Get the coordinates of the rotten cell\\n                var row = current.Key;\\n                var col = current.Value;\\n                \\n                // Search right, left, top, bottom to see if a fresh cell can become rotton\\n                foreach (var direction in directions) {\\n                    var newRow = row + direction.Key;\\n                    var newCol = col + direction.Value;\\n                    \\n                    // If the cell is fresh in this direction, make it rotten\\n                    if (IsValidCell(grid, newRow, newCol) && grid[newRow][newCol] == FRESH) {\\n                        grid[newRow][newCol] = ROTTEN;\\n                        queue.Enqueue(new KeyValuePair<int, int>(newRow, newCol));\\n                        --freshCount;                        \\n                    }\\n                }       \\n            }\\n            \\n            // Increment elapsed time\\n            if (queue.Count > 0) {\\n                ++elapsed;\\n            }\\n        }\\n        \\n        return freshCount > 0 ? -1 : elapsed;\\n    }\\n    \\n    private bool IsValidCell(int[][] grid, int row, int col) {\\n        return row >= 0 && row < grid.Length && col >= 0 && col < grid[row].Length;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int OrangesRotting(int[][] grid) {    \\n        var result = 0;\\n        \\n        // 2D array to keep track of paths visited\\n        var visited = new bool[grid.Length][];\\n        for (int row = 0; row < grid.Length; ++row) {\\n            visited[row] = new bool[grid[row].Length];\\n        } \\n        \\n        // The Answer is the max of all shortest distances to a rotten cell\\n        for (int row = 0; row < grid.Length; ++row) {\\n            for (int col = 0; col < grid[row].Length; ++col) {\\n                // Cell is fresh, get distance to rotten\\n                if (grid[row][col] == 1) {\\n                    result = Math.Max(result, ShortestPath(grid, row, col, 0, visited));\\n                }                \\n            }          \\n        }        \\n        return result == int.MaxValue ? -1 : result;\\n    }\\n    \\n    // Compute shortest distance to a rotten cell\\n    private int ShortestPath(int[][] grid, int row, int col, int depth, bool[][] visited) {\\n        // Make sure parameters are in bounds\\n        if (row < 0 || row >= grid.Length || col < 0 || col >= grid[row].Length) {\\n            return int.MaxValue;\\n        }    \\n                    \\n        // Cell is rotten\\n        if (grid[row][col] == 2) {\\n            return depth;\\n        }\\n        \\n        // Path been visited\\n        if (visited[row][col]) {\\n            return int.MaxValue;\\n        }       \\n        \\n        var distance = int.MaxValue;\\n        \\n        // Set path as visited\\n        visited[row][col] = true;\\n        \\n        // Cell is fresh, keep searching\\n        if (grid[row][col] == 1) {\\n            // Search right\\n            distance = Math.Min(distance, ShortestPath(grid, row, col + 1, depth + 1, visited));\\n\\n            // Search left\\n            distance = Math.Min(distance, ShortestPath(grid, row, col - 1, depth + 1, visited)); \\n\\n            // Search top\\n            distance = Math.Min(distance, ShortestPath(grid, row + 1, col, depth + 1, visited));\\n\\n            // Search bottom\\n            distance = Math.Min(distance, ShortestPath(grid, row - 1, col, depth + 1, visited)); \\n        }\\n        \\n        // Set path as un visited\\n        visited[row][col] = false;\\n        \\n        return distance;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int OrangesRotting(int[][] grid) {    \\n        // Set a value other than 0,1,2 as the initial timestamp offset\\n        // when a cell becomes rotten\\n        var offset = 1987;\\n        \\n        for (int row = 0; row < grid.Length; ++row) {\\n            for (int col = 0; col < grid[row].Length; ++col) {\\n                // Cell is rotten, try to infect fresh cells\\n                if (grid[row][col] == 2) {\\n                    grid[row][col] = offset;\\n                    Search(grid, row, col, offset);\\n                }                \\n            }          \\n        }\\n        \\n        var result = 0;        \\n        for (int row = 0; row < grid.Length; ++row) {\\n            for (int col = 0; col < grid[row].Length; ++col) {\\n                // Cell was unable to be turned rotten\\n                if (grid[row][col] == 1) {\\n                    return -1;\\n                }\\n                // Get the timestamp when this cell became rotten, minus offset\\n                result = Math.Max(result, grid[row][col] - offset);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private void Search(int[][] grid, int row, int col, int timestamp) {\\n        // Make sure parameters are in bounds\\n        if (row < 0 || row >= grid.Length || col < 0 || col >= grid[row].Length) {\\n            return;\\n        }       \\n        \\n        // Cell is empty\\n        if (grid[row][col] == 0) {\\n            return;\\n        }     \\n        \\n        // Cell is already rotten\\n        if (grid[row][col] == 2) {\\n            return;\\n        }         \\n        \\n        // Cell was made rotten by another rotten cell\\n        if (grid[row][col] > 2 && grid[row][col] < timestamp) {         \\n            return;\\n        }\\n        \\n        // Set the timestamp when this cell becomes rotten\\n        grid[row][col] = timestamp;\\n                \\n        // Search right\\n        Search(grid, row, col + 1, timestamp + 1);\\n        \\n        // Search left\\n        Search(grid, row, col - 1, timestamp + 1); \\n        \\n        // Search top\\n        Search(grid, row + 1, col, timestamp + 1);\\n        \\n        // Search bottom\\n        Search(grid, row - 1, col, timestamp + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461265,
                "title": "well-explained-easy-approach-94-faster",
                "content": "## IDEA :\\n\\uD83D\\uDC49*First form the list of all rotten cells with their cell number and time as 0.\\n\\uD83D\\uDC49 Now poping one by one from left of queue of rotten list.\\n\\uD83D\\uDC49 Change this cell to empty and call **Convert** Function to change all the 4-Directional fresh cells(if exists) to empty and also add them in rotten cells. With time extended by 1.\\n\\uD83D\\uDC49 At last you will be with the last minute.\\n\\uD83D\\uDC49 Check if any cell is with fresh orange then return -1 else return the last minute.*\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        m,n,l = len(grid),len(grid[0]),0\\n        rot = []\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==2:\\n                    rot.append([i,j,l])\\n                \\n        def convert(i,j,l):\\n            nonlocal rot\\n            if i<0 or i>=m or j<0 or j>=n or grid[i][j]==0:\\n                return\\n            if grid[i][j]==1:\\n                rot.append([i,j,l+1])\\n                grid[i][j]=0\\n        \\n        while rot:\\n            a,b,l = rot.pop(0)\\n            grid[a][b] = 0\\n            convert(a+1,b,l)\\n            convert(a-1,b,l)\\n            convert(a,b+1,l)\\n            convert(a,b-1,l)    \\n\\n        # Checking any 1 exist in grid\\n\\t\\tfor r in grid:\\n            if 1 in r:\\n                return -1\\n            \\n        return l\\n\\nFeel free to ask if you have any doubts \\uD83E\\uDD17\\nThanks and Upvote if you got any help !! \\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "## IDEA :\\n\\uD83D\\uDC49*First form the list of all rotten cells with their cell number and time as 0.\\n\\uD83D\\uDC49 Now poping one by one from left of queue of rotten list.\\n\\uD83D\\uDC49 Change this cell to empty and call **Convert** Function to change all the 4-Directional fresh cells(if exists) to empty and also add them in rotten cells. With time extended by 1.\\n\\uD83D\\uDC49 At last you will be with the last minute.\\n\\uD83D\\uDC49 Check if any cell is with fresh orange then return -1 else return the last minute.*\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        m,n,l = len(grid),len(grid[0]),0\\n        rot = []\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==2:\\n                    rot.append([i,j,l])\\n                \\n        def convert(i,j,l):\\n            nonlocal rot\\n            if i<0 or i>=m or j<0 or j>=n or grid[i][j]==0:\\n                return\\n            if grid[i][j]==1:\\n                rot.append([i,j,l+1])\\n                grid[i][j]=0\\n        \\n        while rot:\\n            a,b,l = rot.pop(0)\\n            grid[a][b] = 0\\n            convert(a+1,b,l)\\n            convert(a-1,b,l)\\n            convert(a,b+1,l)\\n            convert(a,b-1,l)    \\n\\n        # Checking any 1 exist in grid\\n\\t\\tfor r in grid:\\n            if 1 in r:\\n                return -1\\n            \\n        return l\\n\\nFeel free to ask if you have any doubts \\uD83E\\uDD17\\nThanks and Upvote if you got any help !! \\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1414614,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSafe(int i, int j, int n, int m){\\n        if(i<0 || i>=n || j<0 || j>=m) return 0;\\n        return 1;\\n    }\\n    bool allRotten(vector<vector<int>> &a){\\n        int i,j,n=a.size(),m=a[0].size();\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                if(a[i][j]==1) return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n    int orangesRotting(vector<vector<int>>& a) {\\n        int i,j,n=a.size(),m=a[0].size(),timeFrame,x,y;\\n        queue<vector<int>> q;\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                if(a[i][j]==2){\\n                    q.push({0,i,j});\\n                }\\n            }\\n        }\\n        while(q.size()){\\n            vector<int> v=q.front(); q.pop();\\n            timeFrame=v[0], x=v[1], y=v[2];\\n            if(isSafe(x-1,y,n,m) && a[x-1][y]==1){\\n                a[x-1][y]=2;\\n                q.push({timeFrame+1, x-1, y});\\n            }\\n            if(isSafe(x+1,y,n,m) && a[x+1][y]==1){\\n                a[x+1][y]=2;\\n                q.push({timeFrame+1, x+1, y});\\n            }\\n            if(isSafe(x,y-1,n,m) && a[x][y-1]==1){\\n                a[x][y-1]=2;\\n                q.push({timeFrame+1, x, y-1});\\n            }\\n            if(isSafe(x,y+1,n,m) && a[x][y+1]==1){\\n                a[x][y+1]=2;\\n                q.push({timeFrame+1, x, y+1});\\n            }\\n        }\\n        if(allRotten(a)) return timeFrame;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSafe(int i, int j, int n, int m){\\n        if(i<0 || i>=n || j<0 || j>=m) return 0;\\n        return 1;\\n    }\\n    bool allRotten(vector<vector<int>> &a){\\n        int i,j,n=a.size(),m=a[0].size();\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                if(a[i][j]==1) return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n    int orangesRotting(vector<vector<int>>& a) {\\n        int i,j,n=a.size(),m=a[0].size(),timeFrame,x,y;\\n        queue<vector<int>> q;\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                if(a[i][j]==2){\\n                    q.push({0,i,j});\\n                }\\n            }\\n        }\\n        while(q.size()){\\n            vector<int> v=q.front(); q.pop();\\n            timeFrame=v[0], x=v[1], y=v[2];\\n            if(isSafe(x-1,y,n,m) && a[x-1][y]==1){\\n                a[x-1][y]=2;\\n                q.push({timeFrame+1, x-1, y});\\n            }\\n            if(isSafe(x+1,y,n,m) && a[x+1][y]==1){\\n                a[x+1][y]=2;\\n                q.push({timeFrame+1, x+1, y});\\n            }\\n            if(isSafe(x,y-1,n,m) && a[x][y-1]==1){\\n                a[x][y-1]=2;\\n                q.push({timeFrame+1, x, y-1});\\n            }\\n            if(isSafe(x,y+1,n,m) && a[x][y+1]==1){\\n                a[x][y+1]=2;\\n                q.push({timeFrame+1, x, y+1});\\n            }\\n        }\\n        if(allRotten(a)) return timeFrame;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411913,
                "title": "this-is-the-simplest-solution",
                "content": "This is a pretty common problem and gfg gave a very complicated solution! \\n```\\nclass Solution {\\npublic:\\n    \\n    int dx[4] = {0,0,-1,1};\\n    int dy[4] = {1,-1,0,0}; \\n    int m , n;\\n    \\n    bool valid(int x , int y, vector<vector<int>>& grid){\\n        return (x>=0 && y>= 0 && x<m && y<n && grid[x][y] == 1) ; \\n    }\\n    \\n    bool check(vector<vector<int>>& grid){\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 1)\\n                    return 0;\\n            }\\n        }\\n        return 1; \\n    }\\n    \\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int ans = 0 ; m =grid.size() , n = grid[0].size();\\n        queue<pair<int,int>> q; \\n        vector<vector<bool>> visited(m,vector<bool>(n,0)); \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==2){\\n                    q.push({i,j}); \\n                    visited[i][j] = 1; \\n                }\\n            }\\n        }        \\n        if((q.empty() && check(grid)) || q.size() == m*n)\\n            return 0;\\n        \\n        while(!q.empty()){\\n            int size = q.size(); \\n            for(int i=0;i<size;i++){\\n                auto curr = q.front();\\n                q.pop(); \\n                for(int j=0;j<4;j++){\\n                    int x = curr.first + dx[j] , y = curr.second + dy[j]; \\n                    if(valid(x,y,grid) && !visited[x][y]) {\\n                        grid[x][y] = 2; \\n                        visited[x][y] = 1; \\n                        q.push({x,y});\\n                    }\\n                }\\n            }\\n            ans++; \\n        }\\n        \\n        return check(grid) ?  ans-1 : -1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dx[4] = {0,0,-1,1};\\n    int dy[4] = {1,-1,0,0}; \\n    int m , n;\\n    \\n    bool valid(int x , int y, vector<vector<int>>& grid){\\n        return (x>=0 && y>= 0 && x<m && y<n && grid[x][y] == 1) ; \\n    }\\n    \\n    bool check(vector<vector<int>>& grid){\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 1)\\n                    return 0;\\n            }\\n        }\\n        return 1; \\n    }\\n    \\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int ans = 0 ; m =grid.size() , n = grid[0].size();\\n        queue<pair<int,int>> q; \\n        vector<vector<bool>> visited(m,vector<bool>(n,0)); \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==2){\\n                    q.push({i,j}); \\n                    visited[i][j] = 1; \\n                }\\n            }\\n        }        \\n        if((q.empty() && check(grid)) || q.size() == m*n)\\n            return 0;\\n        \\n        while(!q.empty()){\\n            int size = q.size(); \\n            for(int i=0;i<size;i++){\\n                auto curr = q.front();\\n                q.pop(); \\n                for(int j=0;j<4;j++){\\n                    int x = curr.first + dx[j] , y = curr.second + dy[j]; \\n                    if(valid(x,y,grid) && !visited[x][y]) {\\n                        grid[x][y] = 2; \\n                        visited[x][y] = 1; \\n                        q.push({x,y});\\n                    }\\n                }\\n            }\\n            ans++; \\n        }\\n        \\n        return check(grid) ?  ans-1 : -1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314753,
                "title": "easy-java-solution-t-c-o-n-m-s-c-o-n",
                "content": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        \\n        Queue<Pair> q = new LinkedList<Pair>();\\n\\t\\t\\n        int r = grid.length;\\n        int c = grid[0].length;\\n\\t\\tint fresh = 0, rotten = 0;\\n\\t\\tfor(int i=0;i<r;i++) {\\n\\t\\t\\t\\n\\t\\t\\tfor(int j=0;j<c;j++) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(grid[i][j]==2) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tq.add(new Pair(i,j));\\n\\t\\t\\t\\t\\trotten++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(grid[i][j]==1) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfresh++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(rotten==0 && fresh>0) {\\n\\t\\t\\t\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n        \\n\\t\\t\\n\\t\\tint time = 0;\\n\\t\\t\\n\\t\\twhile(!q.isEmpty() && fresh>0) {\\n\\t\\t\\t\\n\\t\\t\\ttime++;\\n\\t\\t\\tint size = q.size();\\n\\t\\t\\t\\n\\t\\t\\twhile(size-- >0 && fresh>0) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tPair g = q.peek();\\n\\t\\t\\t\\tq.poll();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tint x = g.first;\\n\\t\\t\\t\\tint y = g.second;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(isSafe(x-1,y,r,c) && grid[x-1][y]==1) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfresh--;\\n\\t\\t\\t\\t\\tq.add(new Pair(x-1,y));\\n\\t\\t\\t\\t\\tgrid[x-1][y] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(isSafe(x,y-1,r,c) && grid[x][y-1]==1) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfresh--;\\n\\t\\t\\t\\t\\tq.add(new Pair(x,y-1));\\n\\t\\t\\t\\t\\tgrid[x][y-1] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(isSafe(x+1,y,r,c) && grid[x+1][y]==1) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfresh--;\\n\\t\\t\\t\\t\\tq.add(new Pair(x+1,y));\\n\\t\\t\\t\\t\\tgrid[x+1][y] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(isSafe(x,y+1,r,c) && grid[x][y+1]==1) {\\n\\t\\n\\t\\t\\t\\t\\tfresh--;\\n\\t\\t\\t\\t\\tq.add(new Pair(x,y+1));\\n\\t\\t\\t\\t\\tgrid[x][y+1] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\tif(fresh==0) return time;\\n\\t\\treturn -1;\\n    }\\n    boolean isSafe(int x, int y, int r, int c) {\\n\\t\\t\\n\\t\\tif(x>=0 && y>=0 && x<r && y<c) return true;\\n\\t\\treturn false;\\n\\t}\\n}\\n\\nclass Pair{\\n\\t\\n\\tint first;\\n\\tint second;\\n\\t\\n\\tpublic Pair(int first, int second) {\\n\\t\\t\\n\\t\\tthis.first = first;\\n\\t\\tthis.second = second;\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        \\n        Queue<Pair> q = new LinkedList<Pair>();\\n\\t\\t\\n        int r = grid.length;\\n        int c = grid[0].length;\\n\\t\\tint fresh = 0, rotten = 0;\\n\\t\\tfor(int i=0;i<r;i++) {\\n\\t\\t\\t\\n\\t\\t\\tfor(int j=0;j<c;j++) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(grid[i][j]==2) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tq.add(new Pair(i,j));\\n\\t\\t\\t\\t\\trotten++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(grid[i][j]==1) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfresh++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(rotten==0 && fresh>0) {\\n\\t\\t\\t\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n        \\n\\t\\t\\n\\t\\tint time = 0;\\n\\t\\t\\n\\t\\twhile(!q.isEmpty() && fresh>0) {\\n\\t\\t\\t\\n\\t\\t\\ttime++;\\n\\t\\t\\tint size = q.size();\\n\\t\\t\\t\\n\\t\\t\\twhile(size-- >0 && fresh>0) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tPair g = q.peek();\\n\\t\\t\\t\\tq.poll();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tint x = g.first;\\n\\t\\t\\t\\tint y = g.second;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(isSafe(x-1,y,r,c) && grid[x-1][y]==1) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfresh--;\\n\\t\\t\\t\\t\\tq.add(new Pair(x-1,y));\\n\\t\\t\\t\\t\\tgrid[x-1][y] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(isSafe(x,y-1,r,c) && grid[x][y-1]==1) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfresh--;\\n\\t\\t\\t\\t\\tq.add(new Pair(x,y-1));\\n\\t\\t\\t\\t\\tgrid[x][y-1] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(isSafe(x+1,y,r,c) && grid[x+1][y]==1) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfresh--;\\n\\t\\t\\t\\t\\tq.add(new Pair(x+1,y));\\n\\t\\t\\t\\t\\tgrid[x+1][y] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(isSafe(x,y+1,r,c) && grid[x][y+1]==1) {\\n\\t\\n\\t\\t\\t\\t\\tfresh--;\\n\\t\\t\\t\\t\\tq.add(new Pair(x,y+1));\\n\\t\\t\\t\\t\\tgrid[x][y+1] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\tif(fresh==0) return time;\\n\\t\\treturn -1;\\n    }\\n    boolean isSafe(int x, int y, int r, int c) {\\n\\t\\t\\n\\t\\tif(x>=0 && y>=0 && x<r && y<c) return true;\\n\\t\\treturn false;\\n\\t}\\n}\\n\\nclass Pair{\\n\\t\\n\\tint first;\\n\\tint second;\\n\\t\\n\\tpublic Pair(int first, int second) {\\n\\t\\t\\n\\t\\tthis.first = first;\\n\\t\\tthis.second = second;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1291966,
                "title": "java-do-checkout-for-detailed-explanation-3-approaches-using-bfs-o-m-n-complexity",
                "content": "**Do vote up if you like it :)**\\n\\nCreating a Pair class to keep track of the x and y coordinate,\\nx and y coordinate would be there to keep track of which grid is being processed.\\n\\nThe idea is to put all the grid with value = 2 in queue by iterating the whole grid and also count one, one needs to be counted because there can be some grid with value = 1, which would be surrounded by all 0\\'s therefore that grid with value = 1 cannot be rotten ever.\\n\\nNow, While we are processing queue (simple bfs) we reach to each of the neighbours of that polled currentPair, if that i, j is within the grid and grid value of that i and j is 1, then we keep adding the neighbours of 2 which is 1 in the queue and also we keep on subtracting freshOranges(ones) each time and also to keep track of visited grids we mark it as 2.\\nNow, observe that if all ones would have been processed then countOnes will eventually become 0, if not then returning -1, simply because freshOrange(ones)s is not 0, that means there was some grid which could not be reached from any 2\\'s of the grid.\\n```\\nclass Solution {\\n    \\n    static class Pair {\\n        int x;\\n        int y;\\n        \\n        public Pair(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    \\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        Queue<Pair> queue = new LinkedList<>();\\n        \\n        int freshOranges = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 2) queue.add(new Pair(i, j));\\n                else if(grid[i][j] == 1)  freshOranges++;\\n            }\\n        }\\n        \\n        if(freshOranges == 0) return 0;\\n        \\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        int time = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size-- > 0) {\\n                Pair currentPair = queue.poll();\\n\\n                for(int d = 0; d < dir.length; d++) {\\n                    int r = currentPair.x + dir[d][0];\\n                    int c = currentPair.y + dir[d][1];\\n                    if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] == 1) {\\n                        queue.add(new Pair(r, c));\\n                        grid[r][c] = 2;\\n                        freshOranges--;\\n                        if(freshOranges == 0) return time + 1;\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n------------------------------------------------------------\\nIn case you did not understand the level concept then here\\'s another way out.\\nKeep an additional time field in the Pair class to keep track to the dist or time from the parent 2 to 1.\\nAlso, x and y coordinate would be there to keep track of which grid is being processed.\\nRest would work the same as the above explantion.\\n```\\nclass Solution {\\n    \\n    static class Pair {\\n        int x;\\n        int y;\\n        int time;\\n        \\n        public Pair(int x, int y, int time) {\\n            this.x = x;\\n            this.y = y;\\n            this.time = time;\\n        }\\n    }\\n    \\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        Queue<Pair> queue = new LinkedList<>();\\n        \\n        int freshOranges = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 2) queue.add(new Pair(i, j, 0));\\n                else if(grid[i][j] == 1)  freshOranges++;\\n            }\\n        }\\n        \\n        if(freshOranges == 0) return 0;\\n        \\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size-- > 0) {\\n                Pair currentPair = queue.poll();\\n                int time = currentPair.time;\\n                \\n                for(int d = 0; d < dir.length; d++) {\\n                    int r = currentPair.x + dir[d][0];\\n                    int c = currentPair.y + dir[d][1];\\n                    if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] == 1) {\\n                        queue.add(new Pair(r, c, time + 1));\\n                        grid[r][c] = 2;\\n                        freshOranges--;\\n                        if(freshOranges == 0) return time + 1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n-------------------------------------------------------------\\n2D into 1D\\nWithout Pair class\\n```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        \\n        int freshOranges = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 2) queue.add(i * m + j);\\n                else if(grid[i][j] == 1)  freshOranges++;\\n            }\\n        }\\n        \\n        if(freshOranges == 0) return 0;\\n        \\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        int time = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size-- > 0) {\\n                int idx = queue.poll();\\n                int x = idx / m;\\n                int y = idx % m;\\n                \\n                for(int d = 0; d < dir.length; d++) {\\n                    int r = x + dir[d][0];\\n                    int c = y + dir[d][1];\\n                    \\n                    if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] == 1) {\\n                        queue.add(r * m + c);\\n                        grid[r][c] = 2;\\n                        freshOranges--;\\n                        if(freshOranges == 0) return time + 1;\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n------------------------------------------------------------------------------",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    static class Pair {\\n        int x;\\n        int y;\\n        \\n        public Pair(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    \\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        Queue<Pair> queue = new LinkedList<>();\\n        \\n        int freshOranges = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 2) queue.add(new Pair(i, j));\\n                else if(grid[i][j] == 1)  freshOranges++;\\n            }\\n        }\\n        \\n        if(freshOranges == 0) return 0;\\n        \\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        int time = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size-- > 0) {\\n                Pair currentPair = queue.poll();\\n\\n                for(int d = 0; d < dir.length; d++) {\\n                    int r = currentPair.x + dir[d][0];\\n                    int c = currentPair.y + dir[d][1];\\n                    if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] == 1) {\\n                        queue.add(new Pair(r, c));\\n                        grid[r][c] = 2;\\n                        freshOranges--;\\n                        if(freshOranges == 0) return time + 1;\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    static class Pair {\\n        int x;\\n        int y;\\n        int time;\\n        \\n        public Pair(int x, int y, int time) {\\n            this.x = x;\\n            this.y = y;\\n            this.time = time;\\n        }\\n    }\\n    \\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        Queue<Pair> queue = new LinkedList<>();\\n        \\n        int freshOranges = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 2) queue.add(new Pair(i, j, 0));\\n                else if(grid[i][j] == 1)  freshOranges++;\\n            }\\n        }\\n        \\n        if(freshOranges == 0) return 0;\\n        \\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size-- > 0) {\\n                Pair currentPair = queue.poll();\\n                int time = currentPair.time;\\n                \\n                for(int d = 0; d < dir.length; d++) {\\n                    int r = currentPair.x + dir[d][0];\\n                    int c = currentPair.y + dir[d][1];\\n                    if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] == 1) {\\n                        queue.add(new Pair(r, c, time + 1));\\n                        grid[r][c] = 2;\\n                        freshOranges--;\\n                        if(freshOranges == 0) return time + 1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        \\n        int freshOranges = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 2) queue.add(i * m + j);\\n                else if(grid[i][j] == 1)  freshOranges++;\\n            }\\n        }\\n        \\n        if(freshOranges == 0) return 0;\\n        \\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        int time = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size-- > 0) {\\n                int idx = queue.poll();\\n                int x = idx / m;\\n                int y = idx % m;\\n                \\n                for(int d = 0; d < dir.length; d++) {\\n                    int r = x + dir[d][0];\\n                    int c = y + dir[d][1];\\n                    \\n                    if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] == 1) {\\n                        queue.add(r * m + c);\\n                        grid[r][c] = 2;\\n                        freshOranges--;\\n                        if(freshOranges == 0) return time + 1;\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274017,
                "title": "dfs-soln-with-o-1-space-faster-then-94",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(int i,int j,vector<vector<int>>& grid,int timer)\\n    {\\n        if(i>=0&&j>=0&&j<grid[0].size()&&i<grid.size()&&(grid[i][j]==1||grid[i][j]<timer))\\n            return 1;\\n        return 0;\\n    }\\n    void dfs(int i,int j,vector<vector<int>>& grid,int timer)\\n  {\\n      grid[i][j]=timer;\\n      timer--;\\n       if(check(i-1,j,grid,timer))\\n       dfs(i-1,j,grid,timer);\\n       if(check(i+1,j,grid,timer))\\n       dfs(i+1,j,grid,timer);\\n       if(check(i,j-1,grid,timer))\\n       dfs(i,j-1,grid,timer);\\n       if(check(i,j+1,grid,timer))\\n       dfs(i,j+1,grid,timer);\\n       \\n  }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n           for(int i=0;i<grid.size();i++)\\n           {\\n               for(int j=0;j<grid[0].size();j++)\\n               {\\n                   if(grid[i][j]==2)\\n                   dfs(i,j,grid,0);\\n               }\\n           }\\n           int  min=0;\\n            for(int i=0;i<grid.size();i++)\\n                   {\\n                   for(int j=0;j<grid[0].size();j++)\\n               {\\n                   if(grid[i][j]==1)\\n                   return -1;\\n                   //cout<<grid[i][j]<<\" \";\\n                   if(grid[i][j]<min)\\n               min=grid[i][j];\\n               }\\n              // cout<<endl;\\n                   }\\n               return -min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int i,int j,vector<vector<int>>& grid,int timer)\\n    {\\n        if(i>=0&&j>=0&&j<grid[0].size()&&i<grid.size()&&(grid[i][j]==1||grid[i][j]<timer))\\n            return 1;\\n        return 0;\\n    }\\n    void dfs(int i,int j,vector<vector<int>>& grid,int timer)\\n  {\\n      grid[i][j]=timer;\\n      timer--;\\n       if(check(i-1,j,grid,timer))\\n       dfs(i-1,j,grid,timer);\\n       if(check(i+1,j,grid,timer))\\n       dfs(i+1,j,grid,timer);\\n       if(check(i,j-1,grid,timer))\\n       dfs(i,j-1,grid,timer);\\n       if(check(i,j+1,grid,timer))\\n       dfs(i,j+1,grid,timer);\\n       \\n  }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n           for(int i=0;i<grid.size();i++)\\n           {\\n               for(int j=0;j<grid[0].size();j++)\\n               {\\n                   if(grid[i][j]==2)\\n                   dfs(i,j,grid,0);\\n               }\\n           }\\n           int  min=0;\\n            for(int i=0;i<grid.size();i++)\\n                   {\\n                   for(int j=0;j<grid[0].size();j++)\\n               {\\n                   if(grid[i][j]==1)\\n                   return -1;\\n                   //cout<<grid[i][j]<<\" \";\\n                   if(grid[i][j]<min)\\n               min=grid[i][j];\\n               }\\n              // cout<<endl;\\n                   }\\n               return -min;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1255777,
                "title": "simple-c-soln",
                "content": "```\\nint dir[4][2]={{0,1},{0,-1},{1,0},{-1,0}};\\n    int orangesRotting(vector<vector<int>>&arr) {\\n        int m=arr.size();\\n        int n=arr[0].size();\\n        int time=0;\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(arr[i][j]==2){\\n                    q.push({i,j});\\n                    arr[i][j]=-1;\\n                }\\n            }         \\n        }\\n        while(q.size()){\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                pair<int,int>curr=q.front();\\n                q.pop();\\n                for(int j=0;j<4;j++){\\n                    int r=curr.first+dir[j][0];\\n                    int c=curr.second+dir[j][1];\\n                    if(r<0||c<0||r>m-1||c>n-1||arr[r][c]!=1)\\n                        continue;\\n                    q.push({r,c});\\n                    arr[r][c]=-1;\\n                }\\n            }\\n            time++;\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(arr[i][j]==1)\\n                    return -1;\\n            }\\n        }\\n        return time!=0? time-1:time;;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint dir[4][2]={{0,1},{0,-1},{1,0},{-1,0}};\\n    int orangesRotting(vector<vector<int>>&arr) {\\n        int m=arr.size();\\n        int n=arr[0].size();\\n        int time=0;\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(arr[i][j]==2){\\n                    q.push({i,j});\\n                    arr[i][j]=-1;\\n                }\\n            }         \\n        }\\n        while(q.size()){\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                pair<int,int>curr=q.front();\\n                q.pop();\\n                for(int j=0;j<4;j++){\\n                    int r=curr.first+dir[j][0];\\n                    int c=curr.second+dir[j][1];\\n                    if(r<0||c<0||r>m-1||c>n-1||arr[r][c]!=1)\\n                        continue;\\n                    q.push({r,c});\\n                    arr[r][c]=-1;\\n                }\\n            }\\n            time++;\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(arr[i][j]==1)\\n                    return -1;\\n            }\\n        }\\n        return time!=0? time-1:time;;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1231899,
                "title": "easy-solution-for-beginners",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n    // to change the fresh oranges which will rot due to their neighbours\\n    void cor(vector<vector<int>> &grid) { \\n        int r=grid.size(), c=grid[0].size();\\n        for (auto i=0;i<r;i++) for (auto j=0;j<c;j++) if(grid[i][j]==3) grid[i][j]=2;\\n    }\\n    \\n\\t// here we see whether there is a fresh orange in the neighbourhood of a rotten orange. If yes, we\\'ll mark that \\'3\\' which will later be marked \\'2\\'(rotten) using cor()\\n    void repair(vector<vector<int>> &grid, int i, int j) { \\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size()) return;\\n        \\n        if(grid[i][j]==1) grid[i][j]=3;\\n        return;\\n    }\\n    \\n\\t// we check whether there are any fresh oranges left in the grid\\n    bool check(vector<vector<int>> grid) { \\n        int r=grid.size(), c=grid[0].size();\\n        for (auto i=0;i<r;i++) for (auto j=0;j<c;j++) if(grid[i][j]==1) return true;\\n        return false;\\n    }\\n    \\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int r=grid.size(), c=grid[0].size();\\n        int ans=0; //to count the number of minutes\\n\\n        while(check(grid)) {\\n\\t\\t// observing the boundary conditions, if the count of minutes turns out to be more than let\\'s say 100, than there is some fresh orange who is living in a full healthy neighbourhood. In short, mission failed for rotten oranges\\n            if(ans>100) return -1; \\n            ans++;\\n            for (auto i=0;i<r;i++) {\\n                for (auto j=0;j<c;j++) \\n                    if(grid[i][j]==2) {\\n\\t\\t\\t\\t\\t// Taking a stroll in the neighbourhood of this rotten orange\\n                        repair(grid,i-1,j);\\n                        repair(grid,i,j-1);\\n                        repair(grid,i,j+1);\\n                        repair(grid,i+1,j);\\n                    }\\n            }\\n            \\n            cor(grid);\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n    // to change the fresh oranges which will rot due to their neighbours\\n    void cor(vector<vector<int>> &grid) { \\n        int r=grid.size(), c=grid[0].size();\\n        for (auto i=0;i<r;i++) for (auto j=0;j<c;j++) if(grid[i][j]==3) grid[i][j]=2;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 910426,
                "title": "bfs-js-solution",
                "content": "```\\nvar orangesRotting = function(grid) {\\n    if (grid.length === 0 || grid[0].length === 0) {\\n        return -1;\\n    }\\n    let DIRECTIONS = [[-1,0],[0,1],[1,0],[0,-1]];\\n    let height = grid.length, width = grid[0].length;\\n    let fresh = 0;\\n    let queue = [], depth = 0;\\n    // Get the number of fresh oranges at start and\\n    // collect starting points of BFS traversal\\n    for (let i = 0; i < height; i++) {\\n        for (let j = 0; j < width; j++) {\\n            if (grid[i][j] === 1) {\\n                fresh++;\\n            } else if (grid[i][j] === 2) {\\n                queue.push([i, j]);\\n            }\\n        }\\n    }\\n    if (fresh === 0) {\\n        return 0;\\n    }\\n    while (queue.length > 0) {\\n        let queueLen = queue.length;\\n        let rot = 0;\\n        for (let i = 0; i < queueLen; i++) {\\n            let [row, col] = queue.shift();\\n            if (grid[row][col] === 1) {\\n                rot++;\\n                grid[row][col] = 2;\\n            }\\n            for (let dir of DIRECTIONS) {\\n                let newRow = row + dir[0], newCol = col + dir[1];\\n                if (newRow >= 0 && newRow < height \\n                    && newCol >= 0 && newCol < width\\n                   && grid[newRow][newCol] === 1) {\\n                    queue.push([newRow, newCol]);\\n                }\\n            }\\n        }\\n        if (rot > 0) {\\n            fresh -= rot;\\n            depth++;\\n        }\\n    }\\n    return fresh === 0 ? depth : -1;\\n};\\n\\n/*\\nSolution\\n\\n1. Perform BFS traversal at each rotten orange simultaneously\\n2. Check if there is no fresh orange at the end of traversal\\n3. The depth of the traversal is equivalent to the number of minutes elapsed\\n\\nTime Complexity: O(m*n) where m = the number of rows, n = the number of columns\\nSpace Complexity: O(m*n)\\n*/\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar orangesRotting = function(grid) {\\n    if (grid.length === 0 || grid[0].length === 0) {\\n        return -1;\\n    }\\n    let DIRECTIONS = [[-1,0],[0,1],[1,0],[0,-1]];\\n    let height = grid.length, width = grid[0].length;\\n    let fresh = 0;\\n    let queue = [], depth = 0;\\n    // Get the number of fresh oranges at start and\\n    // collect starting points of BFS traversal\\n    for (let i = 0; i < height; i++) {\\n        for (let j = 0; j < width; j++) {\\n            if (grid[i][j] === 1) {\\n                fresh++;\\n            } else if (grid[i][j] === 2) {\\n                queue.push([i, j]);\\n            }\\n        }\\n    }\\n    if (fresh === 0) {\\n        return 0;\\n    }\\n    while (queue.length > 0) {\\n        let queueLen = queue.length;\\n        let rot = 0;\\n        for (let i = 0; i < queueLen; i++) {\\n            let [row, col] = queue.shift();\\n            if (grid[row][col] === 1) {\\n                rot++;\\n                grid[row][col] = 2;\\n            }\\n            for (let dir of DIRECTIONS) {\\n                let newRow = row + dir[0], newCol = col + dir[1];\\n                if (newRow >= 0 && newRow < height \\n                    && newCol >= 0 && newCol < width\\n                   && grid[newRow][newCol] === 1) {\\n                    queue.push([newRow, newCol]);\\n                }\\n            }\\n        }\\n        if (rot > 0) {\\n            fresh -= rot;\\n            depth++;\\n        }\\n    }\\n    return fresh === 0 ? depth : -1;\\n};\\n\\n/*\\nSolution\\n\\n1. Perform BFS traversal at each rotten orange simultaneously\\n2. Check if there is no fresh orange at the end of traversal\\n3. The depth of the traversal is equivalent to the number of minutes elapsed\\n\\nTime Complexity: O(m*n) where m = the number of rows, n = the number of columns\\nSpace Complexity: O(m*n)\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 907086,
                "title": "c-solution-using-queue-runtime-80-ms-faster-than-100-00",
                "content": "```\\npublic class Solution \\n{\\n    private int minutes = 0;\\n    \\n    public int OrangesRotting(int[][] grid) \\n    {\\n        var freshCount = 0;\\n        var rottenCoordinates = new Queue<(int i, int j)>();\\n        for (int i = 0; i < grid.Length; i++)\\n        {\\n            var row = grid[i];\\n            for (int j = 0; j < row.Length; j++)\\n            {\\n                if (row[j] == 1)\\n                {\\n                    freshCount++;\\n                }\\n                \\n                if (row[j] == 2)\\n                {\\n                    rottenCoordinates.Enqueue((i, j));\\n                }\\n            }\\n        }\\n        \\n        if (freshCount == 0)\\n        {\\n            return 0;\\n        }\\n        \\n        var minutes = -1;\\n        while (rottenCoordinates.Count > 0)\\n        {\\n            var count = rottenCoordinates.Count;\\n            \\n            while (count > 0)\\n            {\\n                var coordinates = rottenCoordinates.Dequeue();\\n                var i = coordinates.i;\\n                var j = coordinates.j;\\n                \\n                if (j < grid[i].Length - 1 && grid[i][j + 1] == 1)\\n                {\\n                    rottenCoordinates.Enqueue((i, j + 1));\\n                    grid[i][j + 1] = 2;\\n                    freshCount--;\\n                }\\n                \\n                if (i > 0 && grid[i - 1][j] == 1)\\n                {\\n                    rottenCoordinates.Enqueue((i - 1, j));\\n                    grid[i - 1][j] = 2;\\n                    freshCount--;\\n                }\\n                \\n                if (j > 0 && grid[i][j - 1] == 1)\\n                {\\n                    rottenCoordinates.Enqueue((i, j - 1));\\n                    grid[i][j - 1] = 2;\\n                    freshCount--;\\n                }\\n                \\n                if (i < grid.Length - 1 && grid[i + 1][j] == 1)\\n                {\\n                    rottenCoordinates.Enqueue((i + 1, j));\\n                    grid[i + 1][j] = 2;\\n                    freshCount--;\\n                }\\n                \\n                count--;\\n            }\\n            \\n            minutes++;\\n        }\\n        \\n        return freshCount > 0 ? -1 : minutes;\\n    }\\n}",
                "solutionTags": [
                    "Queue"
                ],
                "code": "class Solution \\n{\\n    private int minutes = 0;\\n    \\n    public int OrangesRotting(int[][] grid) \\n    {\\n        var freshCount = 0;\\n        var rottenCoordinates = new Queue<(int i, int j)>();\\n        for (int i = 0; i < grid.Length; i++)\\n        {\\n            var row = grid[i];\\n            for (int j = 0; j < row.Length; j++)\\n            {\\n                if (row[j] == 1)\\n                {\\n                    freshCount++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 781645,
                "title": "c-simple-bfs-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,1,0,0,};\\n    int dy[4]={0,0,-1,1};\\n    \\n    vector<vector<int>> grd;\\n    int ans=0,n,m;\\n    \\n    void bfs(){\\n        queue<pair<int,int>> qu;\\n        \\n        //pushing every rotten orange in queue\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(grd[i][j]==2) qu.push({i,j});\\n        \\n        while(!qu.empty()){\\n            int sz=qu.size();\\n            //pushed is used to know whether next level of fresh oranges (next layer of bfs) are there\\n            bool pushed=false;\\n            \\n            //loop used to traverse all rotten oranges which are in queue\\n            for(int i=0;i<sz;i++){\\n                int x=qu.front().first,y=qu.front().second;\\n                qu.pop();\\n                for(int k=0;k<4;k++){\\n                    //if coordinates are invalid then skip\\n                    if(x+dx[k]<0 or y+dy[k]<0 or x+dx[k]>=grd.size() or y+dy[k]>=grd[0].size()) continue;\\n                    //if they are and valid and we encounter fresh orange then push that into queue\\n                    if(grd[x+dx[k]][y+dy[k]]==1){\\n                        //pushed is also made true confirming there is another layer also\\n                        qu.push({x+dx[k],y+dy[k]}),pushed=true;\\n                        //fresh orange converted into rotten orange \\n                        grd[x+dx[k]][y+dy[k]]=2;    \\n                    } \\n                }\\n            }\\n            //confirming that this is not last layer and increamenting ans\\n            if(pushed) ans++;\\n        }\\n    }\\n    \\n    int orangesRotting(vector<vector<int>>& grid) {\\n        grd=grid,n=grd.size(),m=grd[0].size();\\n        //breadth first search over the grid\\n        bfs();\\n        //if there is still some fresh oranges return -1 else return the ans\\n        for(auto it:grd) for(auto jt:it) if(jt==1) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,1,0,0,};\\n    int dy[4]={0,0,-1,1};\\n    \\n    vector<vector<int>> grd;\\n    int ans=0,n,m;\\n    \\n    void bfs(){\\n        queue<pair<int,int>> qu;\\n        \\n        //pushing every rotten orange in queue\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(grd[i][j]==2) qu.push({i,j});\\n        \\n        while(!qu.empty()){\\n            int sz=qu.size();\\n            //pushed is used to know whether next level of fresh oranges (next layer of bfs) are there\\n            bool pushed=false;\\n            \\n            //loop used to traverse all rotten oranges which are in queue\\n            for(int i=0;i<sz;i++){\\n                int x=qu.front().first,y=qu.front().second;\\n                qu.pop();\\n                for(int k=0;k<4;k++){\\n                    //if coordinates are invalid then skip\\n                    if(x+dx[k]<0 or y+dy[k]<0 or x+dx[k]>=grd.size() or y+dy[k]>=grd[0].size()) continue;\\n                    //if they are and valid and we encounter fresh orange then push that into queue\\n                    if(grd[x+dx[k]][y+dy[k]]==1){\\n                        //pushed is also made true confirming there is another layer also\\n                        qu.push({x+dx[k],y+dy[k]}),pushed=true;\\n                        //fresh orange converted into rotten orange \\n                        grd[x+dx[k]][y+dy[k]]=2;    \\n                    } \\n                }\\n            }\\n            //confirming that this is not last layer and increamenting ans\\n            if(pushed) ans++;\\n        }\\n    }\\n    \\n    int orangesRotting(vector<vector<int>>& grid) {\\n        grd=grid,n=grd.size(),m=grd[0].size();\\n        //breadth first search over the grid\\n        bfs();\\n        //if there is still some fresh oranges return -1 else return the ans\\n        for(auto it:grd) for(auto jt:it) if(jt==1) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 751708,
                "title": "c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\nstruct Test{\\n    int x,y,z;\\n};\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int numFresh = 0;\\n        queue<Test> q;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++){\\n                if(grid[i][j] == 2) q.push({i,j,0});\\n                if(grid[i][j] == 1) numFresh++;\\n            }\\n        }\\n        int res = 0;\\n        while(!q.empty()){\\n            Test pos = q.front();\\n            q.pop();\\n            int row = pos.x;\\n            int col = pos.y;\\n            int minute = pos.z;\\n            if(row != 0){\\n                if(grid[row-1][col] == 1){\\n                    q.push({row-1,col,minute + 1});\\n                    grid[row-1][col] = 2;\\n                    numFresh--;\\n                }\\n            }\\n            if(row != grid.size() - 1){\\n                if(grid[row+1][col] == 1){\\n                    q.push({row+1,col,minute + 1});\\n                    grid[row+1][col] = 2;\\n                    numFresh--;\\n                }\\n            }\\n            if(col != 0){\\n                if(grid[row][col-1] == 1){\\n                    q.push({row,col-1,minute + 1});\\n                    grid[row][col-1] = 2;\\n                    numFresh--;\\n                }\\n            }\\n            if(col != grid[0].size()-1){\\n                if(grid[row][col+1] == 1){\\n                    q.push({row,col+1,minute + 1});\\n                    grid[row][col+1] = 2;\\n                    numFresh--;\\n                }\\n            }\\n            res = minute;\\n\\n        }\\n        if(numFresh == 0){\\n            return res;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nstruct Test{\\n    int x,y,z;\\n};\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int numFresh = 0;\\n        queue<Test> q;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++){\\n                if(grid[i][j] == 2) q.push({i,j,0});\\n                if(grid[i][j] == 1) numFresh++;\\n            }\\n        }\\n        int res = 0;\\n        while(!q.empty()){\\n            Test pos = q.front();\\n            q.pop();\\n            int row = pos.x;\\n            int col = pos.y;\\n            int minute = pos.z;\\n            if(row != 0){\\n                if(grid[row-1][col] == 1){\\n                    q.push({row-1,col,minute + 1});\\n                    grid[row-1][col] = 2;\\n                    numFresh--;\\n                }\\n            }\\n            if(row != grid.size() - 1){\\n                if(grid[row+1][col] == 1){\\n                    q.push({row+1,col,minute + 1});\\n                    grid[row+1][col] = 2;\\n                    numFresh--;\\n                }\\n            }\\n            if(col != 0){\\n                if(grid[row][col-1] == 1){\\n                    q.push({row,col-1,minute + 1});\\n                    grid[row][col-1] = 2;\\n                    numFresh--;\\n                }\\n            }\\n            if(col != grid[0].size()-1){\\n                if(grid[row][col+1] == 1){\\n                    q.push({row,col+1,minute + 1});\\n                    grid[row][col+1] = 2;\\n                    numFresh--;\\n                }\\n            }\\n            res = minute;\\n\\n        }\\n        if(numFresh == 0){\\n            return res;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 656460,
                "title": "simple-solution-in-the-lines-of-number-of-islands-problem",
                "content": "```\\nclass Solution {\\n    \\n    // bfs .. lets make queue.\\n    Queue<Node> queue = new LinkedList<Node>();\\n\\n    public int orangesRotting(int[][] grid) {\\n    int max = 0;\\n\\n        for(int i=0;i<grid.length;i++) {\\n            \\n            for(int j=0;j<grid[i].length;j++) {\\n        \\n                if (grid[i][j]==2) {\\n                    Node node = new Node();\\n                    node.point.x = i;\\n                    node.point.y = j;\\n                    queue.add(node);\\n                } \\n            }\\n        }\\n        \\n        while(!queue.isEmpty()) {\\n            \\n            Node node = queue.poll();\\n            int i = node.point.x;\\n            int j = node.point.y;\\n            int minutes = node.minutes;\\n            if (max<minutes)\\n                max = minutes;\\n           \\n            makeRotten(i+1, j,minutes, grid );\\n            makeRotten(i-1, j,minutes, grid);\\n            makeRotten(i, j+1,minutes, grid);\\n            makeRotten(i, j-1,minutes, grid);\\n\\n        }\\n        \\n        for(int i=0;i<grid.length;i++) {\\n            for(int j=0;j<grid[i].length;j++) {\\n        \\n                if (grid[i][j]==1) {\\n                   return -1;\\n                } \\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public boolean makeRotten(int i, int j,int minutes, int[][] grid) {\\n                \\n        // if no fresh orange found then return \\n        if (i<0 || i>=grid.length || j<0 || j>=grid[i].length ||\\n           grid[i][j]!=1) {\\n            return false;\\n        }\\n         \\n       // if fresh orange found then make it to rotten and add to queue with counter incremented \\n        grid[i][j]=2;\\n        Node node = new Node();\\n        node.point.x=i;\\n        node.point.y=j;\\n        node.minutes = minutes+1;\\n        queue.add(node); \\n        return true;\\n         \\n    }\\n    \\nclass Node {\\n    \\n    public int minutes;\\n    public Point point;\\n    \\n    public Node() {\\n        minutes = 0;\\n        point = new Point();\\n        point.x = 0;\\n        point.y = 0;\\n    }\\n}\\n    \\nclass Point {\\n    \\n    public int x;\\n    public int y;\\n}    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // bfs .. lets make queue.\\n    Queue<Node> queue = new LinkedList<Node>();\\n\\n    public int orangesRotting(int[][] grid) {\\n    int max = 0;\\n\\n        for(int i=0;i<grid.length;i++) {\\n            \\n            for(int j=0;j<grid[i].length;j++) {\\n        \\n                if (grid[i][j]==2) {\\n                    Node node = new Node();\\n                    node.point.x = i;\\n                    node.point.y = j;\\n                    queue.add(node);\\n                } \\n            }\\n        }\\n        \\n        while(!queue.isEmpty()) {\\n            \\n            Node node = queue.poll();\\n            int i = node.point.x;\\n            int j = node.point.y;\\n            int minutes = node.minutes;\\n            if (max<minutes)\\n                max = minutes;\\n           \\n            makeRotten(i+1, j,minutes, grid );\\n            makeRotten(i-1, j,minutes, grid);\\n            makeRotten(i, j+1,minutes, grid);\\n            makeRotten(i, j-1,minutes, grid);\\n\\n        }\\n        \\n        for(int i=0;i<grid.length;i++) {\\n            for(int j=0;j<grid[i].length;j++) {\\n        \\n                if (grid[i][j]==1) {\\n                   return -1;\\n                } \\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public boolean makeRotten(int i, int j,int minutes, int[][] grid) {\\n                \\n        // if no fresh orange found then return \\n        if (i<0 || i>=grid.length || j<0 || j>=grid[i].length ||\\n           grid[i][j]!=1) {\\n            return false;\\n        }\\n         \\n       // if fresh orange found then make it to rotten and add to queue with counter incremented \\n        grid[i][j]=2;\\n        Node node = new Node();\\n        node.point.x=i;\\n        node.point.y=j;\\n        node.minutes = minutes+1;\\n        queue.add(node); \\n        return true;\\n         \\n    }\\n    \\nclass Node {\\n    \\n    public int minutes;\\n    public Point point;\\n    \\n    public Node() {\\n        minutes = 0;\\n        point = new Point();\\n        point.x = 0;\\n        point.y = 0;\\n    }\\n}\\n    \\nclass Point {\\n    \\n    public int x;\\n    public int y;\\n}    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649989,
                "title": "c-bfs-with-explanation-for-beginners",
                "content": "```\\nclass Solution {\\n\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {        \\n        queue<pair<int,int>> rottenOrangesQ;\\n        int freshOrganges = 0;\\n        for(int i=0; i<grid.size(); ++i)\\n        {\\n            for(int j=0; j<grid[0].size(); ++j)\\n            {\\n                if(grid[i][j] == 2)\\n                   rottenOrangesQ.push({i,j});//rottenOranges\\n                else if(grid[i][j] == 1)\\n                    freshOrganges++;//freshOrganges count\\n            }\\n        }\\n        \\n        if(freshOrganges == 0)//No fresh orange, return 0 days\\n            return 0;\\n        \\n        if(rottenOrangesQ.size() == 0)//No rotten oranges, simply return -1;\\n            return -1;\\n        \\n        int days = 0;\\n        vector<pair<int,int>> directions ={{-1,0},{0,1},{1,0},{0,-1}};//all four directions.\\n        while(!rottenOrangesQ.empty() && freshOrganges>0)//Run until no rotten oranges left in q.\\n        {\\n            int size = rottenOrangesQ.size();//same as level orer.\\n            for(int rottenOranges=0; rottenOranges<size; ++rottenOranges)\\n            {\\n                auto coordinates= rottenOrangesQ.front(); rottenOrangesQ.pop();//take rotten orange coordinate\\n                for(auto dir:directions)//navigate in all four direction.\\n                {\\n                    int i = coordinates.first+dir.first;\\n                    int j = coordinates.second+dir.second;\\n                    if(i<0 || j<0 || i==grid.size() || j==grid[i].size() || grid[i][j] != 1)\\n                        continue;\\n                    \\n                    grid[i][j]=2;\\n                    rottenOrangesQ.push({i,j});//Add new cordinate as rotten orange.\\n                    freshOrganges--;\\n                }\\n            }\\n            days++;\\n        }\\n        if(freshOrganges>0)\\n            return -1;\\n        return days;    \\n    }    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {        \\n        queue<pair<int,int>> rottenOrangesQ;\\n        int freshOrganges = 0;\\n        for(int i=0; i<grid.size(); ++i)\\n        {\\n            for(int j=0; j<grid[0].size(); ++j)\\n            {\\n                if(grid[i][j] == 2)\\n                   rottenOrangesQ.push({i,j});//rottenOranges\\n                else if(grid[i][j] == 1)\\n                    freshOrganges++;//freshOrganges count\\n            }\\n        }\\n        \\n        if(freshOrganges == 0)//No fresh orange, return 0 days\\n            return 0;\\n        \\n        if(rottenOrangesQ.size() == 0)//No rotten oranges, simply return -1;\\n            return -1;\\n        \\n        int days = 0;\\n        vector<pair<int,int>> directions ={{-1,0},{0,1},{1,0},{0,-1}};//all four directions.\\n        while(!rottenOrangesQ.empty() && freshOrganges>0)//Run until no rotten oranges left in q.\\n        {\\n            int size = rottenOrangesQ.size();//same as level orer.\\n            for(int rottenOranges=0; rottenOranges<size; ++rottenOranges)\\n            {\\n                auto coordinates= rottenOrangesQ.front(); rottenOrangesQ.pop();//take rotten orange coordinate\\n                for(auto dir:directions)//navigate in all four direction.\\n                {\\n                    int i = coordinates.first+dir.first;\\n                    int j = coordinates.second+dir.second;\\n                    if(i<0 || j<0 || i==grid.size() || j==grid[i].size() || grid[i][j] != 1)\\n                        continue;\\n                    \\n                    grid[i][j]=2;\\n                    rottenOrangesQ.push({i,j});//Add new cordinate as rotten orange.\\n                    freshOrganges--;\\n                }\\n            }\\n            days++;\\n        }\\n        if(freshOrganges>0)\\n            return -1;\\n        return days;    \\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645705,
                "title": "java-bfs-solution",
                "content": "My intuitive BFS solution.\\n1. Initial state: Find all rotten oranges.\\n2. Start: A rotten orange starts rotting its neighbors as time goes by.\\n3. End: Check if all oranges are rotten. If yes, return ```time```. Otherwise, return ```-1```.\\n\\n```\\nclass Solution {\\n    int[] dir = new int[] { 0, 1, 0, -1, 0 };\\n    public int orangesRotting(int[][] grid) {\\n        // Init: Find all rotten oranges\\n        int time = 0;\\n        Queue<int[]> queue = new LinkedList<>();\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 2) queue.add(new int[]{ i, j });\\n            }\\n        }\\n        \\n        // Start: A rotten orange starts rotting its neighbors as time goes by\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++) {\\n                int[] cur = queue.poll();\\n                // Find its unrotten neighbors\\n                for(int j = 0; j < 4; j++) {\\n                    int x = cur[0] + dir[j], y = cur[1] + dir[j+1];\\n                    if(0 <= x && 0 <= y && x < grid.length && y < grid[0].length && grid[x][y] == 1) {\\n                        grid[x][y] = 2; \\n                        queue.add(new int[]{ x, y });\\n                    }\\n                }\\n            }\\n            if(!queue.isEmpty()) time++;\\n        }\\n\\n        // End: Check if all oranges are rotten. If yes, return time. Otherwise, return -1.\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1) return -1;\\n            }\\n        }\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```time```\n```-1```\n```\\nclass Solution {\\n    int[] dir = new int[] { 0, 1, 0, -1, 0 };\\n    public int orangesRotting(int[][] grid) {\\n        // Init: Find all rotten oranges\\n        int time = 0;\\n        Queue<int[]> queue = new LinkedList<>();\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 2) queue.add(new int[]{ i, j });\\n            }\\n        }\\n        \\n        // Start: A rotten orange starts rotting its neighbors as time goes by\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++) {\\n                int[] cur = queue.poll();\\n                // Find its unrotten neighbors\\n                for(int j = 0; j < 4; j++) {\\n                    int x = cur[0] + dir[j], y = cur[1] + dir[j+1];\\n                    if(0 <= x && 0 <= y && x < grid.length && y < grid[0].length && grid[x][y] == 1) {\\n                        grid[x][y] = 2; \\n                        queue.add(new int[]{ x, y });\\n                    }\\n                }\\n            }\\n            if(!queue.isEmpty()) time++;\\n        }\\n\\n        // End: Check if all oranges are rotten. If yes, return time. Otherwise, return -1.\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1) return -1;\\n            }\\n        }\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 569248,
                "title": "alternate-approach-bfs-o-n-height-but-constant-space-easy-to-understand-modular-code",
                "content": "The idea is to do BFS using the given input array.\\n\\nEvery minute, just find and set the ones that are going to rot, to the current minute in the input array.\\nTo illustrate the idea, consider how it would play out - \\nStart by marking all fresh ones adjacent to the rotten ones with value 2 as 3.\\nThen, mark all fresh ones adjacent to the rotten ones with value 3 as 4.\\nThen, mark all fresh ones adjacent to the rotten ones with value 4 as 5.\\n...\\nKeep doing this until that are no more adjacent fresh oranges to rot.\\nNote: One can start timer at minute 2 as it\\'s the time elapsed that matters. \\n\\nTime - O (N * Height)\\nSpace - O (1) \\nThis offcourse assumes that the input can be modified.  \\n\\n```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int time = 2;\\n        boolean moreToRot = true;\\n        while (moreToRot) {\\n            moreToRot = rotNextMinuteOnes(grid, time);\\n            if (moreToRot) time++;\\n        }\\n        return allRotten(grid) ? time - 2 : -1;\\n    }\\n    \\n    private boolean rotNextMinuteOnes(int[][] grid, int time) {\\n        boolean moreToRot = false;\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                moreToRot = rotAdjacentIfJustRotten(grid, i, j, time) || moreToRot;\\n        return moreToRot;\\n    }\\n    \\n    private boolean rotAdjacentIfJustRotten(int[][] grid, int i, int j, int time) {\\n        if (grid[i][j] != time) return false;\\n        boolean right = rotIfFresh(grid, i, j + 1, time + 1);\\n        boolean bottom = rotIfFresh(grid, i + 1, j, time + 1);\\n        boolean left = rotIfFresh(grid, i, j - 1, time + 1);\\n        boolean up = rotIfFresh(grid, i - 1, j, time + 1);\\n        return right || bottom || left || up;\\n    }\\n    \\n    private boolean rotIfFresh(int[][] grid, int i, int j, int time) {\\n        if (i < 0 || i >= grid.length) return false;\\n        if (j < 0 || j >= grid[0].length) return false;\\n        if (grid[i][j] != 1) return false;\\n        grid[i][j] = time;\\n        return true;\\n    }\\n    \\n    private boolean allRotten(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (grid[i][j] == 1) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int time = 2;\\n        boolean moreToRot = true;\\n        while (moreToRot) {\\n            moreToRot = rotNextMinuteOnes(grid, time);\\n            if (moreToRot) time++;\\n        }\\n        return allRotten(grid) ? time - 2 : -1;\\n    }\\n    \\n    private boolean rotNextMinuteOnes(int[][] grid, int time) {\\n        boolean moreToRot = false;\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                moreToRot = rotAdjacentIfJustRotten(grid, i, j, time) || moreToRot;\\n        return moreToRot;\\n    }\\n    \\n    private boolean rotAdjacentIfJustRotten(int[][] grid, int i, int j, int time) {\\n        if (grid[i][j] != time) return false;\\n        boolean right = rotIfFresh(grid, i, j + 1, time + 1);\\n        boolean bottom = rotIfFresh(grid, i + 1, j, time + 1);\\n        boolean left = rotIfFresh(grid, i, j - 1, time + 1);\\n        boolean up = rotIfFresh(grid, i - 1, j, time + 1);\\n        return right || bottom || left || up;\\n    }\\n    \\n    private boolean rotIfFresh(int[][] grid, int i, int j, int time) {\\n        if (i < 0 || i >= grid.length) return false;\\n        if (j < 0 || j >= grid[0].length) return false;\\n        if (grid[i][j] != 1) return false;\\n        grid[i][j] = time;\\n        return true;\\n    }\\n    \\n    private boolean allRotten(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (grid[i][j] == 1) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 560328,
                "title": "c-bfs-runtime-error-addition-of-unsigned-offset",
                "content": "I am getting this error on running the following code. \\n\\nruntime erroe:addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\nSUMMARY: undefined-Behaviour......\\n\\nPlease help me out.\\n\"\"\"\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int rows=grid[0].size();\\n        int cols=grid.size();\\n        queue<vector<int>> q;\\n        int res;\\n        vector<int>qc={0,0,grid[0][0]};\\n        q.push(qc);\\n        \\n        while(!q.empty())\\n        {\\n            vector<int> temp=q.front();\\n            q.pop();\\n            res++;\\n            if(temp[2]==2)\\n            {\\n                if(temp[0]-1>=0)\\n                { if(grid[temp[0]-1][temp[1]]==1)\\n                {grid[temp[0]-1][temp[1]]=2;\\n                    q.push({temp[0]-1,temp[1],2});\\n                }\\n                }\\n                \\n                 if(temp[0]+1<rows)\\n                {\\n                     if( grid[temp[0]+1][temp[1]]==1)\\n                     {\\n                    grid[temp[0]-1][temp[1]]=2;\\n                    q.push({temp[0]+1,temp[1],2});\\n                }\\n                 }\\n                 if(temp[1]-1>=0 )\\n                { if(grid[temp[0]][temp[1]-1]==1)\\n                {\\n                    grid[temp[0]-1][temp[1]]=2;\\n                    q.push({temp[0],temp[1]-1,2});\\n                }\\n                }\\n                 if(temp[1]+1<cols )\\n                { if(grid[temp[0]][temp[1]+1]==1)\\n                {\\n                    grid[temp[0]-1][temp[1]]=2;\\n                    q.push({temp[0],temp[1]+1,2});\\n                }\\n                }\\n            }\\n            \\n        }\\n        \\n        for(int i=0;i<rows;++i)\\n            for(int j=0;j<cols;++j)\\n                if(grid[i][j]==1)\\n                    return -1;\\n        \\n        return res;\\n    }\\n};\\n\"\"\"\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int rows=grid[0].size();\\n        int cols=grid.size();\\n        queue<vector<int>> q;\\n        int res;\\n        vector<int>qc={0,0,grid[0][0]}",
                "codeTag": "Java"
            },
            {
                "id": 380667,
                "title": "2ms-readable-java-solution-bfs",
                "content": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        int numFresh = 0;\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        for(int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == 2) {\\n                    queue.add(new int[]{ j, i });\\n                } else if (grid[i][j] == 1) {\\n                    numFresh++;\\n                }\\n            }\\n        }\\n        \\n        if (numFresh == 0) return 0;\\n        \\n        int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        int minutes = 0;\\n                \\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            for(int k = 0; k < size; k++) {\\n                int[] coordinate = queue.poll();\\n                \\n                for (int[] dir: dirs) {\\n                    int x = coordinate[0] + dir[0];\\n                    int y = coordinate[1] + dir[1];\\n                    \\n                    if (x < 0 || y < 0 || x >= cols || y >= rows) continue;\\n                    \\n                    if (grid[y][x] == 1) {\\n                        grid[y][x] = 2;\\n                        queue.add(new int[]{ x, y });\\n                        numFresh--;\\n                    }\\n                }\\n            }\\n            minutes++;\\n        }\\n        \\n        return numFresh > 0 ? -1 : minutes-1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        int numFresh = 0;\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        for(int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == 2) {\\n                    queue.add(new int[]{ j, i });\\n                } else if (grid[i][j] == 1) {\\n                    numFresh++;\\n                }\\n            }\\n        }\\n        \\n        if (numFresh == 0) return 0;\\n        \\n        int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        int minutes = 0;\\n                \\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            for(int k = 0; k < size; k++) {\\n                int[] coordinate = queue.poll();\\n                \\n                for (int[] dir: dirs) {\\n                    int x = coordinate[0] + dir[0];\\n                    int y = coordinate[1] + dir[1];\\n                    \\n                    if (x < 0 || y < 0 || x >= cols || y >= rows) continue;\\n                    \\n                    if (grid[y][x] == 1) {\\n                        grid[y][x] = 2;\\n                        queue.add(new int[]{ x, y });\\n                        numFresh--;\\n                    }\\n                }\\n            }\\n            minutes++;\\n        }\\n        \\n        return numFresh > 0 ? -1 : minutes-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 368827,
                "title": "c-solution-100",
                "content": "```\\n public int OrangesRotting(int[][] grid)\\n        {\\n            // create direction array to navigate\\n            int[][] dirs = { new[] { 0, -1 }, new[] { 0, 1 }, new[] { -1, 0 }, new[] { 1, 0 } };\\n            // rotten orange queue. \\n            var rottenQueue= new Queue<O>();\\n            var countFresh = 0;\\n            // add the location for all the rotten orange in queue , and processes one orange at a time, and one layer. \\n            for (int i = 0; i < grid.Length; i++)\\n            {\\n                for (int j = 0; j < grid[0].Length; j++)\\n                {\\n                    if (grid[i][j] == 2)\\n                    {\\n                        rottenQueue.Enqueue(new O(i,j,0));\\n                    }\\n                    if (grid[i][j] == 1)\\n                    {\\n                        countFresh++;\\n                    }\\n                }\\n            }\\n            var minute = 0;\\n            while (rottenQueue.Count>0)\\n            {\\n                var o = rottenQueue.Dequeue();\\n                // navigate in all four direction. \\n                foreach (var dir in dirs)\\n                {\\n                    var x = o.X + dir[0];\\n                    var y = o.Y + dir[1];\\n                    // check for boundary condition and , check if the the orange is fresh then only process it.\\n                    if(x<0||x>=grid.Length||y<0||y>=grid[0].Length|| grid[x][y] != 1) continue;\\n                    // increment the layer of rotten orange\\n                    rottenQueue.Enqueue(new O(x,y,o.Layer+1));\\n                    // set orange to rotten\\n                    grid[x][y] = 2;\\n                    // decrement fresh count.\\n                    countFresh--;\\n                }\\n                // replace max layer count.\\n                minute = Math.Max(minute, o.Layer);\\n            }\\n            // if there is still fresh orange left then return -1;\\n            return countFresh >0?-1:minute;\\n\\n        }\\n\\n        public class O\\n        {\\n            public int X { get; }\\n            public int Y { get; }\\n            public int Layer { get; }\\n\\n            public O(int x,int y, int layer)\\n            {\\n                X = x;\\n                Y = y;\\n                Layer = layer;\\n            }\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n public int OrangesRotting(int[][] grid)\\n        {\\n            // create direction array to navigate\\n            int[][] dirs = { new[] { 0, -1 }, new[] { 0, 1 }, new[] { -1, 0 }, new[] { 1, 0 } };\\n            // rotten orange queue. \\n            var rottenQueue= new Queue<O>();\\n            var countFresh = 0;\\n            // add the location for all the rotten orange in queue , and processes one orange at a time, and one layer. \\n            for (int i = 0; i < grid.Length; i++)\\n            {\\n                for (int j = 0; j < grid[0].Length; j++)\\n                {\\n                    if (grid[i][j] == 2)\\n                    {\\n                        rottenQueue.Enqueue(new O(i,j,0));\\n                    }\\n                    if (grid[i][j] == 1)\\n                    {\\n                        countFresh++;\\n                    }\\n                }\\n            }\\n            var minute = 0;\\n            while (rottenQueue.Count>0)\\n            {\\n                var o = rottenQueue.Dequeue();\\n                // navigate in all four direction. \\n                foreach (var dir in dirs)\\n                {\\n                    var x = o.X + dir[0];\\n                    var y = o.Y + dir[1];\\n                    // check for boundary condition and , check if the the orange is fresh then only process it.\\n                    if(x<0||x>=grid.Length||y<0||y>=grid[0].Length|| grid[x][y] != 1) continue;\\n                    // increment the layer of rotten orange\\n                    rottenQueue.Enqueue(new O(x,y,o.Layer+1));\\n                    // set orange to rotten\\n                    grid[x][y] = 2;\\n                    // decrement fresh count.\\n                    countFresh--;\\n                }\\n                // replace max layer count.\\n                minute = Math.Max(minute, o.Layer);\\n            }\\n            // if there is still fresh orange left then return -1;\\n            return countFresh >0?-1:minute;\\n\\n        }\\n\\n        public class O\\n        {\\n            public int X { get; }\\n            public int Y { get; }\\n            public int Layer { get; }\\n\\n            public O(int x,int y, int layer)\\n            {\\n                X = x;\\n                Y = y;\\n                Layer = layer;\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 342939,
                "title": "python-dp-solution",
                "content": "Although BFS can be used to solve the problem, I just want to provide a alternative.\\nIf we let DP[i][j][t] be the days to rot good oranges at step t, then\\nDP[i][j][t] = 1 + min(DP[x][y][t - 1]) for x, y is neighbor of i, j and grid[x][y] != 0\\n\\nInitial conditions are DP[i][j][t] = 0 if grid[i][j] = 2 and DP[i][j][t] = infinity if grid[i][j] != 2\\n\\nAt step mxn, all oranges that can be rotten will get rotten. These are oranges that can be reached from \"2\".\\n\\nBelow is my python implementation\\n\\n```python\\n\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        DP = [[[float(\\'inf\\') for k in range(m*n)] for j in range(n)] for i in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                for t in range(m*n):\\n                    if grid[i][j] == 2:\\n                        DP[i][j][t] = 0\\n                    else:\\n                        DP[i][j][t] = float(\\'inf\\')\\n                    \\n        for t in range(1, m*n):\\n            for i in range(m):\\n                for j in range(n):\\n                    if i + 1 < m and grid[i + 1][j] != 0:\\n                        DP[i][j][t] = min(DP[i][j][t], 1 + DP[i + 1][j][t - 1])\\n                    if i - 1 >= 0 and grid[i - 1][j] != 0:\\n                        DP[i][j][t] = min(DP[i][j][t], 1 + DP[i - 1][j][t - 1])\\n                    if j + 1 < n and grid[i][j + 1] != 0:\\n                        DP[i][j][t] = min(DP[i][j][t], 1 + DP[i][j + 1][t - 1])\\n                    if j - 1 >= 0 and grid[i][j - 1] != 0:\\n                        DP[i][j][t] = min(DP[i][j][t], 1 + DP[i][j - 1][t - 1])\\n                        \\n        res = -float(\\'inf\\')\\n        noOnesFlag = True\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1 and DP[i][j][m*n - 1] > res:\\n                    res = DP[i][j][m*n - 1]\\n                    noOnesFlag = False\\n        if noOnesFlag == True:\\n            return 0\\n        return res if res < float(\\'inf\\') else -1\\n                \\n```",
                "solutionTags": [],
                "code": "```python\\n\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        DP = [[[float(\\'inf\\') for k in range(m*n)] for j in range(n)] for i in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                for t in range(m*n):\\n                    if grid[i][j] == 2:\\n                        DP[i][j][t] = 0\\n                    else:\\n                        DP[i][j][t] = float(\\'inf\\')\\n                    \\n        for t in range(1, m*n):\\n            for i in range(m):\\n                for j in range(n):\\n                    if i + 1 < m and grid[i + 1][j] != 0:\\n                        DP[i][j][t] = min(DP[i][j][t], 1 + DP[i + 1][j][t - 1])\\n                    if i - 1 >= 0 and grid[i - 1][j] != 0:\\n                        DP[i][j][t] = min(DP[i][j][t], 1 + DP[i - 1][j][t - 1])\\n                    if j + 1 < n and grid[i][j + 1] != 0:\\n                        DP[i][j][t] = min(DP[i][j][t], 1 + DP[i][j + 1][t - 1])\\n                    if j - 1 >= 0 and grid[i][j - 1] != 0:\\n                        DP[i][j][t] = min(DP[i][j][t], 1 + DP[i][j - 1][t - 1])\\n                        \\n        res = -float(\\'inf\\')\\n        noOnesFlag = True\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1 and DP[i][j][m*n - 1] > res:\\n                    res = DP[i][j][m*n - 1]\\n                    noOnesFlag = False\\n        if noOnesFlag == True:\\n            return 0\\n        return res if res < float(\\'inf\\') else -1\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 287516,
                "title": "java-dfs-solution",
                "content": "```\\n    private int row, col;\\n    public int orangesRotting(int[][] grid) {\\n        row = grid.length;\\n        col = grid[0].length;\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (grid[i][j] == 2) {\\n                    dfs(grid, i, j , 0, true);\\n                }\\n            }\\n        }\\n\\n        int max = 0;\\n        for (int[] ints : grid) {\\n            for (int anInt : ints) {\\n                if (anInt == 1) {\\n                    return -1;\\n                }\\n                max = Math.min(max, anInt);\\n            }\\n        }\\n        return -max;\\n    }\\n\\n\\n    private void dfs(int[][] grid, int i, int j, int dist, boolean begin) {\\n        if (i >= row || i < 0 || j >= col || j < 0 || grid[i][j] == 0 || grid[i][j] < 0 && -grid[i][j] < dist) return;\\n\\n        if (grid[i][j] == 2 && !begin) {\\n            return;\\n        }\\n        grid[i][j] = -dist;\\n        dfs(grid, i + 1, j, dist + 1, false);\\n        dfs(grid, i - 1, j, dist + 1, false);\\n        dfs(grid, i, j - 1, dist + 1, false);\\n        dfs(grid, i, j + 1, dist + 1, false);\\n    }\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    private int row, col;\\n    public int orangesRotting(int[][] grid) {\\n        row = grid.length;\\n        col = grid[0].length;\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (grid[i][j] == 2) {\\n                    dfs(grid, i, j , 0, true);\\n                }\\n            }\\n        }\\n\\n        int max = 0;\\n        for (int[] ints : grid) {\\n            for (int anInt : ints) {\\n                if (anInt == 1) {\\n                    return -1;\\n                }\\n                max = Math.min(max, anInt);\\n            }\\n        }\\n        return -max;\\n    }\\n\\n\\n    private void dfs(int[][] grid, int i, int j, int dist, boolean begin) {\\n        if (i >= row || i < 0 || j >= col || j < 0 || grid[i][j] == 0 || grid[i][j] < 0 && -grid[i][j] < dist) return;\\n\\n        if (grid[i][j] == 2 && !begin) {\\n            return;\\n        }\\n        grid[i][j] = -dist;\\n        dfs(grid, i + 1, j, dist + 1, false);\\n        dfs(grid, i - 1, j, dist + 1, false);\\n        dfs(grid, i, j - 1, dist + 1, false);\\n        dfs(grid, i, j + 1, dist + 1, false);\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3964616,
                "title": "efficient-bfs-method-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUpon observing example 1, we can notice that the way a rotten orange make its neighbors go rotten is by each level (go north, go east, go south, go west). Therefore, we use BFS and we only need to do it once. \\n\\nOur starting position is rotten oranges since our goal is to make its neighbors go rotten and calculate the total time to make all fresh oranges rotten. Since there could be multiple rotten oranges initially, we push all of their coordinates into a queue while traversing the grid, and start to pop them out while adding their neighbors. Every time we pop/add queue.size() of elements, one second elapses and we can increment our time counter.\\n\\nOnce we finish bfs, if there are still fresh oranges left, we know its impossible to make all fresh oranges go rotten. Sometimes, this happens when we have some fresh oranges isolated from the main block of rotten and fresh oranges. If that\\'s the case, we return -1. We can calculate the amount of fresh oranges in the same loop we populate the queue with initially rotten oranges. Then, we decrement the count for fresh oranges  every time we make a fresh orange rotten in the big while loop when we do BFS. If fresh count != 0, we should return -1 in the end because some fresh oranges remain fresh. \\n\\nIf you are interested in more details, you can search up Neetcode\\'s Youtube video about this problem. Although it\\'s in Python, it helps me a lot to understand. Thank you!  \\nhttps://www.youtube.com/watch?v=y704fEOx0s0\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(row * col)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n      int row = grid.size();\\n      int col = grid[0].size();\\n      int time = 0;\\n\\n      // count the total number of fresh oranges so that we can track if every orange goes rotten eventually\\n      int freshCount = 0;\\n      \\n      // store the locations of initially rotten oranges. Later, we will conduct BFS starting from these locations\\n      queue<pair<int, int>> rotOranges;\\n\\n      // update freshCount and rotOranges\\n      for(int r = 0; r < row; r++){\\n        for (int c = 0; c < col; c++){\\n          if(grid[r][c] == 1){\\n            freshCount++;\\n          } else if(grid[r][c] == 2){\\n              rotOranges.push({r, c});\\n            }\\n          } \\n        }\\n\\n      // directions (N, E, S, W) to explore\\n      vector<pair<int, int>> directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n      while(freshCount > 0 && !rotOranges.empty()){\\n        int n = rotOranges.size();\\n        for(int i = 0; i < n; i++){\\n          pair<int, int> toPop = rotOranges.front();\\n          rotOranges.pop();\\n\\n          // check four directions and make neighbors go rotten if possible\\n          for(auto d: directions){\\n            int r = toPop.first + d.first;\\n            int c = toPop.second + d.second;\\n            if(r >= 0 && r < row && c >= 0 && c < col && grid[r][c] == 1){\\n              grid[r][c] = 2;\\n              freshCount--;\\n              rotOranges.push({r, c});\\n            }\\n          }\\n        }\\n        time++;\\n      }\\n\\n      if(freshCount != 0) {\\n        return -1;\\n      }\\n      return time;\\n    }\\n\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n      int row = grid.size();\\n      int col = grid[0].size();\\n      int time = 0;\\n\\n      // count the total number of fresh oranges so that we can track if every orange goes rotten eventually\\n      int freshCount = 0;\\n      \\n      // store the locations of initially rotten oranges. Later, we will conduct BFS starting from these locations\\n      queue<pair<int, int>> rotOranges;\\n\\n      // update freshCount and rotOranges\\n      for(int r = 0; r < row; r++){\\n        for (int c = 0; c < col; c++){\\n          if(grid[r][c] == 1){\\n            freshCount++;\\n          } else if(grid[r][c] == 2){\\n              rotOranges.push({r, c});\\n            }\\n          } \\n        }\\n\\n      // directions (N, E, S, W) to explore\\n      vector<pair<int, int>> directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n      while(freshCount > 0 && !rotOranges.empty()){\\n        int n = rotOranges.size();\\n        for(int i = 0; i < n; i++){\\n          pair<int, int> toPop = rotOranges.front();\\n          rotOranges.pop();\\n\\n          // check four directions and make neighbors go rotten if possible\\n          for(auto d: directions){\\n            int r = toPop.first + d.first;\\n            int c = toPop.second + d.second;\\n            if(r >= 0 && r < row && c >= 0 && c < col && grid[r][c] == 1){\\n              grid[r][c] = 2;\\n              freshCount--;\\n              rotOranges.push({r, c});\\n            }\\n          }\\n        }\\n        time++;\\n      }\\n\\n      if(freshCount != 0) {\\n        return -1;\\n      }\\n      return time;\\n    }\\n\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961474,
                "title": "best-solution-you-can-get",
                "content": "# **PLEASE UPVOTE MY SOLUTION IF YOU LIKE IT**\\n\\n# Approach\\nGet the dimensions of the grid (m rows and n columns).\\n\\nCreate a copy of the grid named visited to keep track of the state of each orange (0 for empty, 1 for fresh, and 2 for rotten).\\n\\nInitialize a queue named q to store the coordinates of the initially rotten oranges.\\n\\nInitialize countFreshOrange to keep track of the number of fresh oranges.\\n\\nIterate through the entire grid using two nested loops to:\\n\\nPush the coordinates of rotten oranges into the queue (q).\\nCount the number of fresh oranges and increment countFreshOrange.\\nCheck if there are no fresh oranges (countFreshOrange == 0). If there are none, return 0, as the grid is already in the desired state.\\n\\nCheck if there are no initially rotten oranges in the grid (q.empty()). If so, it\\'s not possible to rot all fresh oranges, and thus return -1.\\n\\nInitialize minutes to -1. This variable will keep track of the time passed as we simulate the rotting process.\\n\\nDefine the four possible directions to move: up, down, left, and right, using the dirs vector.\\n\\nBegin the BFS traversal loop:\\n\\nFor each iteration of the outer loop, process all oranges in the queue that are at the same level of rotting (i.e., were rotten for the same number of minutes).\\nFor each orange in the current level, get its coordinates from the front of the queue.\\nFor each direction in the dirs vector, calculate the new coordinates (i, j) based on the current orange\\'s coordinates (x, y).\\nCheck if the new coordinates are within the grid boundaries and if the orange at those coordinates is fresh (denoted by visited[i][j] == 1).\\nIf the conditions are met, mark the orange as rotten (visited[i][j] = 2), decrement the count of fresh oranges, and push the newly rotten orange into the queue for processing in the next level.\\nAfter processing all oranges at the current level, increment the minutes counter.\\n\\nAfter the BFS traversal is complete, check if there are any remaining fresh oranges. If there are none (countFreshOrange == 0), return the value of minutes, indicating the minimum time taken to rot all oranges.\\n\\nIf there are still fresh oranges left, it means they couldn\\'t be rotten, so return -1 to indicate that it\\'s not possible to rot all oranges.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(m * n).\\n\\n\\n- Space complexity:O(m * n).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size(); // Number of rows in the grid\\n        int n = grid[0].size(); // Number of columns in the grid\\n        \\n        // Create a copy of the grid called \"visited\" to track the state of oranges\\n        vector<vector<int>> visited = grid;\\n        \\n        // Create a queue to store the coordinates of rotten oranges\\n        queue<pair<int, int>> q;\\n        \\n        int countFreshOrange = 0; // Count of fresh oranges\\n        \\n        // Iterate through the grid to populate the queue and count fresh oranges\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (visited[i][j] == 2) {\\n                    q.push({i, j}); // Add rotten oranges to the queue\\n                }\\n                if (visited[i][j] == 1) {\\n                    countFreshOrange++; // Count fresh oranges\\n                }\\n            }\\n        }\\n        \\n        // If there are no fresh oranges, return 0 as they are already rotten\\n        if (countFreshOrange == 0)\\n            return 0;\\n        \\n        // If there are no rotten oranges initially, but there are fresh oranges, \\n        // we cannot make them all rotten, so return -1\\n        if (q.empty())\\n            return -1;\\n        \\n        int minutes = -1; // Initialize the time counter\\n        \\n        // Define the four possible directions to move: up, down, left, right\\n        vector<pair<int, int>> dirs = {{1, 0}, {-1, 0}, {0, -1}, {0, 1}};\\n        \\n        // Start the BFS traversal of the grid\\n        while (!q.empty()) {\\n            int size = q.size();\\n            while (size--) { // Process each level of oranges separately\\n                auto [x, y] = q.front(); // Get the coordinates of the current rotten orange\\n                q.pop();\\n                \\n                // Check all four directions for neighboring fresh oranges\\n                for (auto [dx, dy] : dirs) {\\n                    int i = x + dx; // New row coordinate\\n                    int j = y + dy; // New column coordinate\\n                    \\n                    // Check if the new coordinates are within the grid boundaries\\n                    // and if the orange at the new coordinates is fresh\\n                    if (i >= 0 && i < m && j >= 0 && j < n && visited[i][j] == 1) {\\n                        visited[i][j] = 2; // Rot the fresh orange\\n                        countFreshOrange--; // Decrement the count of fresh oranges\\n                        q.push({i, j}); // Add the newly rotten orange to the queue\\n                    }\\n                }\\n            }\\n            minutes++; // Increment the time counter after processing each level\\n        }\\n        \\n        // If there are still fresh oranges left, return -1, as they couldn\\'t be rotten\\n        if (countFreshOrange > 0)\\n            return -1;\\n        \\n        return minutes; // Return the total time taken to rot all oranges\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size(); // Number of rows in the grid\\n        int n = grid[0].size(); // Number of columns in the grid\\n        \\n        // Create a copy of the grid called \"visited\" to track the state of oranges\\n        vector<vector<int>> visited = grid;\\n        \\n        // Create a queue to store the coordinates of rotten oranges\\n        queue<pair<int, int>> q;\\n        \\n        int countFreshOrange = 0; // Count of fresh oranges\\n        \\n        // Iterate through the grid to populate the queue and count fresh oranges\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (visited[i][j] == 2) {\\n                    q.push({i, j}); // Add rotten oranges to the queue\\n                }\\n                if (visited[i][j] == 1) {\\n                    countFreshOrange++; // Count fresh oranges\\n                }\\n            }\\n        }\\n        \\n        // If there are no fresh oranges, return 0 as they are already rotten\\n        if (countFreshOrange == 0)\\n            return 0;\\n        \\n        // If there are no rotten oranges initially, but there are fresh oranges, \\n        // we cannot make them all rotten, so return -1\\n        if (q.empty())\\n            return -1;\\n        \\n        int minutes = -1; // Initialize the time counter\\n        \\n        // Define the four possible directions to move: up, down, left, right\\n        vector<pair<int, int>> dirs = {{1, 0}, {-1, 0}, {0, -1}, {0, 1}};\\n        \\n        // Start the BFS traversal of the grid\\n        while (!q.empty()) {\\n            int size = q.size();\\n            while (size--) { // Process each level of oranges separately\\n                auto [x, y] = q.front(); // Get the coordinates of the current rotten orange\\n                q.pop();\\n                \\n                // Check all four directions for neighboring fresh oranges\\n                for (auto [dx, dy] : dirs) {\\n                    int i = x + dx; // New row coordinate\\n                    int j = y + dy; // New column coordinate\\n                    \\n                    // Check if the new coordinates are within the grid boundaries\\n                    // and if the orange at the new coordinates is fresh\\n                    if (i >= 0 && i < m && j >= 0 && j < n && visited[i][j] == 1) {\\n                        visited[i][j] = 2; // Rot the fresh orange\\n                        countFreshOrange--; // Decrement the count of fresh oranges\\n                        q.push({i, j}); // Add the newly rotten orange to the queue\\n                    }\\n                }\\n            }\\n            minutes++; // Increment the time counter after processing each level\\n        }\\n        \\n        // If there are still fresh oranges left, return -1, as they couldn\\'t be rotten\\n        if (countFreshOrange > 0)\\n            return -1;\\n        \\n        return minutes; // Return the total time taken to rot all oranges\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892319,
                "title": "c-bfs-with-explanation",
                "content": "Time Complexity: O(n * m)\\nSpace Complexity: O(n * m)\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int count_fresh_orange = 0;  // Count of fresh oranges\\n        int ans = 0;  // count time\\n\\n        // Queue to store the positions of rotten oranges\\n        queue<pair<int, int>> q;\\n\\n        // Count fresh oranges and enqueue rotten oranges\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    count_fresh_orange++;  // Count the number of fresh oranges\\n                }\\n                else if (grid[i][j] == 2) {\\n                    q.push({i, j});   // Enqueue rotten orange\\n                }\\n            }\\n        }\\n\\n        int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  // Possible directions for rotting\\n\\n        // Perform BFS\\n        while (!q.empty()) {\\n            int size = q.size();\\n            for (int k = 0; k < size; k++) {   // If there are 2 rotten oranges, they can rot other fresh oranges simultaneously\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                q.pop();\\n\\n                for (int i = 0; i < 4; i++) {\\n                    int xi = x + dir[i][0];\\n                    int yi = y + dir[i][1];\\n                    if (xi >= 0 && xi < n && yi >= 0 && yi < m && grid[xi][yi] == 1) {\\n                        count_fresh_orange--;\\n                        grid[xi][yi] = 2;  // Mark the orange as rotten\\n                        q.push({xi, yi});  // Enqueue the newly rotten orange\\n                    }\\n                }\\n            }\\n            ans++;  // Increment time \\n        }\\n\\n        if (count_fresh_orange > 0) {\\n            return -1;  // Not all oranges can be rotten\\n        }\\n\\n        // Subtract 1 from ans since we started counting from 0\\n        return ans > 0 ? ans - 1 : 0;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/f243e411-0738-4df6-87e0-e07e1ff1b12b_1691699262.5035586.webp)\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int count_fresh_orange = 0;  // Count of fresh oranges\\n        int ans = 0;  // count time\\n\\n        // Queue to store the positions of rotten oranges\\n        queue<pair<int, int>> q;\\n\\n        // Count fresh oranges and enqueue rotten oranges\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    count_fresh_orange++;  // Count the number of fresh oranges\\n                }\\n                else if (grid[i][j] == 2) {\\n                    q.push({i, j});   // Enqueue rotten orange\\n                }\\n            }\\n        }\\n\\n        int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  // Possible directions for rotting\\n\\n        // Perform BFS\\n        while (!q.empty()) {\\n            int size = q.size();\\n            for (int k = 0; k < size; k++) {   // If there are 2 rotten oranges, they can rot other fresh oranges simultaneously\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                q.pop();\\n\\n                for (int i = 0; i < 4; i++) {\\n                    int xi = x + dir[i][0];\\n                    int yi = y + dir[i][1];\\n                    if (xi >= 0 && xi < n && yi >= 0 && yi < m && grid[xi][yi] == 1) {\\n                        count_fresh_orange--;\\n                        grid[xi][yi] = 2;  // Mark the orange as rotten\\n                        q.push({xi, yi});  // Enqueue the newly rotten orange\\n                    }\\n                }\\n            }\\n            ans++;  // Increment time \\n        }\\n\\n        if (count_fresh_orange > 0) {\\n            return -1;  // Not all oranges can be rotten\\n        }\\n\\n        // Subtract 1 from ans since we started counting from 0\\n        return ans > 0 ? ans - 1 : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868827,
                "title": "c-clean-bfs-solution",
                "content": "# BFS\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();    \\n        int time = 0;\\n\\n        // row, col, time\\n        queue<array<int, 3>> Q;\\n\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (grid[r][c] == 2)\\n                    Q.push({r, c, 0});\\n            }\\n        }\\n\\n        int DIR[][2] = { {0, -1}, {1, 0}, {0, 1}, {-1, 0} };\\n\\n        while (!Q.empty()) {\\n            int r = Q.front()[0];\\n            int c = Q.front()[1];\\n            int t = Q.front()[2];\\n            Q.pop();\\n\\n            time = max(time, t);\\n\\n            for (int i = 0; i < 4; i++) {\\n                int nr = r + DIR[i][0], nc = c + DIR[i][1];\\n                if (nr < 0 || nc < 0 || nr == m || nc == n || grid[nr][nc] != 1)\\n                    continue;\\n                grid[nr][nc] = 2; // rotten\\n                Q.push({nr, nc, t + 1});\\n            }\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1)\\n                    return -1;\\n            }\\n        }\\n\\n        return time; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();    \\n        int time = 0;\\n\\n        // row, col, time\\n        queue<array<int, 3>> Q;\\n\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (grid[r][c] == 2)\\n                    Q.push({r, c, 0});\\n            }\\n        }\\n\\n        int DIR[][2] = { {0, -1}, {1, 0}, {0, 1}, {-1, 0} };\\n\\n        while (!Q.empty()) {\\n            int r = Q.front()[0];\\n            int c = Q.front()[1];\\n            int t = Q.front()[2];\\n            Q.pop();\\n\\n            time = max(time, t);\\n\\n            for (int i = 0; i < 4; i++) {\\n                int nr = r + DIR[i][0], nc = c + DIR[i][1];\\n                if (nr < 0 || nc < 0 || nr == m || nc == n || grid[nr][nc] != 1)\\n                    continue;\\n                grid[nr][nc] = 2; // rotten\\n                Q.push({nr, nc, t + 1});\\n            }\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1)\\n                    return -1;\\n            }\\n        }\\n\\n        return time; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783534,
                "title": "100-working-java-bfs-algorithm-solution",
                "content": "# Intuition\\nThere are two common approaches to solve this problem: BFS and DFS. Both algorithms are recursive, but they differ in their traversal strategies.\\n\\nDFS (Depth First Search) visits each node as far as possible before backtracking. It explores the deepest levels of the graph, marking nodes as visited. This approach might take longer because it visits every node before completing the traversal.\\n\\nBFS (Breadth First Search) traverses the graph level by level. It moves horizontally to the next level after completing the current level. In this problem, using BFS is more efficient because it allows us to cover more nodes (rotten more oranges) in less time.\\n\\n# Approach\\nTo implement the BFS approach, we can use a Queue data structure to maintain the order of traversal and keep track of visited vertices. We also create a \"visited\" array to store all the visited nodes or rotten oranges.\\n\\nInitially, we add all the initially rotten oranges to the Queue and mark them as visited in the \"visited\" array.\\n\\nTo determine the neighboring nodes or oranges, we maintain two arrays: \"delRow\" and \"delCol\". By adding the corresponding values from these arrays, we can access the neighboring elements of the current node. This process is explained further in the code.\\n\\nWe remove the first node from the Queue and check its neighboring nodes. If a neighboring node is not visited and is a fresh orange, we rot it and mark it as visited.\\n\\nEvery time we rot neighboring oranges, we increment the time.\\n\\nAfter this process, if any fresh oranges remain, we return -1, indicating that it\\'s impossible to rot all the oranges.\\n\\n\\n# Complexity\\n- Time complexity:\\nN*M + (N*M)*4\\n\\n- Space complexity:\\n O(N*M)\\n\\n\\n# Code\\n```\\nclass Pair{\\n    int row;\\n    int col;\\n    int tm;\\n    public Pair(int row, int col, int tm){\\n        this.row = row;\\n        this.col = col;\\n        this.tm = tm;\\n    }\\n}\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int vis[][] = new int[n][m];\\n        Queue<Pair> q = new LinkedList<>();\\n        int cntFresh = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j] == 2){\\n                    q.add(new Pair(i,j,0));\\n                    vis[i][j] = 2;\\n                }else{\\n                    vis[i][j] = 0;\\n                }\\n                if(grid[i][j] == 1){\\n                    cntFresh++;\\n                }\\n            }\\n        }\\n        int tm = 0;\\n        int count = 0;\\n        int delRow[] = {-1, 0, 1, 0};\\n        int delCol[] = {0, 1, 0, -1};\\n        while(!q.isEmpty()){\\n            int row = q.peek().row;\\n            int col = q.peek().col;\\n            int time = q.peek().tm;\\n            tm = Math.max(tm, time);\\n            q.remove();\\n            for(int i=0; i<4; i++){\\n                int nrow = row + delRow[i];\\n                int ncol = col + delCol[i];\\n                if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m\\n                && vis[nrow][ncol] == 0 && grid[nrow][ncol] == 1){\\n                    q.add(new Pair(nrow,ncol,tm+1));\\n                    vis[nrow][ncol] = 2;\\n                    count++;\\n                }\\n            }\\n        }\\n        if(cntFresh != count) return -1;\\n        return tm;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Pair{\\n    int row;\\n    int col;\\n    int tm;\\n    public Pair(int row, int col, int tm){\\n        this.row = row;\\n        this.col = col;\\n        this.tm = tm;\\n    }\\n}\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int vis[][] = new int[n][m];\\n        Queue<Pair> q = new LinkedList<>();\\n        int cntFresh = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j] == 2){\\n                    q.add(new Pair(i,j,0));\\n                    vis[i][j] = 2;\\n                }else{\\n                    vis[i][j] = 0;\\n                }\\n                if(grid[i][j] == 1){\\n                    cntFresh++;\\n                }\\n            }\\n        }\\n        int tm = 0;\\n        int count = 0;\\n        int delRow[] = {-1, 0, 1, 0};\\n        int delCol[] = {0, 1, 0, -1};\\n        while(!q.isEmpty()){\\n            int row = q.peek().row;\\n            int col = q.peek().col;\\n            int time = q.peek().tm;\\n            tm = Math.max(tm, time);\\n            q.remove();\\n            for(int i=0; i<4; i++){\\n                int nrow = row + delRow[i];\\n                int ncol = col + delCol[i];\\n                if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m\\n                && vis[nrow][ncol] == 0 && grid[nrow][ncol] == 1){\\n                    q.add(new Pair(nrow,ncol,tm+1));\\n                    vis[nrow][ncol] = 2;\\n                    count++;\\n                }\\n            }\\n        }\\n        if(cntFresh != count) return -1;\\n        return tm;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731200,
                "title": "easy-to-understand-java-rotten-oranges-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n## Why i used BFS here?\\n```\\nA rotten orange can rot fresh orange neighbours that are at a distance of 1 or at the same level. It means each of them got rotten at a similar level or stage, implying we need to visit the same level at the same time. Hence, level-wise traversal is BFS traversal.\\nIf we use DFS traversal then all neighbouring fresh oranges will be visited depth-wise. But here it is not the case to rot all the oranges, we need to find the minimum time to rot them all, which is possible only when we are in neighbouring directions at an equal pace. We want to rotten them simultaneously.\\n\\nSo, BFS traversal will be used to solve this problem.\\n``` \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First i will make a queue storing row, col, time.\\n2. Make a visited array of same length as grid\\n3. traverse in the grid and add all possible rotten oranges in the queue and mark them 2 in visited array and simultaneously count number of frease oranges also.\\n4. delRow & delCol are possible 4 directions index\\n5. loop in the queue utill it will empty and assign row, col, time and add neighbors to the queue and mark them visited in visited array.\\n6. Return answer.\\n\\n# Complexity\\n- Time complexity: $$O(N*M*4)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N*M)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair{\\n    int r;\\n    int c;\\n    int t;\\n    Pair(int r, int c, int t){\\n        this.r = r;\\n        this.c = c;\\n        this.t = t;\\n    }\\n}\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int ans_time = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        int[][] visited = new int[n][m]; // to mark roten oranges\\n        int cntFreash = 0; // Counting Freash orange\\n\\n        // travers in grid to find out possible position of rotten orange and also count freash oranges\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == 2){\\n                    q.add(new Pair(i,j,0));\\n                    visited[i][j] = 2;\\n                }else if(grid[i][j] == 1){\\n                    cntFreash++;\\n                }else{\\n                    visited[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        int[] delRow = {-1, 0, +1, 0};\\n        int[] delCol = {0, +1, 0, -1};\\n        int cnt = 0; // keep track of rotten orange\\n        // BFS Traversal\\n        while(!q.isEmpty()){\\n            int row = q.peek().r;\\n            int col = q.peek().c;\\n            int time = q.peek().t;\\n            ans_time = Math.max(ans_time, time);\\n            q.remove();\\n            // now i have to check for neighbours in four directions\\n            for(int i = 0; i < 4; i++){\\n                int nrow = row + delRow[i];\\n                int ncol = col + delCol[i];\\n\\n                if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m && visited[nrow][ncol] == 0 && \\n                grid[nrow][ncol] == 1){\\n                    q.add(new Pair(nrow, ncol, time + 1));\\n                    visited[nrow][ncol] = 2;\\n                    cnt++;\\n                }   \\n            }\\n        }\\n        \\n        if(cnt != cntFreash) return -1;\\n        return ans_time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nA rotten orange can rot fresh orange neighbours that are at a distance of 1 or at the same level. It means each of them got rotten at a similar level or stage, implying we need to visit the same level at the same time. Hence, level-wise traversal is BFS traversal.\\nIf we use DFS traversal then all neighbouring fresh oranges will be visited depth-wise. But here it is not the case to rot all the oranges, we need to find the minimum time to rot them all, which is possible only when we are in neighbouring directions at an equal pace. We want to rotten them simultaneously.\\n\\nSo, BFS traversal will be used to solve this problem.\\n```\n```\\nclass Pair{\\n    int r;\\n    int c;\\n    int t;\\n    Pair(int r, int c, int t){\\n        this.r = r;\\n        this.c = c;\\n        this.t = t;\\n    }\\n}\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int ans_time = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        int[][] visited = new int[n][m]; // to mark roten oranges\\n        int cntFreash = 0; // Counting Freash orange\\n\\n        // travers in grid to find out possible position of rotten orange and also count freash oranges\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == 2){\\n                    q.add(new Pair(i,j,0));\\n                    visited[i][j] = 2;\\n                }else if(grid[i][j] == 1){\\n                    cntFreash++;\\n                }else{\\n                    visited[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        int[] delRow = {-1, 0, +1, 0};\\n        int[] delCol = {0, +1, 0, -1};\\n        int cnt = 0; // keep track of rotten orange\\n        // BFS Traversal\\n        while(!q.isEmpty()){\\n            int row = q.peek().r;\\n            int col = q.peek().c;\\n            int time = q.peek().t;\\n            ans_time = Math.max(ans_time, time);\\n            q.remove();\\n            // now i have to check for neighbours in four directions\\n            for(int i = 0; i < 4; i++){\\n                int nrow = row + delRow[i];\\n                int ncol = col + delCol[i];\\n\\n                if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m && visited[nrow][ncol] == 0 && \\n                grid[nrow][ncol] == 1){\\n                    q.add(new Pair(nrow, ncol, time + 1));\\n                    visited[nrow][ncol] = 2;\\n                    cnt++;\\n                }   \\n            }\\n        }\\n        \\n        if(cnt != cntFreash) return -1;\\n        return ans_time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703665,
                "title": "easy-to-understand-c-using-two-stacks-queue-alternative-bfs",
                "content": "**Approach**\\nIn this approach, i have used 2 stacks s1 and s2 to implement the solution. Stack s1 stores the oraanges to be rotten. Then, those oranges are transferred to stack s2 which calls the solve function to rot any neighbouring oranges if there.\\nFirstly, the grid is iterated over to find if there any rotten oranges using ```if(grid[i][j]==2)``` and if present, they are pushed to stack s1. Now, we check for the base case when all the cells are empty using ```if(s1.empty() and !ones)``` and if true return 0. Then until s1 is not empty, we increment minutes, and empty s1 by marking those oranges as rotten and push them to s2.\\n(Why empty s1? Because when we call solve function from the contents of s2, the neighbouring fresh oranges will be pushed into s1. So, we need to make sure s1 is empty so that the next top element from s1 would be an orange that got rotten in the next minute only.)\\nNow, we emtpy s2 by calling solve function to push into s1 the neighbouring oranges that are fresh but will get rotten in the next minute due to the parent rotten orange.\\nWhen s1 is finally empty, it is because no other oranges could get rotten anymore. Which gives way to 2 cases -\\n1. All oranges got rotten.\\n2. There are some oranges which didn\\'t get rotten.\\n\\nSo, we check for the later case by iterating through grid to find a fresh orange using ```if(grid[i][j]==1)``` and if true, we return -1 meaning all oranges couldn\\'t get rotten. If false, we return ```minutes-1``` as minutes gets incremented once even after all oranges gor rotten for the final iteration when s1 is empty after all the solve function calls from elements in s2.\\n\\n\\n**Code**\\n\\n```\\nclass Solution {\\npublic:\\n    stack<pair<int,int>> s1,s2;\\n    \\n    bool valid(int i,int j,vector<vector<int>>& grid){\\n        if(i<0 or j<0 or i>=grid.size() or j>=grid[0].size() or grid[i][j]==0)return false;\\n        return true;\\n    }\\n    void solve(int i,int j,vector<vector<int>>& grid){\\n        \\n        if(valid(i+1,j,grid) and grid[i+1][j]==1)\\n            s1.push({i+1,j});\\n        if(valid(i-1,j,grid) and grid[i-1][j]==1)\\n            s1.push({i-1,j});\\n        if(valid(i,j-1,grid) and grid[i][j-1]==1)\\n            s1.push({i,j-1});\\n        if(valid(i,j+1,grid) and grid[i][j+1]==1)\\n            s1.push({i,j+1});\\n    }\\n    \\n    int orangesRotting(vector<vector<int>>& grid) {\\n        bool ones=false;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==2)\\n                    s1.push({i,j});\\n                if(grid[i][j]==1)\\n                    ones=true;\\n            }\\n        }\\n        if(s1.empty() and !ones)return 0;\\n        int minutes=0;\\n        \\n        while(!s1.empty()){\\n            minutes++;\\n            \\n            while(!s1.empty()){\\n                grid[s1.top().first][s1.top().second]=2;\\n                s2.push(s1.top());\\n                s1.pop();\\n            }\\n            \\n            while(!s2.empty()){\\n                solve(s2.top().first,s2.top().second,grid);\\n                s2.pop();\\n            }\\n        }\\n        \\n         for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1)\\n                    return -1;\\n            }\\n        }\\n        \\n        return minutes-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack",
                    "Breadth-First Search"
                ],
                "code": "```if(grid[i][j]==2)```\n```if(s1.empty() and !ones)```\n```if(grid[i][j]==1)```\n```minutes-1```\n```\\nclass Solution {\\npublic:\\n    stack<pair<int,int>> s1,s2;\\n    \\n    bool valid(int i,int j,vector<vector<int>>& grid){\\n        if(i<0 or j<0 or i>=grid.size() or j>=grid[0].size() or grid[i][j]==0)return false;\\n        return true;\\n    }\\n    void solve(int i,int j,vector<vector<int>>& grid){\\n        \\n        if(valid(i+1,j,grid) and grid[i+1][j]==1)\\n            s1.push({i+1,j});\\n        if(valid(i-1,j,grid) and grid[i-1][j]==1)\\n            s1.push({i-1,j});\\n        if(valid(i,j-1,grid) and grid[i][j-1]==1)\\n            s1.push({i,j-1});\\n        if(valid(i,j+1,grid) and grid[i][j+1]==1)\\n            s1.push({i,j+1});\\n    }\\n    \\n    int orangesRotting(vector<vector<int>>& grid) {\\n        bool ones=false;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==2)\\n                    s1.push({i,j});\\n                if(grid[i][j]==1)\\n                    ones=true;\\n            }\\n        }\\n        if(s1.empty() and !ones)return 0;\\n        int minutes=0;\\n        \\n        while(!s1.empty()){\\n            minutes++;\\n            \\n            while(!s1.empty()){\\n                grid[s1.top().first][s1.top().second]=2;\\n                s2.push(s1.top());\\n                s1.pop();\\n            }\\n            \\n            while(!s2.empty()){\\n                solve(s2.top().first,s2.top().second,grid);\\n                s2.pop();\\n            }\\n        }\\n        \\n         for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1)\\n                    return -1;\\n            }\\n        }\\n        \\n        return minutes-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679126,
                "title": "c-simple-straight-forward-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        queue<pair<pair<int,int>,int>> q;\\n        vector<vector<int>> vis(n,vector<int> (m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==2){\\n                    q.push({{i,j},0});\\n                    vis[i][j] = 2;\\n                }\\n            }\\n        }\\n        int tm = 0;\\n        int drow[] = {-1,0,1,0};\\n        int dcol[] = {0,1,0,-1};\\n        while(!q.empty()){\\n            int r = q.front().first.first;\\n            int c = q.front().first.second;\\n            int t = q.front().second;\\n            q.pop();\\n            tm = max(tm,t);\\n            for(int i=0;i<4;i++){\\n                int nrow = r + drow[i];\\n                int ncol = c + dcol[i];\\n                if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && vis[nrow][ncol]!=2\\n                      && grid[nrow][ncol] == 1)\\n                {\\n                    q.push({{nrow,ncol},t+1});\\n                    vis[nrow][ncol] = 2;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1 && vis[i][j] != 2) return -1;\\n            }\\n        }\\n        return tm;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/39451a8b-4887-46f6-9b8f-b994e2e40253_1687453528.6643982.jpeg)\\n\\n**please upvote!! if you like.**\\ncomment below\\uD83D\\uDC47",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        queue<pair<pair<int,int>,int>> q;\\n        vector<vector<int>> vis(n,vector<int> (m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==2){\\n                    q.push({{i,j},0});\\n                    vis[i][j] = 2;\\n                }\\n            }\\n        }\\n        int tm = 0;\\n        int drow[] = {-1,0,1,0};\\n        int dcol[] = {0,1,0,-1};\\n        while(!q.empty()){\\n            int r = q.front().first.first;\\n            int c = q.front().first.second;\\n            int t = q.front().second;\\n            q.pop();\\n            tm = max(tm,t);\\n            for(int i=0;i<4;i++){\\n                int nrow = r + drow[i];\\n                int ncol = c + dcol[i];\\n                if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && vis[nrow][ncol]!=2\\n                      && grid[nrow][ncol] == 1)\\n                {\\n                    q.push({{nrow,ncol},t+1});\\n                    vis[nrow][ncol] = 2;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1 && vis[i][j] != 2) return -1;\\n            }\\n        }\\n        return tm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490056,
                "title": "c-code-begginer-friendly-100-best",
                "content": "# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\nprivate:\\n    int bfs(queue<pair<int, int>> que, vector<vector<int>> &grid, int r[], int c[]){\\n        int time = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        while(!que.empty()){\\n            int size = que.size();\\n            bool isRotten = false;  // if rotten oranges can\\'t rotten any oranges\\n\\n            for(int i=0; i<size; i++){\\n                int row = que.front().first;\\n                int col = que.front().second;\\n\\n                que.pop();\\n\\n                for(int i=0; i<4; i++){\\n                    int nr = row + r[i];\\n                    int nc = col + c[i];\\n\\n                    if(nr>=0 && nr<n && nc>=0 && nc<m && grid[nr][nc] == 1){\\n                        isRotten = true;\\n                        grid[nr][nc] = 2;\\n                        que.push({nr,nc});\\n                    } \\n                }\\n            }\\n\\n            if(isRotten) time++;\\n        }\\n\\n        return time;\\n    }\\n\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        queue<pair<int, int>> que;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        // checking the rotten oranges in the grid the pushing it to que\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j] == 2){\\n                    que.push({i,j});\\n                }\\n            }\\n        }\\n\\n        int r[4] = {-1, 1, 0, 0};\\n        int c[4] = {0, 0, -1, 1}; \\n\\n        int rottenTime = bfs(que, grid, r, c);\\n\\n        // checking if any not rotten oranges left, if yes then returning -1\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j] == 1) return -1;\\n            }\\n        }\\n\\n        return rottenTime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n\\nprivate:\\n    int bfs(queue<pair<int, int>> que, vector<vector<int>> &grid, int r[], int c[]){\\n        int time = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        while(!que.empty()){\\n            int size = que.size();\\n            bool isRotten = false;  // if rotten oranges can\\'t rotten any oranges\\n\\n            for(int i=0; i<size; i++){\\n                int row = que.front().first;\\n                int col = que.front().second;\\n\\n                que.pop();\\n\\n                for(int i=0; i<4; i++){\\n                    int nr = row + r[i];\\n                    int nc = col + c[i];\\n\\n                    if(nr>=0 && nr<n && nc>=0 && nc<m && grid[nr][nc] == 1){\\n                        isRotten = true;\\n                        grid[nr][nc] = 2;\\n                        que.push({nr,nc});\\n                    } \\n                }\\n            }\\n\\n            if(isRotten) time++;\\n        }\\n\\n        return time;\\n    }\\n\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        queue<pair<int, int>> que;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        // checking the rotten oranges in the grid the pushing it to que\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j] == 2){\\n                    que.push({i,j});\\n                }\\n            }\\n        }\\n\\n        int r[4] = {-1, 1, 0, 0};\\n        int c[4] = {0, 0, -1, 1}; \\n\\n        int rottenTime = bfs(que, grid, r, c);\\n\\n        // checking if any not rotten oranges left, if yes then returning -1\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j] == 1) return -1;\\n            }\\n        }\\n\\n        return rottenTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375216,
                "title": "well-commented-c-code-using-bfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int vis[n][m];\\n        // queue will store coordinates and corresponding time\\n        queue<pair<pair<int, int>, int>> q;\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == 2){\\n                    // initial vertices will be the rotten ones\\n                    q.push({{i,j}, 0});\\n                    vis[i][j] = 2;\\n                }\\n            }\\n        }\\n\\n        // initializing directions for bfs traversal\\n        int dx[] = {-1,0,1,0};\\n        int dy[] = {0,-1,0,1};\\n        int time = 0;\\n\\n        while(!q.empty())\\n        {\\n            int r = q.front().first.first, c = q.front().first.second, t = q.front().second;\\n            time = max(time, t);\\n            q.pop();\\n            for(int i = 0; i < 4; i++){\\n                int nrow = r + dx[i], ncol = c + dy[i];\\n                // if all conditions satisfy then push the neighbouring row, col into the queue\\n                // while also updating the time and vis\\n                if (nrow >= 0 && ncol >= 0 && nrow < n && ncol < m && vis[nrow][ncol] != 2 && grid[nrow][ncol] == 1)\\n                {\\n                    q.push({{nrow, ncol}, t + 1});\\n                    vis[nrow][ncol] = 2;\\n                }\\n            }\\n        }\\n\\n        // in the end check for the -1 case\\n        // this happens when for any (i,j) vis != 2 and the grid val = 1\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(vis[i][j] != 2 && grid[i][j] == 1){\\n                    return -1;\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int vis[n][m];\\n        // queue will store coordinates and corresponding time\\n        queue<pair<pair<int, int>, int>> q;\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == 2){\\n                    // initial vertices will be the rotten ones\\n                    q.push({{i,j}, 0});\\n                    vis[i][j] = 2;\\n                }\\n            }\\n        }\\n\\n        // initializing directions for bfs traversal\\n        int dx[] = {-1,0,1,0};\\n        int dy[] = {0,-1,0,1};\\n        int time = 0;\\n\\n        while(!q.empty())\\n        {\\n            int r = q.front().first.first, c = q.front().first.second, t = q.front().second;\\n            time = max(time, t);\\n            q.pop();\\n            for(int i = 0; i < 4; i++){\\n                int nrow = r + dx[i], ncol = c + dy[i];\\n                // if all conditions satisfy then push the neighbouring row, col into the queue\\n                // while also updating the time and vis\\n                if (nrow >= 0 && ncol >= 0 && nrow < n && ncol < m && vis[nrow][ncol] != 2 && grid[nrow][ncol] == 1)\\n                {\\n                    q.push({{nrow, ncol}, t + 1});\\n                    vis[nrow][ncol] = 2;\\n                }\\n            }\\n        }\\n\\n        // in the end check for the -1 case\\n        // this happens when for any (i,j) vis != 2 and the grid val = 1\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(vis[i][j] != 2 && grid[i][j] == 1){\\n                    return -1;\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354232,
                "title": "c-easy-and-understanding-solution-with-bfs",
                "content": "# Complexity\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(n*m)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int OrangesRotting(int[][] grid) {\\n        Queue<IList<int>> rottenOranges = new Queue<IList<int>>();\\n        int time = 0, freshOranges = 0;\\n\\n        int rows = grid.Length, cols = grid[0].Length;\\n        for(int row = 0; row < rows; row++) {\\n            for(int col = 0; col < cols; col++) {\\n                if(grid[row][col] == 1) freshOranges++;\\n                else if(grid[row][col] == 2) rottenOranges.Enqueue(new List<int> { row, col });\\n            }\\n        }\\n\\n        var directions = new List<IList<int>> {\\n            new List<int> { 1, 0 },\\n            new List<int> { -1, 0 },\\n            new List<int> { 0, 1 },\\n            new List<int> { 0, -1 }\\n        };\\n        while(rottenOranges.Count > 0 && freshOranges > 0) {\\n            int size = rottenOranges.Count;\\n\\n            for(int ind = 0; ind < size; ind++) {\\n                var inds = rottenOranges.Dequeue();\\n                int row = inds[0];\\n                int col = inds[1];\\n\\n                foreach(var dir in directions) {\\n                    int rowInd = row + dir[0];\\n                    int colInd = col + dir[1];\\n\\n                    if(rowInd < 0 || rowInd >= rows ||\\n                       colInd < 0 || colInd >= cols ||\\n                       grid[rowInd][colInd] != 1) continue;\\n\\n                    grid[rowInd][colInd] = 2;\\n                    rottenOranges.Enqueue(new List<int> { rowInd, colInd });\\n                    freshOranges--;\\n                }\\n            }\\n\\n            time++;\\n        }\\n\\n        return freshOranges == 0 ? time : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int OrangesRotting(int[][] grid) {\\n        Queue<IList<int>> rottenOranges = new Queue<IList<int>>();\\n        int time = 0, freshOranges = 0;\\n\\n        int rows = grid.Length, cols = grid[0].Length;\\n        for(int row = 0; row < rows; row++) {\\n            for(int col = 0; col < cols; col++) {\\n                if(grid[row][col] == 1) freshOranges++;\\n                else if(grid[row][col] == 2) rottenOranges.Enqueue(new List<int> { row, col });\\n            }\\n        }\\n\\n        var directions = new List<IList<int>> {\\n            new List<int> { 1, 0 },\\n            new List<int> { -1, 0 },\\n            new List<int> { 0, 1 },\\n            new List<int> { 0, -1 }\\n        };\\n        while(rottenOranges.Count > 0 && freshOranges > 0) {\\n            int size = rottenOranges.Count;\\n\\n            for(int ind = 0; ind < size; ind++) {\\n                var inds = rottenOranges.Dequeue();\\n                int row = inds[0];\\n                int col = inds[1];\\n\\n                foreach(var dir in directions) {\\n                    int rowInd = row + dir[0];\\n                    int colInd = col + dir[1];\\n\\n                    if(rowInd < 0 || rowInd >= rows ||\\n                       colInd < 0 || colInd >= cols ||\\n                       grid[rowInd][colInd] != 1) continue;\\n\\n                    grid[rowInd][colInd] = 2;\\n                    rottenOranges.Enqueue(new List<int> { rowInd, colInd });\\n                    freshOranges--;\\n                }\\n            }\\n\\n            time++;\\n        }\\n\\n        return freshOranges == 0 ? time : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196790,
                "title": "c-using-bfs-beats-100-t-c-o-n-2-s-c-o-n-2",
                "content": "```\\nclass Solution {\\n\\t/*\\n\\t\\tTime Complexity : O(N^2)\\n\\t\\tSpace Complexity : O(N^2)\\n\\t*/\\n    \\n\\tint m, n;\\n    \\n    bool isValid(int i, int j){\\n        if(i>=0 && i<m && j>=0 && j<n) return true;\\n        return false;\\n    }\\n    \\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size();\\n        int freshOranges = 0;\\n        queue<pair<int, int>> q1;\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1){\\n                    freshOranges++;\\n                }else if(grid[i][j] == 2){\\n                    q1.push({i, j});\\n                }\\n            }\\n        }\\n        \\n        if(freshOranges == 0) return 0;\\n        \\n        vector<int> x = {+1, -1, 0, 0};\\n        vector<int> y = {0, 0, +1, -1};\\n        \\n        int time = 0;\\n        \\n        while(!q1.empty()){\\n            int size = q1.size();\\n            \\n            while(size--){\\n                pair<int, int> curr = q1.front();\\n                q1.pop();\\n                \\n                for(int k=0; k<4; k++){\\n                    int newX = curr.first + x[k];\\n                    int newY = curr.second + y[k];\\n                    \\n                    if(isValid(newX, newY) && grid[newX][newY] == 1){\\n                        grid[newX][newY] = 2;\\n                        q1.push({newX, newY});\\n                        freshOranges--;\\n                    }\\n                }\\n            }\\n            \\n            time++;\\n        }\\n        \\n        if(freshOranges > 0) return -1;\\n        return --time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\t/*\\n\\t\\tTime Complexity : O(N^2)\\n\\t\\tSpace Complexity : O(N^2)\\n\\t*/\\n    \\n\\tint m, n;\\n    \\n    bool isValid(int i, int j){\\n        if(i>=0 && i<m && j>=0 && j<n) return true;\\n        return false;\\n    }\\n    \\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size();\\n        int freshOranges = 0;\\n        queue<pair<int, int>> q1;\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1){\\n                    freshOranges++;\\n                }else if(grid[i][j] == 2){\\n                    q1.push({i, j});\\n                }\\n            }\\n        }\\n        \\n        if(freshOranges == 0) return 0;\\n        \\n        vector<int> x = {+1, -1, 0, 0};\\n        vector<int> y = {0, 0, +1, -1};\\n        \\n        int time = 0;\\n        \\n        while(!q1.empty()){\\n            int size = q1.size();\\n            \\n            while(size--){\\n                pair<int, int> curr = q1.front();\\n                q1.pop();\\n                \\n                for(int k=0; k<4; k++){\\n                    int newX = curr.first + x[k];\\n                    int newY = curr.second + y[k];\\n                    \\n                    if(isValid(newX, newY) && grid[newX][newY] == 1){\\n                        grid[newX][newY] = 2;\\n                        q1.push({newX, newY});\\n                        freshOranges--;\\n                    }\\n                }\\n            }\\n            \\n            time++;\\n        }\\n        \\n        if(freshOranges > 0) return -1;\\n        return --time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158808,
                "title": "c-easytounderstand-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeep (coordinates,time) in queue and do BFS \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncollect all rotten apples first with time=0 in queue and change them to taken bt changing their grid[i][j] to 0(suppose)\\n\\nnow start performing BFS by pushing all 4 direction apples which are not rotten and mark them taken by changing their grid[i][j] to 0(suppose)\\n\\nfind maximum value of time and return it\\n# Complexity\\n- Time complexity:O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(mn) (queue)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid){\\n        int ans=0;\\n\\n        queue<vector<int>> q;\\n        int m=grid.size(), n=grid[0].size();\\n        \\n        bool all0=true;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]!=0) all0=false;\\n                if(grid[i][j]==2){\\n                    q.push({i,j,0});\\n                    grid[i][j]=0;\\n                }\\n            }\\n        }\\n        if(all0) return 0;\\n        if(q.empty()) return -1;\\n     \\n        while(!q.empty()){\\n            auto v=q.front();\\n            int i=v[0], j=v[1];\\n\\n            if(i+1<m && grid[i+1][j]==1){\\n                q.push({i+1,j,v[2]+1});\\n                grid[i+1][j]=0;\\n            }\\n            if(i-1>=0 && grid[i-1][j]==1){\\n                q.push({i-1,j,v[2]+1});\\n                grid[i-1][j]=0;\\n            }\\n            if(j+1<n && grid[i][j+1]==1){\\n                q.push({i,j+1,v[2]+1});\\n                grid[i][j+1]=0;\\n            }\\n            if(j-1>=0 && grid[i][j-1]==1){\\n                q.push({i,j-1,v[2]+1});\\n                grid[i][j-1]=0;\\n            }\\n            ans=max(ans,v[2]);\\n            q.pop(); \\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1) return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid){\\n        int ans=0;\\n\\n        queue<vector<int>> q;\\n        int m=grid.size(), n=grid[0].size();\\n        \\n        bool all0=true;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]!=0) all0=false;\\n                if(grid[i][j]==2){\\n                    q.push({i,j,0});\\n                    grid[i][j]=0;\\n                }\\n            }\\n        }\\n        if(all0) return 0;\\n        if(q.empty()) return -1;\\n     \\n        while(!q.empty()){\\n            auto v=q.front();\\n            int i=v[0], j=v[1];\\n\\n            if(i+1<m && grid[i+1][j]==1){\\n                q.push({i+1,j,v[2]+1});\\n                grid[i+1][j]=0;\\n            }\\n            if(i-1>=0 && grid[i-1][j]==1){\\n                q.push({i-1,j,v[2]+1});\\n                grid[i-1][j]=0;\\n            }\\n            if(j+1<n && grid[i][j+1]==1){\\n                q.push({i,j+1,v[2]+1});\\n                grid[i][j+1]=0;\\n            }\\n            if(j-1>=0 && grid[i][j-1]==1){\\n                q.push({i,j-1,v[2]+1});\\n                grid[i][j-1]=0;\\n            }\\n            ans=max(ans,v[2]);\\n            q.pop(); \\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1) return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073064,
                "title": "c-solution-using-bfs-graphs",
                "content": "\\n\\t\\n\\tint orangesRotting(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size(),m=grid[0].size();\\n       \\n        queue<pair<pair<int,int>,int>>q; \\n        \\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        \\n        for (int i = 0; i < n; i++) \\n        {\\n            for (int j = 0; j < m; j++) \\n            {\\n                if (grid[i][j] == 2) \\n                {\\n                    q.push({{i, j}, 0}); \\n                    vis[i][j] = 2;\\n                }\\n                else \\n                    vis[i][j] = 0;\\n            }\\n        }\\n        \\n        vector<vector<int>>d={{-1,0},{0,-1},{1,0},{0,1}};\\n        int time=0;\\n        \\n        while (!q.empty())\\n        {\\n            int r = q.front().first.first;\\n            int c = q.front().first.second;\\n            int t = q.front().second;\\n            q.pop();\\n            \\n            time=max(time,t);\\n            \\n            for(int i=0;i<4;i++)\\n            {\\n                int nr=r+d[i][0];\\n                int nc=c+d[i][1];\\n                \\n                        if(nr<n && nc<m && nr>=0 && nc>=0 && grid[nr][nc]==1 &&vis[nr][nc]!=2)\\n                {\\n                    q.push({{nr,nc},t+1});\\n                    vis[nr][nc]=2;\\n                }\\n                    \\n            }   \\n        }\\n        \\n        \\n        for (int i = 0; i < n; i++) \\n        {\\n            for (int j = 0; j < m; j++) \\n            {\\n                if(vis[i][j]!=2 && grid[i][j]==1)\\n                    return -1;\\n            }\\n        }\\n        return time;    \\n    }\\n\\t\\n# \\tPlease Upvote if you find it helpful",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "\\n\\t\\n\\tint orangesRotting(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size(),m=grid[0].size();\\n       \\n        queue<pair<pair<int,int>,int>>q; \\n        \\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        \\n        for (int i = 0; i < n; i++) \\n        {\\n            for (int j = 0; j < m; j++) \\n            {\\n                if (grid[i][j] == 2) \\n                {\\n                    q.push({{i, j}, 0}); \\n                    vis[i][j] = 2;\\n                }\\n                else \\n                    vis[i][j] = 0;\\n            }\\n        }\\n        \\n        vector<vector<int>>d={{-1,0},{0,-1},{1,0},{0,1}};\\n        int time=0;\\n        \\n        while (!q.empty())\\n        {\\n            int r = q.front().first.first;\\n            int c = q.front().first.second;\\n            int t = q.front().second;\\n            q.pop();\\n            \\n            time=max(time,t);\\n            \\n            for(int i=0;i<4;i++)\\n            {\\n                int nr=r+d[i][0];\\n                int nc=c+d[i][1];\\n                \\n                        if(nr<n && nc<m && nr>=0 && nc>=0 && grid[nr][nc]==1 &&vis[nr][nc]!=2)\\n                {\\n                    q.push({{nr,nc},t+1});\\n                    vis[nr][nc]=2;\\n                }\\n                    \\n            }   \\n        }\\n        \\n        \\n        for (int i = 0; i < n; i++) \\n        {\\n            for (int j = 0; j < m; j++) \\n            {\\n                if(vis[i][j]!=2 && grid[i][j]==1)\\n                    return -1;\\n            }\\n        }\\n        return time;    \\n    }\\n\\t\\n# \\tPlease Upvote if you find it helpful",
                "codeTag": "Unknown"
            },
            {
                "id": 2963373,
                "title": "c-easy-bfs-graph-traversal-clean-easy-code",
                "content": "![image](https://assets.leetcode.com/users/images/0cd3b45b-05cd-4555-95a5-77cd3f8ea552_1672237797.2517793.png)\\n\\n**T->O(4 X nm) ~ O(nm) && S->O(nm)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<pair<int,int>> dir={{-1,0},{1,0},{0,1},{0,-1}};\\n\\t\\t\\tint orangesRotting(vector<vector<int>>& grid) {\\n\\t\\t\\t\\tint n=grid.size();\\n\\t\\t\\t\\tint m=grid[0].size();\\n\\t\\t\\t\\tvector<vector<int>> vis(n,vector<int>(m,0));\\n\\t\\t//      {{r,c},t}\\n\\t\\t\\t\\tqueue<pair<pair<int,int>,int>>q;\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tfor(int j=0;j<m;j++){\\n\\t\\t\\t\\t\\t\\tif(grid[i][j]==2){\\n\\t\\t\\t\\t\\t\\t\\tq.push({{i,j},0});\\n\\t\\t\\t\\t\\t\\t\\tvis[i][j]=2;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint time=0;\\n\\t\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\t\\tauto node=q.front();\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\tint t=node.second;\\n\\t\\t\\t\\t\\ttime=max(time,t);\\n\\t\\t\\t\\t\\tfor(auto d:dir){\\n\\t\\t\\t\\t\\t\\tint new_r=node.first.first+d.first;\\n\\t\\t\\t\\t\\t\\tint new_c=node.first.second+d.second;\\n\\t\\t\\t\\t\\t\\tif(new_r<n && new_r>=0 && new_c<m && new_c>=0 && vis[new_r][new_c]!=2 && grid[new_r][new_c]==1){\\n\\t\\t\\t\\t\\t\\t\\tq.push({{new_r,new_c},t+1});\\n\\t\\t\\t\\t\\t\\t\\tvis[new_r][new_c]=2;\\n\\t\\t\\t\\t\\t\\t}    \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tfor(int j=0;j<m;j++){\\n\\t\\t\\t\\t\\t\\tif(grid[i][j]==1 && vis[i][j]!=2) return -1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn time;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<pair<int,int>> dir={{-1,0}",
                "codeTag": "Java"
            },
            {
                "id": 2893338,
                "title": "c-solution-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int orangesRotting(vector<vector<int>>& grid) {\\n        \\n        queue<pair<int,int>> q;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==2){ // push all rotten oranges\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n        \\n        int time=0;\\n        vector<pair<int,int>> validmove={{1,0},{-1,0},{0,-1},{0,1}};\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            bool is_any_rotten=false;\\n            for(int i=0;i<size;i++){\\n\\n                auto p=q.front();\\n                q.pop();\\n                int x1=p.first;\\n                int y1=p.second;\\n\\n                for(int k=0;k<4;k++){\\n                    int x=x1+validmove[k].first;\\n                    int y=y1+validmove[k].second;\\n                    if(x<0 || x>=m || y<0 || y>=n || grid[x][y]!=1){\\n                        continue;\\n                    }\\n                \\n                    is_any_rotten=true;\\n                    grid[x][y]=2;\\n                    q.push({x,y});\\n                }\\n                \\n            }\\n            if(is_any_rotten)\\n                time++;\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){ // checking is any fresh oraneg reamin\\n                   return -1;\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int orangesRotting(vector<vector<int>>& grid) {\\n        \\n        queue<pair<int,int>> q;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==2){ // push all rotten oranges\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n        \\n        int time=0;\\n        vector<pair<int,int>> validmove={{1,0},{-1,0},{0,-1},{0,1}};\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            bool is_any_rotten=false;\\n            for(int i=0;i<size;i++){\\n\\n                auto p=q.front();\\n                q.pop();\\n                int x1=p.first;\\n                int y1=p.second;\\n\\n                for(int k=0;k<4;k++){\\n                    int x=x1+validmove[k].first;\\n                    int y=y1+validmove[k].second;\\n                    if(x<0 || x>=m || y<0 || y>=n || grid[x][y]!=1){\\n                        continue;\\n                    }\\n                \\n                    is_any_rotten=true;\\n                    grid[x][y]=2;\\n                    q.push({x,y});\\n                }\\n                \\n            }\\n            if(is_any_rotten)\\n                time++;\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){ // checking is any fresh oraneg reamin\\n                   return -1;\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881317,
                "title": "c-bfs-easy-intuitive-solution",
                "content": "**INTUITION**\\n\\n\\u2705Firstly we create a queue which store the indices of the rotten oranges.\\n\\u2705Then for each entry in queue if any fresh orange is present we mark it as rotten. And push it in our queue\\n\\u2705Then the number of times it runs is the number of elapses it take to make all fresh oranges to rotten. \\n\\u2705If queue becomes empty and our fresh oranges remained in the grid then we return -1 as it is impossible to make those fresh oranges to rotten\\n\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        \\n        int fresh=0,time_elapse=0;\\n        vector<int>offset={0,1,0,-1,0}; /// for traversing up down left right in grid\\n        queue<pair<int,int>>q;\\n        \\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1)fresh++;\\n                else if(grid[i][j]==2)q.push({i,j});\\n            }\\n        }\\n        \\n        while(q.size() && fresh){\\n            time_elapse++;\\n            int n=q.size();\\n            \\n            for(int i=0;i<n;i++){\\n                \\n                auto [r,c]=q.front();q.pop();\\n                \\n                for(int j=0;j<4;j++){\\n                    int nr=r+offset[j],nc=c+offset[j+1];\\n                    if(nr<0 || nc<0 || nr>=grid.size() || nc>=grid[0].size() || grid[nr][nc]!=1)continue;\\n                    fresh--;\\n                    grid[nr][nc]=2;\\n                    q.push({nr,nc});\\n                }\\n                \\n            }\\n            \\n        }\\n        return fresh?-1:time_elapse;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        \\n        int fresh=0,time_elapse=0;\\n        vector<int>offset={0,1,0,-1,0}; /// for traversing up down left right in grid\\n        queue<pair<int,int>>q;\\n        \\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1)fresh++;\\n                else if(grid[i][j]==2)q.push({i,j});\\n            }\\n        }\\n        \\n        while(q.size() && fresh){\\n            time_elapse++;\\n            int n=q.size();\\n            \\n            for(int i=0;i<n;i++){\\n                \\n                auto [r,c]=q.front();q.pop();\\n                \\n                for(int j=0;j<4;j++){\\n                    int nr=r+offset[j],nc=c+offset[j+1];\\n                    if(nr<0 || nc<0 || nr>=grid.size() || nc>=grid[0].size() || grid[nr][nc]!=1)continue;\\n                    fresh--;\\n                    grid[nr][nc]=2;\\n                    q.push({nr,nc});\\n                }\\n                \\n            }\\n            \\n        }\\n        return fresh?-1:time_elapse;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849762,
                "title": "dfs-recursion-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&grid,int i,int j,int min){ \\nif(i<0 || j<0 || j>grid[0].size()-1 || i>grid.size()-1 ||  grid[i][j]==0 ||(1<grid[i][j] && grid[i][j]<min)){\\n            return ;\\n        }\\n          grid[i][j]=min;                                                                                          \\n       dfs(grid,i+1,j,min+1); \\n       dfs(grid,i,j+1,min+1); \\n       dfs(grid,i-1,j,min+1); \\n       dfs(grid,i,j-1,min+1);                                                                                                                          \\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int min=2;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(n==1 && m==1){\\n            if(grid[0][0]==1){\\n                return -1;\\n            }\\n             if(grid[0][0]==0){\\n                return 0;\\n            }\\n             if(grid[0][0]==2){\\n                return 0;\\n            }\\n        }\\n       \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==2){\\n                    dfs(grid,i,j,min);\\n                }\\n            }\\n        }\\n        int maxi=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    return -1;\\n                }\\n               maxi=max(maxi,grid[i][j]); \\n              \\n            }\\n        }\\n       \\n        if(maxi==0){\\n            return 0;\\n        }\\n        return  maxi-2;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&grid,int i,int j,int min){ \\nif(i<0 || j<0 || j>grid[0].size()-1 || i>grid.size()-1 ||  grid[i][j]==0 ||(1<grid[i][j] && grid[i][j]<min)){\\n            return ;\\n        }\\n          grid[i][j]=min;                                                                                          \\n       dfs(grid,i+1,j,min+1); \\n       dfs(grid,i,j+1,min+1); \\n       dfs(grid,i-1,j,min+1); \\n       dfs(grid,i,j-1,min+1);                                                                                                                          \\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int min=2;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(n==1 && m==1){\\n            if(grid[0][0]==1){\\n                return -1;\\n            }\\n             if(grid[0][0]==0){\\n                return 0;\\n            }\\n             if(grid[0][0]==2){\\n                return 0;\\n            }\\n        }\\n       \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==2){\\n                    dfs(grid,i,j,min);\\n                }\\n            }\\n        }\\n        int maxi=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    return -1;\\n                }\\n               maxi=max(maxi,grid[i][j]); \\n              \\n            }\\n        }\\n       \\n        if(maxi==0){\\n            return 0;\\n        }\\n        return  maxi-2;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793051,
                "title": "fully-explained-cpp-solution",
                "content": "# Intuition\\nWe have to do level order traversal on the indices with rotten oranges and increase the time accordingly.\\n**Why BFS?**\\nBecause BFS will give the minimum time as asked in question and we have to travel level wise simultaneously.\\n\\n\\n# Approach\\n1. Find out the indices of element with value = 2(rotten oranges), push them into queue, also add time = 0, initially.\\n```\\nqueue<pair<pair<int, int>, int>> q;\\nif(grid[i][j] == 2)\\n    q.push({{i, j}, 0});\\n```\\nAlso, take a visited matrix and initialze it with values of grid matrix. \\n\\n2. Until queue become empty, \\n- Store the front element of the queue, and pop it.\\n- For that particular element, traverse in four directions and add those indices to the queue if *it is in the range of size, index is not empty i.e. != 0 and it is not already rotted i.e it is != 2*.\\n- While adding it to the queue, increase the timings by 1 and marks that index as 2 in visited matrix i.e it is rotten by that time.\\n```\\nq.push({{newRow, newCol}, time+1});\\n    visited[newRow][newCol] = 2;\\n```\\n\\n\\n3. Check if the visited matrix still contains any fresh oranges i.e value is 1 , return -1 because after traversing it cant be rotted. Otherwise return the time.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(m x n)\\n\\n- Space complexity:\\nO(m x n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        //pair of pair for marking indices and time simulateneously\\n        queue<pair<pair<int, int>, int>> q;\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n//It is important to calculate the number of times fresh  oranges occur in the grid. \\n//If there is no fresh oranges simply return 0. \\n//IF there are no rotten eggs, then return -1. \\n        int count_of_one = 0;\\n        for(int i = 0; i < rows; i++)\\n        {\\n            for(int j = 0; j < cols; j++)\\n            {\\n                if(grid[i][j] == 2)\\n                    q.push({{i, j}, 0});\\n                if(grid[i][j] == 1)\\n                    count_of_one++;\\n            }\\n        }\\n        if(count_of_one == 0) return 0;\\n        if(q.empty()) return -1;\\n//make a visited matrix. Initialize it with elements of grid.\\n        vector<vector<int>> visited(rows, vector<int>(cols, 0));\\n        for(int i = 0; i < rows; i++)\\n        {\\n            for(int j = 0; j < cols; j++)\\n            {\\n                visited[i][j] = grid[i][j];\\n            }\\n        }\\n//to travel in 4 directions we will use two arrays\\n        int delRow[] = {-1, 0, 1, 0};\\n        int delCol[] = {0, 1, 0, -1};\\n\\n//NOW perform BFS on the grid, because we need a level order traversal\\n        int time = 0;\\n        while(!q.empty())\\n        {\\n            pair<pair<int, int>, int> p = q.front();\\n            q.pop();\\n            pair<int, int> index = p.first;\\n            time = p.second;\\n\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int newRow = delRow[i] + index.first;\\n                int newCol = delCol[i] + index.second;\\n\\n                if(newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && visited[newRow][newCol] != 2 && visited[newRow][newCol] != 0)\\n                {\\n                    q.push({{newRow, newCol}, time+1});\\n                    visited[newRow][newCol] = 2;\\n                }\\n            }\\n        }\\n//if there is still any 1 in the visited matrix, then it is because some fresh oranges are still left. So return -1 in this case.\\n        for(int i = 0; i < rows; i++)\\n        {\\n            for(int j = 0;  j < cols; j++)\\n            {\\n                if(visited[i][j] == 1)\\n                    return -1;\\n            }\\n        }\\n//otherwise return time.\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nqueue<pair<pair<int, int>, int>> q;\\nif(grid[i][j] == 2)\\n    q.push({{i, j}, 0});\\n```\n```\\nq.push({{newRow, newCol}, time+1});\\n    visited[newRow][newCol] = 2;\\n```\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        //pair of pair for marking indices and time simulateneously\\n        queue<pair<pair<int, int>, int>> q;\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n//It is important to calculate the number of times fresh  oranges occur in the grid. \\n//If there is no fresh oranges simply return 0. \\n//IF there are no rotten eggs, then return -1. \\n        int count_of_one = 0;\\n        for(int i = 0; i < rows; i++)\\n        {\\n            for(int j = 0; j < cols; j++)\\n            {\\n                if(grid[i][j] == 2)\\n                    q.push({{i, j}, 0});\\n                if(grid[i][j] == 1)\\n                    count_of_one++;\\n            }\\n        }\\n        if(count_of_one == 0) return 0;\\n        if(q.empty()) return -1;\\n//make a visited matrix. Initialize it with elements of grid.\\n        vector<vector<int>> visited(rows, vector<int>(cols, 0));\\n        for(int i = 0; i < rows; i++)\\n        {\\n            for(int j = 0; j < cols; j++)\\n            {\\n                visited[i][j] = grid[i][j];\\n            }\\n        }\\n//to travel in 4 directions we will use two arrays\\n        int delRow[] = {-1, 0, 1, 0};\\n        int delCol[] = {0, 1, 0, -1};\\n\\n//NOW perform BFS on the grid, because we need a level order traversal\\n        int time = 0;\\n        while(!q.empty())\\n        {\\n            pair<pair<int, int>, int> p = q.front();\\n            q.pop();\\n            pair<int, int> index = p.first;\\n            time = p.second;\\n\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int newRow = delRow[i] + index.first;\\n                int newCol = delCol[i] + index.second;\\n\\n                if(newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && visited[newRow][newCol] != 2 && visited[newRow][newCol] != 0)\\n                {\\n                    q.push({{newRow, newCol}, time+1});\\n                    visited[newRow][newCol] = 2;\\n                }\\n            }\\n        }\\n//if there is still any 1 in the visited matrix, then it is because some fresh oranges are still left. So return -1 in this case.\\n        for(int i = 0; i < rows; i++)\\n        {\\n            for(int j = 0;  j < cols; j++)\\n            {\\n                if(visited[i][j] == 1)\\n                    return -1;\\n            }\\n        }\\n//otherwise return time.\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2665570,
                "title": "bfs-solution-in-python",
                "content": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        visited,queue=set(),deque()\\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                if grid[row][col]==1:\\n                    visited.add((row,col))\\n                elif grid[row][col]==2:\\n                    queue.append((row,col))\\n        ans=0\\n        while visited and queue:\\n            for _ in range(len(queue)):\\n                r,c=queue.popleft()\\n                for neighbours in ((r,c-1),(r,c+1),(r-1,c),(r+1,c)):\\n                    if neighbours in visited:\\n                        visited.remove(neighbours)\\n                        queue.append(neighbours)\\n            ans+=1\\n        return -1 if visited else ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        visited,queue=set(),deque()\\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                if grid[row][col]==1:\\n                    visited.add((row,col))\\n                elif grid[row][col]==2:\\n                    queue.append((row,col))\\n        ans=0\\n        while visited and queue:\\n            for _ in range(len(queue)):\\n                r,c=queue.popleft()\\n                for neighbours in ((r,c-1),(r,c+1),(r-1,c),(r+1,c)):\\n                    if neighbours in visited:\\n                        visited.remove(neighbours)\\n                        queue.append(neighbours)\\n            ans+=1\\n        return -1 if visited else ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647595,
                "title": "java-2ms-bfs-solution-faster-than-96-78-with-explaination",
                "content": "**Note:** the same solution when runned at different times produce different runtimes,so it is adviced to not get disappointed about this ,rest assured this is a one of the best bfs solutions for this question.these submissions hold the the same code.\\n![image](https://assets.leetcode.com/users/images/e0d98959-c60b-47a0-a907-570f43c598a4_1664644212.1830633.png)\\nif your solution is getting a high run time,here are some quick suggestions \\n*  keep a variable which keeps count of ones \\n*  keeping count of ones help in breaking the while loop as soon as all the oranges are rooten and prevents us from traversing the whole array in the worst case.\\n*  another use is to just check at the end if all the oranges are rotten or not.\\n**Approach**\\n*  if all zero or all two return 0\\n*  if all one return -1\\n* store the intially rotten tomatos in the queue so that we have starting point of infection, and apply bfs on them.\\n*  keep count of total unrotten tomatos and as soon as every tomato is wrotten terminate the loop.\\n* store the location of the rotten tomato and the time elepsed yet in the queue ,you can use different methods to do this,i just stored an array of size 3 in queue where i,j and time elepsed are stored respectively\\n*  rott the adjacent fresh oranges to these and store them in the queue.\\n*  store the time elapsed to reach previous fresh tomato + 1 for the current tomato in a variable ans.\\n*  when completed return ans.\\n**Code**\\n```\\nclass Solution {\\n    int[][] arr;\\n    boolean inRange(int i,int j){//range validator\\n        return !(i<0||i>arr.length-1||j<0||j>arr[0].length-1);\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        arr=grid;\\n        //possible movements\\n        int[] u={0,0,-1,1};\\n        int[] v={1,-1,0,0};\\n        Queue<int[]> q=new LinkedList<>();\\n        int zero=0,two=0,one=0;\\n // ------------------------------------------------------------------------------            \\n        //count the zeros,twos and ones and store rotten tomatos into queue \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==0) zero++;\\n                else if(grid[i][j]==1) one++;\\n                else two++;\\n                if(grid[i][j]==2){\\n                q.add(new int[]{i,j,0});\\n                }\\n            }\\n        }\\n// ------------------------------------------------------------------------------     \\n        int ans=0;\\n        //optional as this check has no effect in long run\\n        int size=grid.length*grid[0].length;\\n        if(zero==size||two==size) return 0;\\n        if(one==size) return -1;\\n// ------------------------------------------------------------------------------        \\n        while(!q.isEmpty()){\\n                    size=q.size();\\n                    for(int k=0;k<size;k++){\\n                        int[] temp=q.poll();\\n                        int cost=temp[2];\\n                        for(int l=0;l<4;l++){\\n                            int a=temp[0]+u[l];\\n                            int b=temp[1]+v[l];\\n                            if(inRange(a,b) && grid[a][b]==1){//adding an adjacent fresh tomato into queue and rotting it.\\n                                q.add(new int[]{a,b,cost+1});\\n                                grid[a][b]=2;\\n                                ans=cost+1;//storing time elapsed.\\n                                one--;//reducing the count of fresh tomatos\\n                            }\\n                        }\\n                        if(one<=0) break;//if no fresh tomatos left break\\n                    }\\n                }\\n// -----------------------------------------------------------------------------            \\n        if(one!=0) return -1; //it is not possible to rott all tomatos\\n        return ans;    \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    int[][] arr;\\n    boolean inRange(int i,int j){//range validator\\n        return !(i<0||i>arr.length-1||j<0||j>arr[0].length-1);\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        arr=grid;\\n        //possible movements\\n        int[] u={0,0,-1,1};\\n        int[] v={1,-1,0,0};\\n        Queue<int[]> q=new LinkedList<>();\\n        int zero=0,two=0,one=0;\\n // ------------------------------------------------------------------------------            \\n        //count the zeros,twos and ones and store rotten tomatos into queue \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==0) zero++;\\n                else if(grid[i][j]==1) one++;\\n                else two++;\\n                if(grid[i][j]==2){\\n                q.add(new int[]{i,j,0});\\n                }\\n            }\\n        }\\n// ------------------------------------------------------------------------------     \\n        int ans=0;\\n        //optional as this check has no effect in long run\\n        int size=grid.length*grid[0].length;\\n        if(zero==size||two==size) return 0;\\n        if(one==size) return -1;\\n// ------------------------------------------------------------------------------        \\n        while(!q.isEmpty()){\\n                    size=q.size();\\n                    for(int k=0;k<size;k++){\\n                        int[] temp=q.poll();\\n                        int cost=temp[2];\\n                        for(int l=0;l<4;l++){\\n                            int a=temp[0]+u[l];\\n                            int b=temp[1]+v[l];\\n                            if(inRange(a,b) && grid[a][b]==1){//adding an adjacent fresh tomato into queue and rotting it.\\n                                q.add(new int[]{a,b,cost+1});\\n                                grid[a][b]=2;\\n                                ans=cost+1;//storing time elapsed.\\n                                one--;//reducing the count of fresh tomatos\\n                            }\\n                        }\\n                        if(one<=0) break;//if no fresh tomatos left break\\n                    }\\n                }\\n// -----------------------------------------------------------------------------            \\n        if(one!=0) return -1; //it is not possible to rott all tomatos\\n        return ans;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584200,
                "title": "c-dfs-different-intuitive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void helper(vector<vector<int>>& grid, int i, int j, int time)\\n    {\\n        if(i < 0 || i >= grid.size() || j < 0 || j >= grid[i].size() || grid[i][j] == 0 || (grid[i][j] > 1 && grid[i][j] < time))\\n            return;\\n        grid[i][j] = time;\\n        helper(grid, i + 1, j, time + 1);\\n        helper(grid, i - 1, j, time + 1);\\n        helper(grid, i, j + 1, time + 1);\\n        helper(grid, i, j - 1, time + 1);\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int time = 2;\\n        for(int i = 0 ; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[i].size(); j++)\\n            {\\n                if(grid[i][j] == 2)\\n                {\\n                    helper(grid, i, j, time);\\n                }\\n            }\\n        }\\n        int ans = 2;\\n        for(int i = 0 ; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[i].size(); j++)\\n            {\\n                if(grid[i][j] == 1)\\n                    return -1;\\n                ans = max(ans, grid[i][j]);\\n            }\\n        }\\n        return ans - 2;     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void helper(vector<vector<int>>& grid, int i, int j, int time)\\n    {\\n        if(i < 0 || i >= grid.size() || j < 0 || j >= grid[i].size() || grid[i][j] == 0 || (grid[i][j] > 1 && grid[i][j] < time))\\n            return;\\n        grid[i][j] = time;\\n        helper(grid, i + 1, j, time + 1);\\n        helper(grid, i - 1, j, time + 1);\\n        helper(grid, i, j + 1, time + 1);\\n        helper(grid, i, j - 1, time + 1);\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int time = 2;\\n        for(int i = 0 ; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[i].size(); j++)\\n            {\\n                if(grid[i][j] == 2)\\n                {\\n                    helper(grid, i, j, time);\\n                }\\n            }\\n        }\\n        int ans = 2;\\n        for(int i = 0 ; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[i].size(); j++)\\n            {\\n                if(grid[i][j] == 1)\\n                    return -1;\\n                ans = max(ans, grid[i][j]);\\n            }\\n        }\\n        return ans - 2;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446082,
                "title": "bfs-easyyyyy-python",
                "content": "```\\n def orangesRotting(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        Fresh = 0  #count of fresh apples\\n        rotten = 0 # count of apples which which will be rotten\\n        \\n        \\n        visited=[[0 for i in range(m)]for j in range(n)]\\n        queue=[]\\n        for i in range(n):\\n            for j in range(m):\\n                if(grid[i][j]==2):\\n                    queue.append([i,j,0])\\n                    visited[i][j]=1\\n                if(grid[i][j]==1):\\n                    Fresh+=1\\n        if(Fresh==0):\\n            return 0 \\n        \\n        while queue:\\n                row = queue[0][0]\\n                col = queue[0][1]\\n                \\n                t = queue[0][2]\\n                queue.pop(0)\\n                for i,j in [(1,0),(0,1),(0,-1),(-1,0)]:\\n                    newRow = row+i\\n                    newCol = col+j\\n                    \\n                    if(newRow>=0 and newRow<n and newCol>=0 and newCol<m and grid[newRow][newCol]==1 and visited[newRow][newCol]!=1):\\n                        queue.append([newRow,newCol,t+1])\\n                        visited[newRow][newCol]=1\\n                        rotten+=1\\n        \\n        \\n        if(rotten!=Fresh):\\n            return -1\\n        return t\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\n def orangesRotting(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        Fresh = 0  #count of fresh apples\\n        rotten = 0 # count of apples which which will be rotten\\n        \\n        \\n        visited=[[0 for i in range(m)]for j in range(n)]\\n        queue=[]\\n        for i in range(n):\\n            for j in range(m):\\n                if(grid[i][j]==2):\\n                    queue.append([i,j,0])\\n                    visited[i][j]=1\\n                if(grid[i][j]==1):\\n                    Fresh+=1\\n        if(Fresh==0):\\n            return 0 \\n        \\n        while queue:\\n                row = queue[0][0]\\n                col = queue[0][1]\\n                \\n                t = queue[0][2]\\n                queue.pop(0)\\n                for i,j in [(1,0),(0,1),(0,-1),(-1,0)]:\\n                    newRow = row+i\\n                    newCol = col+j\\n                    \\n                    if(newRow>=0 and newRow<n and newCol>=0 and newCol<m and grid[newRow][newCol]==1 and visited[newRow][newCol]!=1):\\n                        queue.append([newRow,newCol,t+1])\\n                        visited[newRow][newCol]=1\\n                        rotten+=1\\n        \\n        \\n        if(rotten!=Fresh):\\n            return -1\\n        return t\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2417466,
                "title": "c-solution-bfs-traversal-using-queue-easy-approach",
                "content": "```\\n// If it helps plz upvote :)\\n\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        // Finding the size of grid\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        // Making visited array\\n        vector<vector<int>> visited(n,vector<int>(m,0));\\n        // Making queue  to store row , col , time\\n        queue<pair<pair<int,int>,int>> q;\\n        int fcount = 0;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                // marking visited array 2 if found rotten orange\\n                if(grid[i][j] == 2){\\n                    visited[i][j] = 2;\\n                    q.push({{i,j},0});\\n                }\\n                \\n                // finding no of fresh orange\\n                if(grid[i][j] == 1){\\n                    fcount++;\\n                }\\n                \\n            }\\n        }\\n        \\n        // doing bfs traversal\\n        int dr[] = {-1,0,1,0};\\n        int dc[] = {0,1,0,-1};\\n        int tmax = 0;\\n        \\n        int count = 0;\\n        while(!q.empty()){\\n            int r = q.front().first.first;\\n            int c = q.front().first.second;\\n            int t = q.front().second;\\n            q.pop();\\n            tmax = max(tmax,t);\\n            \\n            for(int i=0;i<4;i++){\\n                int row = r + dr[i];\\n                int col = c + dc[i];\\n                // base case\\n                if(row >= 0 && col >= 0 && row < n && col < m && grid[row][col] == 1 && visited[row][col] != 2){\\n                    visited[row][col] = 2;\\n                    q.push({{row,col},t + 1});\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        // checking if all fresh orange got rotten or not\\n        if(fcount != count){\\n            return -1;\\n        }\\n        \\n        return tmax;\\n    }\\n};\\n\\n// If it helps plz upvote :)\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n// If it helps plz upvote :)\\n\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        // Finding the size of grid\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        // Making visited array\\n        vector<vector<int>> visited(n,vector<int>(m,0));\\n        // Making queue  to store row , col , time\\n        queue<pair<pair<int,int>,int>> q;\\n        int fcount = 0;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                // marking visited array 2 if found rotten orange\\n                if(grid[i][j] == 2){\\n                    visited[i][j] = 2;\\n                    q.push({{i,j},0});\\n                }\\n                \\n                // finding no of fresh orange\\n                if(grid[i][j] == 1){\\n                    fcount++;\\n                }\\n                \\n            }\\n        }\\n        \\n        // doing bfs traversal\\n        int dr[] = {-1,0,1,0};\\n        int dc[] = {0,1,0,-1};\\n        int tmax = 0;\\n        \\n        int count = 0;\\n        while(!q.empty()){\\n            int r = q.front().first.first;\\n            int c = q.front().first.second;\\n            int t = q.front().second;\\n            q.pop();\\n            tmax = max(tmax,t);\\n            \\n            for(int i=0;i<4;i++){\\n                int row = r + dr[i];\\n                int col = c + dc[i];\\n                // base case\\n                if(row >= 0 && col >= 0 && row < n && col < m && grid[row][col] == 1 && visited[row][col] != 2){\\n                    visited[row][col] = 2;\\n                    q.push({{row,col},t + 1});\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        // checking if all fresh orange got rotten or not\\n        if(fcount != count){\\n            return -1;\\n        }\\n        \\n        return tmax;\\n    }\\n};\\n\\n// If it helps plz upvote :)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354411,
                "title": "python-easy-to-understand-sol-with-explanation",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        # This step is standard for a matrix\\n        row = len(grid)\\n        col = len(grid[0])\\n        \\n        # No need to check if the matrix is empty. [(row, col) >= 1] Given in Constraints\\n        \\n        # For keeping the track of number of fresh oranges\\n        fresh_oranges = 0 \\n        \\n        # For storing the position of rotten oranges\\n        queue = deque()\\n        \\n        # Adding Rotten oranges to the queue, Counting number of fresh oranges\\n        for i in range(0, row):\\n            for j in range(0, col):\\n                \\n                if grid[i][j] == 2:\\n                    queue.append((i, j))\\n                elif grid[i][j] == 1:\\n                    fresh_oranges += 1\\n        \\n        # Initializing time variable\\n        time = 0\\n        \\n        while queue and fresh_oranges > 0:\\n            \\n            for _ in range(len(queue)):\\n                x, y = queue.popleft()\\n                \\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                    \\n                    xx, yy = x + dx, y + dy\\n                    \\n                    # Condition for boundry of the matrix\\n                    if xx < 0 or xx == row or yy < 0 or yy == col:\\n                        continue\\n                    \\n                    # For avoiding adding oranges that are alredy rotten to the queue\\n                    if grid[xx][yy] == 0 or grid[xx][yy] == 2:\\n                        continue\\n                    \\n                    # Adding position of fresh oranges which became rotten\\n                    queue.append((xx, yy))\\n                    \\n                    # making the orange rotten in the matrix\\n                    grid[xx][yy] = 2\\n                    \\n                    # reducing the number of fresh oranges by one\\n                    fresh_oranges -= 1\\n            \\n            # Increasing the time variable by one \\n            time += 1\\n        \\n        return time if fresh_oranges == 0 else -1\\n    \\n\\'\\'\\'\\n\\n#### Please Upvote if you find this solution Helpful !!!",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\'\\'\\'\\n\\n\\tclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        # This step is standard for a matrix\\n        row = len(grid)\\n        col = len(grid[0])\\n        \\n        # No need to check if the matrix is empty. [(row, col) >= 1] Given in Constraints\\n        \\n        # For keeping the track of number of fresh oranges\\n        fresh_oranges = 0 \\n        \\n        # For storing the position of rotten oranges\\n        queue = deque()\\n        \\n        # Adding Rotten oranges to the queue, Counting number of fresh oranges\\n        for i in range(0, row):\\n            for j in range(0, col):\\n                \\n                if grid[i][j] == 2:\\n                    queue.append((i, j))\\n                elif grid[i][j] == 1:\\n                    fresh_oranges += 1\\n        \\n        # Initializing time variable\\n        time = 0\\n        \\n        while queue and fresh_oranges > 0:\\n            \\n            for _ in range(len(queue)):\\n                x, y = queue.popleft()\\n                \\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                    \\n                    xx, yy = x + dx, y + dy\\n                    \\n                    # Condition for boundry of the matrix\\n                    if xx < 0 or xx == row or yy < 0 or yy == col:\\n                        continue\\n                    \\n                    # For avoiding adding oranges that are alredy rotten to the queue\\n                    if grid[xx][yy] == 0 or grid[xx][yy] == 2:\\n                        continue\\n                    \\n                    # Adding position of fresh oranges which became rotten\\n                    queue.append((xx, yy))\\n                    \\n                    # making the orange rotten in the matrix\\n                    grid[xx][yy] = 2\\n                    \\n                    # reducing the number of fresh oranges by one\\n                    fresh_oranges -= 1\\n            \\n            # Increasing the time variable by one \\n            time += 1\\n        \\n        return time if fresh_oranges == 0 else -1\\n    \\n\\'\\'\\'\\n\\n#### Please Upvote if you find this solution Helpful !!!",
                "codeTag": "Java"
            },
            {
                "id": 2344451,
                "title": "c-multi-source-bfs-o-n-m",
                "content": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size(); // No of rows\\n        int m = grid[0].size(); // No of columns\\n        \\n\\t\\t//to store  min visited time and initial time as infinity\\n        vector<vector<int> > time(n,vector<int>(m,1e8));\\n        \\n\\t\\t\\n\\t\\tqueue<pair<int,int> > q;\\n\\t\\t\\n\\t\\t// adding all rotten oranges as source with time 0\\n        for(int i=0;i<n;i++)\\n\\t\\t{    \\n            for(int j=0;j<m;j++)\\n\\t\\t\\t{\\n                if(grid[i][j]==2)\\n\\t\\t\\t\\t{\\n                    q.push({i,j}); \\n                    time[i][j] = 0;\\n                }    \\n            }\\n        }\\n        \\n\\t\\t//direction vector\\'s\\n        int dx[4] = {1,0,0,-1};\\n        int dy[4] = {0,1,-1,0};\\n        \\n\\t\\t\\n\\t\\t// BFS\\n        while(q.size()){\\n            \\n            auto [x,y] = q.front(); q.pop();\\n            \\n            for(int i=0;i<4;i++)\\n\\t\\t\\t{\\n                \\n                int newx = dx[i] + x;\\n                int newy = dy[i] + y;\\n                \\n                if( newx<0 or newy<0 or newx>=n or newy>=m or grid[newx][newy]==0 ) continue;\\n                \\n                if( time[newx][newy] > (1 + time[x][y]) )  // checking for better time \\n\\t\\t\\t\\t{\\n                    time[newx][newy] = 1 + time[x][y];\\n                    q.push({newx,newy});\\n                }\\n                \\n            }    \\n            \\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i=0;i<n;i++)\\n\\t\\t{\\n            for(int j=0;j<m;j++)\\n\\t\\t\\t{\\n                if(grid[i][j]==1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// if there is orange which is unvisited then answer will be -1\\n\\t\\t\\t\\t\\t\\tif(time[i][j]==(1e8))  return -1;\\n\\t\\t\\t\\t\\t\\tans = max(ans,time[i][j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size(); // No of rows\\n        int m = grid[0].size(); // No of columns\\n        \\n\\t\\t//to store  min visited time and initial time as infinity\\n        vector<vector<int> > time(n,vector<int>(m,1e8));\\n        \\n\\t\\t\\n\\t\\tqueue<pair<int,int> > q;\\n\\t\\t\\n\\t\\t// adding all rotten oranges as source with time 0\\n        for(int i=0;i<n;i++)\\n\\t\\t{    \\n            for(int j=0;j<m;j++)\\n\\t\\t\\t{\\n                if(grid[i][j]==2)\\n\\t\\t\\t\\t{\\n                    q.push({i,j}); \\n                    time[i][j] = 0;\\n                }    \\n            }\\n        }\\n        \\n\\t\\t//direction vector\\'s\\n        int dx[4] = {1,0,0,-1};\\n        int dy[4] = {0,1,-1,0};\\n        \\n\\t\\t\\n\\t\\t// BFS\\n        while(q.size()){\\n            \\n            auto [x,y] = q.front(); q.pop();\\n            \\n            for(int i=0;i<4;i++)\\n\\t\\t\\t{\\n                \\n                int newx = dx[i] + x;\\n                int newy = dy[i] + y;\\n                \\n                if( newx<0 or newy<0 or newx>=n or newy>=m or grid[newx][newy]==0 ) continue;\\n                \\n                if( time[newx][newy] > (1 + time[x][y]) )  // checking for better time \\n\\t\\t\\t\\t{\\n                    time[newx][newy] = 1 + time[x][y];\\n                    q.push({newx,newy});\\n                }\\n                \\n            }    \\n            \\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i=0;i<n;i++)\\n\\t\\t{\\n            for(int j=0;j<m;j++)\\n\\t\\t\\t{\\n                if(grid[i][j]==1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// if there is orange which is unvisited then answer will be -1\\n\\t\\t\\t\\t\\t\\tif(time[i][j]==(1e8))  return -1;\\n\\t\\t\\t\\t\\t\\tans = max(ans,time[i][j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342575,
                "title": "bfs-o-m-n-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();// store grid row size\\n        int n = grid[0].size();// store grid coloum size\\n        \\n        vector<vector<int>> toVisit;// to store rotten orrange cells to be visited.\\n        \\n        int i,j,time=0;\\n        \\n        for(i=0;i<m;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==2)\\n                {\\n                    toVisit.push_back({i,j}); // if cell is rooten than add it to toVisit.\\n                }\\n            }\\n        }\\n        \\n        toVisit.push_back({-1,-1});// adding a time breaker for each iteration.\\n        int r,c;\\n        \\n        while(!toVisit.empty())\\n        {\\n            while(toVisit.front()[0]!=-1)// run till it hits breaker\\n            {\\n                r=toVisit.front()[0];// get current row\\n                c=toVisit.front()[1];// get current coloum\\n                \\n                toVisit.erase(toVisit.begin());// erase current cell\\n                \\n                if(r>0)// check for up cell\\n                {\\n                    if(grid[r-1][c]==1)// if orange is freash then rotten it and add to the toVist list.\\n                    {\\n                        grid[r-1][c]=2;\\n                        toVisit.push_back({r-1,c});\\n                    }\\n                }\\n                if(r<m-1)// check for down cell\\n                {\\n                    if(grid[r+1][c]==1)// if orange is freash then rotten it and add to the toVist list.\\n                    {\\n                        grid[r+1][c]=2;\\n                        toVisit.push_back({r+1,c});\\n                    }\\n                }\\n                if(c>0)// check for left cell\\n                {\\n                    if(grid[r][c-1]==1)// if orange is freash then rotten it and add to the toVist list.\\n                    {\\n                        grid[r][c-1]=2;\\n                        toVisit.push_back({r,c-1});                 \\n                    }\\n                }\\n                if(c<n-1)// check for right cell\\n                {\\n                    if(grid[r][c+1]==1)// if orange is freash then rotten it and add to the toVist list.\\n                    {\\n                        grid[r][c+1]=2;\\n                        toVisit.push_back({r,c+1});\\n                    }\\n                }\\n            }\\n            \\n            toVisit.erase(toVisit.begin());// erase the time breaker\\n            if(!toVisit.empty())// add time breaker if toVisit is not empty\\n                toVisit.push_back({-1,-1});\\n            \\n            time++;//increment time\\n        }\\n        \\n        int check=0;// to check for fresh orange\\n        for(i=0;i<m;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    check=1;\\n                }\\n            }\\n        }\\n        \\n        if(check==1)\\n            return -1;\\n        else\\n            return time-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();// store grid row size\\n        int n = grid[0].size();// store grid coloum size\\n        \\n        vector<vector<int>> toVisit;// to store rotten orrange cells to be visited.\\n        \\n        int i,j,time=0;\\n        \\n        for(i=0;i<m;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==2)\\n                {\\n                    toVisit.push_back({i,j}); // if cell is rooten than add it to toVisit.\\n                }\\n            }\\n        }\\n        \\n        toVisit.push_back({-1,-1});// adding a time breaker for each iteration.\\n        int r,c;\\n        \\n        while(!toVisit.empty())\\n        {\\n            while(toVisit.front()[0]!=-1)// run till it hits breaker\\n            {\\n                r=toVisit.front()[0];// get current row\\n                c=toVisit.front()[1];// get current coloum\\n                \\n                toVisit.erase(toVisit.begin());// erase current cell\\n                \\n                if(r>0)// check for up cell\\n                {\\n                    if(grid[r-1][c]==1)// if orange is freash then rotten it and add to the toVist list.\\n                    {\\n                        grid[r-1][c]=2;\\n                        toVisit.push_back({r-1,c});\\n                    }\\n                }\\n                if(r<m-1)// check for down cell\\n                {\\n                    if(grid[r+1][c]==1)// if orange is freash then rotten it and add to the toVist list.\\n                    {\\n                        grid[r+1][c]=2;\\n                        toVisit.push_back({r+1,c});\\n                    }\\n                }\\n                if(c>0)// check for left cell\\n                {\\n                    if(grid[r][c-1]==1)// if orange is freash then rotten it and add to the toVist list.\\n                    {\\n                        grid[r][c-1]=2;\\n                        toVisit.push_back({r,c-1});                 \\n                    }\\n                }\\n                if(c<n-1)// check for right cell\\n                {\\n                    if(grid[r][c+1]==1)// if orange is freash then rotten it and add to the toVist list.\\n                    {\\n                        grid[r][c+1]=2;\\n                        toVisit.push_back({r,c+1});\\n                    }\\n                }\\n            }\\n            \\n            toVisit.erase(toVisit.begin());// erase the time breaker\\n            if(!toVisit.empty())// add time breaker if toVisit is not empty\\n                toVisit.push_back({-1,-1});\\n            \\n            time++;//increment time\\n        }\\n        \\n        int check=0;// to check for fresh orange\\n        for(i=0;i<m;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    check=1;\\n                }\\n            }\\n        }\\n        \\n        if(check==1)\\n            return -1;\\n        else\\n            return time-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271868,
                "title": "c-clean-and-commented-solution-bfs-faster-than-92",
                "content": "***Please upvote if you like the solution. :)***\\n```\\nclass Solution {\\npublic:\\n    // direction vectors to find adjacent coordinates.\\n    vector <int> dx = { -1, 0, 1, 0};\\n    vector <int> dy = {0, 1, 0, -1};\\n\\n    // Function to check if the cell is inside the grid and contains a fresh orange.\\n    bool isValid(int x, int y, vector<vector<int>>& grid) {\\n        if (x >= grid.size() || y >= grid[0].size() || x < 0 || y < 0)return false;\\n        if (grid[x][y] != 1)return false;\\n        return true;\\n    }\\n\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        // Variables to keep the count of fresh and total number of oranges.\\n        int fresh = 0;\\n        int total = 0;\\n        queue <pair<int, int>> rotten;\\n\\n        // Initialising the queue with rotten oranges at time = 0 and counting oranges.\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid[0].size(); j++) {\\n                if (grid[i][j] == 1)fresh++, total++;\\n                else if (grid[i][j] == 2) {\\n                    rotten.push({i, j});\\n                    total++;\\n                }\\n            }\\n        }\\n\\n        // If the grid has no fresh oranges, return 0.\\n        if (fresh == 0) {\\n            return 0;\\n        }\\n        // If the grid has no rotten oranges, return -1.\\n        if (total == fresh) {\\n            return -1;\\n        }\\n\\n        int ans = 0;\\n        // Traversing the grid with standard BFS algorithm.\\n        // Checking for adjacent coordinates of each rotten orange till the queue is not empty.\\n        while (!rotten.empty()) {\\n            // Increasing the minutes count.\\n            ans++;\\n            /**\\n             * Each minute sz number of rotten oranges will be checked for adjacent fresh ones.\\n             * sz being the number of coordinates currently in the queue.\\n            */\\n            int sz = rotten.size();\\n            while (sz--) {\\n                int nodex = rotten.front().first;\\n                int nodey = rotten.front().second;\\n                rotten.pop();\\n\\n                for (int i = 0; i < 4; i++) {\\n                    if (isValid(nodex + dx[i], nodey + dy[i], grid)) {\\n                        // This fresh orange is marked rotten in the grid and pushed into the queue.\\n                        grid[nodex + dx[i]][nodey + dy[i]] = 2;\\n                        rotten.push({nodex + dx[i], nodey + dy[i]});\\n                        fresh--;\\n                    }\\n                }\\n            }\\n        }\\n        // If any fresh orange still remains, return -1.\\n        if (fresh > 0)return -1;\\n        /**\\n         * Else return (ans - 1), reducing ans by 1 because the last set of rotten oranges in the queue will not\\n         * have any adjacent fresh oranges to rot but the loop will still increment 1 to our ans.\\n        */\\n        return ans - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // direction vectors to find adjacent coordinates.\\n    vector <int> dx = { -1, 0, 1, 0};\\n    vector <int> dy = {0, 1, 0, -1};\\n\\n    // Function to check if the cell is inside the grid and contains a fresh orange.\\n    bool isValid(int x, int y, vector<vector<int>>& grid) {\\n        if (x >= grid.size() || y >= grid[0].size() || x < 0 || y < 0)return false;\\n        if (grid[x][y] != 1)return false;\\n        return true;\\n    }\\n\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        // Variables to keep the count of fresh and total number of oranges.\\n        int fresh = 0;\\n        int total = 0;\\n        queue <pair<int, int>> rotten;\\n\\n        // Initialising the queue with rotten oranges at time = 0 and counting oranges.\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid[0].size(); j++) {\\n                if (grid[i][j] == 1)fresh++, total++;\\n                else if (grid[i][j] == 2) {\\n                    rotten.push({i, j});\\n                    total++;\\n                }\\n            }\\n        }\\n\\n        // If the grid has no fresh oranges, return 0.\\n        if (fresh == 0) {\\n            return 0;\\n        }\\n        // If the grid has no rotten oranges, return -1.\\n        if (total == fresh) {\\n            return -1;\\n        }\\n\\n        int ans = 0;\\n        // Traversing the grid with standard BFS algorithm.\\n        // Checking for adjacent coordinates of each rotten orange till the queue is not empty.\\n        while (!rotten.empty()) {\\n            // Increasing the minutes count.\\n            ans++;\\n            /**\\n             * Each minute sz number of rotten oranges will be checked for adjacent fresh ones.\\n             * sz being the number of coordinates currently in the queue.\\n            */\\n            int sz = rotten.size();\\n            while (sz--) {\\n                int nodex = rotten.front().first;\\n                int nodey = rotten.front().second;\\n                rotten.pop();\\n\\n                for (int i = 0; i < 4; i++) {\\n                    if (isValid(nodex + dx[i], nodey + dy[i], grid)) {\\n                        // This fresh orange is marked rotten in the grid and pushed into the queue.\\n                        grid[nodex + dx[i]][nodey + dy[i]] = 2;\\n                        rotten.push({nodex + dx[i], nodey + dy[i]});\\n                        fresh--;\\n                    }\\n                }\\n            }\\n        }\\n        // If any fresh orange still remains, return -1.\\n        if (fresh > 0)return -1;\\n        /**\\n         * Else return (ans - 1), reducing ans by 1 because the last set of rotten oranges in the queue will not\\n         * have any adjacent fresh oranges to rot but the loop will still increment 1 to our ans.\\n        */\\n        return ans - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2185266,
                "title": "python-simple-bfs-solution",
                "content": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        q = deque()\\n        fresh, time = 0, 0\\n        \\n        rows, cols = len(grid), len(grid[0])\\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == 2:\\n                    q.append([r,c])\\n                if grid[r][c] == 1:\\n                    fresh += 1\\n        directions = [[1,0],[-1,0],[0,1],[0,-1]]\\n        while q and fresh > 0:\\n            for i in range(len(q)):\\n                r, c = q.popleft()\\n                for dr, dc in directions:\\n                    row = dr + r\\n                    col = dc + c\\n                    if row < 0 or row == rows or col < 0 or col == cols or grid[row][col] != 1:\\n                        continue\\n                    grid[row][col] = 2\\n                    fresh -= 1\\n                    q.append([row, col])\\n            time += 1\\n        return time if fresh == 0 else -1\\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        q = deque()\\n        fresh, time = 0, 0\\n        \\n        rows, cols = len(grid), len(grid[0])\\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == 2:\\n                    q.append([r,c])\\n                if grid[r][c] == 1:\\n                    fresh += 1\\n        directions = [[1,0],[-1,0],[0,1],[0,-1]]\\n        while q and fresh > 0:\\n            for i in range(len(q)):\\n                r, c = q.popleft()\\n                for dr, dc in directions:\\n                    row = dr + r\\n                    col = dc + c\\n                    if row < 0 or row == rows or col < 0 or col == cols or grid[row][col] != 1:\\n                        continue\\n                    grid[row][col] = 2\\n                    fresh -= 1\\n                    q.append([row, col])\\n            time += 1\\n        return time if fresh == 0 else -1\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836596,
                "title": "java-clean-bfs-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        if(grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        Queue<int[]> queue = new LinkedList<>();\\n        int freshOranges = 0;\\n        for(int i = 0 ; i < rows; i++){\\n            for(int j = 0 ; j < cols ; j++){\\n                if(grid[i][j] == 2){\\n                    //add rotten oranges to queue\\n                    queue.offer(new int[]{i, j});\\n                }\\n                if(grid[i][j] == 1){\\n                    freshOranges++;\\n                }\\n            }\\n        }\\n        int minutes = 0; // this is basically number of levels in BFS\\n        int[][] dir = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        //continue the bfs till there are no more valid fresh oranges that can be rotten\\n        while(!queue.isEmpty() && freshOranges > 0){\\n            int sz = queue.size();\\n            for(int i = 0 ; i < sz ; i++){\\n                int[] node = queue.poll();\\n                for(int[] d : dir){\\n                    int x = node[0] + d[0];\\n                    int y = node[1] + d[1];\\n                    //checking if node is a fresh orange which lies inside the matrix\\n                    if(x < 0 || y < 0 || x >= rows || y >= cols || grid[x][y] == 0 || grid[x][y] == 2){\\n                        continue;\\n                    }\\n                    grid[x][y] = 2;\\n                    queue.offer(new int[]{x,y});\\n                    freshOranges--;\\n                }\\n            }\\n            minutes++;\\n        }\\n        return freshOranges == 0 ? minutes : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n        if(grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        Queue<int[]> queue = new LinkedList<>();\\n        int freshOranges = 0;\\n        for(int i = 0 ; i < rows; i++){\\n            for(int j = 0 ; j < cols ; j++){\\n                if(grid[i][j] == 2){\\n                    //add rotten oranges to queue\\n                    queue.offer(new int[]{i, j});\\n                }\\n                if(grid[i][j] == 1){\\n                    freshOranges++;\\n                }\\n            }\\n        }\\n        int minutes = 0; // this is basically number of levels in BFS\\n        int[][] dir = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        //continue the bfs till there are no more valid fresh oranges that can be rotten\\n        while(!queue.isEmpty() && freshOranges > 0){\\n            int sz = queue.size();\\n            for(int i = 0 ; i < sz ; i++){\\n                int[] node = queue.poll();\\n                for(int[] d : dir){\\n                    int x = node[0] + d[0];\\n                    int y = node[1] + d[1];\\n                    //checking if node is a fresh orange which lies inside the matrix\\n                    if(x < 0 || y < 0 || x >= rows || y >= cols || grid[x][y] == 0 || grid[x][y] == 2){\\n                        continue;\\n                    }\\n                    grid[x][y] = 2;\\n                    queue.offer(new int[]{x,y});\\n                    freshOranges--;\\n                }\\n            }\\n            minutes++;\\n        }\\n        return freshOranges == 0 ? minutes : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832041,
                "title": "c-easy-to-understand-bfs-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        queue<pair<int,int>>q;\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        \\n        int ones=0,twos=0,ans=0;\\n        \\n        //Count number of 2\\'s and 1\\'s and push all 2\\'s in the queue\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(grid[i][j] == 2){\\n                    twos++;\\n                    q.push({i,j});\\n                }\\n                else if(grid[i][j]==1){\\n                    ones++;\\n                }\\n            }\\n        }\\n        \\n        //if there are no fresh oranges present(i.e number of ones is equal to zero), time required will also be zero\\n        if(ones == 0) return 0;\\n        \\n        //else if there are no rotten oranges, fresh oranges will not rot and we will have to return (-1)\\n        else if(twos == 0) return -1;\\n        \\n        // count1 stores the number of unvisited nodes or oranges which are \\n        // going to affect its neighbours at that moment\\n        // count2 is going to store number of children nodes of the oranges in the current level\\n        int count1=twos, count2=0;\\n        // assuming the first level is already rotten, we are counting it and so at the end we will return (ans-1) instead of ans. \\n\\t\\t//(If you want to return ans, you can initialize ans as -1 above\\uD83D\\uDE09 )\\n        \\n        //BFS traversal\\n        while(!q.empty()){\\n            int i = q.front().first;\\n            int j = q.front().second;\\n            q.pop();\\n            // Everytime we pop, unvisited oranges in current level decreases by one, hence count1-- (That is decrementing number of 2\\'s)\\n            count1--;\\n            \\n            //there are four conditions(Top, Bottom, Left, Right) to check for the current orange\\n\\t\\t\\t//and it should not cross the bounds of the grid so using checkValid Function at the end\\n            \\n            //Check for Top Direction\\n            if(checkValid(i+1,j,rows,cols) && grid[i+1][j]==1){\\n                // 1(fresh orange) becomes 2 (Rotten Orange) \\n                // and number of children i.e. count2 increased by one\\n                // and push it to queue to further check its children nodes\\n                q.push({i+1,j});\\n                grid[i+1][j] = 2;\\n                count2++;\\n                ones--;\\n            }\\n            //Check for Bottom Direction\\n            if(checkValid(i-1,j,rows,cols) && grid[i-1][j]==1){\\n                q.push({i-1,j});\\n                grid[i-1][j] = 2;\\n                count2++;\\n                ones--;\\n            }\\n            //Check for Left Direction\\n            if(checkValid(i,j-1,rows,cols) && grid[i][j-1]==1){\\n                q.push({i,j-1});\\n                grid[i][j-1] = 2;\\n                count2++;\\n                ones--;\\n            }\\n            //Check for Right Direction\\n                if(checkValid(i,j+1,rows,cols) && grid[i][j+1]==1){\\n                q.push({i,j+1});\\n                grid[i][j+1] = 2;\\n                count2++;\\n                ones--;\\n            }\\n            \\n            if(count1 == 0){ //Traversed for all 2\\'s\\n                // count1 is zero means we have completed traversing the current level of the graph\\n                // and hence one unit of time is passed. So we increrment ans\\n                // going to the next level, for that count2 becomes count1 and count2 becomes zero, \\n                // i.e. children nodes become parent nodes to their children and child count again re-initialised to zero.\\n                ans++;\\n                count1 = count2;\\n                count2 = 0;\\n            }\\n        }\\n        \\n        //If there are still some numbers of fresh oranges left(isolation condition)\\n        //so in that case return -1;\\n        if(ones > 0) return -1;\\n        \\n        //else return our answer\\n        return ans-1;\\n    }\\n    \\n    //Function to check out of bound condition\\n    bool checkValid(int i,int j,int rows, int cols){\\n        if(i<0 || i>=rows || j<0 || j>=cols){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n<em>Happy Coding!</em>\\uD83C\\uDF89\\uD83E\\uDD42 \\n\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        queue<pair<int,int>>q;\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        \\n        int ones=0,twos=0,ans=0;\\n        \\n        //Count number of 2\\'s and 1\\'s and push all 2\\'s in the queue\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(grid[i][j] == 2){\\n                    twos++;\\n                    q.push({i,j});\\n                }\\n                else if(grid[i][j]==1){\\n                    ones++;\\n                }\\n            }\\n        }\\n        \\n        //if there are no fresh oranges present(i.e number of ones is equal to zero), time required will also be zero\\n        if(ones == 0) return 0;\\n        \\n        //else if there are no rotten oranges, fresh oranges will not rot and we will have to return (-1)\\n        else if(twos == 0) return -1;\\n        \\n        // count1 stores the number of unvisited nodes or oranges which are \\n        // going to affect its neighbours at that moment\\n        // count2 is going to store number of children nodes of the oranges in the current level\\n        int count1=twos, count2=0;\\n        // assuming the first level is already rotten, we are counting it and so at the end we will return (ans-1) instead of ans. \\n\\t\\t//(If you want to return ans, you can initialize ans as -1 above\\uD83D\\uDE09 )\\n        \\n        //BFS traversal\\n        while(!q.empty()){\\n            int i = q.front().first;\\n            int j = q.front().second;\\n            q.pop();\\n            // Everytime we pop, unvisited oranges in current level decreases by one, hence count1-- (That is decrementing number of 2\\'s)\\n            count1--;\\n            \\n            //there are four conditions(Top, Bottom, Left, Right) to check for the current orange\\n\\t\\t\\t//and it should not cross the bounds of the grid so using checkValid Function at the end\\n            \\n            //Check for Top Direction\\n            if(checkValid(i+1,j,rows,cols) && grid[i+1][j]==1){\\n                // 1(fresh orange) becomes 2 (Rotten Orange) \\n                // and number of children i.e. count2 increased by one\\n                // and push it to queue to further check its children nodes\\n                q.push({i+1,j});\\n                grid[i+1][j] = 2;\\n                count2++;\\n                ones--;\\n            }\\n            //Check for Bottom Direction\\n            if(checkValid(i-1,j,rows,cols) && grid[i-1][j]==1){\\n                q.push({i-1,j});\\n                grid[i-1][j] = 2;\\n                count2++;\\n                ones--;\\n            }\\n            //Check for Left Direction\\n            if(checkValid(i,j-1,rows,cols) && grid[i][j-1]==1){\\n                q.push({i,j-1});\\n                grid[i][j-1] = 2;\\n                count2++;\\n                ones--;\\n            }\\n            //Check for Right Direction\\n                if(checkValid(i,j+1,rows,cols) && grid[i][j+1]==1){\\n                q.push({i,j+1});\\n                grid[i][j+1] = 2;\\n                count2++;\\n                ones--;\\n            }\\n            \\n            if(count1 == 0){ //Traversed for all 2\\'s\\n                // count1 is zero means we have completed traversing the current level of the graph\\n                // and hence one unit of time is passed. So we increrment ans\\n                // going to the next level, for that count2 becomes count1 and count2 becomes zero, \\n                // i.e. children nodes become parent nodes to their children and child count again re-initialised to zero.\\n                ans++;\\n                count1 = count2;\\n                count2 = 0;\\n            }\\n        }\\n        \\n        //If there are still some numbers of fresh oranges left(isolation condition)\\n        //so in that case return -1;\\n        if(ones > 0) return -1;\\n        \\n        //else return our answer\\n        return ans-1;\\n    }\\n    \\n    //Function to check out of bound condition\\n    bool checkValid(int i,int j,int rows, int cols){\\n        if(i<0 || i>=rows || j<0 || j>=cols){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777879,
                "title": "c-bfs-using-queue-well-explained-with-comments-tc-o-m-n",
                "content": "##### If you understand the approach please please upvote!!!\\uD83D\\uDC4D\\n***Thanks :)***\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        if(grid.empty()) return 0;\\n        int m=grid.size(), n=grid[0].size(), days=0, tot=0, cnt=0;\\n        queue<pair<int, int>>q;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]!=0) tot++;//count total oranges\\n                if(grid[i][j]==2) q.push({i, j});//keep track of rotten orange\\n            }\\n        }\\n        //store the all possible directions\\n        int dx[4]={0, 0, 1, -1};\\n        int dy[4]={1, -1, 0, 0};\\n        \\n        while(!q.empty()){\\n            int k=q.size();\\n            cnt+=k;//updating total rotten orange\\n            while(k--){//do the following steps untill all rotten orange in queue are processed\\n                int x=q.front().first, y=q.front().second;\\n                q.pop();\\n                for(int i=0;i<4;i++){\\n                    int nx=x + dx[i], ny= y+ dy[i];//in each itration nx & ny go to all possible direction\\n                    //checking boundery cases & avoid the rotten orange cells & empty cells\\n                    if(nx< 0 || ny< 0 || nx>=m || ny>=n || grid[nx][ny]!=1) continue;\\n                    grid[nx][ny]=2;//other wise marks the cell as rotten\\n                    q.push({nx,ny});//update the queue with new rotten cells\\n                }\\n            }\\n            if(!q.empty()) days++;//if queue is not empty, then is makes sure that there is some rotten oranges,and they take another days or times  \\n        }\\n        return tot==cnt? days: -1;//if all oranges are rotten, then return the days count ,other wise -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        if(grid.empty()) return 0;\\n        int m=grid.size(), n=grid[0].size(), days=0, tot=0, cnt=0;\\n        queue<pair<int, int>>q;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]!=0) tot++;//count total oranges\\n                if(grid[i][j]==2) q.push({i, j});//keep track of rotten orange\\n            }\\n        }\\n        //store the all possible directions\\n        int dx[4]={0, 0, 1, -1};\\n        int dy[4]={1, -1, 0, 0};\\n        \\n        while(!q.empty()){\\n            int k=q.size();\\n            cnt+=k;//updating total rotten orange\\n            while(k--){//do the following steps untill all rotten orange in queue are processed\\n                int x=q.front().first, y=q.front().second;\\n                q.pop();\\n                for(int i=0;i<4;i++){\\n                    int nx=x + dx[i], ny= y+ dy[i];//in each itration nx & ny go to all possible direction\\n                    //checking boundery cases & avoid the rotten orange cells & empty cells\\n                    if(nx< 0 || ny< 0 || nx>=m || ny>=n || grid[nx][ny]!=1) continue;\\n                    grid[nx][ny]=2;//other wise marks the cell as rotten\\n                    q.push({nx,ny});//update the queue with new rotten cells\\n                }\\n            }\\n            if(!q.empty()) days++;//if queue is not empty, then is makes sure that there is some rotten oranges,and they take another days or times  \\n        }\\n        return tot==cnt? days: -1;//if all oranges are rotten, then return the days count ,other wise -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765779,
                "title": "multi-source-bfs-heavily-commented-rotting-oranges",
                "content": "```\\nint dx[]={1,-1,0,0};\\nint dy[]={0,0,-1,1};\\n\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        queue<pair<int,int>>q;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n        //we will start from all the rotten oranges at the same time,\\n        //so we will push all of them into the queue.            \\n                if(grid[i][j]==2){\\n                    q.push({i,j});\\n                    \\n        // time taken to reach a rotten orage from a rotten orage \\n        //i.e., form itself to itself is 0 .           \\n                    grid[i][j]=0;\\n                }\\n            }\\n        }\\n        \\n        // we will work on negative values on minutes to use this value as visited\\n\\t\\t// as grid dosent contain any negative values.\\n        \\n        int minutes=-1;\\n        int ans=0;\\n        while(!q.empty()){\\n            int len=q.size();\\n            \\n        // end of this for loop indicated 1 minutes elapsed .        \\n            for(int k=0;k<len;k++){\\n                int ii=q.front().first;\\n                int jj=q.front().second;\\n                q.pop();\\n                \\n        // checking all the four direction from the rotten orange .         \\n                for(int i=0;i<4;i++){  \\n                int row=ii+dx[i];\\n                int col=jj+dy[i];\\n                if(row<0 or col<0 or col>m-1 or row>n-1 or grid[row][col]<=0)\\n                    continue;\\n                grid[row][col]=minutes;\\n                q.push({row,col});\\n                ans=min(ans,grid[row][col]);\\n            }\\n            }\\n            minutes--;\\n        }\\n        \\n        \\n        // checking if there any oranges left which is not rotten\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1)\\n                    return -1;\\n            }\\n        }\\n        \\n        return -1*ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nint dx[]={1,-1,0,0};\\nint dy[]={0,0,-1,1};\\n\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        queue<pair<int,int>>q;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n        //we will start from all the rotten oranges at the same time,\\n        //so we will push all of them into the queue.            \\n                if(grid[i][j]==2){\\n                    q.push({i,j});\\n                    \\n        // time taken to reach a rotten orage from a rotten orage \\n        //i.e., form itself to itself is 0 .           \\n                    grid[i][j]=0;\\n                }\\n            }\\n        }\\n        \\n        // we will work on negative values on minutes to use this value as visited\\n\\t\\t// as grid dosent contain any negative values.\\n        \\n        int minutes=-1;\\n        int ans=0;\\n        while(!q.empty()){\\n            int len=q.size();\\n            \\n        // end of this for loop indicated 1 minutes elapsed .        \\n            for(int k=0;k<len;k++){\\n                int ii=q.front().first;\\n                int jj=q.front().second;\\n                q.pop();\\n                \\n        // checking all the four direction from the rotten orange .         \\n                for(int i=0;i<4;i++){  \\n                int row=ii+dx[i];\\n                int col=jj+dy[i];\\n                if(row<0 or col<0 or col>m-1 or row>n-1 or grid[row][col]<=0)\\n                    continue;\\n                grid[row][col]=minutes;\\n                q.push({row,col});\\n                ans=min(ans,grid[row][col]);\\n            }\\n            }\\n            minutes--;\\n        }\\n        \\n        \\n        // checking if there any oranges left which is not rotten\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1)\\n                    return -1;\\n            }\\n        }\\n        \\n        return -1*ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724350,
                "title": "easiest-c-solution-upvote-to-keep-on-top",
                "content": "/*Runtime: 3 ms, faster than 94.30% of C++ online submissions for Rotting Oranges.*/\\n\\n\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int c = 0,fresh=0;\\n        int n= grid[0].size();\\n        queue<pair<int,int>> rotten;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==2)\\n                {\\n                   rotten.push({i,j});      //push the rotten one\\'s into the queue\\n                }\\n                if(grid[i][j]==1)       \\n                     ++fresh;           //count fresh oranges    \\n            }\\n        }\\n        \\n        while(!rotten.empty())          //while queue is not empty\\n        {\\n            int num = rotten.size();\\n            for(int i=0;i<num;i++)\\n            {\\n                int x =rotten.front().first;\\n                int y= rotten.front().second;\\n                rotten.pop();\\n                if(x>0 && grid[x-1][y]==1)\\n                {\\n                    grid[x-1][y]=2;\\n                    --fresh;\\n                    rotten.push({x-1,y});\\n                }\\n                if(y>0 && grid[x][y-1]==1)\\n                {\\n                    grid[x][y-1]=2;\\n                    --fresh;                    \\n                    rotten.push({x,y-1});\\n                }\\n                if(x<m-1 && grid[x+1][y]==1)\\n                {\\n                    grid[x+1][y]=2;\\n                    --fresh;\\n                    rotten.push({x+1,y});\\n                    \\n                }\\n                if(y<n-1 && grid[x][y+1]==1)\\n                {\\n                    grid[x][y+1]=2;\\n                    --fresh;\\n                    rotten.push({x,y+1});\\n                    \\n                } \\n            }\\n            if(!rotten.empty())\\n                ++c;\\n            \\n            \\n            \\n        }\\n    return fresh==0?c:-1;       // if fresh is 0 then return time otherwise -1\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int c = 0,fresh=0;\\n        int n= grid[0].size();\\n        queue<pair<int,int>> rotten;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==2)\\n                {\\n                   rotten.push({i,j}",
                "codeTag": "Java"
            },
            {
                "id": 1586822,
                "title": "java-easy-solution-brute-and-optimised-bfs",
                "content": "# Optimised\\n```java\\npublic int orangesRotting(int[][] grid) {\\n\\tint fresh_oranges = 0;\\n\\tint row = grid.length, col = grid[0].length;\\n\\tQueue<ArrayList<Integer>> queue = new LinkedList<>(); \\n\\tfor(int i = 0; i < row; i++) {\\n\\t\\tfor(int j = 0; j < col; j++) {\\n\\t\\t\\tif(grid[i][j] == 2) {\\n\\t\\t\\t\\tArrayList l = new ArrayList<>();\\n\\t\\t\\t\\tl.add(i); l.add(j);\\n\\t\\t\\t\\tqueue.add(l);\\n\\t\\t\\t} \\n\\t\\t\\telse if(grid[i][j] == 1) {\\n\\t\\t\\t\\tfresh_oranges++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif(fresh_oranges == 0) return 0;\\n\\n\\tint minutes = -1; // because count of minute is starting from 0\\n\\tint[][] directions = {{-1,0}, {1, 0}, {0, -1}, {0, 1}}; // up down left right\\n\\n\\twhile(!queue.isEmpty()) {\\n\\t\\tminutes++;\\n\\n\\t\\tint queue_length = queue.size();\\n\\t\\tfor(int i = 0; i < queue_length; i++) {\\n\\t\\t\\tArrayList<Integer> coordinates = queue.poll();\\n\\n\\t\\t\\tfor(int[] direction: directions) {\\n\\t\\t\\t\\tint x = coordinates.get(0) + direction[0];\\n\\t\\t\\t\\tint y = coordinates.get(1) + direction[1];\\n\\n\\t\\t\\t\\tif(x < 0 || y < 0 || x >= row || y >= col || grid[x][y] == 0 || grid[x][y] == 2) continue; // continue if either out of range or apple is not fresh\\n\\n\\t\\t\\t\\tgrid[x][y] = 2;\\n\\t\\t\\t\\tArrayList<Integer> l = new ArrayList<>();\\n\\t\\t\\t\\tl.add(x); l.add(y);\\n\\t\\t\\t\\tqueue.add(l);\\n\\t\\t\\t\\tfresh_oranges--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif(fresh_oranges == 0) return minutes;\\n\\treturn -1;\\n}\\n```\\n\\n**Explanation**\\nBFS (Breadth First Search) is used in this method as we can think of this grid as a graph and these oranges connected. We need to find number of minutes including 0 required for all the oranges to get rotten.\\n\\nThe following steps are used:-\\n- count the number of fresh oranges present in the grid as well as put the row and column indices of those oranges that are rotten.\\n- if the number of fresh oranges is 0 it means that all the oranges are already rotten and we can just return 0.\\n- else we will iterate through all the entries in the queue and make adjacent oranges rotten.\\n- iterate and check for all four directions and if grid entry for those indices is 1 then enter them into queue as well as set them to 2. Don\\'t forget to reduce the count of fresh oranges.\\n- at last check if fresh oranges count is 0 return minutes else return -1.\\n\\nIllustration for example in question:-\\n\\n![image](https://assets.leetcode.com/users/images/f7b075b7-dc2c-4c1b-81f3-475c5a4d3023_1637344486.197861.png)\\n\\n\\n---\\n\\n\\n# Brute\\n```java\\npublic int orangesRotting(int[][] grid) {\\n        int totalorange = 0, freshorange = 0, minutes = 0;\\n        int row = grid.length, col = grid[0].length;\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                if(grid[i][j] == 1) {\\n                    freshorange++;\\n                    totalorange++;\\n                }\\n                if(grid[i][j] == 2)\\n                    totalorange++;\\n            }\\n        }\\n        if(totalorange == freshorange) return -1;\\n\\n        while(freshorange != 0) {\\n            for(int i = 0; i < row; i++) {\\n                for(int j = 0; j < col; j++) {\\n                    if(grid[i][j] == 0) continue;\\n                    if(grid[i][j] == 2) {\\n                        // top\\n                        if(i-1 >= 0 && grid[i-1][j] == 1) {\\n                            grid[i-1][j] = 3;\\n                            freshorange--;\\n                        }\\n                        // left\\n                        if(j-1 >= 0 && grid[i][j-1] == 1) {\\n                            grid[i][j-1] = 3;\\n                            freshorange--;\\n                        }\\n                        // right\\n                        if(j+1 < col && grid[i][j+1] == 1) {\\n                            grid[i][j+1] = 3;\\n                            freshorange--;\\n                        }\\n                        // down\\n                        if(i+1 < row && grid[i+1][j] == 1) {\\n                            grid[i+1][j] = 3;\\n                            freshorange--;\\n                        }\\n                    }\\n                }\\n            }\\n            for(int i = 0; i < row; i++)\\n                for(int j = 0; j < col; j++)\\n                    if(grid[i][j] == 3)\\n                        grid[i][j] = 2;\\n\\n            minutes++;\\n        }\\n        return minutes;\\n}\\n```\\n\\nHope it helps\\nDo upvote\\nThanks",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```java\\npublic int orangesRotting(int[][] grid) {\\n\\tint fresh_oranges = 0;\\n\\tint row = grid.length, col = grid[0].length;\\n\\tQueue<ArrayList<Integer>> queue = new LinkedList<>(); \\n\\tfor(int i = 0; i < row; i++) {\\n\\t\\tfor(int j = 0; j < col; j++) {\\n\\t\\t\\tif(grid[i][j] == 2) {\\n\\t\\t\\t\\tArrayList l = new ArrayList<>();\\n\\t\\t\\t\\tl.add(i); l.add(j);\\n\\t\\t\\t\\tqueue.add(l);\\n\\t\\t\\t} \\n\\t\\t\\telse if(grid[i][j] == 1) {\\n\\t\\t\\t\\tfresh_oranges++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif(fresh_oranges == 0) return 0;\\n\\n\\tint minutes = -1; // because count of minute is starting from 0\\n\\tint[][] directions = {{-1,0}, {1, 0}, {0, -1}, {0, 1}}; // up down left right\\n\\n\\twhile(!queue.isEmpty()) {\\n\\t\\tminutes++;\\n\\n\\t\\tint queue_length = queue.size();\\n\\t\\tfor(int i = 0; i < queue_length; i++) {\\n\\t\\t\\tArrayList<Integer> coordinates = queue.poll();\\n\\n\\t\\t\\tfor(int[] direction: directions) {\\n\\t\\t\\t\\tint x = coordinates.get(0) + direction[0];\\n\\t\\t\\t\\tint y = coordinates.get(1) + direction[1];\\n\\n\\t\\t\\t\\tif(x < 0 || y < 0 || x >= row || y >= col || grid[x][y] == 0 || grid[x][y] == 2) continue; // continue if either out of range or apple is not fresh\\n\\n\\t\\t\\t\\tgrid[x][y] = 2;\\n\\t\\t\\t\\tArrayList<Integer> l = new ArrayList<>();\\n\\t\\t\\t\\tl.add(x); l.add(y);\\n\\t\\t\\t\\tqueue.add(l);\\n\\t\\t\\t\\tfresh_oranges--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif(fresh_oranges == 0) return minutes;\\n\\treturn -1;\\n}\\n```\n```java\\npublic int orangesRotting(int[][] grid) {\\n        int totalorange = 0, freshorange = 0, minutes = 0;\\n        int row = grid.length, col = grid[0].length;\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                if(grid[i][j] == 1) {\\n                    freshorange++;\\n                    totalorange++;\\n                }\\n                if(grid[i][j] == 2)\\n                    totalorange++;\\n            }\\n        }\\n        if(totalorange == freshorange) return -1;\\n\\n        while(freshorange != 0) {\\n            for(int i = 0; i < row; i++) {\\n                for(int j = 0; j < col; j++) {\\n                    if(grid[i][j] == 0) continue;\\n                    if(grid[i][j] == 2) {\\n                        // top\\n                        if(i-1 >= 0 && grid[i-1][j] == 1) {\\n                            grid[i-1][j] = 3;\\n                            freshorange--;\\n                        }\\n                        // left\\n                        if(j-1 >= 0 && grid[i][j-1] == 1) {\\n                            grid[i][j-1] = 3;\\n                            freshorange--;\\n                        }\\n                        // right\\n                        if(j+1 < col && grid[i][j+1] == 1) {\\n                            grid[i][j+1] = 3;\\n                            freshorange--;\\n                        }\\n                        // down\\n                        if(i+1 < row && grid[i+1][j] == 1) {\\n                            grid[i+1][j] = 3;\\n                            freshorange--;\\n                        }\\n                    }\\n                }\\n            }\\n            for(int i = 0; i < row; i++)\\n                for(int j = 0; j < col; j++)\\n                    if(grid[i][j] == 3)\\n                        grid[i][j] = 2;\\n\\n            minutes++;\\n        }\\n        return minutes;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1547247,
                "title": "java-97-71-bfs",
                "content": "This approach uses:\\n* a queue to track rotten oranges whose neighbors have not yet been checked\\n* a counter for the number of fresh oranges remaining in the grid\\n* an iteration counter (turns).\\n\\nIn each BFS iteration, the algorithm checks the neighbors of each rotten orange, and \"rots\" them, by placing the newly rotten orange location at the end of the queue, and decrementing the fresh count.  When the fresh count hits zero, the iteration counter is the answer.  If the queue is empty at the start of any iteration, then there are fresh oranges that will never rot, and we return -1.\\n```\\nclass Solution {\\n    private static final int FRESH = 1;\\n    private static final int ROTTEN = 2;\\n    \\n    public int orangesRotting(int[][] grid) {\\n        final int m = grid.length;\\n        final int n = grid[0].length;\\n        \\n        // Scan for rotten oranges, and place in a queue.\\n        // Also count fresh oranges.\\n        int freshCount = 0;\\n        ArrayDeque<Integer> queue = new ArrayDeque<Integer>();\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                switch (grid[i][j]) {\\n                    case FRESH: freshCount++; break;\\n                    case ROTTEN: queue.add(i * n + j); break;\\n                }\\n        if (freshCount == 0) return 0;\\n        \\n        // Use BFS to rot the oranges, and count the number of iterations\\n        int turns = 0;\\n        while (freshCount > 0 && !queue.isEmpty()) {\\n            turns++;\\n            \\n            // Pull each of the rotten oranges from the queue\\n            int queueSize = queue.size();\\n            for (int k = 0; k < queueSize; k++) {\\n                int ij = queue.pollFirst();\\n                int i = ij / n;\\n                int j = ij % n;\\n                \\n                // Find any adjacent fresh oranges, and rot them.\\n                // Decrement the fresh count, and queue the newly rotted orange.\\n                if (i > 0 && grid[i-1][j] == FRESH) {\\n                    if (--freshCount == 0) break;\\n                    grid[i-1][j] = ROTTEN;\\n                    queue.add((i-1) * n + j);\\n                }\\n                if (i < m-1 && grid[i+1][j] == FRESH) {\\n                    if (--freshCount == 0) break;\\n                    grid[i+1][j] = ROTTEN;\\n                    queue.add((i+1) * n + j);\\n                }\\n                if (j > 0 && grid[i][j-1] == FRESH) {\\n                    if (--freshCount == 0) break;\\n                    grid[i][j-1] = ROTTEN;\\n                    queue.add(i * n + j - 1);\\n                }\\n                if (j < n-1 && grid[i][j+1] == FRESH) {\\n                    if (--freshCount == 0) break;\\n                    grid[i][j+1] = ROTTEN;\\n                    queue.add(i * n + j + 1);\\n                }\\n            }\\n        }\\n        if (freshCount > 0) return -1;\\n        return turns;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int FRESH = 1;\\n    private static final int ROTTEN = 2;\\n    \\n    public int orangesRotting(int[][] grid) {\\n        final int m = grid.length;\\n        final int n = grid[0].length;\\n        \\n        // Scan for rotten oranges, and place in a queue.\\n        // Also count fresh oranges.\\n        int freshCount = 0;\\n        ArrayDeque<Integer> queue = new ArrayDeque<Integer>();\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                switch (grid[i][j]) {\\n                    case FRESH: freshCount++; break;\\n                    case ROTTEN: queue.add(i * n + j); break;\\n                }\\n        if (freshCount == 0) return 0;\\n        \\n        // Use BFS to rot the oranges, and count the number of iterations\\n        int turns = 0;\\n        while (freshCount > 0 && !queue.isEmpty()) {\\n            turns++;\\n            \\n            // Pull each of the rotten oranges from the queue\\n            int queueSize = queue.size();\\n            for (int k = 0; k < queueSize; k++) {\\n                int ij = queue.pollFirst();\\n                int i = ij / n;\\n                int j = ij % n;\\n                \\n                // Find any adjacent fresh oranges, and rot them.\\n                // Decrement the fresh count, and queue the newly rotted orange.\\n                if (i > 0 && grid[i-1][j] == FRESH) {\\n                    if (--freshCount == 0) break;\\n                    grid[i-1][j] = ROTTEN;\\n                    queue.add((i-1) * n + j);\\n                }\\n                if (i < m-1 && grid[i+1][j] == FRESH) {\\n                    if (--freshCount == 0) break;\\n                    grid[i+1][j] = ROTTEN;\\n                    queue.add((i+1) * n + j);\\n                }\\n                if (j > 0 && grid[i][j-1] == FRESH) {\\n                    if (--freshCount == 0) break;\\n                    grid[i][j-1] = ROTTEN;\\n                    queue.add(i * n + j - 1);\\n                }\\n                if (j < n-1 && grid[i][j+1] == FRESH) {\\n                    if (--freshCount == 0) break;\\n                    grid[i][j+1] = ROTTEN;\\n                    queue.add(i * n + j + 1);\\n                }\\n            }\\n        }\\n        if (freshCount > 0) return -1;\\n        return turns;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1547204,
                "title": "python3-bfs",
                "content": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        que = []\\n        n = len(grid)\\n        m = len(grid[0])\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == 2:\\n                    que.append((i, j))\\n        adj = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n        t = 0\\n        while que:\\n            f = 0\\n            for i in range(len(que)):\\n                u = que.pop(0)\\n                for v in adj:\\n                    if u[0]+v[0] > -1 and u[1]+v[1] > -1 and u[0]+v[0] < n and u[1]+v[1] < m and grid[u[0]+v[0]][u[1]+v[1]] == 1:\\n                        f = 1\\n                        grid[u[0]+v[0]][u[1]+v[1]] = 2\\n                        que.append((u[0]+v[0], u[1]+v[1]))\\n            t += f\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == 1:\\n                    return -1\\n        return t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        que = []\\n        n = len(grid)\\n        m = len(grid[0])\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == 2:\\n                    que.append((i, j))\\n        adj = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n        t = 0\\n        while que:\\n            f = 0\\n            for i in range(len(que)):\\n                u = que.pop(0)\\n                for v in adj:\\n                    if u[0]+v[0] > -1 and u[1]+v[1] > -1 and u[0]+v[0] < n and u[1]+v[1] < m and grid[u[0]+v[0]][u[1]+v[1]] == 1:\\n                        f = 1\\n                        grid[u[0]+v[0]][u[1]+v[1]] = 2\\n                        que.append((u[0]+v[0], u[1]+v[1]))\\n            t += f\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == 1:\\n                    return -1\\n        return t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523794,
                "title": "c-bfs-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n=grid[0].size();\\n        int m=grid.size();\\n        \\n        queue<pair<int,int>>q;\\n        //to move in four direction\\n        vector<int> dir={-1,0,1,0,-1};\\n        //to count how many fresh oranges we have to rot\\n        int fresh_oranges=0;\\n        \\n        for(int i=0;i<m;i++){\\n            \\n            for(int j=0;j<n;j++){\\n                \\n                if(grid[i][j]==2){\\n                    q.push({i,j});\\n                }\\n                if(grid[i][j]==1)\\n                    fresh_oranges++;\\n            }\\n        }\\n        \\n        int ans=-1;\\n        \\n        while(!q.empty()){\\n            \\n            int N=q.size();\\n            \\n            for(int i=0;i<N;i++){\\n                pair<int,int>tmp=q.front();\\n                q.pop();\\n                //initializing this loop for the movement in four direction\\n                for(int j=0;j<4;j++){\\n                    \\n                    int a=tmp.first+dir[j];\\n                    int b=tmp.second+dir[j+1];\\n                    //we would perform any operation only when encountered with a fresh oranges\\n                    //checking the boundaries and fresh oranges\\n                    if(a>=0 && a<m && b<n && b>=0 && grid[a][b]==1){\\n                        \\n                        grid[a][b]=2;\\n                        q.push({a,b});\\n                        fresh_oranges--;\\n                    }\\n                }\\n                \\n            }\\n            ans++;\\n            \\n        }\\n        //if perfoming all operation still fresh oranges have been left\\n        if(fresh_oranges>0) return -1;\\n        \\n        return ans==-1?0:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int n=grid[0].size();\\n        int m=grid.size();\\n        \\n        queue<pair<int,int>>q;\\n        //to move in four direction\\n        vector<int> dir={-1,0,1,0,-1};\\n        //to count how many fresh oranges we have to rot\\n        int fresh_oranges=0;\\n        \\n        for(int i=0;i<m;i++){\\n            \\n            for(int j=0;j<n;j++){\\n                \\n                if(grid[i][j]==2){\\n                    q.push({i,j});\\n                }\\n                if(grid[i][j]==1)\\n                    fresh_oranges++;\\n            }\\n        }\\n        \\n        int ans=-1;\\n        \\n        while(!q.empty()){\\n            \\n            int N=q.size();\\n            \\n            for(int i=0;i<N;i++){\\n                pair<int,int>tmp=q.front();\\n                q.pop();\\n                //initializing this loop for the movement in four direction\\n                for(int j=0;j<4;j++){\\n                    \\n                    int a=tmp.first+dir[j];\\n                    int b=tmp.second+dir[j+1];\\n                    //we would perform any operation only when encountered with a fresh oranges\\n                    //checking the boundaries and fresh oranges\\n                    if(a>=0 && a<m && b<n && b>=0 && grid[a][b]==1){\\n                        \\n                        grid[a][b]=2;\\n                        q.push({a,b});\\n                        fresh_oranges--;\\n                    }\\n                }\\n                \\n            }\\n            ans++;\\n            \\n        }\\n        //if perfoming all operation still fresh oranges have been left\\n        if(fresh_oranges>0) return -1;\\n        \\n        return ans==-1?0:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461002,
                "title": "c-beginner-easy-to-understand-explained-bfs-multisource",
                "content": "# ***Approach***\\n```\\nTime : O(m * n)\\nSpace : O(m * n) , required for queue\\nThis is a very good MultiSource bfs problem\\n\\nAlgo steps:\\n    (1) Push all rotten oranges to queue\\n    (2) check for edge cases\\n    \\n        if in our grid we don\\'t have any rotten oranges:\\n            if fresh_orange_exists:\\n                return -1; // as no rotten orange exists!!!\\n            else\\n                return 0; // both rotten and fresh orange doesn\\'t exists\\n\\n    (3) Use multisource BFS to rot all fresh oranges adjacent to rotten oranges\\n        Logic for pushing oranges to queue for a given rotten orange!!!\\n            check all four directions UP,DOWN,LEFT,RIGHT\\n            then check \\n            if(neighbor isin grid boundary AND neighbor is a fresh orange)\\n                make it rotten , push it to queue\\n    (4) After bfs is completed check\\n            if any fresh orange still exist , \\n                return -1 , as we can\\'t rot all fresh oranges\\n            else\\n                return minutes;\\n```\\n# ***Code***\\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>> &grid) {\\n        queue<pair<int,int>> q;\\n        bool fresh_orange_exists = false;\\n        \\n        // Pushing all rotten oranges to q\\n        for(int i = 0 ; i < grid.size() ; ++i)\\n            for(int j = 0 ; j < grid[0].size() ; ++j)\\n                if(grid[i][j] == 2)\\n                    q.push(make_pair(i , j));\\n                else if(grid[i][j] == 1)\\n                    fresh_orange_exists = true;\\n        \\n        \\n        if(q.empty())// means no rotten orange exists initially\\n            if(fresh_orange_exists)\\n                return -1;\\n            else\\n                return 0;\\n        \\n        int minutes = -1;\\n        \\n        // Multisource BFS\\n        while(q.empty() == false)\\n        {\\n            int n = q.size();\\n            while(n)\\n            {\\n                int i = q.front().first;\\n                int j = q.front().second;\\n                q.pop();\\n                \\n                // pushing all fresh oranges neighboring to current rotten orange\\n                // LOGIC : if(neighbor isin grid boundary and is a fresh orange)\\n                //                make it rotten , push it to queue\\n                if(i - 1 >= 0 and grid[i - 1][j] == 1) // UP\\n                    grid[i - 1][j] = 2 , q.push(make_pair(i - 1 , j));\\n                if(i + 1 < grid.size() and grid[i + 1][j] == 1) // DOWN\\n                    grid[i + 1][j] = 2 , q.push(make_pair(i + 1 , j));\\n                if(j - 1 >= 0 and grid[i][j - 1] == 1) // LEFT\\n                    grid[i][j - 1] = 2 , q.push(make_pair(i , j - 1));\\n                if(j + 1 < grid[0].size() and grid[i][j + 1] == 1) // RIGHT\\n                    grid[i][j + 1] = 2 , q.push(make_pair(i , j + 1));\\n                \\n                n -= 1;\\n            }\\n            minutes += 1;\\n        }\\n        \\n        for(int i = 0 ; i < grid.size() ; ++i)\\n            for(int j = 0 ; j < grid[0].size() ; ++j)\\n                if(grid[i][j] == 1)\\n                    return -1; // All oranges can\\'t be made rotten\\n        \\n        return minutes;\\n    }\\n};\\n```\\n# ***If you liked the Solution , Please Upvote :)***",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nTime : O(m * n)\\nSpace : O(m * n) , required for queue\\nThis is a very good MultiSource bfs problem\\n\\nAlgo steps:\\n    (1) Push all rotten oranges to queue\\n    (2) check for edge cases\\n    \\n        if in our grid we don\\'t have any rotten oranges:\\n            if fresh_orange_exists:\\n                return -1; // as no rotten orange exists!!!\\n            else\\n                return 0; // both rotten and fresh orange doesn\\'t exists\\n\\n    (3) Use multisource BFS to rot all fresh oranges adjacent to rotten oranges\\n        Logic for pushing oranges to queue for a given rotten orange!!!\\n            check all four directions UP,DOWN,LEFT,RIGHT\\n            then check \\n            if(neighbor isin grid boundary AND neighbor is a fresh orange)\\n                make it rotten , push it to queue\\n    (4) After bfs is completed check\\n            if any fresh orange still exist , \\n                return -1 , as we can\\'t rot all fresh oranges\\n            else\\n                return minutes;\\n```\n```\\nclass Solution {\\npublic:\\n    int orangesRotting(vector<vector<int>> &grid) {\\n        queue<pair<int,int>> q;\\n        bool fresh_orange_exists = false;\\n        \\n        // Pushing all rotten oranges to q\\n        for(int i = 0 ; i < grid.size() ; ++i)\\n            for(int j = 0 ; j < grid[0].size() ; ++j)\\n                if(grid[i][j] == 2)\\n                    q.push(make_pair(i , j));\\n                else if(grid[i][j] == 1)\\n                    fresh_orange_exists = true;\\n        \\n        \\n        if(q.empty())// means no rotten orange exists initially\\n            if(fresh_orange_exists)\\n                return -1;\\n            else\\n                return 0;\\n        \\n        int minutes = -1;\\n        \\n        // Multisource BFS\\n        while(q.empty() == false)\\n        {\\n            int n = q.size();\\n            while(n)\\n            {\\n                int i = q.front().first;\\n                int j = q.front().second;\\n                q.pop();\\n                \\n                // pushing all fresh oranges neighboring to current rotten orange\\n                // LOGIC : if(neighbor isin grid boundary and is a fresh orange)\\n                //                make it rotten , push it to queue\\n                if(i - 1 >= 0 and grid[i - 1][j] == 1) // UP\\n                    grid[i - 1][j] = 2 , q.push(make_pair(i - 1 , j));\\n                if(i + 1 < grid.size() and grid[i + 1][j] == 1) // DOWN\\n                    grid[i + 1][j] = 2 , q.push(make_pair(i + 1 , j));\\n                if(j - 1 >= 0 and grid[i][j - 1] == 1) // LEFT\\n                    grid[i][j - 1] = 2 , q.push(make_pair(i , j - 1));\\n                if(j + 1 < grid[0].size() and grid[i][j + 1] == 1) // RIGHT\\n                    grid[i][j + 1] = 2 , q.push(make_pair(i , j + 1));\\n                \\n                n -= 1;\\n            }\\n            minutes += 1;\\n        }\\n        \\n        for(int i = 0 ; i < grid.size() ; ++i)\\n            for(int j = 0 ; j < grid[0].size() ; ++j)\\n                if(grid[i][j] == 1)\\n                    return -1; // All oranges can\\'t be made rotten\\n        \\n        return minutes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454981,
                "title": "python-bfs-clean-concise",
                "content": "**Solution 1: BFS**\\n```python\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        m, n, remainFreshOrange = len(grid), len(grid[0]), 0\\n        bfs = deque([])\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == 2:\\n                    bfs.append((r, c))\\n                    grid[r][c] = 0\\n                elif grid[r][c] == 1:\\n                    remainFreshOrange += 1\\n            \\n        DIR = [0, 1, 0, -1, 0]\\n        minute = 0\\n        while bfs and remainFreshOrange > 0:\\n            for _ in range(len(bfs)):\\n                r, c = bfs.popleft()\\n                for i in range(4):\\n                    nr, nc = r + DIR[i], c + DIR[i+1]\\n                    if nr < 0 or nr == m or nc < 0 or nc == n or grid[nr][nc] != 1: continue\\n                    grid[nr][nc] = 0\\n                    remainFreshOrange -= 1\\n                    bfs.append((nr, nc))\\n            minute += 1\\n        if remainFreshOrange > 0: return -1\\n        return minute\\n```\\nComplexity:\\n- Time: `O(M*N)`, where `M <= 10` is number of rows, `N <= 10` is number of columns in the grid.\\n- Space: `O(M*N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        m, n, remainFreshOrange = len(grid), len(grid[0]), 0\\n        bfs = deque([])\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == 2:\\n                    bfs.append((r, c))\\n                    grid[r][c] = 0\\n                elif grid[r][c] == 1:\\n                    remainFreshOrange += 1\\n            \\n        DIR = [0, 1, 0, -1, 0]\\n        minute = 0\\n        while bfs and remainFreshOrange > 0:\\n            for _ in range(len(bfs)):\\n                r, c = bfs.popleft()\\n                for i in range(4):\\n                    nr, nc = r + DIR[i], c + DIR[i+1]\\n                    if nr < 0 or nr == m or nc < 0 or nc == n or grid[nr][nc] != 1: continue\\n                    grid[nr][nc] = 0\\n                    remainFreshOrange -= 1\\n                    bfs.append((nr, nc))\\n            minute += 1\\n        if remainFreshOrange > 0: return -1\\n        return minute\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368883,
                "title": "easy-and-readable-code-python-bfs",
                "content": "**PLEASE DO UPVOTE IF U FIND MY CODE HELPFUL**\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    \\n    def isValid(self, li, r, c, n, m):\\n        if 0<=r<n and 0<=c<m and li[r][c] == 1: #if fresh return\\n            return True\\n        return False\\n        \\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n            0 -> empty\\n            1 -> fresh\\n            2 -> Rotten\\n            \\n            Return -1 if any fresh orange is isolated and cannot be rotten\\n            \\n            In the starting time frame there may be multiple starting points\\n            So perform a scan on matrix and add them to queue (store the position in the matrix)\\n            every element should be in the form of at which time this is rotten\\n        \"\"\"\\n        n,m = len(grid), len(grid[0])\\n        queue = deque()\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == 2: #rotten orange\\n                    queue.append((0, i, j))\\n                    \\n        ################INITIAL PROCESSING IS DONE#################\\n        row,col = [0, -1, 0, 1], [-1, 0,  1, 0]\\n        last_time = 0\\n        while len(queue):\\n            for _ in range(len(queue)): #going level wise\\n                time, i, j = queue.popleft()\\n                last_time = time\\n                for k in range(4):\\n                    nr, nc = i+row[k], j+col[k]\\n                    if self.isValid(grid, nr, nc, n, m): #check neighbors for fresh orange\\n                        grid[nr][nc] = 2 \\n                        queue.append((time+1, nr, nc))\\n        \\n        ########FINAL CHECK IF THERE ARE ANY FRESH ORANGES LEFT######\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == 1: #According to question\\n                    return -1\\n        \\n        return last_time  #this says that last time you havent found the fresh oranges that to be rotten\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    \\n    def isValid(self, li, r, c, n, m):\\n        if 0<=r<n and 0<=c<m and li[r][c] == 1: #if fresh return\\n            return True\\n        return False\\n        \\n    def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n            0 -> empty\\n            1 -> fresh\\n            2 -> Rotten\\n            \\n            Return -1 if any fresh orange is isolated and cannot be rotten\\n            \\n            In the starting time frame there may be multiple starting points\\n            So perform a scan on matrix and add them to queue (store the position in the matrix)\\n            every element should be in the form of at which time this is rotten\\n        \"\"\"\\n        n,m = len(grid), len(grid[0])\\n        queue = deque()\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == 2: #rotten orange\\n                    queue.append((0, i, j))\\n                    \\n        ################INITIAL PROCESSING IS DONE#################\\n        row,col = [0, -1, 0, 1], [-1, 0,  1, 0]\\n        last_time = 0\\n        while len(queue):\\n            for _ in range(len(queue)): #going level wise\\n                time, i, j = queue.popleft()\\n                last_time = time\\n                for k in range(4):\\n                    nr, nc = i+row[k], j+col[k]\\n                    if self.isValid(grid, nr, nc, n, m): #check neighbors for fresh orange\\n                        grid[nr][nc] = 2 \\n                        queue.append((time+1, nr, nc))\\n        \\n        ########FINAL CHECK IF THERE ARE ANY FRESH ORANGES LEFT######\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] == 1: #According to question\\n                    return -1\\n        \\n        return last_time  #this says that last time you havent found the fresh oranges that to be rotten\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360125,
                "title": "java-bfs-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public class Pair{\\n        int x, y;\\n        Pair(int x, int y){\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length, m = grid[0].length, time = -1;\\n        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        Queue<Pair> q = new ArrayDeque<>();\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                if(grid[i][j] == 2)\\n                    q.add(new Pair(i, j));\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-- > 0){\\n                Pair rem = q.remove();\\n                for(int i = 0; i < 4; i++){\\n                    int x = rem.x + dirs[i][0], y = rem.y + dirs[i][1];\\n                    if(x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == 1){\\n                        grid[x][y] = 2;\\n                        q.add(new Pair(x, y));\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                if(grid[i][j] == 1)\\n                    return -1;\\n        return Math.max(time, 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public class Pair{\\n        int x, y;\\n        Pair(int x, int y){\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        int n = grid.length, m = grid[0].length, time = -1;\\n        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        Queue<Pair> q = new ArrayDeque<>();\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                if(grid[i][j] == 2)\\n                    q.add(new Pair(i, j));\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-- > 0){\\n                Pair rem = q.remove();\\n                for(int i = 0; i < 4; i++){\\n                    int x = rem.x + dirs[i][0], y = rem.y + dirs[i][1];\\n                    if(x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == 1){\\n                        grid[x][y] = 2;\\n                        q.add(new Pair(x, y));\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                if(grid[i][j] == 1)\\n                    return -1;\\n        return Math.max(time, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568275,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1566630,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1916457,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1721818,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1575167,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1988569,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1575546,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1569791,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1569434,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1691989,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1568275,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1566630,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1916457,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1721818,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1575167,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1988569,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1575546,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1569791,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1569434,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1691989,
                "content": [
                    {
                        "username": "amanraj199825",
                        "content": "I am really grateful to the almighty that the person who decided the difficulty of this question isn\\'t my professor"
                    },
                    {
                        "username": "marcoazer",
                        "content": "I might be overthinking this but is it one or multiple rotten oranges at the begining?\\n\\nIf one, then it could be solved with BFS or DFS. But if it\\'s multiple then we need to look at the whole grid every minute. Please add this detail in the question description."
                    },
                    {
                        "username": "xeniawann",
                        "content": "See comments below from vishalshrm539, only 1 scan is needed."
                    },
                    {
                        "username": "jpbianchi",
                        "content": "Run DFS from every rotten orange and stop when you meet another path that is shorter"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "[@thiscodeisugly](/thiscodeisugly) I spend an hour thinking what if there are multiple rotten oranges and yes this is a slow algo considering the scanning of grid until the entire rotting or no rotting is done."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "# My approach when there are multiple rotten oranges at the beginning - scanning grid multiple times\n```\ndef orangesRotting(self,grid):\n        \n        def rot_orange_at(i, j,li):\n            # if valid fresh orange\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not vis[i][j]:\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n                    vis[i][j] = True\n                    li.append((i,j))\n                    return 1\n            return 0\n\n        minutes, tot_rot, prev_rot = 0, 0, -1\n        import numpy as np\n        vis = np.full_like(grid, False)\n        while True:\n            latest_rotted = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2 and not vis[i][j]:\n                        tot_rot += 1\n                        vis[i][j]=True\n                        # 4d\n                        tot_rot += rot_orange_at(i + 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i - 1, j,latest_rotted)\n                        tot_rot += rot_orange_at(i, j - 1,latest_rotted)\n                        tot_rot += rot_orange_at(i, j + 1,latest_rotted)\n            \n            if not tot_rot : # 0 rotten oranges found\n                break\n            if prev_rot == tot_rot: # rotting done\n                minutes-=1 # time spent for extra scanning\n                break\n            prev_rot=tot_rot\n            for i,j in latest_rotted: vis[i][j]=False\n            # a single scan takes one minute\n            minutes += 1\n\n        # checking for safe oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: return -1\n        return minutes\n```"
                    },
                    {
                        "username": "BoLinTw",
                        "content": "You can still use BFS even if there are more than one rotten orange in the beginning."
                    },
                    {
                        "username": "yousenwang001",
                        "content": "This is exactly what I was thinking too. = ="
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"One bad fish can spoil the entire pond.\"\\nRotten Orange - I am no lesser."
                    },
                    {
                        "username": "A-reum",
                        "content": "pls bhai"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "https://leetcode.com/problems/01-matrix/\\nTry this question too, it\\'s somewhat similar to Rotting Oranges."
                    },
                    {
                        "username": "Justfor5minutes",
                        "content": "[@ianjulo](/ianjulo) Thanks mate\\n"
                    },
                    {
                        "username": "ianjulo",
                        "content": "yeaap. Thank you. The above problem helped in solving this problem in 15 minutes. "
                    },
                    {
                        "username": "zuohuang2021",
                        "content": "If there is no fruits at all... it\\'s impossible to rotten any... so should it be -1 for no fruits cases?"
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "[@uditansh](/uditansh) the result would be 0 since -1 is returned only when its impossible to have no fresh oranges (untrue since there are no oranges at all) and not when there are no oranges for there to rot"
                    },
                    {
                        "username": "uditansh",
                        "content": "i opened the discussions just to see if someone else thought about this too"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "I just ate the good oranges instead of solving this"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "A walking W , we have our savior guys XD"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "1. We just need to run BFS once. \\n2. We\\'ll start the BFS at all rotten oranges(i.e. push all the (i , j) pairs of rotten oranges initially in the Queue).\\n3. Keep a map to track visited elements, we\\'ll visit each element(fresh orange) only once.\\n4. Each fresh orange will be reached by its closest rotten orange due to BFS.\\n5. We can use a map to keep track of distances(\\'k\\' distance means \\'k\\' unit time) of fresh oranges with their closest rotten orange and return the maximum distance in the end if all fresh oranges are reached otherwise return -1."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Sarfraz123](/Sarfraz123) I made the same mistake you did "
                    },
                    {
                        "username": "Sarfraz123",
                        "content": "thanks for your approach firstly i  insert first rotten egg  ,and the i run bfs offcourse that will give me wrong   answer \\nafter seeing your comment  push all the rotten egg in queue in first step and run bfs and i get right ans"
                    },
                    {
                        "username": "onesuccess",
                        "content": "I spent a good deal of time down the DFS path but eventually recognized BFS solution is better, but I am trying to understand a meta-pattern so that I can avoid this train of thought for similar problems. \\n\\nI can think of these answers to the question I had: \\ni) if we need a visited array, then the recursive solution becomes much harder since we need to track the \\'visited\\' component as well the recursion and it becomes a huge mess \\n\\nAny other pointers here?"
                    },
                    {
                        "username": "rajawathimanshu75",
                        "content": "I think it depends upon the objective of problem as well, here the fact that each time we explore nearest neighbors for any rotten orange, 1 minute will pass and all these oranges will become rotten, this lead me to think that BFS will be the better option, as after each iteration we can increment the time."
                    },
                    {
                        "username": "greedyartist71",
                        "content": "Hey, [@macy_projects](/macy_projects) could you please help me by elaborating little further ?"
                    },
                    {
                        "username": "macy_projects",
                        "content": "Here\\'s a pointer: the more connected a graph (i.e. ration of edges-to-nodes), a BFS approach will give the more optimal result.  If the graph is sparsely/loosely connected, then you may choose either. "
                    },
                    {
                        "username": "tripathishashank998",
                        "content": "can there be more than one rotten oranges.."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes"
                    },
                    {
                        "username": "ouoggdev",
                        "content": "I don\\'t understand why no one raised the issue about the test case example 2? And one of the test case `[[2,1,1],[0,1,1],[1,0,1]]`\\nIt should be `[[1,1,1],[0,1,1],[2,0,1]]` to generate `-1` as result, isn\\'t it?\\n\\nWhat am I missing here?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@khabilansomasundar](/khabilansomasundar) *bottom left"
                    },
                    {
                        "username": "khabilansomasundar",
                        "content": "Bro the bottom right orange is not reachable through 4 directions. Because that particular orange is surrounded by no oranges and border.\\n"
                    }
                ]
            },
            {
                "id": 1883231,
                "content": [
                    {
                        "username": "prayag",
                        "content": "Goodluck solving this problem in 30 mins unless you have seen this before."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Mister_CK](/Mister_CK) I have solved almost 173 problems rigth now and dhaven\\'t seen nothing like this at this moment, so it\\'s not a commun problem"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty standart BFS, similar to a lot of to number of islands, biggest island, perimeter of biggest island, fish in pond. So you should have seen something similar before."
                    },
                    {
                        "username": "Aimer101",
                        "content": "The tricky part was if there is multiple rotten oranges, you need to do bfs simultaneously. not the minimum when you do bfs separately on each rotten oranges. nice question though"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yes correct. The BFS will be similar to doing a BFS on trees : layer by layer"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ?\\nIt passed 174 but this test case failed ???\\n\\ngrid =\\n[[2,1,1],[1,1,1],[0,1,2]]\\nOutput\\n1\\nExpected\\n2\\n\\n```\\n\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n    if(grid==null || grid.length == 0) return -1;\\n     int dirs[][] = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean [][] visited = new boolean[rows][cols];\\n        int numOFreshOranges = 0;\\n        int numORottenOranges = 0;\\n\\n        Deque<int[]> q = new ArrayDeque();// r, c, steps\\n        for(int r = 0 ; r < rows ; r++){\\n            for(int c = 0 ; c < cols ; c++){\\n                if(grid[r][c] == 1){\\n                      numOFreshOranges++;\\n                }else if(grid[r][c] == 2){\\n                      q.add(new int[]{r, c});// add all rotten oranges as sources \\n                      visited[r][c] = true;\\n                } \\n            }\\n        }\\n        \\n        \\n        // bfs\\n        int steps = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size ; i++){\\n                 int[] pop =  q.removeFirst();\\n                 int r = pop[0]; int c = pop[1] ;\\n                 \\n                 if(numOFreshOranges == 0 )\\n                    return steps;\\n\\n                for(int[] next:dirs){\\n                 int nextr = r + next[0]; int nextc = c + next[1];\\n                 if( !isOutOFBound(grid , nextr , nextc) && !visited[nextr][nextc] && grid[nextr][nextc] == 1){\\n                    visited[nextr][nextc] = true;\\n                    numOFreshOranges--;\\n                    q.add(new int[]{nextr, nextc});\\n                  }\\n                }\\n           }\\n            steps++; // here please \\n        \\n        }\\n        \\n        return numOFreshOranges == 0 ? steps : -1; // edge case [[0]] -> 0 not -1\\n    }\\n    \\n    private boolean isOutOFBound(int[][] room, int r , int c){\\n        int length = room.length; //#of rows or length\\n        int width = room[0].length; // #of cols\\n        if(r < 0 || r >= length || c < 0 || c >= width ){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "H_An",
                        "content": "At 1 minute:\\n[[2,2,1],\\n [2,1,2],\\n [0,2,2]]\\n\\nAt 2 minute:\\n[[2,2,2],\\n [2,2,2],\\n [0,2,2]]"
                    },
                    {
                        "username": "dpwang",
                        "content": "it\\'s medium question"
                    },
                    {
                        "username": "2uringTested",
                        "content": "To everyone who is wondering if more than one rotten orange is allowed at the beginning or not :\\n\\nYes more than one rotting orange is allowed \\nand it can still be solved with a single BFS run just by inserting all the rotten oranges in the queue at the beginning, also called as multi source BFS."
                    },
                    {
                        "username": "reemantech",
                        "content": "Think of this problem similar to the bfs approach implementation. \\n>How would you differentiate the levels ? \\n>you add `null` after adding the root (or when a level ends)!\\n\\nWhen a level ends you increment the time!"
                    },
                    {
                        "username": "mochiball",
                        "content": "The BFS here is kind of similar to the BFS done on trees. Instead of BFS-ing on each individual orange, we do it level by level "
                    },
                    {
                        "username": "fool_100",
                        "content": " `Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.`\\n\\nThis statement is so confusing , the problem statement is itself not well written .\\n**It should be any fresh orange that is 4-directionally adjacent to any rotten orange becomes rotten at the same time** \\n\\n`That means if there are intially 2 oranges rotten any orange adjacent to it will get rotten at the same time`"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Yes, if there are >1 rotten oranges in the beginning, then we have to scan the grid multiple times. You can check my answer(accepted solution) in the replies of this post (sorted BY BEST)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Average complicated algorithm fan vs average brute force enjoyer\\n\\nBecause the grid is really small, you can very realistically brute force this one lmao"
                    },
                    {
                        "username": "Vithesh",
                        "content": "i dont know why people complicate it. Obviously dfs wont work for such problems. And the movement you think about bfs...the solution is so obvious and simple. i solved this question in like 20min."
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "Please check my code is right, still not giving right answers .. lass Solution {\\n    class pair\\n    {\\n        int row;\\n        int col;\\n        int t;\\n        pair(int r,int c,int t)\\n        {\\n            row=r;col=c;t=t;\\n        }\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        int r=grid.length;\\n        int c=grid[0].length;\\n        int vis[][]=new int[r][c];\\n        Queue<pair> q=new LinkedList<>();\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n               if(grid[i][j]==2)\\n               {\\n                   vis[i][j]=2;\\n                   q.add(new pair(i,j,0));\\n               }\\n               else vis[i][j]=0;\\n            }\\n        }\\n        int mt=0;\\n        int drow[]={-1,1,0,0};\\n        int dcol[]={0,0,-1,1};\\n        while(!q.isEmpty())\\n        {\\n            int r1=q.peek().row;int c1=q.peek().col;int t1=q.peek().t;q.remove();\\n            mt=Math.max(mt,t1);\\n            for(int i=0;i<=3;i++)\\n            {\\n                int nr=r1+drow[i];int nc=c1+dcol[i];\\n                if(nr>=0&&nr<r&&nc>=0&&nc<c)\\n                {\\n                    if(vis[nr][nc]==0&&grid[nr][nc]==1)\\n                    {\\n                        vis[nr][nc]=2;\\n                        q.add(new pair(nr,nc,t1+1));\\n                    }\\n                }\\n            }\\n        }\\n        for (int i = 0; i < r; i++) {\\n    for (int j = 0; j < c; j++) {\\n        if (grid[i][j] == 1 && vis[i][j] == 0) \\n            return -1; \\n    }}\\n        return mt;\\n    }\\n}"
                    },
                    {
                        "username": "kinshuokmunjal",
                        "content": "did you get any solution 304 test cases are running in this and giving a wrong answer on [[2,0],[1,0]] this test case"
                    }
                ]
            },
            {
                "id": 1923991,
                "content": [
                    {
                        "username": "prayag",
                        "content": "Goodluck solving this problem in 30 mins unless you have seen this before."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Mister_CK](/Mister_CK) I have solved almost 173 problems rigth now and dhaven\\'t seen nothing like this at this moment, so it\\'s not a commun problem"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty standart BFS, similar to a lot of to number of islands, biggest island, perimeter of biggest island, fish in pond. So you should have seen something similar before."
                    },
                    {
                        "username": "Aimer101",
                        "content": "The tricky part was if there is multiple rotten oranges, you need to do bfs simultaneously. not the minimum when you do bfs separately on each rotten oranges. nice question though"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yes correct. The BFS will be similar to doing a BFS on trees : layer by layer"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ?\\nIt passed 174 but this test case failed ???\\n\\ngrid =\\n[[2,1,1],[1,1,1],[0,1,2]]\\nOutput\\n1\\nExpected\\n2\\n\\n```\\n\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n    if(grid==null || grid.length == 0) return -1;\\n     int dirs[][] = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean [][] visited = new boolean[rows][cols];\\n        int numOFreshOranges = 0;\\n        int numORottenOranges = 0;\\n\\n        Deque<int[]> q = new ArrayDeque();// r, c, steps\\n        for(int r = 0 ; r < rows ; r++){\\n            for(int c = 0 ; c < cols ; c++){\\n                if(grid[r][c] == 1){\\n                      numOFreshOranges++;\\n                }else if(grid[r][c] == 2){\\n                      q.add(new int[]{r, c});// add all rotten oranges as sources \\n                      visited[r][c] = true;\\n                } \\n            }\\n        }\\n        \\n        \\n        // bfs\\n        int steps = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size ; i++){\\n                 int[] pop =  q.removeFirst();\\n                 int r = pop[0]; int c = pop[1] ;\\n                 \\n                 if(numOFreshOranges == 0 )\\n                    return steps;\\n\\n                for(int[] next:dirs){\\n                 int nextr = r + next[0]; int nextc = c + next[1];\\n                 if( !isOutOFBound(grid , nextr , nextc) && !visited[nextr][nextc] && grid[nextr][nextc] == 1){\\n                    visited[nextr][nextc] = true;\\n                    numOFreshOranges--;\\n                    q.add(new int[]{nextr, nextc});\\n                  }\\n                }\\n           }\\n            steps++; // here please \\n        \\n        }\\n        \\n        return numOFreshOranges == 0 ? steps : -1; // edge case [[0]] -> 0 not -1\\n    }\\n    \\n    private boolean isOutOFBound(int[][] room, int r , int c){\\n        int length = room.length; //#of rows or length\\n        int width = room[0].length; // #of cols\\n        if(r < 0 || r >= length || c < 0 || c >= width ){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "H_An",
                        "content": "At 1 minute:\\n[[2,2,1],\\n [2,1,2],\\n [0,2,2]]\\n\\nAt 2 minute:\\n[[2,2,2],\\n [2,2,2],\\n [0,2,2]]"
                    },
                    {
                        "username": "dpwang",
                        "content": "it\\'s medium question"
                    },
                    {
                        "username": "2uringTested",
                        "content": "To everyone who is wondering if more than one rotten orange is allowed at the beginning or not :\\n\\nYes more than one rotting orange is allowed \\nand it can still be solved with a single BFS run just by inserting all the rotten oranges in the queue at the beginning, also called as multi source BFS."
                    },
                    {
                        "username": "reemantech",
                        "content": "Think of this problem similar to the bfs approach implementation. \\n>How would you differentiate the levels ? \\n>you add `null` after adding the root (or when a level ends)!\\n\\nWhen a level ends you increment the time!"
                    },
                    {
                        "username": "mochiball",
                        "content": "The BFS here is kind of similar to the BFS done on trees. Instead of BFS-ing on each individual orange, we do it level by level "
                    },
                    {
                        "username": "fool_100",
                        "content": " `Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.`\\n\\nThis statement is so confusing , the problem statement is itself not well written .\\n**It should be any fresh orange that is 4-directionally adjacent to any rotten orange becomes rotten at the same time** \\n\\n`That means if there are intially 2 oranges rotten any orange adjacent to it will get rotten at the same time`"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Yes, if there are >1 rotten oranges in the beginning, then we have to scan the grid multiple times. You can check my answer(accepted solution) in the replies of this post (sorted BY BEST)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Average complicated algorithm fan vs average brute force enjoyer\\n\\nBecause the grid is really small, you can very realistically brute force this one lmao"
                    },
                    {
                        "username": "Vithesh",
                        "content": "i dont know why people complicate it. Obviously dfs wont work for such problems. And the movement you think about bfs...the solution is so obvious and simple. i solved this question in like 20min."
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "Please check my code is right, still not giving right answers .. lass Solution {\\n    class pair\\n    {\\n        int row;\\n        int col;\\n        int t;\\n        pair(int r,int c,int t)\\n        {\\n            row=r;col=c;t=t;\\n        }\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        int r=grid.length;\\n        int c=grid[0].length;\\n        int vis[][]=new int[r][c];\\n        Queue<pair> q=new LinkedList<>();\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n               if(grid[i][j]==2)\\n               {\\n                   vis[i][j]=2;\\n                   q.add(new pair(i,j,0));\\n               }\\n               else vis[i][j]=0;\\n            }\\n        }\\n        int mt=0;\\n        int drow[]={-1,1,0,0};\\n        int dcol[]={0,0,-1,1};\\n        while(!q.isEmpty())\\n        {\\n            int r1=q.peek().row;int c1=q.peek().col;int t1=q.peek().t;q.remove();\\n            mt=Math.max(mt,t1);\\n            for(int i=0;i<=3;i++)\\n            {\\n                int nr=r1+drow[i];int nc=c1+dcol[i];\\n                if(nr>=0&&nr<r&&nc>=0&&nc<c)\\n                {\\n                    if(vis[nr][nc]==0&&grid[nr][nc]==1)\\n                    {\\n                        vis[nr][nc]=2;\\n                        q.add(new pair(nr,nc,t1+1));\\n                    }\\n                }\\n            }\\n        }\\n        for (int i = 0; i < r; i++) {\\n    for (int j = 0; j < c; j++) {\\n        if (grid[i][j] == 1 && vis[i][j] == 0) \\n            return -1; \\n    }}\\n        return mt;\\n    }\\n}"
                    },
                    {
                        "username": "kinshuokmunjal",
                        "content": "did you get any solution 304 test cases are running in this and giving a wrong answer on [[2,0],[1,0]] this test case"
                    }
                ]
            },
            {
                "id": 1787700,
                "content": [
                    {
                        "username": "prayag",
                        "content": "Goodluck solving this problem in 30 mins unless you have seen this before."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Mister_CK](/Mister_CK) I have solved almost 173 problems rigth now and dhaven\\'t seen nothing like this at this moment, so it\\'s not a commun problem"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty standart BFS, similar to a lot of to number of islands, biggest island, perimeter of biggest island, fish in pond. So you should have seen something similar before."
                    },
                    {
                        "username": "Aimer101",
                        "content": "The tricky part was if there is multiple rotten oranges, you need to do bfs simultaneously. not the minimum when you do bfs separately on each rotten oranges. nice question though"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yes correct. The BFS will be similar to doing a BFS on trees : layer by layer"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ?\\nIt passed 174 but this test case failed ???\\n\\ngrid =\\n[[2,1,1],[1,1,1],[0,1,2]]\\nOutput\\n1\\nExpected\\n2\\n\\n```\\n\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n    if(grid==null || grid.length == 0) return -1;\\n     int dirs[][] = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean [][] visited = new boolean[rows][cols];\\n        int numOFreshOranges = 0;\\n        int numORottenOranges = 0;\\n\\n        Deque<int[]> q = new ArrayDeque();// r, c, steps\\n        for(int r = 0 ; r < rows ; r++){\\n            for(int c = 0 ; c < cols ; c++){\\n                if(grid[r][c] == 1){\\n                      numOFreshOranges++;\\n                }else if(grid[r][c] == 2){\\n                      q.add(new int[]{r, c});// add all rotten oranges as sources \\n                      visited[r][c] = true;\\n                } \\n            }\\n        }\\n        \\n        \\n        // bfs\\n        int steps = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size ; i++){\\n                 int[] pop =  q.removeFirst();\\n                 int r = pop[0]; int c = pop[1] ;\\n                 \\n                 if(numOFreshOranges == 0 )\\n                    return steps;\\n\\n                for(int[] next:dirs){\\n                 int nextr = r + next[0]; int nextc = c + next[1];\\n                 if( !isOutOFBound(grid , nextr , nextc) && !visited[nextr][nextc] && grid[nextr][nextc] == 1){\\n                    visited[nextr][nextc] = true;\\n                    numOFreshOranges--;\\n                    q.add(new int[]{nextr, nextc});\\n                  }\\n                }\\n           }\\n            steps++; // here please \\n        \\n        }\\n        \\n        return numOFreshOranges == 0 ? steps : -1; // edge case [[0]] -> 0 not -1\\n    }\\n    \\n    private boolean isOutOFBound(int[][] room, int r , int c){\\n        int length = room.length; //#of rows or length\\n        int width = room[0].length; // #of cols\\n        if(r < 0 || r >= length || c < 0 || c >= width ){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "H_An",
                        "content": "At 1 minute:\\n[[2,2,1],\\n [2,1,2],\\n [0,2,2]]\\n\\nAt 2 minute:\\n[[2,2,2],\\n [2,2,2],\\n [0,2,2]]"
                    },
                    {
                        "username": "dpwang",
                        "content": "it\\'s medium question"
                    },
                    {
                        "username": "2uringTested",
                        "content": "To everyone who is wondering if more than one rotten orange is allowed at the beginning or not :\\n\\nYes more than one rotting orange is allowed \\nand it can still be solved with a single BFS run just by inserting all the rotten oranges in the queue at the beginning, also called as multi source BFS."
                    },
                    {
                        "username": "reemantech",
                        "content": "Think of this problem similar to the bfs approach implementation. \\n>How would you differentiate the levels ? \\n>you add `null` after adding the root (or when a level ends)!\\n\\nWhen a level ends you increment the time!"
                    },
                    {
                        "username": "mochiball",
                        "content": "The BFS here is kind of similar to the BFS done on trees. Instead of BFS-ing on each individual orange, we do it level by level "
                    },
                    {
                        "username": "fool_100",
                        "content": " `Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.`\\n\\nThis statement is so confusing , the problem statement is itself not well written .\\n**It should be any fresh orange that is 4-directionally adjacent to any rotten orange becomes rotten at the same time** \\n\\n`That means if there are intially 2 oranges rotten any orange adjacent to it will get rotten at the same time`"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Yes, if there are >1 rotten oranges in the beginning, then we have to scan the grid multiple times. You can check my answer(accepted solution) in the replies of this post (sorted BY BEST)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Average complicated algorithm fan vs average brute force enjoyer\\n\\nBecause the grid is really small, you can very realistically brute force this one lmao"
                    },
                    {
                        "username": "Vithesh",
                        "content": "i dont know why people complicate it. Obviously dfs wont work for such problems. And the movement you think about bfs...the solution is so obvious and simple. i solved this question in like 20min."
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "Please check my code is right, still not giving right answers .. lass Solution {\\n    class pair\\n    {\\n        int row;\\n        int col;\\n        int t;\\n        pair(int r,int c,int t)\\n        {\\n            row=r;col=c;t=t;\\n        }\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        int r=grid.length;\\n        int c=grid[0].length;\\n        int vis[][]=new int[r][c];\\n        Queue<pair> q=new LinkedList<>();\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n               if(grid[i][j]==2)\\n               {\\n                   vis[i][j]=2;\\n                   q.add(new pair(i,j,0));\\n               }\\n               else vis[i][j]=0;\\n            }\\n        }\\n        int mt=0;\\n        int drow[]={-1,1,0,0};\\n        int dcol[]={0,0,-1,1};\\n        while(!q.isEmpty())\\n        {\\n            int r1=q.peek().row;int c1=q.peek().col;int t1=q.peek().t;q.remove();\\n            mt=Math.max(mt,t1);\\n            for(int i=0;i<=3;i++)\\n            {\\n                int nr=r1+drow[i];int nc=c1+dcol[i];\\n                if(nr>=0&&nr<r&&nc>=0&&nc<c)\\n                {\\n                    if(vis[nr][nc]==0&&grid[nr][nc]==1)\\n                    {\\n                        vis[nr][nc]=2;\\n                        q.add(new pair(nr,nc,t1+1));\\n                    }\\n                }\\n            }\\n        }\\n        for (int i = 0; i < r; i++) {\\n    for (int j = 0; j < c; j++) {\\n        if (grid[i][j] == 1 && vis[i][j] == 0) \\n            return -1; \\n    }}\\n        return mt;\\n    }\\n}"
                    },
                    {
                        "username": "kinshuokmunjal",
                        "content": "did you get any solution 304 test cases are running in this and giving a wrong answer on [[2,0],[1,0]] this test case"
                    }
                ]
            },
            {
                "id": 1572458,
                "content": [
                    {
                        "username": "prayag",
                        "content": "Goodluck solving this problem in 30 mins unless you have seen this before."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Mister_CK](/Mister_CK) I have solved almost 173 problems rigth now and dhaven\\'t seen nothing like this at this moment, so it\\'s not a commun problem"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty standart BFS, similar to a lot of to number of islands, biggest island, perimeter of biggest island, fish in pond. So you should have seen something similar before."
                    },
                    {
                        "username": "Aimer101",
                        "content": "The tricky part was if there is multiple rotten oranges, you need to do bfs simultaneously. not the minimum when you do bfs separately on each rotten oranges. nice question though"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yes correct. The BFS will be similar to doing a BFS on trees : layer by layer"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ?\\nIt passed 174 but this test case failed ???\\n\\ngrid =\\n[[2,1,1],[1,1,1],[0,1,2]]\\nOutput\\n1\\nExpected\\n2\\n\\n```\\n\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n    if(grid==null || grid.length == 0) return -1;\\n     int dirs[][] = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean [][] visited = new boolean[rows][cols];\\n        int numOFreshOranges = 0;\\n        int numORottenOranges = 0;\\n\\n        Deque<int[]> q = new ArrayDeque();// r, c, steps\\n        for(int r = 0 ; r < rows ; r++){\\n            for(int c = 0 ; c < cols ; c++){\\n                if(grid[r][c] == 1){\\n                      numOFreshOranges++;\\n                }else if(grid[r][c] == 2){\\n                      q.add(new int[]{r, c});// add all rotten oranges as sources \\n                      visited[r][c] = true;\\n                } \\n            }\\n        }\\n        \\n        \\n        // bfs\\n        int steps = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size ; i++){\\n                 int[] pop =  q.removeFirst();\\n                 int r = pop[0]; int c = pop[1] ;\\n                 \\n                 if(numOFreshOranges == 0 )\\n                    return steps;\\n\\n                for(int[] next:dirs){\\n                 int nextr = r + next[0]; int nextc = c + next[1];\\n                 if( !isOutOFBound(grid , nextr , nextc) && !visited[nextr][nextc] && grid[nextr][nextc] == 1){\\n                    visited[nextr][nextc] = true;\\n                    numOFreshOranges--;\\n                    q.add(new int[]{nextr, nextc});\\n                  }\\n                }\\n           }\\n            steps++; // here please \\n        \\n        }\\n        \\n        return numOFreshOranges == 0 ? steps : -1; // edge case [[0]] -> 0 not -1\\n    }\\n    \\n    private boolean isOutOFBound(int[][] room, int r , int c){\\n        int length = room.length; //#of rows or length\\n        int width = room[0].length; // #of cols\\n        if(r < 0 || r >= length || c < 0 || c >= width ){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "H_An",
                        "content": "At 1 minute:\\n[[2,2,1],\\n [2,1,2],\\n [0,2,2]]\\n\\nAt 2 minute:\\n[[2,2,2],\\n [2,2,2],\\n [0,2,2]]"
                    },
                    {
                        "username": "dpwang",
                        "content": "it\\'s medium question"
                    },
                    {
                        "username": "2uringTested",
                        "content": "To everyone who is wondering if more than one rotten orange is allowed at the beginning or not :\\n\\nYes more than one rotting orange is allowed \\nand it can still be solved with a single BFS run just by inserting all the rotten oranges in the queue at the beginning, also called as multi source BFS."
                    },
                    {
                        "username": "reemantech",
                        "content": "Think of this problem similar to the bfs approach implementation. \\n>How would you differentiate the levels ? \\n>you add `null` after adding the root (or when a level ends)!\\n\\nWhen a level ends you increment the time!"
                    },
                    {
                        "username": "mochiball",
                        "content": "The BFS here is kind of similar to the BFS done on trees. Instead of BFS-ing on each individual orange, we do it level by level "
                    },
                    {
                        "username": "fool_100",
                        "content": " `Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.`\\n\\nThis statement is so confusing , the problem statement is itself not well written .\\n**It should be any fresh orange that is 4-directionally adjacent to any rotten orange becomes rotten at the same time** \\n\\n`That means if there are intially 2 oranges rotten any orange adjacent to it will get rotten at the same time`"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Yes, if there are >1 rotten oranges in the beginning, then we have to scan the grid multiple times. You can check my answer(accepted solution) in the replies of this post (sorted BY BEST)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Average complicated algorithm fan vs average brute force enjoyer\\n\\nBecause the grid is really small, you can very realistically brute force this one lmao"
                    },
                    {
                        "username": "Vithesh",
                        "content": "i dont know why people complicate it. Obviously dfs wont work for such problems. And the movement you think about bfs...the solution is so obvious and simple. i solved this question in like 20min."
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "Please check my code is right, still not giving right answers .. lass Solution {\\n    class pair\\n    {\\n        int row;\\n        int col;\\n        int t;\\n        pair(int r,int c,int t)\\n        {\\n            row=r;col=c;t=t;\\n        }\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        int r=grid.length;\\n        int c=grid[0].length;\\n        int vis[][]=new int[r][c];\\n        Queue<pair> q=new LinkedList<>();\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n               if(grid[i][j]==2)\\n               {\\n                   vis[i][j]=2;\\n                   q.add(new pair(i,j,0));\\n               }\\n               else vis[i][j]=0;\\n            }\\n        }\\n        int mt=0;\\n        int drow[]={-1,1,0,0};\\n        int dcol[]={0,0,-1,1};\\n        while(!q.isEmpty())\\n        {\\n            int r1=q.peek().row;int c1=q.peek().col;int t1=q.peek().t;q.remove();\\n            mt=Math.max(mt,t1);\\n            for(int i=0;i<=3;i++)\\n            {\\n                int nr=r1+drow[i];int nc=c1+dcol[i];\\n                if(nr>=0&&nr<r&&nc>=0&&nc<c)\\n                {\\n                    if(vis[nr][nc]==0&&grid[nr][nc]==1)\\n                    {\\n                        vis[nr][nc]=2;\\n                        q.add(new pair(nr,nc,t1+1));\\n                    }\\n                }\\n            }\\n        }\\n        for (int i = 0; i < r; i++) {\\n    for (int j = 0; j < c; j++) {\\n        if (grid[i][j] == 1 && vis[i][j] == 0) \\n            return -1; \\n    }}\\n        return mt;\\n    }\\n}"
                    },
                    {
                        "username": "kinshuokmunjal",
                        "content": "did you get any solution 304 test cases are running in this and giving a wrong answer on [[2,0],[1,0]] this test case"
                    }
                ]
            },
            {
                "id": 1972347,
                "content": [
                    {
                        "username": "prayag",
                        "content": "Goodluck solving this problem in 30 mins unless you have seen this before."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Mister_CK](/Mister_CK) I have solved almost 173 problems rigth now and dhaven\\'t seen nothing like this at this moment, so it\\'s not a commun problem"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty standart BFS, similar to a lot of to number of islands, biggest island, perimeter of biggest island, fish in pond. So you should have seen something similar before."
                    },
                    {
                        "username": "Aimer101",
                        "content": "The tricky part was if there is multiple rotten oranges, you need to do bfs simultaneously. not the minimum when you do bfs separately on each rotten oranges. nice question though"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yes correct. The BFS will be similar to doing a BFS on trees : layer by layer"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ?\\nIt passed 174 but this test case failed ???\\n\\ngrid =\\n[[2,1,1],[1,1,1],[0,1,2]]\\nOutput\\n1\\nExpected\\n2\\n\\n```\\n\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n    if(grid==null || grid.length == 0) return -1;\\n     int dirs[][] = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean [][] visited = new boolean[rows][cols];\\n        int numOFreshOranges = 0;\\n        int numORottenOranges = 0;\\n\\n        Deque<int[]> q = new ArrayDeque();// r, c, steps\\n        for(int r = 0 ; r < rows ; r++){\\n            for(int c = 0 ; c < cols ; c++){\\n                if(grid[r][c] == 1){\\n                      numOFreshOranges++;\\n                }else if(grid[r][c] == 2){\\n                      q.add(new int[]{r, c});// add all rotten oranges as sources \\n                      visited[r][c] = true;\\n                } \\n            }\\n        }\\n        \\n        \\n        // bfs\\n        int steps = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size ; i++){\\n                 int[] pop =  q.removeFirst();\\n                 int r = pop[0]; int c = pop[1] ;\\n                 \\n                 if(numOFreshOranges == 0 )\\n                    return steps;\\n\\n                for(int[] next:dirs){\\n                 int nextr = r + next[0]; int nextc = c + next[1];\\n                 if( !isOutOFBound(grid , nextr , nextc) && !visited[nextr][nextc] && grid[nextr][nextc] == 1){\\n                    visited[nextr][nextc] = true;\\n                    numOFreshOranges--;\\n                    q.add(new int[]{nextr, nextc});\\n                  }\\n                }\\n           }\\n            steps++; // here please \\n        \\n        }\\n        \\n        return numOFreshOranges == 0 ? steps : -1; // edge case [[0]] -> 0 not -1\\n    }\\n    \\n    private boolean isOutOFBound(int[][] room, int r , int c){\\n        int length = room.length; //#of rows or length\\n        int width = room[0].length; // #of cols\\n        if(r < 0 || r >= length || c < 0 || c >= width ){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "H_An",
                        "content": "At 1 minute:\\n[[2,2,1],\\n [2,1,2],\\n [0,2,2]]\\n\\nAt 2 minute:\\n[[2,2,2],\\n [2,2,2],\\n [0,2,2]]"
                    },
                    {
                        "username": "dpwang",
                        "content": "it\\'s medium question"
                    },
                    {
                        "username": "2uringTested",
                        "content": "To everyone who is wondering if more than one rotten orange is allowed at the beginning or not :\\n\\nYes more than one rotting orange is allowed \\nand it can still be solved with a single BFS run just by inserting all the rotten oranges in the queue at the beginning, also called as multi source BFS."
                    },
                    {
                        "username": "reemantech",
                        "content": "Think of this problem similar to the bfs approach implementation. \\n>How would you differentiate the levels ? \\n>you add `null` after adding the root (or when a level ends)!\\n\\nWhen a level ends you increment the time!"
                    },
                    {
                        "username": "mochiball",
                        "content": "The BFS here is kind of similar to the BFS done on trees. Instead of BFS-ing on each individual orange, we do it level by level "
                    },
                    {
                        "username": "fool_100",
                        "content": " `Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.`\\n\\nThis statement is so confusing , the problem statement is itself not well written .\\n**It should be any fresh orange that is 4-directionally adjacent to any rotten orange becomes rotten at the same time** \\n\\n`That means if there are intially 2 oranges rotten any orange adjacent to it will get rotten at the same time`"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Yes, if there are >1 rotten oranges in the beginning, then we have to scan the grid multiple times. You can check my answer(accepted solution) in the replies of this post (sorted BY BEST)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Average complicated algorithm fan vs average brute force enjoyer\\n\\nBecause the grid is really small, you can very realistically brute force this one lmao"
                    },
                    {
                        "username": "Vithesh",
                        "content": "i dont know why people complicate it. Obviously dfs wont work for such problems. And the movement you think about bfs...the solution is so obvious and simple. i solved this question in like 20min."
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "Please check my code is right, still not giving right answers .. lass Solution {\\n    class pair\\n    {\\n        int row;\\n        int col;\\n        int t;\\n        pair(int r,int c,int t)\\n        {\\n            row=r;col=c;t=t;\\n        }\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        int r=grid.length;\\n        int c=grid[0].length;\\n        int vis[][]=new int[r][c];\\n        Queue<pair> q=new LinkedList<>();\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n               if(grid[i][j]==2)\\n               {\\n                   vis[i][j]=2;\\n                   q.add(new pair(i,j,0));\\n               }\\n               else vis[i][j]=0;\\n            }\\n        }\\n        int mt=0;\\n        int drow[]={-1,1,0,0};\\n        int dcol[]={0,0,-1,1};\\n        while(!q.isEmpty())\\n        {\\n            int r1=q.peek().row;int c1=q.peek().col;int t1=q.peek().t;q.remove();\\n            mt=Math.max(mt,t1);\\n            for(int i=0;i<=3;i++)\\n            {\\n                int nr=r1+drow[i];int nc=c1+dcol[i];\\n                if(nr>=0&&nr<r&&nc>=0&&nc<c)\\n                {\\n                    if(vis[nr][nc]==0&&grid[nr][nc]==1)\\n                    {\\n                        vis[nr][nc]=2;\\n                        q.add(new pair(nr,nc,t1+1));\\n                    }\\n                }\\n            }\\n        }\\n        for (int i = 0; i < r; i++) {\\n    for (int j = 0; j < c; j++) {\\n        if (grid[i][j] == 1 && vis[i][j] == 0) \\n            return -1; \\n    }}\\n        return mt;\\n    }\\n}"
                    },
                    {
                        "username": "kinshuokmunjal",
                        "content": "did you get any solution 304 test cases are running in this and giving a wrong answer on [[2,0],[1,0]] this test case"
                    }
                ]
            },
            {
                "id": 1796687,
                "content": [
                    {
                        "username": "prayag",
                        "content": "Goodluck solving this problem in 30 mins unless you have seen this before."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Mister_CK](/Mister_CK) I have solved almost 173 problems rigth now and dhaven\\'t seen nothing like this at this moment, so it\\'s not a commun problem"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty standart BFS, similar to a lot of to number of islands, biggest island, perimeter of biggest island, fish in pond. So you should have seen something similar before."
                    },
                    {
                        "username": "Aimer101",
                        "content": "The tricky part was if there is multiple rotten oranges, you need to do bfs simultaneously. not the minimum when you do bfs separately on each rotten oranges. nice question though"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yes correct. The BFS will be similar to doing a BFS on trees : layer by layer"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ?\\nIt passed 174 but this test case failed ???\\n\\ngrid =\\n[[2,1,1],[1,1,1],[0,1,2]]\\nOutput\\n1\\nExpected\\n2\\n\\n```\\n\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n    if(grid==null || grid.length == 0) return -1;\\n     int dirs[][] = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean [][] visited = new boolean[rows][cols];\\n        int numOFreshOranges = 0;\\n        int numORottenOranges = 0;\\n\\n        Deque<int[]> q = new ArrayDeque();// r, c, steps\\n        for(int r = 0 ; r < rows ; r++){\\n            for(int c = 0 ; c < cols ; c++){\\n                if(grid[r][c] == 1){\\n                      numOFreshOranges++;\\n                }else if(grid[r][c] == 2){\\n                      q.add(new int[]{r, c});// add all rotten oranges as sources \\n                      visited[r][c] = true;\\n                } \\n            }\\n        }\\n        \\n        \\n        // bfs\\n        int steps = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size ; i++){\\n                 int[] pop =  q.removeFirst();\\n                 int r = pop[0]; int c = pop[1] ;\\n                 \\n                 if(numOFreshOranges == 0 )\\n                    return steps;\\n\\n                for(int[] next:dirs){\\n                 int nextr = r + next[0]; int nextc = c + next[1];\\n                 if( !isOutOFBound(grid , nextr , nextc) && !visited[nextr][nextc] && grid[nextr][nextc] == 1){\\n                    visited[nextr][nextc] = true;\\n                    numOFreshOranges--;\\n                    q.add(new int[]{nextr, nextc});\\n                  }\\n                }\\n           }\\n            steps++; // here please \\n        \\n        }\\n        \\n        return numOFreshOranges == 0 ? steps : -1; // edge case [[0]] -> 0 not -1\\n    }\\n    \\n    private boolean isOutOFBound(int[][] room, int r , int c){\\n        int length = room.length; //#of rows or length\\n        int width = room[0].length; // #of cols\\n        if(r < 0 || r >= length || c < 0 || c >= width ){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "H_An",
                        "content": "At 1 minute:\\n[[2,2,1],\\n [2,1,2],\\n [0,2,2]]\\n\\nAt 2 minute:\\n[[2,2,2],\\n [2,2,2],\\n [0,2,2]]"
                    },
                    {
                        "username": "dpwang",
                        "content": "it\\'s medium question"
                    },
                    {
                        "username": "2uringTested",
                        "content": "To everyone who is wondering if more than one rotten orange is allowed at the beginning or not :\\n\\nYes more than one rotting orange is allowed \\nand it can still be solved with a single BFS run just by inserting all the rotten oranges in the queue at the beginning, also called as multi source BFS."
                    },
                    {
                        "username": "reemantech",
                        "content": "Think of this problem similar to the bfs approach implementation. \\n>How would you differentiate the levels ? \\n>you add `null` after adding the root (or when a level ends)!\\n\\nWhen a level ends you increment the time!"
                    },
                    {
                        "username": "mochiball",
                        "content": "The BFS here is kind of similar to the BFS done on trees. Instead of BFS-ing on each individual orange, we do it level by level "
                    },
                    {
                        "username": "fool_100",
                        "content": " `Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.`\\n\\nThis statement is so confusing , the problem statement is itself not well written .\\n**It should be any fresh orange that is 4-directionally adjacent to any rotten orange becomes rotten at the same time** \\n\\n`That means if there are intially 2 oranges rotten any orange adjacent to it will get rotten at the same time`"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Yes, if there are >1 rotten oranges in the beginning, then we have to scan the grid multiple times. You can check my answer(accepted solution) in the replies of this post (sorted BY BEST)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Average complicated algorithm fan vs average brute force enjoyer\\n\\nBecause the grid is really small, you can very realistically brute force this one lmao"
                    },
                    {
                        "username": "Vithesh",
                        "content": "i dont know why people complicate it. Obviously dfs wont work for such problems. And the movement you think about bfs...the solution is so obvious and simple. i solved this question in like 20min."
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "Please check my code is right, still not giving right answers .. lass Solution {\\n    class pair\\n    {\\n        int row;\\n        int col;\\n        int t;\\n        pair(int r,int c,int t)\\n        {\\n            row=r;col=c;t=t;\\n        }\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        int r=grid.length;\\n        int c=grid[0].length;\\n        int vis[][]=new int[r][c];\\n        Queue<pair> q=new LinkedList<>();\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n               if(grid[i][j]==2)\\n               {\\n                   vis[i][j]=2;\\n                   q.add(new pair(i,j,0));\\n               }\\n               else vis[i][j]=0;\\n            }\\n        }\\n        int mt=0;\\n        int drow[]={-1,1,0,0};\\n        int dcol[]={0,0,-1,1};\\n        while(!q.isEmpty())\\n        {\\n            int r1=q.peek().row;int c1=q.peek().col;int t1=q.peek().t;q.remove();\\n            mt=Math.max(mt,t1);\\n            for(int i=0;i<=3;i++)\\n            {\\n                int nr=r1+drow[i];int nc=c1+dcol[i];\\n                if(nr>=0&&nr<r&&nc>=0&&nc<c)\\n                {\\n                    if(vis[nr][nc]==0&&grid[nr][nc]==1)\\n                    {\\n                        vis[nr][nc]=2;\\n                        q.add(new pair(nr,nc,t1+1));\\n                    }\\n                }\\n            }\\n        }\\n        for (int i = 0; i < r; i++) {\\n    for (int j = 0; j < c; j++) {\\n        if (grid[i][j] == 1 && vis[i][j] == 0) \\n            return -1; \\n    }}\\n        return mt;\\n    }\\n}"
                    },
                    {
                        "username": "kinshuokmunjal",
                        "content": "did you get any solution 304 test cases are running in this and giving a wrong answer on [[2,0],[1,0]] this test case"
                    }
                ]
            },
            {
                "id": 1719170,
                "content": [
                    {
                        "username": "prayag",
                        "content": "Goodluck solving this problem in 30 mins unless you have seen this before."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Mister_CK](/Mister_CK) I have solved almost 173 problems rigth now and dhaven\\'t seen nothing like this at this moment, so it\\'s not a commun problem"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty standart BFS, similar to a lot of to number of islands, biggest island, perimeter of biggest island, fish in pond. So you should have seen something similar before."
                    },
                    {
                        "username": "Aimer101",
                        "content": "The tricky part was if there is multiple rotten oranges, you need to do bfs simultaneously. not the minimum when you do bfs separately on each rotten oranges. nice question though"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yes correct. The BFS will be similar to doing a BFS on trees : layer by layer"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ?\\nIt passed 174 but this test case failed ???\\n\\ngrid =\\n[[2,1,1],[1,1,1],[0,1,2]]\\nOutput\\n1\\nExpected\\n2\\n\\n```\\n\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n    if(grid==null || grid.length == 0) return -1;\\n     int dirs[][] = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean [][] visited = new boolean[rows][cols];\\n        int numOFreshOranges = 0;\\n        int numORottenOranges = 0;\\n\\n        Deque<int[]> q = new ArrayDeque();// r, c, steps\\n        for(int r = 0 ; r < rows ; r++){\\n            for(int c = 0 ; c < cols ; c++){\\n                if(grid[r][c] == 1){\\n                      numOFreshOranges++;\\n                }else if(grid[r][c] == 2){\\n                      q.add(new int[]{r, c});// add all rotten oranges as sources \\n                      visited[r][c] = true;\\n                } \\n            }\\n        }\\n        \\n        \\n        // bfs\\n        int steps = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size ; i++){\\n                 int[] pop =  q.removeFirst();\\n                 int r = pop[0]; int c = pop[1] ;\\n                 \\n                 if(numOFreshOranges == 0 )\\n                    return steps;\\n\\n                for(int[] next:dirs){\\n                 int nextr = r + next[0]; int nextc = c + next[1];\\n                 if( !isOutOFBound(grid , nextr , nextc) && !visited[nextr][nextc] && grid[nextr][nextc] == 1){\\n                    visited[nextr][nextc] = true;\\n                    numOFreshOranges--;\\n                    q.add(new int[]{nextr, nextc});\\n                  }\\n                }\\n           }\\n            steps++; // here please \\n        \\n        }\\n        \\n        return numOFreshOranges == 0 ? steps : -1; // edge case [[0]] -> 0 not -1\\n    }\\n    \\n    private boolean isOutOFBound(int[][] room, int r , int c){\\n        int length = room.length; //#of rows or length\\n        int width = room[0].length; // #of cols\\n        if(r < 0 || r >= length || c < 0 || c >= width ){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "H_An",
                        "content": "At 1 minute:\\n[[2,2,1],\\n [2,1,2],\\n [0,2,2]]\\n\\nAt 2 minute:\\n[[2,2,2],\\n [2,2,2],\\n [0,2,2]]"
                    },
                    {
                        "username": "dpwang",
                        "content": "it\\'s medium question"
                    },
                    {
                        "username": "2uringTested",
                        "content": "To everyone who is wondering if more than one rotten orange is allowed at the beginning or not :\\n\\nYes more than one rotting orange is allowed \\nand it can still be solved with a single BFS run just by inserting all the rotten oranges in the queue at the beginning, also called as multi source BFS."
                    },
                    {
                        "username": "reemantech",
                        "content": "Think of this problem similar to the bfs approach implementation. \\n>How would you differentiate the levels ? \\n>you add `null` after adding the root (or when a level ends)!\\n\\nWhen a level ends you increment the time!"
                    },
                    {
                        "username": "mochiball",
                        "content": "The BFS here is kind of similar to the BFS done on trees. Instead of BFS-ing on each individual orange, we do it level by level "
                    },
                    {
                        "username": "fool_100",
                        "content": " `Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.`\\n\\nThis statement is so confusing , the problem statement is itself not well written .\\n**It should be any fresh orange that is 4-directionally adjacent to any rotten orange becomes rotten at the same time** \\n\\n`That means if there are intially 2 oranges rotten any orange adjacent to it will get rotten at the same time`"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Yes, if there are >1 rotten oranges in the beginning, then we have to scan the grid multiple times. You can check my answer(accepted solution) in the replies of this post (sorted BY BEST)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Average complicated algorithm fan vs average brute force enjoyer\\n\\nBecause the grid is really small, you can very realistically brute force this one lmao"
                    },
                    {
                        "username": "Vithesh",
                        "content": "i dont know why people complicate it. Obviously dfs wont work for such problems. And the movement you think about bfs...the solution is so obvious and simple. i solved this question in like 20min."
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "Please check my code is right, still not giving right answers .. lass Solution {\\n    class pair\\n    {\\n        int row;\\n        int col;\\n        int t;\\n        pair(int r,int c,int t)\\n        {\\n            row=r;col=c;t=t;\\n        }\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        int r=grid.length;\\n        int c=grid[0].length;\\n        int vis[][]=new int[r][c];\\n        Queue<pair> q=new LinkedList<>();\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n               if(grid[i][j]==2)\\n               {\\n                   vis[i][j]=2;\\n                   q.add(new pair(i,j,0));\\n               }\\n               else vis[i][j]=0;\\n            }\\n        }\\n        int mt=0;\\n        int drow[]={-1,1,0,0};\\n        int dcol[]={0,0,-1,1};\\n        while(!q.isEmpty())\\n        {\\n            int r1=q.peek().row;int c1=q.peek().col;int t1=q.peek().t;q.remove();\\n            mt=Math.max(mt,t1);\\n            for(int i=0;i<=3;i++)\\n            {\\n                int nr=r1+drow[i];int nc=c1+dcol[i];\\n                if(nr>=0&&nr<r&&nc>=0&&nc<c)\\n                {\\n                    if(vis[nr][nc]==0&&grid[nr][nc]==1)\\n                    {\\n                        vis[nr][nc]=2;\\n                        q.add(new pair(nr,nc,t1+1));\\n                    }\\n                }\\n            }\\n        }\\n        for (int i = 0; i < r; i++) {\\n    for (int j = 0; j < c; j++) {\\n        if (grid[i][j] == 1 && vis[i][j] == 0) \\n            return -1; \\n    }}\\n        return mt;\\n    }\\n}"
                    },
                    {
                        "username": "kinshuokmunjal",
                        "content": "did you get any solution 304 test cases are running in this and giving a wrong answer on [[2,0],[1,0]] this test case"
                    }
                ]
            },
            {
                "id": 2062374,
                "content": [
                    {
                        "username": "prayag",
                        "content": "Goodluck solving this problem in 30 mins unless you have seen this before."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Mister_CK](/Mister_CK) I have solved almost 173 problems rigth now and dhaven\\'t seen nothing like this at this moment, so it\\'s not a commun problem"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty standart BFS, similar to a lot of to number of islands, biggest island, perimeter of biggest island, fish in pond. So you should have seen something similar before."
                    },
                    {
                        "username": "Aimer101",
                        "content": "The tricky part was if there is multiple rotten oranges, you need to do bfs simultaneously. not the minimum when you do bfs separately on each rotten oranges. nice question though"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yes correct. The BFS will be similar to doing a BFS on trees : layer by layer"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ?\\nIt passed 174 but this test case failed ???\\n\\ngrid =\\n[[2,1,1],[1,1,1],[0,1,2]]\\nOutput\\n1\\nExpected\\n2\\n\\n```\\n\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n    if(grid==null || grid.length == 0) return -1;\\n     int dirs[][] = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean [][] visited = new boolean[rows][cols];\\n        int numOFreshOranges = 0;\\n        int numORottenOranges = 0;\\n\\n        Deque<int[]> q = new ArrayDeque();// r, c, steps\\n        for(int r = 0 ; r < rows ; r++){\\n            for(int c = 0 ; c < cols ; c++){\\n                if(grid[r][c] == 1){\\n                      numOFreshOranges++;\\n                }else if(grid[r][c] == 2){\\n                      q.add(new int[]{r, c});// add all rotten oranges as sources \\n                      visited[r][c] = true;\\n                } \\n            }\\n        }\\n        \\n        \\n        // bfs\\n        int steps = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size ; i++){\\n                 int[] pop =  q.removeFirst();\\n                 int r = pop[0]; int c = pop[1] ;\\n                 \\n                 if(numOFreshOranges == 0 )\\n                    return steps;\\n\\n                for(int[] next:dirs){\\n                 int nextr = r + next[0]; int nextc = c + next[1];\\n                 if( !isOutOFBound(grid , nextr , nextc) && !visited[nextr][nextc] && grid[nextr][nextc] == 1){\\n                    visited[nextr][nextc] = true;\\n                    numOFreshOranges--;\\n                    q.add(new int[]{nextr, nextc});\\n                  }\\n                }\\n           }\\n            steps++; // here please \\n        \\n        }\\n        \\n        return numOFreshOranges == 0 ? steps : -1; // edge case [[0]] -> 0 not -1\\n    }\\n    \\n    private boolean isOutOFBound(int[][] room, int r , int c){\\n        int length = room.length; //#of rows or length\\n        int width = room[0].length; // #of cols\\n        if(r < 0 || r >= length || c < 0 || c >= width ){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "H_An",
                        "content": "At 1 minute:\\n[[2,2,1],\\n [2,1,2],\\n [0,2,2]]\\n\\nAt 2 minute:\\n[[2,2,2],\\n [2,2,2],\\n [0,2,2]]"
                    },
                    {
                        "username": "dpwang",
                        "content": "it\\'s medium question"
                    },
                    {
                        "username": "2uringTested",
                        "content": "To everyone who is wondering if more than one rotten orange is allowed at the beginning or not :\\n\\nYes more than one rotting orange is allowed \\nand it can still be solved with a single BFS run just by inserting all the rotten oranges in the queue at the beginning, also called as multi source BFS."
                    },
                    {
                        "username": "reemantech",
                        "content": "Think of this problem similar to the bfs approach implementation. \\n>How would you differentiate the levels ? \\n>you add `null` after adding the root (or when a level ends)!\\n\\nWhen a level ends you increment the time!"
                    },
                    {
                        "username": "mochiball",
                        "content": "The BFS here is kind of similar to the BFS done on trees. Instead of BFS-ing on each individual orange, we do it level by level "
                    },
                    {
                        "username": "fool_100",
                        "content": " `Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.`\\n\\nThis statement is so confusing , the problem statement is itself not well written .\\n**It should be any fresh orange that is 4-directionally adjacent to any rotten orange becomes rotten at the same time** \\n\\n`That means if there are intially 2 oranges rotten any orange adjacent to it will get rotten at the same time`"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Yes, if there are >1 rotten oranges in the beginning, then we have to scan the grid multiple times. You can check my answer(accepted solution) in the replies of this post (sorted BY BEST)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Average complicated algorithm fan vs average brute force enjoyer\\n\\nBecause the grid is really small, you can very realistically brute force this one lmao"
                    },
                    {
                        "username": "Vithesh",
                        "content": "i dont know why people complicate it. Obviously dfs wont work for such problems. And the movement you think about bfs...the solution is so obvious and simple. i solved this question in like 20min."
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "Please check my code is right, still not giving right answers .. lass Solution {\\n    class pair\\n    {\\n        int row;\\n        int col;\\n        int t;\\n        pair(int r,int c,int t)\\n        {\\n            row=r;col=c;t=t;\\n        }\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        int r=grid.length;\\n        int c=grid[0].length;\\n        int vis[][]=new int[r][c];\\n        Queue<pair> q=new LinkedList<>();\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n               if(grid[i][j]==2)\\n               {\\n                   vis[i][j]=2;\\n                   q.add(new pair(i,j,0));\\n               }\\n               else vis[i][j]=0;\\n            }\\n        }\\n        int mt=0;\\n        int drow[]={-1,1,0,0};\\n        int dcol[]={0,0,-1,1};\\n        while(!q.isEmpty())\\n        {\\n            int r1=q.peek().row;int c1=q.peek().col;int t1=q.peek().t;q.remove();\\n            mt=Math.max(mt,t1);\\n            for(int i=0;i<=3;i++)\\n            {\\n                int nr=r1+drow[i];int nc=c1+dcol[i];\\n                if(nr>=0&&nr<r&&nc>=0&&nc<c)\\n                {\\n                    if(vis[nr][nc]==0&&grid[nr][nc]==1)\\n                    {\\n                        vis[nr][nc]=2;\\n                        q.add(new pair(nr,nc,t1+1));\\n                    }\\n                }\\n            }\\n        }\\n        for (int i = 0; i < r; i++) {\\n    for (int j = 0; j < c; j++) {\\n        if (grid[i][j] == 1 && vis[i][j] == 0) \\n            return -1; \\n    }}\\n        return mt;\\n    }\\n}"
                    },
                    {
                        "username": "kinshuokmunjal",
                        "content": "did you get any solution 304 test cases are running in this and giving a wrong answer on [[2,0],[1,0]] this test case"
                    }
                ]
            },
            {
                "id": 2055019,
                "content": [
                    {
                        "username": "prayag",
                        "content": "Goodluck solving this problem in 30 mins unless you have seen this before."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Mister_CK](/Mister_CK) I have solved almost 173 problems rigth now and dhaven\\'t seen nothing like this at this moment, so it\\'s not a commun problem"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty standart BFS, similar to a lot of to number of islands, biggest island, perimeter of biggest island, fish in pond. So you should have seen something similar before."
                    },
                    {
                        "username": "Aimer101",
                        "content": "The tricky part was if there is multiple rotten oranges, you need to do bfs simultaneously. not the minimum when you do bfs separately on each rotten oranges. nice question though"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yes correct. The BFS will be similar to doing a BFS on trees : layer by layer"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ?\\nIt passed 174 but this test case failed ???\\n\\ngrid =\\n[[2,1,1],[1,1,1],[0,1,2]]\\nOutput\\n1\\nExpected\\n2\\n\\n```\\n\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n    if(grid==null || grid.length == 0) return -1;\\n     int dirs[][] = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean [][] visited = new boolean[rows][cols];\\n        int numOFreshOranges = 0;\\n        int numORottenOranges = 0;\\n\\n        Deque<int[]> q = new ArrayDeque();// r, c, steps\\n        for(int r = 0 ; r < rows ; r++){\\n            for(int c = 0 ; c < cols ; c++){\\n                if(grid[r][c] == 1){\\n                      numOFreshOranges++;\\n                }else if(grid[r][c] == 2){\\n                      q.add(new int[]{r, c});// add all rotten oranges as sources \\n                      visited[r][c] = true;\\n                } \\n            }\\n        }\\n        \\n        \\n        // bfs\\n        int steps = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size ; i++){\\n                 int[] pop =  q.removeFirst();\\n                 int r = pop[0]; int c = pop[1] ;\\n                 \\n                 if(numOFreshOranges == 0 )\\n                    return steps;\\n\\n                for(int[] next:dirs){\\n                 int nextr = r + next[0]; int nextc = c + next[1];\\n                 if( !isOutOFBound(grid , nextr , nextc) && !visited[nextr][nextc] && grid[nextr][nextc] == 1){\\n                    visited[nextr][nextc] = true;\\n                    numOFreshOranges--;\\n                    q.add(new int[]{nextr, nextc});\\n                  }\\n                }\\n           }\\n            steps++; // here please \\n        \\n        }\\n        \\n        return numOFreshOranges == 0 ? steps : -1; // edge case [[0]] -> 0 not -1\\n    }\\n    \\n    private boolean isOutOFBound(int[][] room, int r , int c){\\n        int length = room.length; //#of rows or length\\n        int width = room[0].length; // #of cols\\n        if(r < 0 || r >= length || c < 0 || c >= width ){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "H_An",
                        "content": "At 1 minute:\\n[[2,2,1],\\n [2,1,2],\\n [0,2,2]]\\n\\nAt 2 minute:\\n[[2,2,2],\\n [2,2,2],\\n [0,2,2]]"
                    },
                    {
                        "username": "dpwang",
                        "content": "it\\'s medium question"
                    },
                    {
                        "username": "2uringTested",
                        "content": "To everyone who is wondering if more than one rotten orange is allowed at the beginning or not :\\n\\nYes more than one rotting orange is allowed \\nand it can still be solved with a single BFS run just by inserting all the rotten oranges in the queue at the beginning, also called as multi source BFS."
                    },
                    {
                        "username": "reemantech",
                        "content": "Think of this problem similar to the bfs approach implementation. \\n>How would you differentiate the levels ? \\n>you add `null` after adding the root (or when a level ends)!\\n\\nWhen a level ends you increment the time!"
                    },
                    {
                        "username": "mochiball",
                        "content": "The BFS here is kind of similar to the BFS done on trees. Instead of BFS-ing on each individual orange, we do it level by level "
                    },
                    {
                        "username": "fool_100",
                        "content": " `Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.`\\n\\nThis statement is so confusing , the problem statement is itself not well written .\\n**It should be any fresh orange that is 4-directionally adjacent to any rotten orange becomes rotten at the same time** \\n\\n`That means if there are intially 2 oranges rotten any orange adjacent to it will get rotten at the same time`"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Yes, if there are >1 rotten oranges in the beginning, then we have to scan the grid multiple times. You can check my answer(accepted solution) in the replies of this post (sorted BY BEST)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Average complicated algorithm fan vs average brute force enjoyer\\n\\nBecause the grid is really small, you can very realistically brute force this one lmao"
                    },
                    {
                        "username": "Vithesh",
                        "content": "i dont know why people complicate it. Obviously dfs wont work for such problems. And the movement you think about bfs...the solution is so obvious and simple. i solved this question in like 20min."
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "Please check my code is right, still not giving right answers .. lass Solution {\\n    class pair\\n    {\\n        int row;\\n        int col;\\n        int t;\\n        pair(int r,int c,int t)\\n        {\\n            row=r;col=c;t=t;\\n        }\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        int r=grid.length;\\n        int c=grid[0].length;\\n        int vis[][]=new int[r][c];\\n        Queue<pair> q=new LinkedList<>();\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n               if(grid[i][j]==2)\\n               {\\n                   vis[i][j]=2;\\n                   q.add(new pair(i,j,0));\\n               }\\n               else vis[i][j]=0;\\n            }\\n        }\\n        int mt=0;\\n        int drow[]={-1,1,0,0};\\n        int dcol[]={0,0,-1,1};\\n        while(!q.isEmpty())\\n        {\\n            int r1=q.peek().row;int c1=q.peek().col;int t1=q.peek().t;q.remove();\\n            mt=Math.max(mt,t1);\\n            for(int i=0;i<=3;i++)\\n            {\\n                int nr=r1+drow[i];int nc=c1+dcol[i];\\n                if(nr>=0&&nr<r&&nc>=0&&nc<c)\\n                {\\n                    if(vis[nr][nc]==0&&grid[nr][nc]==1)\\n                    {\\n                        vis[nr][nc]=2;\\n                        q.add(new pair(nr,nc,t1+1));\\n                    }\\n                }\\n            }\\n        }\\n        for (int i = 0; i < r; i++) {\\n    for (int j = 0; j < c; j++) {\\n        if (grid[i][j] == 1 && vis[i][j] == 0) \\n            return -1; \\n    }}\\n        return mt;\\n    }\\n}"
                    },
                    {
                        "username": "kinshuokmunjal",
                        "content": "did you get any solution 304 test cases are running in this and giving a wrong answer on [[2,0],[1,0]] this test case"
                    }
                ]
            },
            {
                "id": 2036241,
                "content": [
                    {
                        "username": "prayag",
                        "content": "Goodluck solving this problem in 30 mins unless you have seen this before."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Mister_CK](/Mister_CK) I have solved almost 173 problems rigth now and dhaven\\'t seen nothing like this at this moment, so it\\'s not a commun problem"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty standart BFS, similar to a lot of to number of islands, biggest island, perimeter of biggest island, fish in pond. So you should have seen something similar before."
                    },
                    {
                        "username": "Aimer101",
                        "content": "The tricky part was if there is multiple rotten oranges, you need to do bfs simultaneously. not the minimum when you do bfs separately on each rotten oranges. nice question though"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yes correct. The BFS will be similar to doing a BFS on trees : layer by layer"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ?\\nIt passed 174 but this test case failed ???\\n\\ngrid =\\n[[2,1,1],[1,1,1],[0,1,2]]\\nOutput\\n1\\nExpected\\n2\\n\\n```\\n\\nclass Solution {\\n    public int orangesRotting(int[][] grid) {\\n    if(grid==null || grid.length == 0) return -1;\\n     int dirs[][] = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean [][] visited = new boolean[rows][cols];\\n        int numOFreshOranges = 0;\\n        int numORottenOranges = 0;\\n\\n        Deque<int[]> q = new ArrayDeque();// r, c, steps\\n        for(int r = 0 ; r < rows ; r++){\\n            for(int c = 0 ; c < cols ; c++){\\n                if(grid[r][c] == 1){\\n                      numOFreshOranges++;\\n                }else if(grid[r][c] == 2){\\n                      q.add(new int[]{r, c});// add all rotten oranges as sources \\n                      visited[r][c] = true;\\n                } \\n            }\\n        }\\n        \\n        \\n        // bfs\\n        int steps = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size ; i++){\\n                 int[] pop =  q.removeFirst();\\n                 int r = pop[0]; int c = pop[1] ;\\n                 \\n                 if(numOFreshOranges == 0 )\\n                    return steps;\\n\\n                for(int[] next:dirs){\\n                 int nextr = r + next[0]; int nextc = c + next[1];\\n                 if( !isOutOFBound(grid , nextr , nextc) && !visited[nextr][nextc] && grid[nextr][nextc] == 1){\\n                    visited[nextr][nextc] = true;\\n                    numOFreshOranges--;\\n                    q.add(new int[]{nextr, nextc});\\n                  }\\n                }\\n           }\\n            steps++; // here please \\n        \\n        }\\n        \\n        return numOFreshOranges == 0 ? steps : -1; // edge case [[0]] -> 0 not -1\\n    }\\n    \\n    private boolean isOutOFBound(int[][] room, int r , int c){\\n        int length = room.length; //#of rows or length\\n        int width = room[0].length; // #of cols\\n        if(r < 0 || r >= length || c < 0 || c >= width ){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "H_An",
                        "content": "At 1 minute:\\n[[2,2,1],\\n [2,1,2],\\n [0,2,2]]\\n\\nAt 2 minute:\\n[[2,2,2],\\n [2,2,2],\\n [0,2,2]]"
                    },
                    {
                        "username": "dpwang",
                        "content": "it\\'s medium question"
                    },
                    {
                        "username": "2uringTested",
                        "content": "To everyone who is wondering if more than one rotten orange is allowed at the beginning or not :\\n\\nYes more than one rotting orange is allowed \\nand it can still be solved with a single BFS run just by inserting all the rotten oranges in the queue at the beginning, also called as multi source BFS."
                    },
                    {
                        "username": "reemantech",
                        "content": "Think of this problem similar to the bfs approach implementation. \\n>How would you differentiate the levels ? \\n>you add `null` after adding the root (or when a level ends)!\\n\\nWhen a level ends you increment the time!"
                    },
                    {
                        "username": "mochiball",
                        "content": "The BFS here is kind of similar to the BFS done on trees. Instead of BFS-ing on each individual orange, we do it level by level "
                    },
                    {
                        "username": "fool_100",
                        "content": " `Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.`\\n\\nThis statement is so confusing , the problem statement is itself not well written .\\n**It should be any fresh orange that is 4-directionally adjacent to any rotten orange becomes rotten at the same time** \\n\\n`That means if there are intially 2 oranges rotten any orange adjacent to it will get rotten at the same time`"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Yes, if there are >1 rotten oranges in the beginning, then we have to scan the grid multiple times. You can check my answer(accepted solution) in the replies of this post (sorted BY BEST)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Average complicated algorithm fan vs average brute force enjoyer\\n\\nBecause the grid is really small, you can very realistically brute force this one lmao"
                    },
                    {
                        "username": "Vithesh",
                        "content": "i dont know why people complicate it. Obviously dfs wont work for such problems. And the movement you think about bfs...the solution is so obvious and simple. i solved this question in like 20min."
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "Please check my code is right, still not giving right answers .. lass Solution {\\n    class pair\\n    {\\n        int row;\\n        int col;\\n        int t;\\n        pair(int r,int c,int t)\\n        {\\n            row=r;col=c;t=t;\\n        }\\n    }\\n    public int orangesRotting(int[][] grid) {\\n        int r=grid.length;\\n        int c=grid[0].length;\\n        int vis[][]=new int[r][c];\\n        Queue<pair> q=new LinkedList<>();\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n               if(grid[i][j]==2)\\n               {\\n                   vis[i][j]=2;\\n                   q.add(new pair(i,j,0));\\n               }\\n               else vis[i][j]=0;\\n            }\\n        }\\n        int mt=0;\\n        int drow[]={-1,1,0,0};\\n        int dcol[]={0,0,-1,1};\\n        while(!q.isEmpty())\\n        {\\n            int r1=q.peek().row;int c1=q.peek().col;int t1=q.peek().t;q.remove();\\n            mt=Math.max(mt,t1);\\n            for(int i=0;i<=3;i++)\\n            {\\n                int nr=r1+drow[i];int nc=c1+dcol[i];\\n                if(nr>=0&&nr<r&&nc>=0&&nc<c)\\n                {\\n                    if(vis[nr][nc]==0&&grid[nr][nc]==1)\\n                    {\\n                        vis[nr][nc]=2;\\n                        q.add(new pair(nr,nc,t1+1));\\n                    }\\n                }\\n            }\\n        }\\n        for (int i = 0; i < r; i++) {\\n    for (int j = 0; j < c; j++) {\\n        if (grid[i][j] == 1 && vis[i][j] == 0) \\n            return -1; \\n    }}\\n        return mt;\\n    }\\n}"
                    },
                    {
                        "username": "kinshuokmunjal",
                        "content": "did you get any solution 304 test cases are running in this and giving a wrong answer on [[2,0],[1,0]] this test case"
                    }
                ]
            },
            {
                "id": 2025528,
                "content": [
                    {
                        "username": "sarthakagarwal4043",
                        "content": "We can use multisource BFS in this case"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Does the question mean we have only at max 1 Rotten orange ( initially )?   "
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "No there can be any number of rotten oranges initially, the whole grid can be rotten oranges too which has an output of 0\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "BFS is easier for this problem. This problem is very annoying and the mistake I made was starting a BFS at the first rotten orange I found, when in reality I should have started a queue and added all the rotten ones, THEN perform BFS layer by layer "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Coding is like ripening oranges; it takes time for the rot to spread. With an optimized BFS approach, even the most challenging grids can yield their secrets efficiently, revealing the minimum time needed to turn all oranges rotten.***"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, BFS , Optimized code. Proper algorithm commented.\\n\\nApproach\\nObtain the number of rows of the grid and assign it to the variable \"m\".\\nObtain the number of columns of the grid and assign it to the variable \"n\".\\nCreate an empty queue named \"q\" to store the coordinates of rotten oranges.\\nCreate a 2D vector \"vis\" of size m x n and initialize all elements to 0.\\nThis vector will be used to track visited oranges.\\nIterate through each cell in the grid using two nested loops:\\na. If the current cell contains a rotten orange (with a value of 2),\\nmark it as visited (set vis[i][j] to 1) and push its coordinates\\n(level 0, row i, column j) to the queue.\\nCreate two arrays, \"rN\" and \"cN,\" to represent the relative positions\\nof neighboring cells: {-1, 0, 1, 0} and {0, 1, 0, -1}, respectively.\\nInitialize a variable \"ans\" to 0, which will store the minimum\\ntime required for all oranges to rot.\\nPerform a breadth-first search (BFS) while the queue is not empty:\\na. Dequeue the front element of the queue and assign its level,\\nrow, and column values to variables \"lvl,\" \"row,\" and \"col,\" respectively.\\nb. Iterate through all possible neighboring cells:\\ni. Calculate the coordinates of the neighbor using the formula:\\nrV = row + rN[i] and cV = col + cN[i].\\nii. Check if the calculated coordinates are within the grid\\nboundaries (0 <= rV < m and 0 <= cV < n) and the cell contains\\na fresh orange (with a value of 1) that has not been visited (vis[rV][cV] == 0).\\n- If the conditions are satisfied, enqueue the neighbor\\'s coordinates\\n(level lvl+1, row rV, column cV) to the queue and mark it\\nas visited (set vis[rV][cV] to 1).\\nc. Update \"ans\" to the maximum value between \"ans\" and \"lvl\" to\\nkeep track of the maximum time taken to rot all oranges.\\nAfter the BFS is complete, iterate through all cells in the grid:\\na. If a fresh orange (with a value of 1) is found and it has not\\nbeen visited (vis[i][j] == 0), return -1 to indicate that it is impossible to rot all oranges.\\nReturn the value of \"ans\" as the minimum time required to rot all oranges.\\nComplexity\\nTime complexity:\\nT.C=O(m*n) because we have to iterate whole matrix.\\n\\nSpace complexity:\\nS.C=O(m*n) because In worst case whole matrix contain Rotten orange.\\nSo we have to store all in queue.\\n\\n-------------------------------------------------------\\nPlease Upvote if understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/rotting-oranges/solutions/3661472/c-bfs-optimized-code-proper-algorithm-commented/"
                    },
                    {
                        "username": "Pranjal2608",
                        "content": "I have written this code using bfs traversal but getting the wrong output pls help\\nclass Solution {\\n    int bfs(vector<vector<int>>& grid,vector<vector<int>>& vis, int row, int col,int& freshOranges) {\\n    int m=grid.size();\\n    int n=grid[0].size();\\n    queue<pair<int,int>> q;\\n    int lim=0;\\n    q.push({row,col});\\n    int offsets[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  \\n    while(!q.empty()){\\n        int row=q.front().first;\\n        int col=q.front().second;    \\n        q.pop();\\n        for (int i = 0; i < 4; i++) {\\n            int newRow = row + offsets[i][0];\\n            int newCol = col + offsets[i][1];        \\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && grid[newRow][newCol]==1) {\\n                    grid[newRow][newCol]=2;\\n                    freshOranges--;\\n                    vis[newRow][newCol]=1;\\n                    q.push({newRow,newCol});\\n                   \\n                        \\n            }\\n        }\\n        lim++;\\n    }  \\n    if(freshOranges==0){\\n       return lim;\\n    }\\n    return -1; \\n}\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> vis(m,vector<int>(n,0));  \\n        int freshOranges = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1)\\n                    freshOranges++;\\n            }\\n        }     \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && grid[i][j]==2){\\n                    vis[i][j]=1;\\n                  count=bfs(grid,vis,i,j,freshOranges);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sahilbheke",
                        "content": "Why this code is producing runtime error please help me #LeetCode #Community\\nclass Solution {\\npublic:\\n\\n    void solve(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& vis, int ans){\\n        if( vis[i][j] == 1 || i < 0 || j < 0 || i >= grid.size() \\n            || j >= grid[0].size() || grid[i][j] == 0)\\n            return;\\n\\n        vis[i][j] = 1;\\n        // if(grid[i][j] == 2)\\n        grid[i][j] = 2;\\n\\n        solve(grid, i+1, j, vis, ans);\\n        solve(grid, i, j+1, vis, ans);\\n        solve(grid, i-1, j, vis, ans);\\n        solve(grid, i, j-1, vis, ans);\\n        ans++;\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int> (n, 0));\\n        int ans = 2;\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && grid[i][j] == 2){\\n                    solve(grid, i, j, vis, ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "but how to get minimum time,\\nfor the first test case example 5 is also the time."
                    },
                    {
                        "username": "thawesu",
                        "content": "Hmm.\\nConstraint:  grid[i][j] is 0, 1, or 2.\\nTestcase : [[1],[2]] \\nExpected output 1\\n"
                    },
                    {
                        "username": "oleg_vasilev",
                        "content": "You don\\'t need any depth-first or breadth-first search, it is much easier. \\ntip: Take a look at classic Conway\\'s \"Game of Life\".\\n"
                    }
                ]
            },
            {
                "id": 2017847,
                "content": [
                    {
                        "username": "sarthakagarwal4043",
                        "content": "We can use multisource BFS in this case"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Does the question mean we have only at max 1 Rotten orange ( initially )?   "
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "No there can be any number of rotten oranges initially, the whole grid can be rotten oranges too which has an output of 0\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "BFS is easier for this problem. This problem is very annoying and the mistake I made was starting a BFS at the first rotten orange I found, when in reality I should have started a queue and added all the rotten ones, THEN perform BFS layer by layer "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Coding is like ripening oranges; it takes time for the rot to spread. With an optimized BFS approach, even the most challenging grids can yield their secrets efficiently, revealing the minimum time needed to turn all oranges rotten.***"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, BFS , Optimized code. Proper algorithm commented.\\n\\nApproach\\nObtain the number of rows of the grid and assign it to the variable \"m\".\\nObtain the number of columns of the grid and assign it to the variable \"n\".\\nCreate an empty queue named \"q\" to store the coordinates of rotten oranges.\\nCreate a 2D vector \"vis\" of size m x n and initialize all elements to 0.\\nThis vector will be used to track visited oranges.\\nIterate through each cell in the grid using two nested loops:\\na. If the current cell contains a rotten orange (with a value of 2),\\nmark it as visited (set vis[i][j] to 1) and push its coordinates\\n(level 0, row i, column j) to the queue.\\nCreate two arrays, \"rN\" and \"cN,\" to represent the relative positions\\nof neighboring cells: {-1, 0, 1, 0} and {0, 1, 0, -1}, respectively.\\nInitialize a variable \"ans\" to 0, which will store the minimum\\ntime required for all oranges to rot.\\nPerform a breadth-first search (BFS) while the queue is not empty:\\na. Dequeue the front element of the queue and assign its level,\\nrow, and column values to variables \"lvl,\" \"row,\" and \"col,\" respectively.\\nb. Iterate through all possible neighboring cells:\\ni. Calculate the coordinates of the neighbor using the formula:\\nrV = row + rN[i] and cV = col + cN[i].\\nii. Check if the calculated coordinates are within the grid\\nboundaries (0 <= rV < m and 0 <= cV < n) and the cell contains\\na fresh orange (with a value of 1) that has not been visited (vis[rV][cV] == 0).\\n- If the conditions are satisfied, enqueue the neighbor\\'s coordinates\\n(level lvl+1, row rV, column cV) to the queue and mark it\\nas visited (set vis[rV][cV] to 1).\\nc. Update \"ans\" to the maximum value between \"ans\" and \"lvl\" to\\nkeep track of the maximum time taken to rot all oranges.\\nAfter the BFS is complete, iterate through all cells in the grid:\\na. If a fresh orange (with a value of 1) is found and it has not\\nbeen visited (vis[i][j] == 0), return -1 to indicate that it is impossible to rot all oranges.\\nReturn the value of \"ans\" as the minimum time required to rot all oranges.\\nComplexity\\nTime complexity:\\nT.C=O(m*n) because we have to iterate whole matrix.\\n\\nSpace complexity:\\nS.C=O(m*n) because In worst case whole matrix contain Rotten orange.\\nSo we have to store all in queue.\\n\\n-------------------------------------------------------\\nPlease Upvote if understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/rotting-oranges/solutions/3661472/c-bfs-optimized-code-proper-algorithm-commented/"
                    },
                    {
                        "username": "Pranjal2608",
                        "content": "I have written this code using bfs traversal but getting the wrong output pls help\\nclass Solution {\\n    int bfs(vector<vector<int>>& grid,vector<vector<int>>& vis, int row, int col,int& freshOranges) {\\n    int m=grid.size();\\n    int n=grid[0].size();\\n    queue<pair<int,int>> q;\\n    int lim=0;\\n    q.push({row,col});\\n    int offsets[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  \\n    while(!q.empty()){\\n        int row=q.front().first;\\n        int col=q.front().second;    \\n        q.pop();\\n        for (int i = 0; i < 4; i++) {\\n            int newRow = row + offsets[i][0];\\n            int newCol = col + offsets[i][1];        \\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && grid[newRow][newCol]==1) {\\n                    grid[newRow][newCol]=2;\\n                    freshOranges--;\\n                    vis[newRow][newCol]=1;\\n                    q.push({newRow,newCol});\\n                   \\n                        \\n            }\\n        }\\n        lim++;\\n    }  \\n    if(freshOranges==0){\\n       return lim;\\n    }\\n    return -1; \\n}\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> vis(m,vector<int>(n,0));  \\n        int freshOranges = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1)\\n                    freshOranges++;\\n            }\\n        }     \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && grid[i][j]==2){\\n                    vis[i][j]=1;\\n                  count=bfs(grid,vis,i,j,freshOranges);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sahilbheke",
                        "content": "Why this code is producing runtime error please help me #LeetCode #Community\\nclass Solution {\\npublic:\\n\\n    void solve(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& vis, int ans){\\n        if( vis[i][j] == 1 || i < 0 || j < 0 || i >= grid.size() \\n            || j >= grid[0].size() || grid[i][j] == 0)\\n            return;\\n\\n        vis[i][j] = 1;\\n        // if(grid[i][j] == 2)\\n        grid[i][j] = 2;\\n\\n        solve(grid, i+1, j, vis, ans);\\n        solve(grid, i, j+1, vis, ans);\\n        solve(grid, i-1, j, vis, ans);\\n        solve(grid, i, j-1, vis, ans);\\n        ans++;\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int> (n, 0));\\n        int ans = 2;\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && grid[i][j] == 2){\\n                    solve(grid, i, j, vis, ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "but how to get minimum time,\\nfor the first test case example 5 is also the time."
                    },
                    {
                        "username": "thawesu",
                        "content": "Hmm.\\nConstraint:  grid[i][j] is 0, 1, or 2.\\nTestcase : [[1],[2]] \\nExpected output 1\\n"
                    },
                    {
                        "username": "oleg_vasilev",
                        "content": "You don\\'t need any depth-first or breadth-first search, it is much easier. \\ntip: Take a look at classic Conway\\'s \"Game of Life\".\\n"
                    }
                ]
            },
            {
                "id": 2004585,
                "content": [
                    {
                        "username": "sarthakagarwal4043",
                        "content": "We can use multisource BFS in this case"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Does the question mean we have only at max 1 Rotten orange ( initially )?   "
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "No there can be any number of rotten oranges initially, the whole grid can be rotten oranges too which has an output of 0\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "BFS is easier for this problem. This problem is very annoying and the mistake I made was starting a BFS at the first rotten orange I found, when in reality I should have started a queue and added all the rotten ones, THEN perform BFS layer by layer "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Coding is like ripening oranges; it takes time for the rot to spread. With an optimized BFS approach, even the most challenging grids can yield their secrets efficiently, revealing the minimum time needed to turn all oranges rotten.***"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, BFS , Optimized code. Proper algorithm commented.\\n\\nApproach\\nObtain the number of rows of the grid and assign it to the variable \"m\".\\nObtain the number of columns of the grid and assign it to the variable \"n\".\\nCreate an empty queue named \"q\" to store the coordinates of rotten oranges.\\nCreate a 2D vector \"vis\" of size m x n and initialize all elements to 0.\\nThis vector will be used to track visited oranges.\\nIterate through each cell in the grid using two nested loops:\\na. If the current cell contains a rotten orange (with a value of 2),\\nmark it as visited (set vis[i][j] to 1) and push its coordinates\\n(level 0, row i, column j) to the queue.\\nCreate two arrays, \"rN\" and \"cN,\" to represent the relative positions\\nof neighboring cells: {-1, 0, 1, 0} and {0, 1, 0, -1}, respectively.\\nInitialize a variable \"ans\" to 0, which will store the minimum\\ntime required for all oranges to rot.\\nPerform a breadth-first search (BFS) while the queue is not empty:\\na. Dequeue the front element of the queue and assign its level,\\nrow, and column values to variables \"lvl,\" \"row,\" and \"col,\" respectively.\\nb. Iterate through all possible neighboring cells:\\ni. Calculate the coordinates of the neighbor using the formula:\\nrV = row + rN[i] and cV = col + cN[i].\\nii. Check if the calculated coordinates are within the grid\\nboundaries (0 <= rV < m and 0 <= cV < n) and the cell contains\\na fresh orange (with a value of 1) that has not been visited (vis[rV][cV] == 0).\\n- If the conditions are satisfied, enqueue the neighbor\\'s coordinates\\n(level lvl+1, row rV, column cV) to the queue and mark it\\nas visited (set vis[rV][cV] to 1).\\nc. Update \"ans\" to the maximum value between \"ans\" and \"lvl\" to\\nkeep track of the maximum time taken to rot all oranges.\\nAfter the BFS is complete, iterate through all cells in the grid:\\na. If a fresh orange (with a value of 1) is found and it has not\\nbeen visited (vis[i][j] == 0), return -1 to indicate that it is impossible to rot all oranges.\\nReturn the value of \"ans\" as the minimum time required to rot all oranges.\\nComplexity\\nTime complexity:\\nT.C=O(m*n) because we have to iterate whole matrix.\\n\\nSpace complexity:\\nS.C=O(m*n) because In worst case whole matrix contain Rotten orange.\\nSo we have to store all in queue.\\n\\n-------------------------------------------------------\\nPlease Upvote if understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/rotting-oranges/solutions/3661472/c-bfs-optimized-code-proper-algorithm-commented/"
                    },
                    {
                        "username": "Pranjal2608",
                        "content": "I have written this code using bfs traversal but getting the wrong output pls help\\nclass Solution {\\n    int bfs(vector<vector<int>>& grid,vector<vector<int>>& vis, int row, int col,int& freshOranges) {\\n    int m=grid.size();\\n    int n=grid[0].size();\\n    queue<pair<int,int>> q;\\n    int lim=0;\\n    q.push({row,col});\\n    int offsets[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  \\n    while(!q.empty()){\\n        int row=q.front().first;\\n        int col=q.front().second;    \\n        q.pop();\\n        for (int i = 0; i < 4; i++) {\\n            int newRow = row + offsets[i][0];\\n            int newCol = col + offsets[i][1];        \\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && grid[newRow][newCol]==1) {\\n                    grid[newRow][newCol]=2;\\n                    freshOranges--;\\n                    vis[newRow][newCol]=1;\\n                    q.push({newRow,newCol});\\n                   \\n                        \\n            }\\n        }\\n        lim++;\\n    }  \\n    if(freshOranges==0){\\n       return lim;\\n    }\\n    return -1; \\n}\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> vis(m,vector<int>(n,0));  \\n        int freshOranges = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1)\\n                    freshOranges++;\\n            }\\n        }     \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && grid[i][j]==2){\\n                    vis[i][j]=1;\\n                  count=bfs(grid,vis,i,j,freshOranges);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sahilbheke",
                        "content": "Why this code is producing runtime error please help me #LeetCode #Community\\nclass Solution {\\npublic:\\n\\n    void solve(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& vis, int ans){\\n        if( vis[i][j] == 1 || i < 0 || j < 0 || i >= grid.size() \\n            || j >= grid[0].size() || grid[i][j] == 0)\\n            return;\\n\\n        vis[i][j] = 1;\\n        // if(grid[i][j] == 2)\\n        grid[i][j] = 2;\\n\\n        solve(grid, i+1, j, vis, ans);\\n        solve(grid, i, j+1, vis, ans);\\n        solve(grid, i-1, j, vis, ans);\\n        solve(grid, i, j-1, vis, ans);\\n        ans++;\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int> (n, 0));\\n        int ans = 2;\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && grid[i][j] == 2){\\n                    solve(grid, i, j, vis, ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "but how to get minimum time,\\nfor the first test case example 5 is also the time."
                    },
                    {
                        "username": "thawesu",
                        "content": "Hmm.\\nConstraint:  grid[i][j] is 0, 1, or 2.\\nTestcase : [[1],[2]] \\nExpected output 1\\n"
                    },
                    {
                        "username": "oleg_vasilev",
                        "content": "You don\\'t need any depth-first or breadth-first search, it is much easier. \\ntip: Take a look at classic Conway\\'s \"Game of Life\".\\n"
                    }
                ]
            },
            {
                "id": 1994628,
                "content": [
                    {
                        "username": "sarthakagarwal4043",
                        "content": "We can use multisource BFS in this case"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Does the question mean we have only at max 1 Rotten orange ( initially )?   "
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "No there can be any number of rotten oranges initially, the whole grid can be rotten oranges too which has an output of 0\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "BFS is easier for this problem. This problem is very annoying and the mistake I made was starting a BFS at the first rotten orange I found, when in reality I should have started a queue and added all the rotten ones, THEN perform BFS layer by layer "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Coding is like ripening oranges; it takes time for the rot to spread. With an optimized BFS approach, even the most challenging grids can yield their secrets efficiently, revealing the minimum time needed to turn all oranges rotten.***"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, BFS , Optimized code. Proper algorithm commented.\\n\\nApproach\\nObtain the number of rows of the grid and assign it to the variable \"m\".\\nObtain the number of columns of the grid and assign it to the variable \"n\".\\nCreate an empty queue named \"q\" to store the coordinates of rotten oranges.\\nCreate a 2D vector \"vis\" of size m x n and initialize all elements to 0.\\nThis vector will be used to track visited oranges.\\nIterate through each cell in the grid using two nested loops:\\na. If the current cell contains a rotten orange (with a value of 2),\\nmark it as visited (set vis[i][j] to 1) and push its coordinates\\n(level 0, row i, column j) to the queue.\\nCreate two arrays, \"rN\" and \"cN,\" to represent the relative positions\\nof neighboring cells: {-1, 0, 1, 0} and {0, 1, 0, -1}, respectively.\\nInitialize a variable \"ans\" to 0, which will store the minimum\\ntime required for all oranges to rot.\\nPerform a breadth-first search (BFS) while the queue is not empty:\\na. Dequeue the front element of the queue and assign its level,\\nrow, and column values to variables \"lvl,\" \"row,\" and \"col,\" respectively.\\nb. Iterate through all possible neighboring cells:\\ni. Calculate the coordinates of the neighbor using the formula:\\nrV = row + rN[i] and cV = col + cN[i].\\nii. Check if the calculated coordinates are within the grid\\nboundaries (0 <= rV < m and 0 <= cV < n) and the cell contains\\na fresh orange (with a value of 1) that has not been visited (vis[rV][cV] == 0).\\n- If the conditions are satisfied, enqueue the neighbor\\'s coordinates\\n(level lvl+1, row rV, column cV) to the queue and mark it\\nas visited (set vis[rV][cV] to 1).\\nc. Update \"ans\" to the maximum value between \"ans\" and \"lvl\" to\\nkeep track of the maximum time taken to rot all oranges.\\nAfter the BFS is complete, iterate through all cells in the grid:\\na. If a fresh orange (with a value of 1) is found and it has not\\nbeen visited (vis[i][j] == 0), return -1 to indicate that it is impossible to rot all oranges.\\nReturn the value of \"ans\" as the minimum time required to rot all oranges.\\nComplexity\\nTime complexity:\\nT.C=O(m*n) because we have to iterate whole matrix.\\n\\nSpace complexity:\\nS.C=O(m*n) because In worst case whole matrix contain Rotten orange.\\nSo we have to store all in queue.\\n\\n-------------------------------------------------------\\nPlease Upvote if understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/rotting-oranges/solutions/3661472/c-bfs-optimized-code-proper-algorithm-commented/"
                    },
                    {
                        "username": "Pranjal2608",
                        "content": "I have written this code using bfs traversal but getting the wrong output pls help\\nclass Solution {\\n    int bfs(vector<vector<int>>& grid,vector<vector<int>>& vis, int row, int col,int& freshOranges) {\\n    int m=grid.size();\\n    int n=grid[0].size();\\n    queue<pair<int,int>> q;\\n    int lim=0;\\n    q.push({row,col});\\n    int offsets[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  \\n    while(!q.empty()){\\n        int row=q.front().first;\\n        int col=q.front().second;    \\n        q.pop();\\n        for (int i = 0; i < 4; i++) {\\n            int newRow = row + offsets[i][0];\\n            int newCol = col + offsets[i][1];        \\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && grid[newRow][newCol]==1) {\\n                    grid[newRow][newCol]=2;\\n                    freshOranges--;\\n                    vis[newRow][newCol]=1;\\n                    q.push({newRow,newCol});\\n                   \\n                        \\n            }\\n        }\\n        lim++;\\n    }  \\n    if(freshOranges==0){\\n       return lim;\\n    }\\n    return -1; \\n}\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> vis(m,vector<int>(n,0));  \\n        int freshOranges = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1)\\n                    freshOranges++;\\n            }\\n        }     \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && grid[i][j]==2){\\n                    vis[i][j]=1;\\n                  count=bfs(grid,vis,i,j,freshOranges);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sahilbheke",
                        "content": "Why this code is producing runtime error please help me #LeetCode #Community\\nclass Solution {\\npublic:\\n\\n    void solve(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& vis, int ans){\\n        if( vis[i][j] == 1 || i < 0 || j < 0 || i >= grid.size() \\n            || j >= grid[0].size() || grid[i][j] == 0)\\n            return;\\n\\n        vis[i][j] = 1;\\n        // if(grid[i][j] == 2)\\n        grid[i][j] = 2;\\n\\n        solve(grid, i+1, j, vis, ans);\\n        solve(grid, i, j+1, vis, ans);\\n        solve(grid, i-1, j, vis, ans);\\n        solve(grid, i, j-1, vis, ans);\\n        ans++;\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int> (n, 0));\\n        int ans = 2;\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && grid[i][j] == 2){\\n                    solve(grid, i, j, vis, ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "but how to get minimum time,\\nfor the first test case example 5 is also the time."
                    },
                    {
                        "username": "thawesu",
                        "content": "Hmm.\\nConstraint:  grid[i][j] is 0, 1, or 2.\\nTestcase : [[1],[2]] \\nExpected output 1\\n"
                    },
                    {
                        "username": "oleg_vasilev",
                        "content": "You don\\'t need any depth-first or breadth-first search, it is much easier. \\ntip: Take a look at classic Conway\\'s \"Game of Life\".\\n"
                    }
                ]
            },
            {
                "id": 1937174,
                "content": [
                    {
                        "username": "sarthakagarwal4043",
                        "content": "We can use multisource BFS in this case"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Does the question mean we have only at max 1 Rotten orange ( initially )?   "
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "No there can be any number of rotten oranges initially, the whole grid can be rotten oranges too which has an output of 0\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "BFS is easier for this problem. This problem is very annoying and the mistake I made was starting a BFS at the first rotten orange I found, when in reality I should have started a queue and added all the rotten ones, THEN perform BFS layer by layer "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Coding is like ripening oranges; it takes time for the rot to spread. With an optimized BFS approach, even the most challenging grids can yield their secrets efficiently, revealing the minimum time needed to turn all oranges rotten.***"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, BFS , Optimized code. Proper algorithm commented.\\n\\nApproach\\nObtain the number of rows of the grid and assign it to the variable \"m\".\\nObtain the number of columns of the grid and assign it to the variable \"n\".\\nCreate an empty queue named \"q\" to store the coordinates of rotten oranges.\\nCreate a 2D vector \"vis\" of size m x n and initialize all elements to 0.\\nThis vector will be used to track visited oranges.\\nIterate through each cell in the grid using two nested loops:\\na. If the current cell contains a rotten orange (with a value of 2),\\nmark it as visited (set vis[i][j] to 1) and push its coordinates\\n(level 0, row i, column j) to the queue.\\nCreate two arrays, \"rN\" and \"cN,\" to represent the relative positions\\nof neighboring cells: {-1, 0, 1, 0} and {0, 1, 0, -1}, respectively.\\nInitialize a variable \"ans\" to 0, which will store the minimum\\ntime required for all oranges to rot.\\nPerform a breadth-first search (BFS) while the queue is not empty:\\na. Dequeue the front element of the queue and assign its level,\\nrow, and column values to variables \"lvl,\" \"row,\" and \"col,\" respectively.\\nb. Iterate through all possible neighboring cells:\\ni. Calculate the coordinates of the neighbor using the formula:\\nrV = row + rN[i] and cV = col + cN[i].\\nii. Check if the calculated coordinates are within the grid\\nboundaries (0 <= rV < m and 0 <= cV < n) and the cell contains\\na fresh orange (with a value of 1) that has not been visited (vis[rV][cV] == 0).\\n- If the conditions are satisfied, enqueue the neighbor\\'s coordinates\\n(level lvl+1, row rV, column cV) to the queue and mark it\\nas visited (set vis[rV][cV] to 1).\\nc. Update \"ans\" to the maximum value between \"ans\" and \"lvl\" to\\nkeep track of the maximum time taken to rot all oranges.\\nAfter the BFS is complete, iterate through all cells in the grid:\\na. If a fresh orange (with a value of 1) is found and it has not\\nbeen visited (vis[i][j] == 0), return -1 to indicate that it is impossible to rot all oranges.\\nReturn the value of \"ans\" as the minimum time required to rot all oranges.\\nComplexity\\nTime complexity:\\nT.C=O(m*n) because we have to iterate whole matrix.\\n\\nSpace complexity:\\nS.C=O(m*n) because In worst case whole matrix contain Rotten orange.\\nSo we have to store all in queue.\\n\\n-------------------------------------------------------\\nPlease Upvote if understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/rotting-oranges/solutions/3661472/c-bfs-optimized-code-proper-algorithm-commented/"
                    },
                    {
                        "username": "Pranjal2608",
                        "content": "I have written this code using bfs traversal but getting the wrong output pls help\\nclass Solution {\\n    int bfs(vector<vector<int>>& grid,vector<vector<int>>& vis, int row, int col,int& freshOranges) {\\n    int m=grid.size();\\n    int n=grid[0].size();\\n    queue<pair<int,int>> q;\\n    int lim=0;\\n    q.push({row,col});\\n    int offsets[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  \\n    while(!q.empty()){\\n        int row=q.front().first;\\n        int col=q.front().second;    \\n        q.pop();\\n        for (int i = 0; i < 4; i++) {\\n            int newRow = row + offsets[i][0];\\n            int newCol = col + offsets[i][1];        \\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && grid[newRow][newCol]==1) {\\n                    grid[newRow][newCol]=2;\\n                    freshOranges--;\\n                    vis[newRow][newCol]=1;\\n                    q.push({newRow,newCol});\\n                   \\n                        \\n            }\\n        }\\n        lim++;\\n    }  \\n    if(freshOranges==0){\\n       return lim;\\n    }\\n    return -1; \\n}\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> vis(m,vector<int>(n,0));  \\n        int freshOranges = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1)\\n                    freshOranges++;\\n            }\\n        }     \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && grid[i][j]==2){\\n                    vis[i][j]=1;\\n                  count=bfs(grid,vis,i,j,freshOranges);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sahilbheke",
                        "content": "Why this code is producing runtime error please help me #LeetCode #Community\\nclass Solution {\\npublic:\\n\\n    void solve(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& vis, int ans){\\n        if( vis[i][j] == 1 || i < 0 || j < 0 || i >= grid.size() \\n            || j >= grid[0].size() || grid[i][j] == 0)\\n            return;\\n\\n        vis[i][j] = 1;\\n        // if(grid[i][j] == 2)\\n        grid[i][j] = 2;\\n\\n        solve(grid, i+1, j, vis, ans);\\n        solve(grid, i, j+1, vis, ans);\\n        solve(grid, i-1, j, vis, ans);\\n        solve(grid, i, j-1, vis, ans);\\n        ans++;\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int> (n, 0));\\n        int ans = 2;\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && grid[i][j] == 2){\\n                    solve(grid, i, j, vis, ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "but how to get minimum time,\\nfor the first test case example 5 is also the time."
                    },
                    {
                        "username": "thawesu",
                        "content": "Hmm.\\nConstraint:  grid[i][j] is 0, 1, or 2.\\nTestcase : [[1],[2]] \\nExpected output 1\\n"
                    },
                    {
                        "username": "oleg_vasilev",
                        "content": "You don\\'t need any depth-first or breadth-first search, it is much easier. \\ntip: Take a look at classic Conway\\'s \"Game of Life\".\\n"
                    }
                ]
            },
            {
                "id": 1922325,
                "content": [
                    {
                        "username": "sarthakagarwal4043",
                        "content": "We can use multisource BFS in this case"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Does the question mean we have only at max 1 Rotten orange ( initially )?   "
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "No there can be any number of rotten oranges initially, the whole grid can be rotten oranges too which has an output of 0\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "BFS is easier for this problem. This problem is very annoying and the mistake I made was starting a BFS at the first rotten orange I found, when in reality I should have started a queue and added all the rotten ones, THEN perform BFS layer by layer "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Coding is like ripening oranges; it takes time for the rot to spread. With an optimized BFS approach, even the most challenging grids can yield their secrets efficiently, revealing the minimum time needed to turn all oranges rotten.***"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, BFS , Optimized code. Proper algorithm commented.\\n\\nApproach\\nObtain the number of rows of the grid and assign it to the variable \"m\".\\nObtain the number of columns of the grid and assign it to the variable \"n\".\\nCreate an empty queue named \"q\" to store the coordinates of rotten oranges.\\nCreate a 2D vector \"vis\" of size m x n and initialize all elements to 0.\\nThis vector will be used to track visited oranges.\\nIterate through each cell in the grid using two nested loops:\\na. If the current cell contains a rotten orange (with a value of 2),\\nmark it as visited (set vis[i][j] to 1) and push its coordinates\\n(level 0, row i, column j) to the queue.\\nCreate two arrays, \"rN\" and \"cN,\" to represent the relative positions\\nof neighboring cells: {-1, 0, 1, 0} and {0, 1, 0, -1}, respectively.\\nInitialize a variable \"ans\" to 0, which will store the minimum\\ntime required for all oranges to rot.\\nPerform a breadth-first search (BFS) while the queue is not empty:\\na. Dequeue the front element of the queue and assign its level,\\nrow, and column values to variables \"lvl,\" \"row,\" and \"col,\" respectively.\\nb. Iterate through all possible neighboring cells:\\ni. Calculate the coordinates of the neighbor using the formula:\\nrV = row + rN[i] and cV = col + cN[i].\\nii. Check if the calculated coordinates are within the grid\\nboundaries (0 <= rV < m and 0 <= cV < n) and the cell contains\\na fresh orange (with a value of 1) that has not been visited (vis[rV][cV] == 0).\\n- If the conditions are satisfied, enqueue the neighbor\\'s coordinates\\n(level lvl+1, row rV, column cV) to the queue and mark it\\nas visited (set vis[rV][cV] to 1).\\nc. Update \"ans\" to the maximum value between \"ans\" and \"lvl\" to\\nkeep track of the maximum time taken to rot all oranges.\\nAfter the BFS is complete, iterate through all cells in the grid:\\na. If a fresh orange (with a value of 1) is found and it has not\\nbeen visited (vis[i][j] == 0), return -1 to indicate that it is impossible to rot all oranges.\\nReturn the value of \"ans\" as the minimum time required to rot all oranges.\\nComplexity\\nTime complexity:\\nT.C=O(m*n) because we have to iterate whole matrix.\\n\\nSpace complexity:\\nS.C=O(m*n) because In worst case whole matrix contain Rotten orange.\\nSo we have to store all in queue.\\n\\n-------------------------------------------------------\\nPlease Upvote if understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/rotting-oranges/solutions/3661472/c-bfs-optimized-code-proper-algorithm-commented/"
                    },
                    {
                        "username": "Pranjal2608",
                        "content": "I have written this code using bfs traversal but getting the wrong output pls help\\nclass Solution {\\n    int bfs(vector<vector<int>>& grid,vector<vector<int>>& vis, int row, int col,int& freshOranges) {\\n    int m=grid.size();\\n    int n=grid[0].size();\\n    queue<pair<int,int>> q;\\n    int lim=0;\\n    q.push({row,col});\\n    int offsets[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  \\n    while(!q.empty()){\\n        int row=q.front().first;\\n        int col=q.front().second;    \\n        q.pop();\\n        for (int i = 0; i < 4; i++) {\\n            int newRow = row + offsets[i][0];\\n            int newCol = col + offsets[i][1];        \\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && grid[newRow][newCol]==1) {\\n                    grid[newRow][newCol]=2;\\n                    freshOranges--;\\n                    vis[newRow][newCol]=1;\\n                    q.push({newRow,newCol});\\n                   \\n                        \\n            }\\n        }\\n        lim++;\\n    }  \\n    if(freshOranges==0){\\n       return lim;\\n    }\\n    return -1; \\n}\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> vis(m,vector<int>(n,0));  \\n        int freshOranges = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1)\\n                    freshOranges++;\\n            }\\n        }     \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && grid[i][j]==2){\\n                    vis[i][j]=1;\\n                  count=bfs(grid,vis,i,j,freshOranges);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sahilbheke",
                        "content": "Why this code is producing runtime error please help me #LeetCode #Community\\nclass Solution {\\npublic:\\n\\n    void solve(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& vis, int ans){\\n        if( vis[i][j] == 1 || i < 0 || j < 0 || i >= grid.size() \\n            || j >= grid[0].size() || grid[i][j] == 0)\\n            return;\\n\\n        vis[i][j] = 1;\\n        // if(grid[i][j] == 2)\\n        grid[i][j] = 2;\\n\\n        solve(grid, i+1, j, vis, ans);\\n        solve(grid, i, j+1, vis, ans);\\n        solve(grid, i-1, j, vis, ans);\\n        solve(grid, i, j-1, vis, ans);\\n        ans++;\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int> (n, 0));\\n        int ans = 2;\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && grid[i][j] == 2){\\n                    solve(grid, i, j, vis, ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "but how to get minimum time,\\nfor the first test case example 5 is also the time."
                    },
                    {
                        "username": "thawesu",
                        "content": "Hmm.\\nConstraint:  grid[i][j] is 0, 1, or 2.\\nTestcase : [[1],[2]] \\nExpected output 1\\n"
                    },
                    {
                        "username": "oleg_vasilev",
                        "content": "You don\\'t need any depth-first or breadth-first search, it is much easier. \\ntip: Take a look at classic Conway\\'s \"Game of Life\".\\n"
                    }
                ]
            },
            {
                "id": 1883066,
                "content": [
                    {
                        "username": "sarthakagarwal4043",
                        "content": "We can use multisource BFS in this case"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Does the question mean we have only at max 1 Rotten orange ( initially )?   "
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "No there can be any number of rotten oranges initially, the whole grid can be rotten oranges too which has an output of 0\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "BFS is easier for this problem. This problem is very annoying and the mistake I made was starting a BFS at the first rotten orange I found, when in reality I should have started a queue and added all the rotten ones, THEN perform BFS layer by layer "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Coding is like ripening oranges; it takes time for the rot to spread. With an optimized BFS approach, even the most challenging grids can yield their secrets efficiently, revealing the minimum time needed to turn all oranges rotten.***"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, BFS , Optimized code. Proper algorithm commented.\\n\\nApproach\\nObtain the number of rows of the grid and assign it to the variable \"m\".\\nObtain the number of columns of the grid and assign it to the variable \"n\".\\nCreate an empty queue named \"q\" to store the coordinates of rotten oranges.\\nCreate a 2D vector \"vis\" of size m x n and initialize all elements to 0.\\nThis vector will be used to track visited oranges.\\nIterate through each cell in the grid using two nested loops:\\na. If the current cell contains a rotten orange (with a value of 2),\\nmark it as visited (set vis[i][j] to 1) and push its coordinates\\n(level 0, row i, column j) to the queue.\\nCreate two arrays, \"rN\" and \"cN,\" to represent the relative positions\\nof neighboring cells: {-1, 0, 1, 0} and {0, 1, 0, -1}, respectively.\\nInitialize a variable \"ans\" to 0, which will store the minimum\\ntime required for all oranges to rot.\\nPerform a breadth-first search (BFS) while the queue is not empty:\\na. Dequeue the front element of the queue and assign its level,\\nrow, and column values to variables \"lvl,\" \"row,\" and \"col,\" respectively.\\nb. Iterate through all possible neighboring cells:\\ni. Calculate the coordinates of the neighbor using the formula:\\nrV = row + rN[i] and cV = col + cN[i].\\nii. Check if the calculated coordinates are within the grid\\nboundaries (0 <= rV < m and 0 <= cV < n) and the cell contains\\na fresh orange (with a value of 1) that has not been visited (vis[rV][cV] == 0).\\n- If the conditions are satisfied, enqueue the neighbor\\'s coordinates\\n(level lvl+1, row rV, column cV) to the queue and mark it\\nas visited (set vis[rV][cV] to 1).\\nc. Update \"ans\" to the maximum value between \"ans\" and \"lvl\" to\\nkeep track of the maximum time taken to rot all oranges.\\nAfter the BFS is complete, iterate through all cells in the grid:\\na. If a fresh orange (with a value of 1) is found and it has not\\nbeen visited (vis[i][j] == 0), return -1 to indicate that it is impossible to rot all oranges.\\nReturn the value of \"ans\" as the minimum time required to rot all oranges.\\nComplexity\\nTime complexity:\\nT.C=O(m*n) because we have to iterate whole matrix.\\n\\nSpace complexity:\\nS.C=O(m*n) because In worst case whole matrix contain Rotten orange.\\nSo we have to store all in queue.\\n\\n-------------------------------------------------------\\nPlease Upvote if understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/rotting-oranges/solutions/3661472/c-bfs-optimized-code-proper-algorithm-commented/"
                    },
                    {
                        "username": "Pranjal2608",
                        "content": "I have written this code using bfs traversal but getting the wrong output pls help\\nclass Solution {\\n    int bfs(vector<vector<int>>& grid,vector<vector<int>>& vis, int row, int col,int& freshOranges) {\\n    int m=grid.size();\\n    int n=grid[0].size();\\n    queue<pair<int,int>> q;\\n    int lim=0;\\n    q.push({row,col});\\n    int offsets[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  \\n    while(!q.empty()){\\n        int row=q.front().first;\\n        int col=q.front().second;    \\n        q.pop();\\n        for (int i = 0; i < 4; i++) {\\n            int newRow = row + offsets[i][0];\\n            int newCol = col + offsets[i][1];        \\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && grid[newRow][newCol]==1) {\\n                    grid[newRow][newCol]=2;\\n                    freshOranges--;\\n                    vis[newRow][newCol]=1;\\n                    q.push({newRow,newCol});\\n                   \\n                        \\n            }\\n        }\\n        lim++;\\n    }  \\n    if(freshOranges==0){\\n       return lim;\\n    }\\n    return -1; \\n}\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> vis(m,vector<int>(n,0));  \\n        int freshOranges = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1)\\n                    freshOranges++;\\n            }\\n        }     \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && grid[i][j]==2){\\n                    vis[i][j]=1;\\n                  count=bfs(grid,vis,i,j,freshOranges);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sahilbheke",
                        "content": "Why this code is producing runtime error please help me #LeetCode #Community\\nclass Solution {\\npublic:\\n\\n    void solve(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& vis, int ans){\\n        if( vis[i][j] == 1 || i < 0 || j < 0 || i >= grid.size() \\n            || j >= grid[0].size() || grid[i][j] == 0)\\n            return;\\n\\n        vis[i][j] = 1;\\n        // if(grid[i][j] == 2)\\n        grid[i][j] = 2;\\n\\n        solve(grid, i+1, j, vis, ans);\\n        solve(grid, i, j+1, vis, ans);\\n        solve(grid, i-1, j, vis, ans);\\n        solve(grid, i, j-1, vis, ans);\\n        ans++;\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int> (n, 0));\\n        int ans = 2;\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && grid[i][j] == 2){\\n                    solve(grid, i, j, vis, ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "but how to get minimum time,\\nfor the first test case example 5 is also the time."
                    },
                    {
                        "username": "thawesu",
                        "content": "Hmm.\\nConstraint:  grid[i][j] is 0, 1, or 2.\\nTestcase : [[1],[2]] \\nExpected output 1\\n"
                    },
                    {
                        "username": "oleg_vasilev",
                        "content": "You don\\'t need any depth-first or breadth-first search, it is much easier. \\ntip: Take a look at classic Conway\\'s \"Game of Life\".\\n"
                    }
                ]
            },
            {
                "id": 1840088,
                "content": [
                    {
                        "username": "sarthakagarwal4043",
                        "content": "We can use multisource BFS in this case"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Does the question mean we have only at max 1 Rotten orange ( initially )?   "
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "No there can be any number of rotten oranges initially, the whole grid can be rotten oranges too which has an output of 0\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "BFS is easier for this problem. This problem is very annoying and the mistake I made was starting a BFS at the first rotten orange I found, when in reality I should have started a queue and added all the rotten ones, THEN perform BFS layer by layer "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Coding is like ripening oranges; it takes time for the rot to spread. With an optimized BFS approach, even the most challenging grids can yield their secrets efficiently, revealing the minimum time needed to turn all oranges rotten.***"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, BFS , Optimized code. Proper algorithm commented.\\n\\nApproach\\nObtain the number of rows of the grid and assign it to the variable \"m\".\\nObtain the number of columns of the grid and assign it to the variable \"n\".\\nCreate an empty queue named \"q\" to store the coordinates of rotten oranges.\\nCreate a 2D vector \"vis\" of size m x n and initialize all elements to 0.\\nThis vector will be used to track visited oranges.\\nIterate through each cell in the grid using two nested loops:\\na. If the current cell contains a rotten orange (with a value of 2),\\nmark it as visited (set vis[i][j] to 1) and push its coordinates\\n(level 0, row i, column j) to the queue.\\nCreate two arrays, \"rN\" and \"cN,\" to represent the relative positions\\nof neighboring cells: {-1, 0, 1, 0} and {0, 1, 0, -1}, respectively.\\nInitialize a variable \"ans\" to 0, which will store the minimum\\ntime required for all oranges to rot.\\nPerform a breadth-first search (BFS) while the queue is not empty:\\na. Dequeue the front element of the queue and assign its level,\\nrow, and column values to variables \"lvl,\" \"row,\" and \"col,\" respectively.\\nb. Iterate through all possible neighboring cells:\\ni. Calculate the coordinates of the neighbor using the formula:\\nrV = row + rN[i] and cV = col + cN[i].\\nii. Check if the calculated coordinates are within the grid\\nboundaries (0 <= rV < m and 0 <= cV < n) and the cell contains\\na fresh orange (with a value of 1) that has not been visited (vis[rV][cV] == 0).\\n- If the conditions are satisfied, enqueue the neighbor\\'s coordinates\\n(level lvl+1, row rV, column cV) to the queue and mark it\\nas visited (set vis[rV][cV] to 1).\\nc. Update \"ans\" to the maximum value between \"ans\" and \"lvl\" to\\nkeep track of the maximum time taken to rot all oranges.\\nAfter the BFS is complete, iterate through all cells in the grid:\\na. If a fresh orange (with a value of 1) is found and it has not\\nbeen visited (vis[i][j] == 0), return -1 to indicate that it is impossible to rot all oranges.\\nReturn the value of \"ans\" as the minimum time required to rot all oranges.\\nComplexity\\nTime complexity:\\nT.C=O(m*n) because we have to iterate whole matrix.\\n\\nSpace complexity:\\nS.C=O(m*n) because In worst case whole matrix contain Rotten orange.\\nSo we have to store all in queue.\\n\\n-------------------------------------------------------\\nPlease Upvote if understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/rotting-oranges/solutions/3661472/c-bfs-optimized-code-proper-algorithm-commented/"
                    },
                    {
                        "username": "Pranjal2608",
                        "content": "I have written this code using bfs traversal but getting the wrong output pls help\\nclass Solution {\\n    int bfs(vector<vector<int>>& grid,vector<vector<int>>& vis, int row, int col,int& freshOranges) {\\n    int m=grid.size();\\n    int n=grid[0].size();\\n    queue<pair<int,int>> q;\\n    int lim=0;\\n    q.push({row,col});\\n    int offsets[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  \\n    while(!q.empty()){\\n        int row=q.front().first;\\n        int col=q.front().second;    \\n        q.pop();\\n        for (int i = 0; i < 4; i++) {\\n            int newRow = row + offsets[i][0];\\n            int newCol = col + offsets[i][1];        \\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && grid[newRow][newCol]==1) {\\n                    grid[newRow][newCol]=2;\\n                    freshOranges--;\\n                    vis[newRow][newCol]=1;\\n                    q.push({newRow,newCol});\\n                   \\n                        \\n            }\\n        }\\n        lim++;\\n    }  \\n    if(freshOranges==0){\\n       return lim;\\n    }\\n    return -1; \\n}\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> vis(m,vector<int>(n,0));  \\n        int freshOranges = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1)\\n                    freshOranges++;\\n            }\\n        }     \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && grid[i][j]==2){\\n                    vis[i][j]=1;\\n                  count=bfs(grid,vis,i,j,freshOranges);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sahilbheke",
                        "content": "Why this code is producing runtime error please help me #LeetCode #Community\\nclass Solution {\\npublic:\\n\\n    void solve(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& vis, int ans){\\n        if( vis[i][j] == 1 || i < 0 || j < 0 || i >= grid.size() \\n            || j >= grid[0].size() || grid[i][j] == 0)\\n            return;\\n\\n        vis[i][j] = 1;\\n        // if(grid[i][j] == 2)\\n        grid[i][j] = 2;\\n\\n        solve(grid, i+1, j, vis, ans);\\n        solve(grid, i, j+1, vis, ans);\\n        solve(grid, i-1, j, vis, ans);\\n        solve(grid, i, j-1, vis, ans);\\n        ans++;\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int> (n, 0));\\n        int ans = 2;\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && grid[i][j] == 2){\\n                    solve(grid, i, j, vis, ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "but how to get minimum time,\\nfor the first test case example 5 is also the time."
                    },
                    {
                        "username": "thawesu",
                        "content": "Hmm.\\nConstraint:  grid[i][j] is 0, 1, or 2.\\nTestcase : [[1],[2]] \\nExpected output 1\\n"
                    },
                    {
                        "username": "oleg_vasilev",
                        "content": "You don\\'t need any depth-first or breadth-first search, it is much easier. \\ntip: Take a look at classic Conway\\'s \"Game of Life\".\\n"
                    }
                ]
            },
            {
                "id": 1816825,
                "content": [
                    {
                        "username": "sarthakagarwal4043",
                        "content": "We can use multisource BFS in this case"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Does the question mean we have only at max 1 Rotten orange ( initially )?   "
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "No there can be any number of rotten oranges initially, the whole grid can be rotten oranges too which has an output of 0\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "BFS is easier for this problem. This problem is very annoying and the mistake I made was starting a BFS at the first rotten orange I found, when in reality I should have started a queue and added all the rotten ones, THEN perform BFS layer by layer "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Coding is like ripening oranges; it takes time for the rot to spread. With an optimized BFS approach, even the most challenging grids can yield their secrets efficiently, revealing the minimum time needed to turn all oranges rotten.***"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, BFS , Optimized code. Proper algorithm commented.\\n\\nApproach\\nObtain the number of rows of the grid and assign it to the variable \"m\".\\nObtain the number of columns of the grid and assign it to the variable \"n\".\\nCreate an empty queue named \"q\" to store the coordinates of rotten oranges.\\nCreate a 2D vector \"vis\" of size m x n and initialize all elements to 0.\\nThis vector will be used to track visited oranges.\\nIterate through each cell in the grid using two nested loops:\\na. If the current cell contains a rotten orange (with a value of 2),\\nmark it as visited (set vis[i][j] to 1) and push its coordinates\\n(level 0, row i, column j) to the queue.\\nCreate two arrays, \"rN\" and \"cN,\" to represent the relative positions\\nof neighboring cells: {-1, 0, 1, 0} and {0, 1, 0, -1}, respectively.\\nInitialize a variable \"ans\" to 0, which will store the minimum\\ntime required for all oranges to rot.\\nPerform a breadth-first search (BFS) while the queue is not empty:\\na. Dequeue the front element of the queue and assign its level,\\nrow, and column values to variables \"lvl,\" \"row,\" and \"col,\" respectively.\\nb. Iterate through all possible neighboring cells:\\ni. Calculate the coordinates of the neighbor using the formula:\\nrV = row + rN[i] and cV = col + cN[i].\\nii. Check if the calculated coordinates are within the grid\\nboundaries (0 <= rV < m and 0 <= cV < n) and the cell contains\\na fresh orange (with a value of 1) that has not been visited (vis[rV][cV] == 0).\\n- If the conditions are satisfied, enqueue the neighbor\\'s coordinates\\n(level lvl+1, row rV, column cV) to the queue and mark it\\nas visited (set vis[rV][cV] to 1).\\nc. Update \"ans\" to the maximum value between \"ans\" and \"lvl\" to\\nkeep track of the maximum time taken to rot all oranges.\\nAfter the BFS is complete, iterate through all cells in the grid:\\na. If a fresh orange (with a value of 1) is found and it has not\\nbeen visited (vis[i][j] == 0), return -1 to indicate that it is impossible to rot all oranges.\\nReturn the value of \"ans\" as the minimum time required to rot all oranges.\\nComplexity\\nTime complexity:\\nT.C=O(m*n) because we have to iterate whole matrix.\\n\\nSpace complexity:\\nS.C=O(m*n) because In worst case whole matrix contain Rotten orange.\\nSo we have to store all in queue.\\n\\n-------------------------------------------------------\\nPlease Upvote if understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/rotting-oranges/solutions/3661472/c-bfs-optimized-code-proper-algorithm-commented/"
                    },
                    {
                        "username": "Pranjal2608",
                        "content": "I have written this code using bfs traversal but getting the wrong output pls help\\nclass Solution {\\n    int bfs(vector<vector<int>>& grid,vector<vector<int>>& vis, int row, int col,int& freshOranges) {\\n    int m=grid.size();\\n    int n=grid[0].size();\\n    queue<pair<int,int>> q;\\n    int lim=0;\\n    q.push({row,col});\\n    int offsets[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  \\n    while(!q.empty()){\\n        int row=q.front().first;\\n        int col=q.front().second;    \\n        q.pop();\\n        for (int i = 0; i < 4; i++) {\\n            int newRow = row + offsets[i][0];\\n            int newCol = col + offsets[i][1];        \\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && grid[newRow][newCol]==1) {\\n                    grid[newRow][newCol]=2;\\n                    freshOranges--;\\n                    vis[newRow][newCol]=1;\\n                    q.push({newRow,newCol});\\n                   \\n                        \\n            }\\n        }\\n        lim++;\\n    }  \\n    if(freshOranges==0){\\n       return lim;\\n    }\\n    return -1; \\n}\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> vis(m,vector<int>(n,0));  \\n        int freshOranges = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1)\\n                    freshOranges++;\\n            }\\n        }     \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && grid[i][j]==2){\\n                    vis[i][j]=1;\\n                  count=bfs(grid,vis,i,j,freshOranges);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sahilbheke",
                        "content": "Why this code is producing runtime error please help me #LeetCode #Community\\nclass Solution {\\npublic:\\n\\n    void solve(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& vis, int ans){\\n        if( vis[i][j] == 1 || i < 0 || j < 0 || i >= grid.size() \\n            || j >= grid[0].size() || grid[i][j] == 0)\\n            return;\\n\\n        vis[i][j] = 1;\\n        // if(grid[i][j] == 2)\\n        grid[i][j] = 2;\\n\\n        solve(grid, i+1, j, vis, ans);\\n        solve(grid, i, j+1, vis, ans);\\n        solve(grid, i-1, j, vis, ans);\\n        solve(grid, i, j-1, vis, ans);\\n        ans++;\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int> (n, 0));\\n        int ans = 2;\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && grid[i][j] == 2){\\n                    solve(grid, i, j, vis, ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "but how to get minimum time,\\nfor the first test case example 5 is also the time."
                    },
                    {
                        "username": "thawesu",
                        "content": "Hmm.\\nConstraint:  grid[i][j] is 0, 1, or 2.\\nTestcase : [[1],[2]] \\nExpected output 1\\n"
                    },
                    {
                        "username": "oleg_vasilev",
                        "content": "You don\\'t need any depth-first or breadth-first search, it is much easier. \\ntip: Take a look at classic Conway\\'s \"Game of Life\".\\n"
                    }
                ]
            },
            {
                "id": 1804791,
                "content": [
                    {
                        "username": "sarthakagarwal4043",
                        "content": "We can use multisource BFS in this case"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Does the question mean we have only at max 1 Rotten orange ( initially )?   "
                    },
                    {
                        "username": "well_seasoned_vegetable",
                        "content": "No there can be any number of rotten oranges initially, the whole grid can be rotten oranges too which has an output of 0\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "BFS is easier for this problem. This problem is very annoying and the mistake I made was starting a BFS at the first rotten orange I found, when in reality I should have started a queue and added all the rotten ones, THEN perform BFS layer by layer "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Coding is like ripening oranges; it takes time for the rot to spread. With an optimized BFS approach, even the most challenging grids can yield their secrets efficiently, revealing the minimum time needed to turn all oranges rotten.***"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, BFS , Optimized code. Proper algorithm commented.\\n\\nApproach\\nObtain the number of rows of the grid and assign it to the variable \"m\".\\nObtain the number of columns of the grid and assign it to the variable \"n\".\\nCreate an empty queue named \"q\" to store the coordinates of rotten oranges.\\nCreate a 2D vector \"vis\" of size m x n and initialize all elements to 0.\\nThis vector will be used to track visited oranges.\\nIterate through each cell in the grid using two nested loops:\\na. If the current cell contains a rotten orange (with a value of 2),\\nmark it as visited (set vis[i][j] to 1) and push its coordinates\\n(level 0, row i, column j) to the queue.\\nCreate two arrays, \"rN\" and \"cN,\" to represent the relative positions\\nof neighboring cells: {-1, 0, 1, 0} and {0, 1, 0, -1}, respectively.\\nInitialize a variable \"ans\" to 0, which will store the minimum\\ntime required for all oranges to rot.\\nPerform a breadth-first search (BFS) while the queue is not empty:\\na. Dequeue the front element of the queue and assign its level,\\nrow, and column values to variables \"lvl,\" \"row,\" and \"col,\" respectively.\\nb. Iterate through all possible neighboring cells:\\ni. Calculate the coordinates of the neighbor using the formula:\\nrV = row + rN[i] and cV = col + cN[i].\\nii. Check if the calculated coordinates are within the grid\\nboundaries (0 <= rV < m and 0 <= cV < n) and the cell contains\\na fresh orange (with a value of 1) that has not been visited (vis[rV][cV] == 0).\\n- If the conditions are satisfied, enqueue the neighbor\\'s coordinates\\n(level lvl+1, row rV, column cV) to the queue and mark it\\nas visited (set vis[rV][cV] to 1).\\nc. Update \"ans\" to the maximum value between \"ans\" and \"lvl\" to\\nkeep track of the maximum time taken to rot all oranges.\\nAfter the BFS is complete, iterate through all cells in the grid:\\na. If a fresh orange (with a value of 1) is found and it has not\\nbeen visited (vis[i][j] == 0), return -1 to indicate that it is impossible to rot all oranges.\\nReturn the value of \"ans\" as the minimum time required to rot all oranges.\\nComplexity\\nTime complexity:\\nT.C=O(m*n) because we have to iterate whole matrix.\\n\\nSpace complexity:\\nS.C=O(m*n) because In worst case whole matrix contain Rotten orange.\\nSo we have to store all in queue.\\n\\n-------------------------------------------------------\\nPlease Upvote if understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/rotting-oranges/solutions/3661472/c-bfs-optimized-code-proper-algorithm-commented/"
                    },
                    {
                        "username": "Pranjal2608",
                        "content": "I have written this code using bfs traversal but getting the wrong output pls help\\nclass Solution {\\n    int bfs(vector<vector<int>>& grid,vector<vector<int>>& vis, int row, int col,int& freshOranges) {\\n    int m=grid.size();\\n    int n=grid[0].size();\\n    queue<pair<int,int>> q;\\n    int lim=0;\\n    q.push({row,col});\\n    int offsets[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  \\n    while(!q.empty()){\\n        int row=q.front().first;\\n        int col=q.front().second;    \\n        q.pop();\\n        for (int i = 0; i < 4; i++) {\\n            int newRow = row + offsets[i][0];\\n            int newCol = col + offsets[i][1];        \\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && grid[newRow][newCol]==1) {\\n                    grid[newRow][newCol]=2;\\n                    freshOranges--;\\n                    vis[newRow][newCol]=1;\\n                    q.push({newRow,newCol});\\n                   \\n                        \\n            }\\n        }\\n        lim++;\\n    }  \\n    if(freshOranges==0){\\n       return lim;\\n    }\\n    return -1; \\n}\\npublic:\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> vis(m,vector<int>(n,0));  \\n        int freshOranges = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1)\\n                    freshOranges++;\\n            }\\n        }     \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && grid[i][j]==2){\\n                    vis[i][j]=1;\\n                  count=bfs(grid,vis,i,j,freshOranges);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sahilbheke",
                        "content": "Why this code is producing runtime error please help me #LeetCode #Community\\nclass Solution {\\npublic:\\n\\n    void solve(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& vis, int ans){\\n        if( vis[i][j] == 1 || i < 0 || j < 0 || i >= grid.size() \\n            || j >= grid[0].size() || grid[i][j] == 0)\\n            return;\\n\\n        vis[i][j] = 1;\\n        // if(grid[i][j] == 2)\\n        grid[i][j] = 2;\\n\\n        solve(grid, i+1, j, vis, ans);\\n        solve(grid, i, j+1, vis, ans);\\n        solve(grid, i-1, j, vis, ans);\\n        solve(grid, i, j-1, vis, ans);\\n        ans++;\\n    }\\n    int orangesRotting(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int> (n, 0));\\n        int ans = 2;\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && grid[i][j] == 2){\\n                    solve(grid, i, j, vis, ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "but how to get minimum time,\\nfor the first test case example 5 is also the time."
                    },
                    {
                        "username": "thawesu",
                        "content": "Hmm.\\nConstraint:  grid[i][j] is 0, 1, or 2.\\nTestcase : [[1],[2]] \\nExpected output 1\\n"
                    },
                    {
                        "username": "oleg_vasilev",
                        "content": "You don\\'t need any depth-first or breadth-first search, it is much easier. \\ntip: Take a look at classic Conway\\'s \"Game of Life\".\\n"
                    }
                ]
            }
        ]
    }
]