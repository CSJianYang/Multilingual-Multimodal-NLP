[
    {
        "title": "Frequency Tracker",
        "question_content": "Design a data structure that keeps track of the values in it and answers some queries regarding their frequencies.\nImplement the FrequencyTracker class.\n\n\tFrequencyTracker(): Initializes the FrequencyTracker object with an empty array initially.\n\tvoid add(int number): Adds number to the data structure.\n\tvoid deleteOne(int number): Deletes one occurrence of number from the data structure. The data structure may not contain number, and in this case nothing is deleted.\n\tbool hasFrequency(int frequency): Returns true if there is a number in the data structure that occurs frequency number of times, otherwise, it returns false.\n\n&nbsp;\nExample 1:\n\nInput\n[\"FrequencyTracker\", \"add\", \"add\", \"hasFrequency\"]\n[[], [3], [3], [2]]\nOutput\n[null, null, null, true]\nExplanation\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.add(3); // The data structure now contains [3]\nfrequencyTracker.add(3); // The data structure now contains [3, 3]\nfrequencyTracker.hasFrequency(2); // Returns true, because 3 occurs twice\n\nExample 2:\n\nInput\n[\"FrequencyTracker\", \"add\", \"deleteOne\", \"hasFrequency\"]\n[[], [1], [1], [1]]\nOutput\n[null, null, null, false]\nExplanation\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.add(1); // The data structure now contains [1]\nfrequencyTracker.deleteOne(1); // The data structure becomes empty []\nfrequencyTracker.hasFrequency(1); // Returns false, because the data structure is empty\n\nExample 3:\n\nInput\n[\"FrequencyTracker\", \"hasFrequency\", \"add\", \"hasFrequency\"]\n[[], [2], [3], [1]]\nOutput\n[null, false, null, true]\nExplanation\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.hasFrequency(2); // Returns false, because the data structure is empty\nfrequencyTracker.add(3); // The data structure now contains [3]\nfrequencyTracker.hasFrequency(1); // Returns true, because 3 occurs once\n\n&nbsp;\nConstraints:\n\n\t1 <= number <= 105\n\t1 <= frequency <= 105\n\tAt most, 2 *&nbsp;105&nbsp;calls will be made to add, deleteOne, and hasFrequency&nbsp;in total.",
        "solutions": [
            {
                "id": 3494972,
                "title": "explained-very-simple-easy-to-understand-solution",
                "content": "<b> Up vote if you like the solution </b>\\n\\n# Approach\\n\\nTake two maps, one to store number & frequency count ( mp )\\n& second one to store frequency & set of number whose frequecny is same ( rmp )\\n   - Basically the rmp is kind of reverse mapping of the data from the frequency to number\\n    \\nThen when we add a new number, \\n - first errase its occurance from the frequency mapping \\n - update the mapping mp\\n - Then add to the new frequency set\\n \\nSame above step we have to execute when deleted a number.\\n     \\nfinally to check if a number has a frequency equal to a particualr frequencyor not\\n    simply check if there is a index in rmp which has a set of size larger than 0.\\n        \\n \\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int, int> mp;   //store number & frequency count\\n    unordered_map<int, unordered_set<int>> mps; //store frequency & set of number whose frequecny is same\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(mp.find(number) != mp.end()){\\n            int f = mp[number];\\n            mps[f].erase(number);\\n        }\\n        mp[number]++;\\n        mps[mp[number]].insert(number);\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number) != mp.end() && mp[number] > 0){\\n            int f = mp[number];\\n            mps[f].erase(number);\\n            mp[number]--;\\n            if(mp[number]){\\n                mps[mp[number]].insert(number);\\n            }\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return (mps[frequency].size() > 0);\\n    }\\n};\\n```\\n\\nSolution 2: The second map can be stored only count of numbers whose frequency is same, without tracking exact number stored as well, as we only need the count. \\n\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int, int> mp;   //store number & frequency count\\n    unordered_map<int, int> mps;  //store frequency & count number whose frequecny is same\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(mp.find(number) != mp.end()){\\n            mps[mp[number]]--;\\n        }\\n        mp[number]++;\\n        mps[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number) != mp.end() && mp[number] > 0){\\n            mps[mp[number]]--;\\n            mp[number]--;\\n            mps[mp[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return (mps[frequency] > 0);\\n    }\\n};\\n```\\n\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int, int> mp;   //store number & frequency count\\n    unordered_map<int, unordered_set<int>> mps; //store frequency & set of number whose frequecny is same\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(mp.find(number) != mp.end()){\\n            int f = mp[number];\\n            mps[f].erase(number);\\n        }\\n        mp[number]++;\\n        mps[mp[number]].insert(number);\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number) != mp.end() && mp[number] > 0){\\n            int f = mp[number];\\n            mps[f].erase(number);\\n            mp[number]--;\\n            if(mp[number]){\\n                mps[mp[number]].insert(number);\\n            }\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return (mps[frequency].size() > 0);\\n    }\\n};\\n```\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int, int> mp;   //store number & frequency count\\n    unordered_map<int, int> mps;  //store frequency & count number whose frequecny is same\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(mp.find(number) != mp.end()){\\n            mps[mp[number]]--;\\n        }\\n        mp[number]++;\\n        mps[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number) != mp.end() && mp[number] > 0){\\n            mps[mp[number]]--;\\n            mp[number]--;\\n            mps[mp[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return (mps[frequency] > 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494909,
                "title": "two-arrays",
                "content": "We use two arrays (or we can use hash maps) to store:\\n- count of each number\\n- count of numbers for each frequency\\n\\nWith two arrays, the update (add/delete), and query (has) operations have O(1) complexity.\\n\\n**C++**\\n```cpp\\nclass FrequencyTracker {\\npublic:\\n    int cnt[100001] = {}, freq[100001] = {};\\n    void add(int number) {\\n        --freq[cnt[number]];\\n        ++freq[++cnt[number]];\\n    }    \\n    void deleteOne(int number) {\\n        if (cnt[number]) {\\n            --freq[cnt[number]];\\n            ++freq[--cnt[number]];\\n        }\\n    }\\n    bool hasFrequency(int frequency) {\\n        return freq[frequency];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass FrequencyTracker {\\npublic:\\n    int cnt[100001] = {}, freq[100001] = {};\\n    void add(int number) {\\n        --freq[cnt[number]];\\n        ++freq[++cnt[number]];\\n    }    \\n    void deleteOne(int number) {\\n        if (cnt[number]) {\\n            --freq[cnt[number]];\\n            ++freq[--cnt[number]];\\n        }\\n    }\\n    bool hasFrequency(int frequency) {\\n        return freq[frequency];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494843,
                "title": "java-simple-solution-frequency-map",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n  int[] map, freq;\\n\\n  public FrequencyTracker() {\\n    map = new int[100001];\\n    freq = new int[100001];\\n  }\\n\\n  public void add(int number) {\\n    freq[map[number]++]--;\\n    freq[map[number]]++;\\n  }\\n\\n  public void deleteOne(int number) {\\n    if (map[number] > 0) {\\n      freq[map[number]--]--;\\n      freq[map[number]]++;\\n    }\\n  }\\n\\n  public boolean hasFrequency(int frequency) {\\n    return freq[frequency] > 0;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass FrequencyTracker {\\n  int[] map, freq;\\n\\n  public FrequencyTracker() {\\n    map = new int[100001];\\n    freq = new int[100001];\\n  }\\n\\n  public void add(int number) {\\n    freq[map[number]++]--;\\n    freq[map[number]]++;\\n  }\\n\\n  public void deleteOne(int number) {\\n    if (map[number] > 0) {\\n      freq[map[number]--]--;\\n      freq[map[number]]++;\\n    }\\n  }\\n\\n  public boolean hasFrequency(int frequency) {\\n    return freq[frequency] > 0;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494900,
                "title": "day-402-better-100-0ms-python-java-c-explained-approach",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n##### \\u2022\\tExplanation:\\n##### \\u2022\\tWe use a HashMap  to store the count of each number and an array frequency to store the frequency of each count.\\n##### \\u2022\\t We initialize the frequency array with a size of 1e5+1.\\n##### \\u2022\\tThe add method takes a number as input and does the following:\\n##### \\u2022\\tIt gets the current count of the number from the map\\n##### \\u2022\\tIf the current count is already present, it decrements its frequency in the frequency array.\\n##### \\u2022\\tIt increments the count of the number in the map\\n##### \\u2022\\tIt increments the frequency of the new count in the frequency array.\\n##### \\u2022\\tThe deleteOne method takes a number as input and does the following:\\n##### \\u2022\\tIt gets the current count of the number from the map\\n##### \\u2022\\tIf the count is not null, it decrements the frequency of the current count in the frequency array.\\n##### \\u2022\\tIf the count is 1, it removes the number from the map\\n##### \\u2022\\tIf the count is greater than 1, it decrements the count of the number in the map and increments the frequency of the new count in the frequency array.\\n##### \\u2022\\tThe hasFrequency method takes a number as input and returns true if the frequency of the number is greater than 0 in the frequency array.\\n\\n\\n\\n# Complexity\\n- Time complexity:o(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\nprivate final Map<Integer,Integer> map; // Map to store the count of each number\\nprivate final int[] frequency; // Array to store the frequency of each count\\npublic FrequencyTracker() {\\n    map = new HashMap<>();\\n    frequency = new int[(int) 1e5 + 1]; // Initialize the frequency array with a size of 10^5 + 1\\n}\\n\\npublic void add(int number) {\\n    Integer freq = map.getOrDefault(number, 0); // Get the current count of the number\\n    if (freq != null && frequency[freq] > 0) { // If the current count is already present, decrement its frequency\\n        frequency[freq]--;\\n    }\\n    map.compute(number, (k, v) -> v == null ? 1 : v + 1); // Increment the count of the number in the map\\n    frequency[map.get(number)]++; // Increment the frequency of the new count in the frequency array\\n}\\n\\npublic void deleteOne(int n) {\\n    Integer count = map.get(n); // Get the current count of the number\\n    if (count != null) {\\n        frequency[count]--; // Decrement the frequency of the current count in the frequency array\\n        if (count == 1) {\\n            map.remove(n); // If the count is 1, remove the number from the map\\n        } else {\\n            map.put(n, count - 1); // Decrement the count of the number in the map\\n            frequency[map.get(n)]++; // Increment the frequency of the new count in the frequency array\\n        }\\n    }\\n}\\n\\npublic boolean hasFrequency(int number) {\\n    return number < this.frequency.length && this.frequency[number] > 0; // Check if the frequency of the given number is greater than 0\\n}\\n```\\n```c++ []\\nclass FrequencyTracker {\\nprivate:\\n    std::unordered_map<int, int> map; // Map to store the count of each number\\n    std::vector<int> frequency; // Vector to store the frequency of each count\\n\\npublic:\\n    FrequencyTracker() {\\n        frequency.resize(1e5 + 1); // Initialize the frequency vector with a size of 10^5 + 1\\n    }\\n\\n    void add(int number) {\\n        int freq = map[number]; // Get the current count of the number\\n        if (freq > 0 && frequency[freq] > 0) { // If the current count is already present, decrement its frequency\\n            frequency[freq]--;\\n        }\\n        map[number]++; // Increment the count of the number in the map\\n        frequency[map[number]]++; // Increment the frequency of the new count in the frequency vector\\n    }\\n\\n    void deleteOne(int n) {\\n        int count = map[n]; // Get the current count of the number\\n        if (count > 0) {\\n            frequency[count]--; // Decrement the frequency of the current count in the frequency vector\\n            if (count == 1) {\\n                map.erase(n); // If the count is 1, remove the number from the map\\n            } else {\\n                map[n]--; // Decrement the count of the number in the map\\n                frequency[map[n]]++; // Increment the frequency of the new count in the frequency vector\\n            }\\n        }\\n    }\\n\\n    bool hasFrequency(int number) {\\n        return number < frequency.size() && frequency[number] > 0; // Check if the frequency of the given number is greater than 0\\n    }\\n};\\n```\\n```python []\\nclass FrequencyTracker:\\n    def __init__(self):\\n        self.map = {} # Dictionary to store the count of each number\\n        self.frequency = [0] * (10**5 + 1) # List to store the frequency of each count\\n\\n    def add(self, number):\\n        freq = self.map.get(number, 0) # Get the current count of the number\\n        if freq > 0 and self.frequency[freq] > 0: # If the current count is already present, decrement its frequency\\n            self.frequency[freq] -= 1\\n        self.map[number] = freq + 1 # Increment the count of the number in the map\\n        self.frequency[self.map[number]] += 1 # Increment the frequency of the new count in the frequency list\\n\\n    def deleteOne(self, n):\\n        count = self.map.get(n, 0) # Get the current count of the number\\n        if count > 0:\\n            self.frequency[count] -= 1 # Decrement the frequency of the current count in the frequency list\\n            if count == 1:\\n                del self.map[n] # If the count is 1, remove the number from the map\\n            else:\\n                self.map[n] = count - 1 # Decrement the count of the number in the map\\n                self.frequency[self.map[n]] += 1 # Increment the frequency of the new count in the frequency list\\n\\n    def hasFrequency(self, number):\\n        return number < len(self.frequency) and self.frequency[number] > 0 # Check if the frequency of the given number is greater than 0\\n```\\n\\n\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n![image.png](https://assets.leetcode.com/users/images/303fa18d-281d-49f0-87ef-1a018fc9a488_1681355186.0923774.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Hash Function"
                ],
                "code": "```java []\\nprivate final Map<Integer,Integer> map; // Map to store the count of each number\\nprivate final int[] frequency; // Array to store the frequency of each count\\npublic FrequencyTracker() {\\n    map = new HashMap<>();\\n    frequency = new int[(int) 1e5 + 1]; // Initialize the frequency array with a size of 10^5 + 1\\n}\\n\\npublic void add(int number) {\\n    Integer freq = map.getOrDefault(number, 0); // Get the current count of the number\\n    if (freq != null && frequency[freq] > 0) { // If the current count is already present, decrement its frequency\\n        frequency[freq]--;\\n    }\\n    map.compute(number, (k, v) -> v == null ? 1 : v + 1); // Increment the count of the number in the map\\n    frequency[map.get(number)]++; // Increment the frequency of the new count in the frequency array\\n}\\n\\npublic void deleteOne(int n) {\\n    Integer count = map.get(n); // Get the current count of the number\\n    if (count != null) {\\n        frequency[count]--; // Decrement the frequency of the current count in the frequency array\\n        if (count == 1) {\\n            map.remove(n); // If the count is 1, remove the number from the map\\n        } else {\\n            map.put(n, count - 1); // Decrement the count of the number in the map\\n            frequency[map.get(n)]++; // Increment the frequency of the new count in the frequency array\\n        }\\n    }\\n}\\n\\npublic boolean hasFrequency(int number) {\\n    return number < this.frequency.length && this.frequency[number] > 0; // Check if the frequency of the given number is greater than 0\\n}\\n```\n```c++ []\\nclass FrequencyTracker {\\nprivate:\\n    std::unordered_map<int, int> map; // Map to store the count of each number\\n    std::vector<int> frequency; // Vector to store the frequency of each count\\n\\npublic:\\n    FrequencyTracker() {\\n        frequency.resize(1e5 + 1); // Initialize the frequency vector with a size of 10^5 + 1\\n    }\\n\\n    void add(int number) {\\n        int freq = map[number]; // Get the current count of the number\\n        if (freq > 0 && frequency[freq] > 0) { // If the current count is already present, decrement its frequency\\n            frequency[freq]--;\\n        }\\n        map[number]++; // Increment the count of the number in the map\\n        frequency[map[number]]++; // Increment the frequency of the new count in the frequency vector\\n    }\\n\\n    void deleteOne(int n) {\\n        int count = map[n]; // Get the current count of the number\\n        if (count > 0) {\\n            frequency[count]--; // Decrement the frequency of the current count in the frequency vector\\n            if (count == 1) {\\n                map.erase(n); // If the count is 1, remove the number from the map\\n            } else {\\n                map[n]--; // Decrement the count of the number in the map\\n                frequency[map[n]]++; // Increment the frequency of the new count in the frequency vector\\n            }\\n        }\\n    }\\n\\n    bool hasFrequency(int number) {\\n        return number < frequency.size() && frequency[number] > 0; // Check if the frequency of the given number is greater than 0\\n    }\\n};\\n```\n```python []\\nclass FrequencyTracker:\\n    def __init__(self):\\n        self.map = {} # Dictionary to store the count of each number\\n        self.frequency = [0] * (10**5 + 1) # List to store the frequency of each count\\n\\n    def add(self, number):\\n        freq = self.map.get(number, 0) # Get the current count of the number\\n        if freq > 0 and self.frequency[freq] > 0: # If the current count is already present, decrement its frequency\\n            self.frequency[freq] -= 1\\n        self.map[number] = freq + 1 # Increment the count of the number in the map\\n        self.frequency[self.map[number]] += 1 # Increment the frequency of the new count in the frequency list\\n\\n    def deleteOne(self, n):\\n        count = self.map.get(n, 0) # Get the current count of the number\\n        if count > 0:\\n            self.frequency[count] -= 1 # Decrement the frequency of the current count in the frequency list\\n            if count == 1:\\n                del self.map[n] # If the count is 1, remove the number from the map\\n            else:\\n                self.map[n] = count - 1 # Decrement the count of the number in the map\\n                self.frequency[self.map[n]] += 1 # Increment the frequency of the new count in the frequency list\\n\\n    def hasFrequency(self, number):\\n        return number < len(self.frequency) and self.frequency[number] > 0 # Check if the frequency of the given number is greater than 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499060,
                "title": "clean-solution-very-easy-to-understand-using-two-maps-faster-than-100",
                "content": "```\\nfrom collections import defaultdict\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.count = defaultdict(int)\\n        self.freq = defaultdict(set)\\n        \\n    def add(self, number: int) -> None:\\n        prevCount = self.count[number] \\n        # delete number if it is already present in the set at its current freq\\n        if number in self.freq[ prevCount ]:\\n            self.freq[self.count[number]].remove(number)\\n        \\n        #increment count or ocurence of number\\n        self.count[number] += 1\\n        newCount = prevCount + 1 \\n        #add number in the set at newCount\\n        self.freq[newCount].add(number)\\n        \\n    def deleteOne(self, number: int) -> None:\\n        # delete number if it is already present in the set at its current freq\\n        if number in self.freq[ self.count[number] ]:\\n            self.freq[self.count[number]].remove(number)\\n        \\n        if self.count[number]: # if number is alredy present, decrement its count by 1\\n            self.count[number] -= 1\\n            if self.count[number] == 0: # if its become remove from count dict \\n                del self.count[number]\\n            else: # otherwise add the number in the set at newCount\\n                newCount = self.count[number]\\n                self.freq[newCount].add(number) \\n    \\n    def hasFrequency(self, frequency: int) -> bool:\\n        # return true if set is exist(i.e length > 0) at frequency, otherwise false \\n        return self.freq[frequency]\\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.count = defaultdict(int)\\n        self.freq = defaultdict(set)\\n        \\n    def add(self, number: int) -> None:\\n        prevCount = self.count[number] \\n        # delete number if it is already present in the set at its current freq\\n        if number in self.freq[ prevCount ]:\\n            self.freq[self.count[number]].remove(number)\\n        \\n        #increment count or ocurence of number\\n        self.count[number] += 1\\n        newCount = prevCount + 1 \\n        #add number in the set at newCount\\n        self.freq[newCount].add(number)\\n        \\n    def deleteOne(self, number: int) -> None:\\n        # delete number if it is already present in the set at its current freq\\n        if number in self.freq[ self.count[number] ]:\\n            self.freq[self.count[number]].remove(number)\\n        \\n        if self.count[number]: # if number is alredy present, decrement its count by 1\\n            self.count[number] -= 1\\n            if self.count[number] == 0: # if its become remove from count dict \\n                del self.count[number]\\n            else: # otherwise add the number in the set at newCount\\n                newCount = self.count[number]\\n                self.freq[newCount].add(number) \\n    \\n    def hasFrequency(self, frequency: int) -> bool:\\n        # return true if set is exist(i.e length > 0) at frequency, otherwise false \\n        return self.freq[frequency]\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 3494888,
                "title": "cpp-two-maps",
                "content": "### Intuition\\nJust count frequency of elements and frequency of frequecies.\\n\\n### TIme Complexity : `O(n)`\\n\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp1,mp2;\\n    FrequencyTracker() {\\n        \\n        \\n    }\\n    void add(int x) {\\n        if(mp2[mp1[x]] > 0) {\\n            mp2[mp1[x]]--;\\n        }\\n        ++mp1[x];\\n        mp2[mp1[x]]++;\\n        \\n    }\\n    void deleteOne(int x) {\\n        if(mp1[x] > 0) {\\n            mp2[mp1[x]]--;\\n            mp1[x]--;\\n            mp2[mp1[x]]++;\\n        }\\n    }\\n    bool hasFrequency(int f) {\\n        return mp2[f] > 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp1,mp2;\\n    FrequencyTracker() {\\n        \\n        \\n    }\\n    void add(int x) {\\n        if(mp2[mp1[x]] > 0) {\\n            mp2[mp1[x]]--;\\n        }\\n        ++mp1[x];\\n        mp2[mp1[x]]++;\\n        \\n    }\\n    void deleteOne(int x) {\\n        if(mp1[x] > 0) {\\n            mp2[mp1[x]]--;\\n            mp1[x]--;\\n            mp2[mp1[x]]++;\\n        }\\n    }\\n    bool hasFrequency(int f) {\\n        return mp2[f] > 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494884,
                "title": "simple-map-easy-to-understand-clean-code",
                "content": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int, int>numCount;  //count of \"numbers\" with a given \"number\"\\n    unordered_map<int, int>freqCount; //count of \"numbers\" with a given \"freq\"\\n    FrequencyTracker() {  }\\n    \\n    void add(int number) \\n    {\\n        int oldNumCount = numCount[number];\\n        int newNumCount = ++numCount[number]; //increment first, then use\\n        \\n        freqCount[oldNumCount]--;\\n        freqCount[newNumCount]++;\\n    }\\n    \\n    void deleteOne(int number) \\n    {\\n        int oldNumCount = numCount[number];\\n        if (oldNumCount == 0) return;\\n        int newNumCount = --numCount[number];\\n        \\n        freqCount[oldNumCount]--;\\n        freqCount[newNumCount]++;\\n    }\\n    \\n    bool hasFrequency(int frequency) \\n    {\\n        return (freqCount[frequency] != 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int, int>numCount;  //count of \"numbers\" with a given \"number\"\\n    unordered_map<int, int>freqCount; //count of \"numbers\" with a given \"freq\"\\n    FrequencyTracker() {  }\\n    \\n    void add(int number) \\n    {\\n        int oldNumCount = numCount[number];\\n        int newNumCount = ++numCount[number]; //increment first, then use\\n        \\n        freqCount[oldNumCount]--;\\n        freqCount[newNumCount]++;\\n    }\\n    \\n    void deleteOne(int number) \\n    {\\n        int oldNumCount = numCount[number];\\n        if (oldNumCount == 0) return;\\n        int newNumCount = --numCount[number];\\n        \\n        freqCount[oldNumCount]--;\\n        freqCount[newNumCount]++;\\n    }\\n    \\n    bool hasFrequency(int frequency) \\n    {\\n        return (freqCount[frequency] != 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494874,
                "title": "2-unordered-maps",
                "content": "# Intuition\\nOne for frequency and one for element.\\n\\n# Approach\\nMaintain 2 unordered maps.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    unordered_map<int, int> f, have;\\n    \\n    void remove(unordered_map<int, int> &m, int x) {\\n        if (--m[x] == 0) {\\n            m.erase(x);\\n        }\\n    }\\n        \\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        remove(f, have[number]);\\n        ++f[++have[number]];\\n        \\n    }\\n    \\n    void deleteOne(int number) {\\n        if (!have.count(number)) {\\n            return;\\n        }\\n        remove(f, have[number]);\\n        ++f[have[number] - 1];\\n        remove(have, number);\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return f.count(frequency);\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    unordered_map<int, int> f, have;\\n    \\n    void remove(unordered_map<int, int> &m, int x) {\\n        if (--m[x] == 0) {\\n            m.erase(x);\\n        }\\n    }\\n        \\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        remove(f, have[number]);\\n        ++f[++have[number]];\\n        \\n    }\\n    \\n    void deleteOne(int number) {\\n        if (!have.count(number)) {\\n            return;\\n        }\\n        remove(f, have[number]);\\n        ++f[have[number] - 1];\\n        remove(have, number);\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return f.count(frequency);\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497498,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    int ele[], freq[];\\n    public FrequencyTracker() {\\n        ele=new int[100001];\\n        freq=new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        if(ele[number]>0)\\n        {\\n            freq[ele[number]]--;\\n        }\\n        ele[number]++;\\n        freq[ele[number]]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(ele[number]>0)\\n        {\\n            freq[ele[number]]--;\\n            ele[number]--;\\n            freq[ele[number]]++;\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freq[frequency]>0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    int ele[], freq[];\\n    public FrequencyTracker() {\\n        ele=new int[100001];\\n        freq=new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        if(ele[number]>0)\\n        {\\n            freq[ele[number]]--;\\n        }\\n        ele[number]++;\\n        freq[ele[number]]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(ele[number]>0)\\n        {\\n            freq[ele[number]]--;\\n            ele[number]--;\\n            freq[ele[number]]++;\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freq[frequency]>0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496734,
                "title": "two-map-approach",
                "content": "# Approach\\nStore added number and its frequency.\\n\\nTo run `hasFrequency` mathod fast, we need another map.\\n\\n# Complexity\\n- Time complexity: all method can run in $O(1)$ time\\n\\n- Space complexity: $O(n)$\\n\\n# Code\\n```\\nclass FrequencyTracker:\\n    \"\"\"\\n    Properties:\\n      count: count the frequency of the given number\\n      freq: how many numbers occurs with given frequency \\n    \"\"\"\\n    def __init__(self):\\n        self.count = defaultdict(int)\\n        self.freq = defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        self.freq[self.count[number]] -= 1\\n        self.count[number] += 1\\n        self.freq[self.count[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        if self.count[number] > 0:\\n            self.freq[self.count[number]] -= 1\\n            self.count[number] -= 1\\n            self.freq[self.count[number]] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FrequencyTracker:\\n    \"\"\"\\n    Properties:\\n      count: count the frequency of the given number\\n      freq: how many numbers occurs with given frequency \\n    \"\"\"\\n    def __init__(self):\\n        self.count = defaultdict(int)\\n        self.freq = defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        self.freq[self.count[number]] -= 1\\n        self.count[number] += 1\\n        self.freq[self.count[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        if self.count[number] > 0:\\n            self.freq[self.count[number]] -= 1\\n            self.count[number] -= 1\\n            self.freq[self.count[number]] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495616,
                "title": "c-only-solution-you-need-to-see",
                "content": "# Intuition\\nThe problem requires us to create a class that maintains the frequency of elements in a given set and provides the following operations:\\n\\nAdd an element to the set\\nDelete an element from the set\\nCheck if a given frequency exists in the set\\nOne way to approach this problem is to use a map to maintain the frequency of elements in the set. We can also maintain another map to keep track of the frequencies of frequencies. This will help us in implementing the hasFrequency() function in constant time.\\n\\n# Approach\\nThe FrequencyTracker class has three functions: add(), deleteOne(), and hasFrequency().\\n\\nThe add() function takes an integer as input and increments its frequency in the map mp. If the frequency of the number was previously greater than zero, we decrement the frequency count in the frequency map np. We then update the frequency count in the frequency map for the new frequency count.\\n\\nThe deleteOne() function takes an integer as input and decrements its frequency in the map mp. If the frequency of the number was greater than zero, we decrement the frequency count in the frequency map np. We then update the frequency count in the frequency map for the new frequency count. If the frequency of the number becomes zero, we remove it from the map mp.\\n\\nThe hasFrequency() function takes an integer as input and returns true if the input integer is present in the frequency map np. Otherwise, it returns false.\\n\\n# Complexity\\n**Time complexity:** The time complexity of the add() and deleteOne() functions is O(log n) because they use the map data structure, which takes logarithmic time for insertions, deletions, and searches. The time complexity of the hasFrequency() function is O(1) because it directly accesses the frequency map np.\\n\\n**Space complexity:** The space complexity of the FrequencyTracker class is O(n), where n is the number of elements in the set. This is because we use two maps of size n to store the frequency counts and the frequency of frequencies.\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    map<int,int> mp,np;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int num) {\\n        if(mp[num]>0)\\n        {\\n            np[mp[num]]--;\\n        }\\n        mp[num]++;\\n        np[mp[num]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n         if(mp[number]>0)\\n        {\\n            np[mp[number]]--;\\n              mp[number]--;\\n             \\n        if(mp[number] == 0)\\n        {\\n            mp.erase(number);\\n        }\\n             else{\\n                 np[mp[number]]++;\\n             }\\n        }\\n       \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return np[frequency] > 0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    map<int,int> mp,np;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int num) {\\n        if(mp[num]>0)\\n        {\\n            np[mp[num]]--;\\n        }\\n        mp[num]++;\\n        np[mp[num]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n         if(mp[number]>0)\\n        {\\n            np[mp[number]]--;\\n              mp[number]--;\\n             \\n        if(mp[number] == 0)\\n        {\\n            mp.erase(number);\\n        }\\n             else{\\n                 np[mp[number]]++;\\n             }\\n        }\\n       \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return np[frequency] > 0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495747,
                "title": "using-map-c-easy-to-understnad",
                "content": "STORE FREDUCY IN MAP.\\nMAINTAIN COUNT OF FREQUENCIES\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    vector<int> v;\\n    unordered_map<int,int> mp;\\n    FrequencyTracker() {\\n        v.resize(1e5+1);\\n    }\\n    \\n    void add(int x) {\\n        if(v[x]>0){\\n            mp[v[x]]--;\\n            if(mp[v[x]]==0){\\n                mp.erase(v[x]);\\n            }\\n        }\\n        v[x]++;\\n        mp[v[x]]++;\\n    }\\n    \\n    void deleteOne(int x) {\\n        if(v[x]){\\n            mp[v[x]]--;\\n            if(mp[v[x]]==0)mp.erase(v[x]);\\n            v[x]--;\\n            mp[v[x]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int x) {\\n        return mp.count(x);\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    vector<int> v;\\n    unordered_map<int,int> mp;\\n    FrequencyTracker() {\\n        v.resize(1e5+1);\\n    }\\n    \\n    void add(int x) {\\n        if(v[x]>0){\\n            mp[v[x]]--;\\n            if(mp[v[x]]==0){\\n                mp.erase(v[x]);\\n            }\\n        }\\n        v[x]++;\\n        mp[v[x]]++;\\n    }\\n    \\n    void deleteOne(int x) {\\n        if(v[x]){\\n            mp[v[x]]--;\\n            if(mp[v[x]]==0)mp.erase(v[x]);\\n            v[x]--;\\n            mp[v[x]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int x) {\\n        return mp.count(x);\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495305,
                "title": "both-using-maps-and-arrays-solution-simple-and-easy",
                "content": "# **Using Two Maps**\\n```\\nclass FrequencyTracker {\\n    unordered_map<int,int> freq,map;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(map[number] > 0) freq[map[number]]--;\\n        map[number]++;\\n        freq[map[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(map[number] > 0) {\\n            freq[map[number]]--;\\n            map[number]--;\\n            freq[map[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency] > 0;\\n    }\\n};\\n```\\n\\n# Using Two arrays\\n```\\nclass FrequencyTracker {\\n    int arr[100001],freq[100001];\\npublic:\\n    FrequencyTracker() {\\n        for(int i = 0;i<100001;i++) arr[i] = 0;\\n        for(int i = 0;i<100001;i++) freq[i] = 0;\\n\\n    }\\n    \\n    void add(int number) {\\n        if(arr[number]>0){\\n            int pre = arr[number];\\n            freq[pre]--;\\n            arr[number]++;\\n            int af = arr[number];\\n            freq[af]++;\\n            return ;\\n        }\\n        arr[number]++;\\n        int t = arr[number];\\n        freq[t]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(arr[number] ==0 ) return ;\\n        int pre = arr[number];\\n        freq[pre]--;\\n        arr[number]--;\\n        int af = arr[number];\\n        freq[af]++;\\n    }\\n    \\n    bool hasFrequency(int fr) {\\n        if(freq[fr]>0) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    unordered_map<int,int> freq,map;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(map[number] > 0) freq[map[number]]--;\\n        map[number]++;\\n        freq[map[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(map[number] > 0) {\\n            freq[map[number]]--;\\n            map[number]--;\\n            freq[map[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency] > 0;\\n    }\\n};\\n```\n```\\nclass FrequencyTracker {\\n    int arr[100001],freq[100001];\\npublic:\\n    FrequencyTracker() {\\n        for(int i = 0;i<100001;i++) arr[i] = 0;\\n        for(int i = 0;i<100001;i++) freq[i] = 0;\\n\\n    }\\n    \\n    void add(int number) {\\n        if(arr[number]>0){\\n            int pre = arr[number];\\n            freq[pre]--;\\n            arr[number]++;\\n            int af = arr[number];\\n            freq[af]++;\\n            return ;\\n        }\\n        arr[number]++;\\n        int t = arr[number];\\n        freq[t]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(arr[number] ==0 ) return ;\\n        int pre = arr[number];\\n        freq[pre]--;\\n        arr[number]--;\\n        int af = arr[number];\\n        freq[af]++;\\n    }\\n    \\n    bool hasFrequency(int fr) {\\n        if(freq[fr]>0) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495095,
                "title": "simple-java-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n   int[] num = new int[100001];\\n   int[] fre = new int[100001];\\n    public FrequencyTracker() {\\n        \\n    }\\n    \\n    public void add(int number) {\\n        if(num[number] > 0){\\n            fre[num[number]]--;\\n        }\\n        num[number]++;\\n        fre[num[number]]++;    \\n    }\\n    \\n    public void deleteOne(int number) {\\n         if(num[number] > 0){\\n            fre[num[number]]--;\\n            num[number]--;\\n            fre[num[number]]++;\\n        }\\n       \\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return fre[frequency] > 0;\\n        \\n    }\\n}\\n\\n \\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n   int[] num = new int[100001];\\n   int[] fre = new int[100001];\\n    public FrequencyTracker() {\\n        \\n    }\\n    \\n    public void add(int number) {\\n        if(num[number] > 0){\\n            fre[num[number]]--;\\n        }\\n        num[number]++;\\n        fre[num[number]]++;    \\n    }\\n    \\n    public void deleteOne(int number) {\\n         if(num[number] > 0){\\n            fre[num[number]]--;\\n            num[number]--;\\n            fre[num[number]]++;\\n        }\\n       \\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return fre[frequency] > 0;\\n        \\n    }\\n}\\n\\n \\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495028,
                "title": "java-frequency-array-concise-code",
                "content": "``` java\\nclass FrequencyTracker {\\n    int[] freq;\\n    int[] count;\\n\\n    public FrequencyTracker() {\\n        freq = new int[100001];\\n        count = new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        freq[count[number]]--;\\n        count[number]++;\\n        freq[count[number]]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if (count[number] > 0) {\\n            freq[count[number]]--;\\n            count[number]--;\\n            freq[count[number]]++;\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freq[frequency] >= 1;\\n    }\\n}\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java\\nclass FrequencyTracker {\\n    int[] freq;\\n    int[] count;\\n\\n    public FrequencyTracker() {\\n        freq = new int[100001];\\n        count = new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        freq[count[number]]--;\\n        count[number]++;\\n        freq[count[number]]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if (count[number] > 0) {\\n            freq[count[number]]--;\\n            count[number]--;\\n            freq[count[number]]++;\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freq[frequency] >= 1;\\n    }\\n}\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494998,
                "title": "keep-2-hashmaps-and-update-them",
                "content": "# Intuition\\n$$add()$$ and $$deleteOne()$$ functions can be made using a hashmap easily. Both of them will change the frequency of $$number$$.\\nThat in turn will lead to a change in the frequencies, i.e. suppose the data structure had 3 numbers appear 5 times and 2 numbers appear  3 times. We have:\\n```\\nFreq[numbers appearing 5 times]=3\\nFreq[nummbers appearing 3 times]=2\\n```\\nIf $$add()$$ is called on a number that was present 5 times, won\\'t this number be present **6** times now? And **freq[5]=2** ?\\n\\nWe just have to keep updating this array. \\n\\n\\n# Approach\\nUse a HashMap two store frequency of a number. Update it accordingly as add and deleteOne functions are called.\\nKeep a frequency array, $$freq[20001]$$. \\n# freq[3]=2 means there are 2 numbers in the data structure that appear 3 times. \\n\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    int[] b;\\n    HashMap<Integer,Integer> map;\\n    public FrequencyTracker() {\\n        b= new int[200001];\\n        map = new HashMap<>(); \\n    }\\n    \\n    public void add(int number) {\\n        int x = map.getOrDefault(number,0);\\n        if(x!=0){\\n            b[x]--;\\n              \\n        }\\n        b[x+1]++;  \\n        map.put(number,x+1);\\n        \\n    }\\n    \\n    public void deleteOne(int number) {\\n        int x =map.getOrDefault(number,0);\\n        if(x==0){ // don\\'t do anything\\n            \\n        }\\n        else { \\n            b[x]--;\\n            b[x-1]++;\\n            map.put(number,x-1);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return b[frequency]>0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nFreq[numbers appearing 5 times]=3\\nFreq[nummbers appearing 3 times]=2\\n```\n```\\nclass FrequencyTracker {\\n    int[] b;\\n    HashMap<Integer,Integer> map;\\n    public FrequencyTracker() {\\n        b= new int[200001];\\n        map = new HashMap<>(); \\n    }\\n    \\n    public void add(int number) {\\n        int x = map.getOrDefault(number,0);\\n        if(x!=0){\\n            b[x]--;\\n              \\n        }\\n        b[x+1]++;  \\n        map.put(number,x+1);\\n        \\n    }\\n    \\n    public void deleteOne(int number) {\\n        int x =map.getOrDefault(number,0);\\n        if(x==0){ // don\\'t do anything\\n            \\n        }\\n        else { \\n            b[x]--;\\n            b[x-1]++;\\n            map.put(number,x-1);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return b[frequency]>0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494996,
                "title": "c-easy-two-maps",
                "content": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> map;\\n    unordered_map<int,int> freq;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int num) {\\n        \\n        if(map.find(num) == map.end())freq[1]++;\\n        else {\\n            freq[map[num]]--;\\n            if(freq[map[num]] == 0)freq.erase(map[num]);\\n            freq[map[num] + 1]++;\\n        }\\n        map[num]++;\\n        \\n    }\\n    \\n    void deleteOne(int num) {\\n        if(map.find(num) != map.end()) {\\n            freq[map[num]]--;\\n            if(freq[map[num]] == 0)freq.erase(map[num]);\\n            freq[map[num]-1]++;\\n            map[num]--;\\n            if(map[num] == 0) map.erase(num);\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequ) {\\n        if(freq.find(frequ) != freq.end())return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> map;\\n    unordered_map<int,int> freq;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int num) {\\n        \\n        if(map.find(num) == map.end())freq[1]++;\\n        else {\\n            freq[map[num]]--;\\n            if(freq[map[num]] == 0)freq.erase(map[num]);\\n            freq[map[num] + 1]++;\\n        }\\n        map[num]++;\\n        \\n    }\\n    \\n    void deleteOne(int num) {\\n        if(map.find(num) != map.end()) {\\n            freq[map[num]]--;\\n            if(freq[map[num]] == 0)freq.erase(map[num]);\\n            freq[map[num]-1]++;\\n            map[num]--;\\n            if(map[num] == 0) map.erase(num);\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequ) {\\n        if(freq.find(frequ) != freq.end())return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494985,
                "title": "c-solution-100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        int old_freq = count[number]++;\\n        freq[old_freq]--;\\n        freq[count[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if (count.find(number) != count.end()) {\\n            int old_freq = count[number]--;\\n            freq[old_freq]--;\\n            if (count[number] == 0) {\\n                count.erase(number);\\n            } else {\\n                freq[count[number]]++;\\n            }\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq.find(frequency) != freq.end() && freq[frequency] > 0;\\n    }\\nprivate:\\n   unordered_map<int, int> count;\\n   unordered_map<int, int> freq;\\n};\\n\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        int old_freq = count[number]++;\\n        freq[old_freq]--;\\n        freq[count[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if (count.find(number) != count.end()) {\\n            int old_freq = count[number]--;\\n            freq[old_freq]--;\\n            if (count[number] == 0) {\\n                count.erase(number);\\n            } else {\\n                freq[count[number]]++;\\n            }\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq.find(frequency) != freq.end() && freq[frequency] > 0;\\n    }\\nprivate:\\n   unordered_map<int, int> count;\\n   unordered_map<int, int> freq;\\n};\\n\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494962,
                "title": "java-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    Map<Integer, Integer> frequencyTracker;\\n    int[] arr = new int[100001];\\n\\n    public FrequencyTracker() {\\n        frequencyTracker = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        if(frequencyTracker.containsKey(number)) {\\n            arr[frequencyTracker.get(number)]--;\\n        }\\n        frequencyTracker.put(number, frequencyTracker.getOrDefault(number, 0) + 1);\\n        arr[frequencyTracker.get(number)]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(frequencyTracker.get(number) == null) {\\n            return;\\n        }\\n        \\n        arr[frequencyTracker.get(number)]--;\\n        frequencyTracker.put(number, frequencyTracker.getOrDefault(number, 0) - 1);\\n        if(frequencyTracker.get(number) != 0) {\\n            arr[frequencyTracker.get(number)]++;\\n        } else {\\n            frequencyTracker.remove(number);\\n        }  \\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(arr[frequency] > 0) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    Map<Integer, Integer> frequencyTracker;\\n    int[] arr = new int[100001];\\n\\n    public FrequencyTracker() {\\n        frequencyTracker = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        if(frequencyTracker.containsKey(number)) {\\n            arr[frequencyTracker.get(number)]--;\\n        }\\n        frequencyTracker.put(number, frequencyTracker.getOrDefault(number, 0) + 1);\\n        arr[frequencyTracker.get(number)]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(frequencyTracker.get(number) == null) {\\n            return;\\n        }\\n        \\n        arr[frequencyTracker.get(number)]--;\\n        frequencyTracker.put(number, frequencyTracker.getOrDefault(number, 0) - 1);\\n        if(frequencyTracker.get(number) != 0) {\\n            arr[frequencyTracker.get(number)]++;\\n        } else {\\n            frequencyTracker.remove(number);\\n        }  \\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(arr[frequency] > 0) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494905,
                "title": "simple-using-2-maps",
                "content": "Please upvote\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp;\\n    unordered_map<int,unordered_set<int>> freqMp; // maps frequency counts to integers\\n    FrequencyTracker() {\\n        mp.clear();\\n        freqMp.clear();\\n    }\\n    \\n    void add(int number) {\\n        int freq = mp[number];\\n        freqMp[freq].erase(number);\\n        freqMp[freq+1].insert(number);\\n        mp[number]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        int freq = mp[number];\\n        if(freq > 0) {\\n            freqMp[freq].erase(number);\\n            freqMp[freq-1].insert(number);\\n            mp[number]--;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freqMp.count(frequency) > 0 && !freqMp[frequency].empty();\\n    }\\n};\\n\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp;\\n    unordered_map<int,unordered_set<int>> freqMp; // maps frequency counts to integers\\n    FrequencyTracker() {\\n        mp.clear();\\n        freqMp.clear();\\n    }\\n    \\n    void add(int number) {\\n        int freq = mp[number];\\n        freqMp[freq].erase(number);\\n        freqMp[freq+1].insert(number);\\n        mp[number]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        int freq = mp[number];\\n        if(freq > 0) {\\n            freqMp[freq].erase(number);\\n            freqMp[freq-1].insert(number);\\n            mp[number]--;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freqMp.count(frequency) > 0 && !freqMp[frequency].empty();\\n    }\\n};\\n\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494904,
                "title": "java-solution-using-two-hashmaps",
                "content": "Here we will use two hashmaps. One with key as the number and another with the key as frequency. This will enable us to do lookups usign both number and frequencies. Thus, each operation be it update, deleteOne, put or get will cost us constant time. \\n```\\nclass FrequencyTracker {\\n\\t//  Map<freq, Set<elements_with_given_freq>\\n    Map<Integer, Set<Integer>> freq;\\n\\t//  Map<number, freq_of_that_number>\\n    Map<Integer, Integer> numbers;\\n    public FrequencyTracker() {\\n        freq = new HashMap<>();\\n        freq.put(0, new HashSet<Integer>());\\n        numbers = new HashMap();\\n    }\\n    \\n    public void add(int number) {\\n        Integer old_freq = numbers.get(number);\\n        int new_freq = old_freq==null ? 1 : old_freq+1;\\n        update_freq(number, new_freq, old_freq);\\n        numbers.put(number, new_freq);\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(!numbers.containsKey(number) || numbers.get(number)==0) return;\\n        int old_freq = numbers.get(number);\\n        int new_freq = old_freq-1;\\n        numbers.put(number, new_freq);\\n        update_freq(number, new_freq, old_freq);\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(freq.containsKey(frequency) && freq.get(frequency).size()!=0) return true;\\n        return false;\\n    }\\n    \\n    public void update_freq(int num, int new_freq, Integer old_freq) {\\n        if(old_freq!=null) freq.get(old_freq).remove(num);\\n        if(!freq.containsKey(new_freq)) freq.put(new_freq, new HashSet<Integer>());\\n        freq.get(new_freq).add(num);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n\\t//  Map<freq, Set<elements_with_given_freq>\\n    Map<Integer, Set<Integer>> freq;\\n\\t//  Map<number, freq_of_that_number>\\n    Map<Integer, Integer> numbers;\\n    public FrequencyTracker() {\\n        freq = new HashMap<>();\\n        freq.put(0, new HashSet<Integer>());\\n        numbers = new HashMap();\\n    }\\n    \\n    public void add(int number) {\\n        Integer old_freq = numbers.get(number);\\n        int new_freq = old_freq==null ? 1 : old_freq+1;\\n        update_freq(number, new_freq, old_freq);\\n        numbers.put(number, new_freq);\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(!numbers.containsKey(number) || numbers.get(number)==0) return;\\n        int old_freq = numbers.get(number);\\n        int new_freq = old_freq-1;\\n        numbers.put(number, new_freq);\\n        update_freq(number, new_freq, old_freq);\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(freq.containsKey(frequency) && freq.get(frequency).size()!=0) return true;\\n        return false;\\n    }\\n    \\n    public void update_freq(int num, int new_freq, Integer old_freq) {\\n        if(old_freq!=null) freq.get(old_freq).remove(num);\\n        if(!freq.containsKey(new_freq)) freq.put(new_freq, new HashSet<Integer>());\\n        freq.get(new_freq).add(num);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707673,
                "title": "python-simple-solution-for-frequency-tracking-using-counter",
                "content": "### Help\\nHere, `self.f` is for counting frequency of numbers.\\nand `self.g` is for counting frequency of frequency.\\n\\nHere, this is the only catch you need to solve this problem.\\n\\n# Code\\n```\\nfrom collections import Counter, defaultdict\\n\\n\\nclass FrequencyTracker(object):\\n    def __init__(self) -> None:\\n        self.f = Counter()\\n        self.g = Counter()\\n        \\n    def add(self, number):\\n        self.f[number] += 1\\n        self.g[self.f[number]] += 1\\n        self.g[self.f[number] - 1] -= 1\\n        \\n    def deleteOne(self, number):\\n        if self.f[number]:\\n            self.f[number] -= 1\\n            if self.f[number] == 0: \\n                del self.f[number]\\n            self.g[self.f[number]] += 1\\n            self.g[self.f[number] + 1] -= 1 \\n\\n    \\n    def hasFrequency(self, frequency):\\n        return self.g[frequency] > 0\\n        \\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nfrom collections import Counter, defaultdict\\n\\n\\nclass FrequencyTracker(object):\\n    def __init__(self) -> None:\\n        self.f = Counter()\\n        self.g = Counter()\\n        \\n    def add(self, number):\\n        self.f[number] += 1\\n        self.g[self.f[number]] += 1\\n        self.g[self.f[number] - 1] -= 1\\n        \\n    def deleteOne(self, number):\\n        if self.f[number]:\\n            self.f[number] -= 1\\n            if self.f[number] == 0: \\n                del self.f[number]\\n            self.g[self.f[number]] += 1\\n            self.g[self.f[number] + 1] -= 1 \\n\\n    \\n    def hasFrequency(self, frequency):\\n        return self.g[frequency] > 0\\n        \\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496896,
                "title": "python3-solution",
                "content": "\\n```\\nclass FrequencyTracker:\\n    \\n    def __init__(self):\\n        self.count = defaultdict(int)\\n        self.freq = defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        self.freq[self.count[number]] -= 1\\n        self.count[number] += 1\\n        self.freq[self.count[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        if self.count[number] > 0:\\n            self.freq[self.count[number]] -= 1\\n            self.count[number] -= 1\\n            self.freq[self.count[number]] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass FrequencyTracker:\\n    \\n    def __init__(self):\\n        self.count = defaultdict(int)\\n        self.freq = defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        self.freq[self.count[number]] -= 1\\n        self.count[number] += 1\\n        self.freq[self.count[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        if self.count[number] > 0:\\n            self.freq[self.count[number]] -= 1\\n            self.count[number] -= 1\\n            self.freq[self.count[number]] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495518,
                "title": "java-o-1-explained",
                "content": "# **Up Vote \\u2705\\u2705\\u23EB\\u23CF**\\n\\n## **Approach :-**\\n\\n### **Each function take O(1) time complexity**\\n   **-- Because we are just accessing and updating the values**\\n\\n---\\n\\n## **Code :-**\\n\\n```\\nclass FrequencyTracker {\\n    int numbers[];         // It stores the how many time a particular number has occurred\\n    int checkFreq[];       // It stores the frequency of different numbers i.e If a particular freq is present or not\\n    public FrequencyTracker() {\\n        numbers=new int[100001];\\n        checkFreq=new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        if(numbers[number]>0)       // If the number has previously occured\\n          checkFreq[numbers[number]]--;    // Remove the old frequency that the number has saved\\n        \\n        numbers[number]++;          // Increase the frequency of the number \\n        \\n        checkFreq[numbers[number]]++;   // Now add the updated frequency of the number\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(numbers[number]>0){               // Check if number is present\\n            checkFreq[numbers[number]]--;    // Remove the old frequency that the number has saved\\n            \\n            numbers[number]--;               // Decrease the frequency of the number\\n            \\n            checkFreq[numbers[number]]++;    // Now add the updated frequency of the number\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(checkFreq[frequency]>0)           // Just check if the frequency is present or not\\n            return true;\\n        \\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    int numbers[];         // It stores the how many time a particular number has occurred\\n    int checkFreq[];       // It stores the frequency of different numbers i.e If a particular freq is present or not\\n    public FrequencyTracker() {\\n        numbers=new int[100001];\\n        checkFreq=new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        if(numbers[number]>0)       // If the number has previously occured\\n          checkFreq[numbers[number]]--;    // Remove the old frequency that the number has saved\\n        \\n        numbers[number]++;          // Increase the frequency of the number \\n        \\n        checkFreq[numbers[number]]++;   // Now add the updated frequency of the number\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(numbers[number]>0){               // Check if number is present\\n            checkFreq[numbers[number]]--;    // Remove the old frequency that the number has saved\\n            \\n            numbers[number]--;               // Decrease the frequency of the number\\n            \\n            checkFreq[numbers[number]]++;    // Now add the updated frequency of the number\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(checkFreq[frequency]>0)           // Just check if the frequency is present or not\\n            return true;\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495392,
                "title": "c-best-solution-frequency-may-count-map-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    public:\\n    unordered_map<int, int> frmp, cntmp;\\n\\n    FrequencyTracker() {\\n    }\\n    \\n    void add(int number) {\\n        int x = frmp[number];\\n        frmp[number]++;\\n        cntmp[x + 1]++;\\n        cntmp[x]--;\\n    }\\n    \\n    void deleteOne(int number) {\\n        int x = frmp[number];\\n        if(x <= 0) return;\\n        frmp[number]--;\\n        cntmp[x]--;\\n        cntmp[x - 1]++;\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return cntmp[frequency];\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Ordered Map"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    public:\\n    unordered_map<int, int> frmp, cntmp;\\n\\n    FrequencyTracker() {\\n    }\\n    \\n    void add(int number) {\\n        int x = frmp[number];\\n        frmp[number]++;\\n        cntmp[x + 1]++;\\n        cntmp[x]--;\\n    }\\n    \\n    void deleteOne(int number) {\\n        int x = frmp[number];\\n        if(x <= 0) return;\\n        frmp[number]--;\\n        cntmp[x]--;\\n        cntmp[x - 1]++;\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return cntmp[frequency];\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495304,
                "title": "easiest-c-solution-using-2-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<long long,long long> mp;\\n    unordered_map<long long,long long> mp1;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(mp1[mp[number]]!=0)\\n        mp1[mp[number]]-=number; // delete the old frequency\\n\\n        mp[number]++;//map the number with frequency\\n        mp1[mp[number]]+=number; //map the new frequency with the number\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]!=0){\\nmp1[mp[number]]-=number; //delete the old frequency\\n        \\n            mp[number]--; //delete the number\\n            \\n            mp1[mp[number]]+=number; //add the new frequency;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(mp1[frequency]>0){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<long long,long long> mp;\\n    unordered_map<long long,long long> mp1;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(mp1[mp[number]]!=0)\\n        mp1[mp[number]]-=number; // delete the old frequency\\n\\n        mp[number]++;//map the number with frequency\\n        mp1[mp[number]]+=number; //map the new frequency with the number\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]!=0){\\nmp1[mp[number]]-=number; //delete the old frequency\\n        \\n            mp[number]--; //delete the number\\n            \\n            mp1[mp[number]]+=number; //add the new frequency;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(mp1[frequency]>0){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495183,
                "title": "java-easy-using-2-arrays-explained-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMaintain 2 arrays:\\n\\ncounts: to maintain the count of numbers.\\n\\nfreq: to maintain a count of the frequencies.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n     int []counts;\\n     int[]freq;\\n\\n    public FrequencyTracker() {\\n            counts=new int[100001];\\n            freq=new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n      \\n             freq[counts[number]]--; //update the frequency of the count till now \\n            freq[++counts[number]]++;//update the frequency again after increasing the count\\n       \\n    }\\n    \\n    public void deleteOne(int number) {\\n       if(counts[number]!=0)\\n         {\\n               freq[counts[number]]--;//update the frequency of the count till now \\n                freq[--counts[number]]++;//update the frequency again after decreasing the count\\n         }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(freq[frequency]>0) return true;//if the desired frequency count is greater than 0 then return true\\n            return false;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n     int []counts;\\n     int[]freq;\\n\\n    public FrequencyTracker() {\\n            counts=new int[100001];\\n            freq=new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n      \\n             freq[counts[number]]--; //update the frequency of the count till now \\n            freq[++counts[number]]++;//update the frequency again after increasing the count\\n       \\n    }\\n    \\n    public void deleteOne(int number) {\\n       if(counts[number]!=0)\\n         {\\n               freq[counts[number]]--;//update the frequency of the count till now \\n                freq[--counts[number]]++;//update the frequency again after decreasing the count\\n         }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(freq[frequency]>0) return true;//if the desired frequency count is greater than 0 then return true\\n            return false;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495124,
                "title": "c-2-arrays",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(10^5)$$ \\n\\n# Code\\n```\\npublic class FrequencyTracker \\n{\\n    private int[] numberFreq;\\n    private int[] freqCount;\\n\\n    public FrequencyTracker()\\n    {\\n        numberFreq = new int[100001];\\n        freqCount = new int[100001];\\n    }\\n\\n    public void Add(int number)\\n    {\\n        int oldFreq = numberFreq[number];\\n        freqCount[oldFreq]--;\\n        freqCount[oldFreq+1]++;\\n        numberFreq[number]++;\\n    }\\n\\n    public void DeleteOne(int number)\\n    {\\n        if (numberFreq[number] > 0)\\n        {\\n            int oldFreq = numberFreq[number];\\n            freqCount[oldFreq]--;\\n            freqCount[oldFreq - 1]++;\\n            numberFreq[number]--;\\n        }\\n    }\\n\\n    public bool HasFrequency(int frequency)\\n    {\\n        return freqCount[frequency] > 0 ? true : false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class FrequencyTracker \\n{\\n    private int[] numberFreq;\\n    private int[] freqCount;\\n\\n    public FrequencyTracker()\\n    {\\n        numberFreq = new int[100001];\\n        freqCount = new int[100001];\\n    }\\n\\n    public void Add(int number)\\n    {\\n        int oldFreq = numberFreq[number];\\n        freqCount[oldFreq]--;\\n        freqCount[oldFreq+1]++;\\n        numberFreq[number]++;\\n    }\\n\\n    public void DeleteOne(int number)\\n    {\\n        if (numberFreq[number] > 0)\\n        {\\n            int oldFreq = numberFreq[number];\\n            freqCount[oldFreq]--;\\n            freqCount[oldFreq - 1]++;\\n            numberFreq[number]--;\\n        }\\n    }\\n\\n    public bool HasFrequency(int frequency)\\n    {\\n        return freqCount[frequency] > 0 ? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495037,
                "title": "easy-c-unordered-map",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> x,y;\\n    void add(int number) {\\n        x[number]++;\\n        if(x[number]!=1) y[x[number]-1]--;\\n        y[x[number]]++;\\n    }\\n    void deleteOne(int number) {\\n        if(x[number]!=0){\\n            x[number]--;\\n            y[x[number]+1]--;\\n            y[x[number]]++;\\n        }\\n    }\\n    bool hasFrequency(int frequency) {\\n        if(y[frequency]!=0) return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> x,y;\\n    void add(int number) {\\n        x[number]++;\\n        if(x[number]!=1) y[x[number]-1]--;\\n        y[x[number]]++;\\n    }\\n    void deleteOne(int number) {\\n        if(x[number]!=0){\\n            x[number]--;\\n            y[x[number]+1]--;\\n            y[x[number]]++;\\n        }\\n    }\\n    bool hasFrequency(int frequency) {\\n        if(y[frequency]!=0) return true;\\n        return false;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 3494865,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nvar FrequencyTracker = function() {\\n    this.freq = {};\\n    this.hasFreq = {};\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.add = function(number) {\\n    this.freq[number] = ++this.freq[number] || 1;\\n    if (this.freq[number] > 1) {\\n        this.hasFreq[this.freq[number] - 1].delete(number);\\n    }\\n    if (!this.hasFreq[this.freq[number]]) {\\n        this.hasFreq[this.freq[number]] = new Set();\\n    }\\n    this.hasFreq[this.freq[number]].add(number);\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.deleteOne = function(number) {\\n    if (this.freq[number]) {\\n        this.hasFreq[this.freq[number]].delete(number);\\n        this.freq[number]--;\\n        if (this.freq[number]) {\\n            this.hasFreq[this.freq[number]].add(number);\\n        }\\n    }\\n};\\n\\n/** \\n * @param {number} frequency\\n * @return {boolean}\\n */\\nFrequencyTracker.prototype.hasFrequency = function(frequency) {\\n    return !!this.hasFreq[frequency]?.size;\\n};\\n\\n/** \\n * Your FrequencyTracker object will be instantiated and called as such:\\n * var obj = new FrequencyTracker()\\n * obj.add(number)\\n * obj.deleteOne(number)\\n * var param_3 = obj.hasFrequency(frequency)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar FrequencyTracker = function() {\\n    this.freq = {};\\n    this.hasFreq = {};\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.add = function(number) {\\n    this.freq[number] = ++this.freq[number] || 1;\\n    if (this.freq[number] > 1) {\\n        this.hasFreq[this.freq[number] - 1].delete(number);\\n    }\\n    if (!this.hasFreq[this.freq[number]]) {\\n        this.hasFreq[this.freq[number]] = new Set();\\n    }\\n    this.hasFreq[this.freq[number]].add(number);\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.deleteOne = function(number) {\\n    if (this.freq[number]) {\\n        this.hasFreq[this.freq[number]].delete(number);\\n        this.freq[number]--;\\n        if (this.freq[number]) {\\n            this.hasFreq[this.freq[number]].add(number);\\n        }\\n    }\\n};\\n\\n/** \\n * @param {number} frequency\\n * @return {boolean}\\n */\\nFrequencyTracker.prototype.hasFrequency = function(frequency) {\\n    return !!this.hasFreq[frequency]?.size;\\n};\\n\\n/** \\n * Your FrequencyTracker object will be instantiated and called as such:\\n * var obj = new FrequencyTracker()\\n * obj.add(number)\\n * obj.deleteOne(number)\\n * var param_3 = obj.hasFrequency(frequency)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049318,
                "title": "c-using-two-maps-simple-easy",
                "content": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int>mp;   // element -> its count/frequency\\n    unordered_map<int,int>freq;  // any frequency -> number of elements with this frequency\\n    \\n    FrequencyTracker() {\\n    }\\n    \\n    void add(int number) {\\n        freq[mp[number]]--;\\n        mp[number]++;\\n        freq[mp[number]]++;      \\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]==0){return;}\\n        freq[mp[number]]--;\\n        mp[number]--;\\n        freq[mp[number]]++;\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency]>0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int>mp;   // element -> its count/frequency\\n    unordered_map<int,int>freq;  // any frequency -> number of elements with this frequency\\n    \\n    FrequencyTracker() {\\n    }\\n    \\n    void add(int number) {\\n        freq[mp[number]]--;\\n        mp[number]++;\\n        freq[mp[number]]++;      \\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]==0){return;}\\n        freq[mp[number]]--;\\n        mp[number]--;\\n        freq[mp[number]]++;\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency]>0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774804,
                "title": "two-unordered-maps-easy-c-beats-92",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse **two unordered maps**, one will **store the frequency of the numbers** and one will **store the current frequency of the numbers**.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> freq,checkfreq;\\n    FrequencyTracker() {}\\n    void add(int number) {\\n        if(freq.find(number)==freq.end())\\n        {\\n            freq[number]++;\\n            checkfreq[freq[number]]++;\\n        }\\n        else\\n        {\\n            checkfreq[freq[number]]--;\\n            if(checkfreq[freq[number]]==0) checkfreq.erase(freq[number]);\\n            freq[number]++;\\n            checkfreq[freq[number]]++;\\n        }\\n    }\\n    void deleteOne(int number) {\\n        if(freq.find(number)!=freq.end())\\n        {\\n            checkfreq[freq[number]]--;\\n            if(checkfreq[freq[number]]==0) checkfreq.erase(freq[number]);\\n            freq[number]--;\\n            if(freq[number]>0) checkfreq[freq[number]]++;\\n            if(freq[number]==0) freq.erase(number);\\n        }\\n    }\\n    bool hasFrequency(int f) {\\n        return checkfreq.find(f)!=checkfreq.end();\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/6e97149a-c02f-4cdb-969c-64c92f8b69f0_1689528824.3558578.jpeg)",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> freq,checkfreq;\\n    FrequencyTracker() {}\\n    void add(int number) {\\n        if(freq.find(number)==freq.end())\\n        {\\n            freq[number]++;\\n            checkfreq[freq[number]]++;\\n        }\\n        else\\n        {\\n            checkfreq[freq[number]]--;\\n            if(checkfreq[freq[number]]==0) checkfreq.erase(freq[number]);\\n            freq[number]++;\\n            checkfreq[freq[number]]++;\\n        }\\n    }\\n    void deleteOne(int number) {\\n        if(freq.find(number)!=freq.end())\\n        {\\n            checkfreq[freq[number]]--;\\n            if(checkfreq[freq[number]]==0) checkfreq.erase(freq[number]);\\n            freq[number]--;\\n            if(freq[number]>0) checkfreq[freq[number]]++;\\n            if(freq[number]==0) freq.erase(number);\\n        }\\n    }\\n    bool hasFrequency(int f) {\\n        return checkfreq.find(f)!=checkfreq.end();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577990,
                "title": "easy-solution-using-2-arrays",
                "content": "# Complexity\\n- Time complexity : $$O(Q)$$ (per query - $$O(1)$$)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    vector<int> nums; // stores the frequency of the number \"i\"\\n    vector<int> freq; // stores the count of numbers having frequency \"i\"\\n    FrequencyTracker() {\\n        nums.resize(100001,0);\\n        freq.resize(100001,0);\\n    }\\n    \\n    void add(int num) {\\n        --freq[nums[num]];\\n        ++nums[num];\\n        ++freq[nums[num]];\\n    }\\n    \\n    void deleteOne(int num) {\\n        if(nums[num] == 0) return;\\n        \\n        --freq[nums[num]];\\n        --nums[num];\\n        ++freq[nums[num]];\\n    }\\n    \\n    bool hasFrequency(int fr) {\\n        return freq[fr]>0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    vector<int> nums; // stores the frequency of the number \"i\"\\n    vector<int> freq; // stores the count of numbers having frequency \"i\"\\n    FrequencyTracker() {\\n        nums.resize(100001,0);\\n        freq.resize(100001,0);\\n    }\\n    \\n    void add(int num) {\\n        --freq[nums[num]];\\n        ++nums[num];\\n        ++freq[nums[num]];\\n    }\\n    \\n    void deleteOne(int num) {\\n        if(nums[num] == 0) return;\\n        \\n        --freq[nums[num]];\\n        --nums[num];\\n        ++freq[nums[num]];\\n    }\\n    \\n    bool hasFrequency(int fr) {\\n        return freq[fr]>0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561203,
                "title": "best-c-code-optimized",
                "content": "# Code\\n### Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp;\\n    unordered_map<int,unordered_set<int>> m2;\\n    FrequencyTracker() {}\\n    \\n    void add(int number) {\\n        if(mp.find(number) != mp.end()){\\n            m2[mp[number]].erase(number);\\n            m2[mp[number] + 1].insert(number);\\n        }\\n        else \\n            m2[1].insert(number);\\n        mp[number] ++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number) != mp.end()){\\n            m2[mp[number]].erase(number);\\n            m2[mp[number] - 1].insert(number);\\n            mp[number] --;\\n            if(mp[number] == 0)\\n                mp.erase(number);\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(m2[frequency].size() > 0)\\n            return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp;\\n    unordered_map<int,unordered_set<int>> m2;\\n    FrequencyTracker() {}\\n    \\n    void add(int number) {\\n        if(mp.find(number) != mp.end()){\\n            m2[mp[number]].erase(number);\\n            m2[mp[number] + 1].insert(number);\\n        }\\n        else \\n            m2[1].insert(number);\\n        mp[number] ++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number) != mp.end()){\\n            m2[mp[number]].erase(number);\\n            m2[mp[number] - 1].insert(number);\\n            mp[number] --;\\n            if(mp[number] == 0)\\n                mp.erase(number);\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(m2[frequency].size() > 0)\\n            return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560555,
                "title": "java-easy-100-solution-with-2-hashmaps",
                "content": "```java\\nimport java.util.HashMap;\\nimport java.util.Map;\\nimport java.util.TreeMap;\\n\\nclass FrequencyTracker {\\n    private final Map<Integer, Integer> numbers;\\n    private final Map<Integer, Integer> occurrences;\\n\\n    public FrequencyTracker() {\\n        numbers = new HashMap<>();\\n        occurrences = new HashMap<>();\\n    }\\n\\n    public void add(final int number) {\\n        final int oldFreq = numbers.getOrDefault(number, 0);\\n        final int newFreq = oldFreq + 1;\\n\\n        numbers.put(number, newFreq);\\n\\n        updateOccurrences(oldFreq, newFreq);\\n    }\\n\\n    public void deleteOne(final int number) {\\n        if(!numbers.containsKey(number))\\n            return;\\n\\n        final int oldFreq = numbers.get(number);\\n        final int newFreq = oldFreq - 1;\\n\\n        numbers.put(number, newFreq);\\n\\n        updateOccurrences(oldFreq, newFreq);\\n\\n        if(newFreq == 0)\\n            numbers.remove(number);\\n    }\\n\\n    public boolean hasFrequency(final int frequency) {\\n        return occurrences.containsKey(frequency);\\n    }\\n\\n    private void updateOccurrences(final int oldFreq, final int newFreq) {\\n        if(oldFreq > 0) {\\n            final int count = occurrences.get(oldFreq);\\n\\n            if(count == 1)\\n                occurrences.remove(oldFreq);\\n            else\\n                occurrences.put(oldFreq, count - 1);\\n        }\\n\\n        occurrences.put(newFreq, occurrences.getOrDefault(newFreq, 0) + 1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nimport java.util.HashMap;\\nimport java.util.Map;\\nimport java.util.TreeMap;\\n\\nclass FrequencyTracker {\\n    private final Map<Integer, Integer> numbers;\\n    private final Map<Integer, Integer> occurrences;\\n\\n    public FrequencyTracker() {\\n        numbers = new HashMap<>();\\n        occurrences = new HashMap<>();\\n    }\\n\\n    public void add(final int number) {\\n        final int oldFreq = numbers.getOrDefault(number, 0);\\n        final int newFreq = oldFreq + 1;\\n\\n        numbers.put(number, newFreq);\\n\\n        updateOccurrences(oldFreq, newFreq);\\n    }\\n\\n    public void deleteOne(final int number) {\\n        if(!numbers.containsKey(number))\\n            return;\\n\\n        final int oldFreq = numbers.get(number);\\n        final int newFreq = oldFreq - 1;\\n\\n        numbers.put(number, newFreq);\\n\\n        updateOccurrences(oldFreq, newFreq);\\n\\n        if(newFreq == 0)\\n            numbers.remove(number);\\n    }\\n\\n    public boolean hasFrequency(final int frequency) {\\n        return occurrences.containsKey(frequency);\\n    }\\n\\n    private void updateOccurrences(final int oldFreq, final int newFreq) {\\n        if(oldFreq > 0) {\\n            final int count = occurrences.get(oldFreq);\\n\\n            if(count == 1)\\n                occurrences.remove(oldFreq);\\n            else\\n                occurrences.put(oldFreq, count - 1);\\n        }\\n\\n        occurrences.put(newFreq, occurrences.getOrDefault(newFreq, 0) + 1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529672,
                "title": "java-all-o-1-operations",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCode is self explanatory.\\n\\n# Complexity\\ntime:  add, delete, and check freq, all O(1)\\nspace: O(N)\\n# Code\\nSome optimization:\\nYou can change countsByFrequencies to Map<Integer, Integer> to track the count of each freq.\\n```\\nclass FrequencyTracker {\\n    Map<Integer, Integer> freqByNumber = new HashMap<>();\\n    Map<Integer, Integer> countsByFrequencies = new HashMap<>();\\n    public FrequencyTracker() {}\\n    \\n    public void add(int number) {\\n        int freq = freqByNumber.getOrDefault(number, 0);\\n        if (freq != 0) countsByFrequencies.put(freq, countsByFrequencies.get(freq) - 1);\\n        countsByFrequencies.put(freq + 1, countsByFrequencies.getOrDefault(freq + 1, 0) + 1);\\n        freqByNumber.put(number, freq + 1);\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if (!freqByNumber.containsKey(number)) return;\\n        int freq = freqByNumber.get(number);\\n        countsByFrequencies.put(freq, countsByFrequencies.get(freq) - 1);\\n        if (freq == 1) {\\n            freqByNumber.remove(number);\\n            return;\\n        }\\n        countsByFrequencies.put(freq - 1, countsByFrequencies.getOrDefault(freq - 1, 0) + 1);\\n        freqByNumber.put(number, freq - 1);\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return countsByFrequencies.getOrDefault(frequency, 0)> 0;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    Map<Integer, Integer> freqByNumber = new HashMap<>();\\n    Map<Integer, Integer> countsByFrequencies = new HashMap<>();\\n    public FrequencyTracker() {}\\n    \\n    public void add(int number) {\\n        int freq = freqByNumber.getOrDefault(number, 0);\\n        if (freq != 0) countsByFrequencies.put(freq, countsByFrequencies.get(freq) - 1);\\n        countsByFrequencies.put(freq + 1, countsByFrequencies.getOrDefault(freq + 1, 0) + 1);\\n        freqByNumber.put(number, freq + 1);\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if (!freqByNumber.containsKey(number)) return;\\n        int freq = freqByNumber.get(number);\\n        countsByFrequencies.put(freq, countsByFrequencies.get(freq) - 1);\\n        if (freq == 1) {\\n            freqByNumber.remove(number);\\n            return;\\n        }\\n        countsByFrequencies.put(freq - 1, countsByFrequencies.getOrDefault(freq - 1, 0) + 1);\\n        freqByNumber.put(number, freq - 1);\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return countsByFrequencies.getOrDefault(frequency, 0)> 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506165,
                "title": "python-elegant-short-o-1-two-hash-tables",
                "content": "# Complexity\\n- Time complexity (each operation): $$O(1)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.__count: dict[int, int] = defaultdict(int)\\n        self.__freq: dict[int, int] = defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        self.__freq[self.__count[number]] -= 1\\n        self.__count[number] += 1\\n        self.__freq[self.__count[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        if self.__count[number] > 0:\\n            self.__freq[self.__count[number]] -= 1\\n            self.__count[number] -= 1\\n            self.__freq[self.__count[number]] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.__freq[frequency] > 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.__count: dict[int, int] = defaultdict(int)\\n        self.__freq: dict[int, int] = defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        self.__freq[self.__count[number]] -= 1\\n        self.__count[number] += 1\\n        self.__freq[self.__count[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        if self.__count[number] > 0:\\n            self.__freq[self.__count[number]] -= 1\\n            self.__count[number] -= 1\\n            self.__freq[self.__count[number]] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.__freq[frequency] > 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499648,
                "title": "java-2-maps",
                "content": "One map to keep track of the element\\'s current frequency and one to keep track of elements with that frequency. Recalculating of `frequencyToElements` map extract in separate method which is used with `previousFrequency` parameter (`current - 1 `/ `current + 1` for add / delete)\\n\\n```\\nclass FrequencyTracker {\\n\\n  private final Map<Integer, Integer> elementToFrequency;\\n  private final Map<Integer, Set<Integer>> frequencyToElements;\\n\\n  public FrequencyTracker() {\\n    elementToFrequency = new HashMap<>();\\n    frequencyToElements = new HashMap<>();\\n  }\\n\\n  public void add(int number) {\\n    elementToFrequency.put(number, elementToFrequency.getOrDefault(number, 0) + 1);\\n    recomputeFrequency(number, elementToFrequency.get(number) - 1);\\n  }\\n\\n  public void deleteOne(int number) {\\n    if (elementToFrequency.containsKey(number)) {\\n      elementToFrequency.put(number, elementToFrequency.get(number) - 1);\\n      recomputeFrequency(number, elementToFrequency.get(number) + 1);\\n\\n      if (elementToFrequency.get(number) == 0)\\n        elementToFrequency.remove(number);\\n    }\\n  }\\n\\n  private void recomputeFrequency(int number, int previousFrequency) {\\n    int frequency = elementToFrequency.get(number);\\n\\n    if (previousFrequency > 0) {\\n      frequencyToElements.get(previousFrequency).remove(number);\\n      if (frequencyToElements.get(previousFrequency).size() == 0)\\n        frequencyToElements.remove(previousFrequency);\\n    }\\n\\n    frequencyToElements.computeIfAbsent(frequency, p -> new HashSet<>()).add(number);\\n  }\\n\\n  public boolean hasFrequency(int frequency) {\\n    return frequencyToElements.containsKey(frequency);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n\\n  private final Map<Integer, Integer> elementToFrequency;\\n  private final Map<Integer, Set<Integer>> frequencyToElements;\\n\\n  public FrequencyTracker() {\\n    elementToFrequency = new HashMap<>();\\n    frequencyToElements = new HashMap<>();\\n  }\\n\\n  public void add(int number) {\\n    elementToFrequency.put(number, elementToFrequency.getOrDefault(number, 0) + 1);\\n    recomputeFrequency(number, elementToFrequency.get(number) - 1);\\n  }\\n\\n  public void deleteOne(int number) {\\n    if (elementToFrequency.containsKey(number)) {\\n      elementToFrequency.put(number, elementToFrequency.get(number) - 1);\\n      recomputeFrequency(number, elementToFrequency.get(number) + 1);\\n\\n      if (elementToFrequency.get(number) == 0)\\n        elementToFrequency.remove(number);\\n    }\\n  }\\n\\n  private void recomputeFrequency(int number, int previousFrequency) {\\n    int frequency = elementToFrequency.get(number);\\n\\n    if (previousFrequency > 0) {\\n      frequencyToElements.get(previousFrequency).remove(number);\\n      if (frequencyToElements.get(previousFrequency).size() == 0)\\n        frequencyToElements.remove(previousFrequency);\\n    }\\n\\n    frequencyToElements.computeIfAbsent(frequency, p -> new HashSet<>()).add(number);\\n  }\\n\\n  public boolean hasFrequency(int frequency) {\\n    return frequencyToElements.containsKey(frequency);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497882,
                "title": "python3-2-maps-simple-explained",
                "content": "# Intuition\\nKeep track of frequency. Loop and find number with `frequency`.\\n![image.png](https://assets.leetcode.com/users/images/7b8b7e9d-e88f-4df9-9c60-9bb94575faea_1683486745.3148494.png)\\n\\n\\n# Approach\\nThe idea is to use 2 dictionaries to keep track of frequencies of numbers.\\nfreq1 format: {number: frequency}\\nfreq2 format: {frequency: number of `number`s (with frequency of `frequency`)}\\nadd(number):\\n.....   Since the current frequency will increase, that means the number will not have a frequency of $$n$$. So, `self.freq2[self.freq1[number]]` decreases because the number of numbers with that frequency loses 1.\\n\\ndeleteOne(number):\\n.....   Same thing as add() but only delete an occurence if there is at least one occurence of a number. \\n> The data structure may not contain `number`, and in this case nothing is deleted.\\n---\\n\\n\\n\\n# Code\\n```\\nclass FrequencyTracker:\\n    def __init__(self):\\n        self.freq1 = collections.defaultdict(lambda: 0)\\n        self.freq2 = collections.defaultdict(lambda: 0)\\n\\n    def add(self, number: int) -> None:\\n        self.freq2[self.freq1[number]] -= 1\\n        self.freq1[number] += 1\\n        self.freq2[self.freq1[number]] += 1\\n    def deleteOne(self, number: int) -> None:\\n        if self.freq1[number] > 0:\\n            self.freq2[self.freq1[number]] -= 1\\n            self.freq1[number] -= 1\\n            self.freq2[self.freq1[number]] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        \"\"\"\\n        \"self.freq[frequency]\" results in the number of numbers with \\n        a frequency of \"frequency\", so access \"frequency\" from \\n        self.freq2 to know whether at least one number has such a\\n        frequency.\\n        \"\"\"\\n        return self.freq2[frequency] > 0\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FrequencyTracker:\\n    def __init__(self):\\n        self.freq1 = collections.defaultdict(lambda: 0)\\n        self.freq2 = collections.defaultdict(lambda: 0)\\n\\n    def add(self, number: int) -> None:\\n        self.freq2[self.freq1[number]] -= 1\\n        self.freq1[number] += 1\\n        self.freq2[self.freq1[number]] += 1\\n    def deleteOne(self, number: int) -> None:\\n        if self.freq1[number] > 0:\\n            self.freq2[self.freq1[number]] -= 1\\n            self.freq1[number] -= 1\\n            self.freq2[self.freq1[number]] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        \"\"\"\\n        \"self.freq[frequency]\" results in the number of numbers with \\n        a frequency of \"frequency\", so access \"frequency\" from \\n        self.freq2 to know whether at least one number has such a\\n        frequency.\\n        \"\"\"\\n        return self.freq2[frequency] > 0\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497359,
                "title": "excellent-performance-after-an-insight",
                "content": "# Intuition\\n\\uD83D\\uDD96 We want 3 things to be fast:\\n- a way to update the frequency of any value (its number of appearances),\\n- a way to update the number of values with a certain frequency,\\n- a way to find if there is at least one number with a certain number of appearances.\\n\\n\\uD83D\\uDECE Hash maps are ideal for this.\\nLet\\'s use them for counting the things above!\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMaintain a couple of mappings:\\n- from each unique value to its frequency\\n- from each unique frequency to the number of unique values appearing that number of times\\n\\nCarefully implement the required operations, taking care of specific situations:\\n- for adding one appearance of a number:\\n    - remove its previous frequency altogether if it was the only value with that frequency\\n\\n    - just decrease the number of values having the previous frequency otherwise\\n- for removing one appearance of a number:\\n    - do nothing if the number doesn\\'t appear at all\\n    - remove the number altogether if it only had one appearance\\n    - just decrease the frequency AND increase the number of values that have $previousFrequency-1$ appearances, otherwise\\n\\n    - remove its previous frequency altogether if the number was the only value with that frequency\\n    - just decrease the number of values having the previous frequency otherwise\\n\\n# Complexity\\n- Time complexity:\\n$$\\u0398(1)$$ for every operation: ``Add``, ``DeleteOne``, and ``HasFrequency``\\n\\n- Space complexity:\\n$$\\u0398(1)$$ for every operation: ``Add``, ``DeleteOne``, and ``HasFrequency``\\nThe overall space that\\'s used is $$\\u0398(d)+\\u0398(k)$$ for d distinct values, having k different frequencies.\\nExample: Adding these 9 values: [3, 3, 5, 6, 8, 8, 8, 9, 9] leads to:\\n    - d = 5 distinct values: 3, 5, 6, 8, and 9\\n    - k = 3 distinct frequencies: 1 (for 5 and 6), 2 (for 3 and 9), and 3 (for 8)\\n\\nSo these take up space proportional to $$d + k = 8 $$\\n\\n## \\uD83D\\uDC40 Notes\\n1. The update of the previous frequency of a value is identical when it is added / removed, so it can be extracted and reused.\\n1. When the range of values is relatively small, we can use slices instead of maps, but that reduces the generality. So this is better.\\n\\n# Code\\n```Go []\\ntype FrequencyTracker struct {\\n    valuesToFrequencies map[int]int\\n    frequenciesToValues map[int]int\\n}\\n\\nfunc Constructor() FrequencyTracker {\\n    return FrequencyTracker {\\n        valuesToFrequencies: make(map[int]int),\\n        frequenciesToValues: make(map[int]int),\\n    }    \\n}\\n\\nfunc (f *FrequencyTracker) Add(number int) {\\n    appearances := f.valuesToFrequencies[number]\\n    f.valuesToFrequencies[number] = appearances + 1\\n    f.frequenciesToValues[appearances + 1]++\\n\\n    frequencyAppearances := f.frequenciesToValues[appearances]\\n    if frequencyAppearances == 1  {\\n        delete(f.frequenciesToValues, appearances)\\n    } else {\\n        f.frequenciesToValues[appearances]--\\n    }\\n}\\n\\nfunc (f *FrequencyTracker) DeleteOne(number int) {\\n    appearances := f.valuesToFrequencies[number]\\n    if appearances == 0 {\\n        return\\n    }\\n\\n    if appearances == 1 {\\n        delete(f.valuesToFrequencies, number)\\n    } else {\\n        f.valuesToFrequencies[number] = appearances - 1\\n        f.frequenciesToValues[appearances - 1]++\\n    }\\n\\n    frequencyAppearances := f.frequenciesToValues[appearances]\\n    if frequencyAppearances == 1 {\\n        delete(f.frequenciesToValues, appearances)\\n    } else {\\n        f.frequenciesToValues[appearances]--\\n    }\\n}\\n\\nfunc (f *FrequencyTracker) HasFrequency(frequency int) bool {\\n    return f.frequenciesToValues[frequency] != 0\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * param_3 := obj.HasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Go",
                    "Design",
                    "Hash Function"
                ],
                "code": "```Go []\\ntype FrequencyTracker struct {\\n    valuesToFrequencies map[int]int\\n    frequenciesToValues map[int]int\\n}\\n\\nfunc Constructor() FrequencyTracker {\\n    return FrequencyTracker {\\n        valuesToFrequencies: make(map[int]int),\\n        frequenciesToValues: make(map[int]int),\\n    }    \\n}\\n\\nfunc (f *FrequencyTracker) Add(number int) {\\n    appearances := f.valuesToFrequencies[number]\\n    f.valuesToFrequencies[number] = appearances + 1\\n    f.frequenciesToValues[appearances + 1]++\\n\\n    frequencyAppearances := f.frequenciesToValues[appearances]\\n    if frequencyAppearances == 1  {\\n        delete(f.frequenciesToValues, appearances)\\n    } else {\\n        f.frequenciesToValues[appearances]--\\n    }\\n}\\n\\nfunc (f *FrequencyTracker) DeleteOne(number int) {\\n    appearances := f.valuesToFrequencies[number]\\n    if appearances == 0 {\\n        return\\n    }\\n\\n    if appearances == 1 {\\n        delete(f.valuesToFrequencies, number)\\n    } else {\\n        f.valuesToFrequencies[number] = appearances - 1\\n        f.frequenciesToValues[appearances - 1]++\\n    }\\n\\n    frequencyAppearances := f.frequenciesToValues[appearances]\\n    if frequencyAppearances == 1 {\\n        delete(f.frequenciesToValues, appearances)\\n    } else {\\n        f.frequenciesToValues[appearances]--\\n    }\\n}\\n\\nfunc (f *FrequencyTracker) HasFrequency(frequency int) bool {\\n    return f.frequenciesToValues[frequency] != 0\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * param_3 := obj.HasFrequency(frequency);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3496716,
                "title": "python-solution-using-defaultdict",
                "content": "# Code\\n```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.di=defaultdict(int)\\n        self.freq=defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        self.freq[self.di[number]]=max(0,self.freq[self.di[number]]-1)\\n        self.di[number]+=1\\n        self.freq[self.di[number]]+=1\\n\\n    def deleteOne(self, number: int) -> None:\\n        self.freq[self.di[number]]=max(0,self.freq[self.di[number]]-1)\\n        self.di[number]=max(self.di[number]-1,0)\\n        self.freq[self.di[number]]+=1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] != 0\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.di=defaultdict(int)\\n        self.freq=defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        self.freq[self.di[number]]=max(0,self.freq[self.di[number]]-1)\\n        self.di[number]+=1\\n        self.freq[self.di[number]]+=1\\n\\n    def deleteOne(self, number: int) -> None:\\n        self.freq[self.di[number]]=max(0,self.freq[self.di[number]]-1)\\n        self.di[number]=max(self.di[number]-1,0)\\n        self.freq[self.di[number]]+=1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] != 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496372,
                "title": "map",
                "content": "# Code\\n```\\nclass FrequencyTracker {\\n    map<int,int> mp;\\n    map<int,set<int>> fr;\\npublic:\\n    void add(int n) {\\n        if(!mp.count(n)){\\n            mp[n]++;\\n            fr[mp[n]].insert(n);\\n        }else{\\n            mp[n]++;\\n            fr[mp[n]-1].erase(n);\\n            if(fr[mp[n]-1].size() == 0) fr.erase(mp[n]-1);\\n            fr[mp[n]].insert(n);\\n        }\\n    }\\n    void deleteOne(int n) {\\n        if(!mp.count(n)) return;\\n        mp[n]--;\\n        fr[mp[n]+1].erase(n);\\n        if(fr[mp[n]+1].size() == 0) fr.erase(mp[n]+1);\\n        if(mp[n] == 0) mp.erase(n);\\n        else fr[mp[n]].insert(n);   \\n    }\\n    bool hasFrequency(int f) {\\n        return fr.count(f);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    map<int,int> mp;\\n    map<int,set<int>> fr;\\npublic:\\n    void add(int n) {\\n        if(!mp.count(n)){\\n            mp[n]++;\\n            fr[mp[n]].insert(n);\\n        }else{\\n            mp[n]++;\\n            fr[mp[n]-1].erase(n);\\n            if(fr[mp[n]-1].size() == 0) fr.erase(mp[n]-1);\\n            fr[mp[n]].insert(n);\\n        }\\n    }\\n    void deleteOne(int n) {\\n        if(!mp.count(n)) return;\\n        mp[n]--;\\n        fr[mp[n]+1].erase(n);\\n        if(fr[mp[n]+1].size() == 0) fr.erase(mp[n]+1);\\n        if(mp[n] == 0) mp.erase(n);\\n        else fr[mp[n]].insert(n);   \\n    }\\n    bool hasFrequency(int f) {\\n        return fr.count(f);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496106,
                "title": "2-hashmap-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar FrequencyTracker = function() {\\n    this.map={}  \\n    this.res={}\\n    \\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.add = function(number) {\\n    if (this.map[number]!==undefined){\\n        \\n          this.res[this.map[number]]-=1\\n          \\n          if (this.res[this.map[number]]===0) delete this.res[this.map[number]]\\n          \\n          this.map[number]+=1\\n          if (this.res[this.map[number]]!==undefined) this.res[this.map[number]]+=1\\n          else {\\n            this.res[this.map[number]]=1\\n          }\\n        \\n        \\n    }else{\\n        \\n        this.map[number]=1\\n        if (this.res[this.map[number]]!==undefined)this.res[this.map[number]]+=1\\n        else this.res[this.map[number]]=1\\n    }\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.deleteOne = function(number) {\\n    \\n    if (this.map[number]!==undefined){\\n        \\n          if (this.res[this.map[number]]!==undefined){\\n              this.res[this.map[number]]-=1\\n              if (this.res[this.map[number]]===0) delete this.res[this.map[number]]\\n              this.map[number]-=1\\n              if (this.map[number]===0)delete this.map[number]  \\n              if (this.res[this.map[number]]!==undefined)this.res[this.map[number]]+=1\\n              else this.res[this.map[number]]=1\\n\\n          }\\n      }\\n      \\n         \\n    \\n};\\n\\n/** \\n * @param {number} frequency\\n * @return {boolean}\\n */\\nFrequencyTracker.prototype.hasFrequency = function(frequency) {\\n    return this.res[frequency]!==undefined\\n};\\n\\n/** \\n * Your FrequencyTracker object will be instantiated and called as such:\\n * var obj = new FrequencyTracker()\\n * obj.add(number)\\n * obj.deleteOne(number)\\n * var param_3 = obj.hasFrequency(frequency)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar FrequencyTracker = function() {\\n    this.map={}  \\n    this.res={}\\n    \\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.add = function(number) {\\n    if (this.map[number]!==undefined){\\n        \\n          this.res[this.map[number]]-=1\\n          \\n          if (this.res[this.map[number]]===0) delete this.res[this.map[number]]\\n          \\n          this.map[number]+=1\\n          if (this.res[this.map[number]]!==undefined) this.res[this.map[number]]+=1\\n          else {\\n            this.res[this.map[number]]=1\\n          }\\n        \\n        \\n    }else{\\n        \\n        this.map[number]=1\\n        if (this.res[this.map[number]]!==undefined)this.res[this.map[number]]+=1\\n        else this.res[this.map[number]]=1\\n    }\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.deleteOne = function(number) {\\n    \\n    if (this.map[number]!==undefined){\\n        \\n          if (this.res[this.map[number]]!==undefined){\\n              this.res[this.map[number]]-=1\\n              if (this.res[this.map[number]]===0) delete this.res[this.map[number]]\\n              this.map[number]-=1\\n              if (this.map[number]===0)delete this.map[number]  \\n              if (this.res[this.map[number]]!==undefined)this.res[this.map[number]]+=1\\n              else this.res[this.map[number]]=1\\n\\n          }\\n      }\\n      \\n         \\n    \\n};\\n\\n/** \\n * @param {number} frequency\\n * @return {boolean}\\n */\\nFrequencyTracker.prototype.hasFrequency = function(frequency) {\\n    return this.res[frequency]!==undefined\\n};\\n\\n/** \\n * Your FrequencyTracker object will be instantiated and called as such:\\n * var obj = new FrequencyTracker()\\n * obj.add(number)\\n * obj.deleteOne(number)\\n * var param_3 = obj.hasFrequency(frequency)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3496004,
                "title": "python-100-runtime-two-dictionaries-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMake use of two dictionaries one to maintain the numbers count and one to\\nmaintain frequencies for fast access\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.ds = defaultdict(int)\\n        self.fs = defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        self.fs[self.ds[number]] -= 1\\n        self.ds[number] += 1\\n        self.fs[self.ds[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        self.fs[self.ds[number]] -= 1\\n        self.ds[number] = max(0,self.ds[number] - 1)\\n        self.fs[self.ds[number]] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.fs[frequency] > 0\\n        \\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.ds = defaultdict(int)\\n        self.fs = defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        self.fs[self.ds[number]] -= 1\\n        self.ds[number] += 1\\n        self.fs[self.ds[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        self.fs[self.ds[number]] -= 1\\n        self.ds[number] = max(0,self.ds[number] - 1)\\n        self.fs[self.ds[number]] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.fs[frequency] > 0\\n        \\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495935,
                "title": "java-all-three-operations-in-o-1-time-hashing",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nadd - O(1)\\ndeleteOne -O(1)\\nhasFrequency - O(1)\\n- Space complexity:\\n- two arrays of size 10^5 (constraints)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n  \\n  int[] count,freq;\\n    \\n    \\n    public FrequencyTracker() {\\n        count = new int[100001];\\n        freq = new int[100001];\\n\\n        \\n    }\\n    \\n    public void add(int n) {\\n      \\n        \\n       freq[count[n]] += (count[n] == 0) ? 0 : -1;\\n        \\n        count[n]++;\\n        \\n        freq[count[n]]++;\\n        \\n        \\n        \\n\\n    }\\n    \\n    public void deleteOne(int n) {\\n        \\n      \\n        freq[count[n]] += (freq[count[n]] == 0) ? 0 : - 1;\\n        \\n        count[n] += (count[n] == 0) ? 0 : -1;\\n        \\n        if(count[n] != 0)\\n        {\\n            freq[count[n]]++;\\n        }\\n        \\n        \\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        \\n        \\n        \\n    \\n\\n        return freq[frequency] != 0; \\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n  \\n  int[] count,freq;\\n    \\n    \\n    public FrequencyTracker() {\\n        count = new int[100001];\\n        freq = new int[100001];\\n\\n        \\n    }\\n    \\n    public void add(int n) {\\n      \\n        \\n       freq[count[n]] += (count[n] == 0) ? 0 : -1;\\n        \\n        count[n]++;\\n        \\n        freq[count[n]]++;\\n        \\n        \\n        \\n\\n    }\\n    \\n    public void deleteOne(int n) {\\n        \\n      \\n        freq[count[n]] += (freq[count[n]] == 0) ? 0 : - 1;\\n        \\n        count[n] += (count[n] == 0) ? 0 : -1;\\n        \\n        if(count[n] != 0)\\n        {\\n            freq[count[n]]++;\\n        }\\n        \\n        \\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        \\n        \\n        \\n    \\n\\n        return freq[frequency] != 0; \\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495512,
                "title": "java-arrays",
                "content": "```\\nclass FrequencyTracker {\\n    int[] ar = new int[100004];\\n//     freq, no of occurence of freq\\n    int[] freq = new int[100004];\\n    \\n    public FrequencyTracker() {\\n    }\\n    \\n    public void add(int number) {\\n        int prevFreq = ar[number];\\n        ar[number]++;    \\n        if(freq[ prevFreq] > 0){\\n            freq[prevFreq]--;\\n        }\\n        freq[ar[number]]++;\\n        return;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(ar[number] > 0){\\n            int curFreq = ar[number];\\n            ar[number]--;\\n            \\n            freq[curFreq]--;\\n            freq[ar[number]]++;\\n        }\\n        return;\\n        \\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freq[frequency] > 0; \\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    int[] ar = new int[100004];\\n//     freq, no of occurence of freq\\n    int[] freq = new int[100004];\\n    \\n    public FrequencyTracker() {\\n    }\\n    \\n    public void add(int number) {\\n        int prevFreq = ar[number];\\n        ar[number]++;    \\n        if(freq[ prevFreq] > 0){\\n            freq[prevFreq]--;\\n        }\\n        freq[ar[number]]++;\\n        return;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(ar[number] > 0){\\n            int curFreq = ar[number];\\n            ar[number]--;\\n            \\n            freq[curFreq]--;\\n            freq[ar[number]]++;\\n        }\\n        return;\\n        \\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freq[frequency] > 0; \\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495288,
                "title": "easy-to-understnd-java-solution-hashmap",
                "content": "# Intuition\\nOne possible optimization is to use two hash maps: one to keep track of the frequency of each number, and another to keep track of the numbers with a given frequency\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    HashMap<Integer, Integer> f;\\n    HashMap<Integer, Set<Integer>> ftn;\\n\\n    public FrequencyTracker() {\\n        f = new HashMap<>();\\n        ftn = new HashMap<>();\\n    }\\n\\n    public void add(int number) {\\n        int old = f.getOrDefault(number, 0);\\n        int cur = old + 1;\\n        f.put(number, cur);\\n        ftn.computeIfAbsent(old, k -> new HashSet<>()).remove(number);\\n        ftn.computeIfAbsent(cur, k -> new HashSet<>()).add(number);\\n    }\\n\\n    public void deleteOne(int number) {\\n        if (f.containsKey(number)) {\\n            int old = f.get(number);\\n            int cur = old - 1;\\n            f.put(number, cur);\\n            ftn.computeIfAbsent(old, k -> new HashSet<>()).remove(number);\\n            if (cur > 0) {\\n                ftn.computeIfAbsent(cur, k -> new HashSet<>()).add(number);\\n            } else {\\n                f.remove(number);\\n            }\\n        }\\n    }\\n\\n    public boolean hasFrequency(int frequency) {\\n        return ftn.containsKey(frequency) && !ftn.get(frequency).isEmpty();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    HashMap<Integer, Integer> f;\\n    HashMap<Integer, Set<Integer>> ftn;\\n\\n    public FrequencyTracker() {\\n        f = new HashMap<>();\\n        ftn = new HashMap<>();\\n    }\\n\\n    public void add(int number) {\\n        int old = f.getOrDefault(number, 0);\\n        int cur = old + 1;\\n        f.put(number, cur);\\n        ftn.computeIfAbsent(old, k -> new HashSet<>()).remove(number);\\n        ftn.computeIfAbsent(cur, k -> new HashSet<>()).add(number);\\n    }\\n\\n    public void deleteOne(int number) {\\n        if (f.containsKey(number)) {\\n            int old = f.get(number);\\n            int cur = old - 1;\\n            f.put(number, cur);\\n            ftn.computeIfAbsent(old, k -> new HashSet<>()).remove(number);\\n            if (cur > 0) {\\n                ftn.computeIfAbsent(cur, k -> new HashSet<>()).add(number);\\n            } else {\\n                f.remove(number);\\n            }\\n        }\\n    }\\n\\n    public boolean hasFrequency(int frequency) {\\n        return ftn.containsKey(frequency) && !ftn.get(frequency).isEmpty();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495277,
                "title": "extra-dictionary-for-frequency",
                "content": "# Code\\n```\\npublic class FrequencyTracker {\\n    \\n    private Dictionary<int, int> _dict = new();\\n    private Dictionary<int, int> _freq = new();\\n\\n    public FrequencyTracker() {\\n        \\n    }\\n    \\n    public void Add(int number) {\\n        \\n        if (_dict.ContainsKey(number))\\n        {\\n            if (_freq.ContainsKey(_dict[number]) && _freq[_dict[number]] > 0)\\n            {\\n                _freq[_dict[number]]--;\\n            }\\n            _dict[number]++;\\n        }\\n        else\\n        {\\n            _dict.Add(number, 1);\\n        }\\n        if (!_freq.ContainsKey(_dict[number]))\\n        {\\n            _freq.Add(_dict[number], 1);\\n        }\\n        else\\n        {\\n            _freq[_dict[number]]++;\\n        }\\n    }\\n    \\n    public void DeleteOne(int number) {\\n        \\n        if (_dict.ContainsKey(number) && _dict[number] > 0)\\n        {\\n            if (_freq.ContainsKey(_dict[number]) && _freq[_dict[number]] > 0)\\n            {\\n                _freq[_dict[number]]--;\\n            }\\n            _dict[number]--;\\n            if (_dict[number] != 0)\\n            {\\n               _freq[_dict[number]]++;\\n            }\\n        }\\n    }\\n    \\n    public bool HasFrequency(int frequency) {\\n        \\n        return _freq.ContainsKey(frequency) && _freq[frequency] > 0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * bool param_3 = obj.HasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class FrequencyTracker {\\n    \\n    private Dictionary<int, int> _dict = new();\\n    private Dictionary<int, int> _freq = new();\\n\\n    public FrequencyTracker() {\\n        \\n    }\\n    \\n    public void Add(int number) {\\n        \\n        if (_dict.ContainsKey(number))\\n        {\\n            if (_freq.ContainsKey(_dict[number]) && _freq[_dict[number]] > 0)\\n            {\\n                _freq[_dict[number]]--;\\n            }\\n            _dict[number]++;\\n        }\\n        else\\n        {\\n            _dict.Add(number, 1);\\n        }\\n        if (!_freq.ContainsKey(_dict[number]))\\n        {\\n            _freq.Add(_dict[number], 1);\\n        }\\n        else\\n        {\\n            _freq[_dict[number]]++;\\n        }\\n    }\\n    \\n    public void DeleteOne(int number) {\\n        \\n        if (_dict.ContainsKey(number) && _dict[number] > 0)\\n        {\\n            if (_freq.ContainsKey(_dict[number]) && _freq[_dict[number]] > 0)\\n            {\\n                _freq[_dict[number]]--;\\n            }\\n            _dict[number]--;\\n            if (_dict[number] != 0)\\n            {\\n               _freq[_dict[number]]++;\\n            }\\n        }\\n    }\\n    \\n    public bool HasFrequency(int frequency) {\\n        \\n        return _freq.ContainsKey(frequency) && _freq[frequency] > 0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * bool param_3 = obj.HasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495275,
                "title": "i-spent-so-much-time-on-this-and-it-s-probably-not-even-good-python-2-hashmap-solution-detailed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo the question is not too bad other than the fact that we have to implement a hasFrequency function. A single hashmap solution results in a time limit error since one of the test cases literally is entirely add and has frequency. Thus, to make this more efficient we use two hashmaps because you can never have too many hashmaps. \\n\\nOnto the actual small brain design of this solution. Essentially, we keep track of the number:frequencies and the frequencies:list(numbers) in two different hashmaps. We need to use frequency:list(numbers) since one frequency can have multiple different numbers in it. This enables us to check if the frequency exists more efficiently.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConstructor is simply creating the two hashmaps: I use collections.defaultdict(list) because it creates a hashmap with the values being a list.\\n\\nThe add function will first get the current frequency of the number. If it doesn\\'t exist, the default is set to 0 using the second parameter in the .get() method. Next, we update the number:frequency hashmap with the updated frequency. The more complicated part is to update the frequency:number part. We need to make sure to remove the number from its old frequency value.\\nThis is done using the \\n\\nif number in self.freqNums[currFreq]:\\n            self.freqNums[currFreq].remove(number)\\n\\npart of the code. \\nNext, we add the number to its new frequency value.\\nThis ensures that with each add operation the frequency:number hashmap is properly updated.\\n\\nThe deleteOne method is very similar, except the first thing we check is if we even need to do anything. If the number exists in the number:frequency hashmap and the frequency is greater than 0 we will get the current frequency stored and save it to a variable to help us with updating the frequency:number hashmap. Next, we update the number:frequency hashmap and then the frequency:number hashmap.\\n\\nThe last hasFrequency method checks if the frequency is in the frequency:number hashmap and the length of the list is greater than 0. This means that there are values that have that frequency and we return True. If this doesn\\'t hit we just return False outside.\\n\\nI hope my explanation helps people understand my solution. \\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.numFreq = {}\\n        self.freqNums = collections.defaultdict(list)\\n        \\n\\n    def add(self, number: int) -> None:\\n        currFreq = self.numFreq.get(number,0)\\n        self.numFreq[number] = 1 + currFreq\\n        if number in self.freqNums[currFreq]:\\n            self.freqNums[currFreq].remove(number)\\n        self.freqNums[1+currFreq].append(number)\\n        \\n\\n    def deleteOne(self, number: int) -> None:\\n        if number in self.numFreq and self.numFreq[number]>0:\\n            currFreq = self.numFreq[number]\\n            self.numFreq[number]-=1\\n            self.freqNums[currFreq].remove(number)\\n            self.freqNums[currFreq-1].append(number)\\n            \\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        if frequency in self.freqNums and len(self.freqNums[frequency]) > 0:\\n            return True\\n        return False\\n        \\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.numFreq = {}\\n        self.freqNums = collections.defaultdict(list)\\n        \\n\\n    def add(self, number: int) -> None:\\n        currFreq = self.numFreq.get(number,0)\\n        self.numFreq[number] = 1 + currFreq\\n        if number in self.freqNums[currFreq]:\\n            self.freqNums[currFreq].remove(number)\\n        self.freqNums[1+currFreq].append(number)\\n        \\n\\n    def deleteOne(self, number: int) -> None:\\n        if number in self.numFreq and self.numFreq[number]>0:\\n            currFreq = self.numFreq[number]\\n            self.numFreq[number]-=1\\n            self.freqNums[currFreq].remove(number)\\n            self.freqNums[currFreq-1].append(number)\\n            \\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        if frequency in self.freqNums and len(self.freqNums[frequency]) > 0:\\n            return True\\n        return False\\n        \\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495237,
                "title": "simple-map-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    private: unordered_map<int, int> freq;\\n    int mx_freq = 0;\\n    \\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        freq[number]++;\\n        if (freq[number] > mx_freq) {\\n            mx_freq = freq[number];\\n        }\\n    }\\n    \\n    void deleteOne(int number) {\\n         if (freq.find(number) != freq.end()) {\\n            freq[number]--;\\n            if (freq[number] == 0) {\\n                freq.erase(number);\\n            }\\n            if (freq.empty()) {\\n                mx_freq = 0;\\n            } else {\\n                auto it = max_element(freq.begin(), freq.end(), [](const auto& a, const auto& b) {\\n                    return a.second < b.second;\\n                });\\n                mx_freq = it->second;\\n            }\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n          return frequency <= mx_freq && any_of(freq.begin(), freq.end(), [frequency](const auto& p) {\\n            return p.second == frequency;\\n        });\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    private: unordered_map<int, int> freq;\\n    int mx_freq = 0;\\n    \\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        freq[number]++;\\n        if (freq[number] > mx_freq) {\\n            mx_freq = freq[number];\\n        }\\n    }\\n    \\n    void deleteOne(int number) {\\n         if (freq.find(number) != freq.end()) {\\n            freq[number]--;\\n            if (freq[number] == 0) {\\n                freq.erase(number);\\n            }\\n            if (freq.empty()) {\\n                mx_freq = 0;\\n            } else {\\n                auto it = max_element(freq.begin(), freq.end(), [](const auto& a, const auto& b) {\\n                    return a.second < b.second;\\n                });\\n                mx_freq = it->second;\\n            }\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n          return frequency <= mx_freq && any_of(freq.begin(), freq.end(), [frequency](const auto& p) {\\n            return p.second == frequency;\\n        });\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495195,
                "title": "lc-2671-m-python3-two-hashmaps",
                "content": "Use another hashmap to record the number of each frequency.\\nTC: $\\\\Omicron(1)$ (each call).\\n\\n```Python3 []\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.cnter, self.freq = defaultdict(int), defaultdict(int)\\n        \\n    def add(self, number: int) -> None:\\n        self.cnter[number] += 1\\n        self.freq[cnt := self.cnter[number]] += 1\\n        self.freq[cnt-1] -= 1\\n        \\n    def deleteOne(self, number: int) -> None:\\n        if self.cnter[number]:\\n            self.cnter[number] -= 1\\n            self.freq[cnt := self.cnter[number]] += 1\\n            self.freq[cnt+1] -= 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python3 []\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.cnter, self.freq = defaultdict(int), defaultdict(int)\\n        \\n    def add(self, number: int) -> None:\\n        self.cnter[number] += 1\\n        self.freq[cnt := self.cnter[number]] += 1\\n        self.freq[cnt-1] -= 1\\n        \\n    def deleteOne(self, number: int) -> None:\\n        if self.cnter[number]:\\n            self.cnter[number] -= 1\\n            self.freq[cnt := self.cnter[number]] += 1\\n            self.freq[cnt+1] -= 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494991,
                "title": "c-o-logn",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    unordered_map<int, int> ump;\\n    multiset<int> st;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(st.count(ump[number])) st.erase(st.find(ump[number]));\\n        ump[number]++;\\n        st.insert(ump[number]);\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(ump.find(number) != ump.end()){\\n        if(st.count(ump[number])) st.erase(st.find(ump[number]));\\n            ump[number]--;\\n            st.insert(ump[number]);\\n\\n            if(ump[number] == 0) ump.erase(number);\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(st.find(frequency) != st.end()) return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    unordered_map<int, int> ump;\\n    multiset<int> st;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(st.count(ump[number])) st.erase(st.find(ump[number]));\\n        ump[number]++;\\n        st.insert(ump[number]);\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(ump.find(number) != ump.end()){\\n        if(st.count(ump[number])) st.erase(st.find(ump[number]));\\n            ump[number]--;\\n            st.insert(ump[number]);\\n\\n            if(ump[number] == 0) ump.erase(number);\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(st.find(frequency) != st.end()) return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494966,
                "title": "c-maps-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(logn)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    map<int, int>m, m1;\\n    //vector<int>v;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        //v.push_back(number);\\n        if(m.find(number)!=m.end()){\\n            m1[m[number]]--;\\n            if(m1[m[number]]==0){\\n                m1.erase(m[number]);\\n            }\\n        }\\n        m[number]++;\\n        m1[m[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        \\n        if(m.find(number)!=m.end()){\\n            // auto it=find(v.begin(), v.end(), number)-v.begin();\\n            // v.erase(v.begin()+it);\\n            m1[m[number]]--;\\n            if(m1[m[number]]==0){\\n                m1.erase(m[number]);\\n            }\\n            m[number]--;\\n            if(m[number]==0){\\n                m.erase(number);\\n            }\\n            else{m1[m[number]]++;}\\n        }\\n        \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(m1[frequency]){return true;}\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    map<int, int>m, m1;\\n    //vector<int>v;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        //v.push_back(number);\\n        if(m.find(number)!=m.end()){\\n            m1[m[number]]--;\\n            if(m1[m[number]]==0){\\n                m1.erase(m[number]);\\n            }\\n        }\\n        m[number]++;\\n        m1[m[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        \\n        if(m.find(number)!=m.end()){\\n            // auto it=find(v.begin(), v.end(), number)-v.begin();\\n            // v.erase(v.begin()+it);\\n            m1[m[number]]--;\\n            if(m1[m[number]]==0){\\n                m1.erase(m[number]);\\n            }\\n            m[number]--;\\n            if(m[number]==0){\\n                m.erase(number);\\n            }\\n            else{m1[m[number]]++;}\\n        }\\n        \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(m1[frequency]){return true;}\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494859,
                "title": "c-two-map-solution",
                "content": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp;\\n    unordered_map<int,set<int>> track;\\n    FrequencyTracker() {\\n        mp.clear();\\n        track.clear();\\n    }\\n    \\n    void add(int number) {\\n        mp[number] += 1;\\n        if(track.find(mp[number]-1)!=track.end() && track[mp[number]-1].count(number)>0){\\n            track[mp[number]-1].erase(number);\\n        }\\n        track[mp[number]].insert(number);\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number)!=mp.end()){\\n            mp[number] -=1;\\n            track[mp[number]+1].erase(number);\\n            if(mp[number]>0) track[mp[number]].insert(number);\\n            if(mp[number] == 0){\\n                mp.erase(number);\\n            }\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return track[frequency].size()>0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp;\\n    unordered_map<int,set<int>> track;\\n    FrequencyTracker() {\\n        mp.clear();\\n        track.clear();\\n    }\\n    \\n    void add(int number) {\\n        mp[number] += 1;\\n        if(track.find(mp[number]-1)!=track.end() && track[mp[number]-1].count(number)>0){\\n            track[mp[number]-1].erase(number);\\n        }\\n        track[mp[number]].insert(number);\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number)!=mp.end()){\\n            mp[number] -=1;\\n            track[mp[number]+1].erase(number);\\n            if(mp[number]>0) track[mp[number]].insert(number);\\n            if(mp[number] == 0){\\n                mp.erase(number);\\n            }\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return track[frequency].size()>0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923221,
                "title": "using-two-maps-only-simple-approach",
                "content": "class FrequencyTracker {\\n    private:\\n    unordered_map<int,int> m;\\n    unordered_map<int,set<int>> map_freq;\\npublic:\\n    FrequencyTracker() {\\n        m.clear();\\n        map_freq.clear();\\n    }\\n    \\n    void add(int number) {\\n        if(m.count(number)){\\n            int freq=m[number];\\n            map_freq[freq].erase(number);\\n        }\\n        m[number]++;\\n        map_freq[m[number]].insert(number);\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(!m.count(number)){\\n            return;\\n        }\\n        int freq=m[number];\\n        map_freq[freq].erase(number);\\n        m[number]--;\\n        if(m[number]==0){\\n            m.erase(number);\\n            return;\\n        }\\n        map_freq[m[number]].insert(number);\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(map_freq[frequency].empty()){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */",
                "solutionTags": [],
                "code": "class FrequencyTracker {\\n    private:\\n    unordered_map<int,int> m;\\n    unordered_map<int,set<int>> map_freq;\\npublic:\\n    FrequencyTracker() {\\n        m.clear();\\n        map_freq.clear();\\n    }\\n    \\n    void add(int number) {\\n        if(m.count(number)){\\n            int freq=m[number];\\n            map_freq[freq].erase(number);\\n        }\\n        m[number]++;\\n        map_freq[m[number]].insert(number);\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(!m.count(number)){\\n            return;\\n        }\\n        int freq=m[number];\\n        map_freq[freq].erase(number);\\n        m[number]--;\\n        if(m[number]==0){\\n            m.erase(number);\\n            return;\\n        }\\n        map_freq[m[number]].insert(number);\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(map_freq[frequency].empty()){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 3921743,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class FrequencyTracker {\\n    private IList<int> _frequencyData;\\n    private Dictionary<int, int> _hash;\\n\\n    public FrequencyTracker() {\\n        _frequencyData = new List<int>() { 1 };\\n        _hash = new();\\n    }\\n    \\n    public void Add(int number) {\\n        if (!_hash.ContainsKey(number)){\\n            _hash.Add(number, 0);\\n        }\\n        _frequencyData[_hash[number]]--;\\n        _hash[number]++;\\n\\n        if (_hash[number] == _frequencyData.Count){\\n            _frequencyData.Add(1);\\n        }\\n        else{\\n            _frequencyData[_hash[number]]++;\\n        }\\n    }\\n    \\n    public void DeleteOne(int number) {\\n        if (!_hash.ContainsKey(number) || _hash[number] == 0){\\n            return;\\n        }\\n        _frequencyData[_hash[number]]--;\\n        _hash[number]--;\\n        _frequencyData[_hash[number]]++;\\n    }\\n    \\n    public bool HasFrequency(int frequency) {\\n        if (_frequencyData.Count <= frequency || _frequencyData[frequency] <= 0){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * bool param_3 = obj.HasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class FrequencyTracker {\\n    private IList<int> _frequencyData;\\n    private Dictionary<int, int> _hash;\\n\\n    public FrequencyTracker() {\\n        _frequencyData = new List<int>() { 1 };\\n        _hash = new();\\n    }\\n    \\n    public void Add(int number) {\\n        if (!_hash.ContainsKey(number)){\\n            _hash.Add(number, 0);\\n        }\\n        _frequencyData[_hash[number]]--;\\n        _hash[number]++;\\n\\n        if (_hash[number] == _frequencyData.Count){\\n            _frequencyData.Add(1);\\n        }\\n        else{\\n            _frequencyData[_hash[number]]++;\\n        }\\n    }\\n    \\n    public void DeleteOne(int number) {\\n        if (!_hash.ContainsKey(number) || _hash[number] == 0){\\n            return;\\n        }\\n        _frequencyData[_hash[number]]--;\\n        _hash[number]--;\\n        _frequencyData[_hash[number]]++;\\n    }\\n    \\n    public bool HasFrequency(int frequency) {\\n        if (_frequencyData.Count <= frequency || _frequencyData[frequency] <= 0){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * bool param_3 = obj.HasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903868,
                "title": "solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n public:\\n  void add(int number) {\\n    if (count[number] > 0)\\n      --freqCount[count[number]];\\n    ++count[number];\\n    ++freqCount[count[number]];\\n  }\\n\\n  void deleteOne(int number) {\\n    if (count[number] == 0)\\n      return;\\n    --freqCount[count[number]];\\n    --count[number];\\n    ++freqCount[count[number]];\\n  }\\n\\n  bool hasFrequency(int frequency) {\\n    return freqCount[frequency] > 0;\\n  }\\n\\n private:\\n  unordered_map<int, int> count;\\n  unordered_map<int, int> freqCount;\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\n public:\\n  void add(int number) {\\n    if (count[number] > 0)\\n      --freqCount[count[number]];\\n    ++count[number];\\n    ++freqCount[count[number]];\\n  }\\n\\n  void deleteOne(int number) {\\n    if (count[number] == 0)\\n      return;\\n    --freqCount[count[number]];\\n    --count[number];\\n    ++freqCount[count[number]];\\n  }\\n\\n  bool hasFrequency(int frequency) {\\n    return freqCount[frequency] > 0;\\n  }\\n\\n private:\\n  unordered_map<int, int> count;\\n  unordered_map<int, int> freqCount;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889373,
                "title": "java-solution-using-two-hashmaps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nFollow [this repo](https://github.com/g-sahu/Practice) for more solutions.\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    private final Map<Integer, Integer> numMap;\\n    private final Map<Integer, List<Integer>> freqMap;\\n\\n    public FrequencyTracker() {\\n        numMap = new HashMap<>();\\n        freqMap = new HashMap<>();\\n    }\\n\\n    public void add(int number) {\\n        int freq = numMap.getOrDefault(number, 0);\\n        increaseFreq(number, freq);\\n    }\\n\\n    public void deleteOne(int number) {\\n        if (numMap.containsKey(number)) {\\n            int freq = numMap.get(number);\\n            decreaseFreq(number, freq);\\n        }\\n    }\\n\\n    private void increaseFreq(int num, int freq) {\\n        //Update freqMap\\n        removeFromList(freq, num);\\n        addToList(freq+1, num);\\n\\n        //Update numMap\\n        int newFreq = numMap.getOrDefault(num, 0) + 1;\\n        numMap.put(num, newFreq);\\n    }\\n\\n    private void decreaseFreq(int num, int freq) {\\n        //Remove from current freq list and add to new freq list\\n        removeFromList(freq, num);\\n        addToList(freq-1, num);\\n\\n        //Update numMap\\n        int newFreq = numMap.get(num) - 1;\\n\\n        if (newFreq == 0) {\\n            numMap.remove(num);\\n        } else {\\n            numMap.put(num, newFreq);\\n        }\\n    }\\n\\n    private void addToList(int freq, int num) {\\n        List<Integer> list = freqMap.getOrDefault(freq, new ArrayList<>());\\n        list.add(num);\\n        freqMap.put(freq, list);\\n    }\\n\\n    private void removeFromList(int freq, int num) {\\n        if (freqMap.containsKey(freq)) {\\n            List<Integer> list = freqMap.get(freq);\\n            list.remove(Integer.valueOf(num));\\n\\n            if (list.isEmpty()) {\\n                freqMap.remove(freq);\\n            } else {\\n                freqMap.put(freq, list);\\n            }\\n        }\\n    }\\n\\n    public boolean hasFrequency(int frequency) {\\n        return freqMap.containsKey(frequency);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    private final Map<Integer, Integer> numMap;\\n    private final Map<Integer, List<Integer>> freqMap;\\n\\n    public FrequencyTracker() {\\n        numMap = new HashMap<>();\\n        freqMap = new HashMap<>();\\n    }\\n\\n    public void add(int number) {\\n        int freq = numMap.getOrDefault(number, 0);\\n        increaseFreq(number, freq);\\n    }\\n\\n    public void deleteOne(int number) {\\n        if (numMap.containsKey(number)) {\\n            int freq = numMap.get(number);\\n            decreaseFreq(number, freq);\\n        }\\n    }\\n\\n    private void increaseFreq(int num, int freq) {\\n        //Update freqMap\\n        removeFromList(freq, num);\\n        addToList(freq+1, num);\\n\\n        //Update numMap\\n        int newFreq = numMap.getOrDefault(num, 0) + 1;\\n        numMap.put(num, newFreq);\\n    }\\n\\n    private void decreaseFreq(int num, int freq) {\\n        //Remove from current freq list and add to new freq list\\n        removeFromList(freq, num);\\n        addToList(freq-1, num);\\n\\n        //Update numMap\\n        int newFreq = numMap.get(num) - 1;\\n\\n        if (newFreq == 0) {\\n            numMap.remove(num);\\n        } else {\\n            numMap.put(num, newFreq);\\n        }\\n    }\\n\\n    private void addToList(int freq, int num) {\\n        List<Integer> list = freqMap.getOrDefault(freq, new ArrayList<>());\\n        list.add(num);\\n        freqMap.put(freq, list);\\n    }\\n\\n    private void removeFromList(int freq, int num) {\\n        if (freqMap.containsKey(freq)) {\\n            List<Integer> list = freqMap.get(freq);\\n            list.remove(Integer.valueOf(num));\\n\\n            if (list.isEmpty()) {\\n                freqMap.remove(freq);\\n            } else {\\n                freqMap.put(freq, list);\\n            }\\n        }\\n    }\\n\\n    public boolean hasFrequency(int frequency) {\\n        return freqMap.containsKey(frequency);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884460,
                "title": "java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    int ele[], freq[];\\n    public FrequencyTracker() {\\n        ele=new int[100001];\\n        freq=new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        if(ele[number]>0)\\n        {\\n            freq[ele[number]]--;\\n        }\\n        ele[number]++;\\n        freq[ele[number]]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(ele[number]>0)\\n        {\\n            freq[ele[number]]--;\\n            ele[number]--;\\n            freq[ele[number]]++;\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freq[frequency]>0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    int ele[], freq[];\\n    public FrequencyTracker() {\\n        ele=new int[100001];\\n        freq=new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        if(ele[number]>0)\\n        {\\n            freq[ele[number]]--;\\n        }\\n        ele[number]++;\\n        freq[ele[number]]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(ele[number]>0)\\n        {\\n            freq[ele[number]]--;\\n            ele[number]--;\\n            freq[ele[number]]++;\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freq[frequency]>0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870945,
                "title": "swift-easy-solution-100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n\\n   var dictNums = [Int:Int]()\\n    var dictFrequency = [Int:Int]()\\n    \\n    init() {\\n        \\n    }\\n    \\n    func add(_ number: Int) {\\n        dictFrequency[dictNums[number,default: 0],default: 0] -= 1\\n        dictNums[number,default: 0] += 1\\n        dictFrequency[dictNums[number,default: 0],default: 0] += 1\\n    }\\n    \\n    func deleteOne(_ number: Int) {\\n        \\n        if dictNums[number,default: 0] > 0 {\\n            dictFrequency[dictNums[number,default: 0],default: 0] -= 1\\n            dictNums[number,default: 0] -= 1\\n            dictFrequency[dictNums[number,default: 0],default: 0] += 1\\n        }\\n    }\\n    \\n    func hasFrequency(_ frequency: Int) -> Bool {\\n        return dictFrequency[frequency,default: 0] > 0 //!= nil\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * let obj = FrequencyTracker()\\n * obj.add(number)\\n * obj.deleteOne(number)\\n * let ret_3: Bool = obj.hasFrequency(frequency)\\n */\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass FrequencyTracker {\\n\\n   var dictNums = [Int:Int]()\\n    var dictFrequency = [Int:Int]()\\n    \\n    init() {\\n        \\n    }\\n    \\n    func add(_ number: Int) {\\n        dictFrequency[dictNums[number,default: 0],default: 0] -= 1\\n        dictNums[number,default: 0] += 1\\n        dictFrequency[dictNums[number,default: 0],default: 0] += 1\\n    }\\n    \\n    func deleteOne(_ number: Int) {\\n        \\n        if dictNums[number,default: 0] > 0 {\\n            dictFrequency[dictNums[number,default: 0],default: 0] -= 1\\n            dictNums[number,default: 0] -= 1\\n            dictFrequency[dictNums[number,default: 0],default: 0] += 1\\n        }\\n    }\\n    \\n    func hasFrequency(_ frequency: Int) -> Bool {\\n        return dictFrequency[frequency,default: 0] > 0 //!= nil\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * let obj = FrequencyTracker()\\n * obj.add(number)\\n * obj.deleteOne(number)\\n * let ret_3: Bool = obj.hasFrequency(frequency)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856611,
                "title": "c-too-easy-clean-short-code",
                "content": "\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:map<int,int> p,q;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int n) {\\n        q[p[n]]--;\\n        p[n]++;\\n        q[p[n]]++;\\n    }\\n    \\n    void deleteOne(int n) {\\n        if(p[n]>0)\\n        {\\n        q[p[n]]--;\\n        p[n]--;\\n        q[p[n]]++;\\n        if(p[n]<=0) p.erase(n);\\n        }\\n    }\\n    \\n    bool hasFrequency(int f) {\\n        return q[f]>0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:map<int,int> p,q;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int n) {\\n        q[p[n]]--;\\n        p[n]++;\\n        q[p[n]]++;\\n    }\\n    \\n    void deleteOne(int n) {\\n        if(p[n]>0)\\n        {\\n        q[p[n]]--;\\n        p[n]--;\\n        q[p[n]]++;\\n        if(p[n]<=0) p.erase(n);\\n        }\\n    }\\n    \\n    bool hasFrequency(int f) {\\n        return q[f]>0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827155,
                "title": "c-beats-100-simple-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int, int> um;\\n    unordered_map<int, int> un;\\n    FrequencyTracker(){}\\n    \\n    void add(int number)\\n    {\\n        int curr = um[number];\\n        if(curr==0){um[number]=1;un[1]++;}\\n        else\\n        {\\n            um[number]=curr+1;\\n            if(un[curr]==1){un.erase(curr);}\\n            else{un[curr]--;}\\n            un[curr+1]++;\\n        }\\n\\n    }\\n    \\n    void deleteOne(int number)\\n    {\\n        if(um.count(number))\\n        {\\n            int curr = um[number];\\n            if(curr==1)\\n            {\\n                um.erase(number);\\n                if(un[curr]==1){un.erase(curr);}\\n                else{un[curr]--;}\\n            }\\n            else\\n            {\\n                um[number]=curr-1;\\n                if(un[curr]==1){un.erase(curr);}\\n                else{un[curr]--;}\\n                un[curr-1]++;\\n            }\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency)\\n    {\\n        return un.count(frequency);\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int, int> um;\\n    unordered_map<int, int> un;\\n    FrequencyTracker(){}\\n    \\n    void add(int number)\\n    {\\n        int curr = um[number];\\n        if(curr==0){um[number]=1;un[1]++;}\\n        else\\n        {\\n            um[number]=curr+1;\\n            if(un[curr]==1){un.erase(curr);}\\n            else{un[curr]--;}\\n            un[curr+1]++;\\n        }\\n\\n    }\\n    \\n    void deleteOne(int number)\\n    {\\n        if(um.count(number))\\n        {\\n            int curr = um[number];\\n            if(curr==1)\\n            {\\n                um.erase(number);\\n                if(un[curr]==1){un.erase(curr);}\\n                else{un[curr]--;}\\n            }\\n            else\\n            {\\n                um[number]=curr-1;\\n                if(un[curr]==1){un.erase(curr);}\\n                else{un[curr]--;}\\n                un[curr-1]++;\\n            }\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency)\\n    {\\n        return un.count(frequency);\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805766,
                "title": "python-two-dicts",
                "content": "```python\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.count = Counter()\\n        self.freq = Counter()\\n\\n    def add(self, number: int) -> None:\\n        self.count[number] += 1\\n\\n        self.freq[self.count[number] - 1] -= 1\\n        self.freq[self.count[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        if number not in self.count:\\n            return\\n\\n        self.count[number] -= 1\\n        \\n        if self.count[number] == 0:\\n            del self.count[number]\\n        \\n        self.freq[self.count[number] + 1] -= 1\\n        self.freq[self.count[number]] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.count = Counter()\\n        self.freq = Counter()\\n\\n    def add(self, number: int) -> None:\\n        self.count[number] += 1\\n\\n        self.freq[self.count[number] - 1] -= 1\\n        self.freq[self.count[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        if number not in self.count:\\n            return\\n\\n        self.count[number] -= 1\\n        \\n        if self.count[number] == 0:\\n            del self.count[number]\\n        \\n        self.freq[self.count[number] + 1] -= 1\\n        self.freq[self.count[number]] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773162,
                "title": "easy-c-code-using-2-unordered-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp;\\n    unordered_map<int,int> freq;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n      freq[mp[number]]--;\\n      mp[number]++;\\n      freq[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]>0){\\n        freq[mp[number]]--;\\n            mp[number]--;\\n        freq[mp[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(freq[frequency]>0){\\n            return true;\\n        }\\n        return false; \\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp;\\n    unordered_map<int,int> freq;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n      freq[mp[number]]--;\\n      mp[number]++;\\n      freq[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]>0){\\n        freq[mp[number]]--;\\n            mp[number]--;\\n        freq[mp[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(freq[frequency]>0){\\n            return true;\\n        }\\n        return false; \\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755373,
                "title": "golang-double-hash-solution",
                "content": "# Code\\n```go\\ntype FrequencyTracker struct {\\n\\tdata map[int]int\\n\\tfreq map[int]int\\n}\\n\\nfunc Constructor() FrequencyTracker {\\n\\treturn FrequencyTracker{\\n\\t\\tdata: map[int]int{},\\n\\t\\tfreq: map[int]int{},\\n\\t}\\n}\\n\\nfunc (ft *FrequencyTracker) Add(number int)  {\\n\\tif ft.data[number] >= 1 {\\n\\t\\tft.freq[ft.data[number]]--\\n\\t}\\n\\tft.data[number]++\\n\\tft.freq[ft.data[number]]++\\n}\\n\\nfunc (ft *FrequencyTracker) DeleteOne(number int)  {\\n\\tif ft.data[number] == 0 {\\n\\t\\treturn\\n\\t}\\n\\tft.freq[ft.data[number]]--\\n\\tft.data[number]--\\n\\tif ft.data[number] != 0 {\\n\\t\\tft.freq[ft.data[number]]++\\n\\t} else {\\n\\t\\tdelete(ft.data, number)\\n\\t}\\n}\\n\\nfunc (ft *FrequencyTracker) HasFrequency(frequency int) bool {\\n\\treturn ft.freq[frequency] > 0\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table"
                ],
                "code": "```go\\ntype FrequencyTracker struct {\\n\\tdata map[int]int\\n\\tfreq map[int]int\\n}\\n\\nfunc Constructor() FrequencyTracker {\\n\\treturn FrequencyTracker{\\n\\t\\tdata: map[int]int{},\\n\\t\\tfreq: map[int]int{},\\n\\t}\\n}\\n\\nfunc (ft *FrequencyTracker) Add(number int)  {\\n\\tif ft.data[number] >= 1 {\\n\\t\\tft.freq[ft.data[number]]--\\n\\t}\\n\\tft.data[number]++\\n\\tft.freq[ft.data[number]]++\\n}\\n\\nfunc (ft *FrequencyTracker) DeleteOne(number int)  {\\n\\tif ft.data[number] == 0 {\\n\\t\\treturn\\n\\t}\\n\\tft.freq[ft.data[number]]--\\n\\tft.data[number]--\\n\\tif ft.data[number] != 0 {\\n\\t\\tft.freq[ft.data[number]]++\\n\\t} else {\\n\\t\\tdelete(ft.data, number)\\n\\t}\\n}\\n\\nfunc (ft *FrequencyTracker) HasFrequency(frequency int) bool {\\n\\treturn ft.freq[frequency] > 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3750123,
                "title": "java-frequencytracker",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    private final Map<Integer, Integer> numberFrequencyMap;\\n    private final Map<Integer, Integer> freqCountMap;\\n\\n    public FrequencyTracker() {\\n        numberFrequencyMap = new HashMap<>(256);\\n        freqCountMap = new HashMap<>(256);\\n    }\\n\\n    public void add(int number) {\\n        var currentFreqCount = numberFrequencyMap.getOrDefault(number, 0);\\n        var newFreqCount = currentFreqCount + 1;\\n        numberFrequencyMap.put(number,newFreqCount);\\n\\n        freqCountMap.compute(newFreqCount, (k, v) -> v != null ? v + newFreqCount : newFreqCount);\\n        freqCountMap.computeIfPresent(currentFreqCount, (k, v) -> v != null && v > currentFreqCount ? v - currentFreqCount : null);\\n\\t\\tfreqCountMap.remove(currentFreqCount,null);\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n    }\\n\\n    public void deleteOne(int number) {\\n        if (!numberFrequencyMap.containsKey(number)) {\\n            return;\\n        }\\n\\n\\n        var freq = numberFrequencyMap.get(number);\\n        numberFrequencyMap.compute(number, (k, v) -> (v != null && v - 1 > 0) ? v - 1 : null);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\n        freqCountMap.compute(freq, (k, v) -> (v != null && v > freq) ? v - freq : null);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\n        if (freq != null && freq - 1 > 0) {\\n            freqCountMap.compute(freq - 1, (k, v) -> v != null ? v + (freq - 1) : freq - 1);\\n        }\\n    }\\n\\n    public boolean hasFrequency(int frequency) {\\n        return freqCountMap.containsKey(frequency);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    private final Map<Integer, Integer> numberFrequencyMap;\\n    private final Map<Integer, Integer> freqCountMap;\\n\\n    public FrequencyTracker() {\\n        numberFrequencyMap = new HashMap<>(256);\\n        freqCountMap = new HashMap<>(256);\\n    }\\n\\n    public void add(int number) {\\n        var currentFreqCount = numberFrequencyMap.getOrDefault(number, 0);\\n        var newFreqCount = currentFreqCount + 1;\\n        numberFrequencyMap.put(number,newFreqCount);\\n\\n        freqCountMap.compute(newFreqCount, (k, v) -> v != null ? v + newFreqCount : newFreqCount);\\n        freqCountMap.computeIfPresent(currentFreqCount, (k, v) -> v != null && v > currentFreqCount ? v - currentFreqCount : null);\\n\\t\\tfreqCountMap.remove(currentFreqCount,null);\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n    }\\n\\n    public void deleteOne(int number) {\\n        if (!numberFrequencyMap.containsKey(number)) {\\n            return;\\n        }\\n\\n\\n        var freq = numberFrequencyMap.get(number);\\n        numberFrequencyMap.compute(number, (k, v) -> (v != null && v - 1 > 0) ? v - 1 : null);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\n        freqCountMap.compute(freq, (k, v) -> (v != null && v > freq) ? v - freq : null);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\n        if (freq != null && freq - 1 > 0) {\\n            freqCountMap.compute(freq - 1, (k, v) -> v != null ? v + (freq - 1) : freq - 1);\\n        }\\n    }\\n\\n    public boolean hasFrequency(int frequency) {\\n        return freqCountMap.containsKey(frequency);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749342,
                "title": "java-frequencytracker",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass FrequencyTracker {\\n    private final Map<Integer, Integer> numberFrequencyMap;\\n    private final Map<Integer, Integer> freqCountMap;\\n\\n    public FrequencyTracker() {\\n        numberFrequencyMap = new HashMap<>(256);\\n        freqCountMap = new HashMap<>(256);\\n    }\\n\\n    public void add(int number) {\\n        var currentFreqCount = numberFrequencyMap.getOrDefault(number, 0);\\n        var newFreqCount = currentFreqCount + 1;\\n        numberFrequencyMap.compute(number, (k, v) -> currentFreqCount + 1);\\n        freqCountMap.compute(newFreqCount, (k, v) -> v != null ? v + newFreqCount : newFreqCount);\\n        freqCountMap.compute(currentFreqCount, (k, v) -> v != null && v > currentFreqCount ? v - currentFreqCount : null);\\n    }\\n\\n    public void deleteOne(int number) {\\n        var freq = numberFrequencyMap.get(number);\\n        numberFrequencyMap.compute(number, (k, v) -> (v != null && v - 1 > 0) ? v - 1 : null);\\n        freqCountMap.compute(freq, (k, v) -> (v != null && v > freq) ? v - freq : null);\\n        if (freq != null && freq - 1 > 0) {\\n            freqCountMap.compute(freq - 1, (k, v) -> v != null ? v + (freq - 1) : freq - 1);\\n        }\\n    }\\n\\n    public boolean hasFrequency(int frequency) {\\n        return freqCountMap.containsKey(frequency);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass FrequencyTracker {\\n    private final Map<Integer, Integer> numberFrequencyMap;\\n    private final Map<Integer, Integer> freqCountMap;\\n\\n    public FrequencyTracker() {\\n        numberFrequencyMap = new HashMap<>(256);\\n        freqCountMap = new HashMap<>(256);\\n    }\\n\\n    public void add(int number) {\\n        var currentFreqCount = numberFrequencyMap.getOrDefault(number, 0);\\n        var newFreqCount = currentFreqCount + 1;\\n        numberFrequencyMap.compute(number, (k, v) -> currentFreqCount + 1);\\n        freqCountMap.compute(newFreqCount, (k, v) -> v != null ? v + newFreqCount : newFreqCount);\\n        freqCountMap.compute(currentFreqCount, (k, v) -> v != null && v > currentFreqCount ? v - currentFreqCount : null);\\n    }\\n\\n    public void deleteOne(int number) {\\n        var freq = numberFrequencyMap.get(number);\\n        numberFrequencyMap.compute(number, (k, v) -> (v != null && v - 1 > 0) ? v - 1 : null);\\n        freqCountMap.compute(freq, (k, v) -> (v != null && v > freq) ? v - freq : null);\\n        if (freq != null && freq - 1 > 0) {\\n            freqCountMap.compute(freq - 1, (k, v) -> v != null ? v + (freq - 1) : freq - 1);\\n        }\\n    }\\n\\n    public boolean hasFrequency(int frequency) {\\n        return freqCountMap.containsKey(frequency);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737417,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.numbers = [0]*100_000\\n        self.frequencies = [0]*100_000\\n\\n    def add(self, number: int) -> None:\\n        number -= 1\\n        if self.numbers[number]:\\n            self.frequencies[self.numbers[number]-1] -= 1\\n        \\n        self.numbers[number] += 1\\n        self.frequencies[self.numbers[number]-1] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        number -= 1\\n        if self.numbers[number]:\\n            self.frequencies[self.numbers[number]-1] -= 1\\n            self.numbers[number] -= 1\\n\\n            if self.numbers[number]:\\n                self.frequencies[self.numbers[number]-1] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.frequencies[frequency-1]\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.numbers = [0]*100_000\\n        self.frequencies = [0]*100_000\\n\\n    def add(self, number: int) -> None:\\n        number -= 1\\n        if self.numbers[number]:\\n            self.frequencies[self.numbers[number]-1] -= 1\\n        \\n        self.numbers[number] += 1\\n        self.frequencies[self.numbers[number]-1] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        number -= 1\\n        if self.numbers[number]:\\n            self.frequencies[self.numbers[number]-1] -= 1\\n            self.numbers[number] -= 1\\n\\n            if self.numbers[number]:\\n                self.frequencies[self.numbers[number]-1] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.frequencies[frequency-1]\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726569,
                "title": "self-explanatory-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    map<int,int>freq,freqOfFreq;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(freq[number])\\n            freqOfFreq[freq[number]]--;\\n\\n        freq[number]++;\\n        freqOfFreq[freq[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(freq[number]){\\n            freqOfFreq[freq[number]]--;\\n            freq[number]--;\\n\\n            freqOfFreq[freq[number]]++;\\n        }\\n        else{\\n            freq.erase(number);\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freqOfFreq[frequency] > 0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    map<int,int>freq,freqOfFreq;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(freq[number])\\n            freqOfFreq[freq[number]]--;\\n\\n        freq[number]++;\\n        freqOfFreq[freq[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(freq[number]){\\n            freqOfFreq[freq[number]]--;\\n            freq[number]--;\\n\\n            freqOfFreq[freq[number]]++;\\n        }\\n        else{\\n            freq.erase(number);\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freqOfFreq[frequency] > 0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714645,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class FrequencyTracker {\\n\\n    Dictionary<int, int> dict;\\n    int [] freq;\\n\\n    public FrequencyTracker() {\\n        dict = new Dictionary<int, int>();\\n        freq = new int[100001];\\n    }\\n    \\n    public void Add(int number) {\\n        if(!dict.ContainsKey(number)){\\n            dict.Add(number, 1);\\n            freq[dict[number]]++;\\n        }   \\n        else{\\n            freq[dict[number]]--;  \\n            dict[number]++;\\n            freq[dict[number]]++;\\n        }\\n    }\\n    \\n    public void DeleteOne(int number) {\\n        if(dict.ContainsKey(number) && dict[number] > 0){\\n            freq[dict[number]]--;  \\n            dict[number]--;\\n            freq[dict[number]]++;\\n        }    \\n    }\\n    \\n    public bool HasFrequency(int frequency) {\\n        return freq[frequency] > 0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * bool param_3 = obj.HasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class FrequencyTracker {\\n\\n    Dictionary<int, int> dict;\\n    int [] freq;\\n\\n    public FrequencyTracker() {\\n        dict = new Dictionary<int, int>();\\n        freq = new int[100001];\\n    }\\n    \\n    public void Add(int number) {\\n        if(!dict.ContainsKey(number)){\\n            dict.Add(number, 1);\\n            freq[dict[number]]++;\\n        }   \\n        else{\\n            freq[dict[number]]--;  \\n            dict[number]++;\\n            freq[dict[number]]++;\\n        }\\n    }\\n    \\n    public void DeleteOne(int number) {\\n        if(dict.ContainsKey(number) && dict[number] > 0){\\n            freq[dict[number]]--;  \\n            dict[number]--;\\n            freq[dict[number]]++;\\n        }    \\n    }\\n    \\n    public bool HasFrequency(int frequency) {\\n        return freq[frequency] > 0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * bool param_3 = obj.HasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671687,
                "title": "c-using-arrays",
                "content": "```\\nclass FrequencyTracker {\\npublic:\\n    int c[100001] = {}, f[100001] = {};\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(f[c[number]])--f[c[number]];\\n        ++f[++c[number]];\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(c[number]){\\n            --f[c[number]];\\n             ++f[--c[number]];\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return f[frequency];\\n        \\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    int c[100001] = {}, f[100001] = {};\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(f[c[number]])--f[c[number]];\\n        ++f[++c[number]];\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(c[number]){\\n            --f[c[number]];\\n             ++f[--c[number]];\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return f[frequency];\\n        \\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670660,
                "title": "easy-c-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    map<int,int>m,n;\\n    FrequencyTracker() {\\n      \\n    }\\n    \\n    void add(int number) {\\n        n[m[number]]--;\\n        m[number]++;\\n        n[m[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(m[number]>0){\\n            n[m[number]]--;\\n            m[number]--;\\n            n[m[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int f) {\\n        return n[f]>0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    map<int,int>m,n;\\n    FrequencyTracker() {\\n      \\n    }\\n    \\n    void add(int number) {\\n        n[m[number]]--;\\n        m[number]++;\\n        n[m[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(m[number]>0){\\n            n[m[number]]--;\\n            m[number]--;\\n            n[m[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int f) {\\n        return n[f]>0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629889,
                "title": "java-52ms-beats-98-and-hashmap",
                "content": "# Approach\\n1. Use 2 maps to store the count of each num. The second map will keep track of how many count groups you have.\\n2. When adding a number, increase the count from countMap.\\n    - Also, the group count has to increase. \\n    - EG: supposing you have 3 of 7s. countMap: 7 -> 3. Frequency Map : 3 -> 1.\\n    - Adding another 7: 4 of 7s: countMap 7 -> 4. Frequncy Map: 4 -> 1. \\n    - Also you need to decrement the old frequency of 7. as you no longer 3 7s but 4 7s\\n3. Same principle for deleting. Check if num exisists in countMap. If yes, decrease its count, decrease its old count frequencyMap  and increase the frequency map of the new count.\\n    - EG: 4 of 7s: countMap: 7 -> 4. Freq Map: 4 ->1\\n    - Deleting 1 seven: countMap -> 7 -> 3. Freq map: 3 -> 1, 4 -> 0.   \\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    private Map<Integer, Integer> numCount;\\n    private Map<Integer, Integer> frequencies;\\n    public FrequencyTracker() {\\n        numCount = new HashMap<>();\\n        frequencies = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        int newCount = numCount.merge(number, 1, Integer::sum);\\n        frequencies.merge(newCount, 1, Integer::sum);\\n        if (newCount > 1) {\\n            frequencies.merge(newCount - 1, -1, Integer::sum);\\n        }\\n    }\\n    \\n    public void deleteOne(int number) {\\n        Integer currentVal = numCount.get(number);\\n        if (currentVal != null && currentVal > 0) {\\n            int newCount = numCount.merge(number, -1, Integer::sum);\\n            frequencies.merge(newCount, 1, Integer::sum);\\n            frequencies.merge(newCount + 1, -1, Integer::sum);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        Integer existing = frequencies.get(frequency);\\n        return existing != null && existing > 0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    private Map<Integer, Integer> numCount;\\n    private Map<Integer, Integer> frequencies;\\n    public FrequencyTracker() {\\n        numCount = new HashMap<>();\\n        frequencies = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        int newCount = numCount.merge(number, 1, Integer::sum);\\n        frequencies.merge(newCount, 1, Integer::sum);\\n        if (newCount > 1) {\\n            frequencies.merge(newCount - 1, -1, Integer::sum);\\n        }\\n    }\\n    \\n    public void deleteOne(int number) {\\n        Integer currentVal = numCount.get(number);\\n        if (currentVal != null && currentVal > 0) {\\n            int newCount = numCount.merge(number, -1, Integer::sum);\\n            frequencies.merge(newCount, 1, Integer::sum);\\n            frequencies.merge(newCount + 1, -1, Integer::sum);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        Integer existing = frequencies.get(frequency);\\n        return existing != null && existing > 0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626738,
                "title": "simple-and-optimized-using-two-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing two maps\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int>mp;\\n    unordered_map<int,int>freq;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        mp[number]++;\\n        if(mp[number]==1)\\n            freq[mp[number]]++;\\n        else{\\n            if(freq[mp[number]-1])\\n                freq[mp[number]-1]--;\\n            freq[mp[number]]++;\\n        }\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number] && freq[mp[number]]){\\n            freq[mp[number]]--;\\n            mp[number]--;\\n            freq[mp[number]]++;\\n        }\\n            \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        // for(auto it:mp)\\n        // {\\n        //     if(it.second==frequency)\\n        //         return true;\\n        // }\\n        return freq[frequency]==0?false:true;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Design",
                    "Ordered Map"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int>mp;\\n    unordered_map<int,int>freq;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        mp[number]++;\\n        if(mp[number]==1)\\n            freq[mp[number]]++;\\n        else{\\n            if(freq[mp[number]-1])\\n                freq[mp[number]-1]--;\\n            freq[mp[number]]++;\\n        }\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number] && freq[mp[number]]){\\n            freq[mp[number]]--;\\n            mp[number]--;\\n            freq[mp[number]]++;\\n        }\\n            \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        // for(auto it:mp)\\n        // {\\n        //     if(it.second==frequency)\\n        //         return true;\\n        // }\\n        return freq[frequency]==0?false:true;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617185,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n   int[] num = new int[100001];\\n   int[] fre = new int[100001];\\n    public FrequencyTracker() {\\n        \\n    }\\n    \\n    public void add(int number) {\\n        if(num[number] > 0){\\n            fre[num[number]]--;\\n        }\\n        num[number]++;\\n        fre[num[number]]++;    \\n    }\\n    \\n    public void deleteOne(int number) {\\n         if(num[number] > 0){\\n            fre[num[number]]--;\\n            num[number]--;\\n            fre[num[number]]++;\\n        }\\n       \\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return fre[frequency] > 0;\\n        \\n    }\\n}\\n\\n \\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n   int[] num = new int[100001];\\n   int[] fre = new int[100001];\\n    public FrequencyTracker() {\\n        \\n    }\\n    \\n    public void add(int number) {\\n        if(num[number] > 0){\\n            fre[num[number]]--;\\n        }\\n        num[number]++;\\n        fre[num[number]]++;    \\n    }\\n    \\n    public void deleteOne(int number) {\\n         if(num[number] > 0){\\n            fre[num[number]]--;\\n            num[number]--;\\n            fre[num[number]]++;\\n        }\\n       \\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return fre[frequency] > 0;\\n        \\n    }\\n}\\n\\n \\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588335,
                "title": "7-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTake 2 map: \\n1: Counter number frequency - tableNum[num, freq]\\n2: Frequency counter - tableFreq[freq, count]\\n\\nAdd `number`: If `tableNum` contains this `number` then in `tableFreq` reduce the number of its frequency `--tableFreq[tableNum[number]];`. Then anyway increase the number of `number` in `tableNum` and increase number of frequency `++tableFreq[++tableNum[number]];`.\\n\\nDelete `number`: Do the same thing, only in reverse order.\\nIf `tableNum` contains this `number` then in `tableFreq` reduce the number of its frequency then reduce number of `number` in `tableNum`: `--tableFreq[tableNum[number]--];`. Then increase number of frequency `++tableFreq[tableNum[number]];`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(2n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker \\n{\\npublic:\\n    FrequencyTracker() {}\\n    \\n    void add(int number) \\n    {\\n        if (tableNum[number])\\n            --tableFreq[tableNum[number]];\\n        ++tableFreq[++tableNum[number]];\\n    }\\n    \\n    void deleteOne(int number) \\n    {\\n        if (tableNum[number])\\n        {\\n            --tableFreq[tableNum[number]--];\\n            ++tableFreq[tableNum[number]];\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) \\n    {\\n        return tableFreq[frequency];\\n    }\\n\\nprivate:\\n    unordered_map<int, int> tableNum, tableFreq;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker \\n{\\npublic:\\n    FrequencyTracker() {}\\n    \\n    void add(int number) \\n    {\\n        if (tableNum[number])\\n            --tableFreq[tableNum[number]];\\n        ++tableFreq[++tableNum[number]];\\n    }\\n    \\n    void deleteOne(int number) \\n    {\\n        if (tableNum[number])\\n        {\\n            --tableFreq[tableNum[number]--];\\n            ++tableFreq[tableNum[number]];\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) \\n    {\\n        return tableFreq[frequency];\\n    }\\n\\nprivate:\\n    unordered_map<int, int> tableNum, tableFreq;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580194,
                "title": "frequency-tracker-hash-table-two-maps-o-1-time-complexity-o-n-space-complexity",
                "content": "# Intuition\\nWe can use maps to represent the added values and their frequencies. One other map is to be used for keeping the track if any element with specific frequency exist or not.\\n\\n# Approach\\n- Take two maps, mp for <value, frequency>, mp2 for <frequency, frequency of frequency>\\n- Nothing to be done in FrequenyTracker\\n- update mp and mp2 in add such that mp[number] increase by one, and old frequency of number decreases and new one increases\\n- deleteOne will do opposite of add for mp, but same for mp2, mp[number] decreases, and old frequency decreases and new one increases\\n- to check if any element exist with given frequency, just check mp2, if frequency of frequency is greater than 0, return \\'true\\', else \\'false\\'\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    unordered_map<int,int> mp;\\n    unordered_map<int,int> mp2;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        mp[number]++;\\n        mp2[mp[number]]++;\\n        mp2[mp[number]-1]--; \\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]>0){\\n            mp[number]--;\\n            if(mp[number]!=0)\\n                mp2[mp[number]]++;\\n            mp2[mp[number]+1]--; \\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return mp2[frequency];\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    unordered_map<int,int> mp;\\n    unordered_map<int,int> mp2;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        mp[number]++;\\n        mp2[mp[number]]++;\\n        mp2[mp[number]-1]--; \\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]>0){\\n            mp[number]--;\\n            if(mp[number]!=0)\\n                mp2[mp[number]]++;\\n            mp2[mp[number]+1]--; \\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return mp2[frequency];\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574827,
                "title": "easy-c-code-to-understand-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need two map \\nI> to store number and frequency\\nII> to store which number has same frequency\\n\\nfirst errase its occurance from the frequency mapping\\nupdate the mapping mp\\nThen add to the new frequency..\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int, int> mp;\\n    unordered_map<int, int> mp2;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(mp.find(number) != mp.end()){\\n            mp2[mp[number]]--;\\n        }\\n        mp[number]++;\\n        mp2[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number) != mp.end() && mp[number] > 0)\\n        {\\n            mp2[mp[number]]--;\\n            mp[number]--;\\n            mp2[mp[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return (mp2[frequency] > 0);\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int, int> mp;\\n    unordered_map<int, int> mp2;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(mp.find(number) != mp.end()){\\n            mp2[mp[number]]--;\\n        }\\n        mp[number]++;\\n        mp2[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number) != mp.end() && mp[number] > 0)\\n        {\\n            mp2[mp[number]]--;\\n            mp[number]--;\\n            mp2[mp[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return (mp2[frequency] > 0);\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555050,
                "title": "solution-using-two-unordered-maps",
                "content": "\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> ump1;\\n    unordered_map<int,int> ump2;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int x) {\\n        if(ump1.find(x)!=ump1.end()){\\n            int oldfreq = ump1[x];\\n            ump1[x]++;\\n            ump2[oldfreq]--;\\n            ump2[ump1[x]]++;\\n        }\\n        else{\\n            ump1[x]++;\\n            ump2[1]++;\\n        }\\n    }\\n    \\n    void deleteOne(int x) {\\n        if(ump1.find(x)!=ump1.end()){\\n            int oldfreq = ump1[x];\\n            ump1[x]--;\\n            if(ump1[x]==0) {\\n                ump1.erase(x);\\n                ump2[oldfreq]--;\\n                return;\\n            }\\n            ump2[oldfreq]--;\\n            ump2[ump1[x]]++;\\n        }\\n        else{\\n            return;\\n        }\\n    }\\n    \\n    bool hasFrequency(int freq) {\\n        // cout<<\"ump1\"<<endl;\\n        // for(auto x:ump1){\\n        //     cout<<x.first<<\"-->\"<<x.second<<endl;\\n        // }\\n        // cout<<\"ump2\"<<endl;\\n        // for(auto x:ump2){\\n        //     cout<<x.first<<\"-->\"<<x.second<<endl;\\n        // }\\n        if(ump2[freq]>0){\\n            return true;\\n        }\\n        else\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> ump1;\\n    unordered_map<int,int> ump2;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int x) {\\n        if(ump1.find(x)!=ump1.end()){\\n            int oldfreq = ump1[x];\\n            ump1[x]++;\\n            ump2[oldfreq]--;\\n            ump2[ump1[x]]++;\\n        }\\n        else{\\n            ump1[x]++;\\n            ump2[1]++;\\n        }\\n    }\\n    \\n    void deleteOne(int x) {\\n        if(ump1.find(x)!=ump1.end()){\\n            int oldfreq = ump1[x];\\n            ump1[x]--;\\n            if(ump1[x]==0) {\\n                ump1.erase(x);\\n                ump2[oldfreq]--;\\n                return;\\n            }\\n            ump2[oldfreq]--;\\n            ump2[ump1[x]]++;\\n        }\\n        else{\\n            return;\\n        }\\n    }\\n    \\n    bool hasFrequency(int freq) {\\n        // cout<<\"ump1\"<<endl;\\n        // for(auto x:ump1){\\n        //     cout<<x.first<<\"-->\"<<x.second<<endl;\\n        // }\\n        // cout<<\"ump2\"<<endl;\\n        // for(auto x:ump2){\\n        //     cout<<x.first<<\"-->\"<<x.second<<endl;\\n        // }\\n        if(ump2[freq]>0){\\n            return true;\\n        }\\n        else\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3554997,
                "title": "c-easiest-solution-using-2-hashmaps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp;\\n    unordered_map<int,int>freq;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(freq[mp[number]]!=0)freq[mp[number]]--;\\n        mp[number]++;\\n        freq[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(freq[mp[number]]!=0)freq[mp[number]]--;\\n        if(mp[number]!=0)mp[number]--;\\n        freq[mp[number]]++;\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency]!=0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp;\\n    unordered_map<int,int>freq;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(freq[mp[number]]!=0)freq[mp[number]]--;\\n        mp[number]++;\\n        freq[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(freq[mp[number]]!=0)freq[mp[number]]--;\\n        if(mp[number]!=0)mp[number]--;\\n        freq[mp[number]]++;\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency]!=0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548740,
                "title": "easy-python3-two-dicts",
                "content": "# Code\\n```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.freqToNum = collections.defaultdict(int)\\n        self.numtofreq = collections.defaultdict(int)\\n\\n    def add(self, num: int) -> None:\\n        if self.numtofreq[num] > 0:\\n            self.freqToNum[self.numtofreq[num]]-=1\\n        self.numtofreq[num]+=1\\n        self.freqToNum[self.numtofreq[num]]+=1\\n\\n\\n    def deleteOne(self, num: int) -> None:\\n        if self.numtofreq[num] > 0:\\n            self.freqToNum[self.numtofreq[num]]-=1\\n            self.numtofreq[num]-=1\\n            if self.numtofreq[num] > 0:\\n                self.freqToNum[self.numtofreq[num]]+=1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freqToNum[frequency] > 0\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.freqToNum = collections.defaultdict(int)\\n        self.numtofreq = collections.defaultdict(int)\\n\\n    def add(self, num: int) -> None:\\n        if self.numtofreq[num] > 0:\\n            self.freqToNum[self.numtofreq[num]]-=1\\n        self.numtofreq[num]+=1\\n        self.freqToNum[self.numtofreq[num]]+=1\\n\\n\\n    def deleteOne(self, num: int) -> None:\\n        if self.numtofreq[num] > 0:\\n            self.freqToNum[self.numtofreq[num]]-=1\\n            self.numtofreq[num]-=1\\n            if self.numtofreq[num] > 0:\\n                self.freqToNum[self.numtofreq[num]]+=1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freqToNum[frequency] > 0\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546065,
                "title": "simple-java-solution",
                "content": "\\n# Code\\n```\\nclass FrequencyTracker {\\n    \\n    HashMap<Integer, Integer> map;\\n    int[] freq;\\n    public FrequencyTracker() {\\n        map = new HashMap<>();\\n        freq = new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        if(map.containsKey(number)){\\n            freq[map.get(number)]--;\\n            map.put(number, map.get(number) + 1);\\n            freq[map.get(number)]++;\\n        }else{\\n            map.put(number, 1);\\n            freq[1]++;\\n        }\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(map.containsKey(number)){\\n            if(map.get(number) == 1){\\n                map.remove(number);\\n                freq[1]--;\\n            }\\n            else{\\n                freq[map.get(number)]--;\\n                map.put(number, map.get(number)-1);\\n                freq[map.get(number)]++;\\n            }\\n                \\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(freq[frequency]>0)\\n            return true;\\n        else\\n            return false;\\n            \\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    \\n    HashMap<Integer, Integer> map;\\n    int[] freq;\\n    public FrequencyTracker() {\\n        map = new HashMap<>();\\n        freq = new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        if(map.containsKey(number)){\\n            freq[map.get(number)]--;\\n            map.put(number, map.get(number) + 1);\\n            freq[map.get(number)]++;\\n        }else{\\n            map.put(number, 1);\\n            freq[1]++;\\n        }\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(map.containsKey(number)){\\n            if(map.get(number) == 1){\\n                map.remove(number);\\n                freq[1]--;\\n            }\\n            else{\\n                freq[map.get(number)]--;\\n                map.put(number, map.get(number)-1);\\n                freq[map.get(number)]++;\\n            }\\n                \\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(freq[frequency]>0)\\n            return true;\\n        else\\n            return false;\\n            \\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545370,
                "title": "a-few-solutions",
                "content": "Use two maps `bucket` and `counter`:\\n\\n1. \\uD83E\\uDEA3 `bucket` associates frequency with a set of values `x` per frequency\\n2. \\uD83D\\uDD22 `counter` associates each value `x` with frequency of each value `x`\\n\\n---\\n\\n*Kotlin*\\n```\\nclass FrequencyTracker() {\\n    private var bucket = mutableMapOf<Int, MutableSet<Int>>()\\n    private var count = mutableMapOf<Int, Int>()\\n    private fun _update(x: Int, diff: Int) {\\n        if (count.contains(x) && bucket.contains(count[x]!!) && bucket[count[x]!!]!!.contains(x))\\n            bucket[count[x]!!]!!.remove(x)\\n        count[x] = Math.max(0, (count[x] ?: 0) + diff)\\n        if (0 < count[x]!! && !bucket.contains(count[x]!!))\\n            bucket[count[x]!!] = mutableSetOf<Int>()\\n        if (bucket.contains(count[x]!!))\\n            bucket[count[x]!!]!!.add(x)\\n    }\\n    fun add(x: Int) { _update(x, 1) }\\n    fun deleteOne(x: Int) { _update(x, -1) }\\n    var hasFrequency = { cnt: Int -> bucket.contains(cnt) && 0 < bucket[cnt]!!.size }\\n}\\n```\\n\\n*Javascript*\\n```\\nclass FrequencyTracker {\\n    constructor() {\\n        this.bucket = new Map();\\n        this.count = new Map();\\n    }\\n    _update(x, diff) {\\n        if (this.bucket.has(this.count.get(x)))\\n            this.bucket.get(this.count.get(x)).delete(x);\\n        this.count.set(x, Math.max(0, (this.count.get(x) || 0) + diff));\\n        if (!this.bucket.has(this.count.get(x)))\\n            this.bucket.set(this.count.get(x), new Set());\\n        this.bucket.get(this.count.get(x)).add(x);\\n    }\\n    add(x) { this._update(x, 1); }\\n    deleteOne(x) { this._update(x, -1); }\\n    hasFrequency = cnt => this.bucket.has(cnt) && this.bucket.get(cnt).size\\n}\\n```\\n\\n*Python3*\\n```\\nclass FrequencyTracker:\\n    def __init__(self):\\n        self.bucket = defaultdict(set)\\n        self.count = Counter()\\n\\n    def _update(self, x, diff):\\n        if self.count[x] in self.bucket and x in self.bucket[self.count[x]]:\\n            self.bucket[self.count[x]].remove(x)\\n        self.count[x] = max(0, self.count[x] + diff)\\n        self.bucket[self.count[x]].add(x)\\n        \\n    def add(self, x: int) -> None:\\n        self._update(x, 1)\\n\\n    def deleteOne(self, x: int) -> None:\\n        self._update(x, -1)\\n\\n    hasFrequency = lambda self, cnt: len(self.bucket[cnt])\\n```\\n\\n*Rust*\\n```\\n// TODO: implement me!\\n```\\n\\n*C++*\\n```\\nclass FrequencyTracker {\\n    using Set = unordered_set<int>;\\n    using Bucket = unordered_map<int, Set>;\\n    using Counter = unordered_map<int, int>;\\n    Bucket bucket;\\n    Counter counter;\\n    void _update(int x, int diff) {\\n        if (bucket.find(counter[x]) != bucket.end())\\n            bucket[counter[x]].erase(x);\\n        counter[x] = max(0, counter[x] + diff);\\n        bucket[counter[x]].insert(x);\\n    }\\npublic:\\n    void add(int x) { _update(x, 1); }\\n    void deleteOne(int x) { _update(x, -1); }\\n    bool hasFrequency(int cnt) { return bucket[cnt].size(); }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass FrequencyTracker() {\\n    private var bucket = mutableMapOf<Int, MutableSet<Int>>()\\n    private var count = mutableMapOf<Int, Int>()\\n    private fun _update(x: Int, diff: Int) {\\n        if (count.contains(x) && bucket.contains(count[x]!!) && bucket[count[x]!!]!!.contains(x))\\n            bucket[count[x]!!]!!.remove(x)\\n        count[x] = Math.max(0, (count[x] ?: 0) + diff)\\n        if (0 < count[x]!! && !bucket.contains(count[x]!!))\\n            bucket[count[x]!!] = mutableSetOf<Int>()\\n        if (bucket.contains(count[x]!!))\\n            bucket[count[x]!!]!!.add(x)\\n    }\\n    fun add(x: Int) { _update(x, 1) }\\n    fun deleteOne(x: Int) { _update(x, -1) }\\n    var hasFrequency = { cnt: Int -> bucket.contains(cnt) && 0 < bucket[cnt]!!.size }\\n}\\n```\n```\\nclass FrequencyTracker {\\n    constructor() {\\n        this.bucket = new Map();\\n        this.count = new Map();\\n    }\\n    _update(x, diff) {\\n        if (this.bucket.has(this.count.get(x)))\\n            this.bucket.get(this.count.get(x)).delete(x);\\n        this.count.set(x, Math.max(0, (this.count.get(x) || 0) + diff));\\n        if (!this.bucket.has(this.count.get(x)))\\n            this.bucket.set(this.count.get(x), new Set());\\n        this.bucket.get(this.count.get(x)).add(x);\\n    }\\n    add(x) { this._update(x, 1); }\\n    deleteOne(x) { this._update(x, -1); }\\n    hasFrequency = cnt => this.bucket.has(cnt) && this.bucket.get(cnt).size\\n}\\n```\n```\\nclass FrequencyTracker:\\n    def __init__(self):\\n        self.bucket = defaultdict(set)\\n        self.count = Counter()\\n\\n    def _update(self, x, diff):\\n        if self.count[x] in self.bucket and x in self.bucket[self.count[x]]:\\n            self.bucket[self.count[x]].remove(x)\\n        self.count[x] = max(0, self.count[x] + diff)\\n        self.bucket[self.count[x]].add(x)\\n        \\n    def add(self, x: int) -> None:\\n        self._update(x, 1)\\n\\n    def deleteOne(self, x: int) -> None:\\n        self._update(x, -1)\\n\\n    hasFrequency = lambda self, cnt: len(self.bucket[cnt])\\n```\n```\\n// TODO: implement me!\\n```\n```\\nclass FrequencyTracker {\\n    using Set = unordered_set<int>;\\n    using Bucket = unordered_map<int, Set>;\\n    using Counter = unordered_map<int, int>;\\n    Bucket bucket;\\n    Counter counter;\\n    void _update(int x, int diff) {\\n        if (bucket.find(counter[x]) != bucket.end())\\n            bucket[counter[x]].erase(x);\\n        counter[x] = max(0, counter[x] + diff);\\n        bucket[counter[x]].insert(x);\\n    }\\npublic:\\n    void add(int x) { _update(x, 1); }\\n    void deleteOne(int x) { _update(x, -1); }\\n    bool hasFrequency(int cnt) { return bucket[cnt].size(); }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545153,
                "title": "2-hashmaps-of-numbers-and-frequencies",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse hashmaps of numbers and frequencies and update them accordingly to keep track of the state. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAll operations are $$O(1)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$, where $$n$$ is the number of items inserted.\\n\\n# Code\\n\\nI added an additional update function to not repeat myself, direction is to indicate if which directions the number move. I am also still learning a lot of rust so feel free to give me feedback.\\n\\n```\\nuse std::collections::HashMap;\\n\\nstruct FrequencyTracker {\\n    numbers: HashMap<i32, i32>,\\n    frequency: HashMap<i32, i32>,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl FrequencyTracker {\\n\\n    fn new() -> Self {\\n        Self {\\n            numbers: HashMap::new(),\\n            frequency: HashMap::new(),\\n        }\\n    }\\n\\n    fn update(&mut self, number: i32, dir: i32) {\\n        let old_freq = *self.numbers.entry(number).or_default();\\n        self.frequency.entry(old_freq).and_modify(|c| *c -= 1);\\n        self.numbers.entry(number).and_modify(|c| *c += dir).or_insert(1);\\n        self.frequency.entry(old_freq + dir).and_modify(|c| *c += 1).or_insert(1);\\n    }\\n    \\n    fn add(&mut self, number: i32) {\\n        self.update(number, 1);\\n    }\\n    \\n    fn delete_one(&mut self, number: i32) {\\n        if self.numbers.contains_key(&number) && self.numbers[&number] > 0 {\\n            self.update(number, -1);\\n        }\\n    }\\n    \\n    fn has_frequency(&self, frequency: i32) -> bool {        \\n        self.frequency.contains_key(&frequency) && self.frequency[&frequency] > 0\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * let obj = FrequencyTracker::new();\\n * obj.add(number);\\n * obj.delete_one(number);\\n * let ret_3: bool = obj.has_frequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nstruct FrequencyTracker {\\n    numbers: HashMap<i32, i32>,\\n    frequency: HashMap<i32, i32>,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl FrequencyTracker {\\n\\n    fn new() -> Self {\\n        Self {\\n            numbers: HashMap::new(),\\n            frequency: HashMap::new(),\\n        }\\n    }\\n\\n    fn update(&mut self, number: i32, dir: i32) {\\n        let old_freq = *self.numbers.entry(number).or_default();\\n        self.frequency.entry(old_freq).and_modify(|c| *c -= 1);\\n        self.numbers.entry(number).and_modify(|c| *c += dir).or_insert(1);\\n        self.frequency.entry(old_freq + dir).and_modify(|c| *c += 1).or_insert(1);\\n    }\\n    \\n    fn add(&mut self, number: i32) {\\n        self.update(number, 1);\\n    }\\n    \\n    fn delete_one(&mut self, number: i32) {\\n        if self.numbers.contains_key(&number) && self.numbers[&number] > 0 {\\n            self.update(number, -1);\\n        }\\n    }\\n    \\n    fn has_frequency(&self, frequency: i32) -> bool {        \\n        self.frequency.contains_key(&frequency) && self.frequency[&frequency] > 0\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * let obj = FrequencyTracker::new();\\n * obj.add(number);\\n * obj.delete_one(number);\\n * let ret_3: bool = obj.has_frequency(frequency);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3544275,
                "title": "o-1-java",
                "content": "\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n\\n    Map<Integer,Integer> numbersFreq, freqsFreq;\\n    public FrequencyTracker() {\\n        numbersFreq = new HashMap();\\n        freqsFreq = new HashMap();\\n    }\\n    \\n    public void add(int number) {\\n        if (numbersFreq.containsKey(number) && numbersFreq.get(number) > 0){\\n            int prevFreq = numbersFreq.get(number);\\n            freqsFreq.put(prevFreq,freqsFreq.get(prevFreq)-1);\\n            freqsFreq.put(prevFreq+1,freqsFreq.getOrDefault(prevFreq+1,0)+1);\\n            numbersFreq.put(number,numbersFreq.get(number)+1);\\n        }\\n        else{\\n            freqsFreq.put(1, freqsFreq.getOrDefault(1,0)+1);\\n            numbersFreq.put(number,1);\\n        }\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if (numbersFreq.containsKey(number) && numbersFreq.get(number) > 0){\\n            int prevFreq = numbersFreq.get(number);\\n            freqsFreq.put(prevFreq , freqsFreq.get(prevFreq) - 1);\\n            freqsFreq.put(prevFreq-1,freqsFreq.getOrDefault(prevFreq-1,0)+1);\\n            numbersFreq.put(number, numbersFreq.get(number) - 1);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return (freqsFreq.containsKey(frequency) && freqsFreq.get(frequency)>0);\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n\\n    Map<Integer,Integer> numbersFreq, freqsFreq;\\n    public FrequencyTracker() {\\n        numbersFreq = new HashMap();\\n        freqsFreq = new HashMap();\\n    }\\n    \\n    public void add(int number) {\\n        if (numbersFreq.containsKey(number) && numbersFreq.get(number) > 0){\\n            int prevFreq = numbersFreq.get(number);\\n            freqsFreq.put(prevFreq,freqsFreq.get(prevFreq)-1);\\n            freqsFreq.put(prevFreq+1,freqsFreq.getOrDefault(prevFreq+1,0)+1);\\n            numbersFreq.put(number,numbersFreq.get(number)+1);\\n        }\\n        else{\\n            freqsFreq.put(1, freqsFreq.getOrDefault(1,0)+1);\\n            numbersFreq.put(number,1);\\n        }\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if (numbersFreq.containsKey(number) && numbersFreq.get(number) > 0){\\n            int prevFreq = numbersFreq.get(number);\\n            freqsFreq.put(prevFreq , freqsFreq.get(prevFreq) - 1);\\n            freqsFreq.put(prevFreq-1,freqsFreq.getOrDefault(prevFreq-1,0)+1);\\n            numbersFreq.put(number, numbersFreq.get(number) - 1);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return (freqsFreq.containsKey(frequency) && freqsFreq.get(frequency)>0);\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539219,
                "title": "easiest-c-solution-ever-seen",
                "content": "# Intuition\\nJUST SEE THE CODE YOU WILL COME TO KNOW. WE USE TWO MAPS ONE TO STORE NUMBER AND ONE TO STORE FREQUENCY OF THE NUMBERS\\n# Approach\\nUSE DOUBLE UNORDERED MAP\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(N)\\n![random image.jpeg](https://assets.leetcode.com/users/images/d80e2da0-26d0-4d80-aea5-0ffe90197bb1_1684430088.198616.jpeg)\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    \\n    unordered_map<int,int>mp;       //stores number\\n    unordered_map<int,int>mpp;      //stores frequency of the numbers\\n\\n    FrequencyTracker() {\\n     \\n    }\\n    \\n    void add(int number) {\\n       \\n        mpp[mp[number]]--;\\n        mp[number]++;\\n        mpp[mp[number]]++;\\n        \\n    }\\n    \\n    void deleteOne(int number) {\\n\\n        if(mp[number]>0)\\n        {\\n            mpp[mp[number]]--;\\n            mp[number]--;\\n            mpp[mp[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n         return mpp[frequency]>0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    \\n    unordered_map<int,int>mp;       //stores number\\n    unordered_map<int,int>mpp;      //stores frequency of the numbers\\n\\n    FrequencyTracker() {\\n     \\n    }\\n    \\n    void add(int number) {\\n       \\n        mpp[mp[number]]--;\\n        mp[number]++;\\n        mpp[mp[number]]++;\\n        \\n    }\\n    \\n    void deleteOne(int number) {\\n\\n        if(mp[number]>0)\\n        {\\n            mpp[mp[number]]--;\\n            mp[number]--;\\n            mpp[mp[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n         return mpp[frequency]>0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539176,
                "title": "java-using-hashmap-as-a-frequency-map",
                "content": "# Code\\n```\\nclass FrequencyTracker {\\n\\n    Map<Integer, Set<Integer>> map;\\n\\n    public FrequencyTracker() {\\n        map = new HashMap<>();\\n        map.put(0, new HashSet<>());\\n        map.put(1, new HashSet<>());\\n    }\\n\\n    public void add(int number) {\\n        int f = -1;\\n        for (int freq : map.keySet()) {\\n            if (map.get(freq).contains(number)) {\\n                f = freq;\\n                break;\\n            }\\n        }\\n        if (f > -1) {\\n            map.get(f).remove(number);\\n            map.computeIfAbsent(f + 1, HashSet::new).add(number);\\n        } else {\\n            map.get(1).add(number);\\n        }\\n    }\\n\\n    public void deleteOne(int number) {\\n        int f = -1;\\n        for (int freq : map.keySet()) {\\n            if (map.get(freq).contains(number)) {\\n                f = freq;\\n                break;\\n            }\\n        }\\n        if (f > 0) {\\n            map.get(f).remove(number);\\n            map.get(f - 1).add(number);\\n        }\\n    }\\n\\n    public boolean hasFrequency(int frequency) {\\n        return map.containsKey(frequency) && map.get(frequency).size() > 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n\\n    Map<Integer, Set<Integer>> map;\\n\\n    public FrequencyTracker() {\\n        map = new HashMap<>();\\n        map.put(0, new HashSet<>());\\n        map.put(1, new HashSet<>());\\n    }\\n\\n    public void add(int number) {\\n        int f = -1;\\n        for (int freq : map.keySet()) {\\n            if (map.get(freq).contains(number)) {\\n                f = freq;\\n                break;\\n            }\\n        }\\n        if (f > -1) {\\n            map.get(f).remove(number);\\n            map.computeIfAbsent(f + 1, HashSet::new).add(number);\\n        } else {\\n            map.get(1).add(number);\\n        }\\n    }\\n\\n    public void deleteOne(int number) {\\n        int f = -1;\\n        for (int freq : map.keySet()) {\\n            if (map.get(freq).contains(number)) {\\n                f = freq;\\n                break;\\n            }\\n        }\\n        if (f > 0) {\\n            map.get(f).remove(number);\\n            map.get(f - 1).add(number);\\n        }\\n    }\\n\\n    public boolean hasFrequency(int frequency) {\\n        return map.containsKey(frequency) && map.get(frequency).size() > 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533013,
                "title": "two-hashmap-solution-just-for-reference",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTwo HashMaps - One to keep number and its frequency and other as reverse mapping that contains frequency as a key and set of numbers as values.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDisclaimer - Not a recommended way, I posted here just for reference.\\n\\nIf the solution with two arrays does not click within time then you can try it this way, But It is a hard way to do it, and I find it time-consuming and difficult to tackle all scenarios.\\n\\n# Complexity\\n- Time complexity: O(1) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n\\n    private Map<Integer,Integer> fMap;\\n    private Map<Integer,Set<Integer>> fSet;\\n\\n    public FrequencyTracker() {\\n        this.fMap = new HashMap<>();\\n        this.fSet = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        if(this.fMap.containsKey(number)) {\\n            int oldFreq = this.fMap.get(number);\\n            int newFreq = oldFreq + 1;\\n            this.fMap.put(number, newFreq);\\n            updateFSet(newFreq, oldFreq, number);\\n        }else {\\n            this.fMap.put(number, 1);\\n            //updateFSet(1, 0, number);\\n            if(this.fSet.containsKey(1)) {\\n                this.fSet.get(1).add(number);\\n            }else {\\n                Set<Integer> set = new HashSet<>();\\n                set.add(number);\\n                this.fSet.put(1, set);\\n            }\\n          \\n        }\\n        //this.map.put(number, this.map.getOrDefault(number, 0)+1);\\n    }\\n\\n    private void updateFSet(int newFreq, int oldFreq, int number) {\\n        Set<Integer> set = fSet.get(oldFreq);\\n        set.remove(number);\\n        //remove set if no element left\\n        if(set.isEmpty()) {\\n            this.fSet.remove(oldFreq);\\n        }\\n        //add number \\n        if(fSet.containsKey(newFreq)) {\\n            fSet.get(newFreq).add(number);\\n        }else{\\n            Set<Integer> nset = new HashSet<>();\\n            nset.add(number);\\n            fSet.put(newFreq, nset);\\n        }\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(this.fMap.containsKey(number)) {\\n            int oldFreq = this.fMap.get(number);\\n            int newFreq = oldFreq - 1;\\n            this.fMap.put(number, newFreq);\\n            if(newFreq == 0) {\\n                this.fMap.remove(number);\\n            }\\n            updateFSet(newFreq, oldFreq, number);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(this.fSet.containsKey(frequency)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\n\\n    private Map<Integer,Integer> fMap;\\n    private Map<Integer,Set<Integer>> fSet;\\n\\n    public FrequencyTracker() {\\n        this.fMap = new HashMap<>();\\n        this.fSet = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        if(this.fMap.containsKey(number)) {\\n            int oldFreq = this.fMap.get(number);\\n            int newFreq = oldFreq + 1;\\n            this.fMap.put(number, newFreq);\\n            updateFSet(newFreq, oldFreq, number);\\n        }else {\\n            this.fMap.put(number, 1);\\n            //updateFSet(1, 0, number);\\n            if(this.fSet.containsKey(1)) {\\n                this.fSet.get(1).add(number);\\n            }else {\\n                Set<Integer> set = new HashSet<>();\\n                set.add(number);\\n                this.fSet.put(1, set);\\n            }\\n          \\n        }\\n        //this.map.put(number, this.map.getOrDefault(number, 0)+1);\\n    }\\n\\n    private void updateFSet(int newFreq, int oldFreq, int number) {\\n        Set<Integer> set = fSet.get(oldFreq);\\n        set.remove(number);\\n        //remove set if no element left\\n        if(set.isEmpty()) {\\n            this.fSet.remove(oldFreq);\\n        }\\n        //add number \\n        if(fSet.containsKey(newFreq)) {\\n            fSet.get(newFreq).add(number);\\n        }else{\\n            Set<Integer> nset = new HashSet<>();\\n            nset.add(number);\\n            fSet.put(newFreq, nset);\\n        }\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(this.fMap.containsKey(number)) {\\n            int oldFreq = this.fMap.get(number);\\n            int newFreq = oldFreq - 1;\\n            this.fMap.put(number, newFreq);\\n            if(newFreq == 0) {\\n                this.fMap.remove(number);\\n            }\\n            updateFSet(newFreq, oldFreq, number);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(this.fSet.containsKey(frequency)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527010,
                "title": "easy-c-solution-map-solution",
                "content": "# Intuition\\nThe intuition is to store the number and their frequencies to be accessible in both ways.\\n\\n# Approach\\nTake an unordered_map to store number with their frequencies and a map to store frequencies in a map with the numbers that have that frequency.\\n\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    unordered_map<int, int> mp;\\n    map<int, unordered_set<int>> freq;\\npublic:\\n    FrequencyTracker() {\\n\\n    }\\n    \\n    void add(int number) {\\n        if(mp.find(number)!= mp.end()){\\n            int cur= mp[number];\\n            if(cur>0) freq[cur].erase(number);\\n        }\\n        mp[number]++;\\n        freq[mp[number]].insert(number); \\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number)!= mp.end()){\\n            int cur= mp[number];\\n            mp[number]--;\\n            if(cur>0) freq[cur].erase(number);\\n            if(mp[number]>0) freq[mp[number]].insert(number); \\n            else mp.erase(number);\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(freq[frequency].size()>0) return true;\\n        else return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    unordered_map<int, int> mp;\\n    map<int, unordered_set<int>> freq;\\npublic:\\n    FrequencyTracker() {\\n\\n    }\\n    \\n    void add(int number) {\\n        if(mp.find(number)!= mp.end()){\\n            int cur= mp[number];\\n            if(cur>0) freq[cur].erase(number);\\n        }\\n        mp[number]++;\\n        freq[mp[number]].insert(number); \\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number)!= mp.end()){\\n            int cur= mp[number];\\n            mp[number]--;\\n            if(cur>0) freq[cur].erase(number);\\n            if(mp[number]>0) freq[mp[number]].insert(number); \\n            else mp.erase(number);\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(freq[frequency].size()>0) return true;\\n        else return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524024,
                "title": "java-hashmap-easy-to-understand",
                "content": "```\\nclass FrequencyTracker {\\n    private HashMap<Integer, Integer> map;\\n    private HashMap<Integer, Integer> valmap;\\n    public FrequencyTracker() {\\n        map = new HashMap<>();\\n        valmap = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        if(map.containsKey(number)) {\\n            int freq = map.get(number); \\n            map.put(number, freq + 1); \\n            valmap.put(freq+1, valmap.getOrDefault(freq+1, 0) + 1);\\n            valmap.put(freq, valmap.getOrDefault(freq, 0) - 1);\\n            if(valmap.get(freq) == 0){\\n                valmap.remove(freq);\\n            }\\n        }\\n        else {\\n           map.put(number, map.getOrDefault(number, 0) + 1);\\n           valmap.put(map.get(number), valmap.getOrDefault(map.get(number), 0) + 1); \\n        }\\n        \\n    }\\n    \\n    public void deleteOne(int number) {\\n       \\n        if(map.containsKey(number)) {\\n            int freq = map.get(number);\\n            map.put(number, freq - 1);   // freq ko 1 ghatao and freq-1 ko 1 badhao in valmap\\n            if(map.get(number) == 0){\\n                map.remove(number);\\n            }\\n            valmap.put(freq , valmap.get(freq) - 1);\\n            if(valmap.get(freq) == 0){\\n                valmap.remove(freq);\\n            }\\n            valmap.put(freq-1 , valmap.getOrDefault(freq-1, 0) + 1);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(valmap.containsKey(frequency)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    private HashMap<Integer, Integer> map;\\n    private HashMap<Integer, Integer> valmap;\\n    public FrequencyTracker() {\\n        map = new HashMap<>();\\n        valmap = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        if(map.containsKey(number)) {\\n            int freq = map.get(number); \\n            map.put(number, freq + 1); \\n            valmap.put(freq+1, valmap.getOrDefault(freq+1, 0) + 1);\\n            valmap.put(freq, valmap.getOrDefault(freq, 0) - 1);\\n            if(valmap.get(freq) == 0){\\n                valmap.remove(freq);\\n            }\\n        }\\n        else {\\n           map.put(number, map.getOrDefault(number, 0) + 1);\\n           valmap.put(map.get(number), valmap.getOrDefault(map.get(number), 0) + 1); \\n        }\\n        \\n    }\\n    \\n    public void deleteOne(int number) {\\n       \\n        if(map.containsKey(number)) {\\n            int freq = map.get(number);\\n            map.put(number, freq - 1);   // freq ko 1 ghatao and freq-1 ko 1 badhao in valmap\\n            if(map.get(number) == 0){\\n                map.remove(number);\\n            }\\n            valmap.put(freq , valmap.get(freq) - 1);\\n            if(valmap.get(freq) == 0){\\n                valmap.remove(freq);\\n            }\\n            valmap.put(freq-1 , valmap.getOrDefault(freq-1, 0) + 1);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(valmap.containsKey(frequency)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3523539,
                "title": "c-two-array-much-simpler-than-two-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs the constrains not so big(up to `10^5`) we can use two array. And it will be little faster, simpler than using two `HashTables`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- `int[] freq;` Frequency of numbers of size `100001`\\n- ` int[] freqFreq;` Frequencies of frequency) of size `100001`\\n \\n# Complexity\\n- Time complexity:$$O(1)$$ for each operation.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity::$$O(n)$$, where n = distinct numbers\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class FrequencyTracker {\\n    int[] freq;\\n    int[] freqFreq;\\n\\n    public FrequencyTracker() {\\n        freq = new int[100001];\\n        freqFreq = new int[100001];\\n    }\\n\\n    public void Add(int number) {\\n        int oldCnt = freq[number];\\n        freq[number]++;\\n\\n        freqFreq[oldCnt]--;\\n        freqFreq[freq[number]]++;\\n    }\\n\\n    public void DeleteOne(int number) {\\n        if (freq[number] > 0) {\\n            int oldCnt = freq[number];\\n            freq[number]--;\\n\\n            freqFreq[oldCnt]--;\\n            freqFreq[freq[number]]++;\\n        }\\n    }\\n\\n    public bool HasFrequency(int frequency) {\\n        return freqFreq[frequency] > 0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * bool param_3 = obj.HasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C#",
                    "Array"
                ],
                "code": "```\\npublic class FrequencyTracker {\\n    int[] freq;\\n    int[] freqFreq;\\n\\n    public FrequencyTracker() {\\n        freq = new int[100001];\\n        freqFreq = new int[100001];\\n    }\\n\\n    public void Add(int number) {\\n        int oldCnt = freq[number];\\n        freq[number]++;\\n\\n        freqFreq[oldCnt]--;\\n        freqFreq[freq[number]]++;\\n    }\\n\\n    public void DeleteOne(int number) {\\n        if (freq[number] > 0) {\\n            int oldCnt = freq[number];\\n            freq[number]--;\\n\\n            freqFreq[oldCnt]--;\\n            freqFreq[freq[number]]++;\\n        }\\n    }\\n\\n    public bool HasFrequency(int frequency) {\\n        return freqFreq[frequency] > 0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * bool param_3 = obj.HasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523458,
                "title": "c-two-dictionaries",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- `Dictionary<int, int> freq;` Frequency of numbers\\n- ` Dictionary<int, int> freqFreq;` Frequencies of frequency)\\n- `private void UpdateCntFromTo(int oldCnt, int newCnt)` Update the `freqFreq`, by decreasing old and increasing new count\\n\\n# Complexity\\n- Time complexity: Each operation takes $$O(1)$$. Only access items by `Dictionary(Hashmap)` key.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$, where n = distinct numbers\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class FrequencyTracker {\\n    Dictionary<int, int> freq;\\n    Dictionary<int, int> freqFreq;\\n\\n    public FrequencyTracker() {\\n        freq = new Dictionary<int, int>();\\n        freqFreq = new Dictionary<int, int>();\\n    }\\n\\n    public void Add(int number) {\\n        int oldCnt = freq.GetValueOrDefault(number, 0);\\n        freq[number] = freq.GetValueOrDefault(number, 0) + 1;\\n        UpdateCntFromTo(oldCnt, freq[number]);\\n    }\\n\\n    public void DeleteOne(int number) {\\n        if (freq.ContainsKey(number)) {\\n            int oldCnt = freq[number];\\n            freq[number]--;\\n            if (freq[number] == 0) freq.Remove(number);\\n\\n            UpdateCntFromTo(oldCnt, freq.GetValueOrDefault(number, 0));\\n        }\\n    }\\n\\n    public bool HasFrequency(int frequency) {\\n        return freqFreq.ContainsKey(frequency);\\n    }\\n\\n    private void UpdateCntFromTo(int oldCnt, int newCnt) {\\n        if (oldCnt > 0) {\\n            freqFreq[oldCnt]--;\\n            if (freqFreq[oldCnt] == 0) freqFreq.Remove(oldCnt);\\n        }\\n\\n        if (newCnt > 0) freqFreq[newCnt] = freqFreq.GetValueOrDefault(newCnt, 0) + 1;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * bool param_3 = obj.HasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class FrequencyTracker {\\n    Dictionary<int, int> freq;\\n    Dictionary<int, int> freqFreq;\\n\\n    public FrequencyTracker() {\\n        freq = new Dictionary<int, int>();\\n        freqFreq = new Dictionary<int, int>();\\n    }\\n\\n    public void Add(int number) {\\n        int oldCnt = freq.GetValueOrDefault(number, 0);\\n        freq[number] = freq.GetValueOrDefault(number, 0) + 1;\\n        UpdateCntFromTo(oldCnt, freq[number]);\\n    }\\n\\n    public void DeleteOne(int number) {\\n        if (freq.ContainsKey(number)) {\\n            int oldCnt = freq[number];\\n            freq[number]--;\\n            if (freq[number] == 0) freq.Remove(number);\\n\\n            UpdateCntFromTo(oldCnt, freq.GetValueOrDefault(number, 0));\\n        }\\n    }\\n\\n    public bool HasFrequency(int frequency) {\\n        return freqFreq.ContainsKey(frequency);\\n    }\\n\\n    private void UpdateCntFromTo(int oldCnt, int newCnt) {\\n        if (oldCnt > 0) {\\n            freqFreq[oldCnt]--;\\n            if (freqFreq[oldCnt] == 0) freqFreq.Remove(oldCnt);\\n        }\\n\\n        if (newCnt > 0) freqFreq[newCnt] = freqFreq.GetValueOrDefault(newCnt, 0) + 1;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * bool param_3 = obj.HasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522499,
                "title": "counter-map-and-frequency-map",
                "content": "```\\n\\nvar FrequencyTracker = function() {\\n    // this.map = new Map(); // <num, freq>\\n    this.nums = new Array(100002).fill(0);\\n    this.freqMap = new Map(); //<freq, counter>\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.add = function(number) {\\n    const oldCount = this.nums[number];\\n    const curCount = oldCount + 1;\\n    this.nums[number]++;\\n    // update freqMap\\n    if(oldCount > 0) {\\n        this.freqMap.set(oldCount, this.freqMap.get(oldCount)  - 1);\\n        if(this.freqMap.get(oldCount) <= 0) {\\n            this.freqMap.delete(oldCount);\\n        }\\n    }\\n    this.freqMap.set(curCount, (this.freqMap.get(curCount) ?? 0 ) + 1);\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.deleteOne = function(number) {\\n    if(this.nums[number] > 0) {\\n        const oldCount = this.nums[number];\\n        const curCount = oldCount - 1;\\n        this.nums[number]--;\\n        // update freqMap\\n        this.freqMap.set(oldCount, this.freqMap.get(oldCount)  - 1);\\n        if(this.freqMap.get(oldCount) <= 0) {\\n            this.freqMap.delete(oldCount);\\n        }\\n        this.freqMap.set(curCount, (this.freqMap.get(curCount) ?? 0 ) + 1);\\n    }\\n};\\n\\n/** \\n * @param {number} frequency\\n * @return {boolean}\\n */\\nFrequencyTracker.prototype.hasFrequency = function(frequency) {\\n    return this.freqMap.has(frequency);\\n};\\n\\n/** \\n * Your FrequencyTracker object will be instantiated and called as such:\\n * var obj = new FrequencyTracker()\\n * obj.add(number)\\n * obj.deleteOne(number)\\n * var param_3 = obj.hasFrequency(frequency)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar FrequencyTracker = function() {\\n    // this.map = new Map(); // <num, freq>\\n    this.nums = new Array(100002).fill(0);\\n    this.freqMap = new Map(); //<freq, counter>\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.add = function(number) {\\n    const oldCount = this.nums[number];\\n    const curCount = oldCount + 1;\\n    this.nums[number]++;\\n    // update freqMap\\n    if(oldCount > 0) {\\n        this.freqMap.set(oldCount, this.freqMap.get(oldCount)  - 1);\\n        if(this.freqMap.get(oldCount) <= 0) {\\n            this.freqMap.delete(oldCount);\\n        }\\n    }\\n    this.freqMap.set(curCount, (this.freqMap.get(curCount) ?? 0 ) + 1);\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.deleteOne = function(number) {\\n    if(this.nums[number] > 0) {\\n        const oldCount = this.nums[number];\\n        const curCount = oldCount - 1;\\n        this.nums[number]--;\\n        // update freqMap\\n        this.freqMap.set(oldCount, this.freqMap.get(oldCount)  - 1);\\n        if(this.freqMap.get(oldCount) <= 0) {\\n            this.freqMap.delete(oldCount);\\n        }\\n        this.freqMap.set(curCount, (this.freqMap.get(curCount) ?? 0 ) + 1);\\n    }\\n};\\n\\n/** \\n * @param {number} frequency\\n * @return {boolean}\\n */\\nFrequencyTracker.prototype.hasFrequency = function(frequency) {\\n    return this.freqMap.has(frequency);\\n};\\n\\n/** \\n * Your FrequencyTracker object will be instantiated and called as such:\\n * var obj = new FrequencyTracker()\\n * obj.add(number)\\n * obj.deleteOne(number)\\n * var param_3 = obj.hasFrequency(frequency)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520029,
                "title": "java-o-1-optimal-solution-2-arrays-easy-explanation-beginner-friendly",
                "content": "# Intuition\\nStoring frequency of number in array as well as storing no. of elements with a frequency in an array.\\n\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    int[] ar;          //for storing frequency of a number\\n    int[] freq;        // for storing no. of elements with a particular frequency\\n\\n    public FrequencyTracker() {\\n        ar=new int[100001];\\n        freq=new int[100001]; \\n    }\\n    \\n    public void add(int number) {\\n        // add 1 to numbers frequency and fetch current frequcny and shift 1 point from lower freq to current frequency\\n        if(ar[number]>0){\\n            freq[ar[number]]--;\\n            ar[number]++;\\n            freq[ar[number]]++;\\n        }else{\\n            ar[number]++;\\n            freq[1]++;\\n        }\\n    }\\n    \\n    public void deleteOne(int number) {\\n        // reduce freq of the number and shift 1 point from freq of numer to 1 less frequency\\n        if(ar[number]==0) return;\\n        if(ar[number]==1){\\n            ar[number]--;\\n            freq[1]--;\\n        }else{\\n            freq[ar[number]]--;\\n            ar[number]--;\\n            freq[ar[number]]++;\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        //true if there are numbers with given frequency\\n        return freq[frequency]>0;\\n        \\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    int[] ar;          //for storing frequency of a number\\n    int[] freq;        // for storing no. of elements with a particular frequency\\n\\n    public FrequencyTracker() {\\n        ar=new int[100001];\\n        freq=new int[100001]; \\n    }\\n    \\n    public void add(int number) {\\n        // add 1 to numbers frequency and fetch current frequcny and shift 1 point from lower freq to current frequency\\n        if(ar[number]>0){\\n            freq[ar[number]]--;\\n            ar[number]++;\\n            freq[ar[number]]++;\\n        }else{\\n            ar[number]++;\\n            freq[1]++;\\n        }\\n    }\\n    \\n    public void deleteOne(int number) {\\n        // reduce freq of the number and shift 1 point from freq of numer to 1 less frequency\\n        if(ar[number]==0) return;\\n        if(ar[number]==1){\\n            ar[number]--;\\n            freq[1]--;\\n        }else{\\n            freq[ar[number]]--;\\n            ar[number]--;\\n            freq[ar[number]]++;\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        //true if there are numbers with given frequency\\n        return freq[frequency]>0;\\n        \\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517382,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass FrequencyTracker {\\n    unordered_map<int,int> mp1;\\n    unordered_map<int,int> mp2;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(mp1.find(number) != mp1.end())\\n        {\\n            mp2[mp1[number]]--;\\n            if(mp2[mp1[number]] == 0) mp2.erase(mp1[number]);\\n        }\\n        mp1[number]++;\\n        mp2[mp1[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp1.find(number) != mp1.end()) \\n        {\\n            mp2[mp1[number]]--;\\n            if(mp2[mp1[number]] == 0) mp2.erase(mp1[number]);\\n            mp1[number]--;\\n            if(mp1[number] == 0) mp1.erase(number);\\n            else mp2[mp1[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(mp2.find(frequency) != mp2.end()) return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    unordered_map<int,int> mp1;\\n    unordered_map<int,int> mp2;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(mp1.find(number) != mp1.end())\\n        {\\n            mp2[mp1[number]]--;\\n            if(mp2[mp1[number]] == 0) mp2.erase(mp1[number]);\\n        }\\n        mp1[number]++;\\n        mp2[mp1[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp1.find(number) != mp1.end()) \\n        {\\n            mp2[mp1[number]]--;\\n            if(mp2[mp1[number]] == 0) mp2.erase(mp1[number]);\\n            mp1[number]--;\\n            if(mp1[number] == 0) mp1.erase(number);\\n            else mp2[mp1[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(mp2.find(frequency) != mp2.end()) return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516740,
                "title": "single-map-tle-1115-1118-tc-s-passed-optimised-two-maps",
                "content": "// USING ONE MAP\\n\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<long long int,long long int> mp;\\n    \\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        mp[number]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n       \\n           if(mp[number]==0)mp.erase(number);\\n        else mp[number]--;\\n        \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n       for(auto it :mp){\\n           if(it.second==frequency) return true;\\n       }\\n        return false;\\n    }\\n};\\n\\n// USING TWO MAPS\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp,freq; // freq map for storing frequency of frequencies \\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(freq[mp[number]]>0){ // if a number is added to mp that is already there, then the value of freq map to that particular key will change\\n            freq[mp[number]]--;\\n        }\\n        mp[number]++;\\n        freq[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]>0){\\n            freq[mp[number]]--; //decrement the freq of that frequency\\n            mp[number]--;\\n            freq[mp[number]]++;// add/increment new frequency generated\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency];\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */",
                "solutionTags": [],
                "code": "// USING ONE MAP\\n\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<long long int,long long int> mp;\\n    \\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        mp[number]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n       \\n           if(mp[number]==0)mp.erase(number);\\n        else mp[number]--;\\n        \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n       for(auto it :mp){\\n           if(it.second==frequency) return true;\\n       }\\n        return false;\\n    }\\n};\\n\\n// USING TWO MAPS\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp,freq; // freq map for storing frequency of frequencies \\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(freq[mp[number]]>0){ // if a number is added to mp that is already there, then the value of freq map to that particular key will change\\n            freq[mp[number]]--;\\n        }\\n        mp[number]++;\\n        freq[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]>0){\\n            freq[mp[number]]--; //decrement the freq of that frequency\\n            mp[number]--;\\n            freq[mp[number]]++;// add/increment new frequency generated\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency];\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 3515693,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n        HashMap <Integer, Integer> map=new HashMap <Integer, Integer>();\\n        HashMap <Integer, Integer> freq=new HashMap <Integer, Integer>();\\n    \\n    public FrequencyTracker() {\\n        \\n\\n    }\\n    \\n    public void add(int number) {\\n        map.put(number, map.getOrDefault(number,0)+1);\\n        int a=map.get(number);\\n        if (a>0) freq.put(a-1, freq.getOrDefault(a-1,0)-1);\\n        freq.put(a, freq.getOrDefault(a,0)+1);\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if (map.getOrDefault(number,0)<=0) return;\\n        map.put(number, map.getOrDefault(number,0)-1);\\n        int a=map.getOrDefault(number,-1);\\n        if (a>=0) {freq.put(a, freq.getOrDefault(a,0)+1);\\n        freq.put(a+1, freq.getOrDefault(a+1,0)-1);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        int a= freq.getOrDefault(frequency,0);\\n        return (a>0);\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n        HashMap <Integer, Integer> map=new HashMap <Integer, Integer>();\\n        HashMap <Integer, Integer> freq=new HashMap <Integer, Integer>();\\n    \\n    public FrequencyTracker() {\\n        \\n\\n    }\\n    \\n    public void add(int number) {\\n        map.put(number, map.getOrDefault(number,0)+1);\\n        int a=map.get(number);\\n        if (a>0) freq.put(a-1, freq.getOrDefault(a-1,0)-1);\\n        freq.put(a, freq.getOrDefault(a,0)+1);\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if (map.getOrDefault(number,0)<=0) return;\\n        map.put(number, map.getOrDefault(number,0)-1);\\n        int a=map.getOrDefault(number,-1);\\n        if (a>=0) {freq.put(a, freq.getOrDefault(a,0)+1);\\n        freq.put(a+1, freq.getOrDefault(a+1,0)-1);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        int a= freq.getOrDefault(frequency,0);\\n        return (a>0);\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514205,
                "title": "c-double-unordered-map",
                "content": "\\n```\\nclass FrequencyTracker \\n{\\n    unordered_map<int, int> nums;\\n    unordered_map<int, int> freq;\\npublic:\\n    FrequencyTracker() \\n    {\\n        \\n    }\\n    \\n    void add(int number) \\n    {\\n        if (nums.find(number) != nums.end())\\n        {\\n            int curFreq = nums[number];\\n            --freq[curFreq];\\n        }\\n\\n        ++nums[number];\\n        ++freq[nums[number]];\\n    }\\n    \\n    void deleteOne(int number) \\n    {\\n        if (nums.find(number) == nums.end())\\n        {\\n            return;\\n        }\\n\\n        int curFreq = nums[number];\\n        --freq[curFreq];\\n\\n        --nums[number];\\n        if (nums[number] > 0)\\n        {\\n            ++freq[nums[number]];\\n        }\\n        else if (nums[number] == 0)\\n        {\\n            nums.erase(number);\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) \\n    {\\n        return freq[frequency] > 0;   \\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker \\n{\\n    unordered_map<int, int> nums;\\n    unordered_map<int, int> freq;\\npublic:\\n    FrequencyTracker() \\n    {\\n        \\n    }\\n    \\n    void add(int number) \\n    {\\n        if (nums.find(number) != nums.end())\\n        {\\n            int curFreq = nums[number];\\n            --freq[curFreq];\\n        }\\n\\n        ++nums[number];\\n        ++freq[nums[number]];\\n    }\\n    \\n    void deleteOne(int number) \\n    {\\n        if (nums.find(number) == nums.end())\\n        {\\n            return;\\n        }\\n\\n        int curFreq = nums[number];\\n        --freq[curFreq];\\n\\n        --nums[number];\\n        if (nums[number] > 0)\\n        {\\n            ++freq[nums[number]];\\n        }\\n        else if (nums[number] == 0)\\n        {\\n            nums.erase(number);\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) \\n    {\\n        return freq[frequency] > 0;   \\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513798,
                "title": "use-2-maps",
                "content": "# Intuition\\none map stores key and number of times keys come.\\nanother map stores frequency of number of keys. \\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int>mp,mps;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int n) {\\n        if(mp.find(n)!=mp.end()){\\n            mps[mp[n]]--;\\n        }\\n        mp[n]++;\\n        \\n        mps[mp[n]]++;\\n    }\\n    \\n    void deleteOne(int n) {\\n        mps[mp[n]]--;\\n        mp[n]--;\\n        \\n        if(mp[n]<=0)mp.erase(n);\\n        else mps[mp[n]]++;\\n    }\\n    \\n    bool hasFrequency(int f) {\\n        if((mps.find(f)!=mps.end())&& mps[f]>0)return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int>mp,mps;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int n) {\\n        if(mp.find(n)!=mp.end()){\\n            mps[mp[n]]--;\\n        }\\n        mp[n]++;\\n        \\n        mps[mp[n]]++;\\n    }\\n    \\n    void deleteOne(int n) {\\n        mps[mp[n]]--;\\n        mp[n]--;\\n        \\n        if(mp[n]<=0)mp.erase(n);\\n        else mps[mp[n]]++;\\n    }\\n    \\n    bool hasFrequency(int f) {\\n        if((mps.find(f)!=mps.end())&& mps[f]>0)return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513679,
                "title": "python-hashmap",
                "content": "```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.dic1 = defaultdict(int)\\n        self.dic2 = defaultdict(set)\\n\\n    def add(self, number: int) -> None:\\n        self.dic1[number] += 1\\n        temp = self.dic1[number]\\n        self.dic2[temp].add(number)\\n        if temp > 1:\\n            self.dic2[temp-1].remove(number)\\n    def deleteOne(self, number: int) -> None:\\n        if number in self.dic1:\\n            self.dic1[number] -= 1\\n            temp = self.dic1[number]\\n            if not self.dic1[number]:\\n                del self.dic1[number]\\n            self.dic2[temp+1].remove(number)\\n            if temp > 0:\\n                self.dic2[temp].add(number)\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        if self.dic2[frequency]:\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.dic1 = defaultdict(int)\\n        self.dic2 = defaultdict(set)\\n\\n    def add(self, number: int) -> None:\\n        self.dic1[number] += 1\\n        temp = self.dic1[number]\\n        self.dic2[temp].add(number)\\n        if temp > 1:\\n            self.dic2[temp-1].remove(number)\\n    def deleteOne(self, number: int) -> None:\\n        if number in self.dic1:\\n            self.dic1[number] -= 1\\n            temp = self.dic1[number]\\n            if not self.dic1[number]:\\n                del self.dic1[number]\\n            self.dic2[temp+1].remove(number)\\n            if temp > 0:\\n                self.dic2[temp].add(number)\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        if self.dic2[frequency]:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512682,
                "title": "swift-solution-not-so-well-optimized-but-worked",
                "content": "# Approach\\n1. We have two arrays, `freqArray` and `freqOfFreq`, both of size 100001. \\n2. `freqArray` is used to keep track of the frequency of each element. \\n3. `freqOfFreq` is used to keep track of the frequency of each frequency, i.e., it is used to keep track of how many elements are there with a frequency of 1, how many elements are there with a frequency of 2, etc. \\n4. When we add a number, we increment the frequency of that number in `freqArray` by 1. Then, we decrement the frequency of the old frequency of that number in `freqOfFreq` by 1, and increment the frequency of the new frequency of that number in `freqOfFreq` by 1. \\n5. When we delete a number, we decrement the frequency of that number in `freqArray` by 1. Then, we decrement the frequency of the old frequency of that number in `freqOfFreq` by 1, and increment the frequency of the new frequency of that number in `freqOfFreq` by 1. \\n6. To check if a frequency exists, we simply check if `freqOfFreq[frequency] > 0`.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    var freqArray: [Int]\\n    var freqOfFreq: [Int]\\n    \\n    init() {\\n        freqArray = [Int](repeating: 0, count: 100001)\\n        freqOfFreq = [Int](repeating: 0, count: 100001)\\n    }\\n    \\n    func add(_ number: Int) {\\n        let oldFreq = freqArray[number]\\n        freqArray[number] += 1\\n        freqOfFreq[oldFreq] -= 1\\n        freqOfFreq[freqArray[number]] += 1\\n    }\\n    \\n    func deleteOne(_ number: Int) {\\n        if freqArray[number] > 0 {\\n            freqOfFreq[freqArray[number]] -= 1\\n            freqArray[number] -= 1\\n            freqOfFreq[freqArray[number]] += 1\\n        }\\n    }\\n    \\n    func hasFrequency(_ frequency: Int) -> Bool {\\n        return freqOfFreq[frequency] > 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    var freqArray: [Int]\\n    var freqOfFreq: [Int]\\n    \\n    init() {\\n        freqArray = [Int](repeating: 0, count: 100001)\\n        freqOfFreq = [Int](repeating: 0, count: 100001)\\n    }\\n    \\n    func add(_ number: Int) {\\n        let oldFreq = freqArray[number]\\n        freqArray[number] += 1\\n        freqOfFreq[oldFreq] -= 1\\n        freqOfFreq[freqArray[number]] += 1\\n    }\\n    \\n    func deleteOne(_ number: Int) {\\n        if freqArray[number] > 0 {\\n            freqOfFreq[freqArray[number]] -= 1\\n            freqArray[number] -= 1\\n            freqOfFreq[freqArray[number]] += 1\\n        }\\n    }\\n    \\n    func hasFrequency(_ frequency: Int) -> Bool {\\n        return freqOfFreq[frequency] > 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511272,
                "title": "java-easy-2-hashmap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n  HashMap<Integer, Integer> table = new HashMap<>();\\n  HashMap<Integer, Integer>  freq = new HashMap<>();\\n  \\n  public void add(int number) {\\n    Integer f = table.get(number);\\n    if(f == null) f = 0;\\n    table.put(number, f + 1);\\n    if(f != 0) freq.put(f, freq.get(f) - 1);\\n    Integer k = freq.get(++f);\\n    if(k == null) k = 0;\\n    freq.put(f, k + 1);     \\n  }\\n    \\n  public void deleteOne(int number) {\\n    Integer f = table.get(number);\\n    if(f == null || f == 0) return;\\n    table.put(number, f - 1);\\n    freq.put(f, freq.get(f) - 1);\\n    if(--f != 0) freq.put(f, freq.get(f) + 1);    \\n  }\\n    \\n  public boolean hasFrequency(int frequency) {\\n    Integer f = freq.get(frequency);\\n    return f != null && f != 0;      \\n  }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n  HashMap<Integer, Integer> table = new HashMap<>();\\n  HashMap<Integer, Integer>  freq = new HashMap<>();\\n  \\n  public void add(int number) {\\n    Integer f = table.get(number);\\n    if(f == null) f = 0;\\n    table.put(number, f + 1);\\n    if(f != 0) freq.put(f, freq.get(f) - 1);\\n    Integer k = freq.get(++f);\\n    if(k == null) k = 0;\\n    freq.put(f, k + 1);     \\n  }\\n    \\n  public void deleteOne(int number) {\\n    Integer f = table.get(number);\\n    if(f == null || f == 0) return;\\n    table.put(number, f - 1);\\n    freq.put(f, freq.get(f) - 1);\\n    if(--f != 0) freq.put(f, freq.get(f) + 1);    \\n  }\\n    \\n  public boolean hasFrequency(int frequency) {\\n    Integer f = freq.get(frequency);\\n    return f != null && f != 0;      \\n  }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511075,
                "title": "c-easy-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMaintain two maps, one for the number and its frequency and second for the frequency and frequency of frequency\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    map<int, int> m;\\n    map<int, int> f;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(m[number])\\n            f[m[number]]--;\\n        m[number]++;        \\n        f[m[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(m[number])\\n        {\\n            f[m[number]]--;\\n            m[number]--;\\n            f[m[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(f[frequency])\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    map<int, int> m;\\n    map<int, int> f;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(m[number])\\n            f[m[number]]--;\\n        m[number]++;        \\n        f[m[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(m[number])\\n        {\\n            f[m[number]]--;\\n            m[number]--;\\n            f[m[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(f[frequency])\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510533,
                "title": "swift-forward-reverse-map-o-1",
                "content": "**Two Maps (accepted answer)**\\n```\\nclass FrequencyTracker {\\n    var freq = [Int:Int]()  // maps `number` -> frequency count\\n    var revFreq = [Int:Int]() // maps frequency count -> how many are at that freq\\n\\n    func add(_ number: Int) { // O(1)\\n        let f = freq[number, default:0]\\n        revFreq[f, default: 1] -= 1 \\n        freq[number] = f+1\\n        revFreq[f+1, default:0] += 1\\n    }\\n    \\n    func deleteOne(_ number: Int) { // O(1)\\n        if let f = freq[number], f > 0 { \\n            revFreq[f]! -= 1 \\n            freq[number] = f-1\\n            revFreq[f-1, default:0] += 1\\n        }\\n    }\\n    \\n    func hasFrequency(_ frequency: Int) -> Bool { // O(1)\\n        revFreq[frequency, default:0] > 0\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    var freq = [Int:Int]()  // maps `number` -> frequency count\\n    var revFreq = [Int:Int]() // maps frequency count -> how many are at that freq\\n\\n    func add(_ number: Int) { // O(1)\\n        let f = freq[number, default:0]\\n        revFreq[f, default: 1] -= 1 \\n        freq[number] = f+1\\n        revFreq[f+1, default:0] += 1\\n    }\\n    \\n    func deleteOne(_ number: Int) { // O(1)\\n        if let f = freq[number], f > 0 { \\n            revFreq[f]! -= 1 \\n            freq[number] = f-1\\n            revFreq[f-1, default:0] += 1\\n        }\\n    }\\n    \\n    func hasFrequency(_ frequency: Int) -> Bool { // O(1)\\n        revFreq[frequency, default:0] > 0\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510156,
                "title": "easy-to-understand",
                "content": "# Code\\n```\\nclass FrequencyTracker {\\n\\n    Map<Integer, Integer> numToFreq;\\n    Map<Integer, Set<Integer>> freqToNum;\\n    \\n    public FrequencyTracker() {\\n        numToFreq = new HashMap<Integer, Integer>();\\n        freqToNum = new HashMap<Integer, Set<Integer>>();\\n    }\\n    \\n    public void add(int number) {\\n        int previousFreq = numToFreq.getOrDefault(number, 0);\\n        numToFreq.put(number, previousFreq + 1);\\n        \\n        adjustFreq(previousFreq, previousFreq + 1, number);\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(!numToFreq.containsKey(number) || (numToFreq.containsKey(number) && numToFreq.get(number) <= 0)) return;\\n        \\n        int previousFreq = numToFreq.get(number);\\n        numToFreq.put(number, previousFreq - 1);\\n        \\n        adjustFreq(previousFreq, previousFreq - 1, number);\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freqToNum.containsKey(frequency) && freqToNum.get(frequency).size() > 0;\\n    }\\n    \\n    private void adjustFreq(int previousFreq, int currFreq, int number) {\\n         if(freqToNum.containsKey(previousFreq)) {\\n            Set<Integer> set = freqToNum.get(previousFreq);\\n            set.remove(number);\\n            freqToNum.put(previousFreq, set);\\n        }\\n        \\n        Set<Integer> set = new HashSet<Integer>();\\n        if(freqToNum.containsKey(currFreq)) {\\n            set = freqToNum.get(currFreq);\\n        }\\n        \\n        set.add(number);\\n        freqToNum.put(currFreq, set);\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nclass FrequencyTracker {\\n\\n    Map<Integer, Integer> numToFreq;\\n    Map<Integer, Set<Integer>> freqToNum;\\n    \\n    public FrequencyTracker() {\\n        numToFreq = new HashMap<Integer, Integer>();\\n        freqToNum = new HashMap<Integer, Set<Integer>>();\\n    }\\n    \\n    public void add(int number) {\\n        int previousFreq = numToFreq.getOrDefault(number, 0);\\n        numToFreq.put(number, previousFreq + 1);\\n        \\n        adjustFreq(previousFreq, previousFreq + 1, number);\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(!numToFreq.containsKey(number) || (numToFreq.containsKey(number) && numToFreq.get(number) <= 0)) return;\\n        \\n        int previousFreq = numToFreq.get(number);\\n        numToFreq.put(number, previousFreq - 1);\\n        \\n        adjustFreq(previousFreq, previousFreq - 1, number);\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freqToNum.containsKey(frequency) && freqToNum.get(frequency).size() > 0;\\n    }\\n    \\n    private void adjustFreq(int previousFreq, int currFreq, int number) {\\n         if(freqToNum.containsKey(previousFreq)) {\\n            Set<Integer> set = freqToNum.get(previousFreq);\\n            set.remove(number);\\n            freqToNum.put(previousFreq, set);\\n        }\\n        \\n        Set<Integer> set = new HashSet<Integer>();\\n        if(freqToNum.containsKey(currFreq)) {\\n            set = freqToNum.get(currFreq);\\n        }\\n        \\n        set.add(number);\\n        freqToNum.put(currFreq, set);\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510049,
                "title": "c-two-unordered-map",
                "content": "# Intuition\\nHow would we solve the problem if it required only add and remove? Some hash-map (`unordered_map`) can keep the numbers + their frequency. \\nWe need to return if there exists one number with a given frequency; we don\\'t care what number -- so, we can keep track of the frequency of frequencies. \\n\\n# Approach\\nWe keep track of the frequency for each number (using a hashmap); also store a hashmap of frequencies of frequencies. If a number `n` is added, then `freq[n]` will increase, so we need to update the counts for the frequency of `freq[n]`, i.e., `freq_freq[freq[n]]` will be incremented, and we decrement the frequency of the previous frequency of n.\\nE.g. if we add number 5, which existed 2 times already, then `freq[5] = 3;`, and then `freq_freq[3]` will increase; we need to keep in mind that the number of numbers with frequency 2 will decrease (since frequency of 5 is now 3).\\n\\n# Complexity\\n- Time complexity:\\n`add(number)` --> $$O(1)$$ -- because we use unordered_map for both numbers and frequencies.\\n`deleteOne(number)` --> $$O(1)$$ -- just update values in unordered_map\\n`hasFrequency` --> $$O(1)$$ -- check value in unordered_map\\n\\n- Space complexity:\\n- Time complexity:\\n$$O(n)$$ -- where n is the number of numbers added; in the worst case scenario, e.g. all numbers are different, we store one frequency for each number.\\n\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        int prev_freq = nfreq_[number];\\n        ++nfreq_[number];\\n        if (prev_freq > 0 && freq_freq[prev_freq] > 0) {\\n            --freq_freq[prev_freq];\\n        }\\n        ++freq_freq[nfreq_[number]];\\n    }\\n    \\n    void deleteOne(int number) {\\n        int prev_freq = nfreq_[number];\\n        if (prev_freq > 0) {\\n            --nfreq_[number];\\n            --freq_freq[prev_freq];\\n            if (nfreq_[number] > 0) {\\n                ++freq_freq[nfreq_[number]];\\n            }\\n            \\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq_freq[frequency] > 0;\\n    }\\n\\nprivate:\\n    unordered_map<int, int> nfreq_;\\n    unordered_map<int, int> freq_freq;\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        int prev_freq = nfreq_[number];\\n        ++nfreq_[number];\\n        if (prev_freq > 0 && freq_freq[prev_freq] > 0) {\\n            --freq_freq[prev_freq];\\n        }\\n        ++freq_freq[nfreq_[number]];\\n    }\\n    \\n    void deleteOne(int number) {\\n        int prev_freq = nfreq_[number];\\n        if (prev_freq > 0) {\\n            --nfreq_[number];\\n            --freq_freq[prev_freq];\\n            if (nfreq_[number] > 0) {\\n                ++freq_freq[nfreq_[number]];\\n            }\\n            \\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq_freq[frequency] > 0;\\n    }\\n\\nprivate:\\n    unordered_map<int, int> nfreq_;\\n    unordered_map<int, int> freq_freq;\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509303,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    int[] arr_map;\\n    int[] arr_freq;\\n    public FrequencyTracker() {\\n        arr_map = new int[100001];\\n        arr_freq = new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        if(arr_map[number] > 0)\\n        {\\n            arr_freq[arr_map[number]]--;\\n        }\\n        arr_map[number]++;\\n        arr_freq[arr_map[number]]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(arr_map[number] > 0)\\n        {\\n            arr_freq[arr_map[number]]--;\\n            arr_map[number]--;\\n            arr_freq[arr_map[number]]++;\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(arr_freq[frequency] > 0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    int[] arr_map;\\n    int[] arr_freq;\\n    public FrequencyTracker() {\\n        arr_map = new int[100001];\\n        arr_freq = new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        if(arr_map[number] > 0)\\n        {\\n            arr_freq[arr_map[number]]--;\\n        }\\n        arr_map[number]++;\\n        arr_freq[arr_map[number]]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(arr_map[number] > 0)\\n        {\\n            arr_freq[arr_map[number]]--;\\n            arr_map[number]--;\\n            arr_freq[arr_map[number]]++;\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(arr_freq[frequency] > 0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507650,
                "title": "simple-java-solution-with-explananation",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\nint freqArray[], freqOfFreq[];\\n    public FrequencyTracker() {\\n        freqArray=new int[100001];//stores the frequency of the numbers, where indices are the numbers (1 <= number <= 105)\\n        freqOfFreq=new int[100001]; //stores the frequency of the frequencies, where indices are frequencies (1 <= frequency <= 105)\\n    }\\n    \\n    public void add(int number) {\\n        //adjusting the freqArray\\n        int oldFreq=freqArray[number]++;\\n        //adjusting the freqOfFreq array, with old and new frequency values\\n        freqOfFreq[oldFreq]--;\\n        freqOfFreq[freqArray[number]]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(freqArray[number]>0) //if the number exists\\n        {   //adjusting the freqOfFreq array, with old and new frequency values\\n            freqOfFreq[freqArray[number]--]--;\\n            freqOfFreq[freqArray[number]]++;\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freqOfFreq[frequency] >0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass FrequencyTracker {\\nint freqArray[], freqOfFreq[];\\n    public FrequencyTracker() {\\n        freqArray=new int[100001];//stores the frequency of the numbers, where indices are the numbers (1 <= number <= 105)\\n        freqOfFreq=new int[100001]; //stores the frequency of the frequencies, where indices are frequencies (1 <= frequency <= 105)\\n    }\\n    \\n    public void add(int number) {\\n        //adjusting the freqArray\\n        int oldFreq=freqArray[number]++;\\n        //adjusting the freqOfFreq array, with old and new frequency values\\n        freqOfFreq[oldFreq]--;\\n        freqOfFreq[freqArray[number]]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(freqArray[number]>0) //if the number exists\\n        {   //adjusting the freqOfFreq array, with old and new frequency values\\n            freqOfFreq[freqArray[number]--]--;\\n            freqOfFreq[freqArray[number]]++;\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freqOfFreq[frequency] >0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507523,
                "title": "c-easy-an-clear",
                "content": "```\\nclass FrequencyTracker {\\nprivate:\\n    unordered_map<int,int>map;\\n    unordered_map<int,int>freq;\\npublic:\\n    FrequencyTracker() {\\n    }\\n    void add(int n) {\\n        if(map.find(n) != map.end()){ //already exists\\n            freq[map[n]]--;         \\n        }\\n        map[n]++;\\n       freq[map[n]]++;\\n    }\\n\\n    void deleteOne(int n) {\\n        if(map.find(n) == map.end()){ //not in found\\n            return;\\n        }\\n\\t\\t\\n        freq[map[n]]--;\\n        map[n]--;\\n        \\n        if(map[n]<=0){\\n            map.erase(n);\\n        }else{\\n            freq[map[n]]++;\\n        }\\n    }\\n\\n    bool hasFrequency(int frequency) {\\n        return freq.find(frequency) != freq.end() && freq[frequency]>0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\nprivate:\\n    unordered_map<int,int>map;\\n    unordered_map<int,int>freq;\\npublic:\\n    FrequencyTracker() {\\n    }\\n    void add(int n) {\\n        if(map.find(n) != map.end()){ //already exists\\n            freq[map[n]]--;         \\n        }\\n        map[n]++;\\n       freq[map[n]]++;\\n    }\\n\\n    void deleteOne(int n) {\\n        if(map.find(n) == map.end()){ //not in found\\n            return;\\n        }\\n\\t\\t\\n        freq[map[n]]--;\\n        map[n]--;\\n        \\n        if(map[n]<=0){\\n            map.erase(n);\\n        }else{\\n            freq[map[n]]++;\\n        }\\n    }\\n\\n    bool hasFrequency(int frequency) {\\n        return freq.find(frequency) != freq.end() && freq[frequency]>0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506288,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Hashing\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker \\n{\\npublic:\\n    unordered_map<int,int> count;\\n    unordered_map<int,int> freq;\\n\\n    FrequencyTracker() \\n    {\\n        ;    \\n    }\\n    \\n    void add(int number) \\n    {\\n        freq[count[number]]--;\\n        count[number]++;\\n        freq[count[number]]++;\\n    }\\n    \\n    void deleteOne(int number) \\n    {\\n        if(count[number]>0)\\n        {\\n            freq[count[number]]--;\\n            count[number]--;\\n            freq[count[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) \\n    {\\n        if(freq[frequency]>0)\\n        {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker \\n{\\npublic:\\n    unordered_map<int,int> count;\\n    unordered_map<int,int> freq;\\n\\n    FrequencyTracker() \\n    {\\n        ;    \\n    }\\n    \\n    void add(int number) \\n    {\\n        freq[count[number]]--;\\n        count[number]++;\\n        freq[count[number]]++;\\n    }\\n    \\n    void deleteOne(int number) \\n    {\\n        if(count[number]>0)\\n        {\\n            freq[count[number]]--;\\n            count[number]--;\\n            freq[count[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) \\n    {\\n        if(freq[frequency]>0)\\n        {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505531,
                "title": "c-solution-using-two-maps",
                "content": "# Approach\\nWe use two maps, one to keep track of elements\\' count and one to keep track of frequencies.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$ (Worst case for unordered map)\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    \\n    unordered_map<int, int> mp, freq;\\n    \\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        freq[mp[number]]--;\\n        if(!freq[mp[number]]) freq.erase(mp[number]);\\n        mp[number]++;\\n        freq[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(!mp.count(number)) return;\\n        freq[mp[number]]--;\\n        if(!freq[mp[number]]) freq.erase(mp[number]);\\n        mp[number]--;\\n        freq[mp[number]]++;\\n        if(!mp[number]) mp.erase(number);\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency];\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    \\n    unordered_map<int, int> mp, freq;\\n    \\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        freq[mp[number]]--;\\n        if(!freq[mp[number]]) freq.erase(mp[number]);\\n        mp[number]++;\\n        freq[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(!mp.count(number)) return;\\n        freq[mp[number]]--;\\n        if(!freq[mp[number]]) freq.erase(mp[number]);\\n        mp[number]--;\\n        freq[mp[number]]++;\\n        if(!mp[number]) mp.erase(number);\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency];\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504299,
                "title": "c-2-hashmaps",
                "content": "```\\nclass FrequencyTracker {\\n    unordered_map<int, int> num_freq;\\n    unordered_map<int, int> freq_count;\\npublic:\\n    FrequencyTracker() {\\n    }\\n    \\n    void add(int number) {\\n        if(num_freq.count(number) == 0) {\\n            num_freq.insert({number, 1});\\n            ++freq_count[1];\\n            return;\\n        }\\n        \\n        int old_freq = num_freq[number];\\n        int new_freq = ++num_freq[number];\\n        \\n        if(--freq_count[old_freq] == 0) {\\n            freq_count.erase(old_freq);\\n        }\\n        ++freq_count[new_freq];\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(num_freq.count(number) == 0) {\\n            return;\\n        }\\n        \\n        int old_freq = num_freq[number];\\n        int new_freq = --num_freq[number];\\n        \\n        if(new_freq == 0) {\\n            num_freq.erase(number);\\n        }\\n        \\n        if(--freq_count[old_freq] == 0) {\\n            freq_count.erase(old_freq);\\n        }\\n        \\n        if(new_freq > 0)\\n            ++freq_count[new_freq];\\n    }\\n    \\n    bool hasFrequency(int frequency) {        \\n        return freq_count.count(frequency) > 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass FrequencyTracker {\\n    unordered_map<int, int> num_freq;\\n    unordered_map<int, int> freq_count;\\npublic:\\n    FrequencyTracker() {\\n    }\\n    \\n    void add(int number) {\\n        if(num_freq.count(number) == 0) {\\n            num_freq.insert({number, 1});\\n            ++freq_count[1];\\n            return;\\n        }\\n        \\n        int old_freq = num_freq[number];\\n        int new_freq = ++num_freq[number];\\n        \\n        if(--freq_count[old_freq] == 0) {\\n            freq_count.erase(old_freq);\\n        }\\n        ++freq_count[new_freq];\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(num_freq.count(number) == 0) {\\n            return;\\n        }\\n        \\n        int old_freq = num_freq[number];\\n        int new_freq = --num_freq[number];\\n        \\n        if(new_freq == 0) {\\n            num_freq.erase(number);\\n        }\\n        \\n        if(--freq_count[old_freq] == 0) {\\n            freq_count.erase(old_freq);\\n        }\\n        \\n        if(new_freq > 0)\\n            ++freq_count[new_freq];\\n    }\\n    \\n    bool hasFrequency(int frequency) {        \\n        return freq_count.count(frequency) > 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504081,
                "title": "commented-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\nunordered_map<int,int> mp , freq; \\n    FrequencyTracker() \\n    {\\n        \\n    }\\n    \\n    void add(int number) \\n    {   \\n        int curr = mp[number];// find frequency of element before insertion if not present it would be zero \\n         \\n        freq[curr]--; // reduce that frequency if freq<int,int> map bcs now you are going to update the frequency of that element \\n        if(freq[curr]<=0) // ex [2,2,3] if you insert 2 then updated freq of 2 will be 3 nd there woulbe no element with freq 2 so \\n        freq.erase(curr); // if freq is <=0 remove from the map \\n         \\n        mp[number]++;\\n        freq[curr+1]++; // updte the increased frequency in freq map\\n       \\n    }\\n    \\n    void deleteOne(int number) \\n    {\\n          if(mp.find(number)==mp.end()) // no is not present \\n          return ;\\n          int currf = mp[number]; // [2,2,3,2] if we delete 2 from list there would be no elemet with freq 3  and update frequency would be 3 \\n         \\n          freq[currf]--; // so reduce the frequecny \\n          \\n          if(freq[currf]<=0)\\n          freq.erase(currf);\\n          \\n          if(currf-1>0)\\n          freq[currf-1]++; // [2,2,3,2] we deleted 2 no updated frequency is 3-1 {prevfrequency -1}\\n          mp[number]--;\\n          if(mp[number]<=0) // delete the number from map as well\\n          mp.erase(number);\\n           \\n\\n           \\n\\n    }\\n    \\n    bool hasFrequency(int frequency) \\n    {\\n        return freq.find(frequency)!=freq.end();\\n    }\\n};\\n\\n \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\nunordered_map<int,int> mp , freq; \\n    FrequencyTracker() \\n    {\\n        \\n    }\\n    \\n    void add(int number) \\n    {   \\n        int curr = mp[number];// find frequency of element before insertion if not present it would be zero \\n         \\n        freq[curr]--; // reduce that frequency if freq<int,int> map bcs now you are going to update the frequency of that element \\n        if(freq[curr]<=0) // ex [2,2,3] if you insert 2 then updated freq of 2 will be 3 nd there woulbe no element with freq 2 so \\n        freq.erase(curr); // if freq is <=0 remove from the map \\n         \\n        mp[number]++;\\n        freq[curr+1]++; // updte the increased frequency in freq map\\n       \\n    }\\n    \\n    void deleteOne(int number) \\n    {\\n          if(mp.find(number)==mp.end()) // no is not present \\n          return ;\\n          int currf = mp[number]; // [2,2,3,2] if we delete 2 from list there would be no elemet with freq 3  and update frequency would be 3 \\n         \\n          freq[currf]--; // so reduce the frequecny \\n          \\n          if(freq[currf]<=0)\\n          freq.erase(currf);\\n          \\n          if(currf-1>0)\\n          freq[currf-1]++; // [2,2,3,2] we deleted 2 no updated frequency is 3-1 {prevfrequency -1}\\n          mp[number]--;\\n          if(mp[number]<=0) // delete the number from map as well\\n          mp.erase(number);\\n           \\n\\n           \\n\\n    }\\n    \\n    bool hasFrequency(int frequency) \\n    {\\n        return freq.find(frequency)!=freq.end();\\n    }\\n};\\n\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504006,
                "title": "c-simplest-solution-on-leetcode-with-step-by-step-explanation",
                "content": "# Please dont forget to UPVOTE\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,set<int>> reversedMap;\\n    unordered_map<int,int> normalMap;\\n\\n    FrequencyTracker() {\\n        normalMap.clear();\\n        reversedMap.clear();\\n    }\\n    \\n    void add(int number) {\\n        //Step1: Find out the existing frequency\\n        int existingFreq=normalMap[number];\\n\\n        //Step2: Delete number from that existing frequency from reversedMap\\n        if(existingFreq != 0)\\n        {\\n            reversedMap[existingFreq].erase(number);\\n        }\\n\\n        //Step3: Increase the existing frequency\\n        normalMap[number]++;\\n\\n        //Step4: Find out new frequency\\n        int newFreq=normalMap[number];\\n\\n        //Step5: Insert the number to newFreq in reversedMap\\n        reversedMap[newFreq].insert(number);                        //set operation\\n    }\\n    \\n    void deleteOne(int number) {\\n        //Step1: Find out the existing frequency\\n        int existingFreq=normalMap[number];\\n        if(existingFreq==0) return;\\n\\n        //Step2: Delete number from that existing frequency from reversedMap\\n        reversedMap[existingFreq].erase(number);\\n\\n        //Step3: Decrease the existing frequency\\n        normalMap[number]--;\\n\\n        //Step4: Find out new frequency\\n        int newFreq=normalMap[number];\\n\\n        //Step5: Insert the number to newFreq in reversedMap\\n        reversedMap[newFreq].insert(number);                         //set operation\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(reversedMap[frequency].size() > 0) return true;\\n        else return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```\\n\\n# Please dont forget to UPVOTE and feel free to ask any question in comments",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,set<int>> reversedMap;\\n    unordered_map<int,int> normalMap;\\n\\n    FrequencyTracker() {\\n        normalMap.clear();\\n        reversedMap.clear();\\n    }\\n    \\n    void add(int number) {\\n        //Step1: Find out the existing frequency\\n        int existingFreq=normalMap[number];\\n\\n        //Step2: Delete number from that existing frequency from reversedMap\\n        if(existingFreq != 0)\\n        {\\n            reversedMap[existingFreq].erase(number);\\n        }\\n\\n        //Step3: Increase the existing frequency\\n        normalMap[number]++;\\n\\n        //Step4: Find out new frequency\\n        int newFreq=normalMap[number];\\n\\n        //Step5: Insert the number to newFreq in reversedMap\\n        reversedMap[newFreq].insert(number);                        //set operation\\n    }\\n    \\n    void deleteOne(int number) {\\n        //Step1: Find out the existing frequency\\n        int existingFreq=normalMap[number];\\n        if(existingFreq==0) return;\\n\\n        //Step2: Delete number from that existing frequency from reversedMap\\n        reversedMap[existingFreq].erase(number);\\n\\n        //Step3: Decrease the existing frequency\\n        normalMap[number]--;\\n\\n        //Step4: Find out new frequency\\n        int newFreq=normalMap[number];\\n\\n        //Step5: Insert the number to newFreq in reversedMap\\n        reversedMap[newFreq].insert(number);                         //set operation\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(reversedMap[frequency].size() > 0) return true;\\n        else return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503638,
                "title": "simple-c-solution-using-two-hash-maps",
                "content": "\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    map<int,int> m1,m2;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        \\n        m2[m1[number]]--;\\n        m1[number]++;\\n        m2[m1[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(m1[number]){\\n        m2[m1[number]]--;\\n        m1[number]--;\\n        m2[m1[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(m2[frequency])\\n        return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    map<int,int> m1,m2;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        \\n        m2[m1[number]]--;\\n        m1[number]++;\\n        m2[m1[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(m1[number]){\\n        m2[m1[number]]--;\\n        m1[number]--;\\n        m2[m1[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(m2[frequency])\\n        return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502762,
                "title": "python3-dict-set",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.numbers_count = defaultdict(int)\\n        self.frequency_map = defaultdict(set)\\n\\n    def add(self, number: int) -> None:\\n        if number in self.numbers_count:\\n            existing_frequency = self.numbers_count[number]\\n            self.frequency_map[existing_frequency].remove(number)\\n            if not self.frequency_map[existing_frequency]:\\n                del self.frequency_map[existing_frequency]\\n            self.numbers_count[number] = existing_frequency + 1\\n            self.frequency_map[existing_frequency+1].add(number)\\n        else:\\n            self.numbers_count[number] = 1\\n            self.frequency_map[1].add(number)\\n\\n\\n    def deleteOne(self, number: int) -> None:\\n        if number in self.numbers_count:\\n            if self.numbers_count[number] > 1:\\n                existing_frequency = self.numbers_count[number]\\n                self.numbers_count[number] = existing_frequency - 1\\n                self.frequency_map[existing_frequency].remove(number)\\n                if not self.frequency_map[existing_frequency]:\\n                    del self.frequency_map[existing_frequency]\\n                self.frequency_map[existing_frequency-1].add(number)\\n            elif self.numbers_count[number] == 1:\\n                del self.numbers_count[number]\\n                self.frequency_map[1].remove(number)\\n                if not self.frequency_map[1]:\\n                    del self.frequency_map[1]\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return frequency in self.frequency_map\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.numbers_count = defaultdict(int)\\n        self.frequency_map = defaultdict(set)\\n\\n    def add(self, number: int) -> None:\\n        if number in self.numbers_count:\\n            existing_frequency = self.numbers_count[number]\\n            self.frequency_map[existing_frequency].remove(number)\\n            if not self.frequency_map[existing_frequency]:\\n                del self.frequency_map[existing_frequency]\\n            self.numbers_count[number] = existing_frequency + 1\\n            self.frequency_map[existing_frequency+1].add(number)\\n        else:\\n            self.numbers_count[number] = 1\\n            self.frequency_map[1].add(number)\\n\\n\\n    def deleteOne(self, number: int) -> None:\\n        if number in self.numbers_count:\\n            if self.numbers_count[number] > 1:\\n                existing_frequency = self.numbers_count[number]\\n                self.numbers_count[number] = existing_frequency - 1\\n                self.frequency_map[existing_frequency].remove(number)\\n                if not self.frequency_map[existing_frequency]:\\n                    del self.frequency_map[existing_frequency]\\n                self.frequency_map[existing_frequency-1].add(number)\\n            elif self.numbers_count[number] == 1:\\n                del self.numbers_count[number]\\n                self.frequency_map[1].remove(number)\\n                if not self.frequency_map[1]:\\n                    del self.frequency_map[1]\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return frequency in self.frequency_map\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502362,
                "title": "java-solution-using-arrays-only",
                "content": "\\n```\\nclass FrequencyTracker {\\n  \\n    int[] fre;\\n    int[] arr;\\n\\n    public FrequencyTracker() {\\n        arr=new int[100001];\\n        fre=new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        fre[arr[number]]--;\\n        arr[number]++;\\n        fre[arr[number]]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(arr[number]>0){\\n        fre[arr[number]]--;\\n        arr[number]--;\\n        fre[arr[number]]++;\\n        }\\n       \\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n            if(fre[frequency]>0){\\n                return true;\\n            }\\n        \\n        return false;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n  \\n    int[] fre;\\n    int[] arr;\\n\\n    public FrequencyTracker() {\\n        arr=new int[100001];\\n        fre=new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        fre[arr[number]]--;\\n        arr[number]++;\\n        fre[arr[number]]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(arr[number]>0){\\n        fre[arr[number]]--;\\n        arr[number]--;\\n        fre[arr[number]]++;\\n        }\\n       \\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n            if(fre[frequency]>0){\\n                return true;\\n            }\\n        \\n        return false;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502344,
                "title": "double-solution-array-mapping-dictionary-approach",
                "content": "# Approach\\n- *map array*: The indices are the numbers while the values are the relative frequencies. The frequency values act as mapping values to the indices of the freq array\\n-  *freq array*: the indices are the values of the frequencies, while the values are zero or one, to indicate that there is a number with that frequency\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(10^5)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n## Solution 1\\n```\\npublic class FrequencyTracker {\\n\\n    private int[] map = new int[100_001];\\n    private int[] freq = new int[100_001];\\n\\n    public void Add(int number) {\\n        freq[map[number]++]--;\\n        freq[map[number]]++;\\n    }\\n\\n    public void DeleteOne(int number) {\\n        if (map[number] > 0) {\\n            freq[map[number]--]--;\\n            freq[map[number]]++;\\n        }\\n    }\\n\\n    public bool HasFrequency(int frequency) => freq[frequency] > 0;\\n}\\n```\\n## Solution 2\\n```\\nusing System.Collections.Generic;\\n\\npublic class FrequencyTracker {\\n\\n    private Dictionary<int, int> frequencies = new();\\n    \\n    public void Add(int number) \\n    {\\n        frequencies.TryGetValue(number, out int frequency);\\n        frequencies[number] = frequency + 1;\\n    }\\n    \\n    public void DeleteOne(int number) \\n    {\\n        frequencies.TryGetValue(number, out int frequency);\\n        frequencies[number] = Math.Max(0, frequency - 1);\\n    }\\n    \\n    public bool HasFrequency(int frequency) => frequencies.ContainsValue(frequency);\\n}\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class FrequencyTracker {\\n\\n    private int[] map = new int[100_001];\\n    private int[] freq = new int[100_001];\\n\\n    public void Add(int number) {\\n        freq[map[number]++]--;\\n        freq[map[number]]++;\\n    }\\n\\n    public void DeleteOne(int number) {\\n        if (map[number] > 0) {\\n            freq[map[number]--]--;\\n            freq[map[number]]++;\\n        }\\n    }\\n\\n    public bool HasFrequency(int frequency) => freq[frequency] > 0;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501866,
                "title": "o-1-solution-tle-ac-map-design-pls-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhow to increase and decrease count of any no and how the count of that count will be affected that we need to figure out other wise it will give tle if we use only one map\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe constructor initializes the two unordered maps. The add function is used to add a new number to the tracker. If the number already exists in the tracker, the count of its frequency is updated in the mp map, and the count of numbers whose frequency is the same is updated in the mps map. If the number is new, it is added to the mp map with a frequency count of 1, and the count of numbers whose frequency is 1 is updated in the mps map.\\n\\nThe deleteOne function is used to remove a number from the tracker. If the number exists in the tracker, its frequency count is updated in the mp map and the count of numbers whose frequency is the same is updated in the mps map. If the frequency count of the number becomes zero, it is removed from the mp map.\\n\\nFinally, the hasFrequency function returns true if there is at least one number in the tracker with the given frequency count, and false otherwise.\\n\\nThis class can be used to efficiently keep track of the frequency count of a set of integers and quickly answer queries about the frequency of specific numbers.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(1) \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n) \\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int, int> mp;   \\n    unordered_map<int, int> mps; \\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(mp.find(number) != mp.end()){\\n            mps[mp[number]]--;\\n        }\\n        mp[number]++;\\n        mps[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number) != mp.end() && mp[number] > 0){\\n            mps[mp[number]]--;\\n            mp[number]--;\\n            mps[mp[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return (mps[frequency] > 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int, int> mp;   \\n    unordered_map<int, int> mps; \\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(mp.find(number) != mp.end()){\\n            mps[mp[number]]--;\\n        }\\n        mp[number]++;\\n        mps[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number) != mp.end() && mp[number] > 0){\\n            mps[mp[number]]--;\\n            mp[number]--;\\n            mps[mp[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return (mps[frequency] > 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501434,
                "title": "c-map",
                "content": "# Code\\n```\\n//---------------------------------------\\n// Solution 1\\n//---------------------------------------\\nclass FrequencyTracker {\\n    unordered_map<int, int> numToFreq;\\n    unordered_map<int, unordered_set<int>> freqToNumList;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        freqToNumList[numToFreq[number]].erase(number);\\n        numToFreq[number]++;\\n        freqToNumList[numToFreq[number]].insert(number);\\n    }\\n    \\n    void deleteOne(int number) {\\n        freqToNumList[numToFreq[number]].erase(number);\\n        if(numToFreq[number] > 0) {\\n            numToFreq[number]--;\\n            freqToNumList[numToFreq[number]].insert(number);\\n        } \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freqToNumList[frequency].size() > 0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n\\n\\n//---------------------------------------\\n// Solution 2\\n//---------------------------------------\\nclass FrequencyTracker {\\n    unordered_map<int, int> count;\\n    unordered_map<int, int> freq;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        freq[count[number]]--;\\n        count[number]++;\\n        freq[count[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(count[number] > 0) {\\n            freq[count[number]]--;\\n            count[number]--;\\n            freq[count[number]]++;\\n        } \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency];\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\n//---------------------------------------\\n// Solution 1\\n//---------------------------------------\\nclass FrequencyTracker {\\n    unordered_map<int, int> numToFreq;\\n    unordered_map<int, unordered_set<int>> freqToNumList;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        freqToNumList[numToFreq[number]].erase(number);\\n        numToFreq[number]++;\\n        freqToNumList[numToFreq[number]].insert(number);\\n    }\\n    \\n    void deleteOne(int number) {\\n        freqToNumList[numToFreq[number]].erase(number);\\n        if(numToFreq[number] > 0) {\\n            numToFreq[number]--;\\n            freqToNumList[numToFreq[number]].insert(number);\\n        } \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freqToNumList[frequency].size() > 0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n\\n\\n//---------------------------------------\\n// Solution 2\\n//---------------------------------------\\nclass FrequencyTracker {\\n    unordered_map<int, int> count;\\n    unordered_map<int, int> freq;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        freq[count[number]]--;\\n        count[number]++;\\n        freq[count[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(count[number] > 0) {\\n            freq[count[number]]--;\\n            count[number]--;\\n            freq[count[number]]++;\\n        } \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency];\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501304,
                "title": "typescript-solution",
                "content": "# Code\\n```\\nclass FrequencyTracker {\\n  numberFrequency: Map<number, number>;\\n  frequencyCount: Map<number, number>;\\n\\n  constructor() {\\n    this.numberFrequency = new Map();\\n    this.frequencyCount = new Map();\\n  }\\n\\n  getNumberFrequency(number: number): number {\\n    return this.numberFrequency.get(number) || 0;\\n  }\\n\\n  getFrequencyCount(frequency: number): number {\\n    return this.frequencyCount.get(frequency) || 0;\\n  }\\n\\n  add(number: number): void {\\n    const prevFreq = this.getNumberFrequency(number);\\n    const newFreq = prevFreq + 1;\\n\\n    this.numberFrequency.set(number, newFreq);\\n    this.frequencyCount.set(prevFreq, this.getFrequencyCount(prevFreq) - 1);\\n    this.frequencyCount.set(newFreq, this.getFrequencyCount(newFreq) + 1);\\n  }\\n\\n  deleteOne(number: number): void {\\n    const prevFreq = this.getNumberFrequency(number);\\n    if (!prevFreq) return;\\n\\n    const newFreq = prevFreq - 1;\\n    this.numberFrequency.set(number, newFreq);\\n    this.frequencyCount.set(prevFreq, this.getFrequencyCount(prevFreq) - 1);\\n    this.frequencyCount.set(newFreq, this.getFrequencyCount(newFreq) + 1);\\n  }\\n\\n  hasFrequency(frequency: number): boolean {\\n    return !!this.getFrequencyCount(frequency);\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass FrequencyTracker {\\n  numberFrequency: Map<number, number>;\\n  frequencyCount: Map<number, number>;\\n\\n  constructor() {\\n    this.numberFrequency = new Map();\\n    this.frequencyCount = new Map();\\n  }\\n\\n  getNumberFrequency(number: number): number {\\n    return this.numberFrequency.get(number) || 0;\\n  }\\n\\n  getFrequencyCount(frequency: number): number {\\n    return this.frequencyCount.get(frequency) || 0;\\n  }\\n\\n  add(number: number): void {\\n    const prevFreq = this.getNumberFrequency(number);\\n    const newFreq = prevFreq + 1;\\n\\n    this.numberFrequency.set(number, newFreq);\\n    this.frequencyCount.set(prevFreq, this.getFrequencyCount(prevFreq) - 1);\\n    this.frequencyCount.set(newFreq, this.getFrequencyCount(newFreq) + 1);\\n  }\\n\\n  deleteOne(number: number): void {\\n    const prevFreq = this.getNumberFrequency(number);\\n    if (!prevFreq) return;\\n\\n    const newFreq = prevFreq - 1;\\n    this.numberFrequency.set(number, newFreq);\\n    this.frequencyCount.set(prevFreq, this.getFrequencyCount(prevFreq) - 1);\\n    this.frequencyCount.set(newFreq, this.getFrequencyCount(newFreq) + 1);\\n  }\\n\\n  hasFrequency(frequency: number): boolean {\\n    return !!this.getFrequencyCount(frequency);\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500855,
                "title": "ruby-solution-100-100",
                "content": "# Intuition\\nKeep track of the count of each number in one hash and the count of each array in another.  Using two hashes keeps everything $$O(1)$$.\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(n)$$, where *n* is the number of distinct values.\\n\\n# Code\\n```\\nclass FrequencyTracker\\n    def initialize()\\n        @eles = Hash.new(0)\\n        @freq = Hash.new(0)\\n    end\\n\\n\\n=begin\\n    :type number: Integer\\n    :rtype: Void\\n=end\\n    def add(number)\\n        @freq[@eles[number]] -= 1 if @freq[@eles[number]] > 0\\n        @eles[number] += 1\\n        @freq[@eles[number]] += 1\\n    end\\n\\n\\n=begin\\n    :type number: Integer\\n    :rtype: Void\\n=end\\n    def delete_one(number)\\n        @freq[@eles[number]] -= 1 if @eles[number] > 0\\n        @eles[number] -= 1 if @eles[number] > 0\\n        @freq[@eles[number]] += 1 if @eles[number] > 0\\n    end\\n\\n\\n=begin\\n    :type frequency: Integer\\n    :rtype: Boolean\\n=end\\n    def has_frequency(frequency)\\n        @freq[frequency] > 0\\n    end\\n\\n\\nend\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker.new()\\n# obj.add(number)\\n# obj.delete_one(number)\\n# param_3 = obj.has_frequency(frequency)\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\nclass FrequencyTracker\\n    def initialize()\\n        @eles = Hash.new(0)\\n        @freq = Hash.new(0)\\n    end\\n\\n\\n=begin\\n    :type number: Integer\\n    :rtype: Void\\n=end\\n    def add(number)\\n        @freq[@eles[number]] -= 1 if @freq[@eles[number]] > 0\\n        @eles[number] += 1\\n        @freq[@eles[number]] += 1\\n    end\\n\\n\\n=begin\\n    :type number: Integer\\n    :rtype: Void\\n=end\\n    def delete_one(number)\\n        @freq[@eles[number]] -= 1 if @eles[number] > 0\\n        @eles[number] -= 1 if @eles[number] > 0\\n        @freq[@eles[number]] += 1 if @eles[number] > 0\\n    end\\n\\n\\n=begin\\n    :type frequency: Integer\\n    :rtype: Boolean\\n=end\\n    def has_frequency(frequency)\\n        @freq[frequency] > 0\\n    end\\n\\n\\nend\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker.new()\\n# obj.add(number)\\n# obj.delete_one(number)\\n# param_3 = obj.has_frequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500448,
                "title": "beats-100-using-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n  constructor() {\\n    this.numbers = new Map();\\n    this.frequencies = new Map();\\n  }\\n\\n  add(number) {\\n    const count = this.numbers.get(number) || 0;\\n    this.numbers.set(number, count + 1);\\n\\n    const freq = this.frequencies.get(count) || new Set();\\n    freq.delete(number); // remove from the previous frequency set\\n    this.frequencies.set(count, freq);\\n\\n    const newFreq = this.frequencies.get(count + 1) || new Set();\\n    newFreq.add(number);\\n    this.frequencies.set(count + 1, newFreq);\\n  }\\n\\n  deleteOne(number) {\\n    const count = this.numbers.get(number) || 0;\\n    if (count > 0) {\\n      this.numbers.set(number, count - 1);\\n\\n      const freq = this.frequencies.get(count) || new Set();\\n      freq.delete(number); // remove from the current frequency set\\n      this.frequencies.set(count, freq);\\n\\n      const newFreq = this.frequencies.get(count - 1) || new Set();\\n      newFreq.add(number);\\n      this.frequencies.set(count - 1, newFreq);\\n    }\\n  }\\n\\n  hasFrequency(frequency) {\\n    return this.frequencies.has(frequency) && this.frequencies.get(frequency).size > 0;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass FrequencyTracker {\\n  constructor() {\\n    this.numbers = new Map();\\n    this.frequencies = new Map();\\n  }\\n\\n  add(number) {\\n    const count = this.numbers.get(number) || 0;\\n    this.numbers.set(number, count + 1);\\n\\n    const freq = this.frequencies.get(count) || new Set();\\n    freq.delete(number); // remove from the previous frequency set\\n    this.frequencies.set(count, freq);\\n\\n    const newFreq = this.frequencies.get(count + 1) || new Set();\\n    newFreq.add(number);\\n    this.frequencies.set(count + 1, newFreq);\\n  }\\n\\n  deleteOne(number) {\\n    const count = this.numbers.get(number) || 0;\\n    if (count > 0) {\\n      this.numbers.set(number, count - 1);\\n\\n      const freq = this.frequencies.get(count) || new Set();\\n      freq.delete(number); // remove from the current frequency set\\n      this.frequencies.set(count, freq);\\n\\n      const newFreq = this.frequencies.get(count - 1) || new Set();\\n      newFreq.add(number);\\n      this.frequencies.set(count - 1, newFreq);\\n    }\\n  }\\n\\n  hasFrequency(frequency) {\\n    return this.frequencies.has(frequency) && this.frequencies.get(frequency).size > 0;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499771,
                "title": "python-solution-normal-dictionary",
                "content": "# Complexity\\n- Time complexity:O(1) \\n                 all functions take O(1) time complexity on average\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.count = dict() # to store the frequency of number\\n        self.frequency = dict()#to store the count of how many keys in the above dict have the same value\\n                               #and store that value\\n\\n    def add(self, number: int) -> None:\\n        occurs = self.count.get(number, 0)#check if number is already present in count\\n        self.count[number] = occurs + 1\\n        if occurs > 0:\\n            self.frequency[occurs] -= 1\\n            self.frequency[self.count[number]] = 1 + self.frequency.get(self.count[number], 0)\\n        else:\\n            self.frequency[self.count[number]] = 1 + self.frequency.get(self.count[number], 0)\\n\\n    def deleteOne(self, number: int) -> None:\\n        occurs = self.count.get(number, 0)#check if number is already present\\n        if occurs > 0:\\n            self.frequency[occurs] -= 1 \\n            self.count[number] -= 1\\n            self.frequency[self.count[number]] =  1 + self.frequency.get(self.count[number], 0)\\n\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        freq = self.frequency.get(frequency, 0) #get frequency from \\n        return freq>0\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.count = dict() # to store the frequency of number\\n        self.frequency = dict()#to store the count of how many keys in the above dict have the same value\\n                               #and store that value\\n\\n    def add(self, number: int) -> None:\\n        occurs = self.count.get(number, 0)#check if number is already present in count\\n        self.count[number] = occurs + 1\\n        if occurs > 0:\\n            self.frequency[occurs] -= 1\\n            self.frequency[self.count[number]] = 1 + self.frequency.get(self.count[number], 0)\\n        else:\\n            self.frequency[self.count[number]] = 1 + self.frequency.get(self.count[number], 0)\\n\\n    def deleteOne(self, number: int) -> None:\\n        occurs = self.count.get(number, 0)#check if number is already present\\n        if occurs > 0:\\n            self.frequency[occurs] -= 1 \\n            self.count[number] -= 1\\n            self.frequency[self.count[number]] =  1 + self.frequency.get(self.count[number], 0)\\n\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        freq = self.frequency.get(frequency, 0) #get frequency from \\n        return freq>0\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499757,
                "title": "a-python-solution-using-two-maps-beats-100",
                "content": "# Code\\n```\\nclass FrequencyTracker:\\n    def __init__(self):\\n        self.numFreq = defaultdict(int)\\n        self.freq = defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        self.updateFreq(number, 1)\\n        \\n    def deleteOne(self, number: int) -> None:\\n        if self.numFreq[number] <= 0:\\n            return\\n\\n        self.updateFreq(number, -1)\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n\\n    def updateFreq(self, number, amount):\\n        self.freq[self.numFreq[number]] -= 1\\n        self.numFreq[number] += amount\\n        self.freq[self.numFreq[number]] += 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker:\\n    def __init__(self):\\n        self.numFreq = defaultdict(int)\\n        self.freq = defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        self.updateFreq(number, 1)\\n        \\n    def deleteOne(self, number: int) -> None:\\n        if self.numFreq[number] <= 0:\\n            return\\n\\n        self.updateFreq(number, -1)\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n\\n    def updateFreq(self, number, amount):\\n        self.freq[self.numFreq[number]] -= 1\\n        self.numFreq[number] += amount\\n        self.freq[self.numFreq[number]] += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499713,
                "title": "easy-with-two-dictionry-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n`Design a data structure that keeps track of the values in it and answers some queries regarding their frequencies. Implement the FrequencyTracker class.`\\n\\nThe very first thing that comes to mind is to create a simple dictionary: `key - number: value - number frequency`.\\n\\nHowever, because of the method `hasFrequency` we will get **TLE**. I think you\\'ve probably already tried it)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn order to perform the method effectively `hasFrequency` we need another dictionary: `key - frequency: value - the number of numbers with this frequency`. It remains only to synchronize the work of these dictionaries together.\\n\\n- we add a new number:\\n`numbers = {newNumber: 1}` and `frequency = {1: count + 1}`\\n- we are changing an existing number:\\nIf we increase the number: \\n`numbers = {number : i + 1}`\\n`frequency = {i: count - 1, i + 1: count + 1}`\\nIf we reduce the number\\n`numbers = {number : i - 1}`\\n`frequency = {i: count - 1, i - 1: count + 1}`\\n\\nLet\\'s create two methods for working with the dictionary `frequency`:\\n```\\ndef addFrequency(self, frequency: int) -> None:\\n    if frequency in self.frequency:\\n        self.frequency[frequency] += 1\\n    else:\\n        self.frequency[frequency] = 1\\n    \\ndef deleteFrequency(self, frequency: int) -> None:\\n    if frequency in self.frequency:\\n        self.frequency[frequency] -= 1\\n```\\nAnd now when we change the frequency of the number, we do it as follows:\\n`self.deleteFrequency(self.numbers[number])` - reducing the number of numbers with the previous frequency\\n`self.numbers[number] +-= 1` increase or decrease\\n`self.addFrequency(self.numbers[number])` - increasing the number of numbers with a new frequency.\\n\\n\\n\\n# Code\\n```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.numbers = dict()\\n        self.frequency = dict()\\n\\n    def add(self, number: int) -> None:\\n        if number in self.numbers:\\n            self.deleteFrequency(self.numbers[number])\\n            self.numbers[number] += 1\\n        else:\\n            self.numbers[number] = 1\\n        self.addFrequency(self.numbers[number])\\n\\n    def deleteOne(self, number: int) -> None:\\n        if number in self.numbers and self.numbers[number] > 0:\\n            self.deleteFrequency(self.numbers[number])\\n            self.numbers[number] -= 1\\n            self.addFrequency(self.numbers[number])\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return frequency in self.frequency and self.frequency[frequency] > 0\\n    \\n    def addFrequency(self, frequency: int) -> None:\\n        if frequency in self.frequency:\\n            self.frequency[frequency] += 1\\n        else:\\n            self.frequency[frequency] = 1\\n    \\n    def deleteFrequency(self, frequency: int) -> None:\\n        if frequency in self.frequency:\\n            self.frequency[frequency] -= 1\\n        \\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef addFrequency(self, frequency: int) -> None:\\n    if frequency in self.frequency:\\n        self.frequency[frequency] += 1\\n    else:\\n        self.frequency[frequency] = 1\\n    \\ndef deleteFrequency(self, frequency: int) -> None:\\n    if frequency in self.frequency:\\n        self.frequency[frequency] -= 1\\n```\n```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.numbers = dict()\\n        self.frequency = dict()\\n\\n    def add(self, number: int) -> None:\\n        if number in self.numbers:\\n            self.deleteFrequency(self.numbers[number])\\n            self.numbers[number] += 1\\n        else:\\n            self.numbers[number] = 1\\n        self.addFrequency(self.numbers[number])\\n\\n    def deleteOne(self, number: int) -> None:\\n        if number in self.numbers and self.numbers[number] > 0:\\n            self.deleteFrequency(self.numbers[number])\\n            self.numbers[number] -= 1\\n            self.addFrequency(self.numbers[number])\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return frequency in self.frequency and self.frequency[frequency] > 0\\n    \\n    def addFrequency(self, frequency: int) -> None:\\n        if frequency in self.frequency:\\n            self.frequency[frequency] += 1\\n        else:\\n            self.frequency[frequency] = 1\\n    \\n    def deleteFrequency(self, frequency: int) -> None:\\n        if frequency in self.frequency:\\n            self.frequency[frequency] -= 1\\n        \\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499258,
                "title": "c-try-to-fullfil-reqs-of-hasfreq-func-in-o-1-not-in-o-n-this-is-motivation-for-using-unord-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(10^5)..Ofcourse in Worst Case!\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(10^5)..Ofcourse in Worst Case!\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> hashf,hashad;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int num) {\\n        if(hashad.count(num)) if(--hashf[hashad[num]]==0) hashf.erase(hashad[num]);\\n        hashad[num]++,hashf[hashad[num]]++;\\n    }\\n    \\n    void deleteOne(int num) {\\n        if(hashad.count(num)){\\n            if(--hashf[hashad[num]]==0) hashf.erase(hashad[num]);\\n            if(--hashad[num]==0) hashad.erase(num);\\n            else hashf[hashad[num]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int freq) {\\n        return hashf.count(freq);\\n    }  \\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> hashf,hashad;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int num) {\\n        if(hashad.count(num)) if(--hashf[hashad[num]]==0) hashf.erase(hashad[num]);\\n        hashad[num]++,hashf[hashad[num]]++;\\n    }\\n    \\n    void deleteOne(int num) {\\n        if(hashad.count(num)){\\n            if(--hashf[hashad[num]]==0) hashf.erase(hashad[num]);\\n            if(--hashad[num]==0) hashad.erase(num);\\n            else hashf[hashad[num]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int freq) {\\n        return hashf.count(freq);\\n    }  \\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499210,
                "title": "python-freq-nums-and-num-freq-dicts",
                "content": "This is 1000%%% not easy to code without numerous errors.\\n```\\nclass FrequencyTracker:\\n    def __init__(self):\\n        self.num_freq = {}\\n        self.freq_nums = {}\\n\\n    def add(self, num: int) -> None:\\n        self._change_num_freq(num, +1)\\n\\n    def deleteOne(self, num: int) -> None:\\n        self._change_num_freq(num, -1)\\n\\n    def _change_num_freq(self, num, delta):\\n        current_freq = self.num_freq.get(num, 0)\\n        if current_freq:\\n            # cleanup freq_nums\\n            self.freq_nums[current_freq].discard(num)\\n            if len(self.freq_nums[current_freq]) == 0:\\n                del self.freq_nums[current_freq]\\n\\n        new_freq = current_freq + delta\\n        if new_freq <= 0:\\n            self.num_freq.pop(num, None)\\n            return\\n\\n        # move num to different frequency\\n        self.num_freq[num] = new_freq\\n        if new_freq not in self.freq_nums:\\n            self.freq_nums[new_freq] = set([num])\\n        else:\\n            self.freq_nums[new_freq].add(num)\\n\\n    def hasFrequency(self, freq: int) -> bool:\\n        return freq in self.freq_nums\\n```\\n\\nSimplified version:\\n```\\nclass FrequencyTracker:\\n    def __init__(self):\\n        self.freq_count = defaultdict(int)\\n        self.num_freq = defaultdict(int)\\n\\n    def add(self, num: int) -> None:\\n        if self.freq_count[self.num_freq[num]] > 0:\\n            self.freq_count[self.num_freq[num]] -= 1\\n        self.num_freq[num] += 1\\n        self.freq_count[self.num_freq[num]] += 1\\n\\n    def deleteOne(self, num: int) -> None:\\n        if self.num_freq[num] > 0:\\n            self.freq_count[self.num_freq[num]] -= 1\\n            self.num_freq[num] -= 1\\n            self.freq_count[self.num_freq[num]] += 1\\n\\n    def hasFrequency(self, freq: int) -> bool:\\n        return self.freq_count[freq] > 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass FrequencyTracker:\\n    def __init__(self):\\n        self.num_freq = {}\\n        self.freq_nums = {}\\n\\n    def add(self, num: int) -> None:\\n        self._change_num_freq(num, +1)\\n\\n    def deleteOne(self, num: int) -> None:\\n        self._change_num_freq(num, -1)\\n\\n    def _change_num_freq(self, num, delta):\\n        current_freq = self.num_freq.get(num, 0)\\n        if current_freq:\\n            # cleanup freq_nums\\n            self.freq_nums[current_freq].discard(num)\\n            if len(self.freq_nums[current_freq]) == 0:\\n                del self.freq_nums[current_freq]\\n\\n        new_freq = current_freq + delta\\n        if new_freq <= 0:\\n            self.num_freq.pop(num, None)\\n            return\\n\\n        # move num to different frequency\\n        self.num_freq[num] = new_freq\\n        if new_freq not in self.freq_nums:\\n            self.freq_nums[new_freq] = set([num])\\n        else:\\n            self.freq_nums[new_freq].add(num)\\n\\n    def hasFrequency(self, freq: int) -> bool:\\n        return freq in self.freq_nums\\n```\n```\\nclass FrequencyTracker:\\n    def __init__(self):\\n        self.freq_count = defaultdict(int)\\n        self.num_freq = defaultdict(int)\\n\\n    def add(self, num: int) -> None:\\n        if self.freq_count[self.num_freq[num]] > 0:\\n            self.freq_count[self.num_freq[num]] -= 1\\n        self.num_freq[num] += 1\\n        self.freq_count[self.num_freq[num]] += 1\\n\\n    def deleteOne(self, num: int) -> None:\\n        if self.num_freq[num] > 0:\\n            self.freq_count[self.num_freq[num]] -= 1\\n            self.num_freq[num] -= 1\\n            self.freq_count[self.num_freq[num]] += 1\\n\\n    def hasFrequency(self, freq: int) -> bool:\\n        return self.freq_count[freq] > 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499157,
                "title": "python-solution-using-defaultdict-beats-100",
                "content": "\\n# Code\\n```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.count = defaultdict(int)\\n        self.freq = defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        if self.freq[self.count[number]] : self.freq[self.count[number]] -= 1\\n        self.count[number] += 1\\n        self.freq[self.count[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        if self.count[number] : \\n            self.freq[self.count[number]] -= 1\\n            self.count[number] -= 1  \\n            self.freq[self.count[number]] += 1\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency]\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.count = defaultdict(int)\\n        self.freq = defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        if self.freq[self.count[number]] : self.freq[self.count[number]] -= 1\\n        self.count[number] += 1\\n        self.freq[self.count[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        if self.count[number] : \\n            self.freq[self.count[number]] -= 1\\n            self.count[number] -= 1  \\n            self.freq[self.count[number]] += 1\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency]\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499048,
                "title": "two-dict-and-two-list-implementations-python",
                "content": "Try to read the code as plain English for the details/logic and improve.\\n\\n```\\nclass FrequencyTracker:\\n    \\n    \"\"\"\\n    Two Dicts Implementation\\n    Faster than Two Lists Implementation\\n    \"\"\"\\n\\n    def __init__(self):\\n        self.data = {}\\n        self.freqs = {}\\n        \\n    def add(self, number: int) -> None:\\n        self.data[number] = self.data.get(number, 0) + 1\\n        cur_f = self.data[number]\\n        prev_f = cur_f - 1\\n        self.freqs[cur_f] = self.freqs.get(cur_f, 0) + 1\\n        if prev_f > 0:\\n            self.freqs[prev_f] -= 1\\n            if self.freqs[prev_f] == 0:\\n                del self.freqs[prev_f]\\n        \\n    \\n    def deleteOne(self, number: int) -> None:\\n        if number in self.data:\\n            cur_f = self.data[number]\\n            self.data[number] -= 1\\n            if self.data[number] == 0:\\n                del self.data[number]\\n            self.freqs[cur_f] -= 1\\n            if self.freqs[cur_f] == 0:\\n                del self.freqs[cur_f]\\n            new_f = cur_f - 1\\n            if new_f > 0:\\n                self.freqs[new_f] = self.freqs.get(new_f, 0) + 1\\n            \\n        \\n        \\n    def hasFrequency(self, frequency: int) -> bool:\\n        return frequency in self.freqs\\n    \\n    \\n    \\nclass FrequencyTracker:\\n    \\n    \"\"\"\\n    Two Lists Implementation\\n    Easy in Logic and Implementation, but slower than two dicts implementation\\n    \"\"\"\\n\\n    def __init__(self):\\n        self.array = [0] * (10 ** 5 + 1) # number(a.k.a index) - freq\\n        self.freq = [0] * (10 ** 5 + 1) # freq(a.k.a index) - freq\\'s freq\\n        \\n        \\n    def add(self, number: int) -> None:\\n        self.array[number] += 1\\n        new_f = self.array[number]\\n        self.freq[new_f] += 1\\n        prev_f = new_f - 1\\n        if prev_f > 0:\\n            self.freq[prev_f] -= 1\\n        \\n        \\n    \\n    def deleteOne(self, number: int) -> None:\\n        org_f = self.array[number]\\n        if org_f != 0:\\n            self.array[number] -= 1\\n            self.freq[org_f] -= 1\\n            if org_f - 1 > 0:\\n                self.freq[org_f - 1] += 1\\n        \\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass FrequencyTracker:\\n    \\n    \"\"\"\\n    Two Dicts Implementation\\n    Faster than Two Lists Implementation\\n    \"\"\"\\n\\n    def __init__(self):\\n        self.data = {}\\n        self.freqs = {}\\n        \\n    def add(self, number: int) -> None:\\n        self.data[number] = self.data.get(number, 0) + 1\\n        cur_f = self.data[number]\\n        prev_f = cur_f - 1\\n        self.freqs[cur_f] = self.freqs.get(cur_f, 0) + 1\\n        if prev_f > 0:\\n            self.freqs[prev_f] -= 1\\n            if self.freqs[prev_f] == 0:\\n                del self.freqs[prev_f]\\n        \\n    \\n    def deleteOne(self, number: int) -> None:\\n        if number in self.data:\\n            cur_f = self.data[number]\\n            self.data[number] -= 1\\n            if self.data[number] == 0:\\n                del self.data[number]\\n            self.freqs[cur_f] -= 1\\n            if self.freqs[cur_f] == 0:\\n                del self.freqs[cur_f]\\n            new_f = cur_f - 1\\n            if new_f > 0:\\n                self.freqs[new_f] = self.freqs.get(new_f, 0) + 1\\n            \\n        \\n        \\n    def hasFrequency(self, frequency: int) -> bool:\\n        return frequency in self.freqs\\n    \\n    \\n    \\nclass FrequencyTracker:\\n    \\n    \"\"\"\\n    Two Lists Implementation\\n    Easy in Logic and Implementation, but slower than two dicts implementation\\n    \"\"\"\\n\\n    def __init__(self):\\n        self.array = [0] * (10 ** 5 + 1) # number(a.k.a index) - freq\\n        self.freq = [0] * (10 ** 5 + 1) # freq(a.k.a index) - freq\\'s freq\\n        \\n        \\n    def add(self, number: int) -> None:\\n        self.array[number] += 1\\n        new_f = self.array[number]\\n        self.freq[new_f] += 1\\n        prev_f = new_f - 1\\n        if prev_f > 0:\\n            self.freq[prev_f] -= 1\\n        \\n        \\n    \\n    def deleteOne(self, number: int) -> None:\\n        org_f = self.array[number]\\n        if org_f != 0:\\n            self.array[number] -= 1\\n            self.freq[org_f] -= 1\\n            if org_f - 1 > 0:\\n                self.freq[org_f - 1] += 1\\n        \\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498955,
                "title": "2-map-solution-c",
                "content": "\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    map<int,int> freq;\\n    map<int,int> isthere;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if (freq.find(number)==freq.end())\\n        {\\n            freq[number]++;\\n            isthere[freq[number]]++;\\n        }\\n        else\\n        {\\n            isthere[freq[number]]--;\\n            freq[number]++;\\n            isthere[freq[number]]++;\\n        }\\n    }\\n    \\n    void deleteOne(int number) {\\n        if (freq.find(number)!=freq.end())\\n        {\\n            isthere[freq[number]]--;\\n            freq[number]--;\\n            if (freq[number]>0)\\n            isthere[freq[number]]++;\\n            if (freq[number]==0)\\n                freq.erase(number);\\n        }\\n        \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return isthere[frequency]>0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    map<int,int> freq;\\n    map<int,int> isthere;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if (freq.find(number)==freq.end())\\n        {\\n            freq[number]++;\\n            isthere[freq[number]]++;\\n        }\\n        else\\n        {\\n            isthere[freq[number]]--;\\n            freq[number]++;\\n            isthere[freq[number]]++;\\n        }\\n    }\\n    \\n    void deleteOne(int number) {\\n        if (freq.find(number)!=freq.end())\\n        {\\n            isthere[freq[number]]--;\\n            freq[number]--;\\n            if (freq[number]>0)\\n            isthere[freq[number]]++;\\n            if (freq[number]==0)\\n                freq.erase(number);\\n        }\\n        \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return isthere[frequency]>0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498695,
                "title": "python3-o-n-2-defaultdict-to-manage-count-and-frequency",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.cnt, self.fre = defaultdict(int), defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        if self.cnt[number]: self.fre[self.cnt[number]] -= 1\\n        self.cnt[number] += 1\\n        self.fre[self.cnt[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        if not self.cnt[number]: return\\n        self.fre[self.cnt[number]] -= 1\\n        self.cnt[number] -= 1\\n        if self.cnt[number]: self.fre[self.cnt[number]] += 1\\n        \\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.fre[frequency]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.cnt, self.fre = defaultdict(int), defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        if self.cnt[number]: self.fre[self.cnt[number]] -= 1\\n        self.cnt[number] += 1\\n        self.fre[self.cnt[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        if not self.cnt[number]: return\\n        self.fre[self.cnt[number]] -= 1\\n        self.cnt[number] -= 1\\n        if self.cnt[number]: self.fre[self.cnt[number]] += 1\\n        \\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.fre[frequency]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498530,
                "title": "java-two-map-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) n is the distinct number of total calls.\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    Map<Integer, Integer> numsMap;\\n    Map<Integer, Integer> freqMap;\\n    public FrequencyTracker() {\\n        numsMap = new HashMap<>();\\n        freqMap = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        numsMap.put(number, numsMap.getOrDefault(number, 0) + 1);\\n        int newCount = numsMap.get(number);\\n        freqMap.put(newCount, freqMap.getOrDefault(newCount, 0) + 1);\\n        if(newCount > 1){\\n            freqMap.put(newCount - 1, freqMap.get(newCount - 1) - 1);\\n        }\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(!numsMap.containsKey(number) || numsMap.get(number) == 0) return;\\n        numsMap.put(number, numsMap.get(number) - 1);\\n        int newCount = numsMap.get(number);\\n        if(newCount > 0){\\n            freqMap.put(newCount, freqMap.getOrDefault(newCount, 0) + 1);\\n        }\\n        freqMap.put(newCount + 1, freqMap.get(newCount + 1) - 1);\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(!freqMap.containsKey(frequency))\\n            return false;\\n        return freqMap.get(frequency) > 0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    Map<Integer, Integer> numsMap;\\n    Map<Integer, Integer> freqMap;\\n    public FrequencyTracker() {\\n        numsMap = new HashMap<>();\\n        freqMap = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        numsMap.put(number, numsMap.getOrDefault(number, 0) + 1);\\n        int newCount = numsMap.get(number);\\n        freqMap.put(newCount, freqMap.getOrDefault(newCount, 0) + 1);\\n        if(newCount > 1){\\n            freqMap.put(newCount - 1, freqMap.get(newCount - 1) - 1);\\n        }\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(!numsMap.containsKey(number) || numsMap.get(number) == 0) return;\\n        numsMap.put(number, numsMap.get(number) - 1);\\n        int newCount = numsMap.get(number);\\n        if(newCount > 0){\\n            freqMap.put(newCount, freqMap.getOrDefault(newCount, 0) + 1);\\n        }\\n        freqMap.put(newCount + 1, freqMap.get(newCount + 1) - 1);\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(!freqMap.containsKey(frequency))\\n            return false;\\n        return freqMap.get(frequency) > 0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498421,
                "title": "python-beat-100",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n**O(1)**\\n\\n- Space complexity:\\n**O(n)**\\n\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.n2f = dict()\\n        self.f2n = defaultdict(set)\\n\\n    def add(self, number: int) -> None:\\n        self.n2f[number] = self.n2f.get(number, 0) + 1\\n        freq = self.n2f[number]\\n        if freq == 1:\\n            self.f2n[freq].add(number)\\n        else:\\n            self.f2n[freq-1].remove(number)\\n            self.f2n[freq].add(number)\\n\\n    def deleteOne(self, number: int) -> None:\\n        if number in self.n2f:\\n            self.n2f[number] -= 1\\n            freq = self.n2f[number]\\n            self.f2n[freq+1].remove(number)\\n            if freq > 0:\\n                self.f2n[freq].add(number)\\n            elif freq == 0:\\n                del self.n2f[number]\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        if len(self.f2n[frequency]) > 0:\\n            return True\\n        return False\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.n2f = dict()\\n        self.f2n = defaultdict(set)\\n\\n    def add(self, number: int) -> None:\\n        self.n2f[number] = self.n2f.get(number, 0) + 1\\n        freq = self.n2f[number]\\n        if freq == 1:\\n            self.f2n[freq].add(number)\\n        else:\\n            self.f2n[freq-1].remove(number)\\n            self.f2n[freq].add(number)\\n\\n    def deleteOne(self, number: int) -> None:\\n        if number in self.n2f:\\n            self.n2f[number] -= 1\\n            freq = self.n2f[number]\\n            self.f2n[freq+1].remove(number)\\n            if freq > 0:\\n                self.f2n[freq].add(number)\\n            elif freq == 0:\\n                del self.n2f[number]\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        if len(self.f2n[frequency]) > 0:\\n            return True\\n        return False\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498383,
                "title": "java-hashmap-easy-to-understand",
                "content": "# Intuition\\n We are dealing with frequencies, so we use hashmap.\\n\\n# Approach\\n`map` - to store number of element.\\nEg. `map[2] -> 3` means number \\'2\\' appears 3 times in the data structure.\\n`freq` - to store frequencies of the frequency.\\nEg. `freq[2] -> 3` means there are 3 numbers which presents 2 times in the data structure.\\n\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n\\n    private Map<Integer,Integer> map;\\n    private Map<Integer,Integer> freq;\\n    public FrequencyTracker() {\\n        map = new HashMap<>();\\n        freq = new HashMap<>();\\n    }\\n\\n    public void add(int number) {\\n        int count = 0;\\n        if(map.containsKey(number)) count = map.get(number);\\n\\n        //we have previous count so decrease it if its not 0\\n        if(count != 0){\\n            if(freq.get(count) == 1) freq.remove(count);\\n            else freq.put(count, freq.get(count) - 1);\\n        }\\n        map.put(number, map.getOrDefault(number, 0) + 1);\\n\\n        if(count == 0){\\n            freq.put(1, freq.getOrDefault(1, 0) + 1);\\n        }else{\\n            //We incremented current number so we take count + 1\\n            freq.put(count + 1, freq.getOrDefault(count + 1, 0) + 1);\\n        }\\n    }\\n\\n    public void deleteOne(int number) {\\n       // if the map doesn\\'t contain the number then just return.\\n       if(!map.containsKey(number)) return;\\n\\n       //if the number present only one time then just remove it.\\n       if(map.get(number) == 1){\\n           map.remove(number);\\n\\n           //update its corresponding freq map.\\n           if(freq.get(1) == 1) freq.remove(1);\\n           else freq.put(1, freq.get(1) - 1);\\n       }else{\\n        //if the number present more than one time then just decrease it count.\\n           int count = map.get(number);\\n        //we remove 1 from current count in the freq.\\n           if(freq.get(count) == 1) freq.remove(count);\\n           else freq.put(count, freq.get(count) - 1);\\n           map.put(number, map.get(number) - 1);\\n\\n           count = map.get(number);\\n        //we add 1 to the decreased count in the freq.\\n           freq.put(count, freq.getOrDefault(count, 0) + 1);\\n       }\\n    }\\n\\n    public boolean hasFrequency(int frequency) {\\n\\n        return freq.containsKey(frequency);\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\n\\n    private Map<Integer,Integer> map;\\n    private Map<Integer,Integer> freq;\\n    public FrequencyTracker() {\\n        map = new HashMap<>();\\n        freq = new HashMap<>();\\n    }\\n\\n    public void add(int number) {\\n        int count = 0;\\n        if(map.containsKey(number)) count = map.get(number);\\n\\n        //we have previous count so decrease it if its not 0\\n        if(count != 0){\\n            if(freq.get(count) == 1) freq.remove(count);\\n            else freq.put(count, freq.get(count) - 1);\\n        }\\n        map.put(number, map.getOrDefault(number, 0) + 1);\\n\\n        if(count == 0){\\n            freq.put(1, freq.getOrDefault(1, 0) + 1);\\n        }else{\\n            //We incremented current number so we take count + 1\\n            freq.put(count + 1, freq.getOrDefault(count + 1, 0) + 1);\\n        }\\n    }\\n\\n    public void deleteOne(int number) {\\n       // if the map doesn\\'t contain the number then just return.\\n       if(!map.containsKey(number)) return;\\n\\n       //if the number present only one time then just remove it.\\n       if(map.get(number) == 1){\\n           map.remove(number);\\n\\n           //update its corresponding freq map.\\n           if(freq.get(1) == 1) freq.remove(1);\\n           else freq.put(1, freq.get(1) - 1);\\n       }else{\\n        //if the number present more than one time then just decrease it count.\\n           int count = map.get(number);\\n        //we remove 1 from current count in the freq.\\n           if(freq.get(count) == 1) freq.remove(count);\\n           else freq.put(count, freq.get(count) - 1);\\n           map.put(number, map.get(number) - 1);\\n\\n           count = map.get(number);\\n        //we add 1 to the decreased count in the freq.\\n           freq.put(count, freq.getOrDefault(count, 0) + 1);\\n       }\\n    }\\n\\n    public boolean hasFrequency(int frequency) {\\n\\n        return freq.containsKey(frequency);\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497941,
                "title": "kotlin-o-n-with-2-array",
                "content": "# Approach\\nWe two arrays set at size as **max n**.\\nOne for keeping track of **count of each number.**\\nOne for keeping track of **count of each frequency.**\\n\\n\\n\\n# Code\\n```\\nclass FrequencyTracker() {\\n\\n\\n    val count = IntArray(100001)\\n    val freq = IntArray(100001)\\n\\n\\n    fun add(number: Int) {\\n        val curFreq = ++count[number]\\n        freq[curFreq - 1]--\\n        freq[curFreq]++\\n    }\\n\\n\\n    fun deleteOne(number: Int) {\\n        if (count[number] > 0) {\\n            val curFreq = --count[number]\\n            freq[curFreq + 1]--\\n            freq[curFreq]++\\n        }\\n    }\\n\\n\\n    fun hasFrequency(frequency: Int) = freq[frequency] > 0\\n\\n\\n}\\n\\n\\n```\\n\\n",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass FrequencyTracker() {\\n\\n\\n    val count = IntArray(100001)\\n    val freq = IntArray(100001)\\n\\n\\n    fun add(number: Int) {\\n        val curFreq = ++count[number]\\n        freq[curFreq - 1]--\\n        freq[curFreq]++\\n    }\\n\\n\\n    fun deleteOne(number: Int) {\\n        if (count[number] > 0) {\\n            val curFreq = --count[number]\\n            freq[curFreq + 1]--\\n            freq[curFreq]++\\n        }\\n    }\\n\\n\\n    fun hasFrequency(frequency: Int) = freq[frequency] > 0\\n\\n\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497847,
                "title": "javascript-two-maps",
                "content": "```\\n\\nvar FrequencyTracker = function() {\\n    this.numbers = new Map();\\n    this.freq = new Map();\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.add = function(number) {\\n    if (!this.numbers.has(number)) {\\n        this.numbers.set(number, 0)\\n    }\\n    \\n    const old = this.numbers.get(number);\\n    const freq = old + 1;\\n    \\n    if (old !== 0) { \\n        this.freq.set(old, this.freq.get(old) - 1)\\n    }\\n    \\n    this.numbers.set(number, freq);\\n    \\n    if (!this.freq.has(freq)) {\\n        this.freq.set(freq, 0)\\n    }\\n    \\n    this.freq.set(freq, this.freq.get(freq) + 1)\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.deleteOne = function(number) {\\n    if (!this.numbers.has(number) || this.numbers.get(number) === 0) {\\n        return;\\n    }\\n    \\n    const old = this.numbers.get(number);\\n    const freq = old - 1;\\n    \\n    this.freq.set(old, this.freq.get(old) - 1)\\n    \\n    this.numbers.set(number, freq);\\n    \\n    if (!this.freq.has(freq)) {\\n        this.freq.set(freq, 0)\\n    }\\n    \\n    if (freq > 0) {\\n        this.freq.set(freq, this.freq.get(freq) + 1)\\n    }\\n};\\n\\n/** \\n * @param {number} frequency\\n * @return {boolean}\\n */\\nFrequencyTracker.prototype.hasFrequency = function(frequency) {\\n    return this.freq.has(frequency) && this.freq.get(frequency) > 0;\\n};\\n\\n/** \\n * Your FrequencyTracker object will be instantiated and called as such:\\n * var obj = new FrequencyTracker()\\n * obj.add(number)\\n * obj.deleteOne(number)\\n * var param_3 = obj.hasFrequency(frequency)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n\\nvar FrequencyTracker = function() {\\n    this.numbers = new Map();\\n    this.freq = new Map();\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.add = function(number) {\\n    if (!this.numbers.has(number)) {\\n        this.numbers.set(number, 0)\\n    }\\n    \\n    const old = this.numbers.get(number);\\n    const freq = old + 1;\\n    \\n    if (old !== 0) { \\n        this.freq.set(old, this.freq.get(old) - 1)\\n    }\\n    \\n    this.numbers.set(number, freq);\\n    \\n    if (!this.freq.has(freq)) {\\n        this.freq.set(freq, 0)\\n    }\\n    \\n    this.freq.set(freq, this.freq.get(freq) + 1)\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.deleteOne = function(number) {\\n    if (!this.numbers.has(number) || this.numbers.get(number) === 0) {\\n        return;\\n    }\\n    \\n    const old = this.numbers.get(number);\\n    const freq = old - 1;\\n    \\n    this.freq.set(old, this.freq.get(old) - 1)\\n    \\n    this.numbers.set(number, freq);\\n    \\n    if (!this.freq.has(freq)) {\\n        this.freq.set(freq, 0)\\n    }\\n    \\n    if (freq > 0) {\\n        this.freq.set(freq, this.freq.get(freq) + 1)\\n    }\\n};\\n\\n/** \\n * @param {number} frequency\\n * @return {boolean}\\n */\\nFrequencyTracker.prototype.hasFrequency = function(frequency) {\\n    return this.freq.has(frequency) && this.freq.get(frequency) > 0;\\n};\\n\\n/** \\n * Your FrequencyTracker object will be instantiated and called as such:\\n * var obj = new FrequencyTracker()\\n * obj.add(number)\\n * obj.deleteOne(number)\\n * var param_3 = obj.hasFrequency(frequency)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3497761,
                "title": "c-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n        public class FrequencyTracker\\n        {\\n            readonly Dictionary<int, int> numbermap;\\n            readonly Dictionary<int, List<int>> frequencyMap;\\n            public FrequencyTracker()\\n            {\\n                numbermap = new Dictionary<int, int>();\\n                frequencyMap = new Dictionary<int, List<int>>();\\n            }\\n\\n            public void Add(int number)\\n            {\\n                int freq = 1;\\n                if (!numbermap.ContainsKey(number))\\n                {\\n                    numbermap.Add(number, 0);\\n                }\\n                else\\n                {\\n                    freq = numbermap[number];\\n\\n                    frequencyMap[freq].Remove(number);\\n                    if(frequencyMap[freq].Count == 0)\\n                    {\\n                        frequencyMap.Remove(freq);\\n                    }\\n                }\\n                numbermap[number]++;\\n\\n                freq = numbermap[number];\\n\\n                if (!frequencyMap.ContainsKey(freq))\\n                {\\n                    frequencyMap.Add(freq, new List<int>());\\n                }\\n                frequencyMap[freq].Add(number);\\n            }\\n\\npublic void DeleteOne(int number)\\n            {\\n                if (numbermap.ContainsKey(number))\\n                {\\n                    int oldfreq = numbermap[number];\\n                    frequencyMap[oldfreq].Remove(number);\\n\\n                    if (frequencyMap[oldfreq].Count == 0) frequencyMap.Remove(oldfreq);\\n\\n                    if (oldfreq == 1)\\n                    {\\n                        numbermap.Remove(number);\\n                    }\\n                    else\\n                    {\\n                        numbermap[number]--;\\n\\n                        int newFreq = oldfreq - 1;\\n\\n                        if (!frequencyMap.ContainsKey(newFreq))\\n                        {\\n                            frequencyMap.Add(newFreq, new List<int>());\\n                        }\\n                        frequencyMap[newFreq].Add(number);\\n                    }\\n\\n\\n                }\\n            }\\n\\n            public bool HasFrequency(int frequency)\\n            {\\n                return frequencyMap.ContainsKey(frequency);\\n            }\\n        }\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * bool param_3 = obj.HasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n        public class FrequencyTracker\\n        {\\n            readonly Dictionary<int, int> numbermap;\\n            readonly Dictionary<int, List<int>> frequencyMap;\\n            public FrequencyTracker()\\n            {\\n                numbermap = new Dictionary<int, int>();\\n                frequencyMap = new Dictionary<int, List<int>>();\\n            }\\n\\n            public void Add(int number)\\n            {\\n                int freq = 1;\\n                if (!numbermap.ContainsKey(number))\\n                {\\n                    numbermap.Add(number, 0);\\n                }\\n                else\\n                {\\n                    freq = numbermap[number];\\n\\n                    frequencyMap[freq].Remove(number);\\n                    if(frequencyMap[freq].Count == 0)\\n                    {\\n                        frequencyMap.Remove(freq);\\n                    }\\n                }\\n                numbermap[number]++;\\n\\n                freq = numbermap[number];\\n\\n                if (!frequencyMap.ContainsKey(freq))\\n                {\\n                    frequencyMap.Add(freq, new List<int>());\\n                }\\n                frequencyMap[freq].Add(number);\\n            }\\n\\npublic void DeleteOne(int number)\\n            {\\n                if (numbermap.ContainsKey(number))\\n                {\\n                    int oldfreq = numbermap[number];\\n                    frequencyMap[oldfreq].Remove(number);\\n\\n                    if (frequencyMap[oldfreq].Count == 0) frequencyMap.Remove(oldfreq);\\n\\n                    if (oldfreq == 1)\\n                    {\\n                        numbermap.Remove(number);\\n                    }\\n                    else\\n                    {\\n                        numbermap[number]--;\\n\\n                        int newFreq = oldfreq - 1;\\n\\n                        if (!frequencyMap.ContainsKey(newFreq))\\n                        {\\n                            frequencyMap.Add(newFreq, new List<int>());\\n                        }\\n                        frequencyMap[newFreq].Add(number);\\n                    }\\n\\n\\n                }\\n            }\\n\\n            public bool HasFrequency(int frequency)\\n            {\\n                return frequencyMap.ContainsKey(frequency);\\n            }\\n        }\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * bool param_3 = obj.HasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497682,
                "title": "using-2-frequency-map-c-map",
                "content": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int>mp,m;\\n    FrequencyTracker() {\\n        mp.clear();\\n        m.clear();\\n    }\\n    \\n    void add(int num) {\\n        if(mp.find(num)!=mp.end())\\n            m[mp[num]]--;\\n        mp[num]++;\\n        m[mp[num]]++;\\n    }\\n    \\n    void deleteOne(int num) {\\n        if(mp.find(num)==mp.end())\\n            return ;\\n        m[mp[num]]--;\\n        if(mp[num]==1)\\n        {\\n            mp.erase(num);\\n        }\\n        else\\n        {\\n            mp[num]--;\\n            m[mp[num]]++;\\n        }   \\n    }\\n    \\n    bool hasFrequency(int f) {\\n        if(m.find(f)!=m.end() && m[f]>=1)\\n            return 1;\\n        return 0;\\n    }\\n};\\n",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int>mp,m;\\n    FrequencyTracker() {\\n        mp.clear();\\n        m.clear();\\n    }\\n    \\n    void add(int num) {\\n        if(mp.find(num)!=mp.end())\\n            m[mp[num]]--;\\n        mp[num]++;\\n        m[mp[num]]++;\\n    }\\n    \\n    void deleteOne(int num) {\\n        if(mp.find(num)==mp.end())\\n            return ;\\n        m[mp[num]]--;\\n        if(mp[num]==1)\\n        {\\n            mp.erase(num);\\n        }\\n        else\\n        {\\n            mp[num]--;\\n            m[mp[num]]++;\\n        }   \\n    }\\n    \\n    bool hasFrequency(int f) {\\n        if(m.find(f)!=m.end() && m[f]>=1)\\n            return 1;\\n        return 0;\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 3497479,
                "title": "easy-approach-using-hash-map-c",
                "content": "\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n unordered_map<int, int> freq;\\n unordered_map<int, unordered_set<int>> hasfreq;\\n FrequencyTracker() {}\\n    \\n    void add(int number) {\\n        if (freq.find(number) != freq.end()) {\\n            int f = freq[number];\\n            hasfreq[f].erase(number);\\n            if (hasfreq[f].empty()) {\\n                hasfreq.erase(f);\\n            }\\n            freq[number]++;\\n            hasfreq[freq[number]].insert(number);\\n        } else {\\n            freq[number] = 1;\\n            hasfreq[freq[number]].insert(number);\\n        }\\n    }\\n    \\n    void deleteOne(int number) {\\n        if (freq.find(number) != freq.end()) {\\n            int f = freq[number];\\n            hasfreq[f].erase(number);\\n            if (hasfreq[f].empty()) {\\n                hasfreq.erase(f);\\n            }\\n            freq[number]--;\\n            if (freq[number] == 0) {\\n                freq.erase(number);\\n            } else {\\n                hasfreq[freq[number]].insert(number);\\n            }\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return hasfreq.find(frequency) != hasfreq.end();\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n unordered_map<int, int> freq;\\n unordered_map<int, unordered_set<int>> hasfreq;\\n FrequencyTracker() {}\\n    \\n    void add(int number) {\\n        if (freq.find(number) != freq.end()) {\\n            int f = freq[number];\\n            hasfreq[f].erase(number);\\n            if (hasfreq[f].empty()) {\\n                hasfreq.erase(f);\\n            }\\n            freq[number]++;\\n            hasfreq[freq[number]].insert(number);\\n        } else {\\n            freq[number] = 1;\\n            hasfreq[freq[number]].insert(number);\\n        }\\n    }\\n    \\n    void deleteOne(int number) {\\n        if (freq.find(number) != freq.end()) {\\n            int f = freq[number];\\n            hasfreq[f].erase(number);\\n            if (hasfreq[f].empty()) {\\n                hasfreq.erase(f);\\n            }\\n            freq[number]--;\\n            if (freq[number] == 0) {\\n                freq.erase(number);\\n            } else {\\n                hasfreq[freq[number]].insert(number);\\n            }\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return hasfreq.find(frequency) != hasfreq.end();\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497442,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass FrequencyTracker {\\n    private HashMap<Integer, Integer> frequencyMap;\\n    private HashMap<Integer, Integer> countMap;\\n\\n    public FrequencyTracker() {\\n        frequencyMap = new HashMap<>();\\n        countMap = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        int frequency = frequencyMap.getOrDefault(number, 0);\\n        frequencyMap.put(number, frequency + 1);\\n        \\n        int count = countMap.getOrDefault(frequency, 0);\\n        countMap.put(frequency, count - 1);\\n        \\n        count = countMap.getOrDefault(frequency + 1, 0);\\n        countMap.put(frequency + 1, count + 1);\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if (!frequencyMap.containsKey(number)) {\\n            return;\\n        }\\n        \\n        int frequency = frequencyMap.get(number);\\n        frequencyMap.put(number, frequency - 1);\\n        \\n        int count = countMap.getOrDefault(frequency, 0);\\n        countMap.put(frequency, count - 1);\\n        \\n        if (frequency == 1) {\\n            frequencyMap.remove(number);\\n        } else {\\n            count = countMap.getOrDefault(frequency - 1, 0);\\n            countMap.put(frequency - 1, count + 1);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return countMap.containsKey(frequency) && countMap.get(frequency) > 0;\\n    }\\n}\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass FrequencyTracker {\\n    private HashMap<Integer, Integer> frequencyMap;\\n    private HashMap<Integer, Integer> countMap;\\n\\n    public FrequencyTracker() {\\n        frequencyMap = new HashMap<>();\\n        countMap = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        int frequency = frequencyMap.getOrDefault(number, 0);\\n        frequencyMap.put(number, frequency + 1);\\n        \\n        int count = countMap.getOrDefault(frequency, 0);\\n        countMap.put(frequency, count - 1);\\n        \\n        count = countMap.getOrDefault(frequency + 1, 0);\\n        countMap.put(frequency + 1, count + 1);\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if (!frequencyMap.containsKey(number)) {\\n            return;\\n        }\\n        \\n        int frequency = frequencyMap.get(number);\\n        frequencyMap.put(number, frequency - 1);\\n        \\n        int count = countMap.getOrDefault(frequency, 0);\\n        countMap.put(frequency, count - 1);\\n        \\n        if (frequency == 1) {\\n            frequencyMap.remove(number);\\n        } else {\\n            count = countMap.getOrDefault(frequency - 1, 0);\\n            countMap.put(frequency - 1, count + 1);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return countMap.containsKey(frequency) && countMap.get(frequency) > 0;\\n    }\\n}\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497298,
                "title": "ez-c-solz",
                "content": "\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    // vector<int> v;\\n    unordered_map<int,int> mp;\\n    unordered_map<int,int> freq;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        // v.push_back(number);\\n        mp[number]++;\\n        freq[mp[number]]++;\\n        freq[mp[number]-1]--;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]>0){\\n            freq[mp[number]]--;\\n            mp[number]--;\\n            freq[mp[number]]++;\\n        }\\n\\n       \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency]>=1;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    // vector<int> v;\\n    unordered_map<int,int> mp;\\n    unordered_map<int,int> freq;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        // v.push_back(number);\\n        mp[number]++;\\n        freq[mp[number]]++;\\n        freq[mp[number]-1]--;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]>0){\\n            freq[mp[number]]--;\\n            mp[number]--;\\n            freq[mp[number]]++;\\n        }\\n\\n       \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency]>=1;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497271,
                "title": "java-solution-easy-design-steps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHashMaps\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Maintain two maps (***numMap*** , ***freqMap***)\\n- One for Numbers and thier frequencies and the other one for the available frequencies and the count of numbers having this frequency.\\n- When a number is added, get its current frequency, decrease its frequency count from ***freqMap*** . If the current frequency\\'s count becomes 0, remove that frequency. \\n- Then increament the frequency of the number in ***numMap*** and subsequently increase the frequency count in ***freqMap***.\\n- When a number is deleted, repeat step 3.\\n- Then decreament the frequency of the number from the ***numMap*** and subsequently decreament the frequency count in ***freqMap***.\\n- Remove frequency if count becomes 0.\\n- To check if a number exists with the given frequency, just check in ***freqMap*** if frequency exists or not.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n\\n    private Map<Integer, Integer> numMap;\\n    private Map<Integer, Integer> freqMap;\\n    \\n    public FrequencyTracker() {\\n        numMap = new HashMap<>();\\n        freqMap = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        int currFreq = numMap.getOrDefault(number, 0);\\n        \\n        if(currFreq > 0 ){\\n            freqMap.put(currFreq, freqMap.get(currFreq) - 1);\\n            \\n            if(freqMap.get(currFreq) == 0){\\n                freqMap.remove(currFreq);\\n            }\\n        }\\n        \\n        numMap.put(number, numMap.getOrDefault(number, 0) + 1);\\n        \\n        int newFreq = numMap.get(number);\\n        \\n        freqMap.put(newFreq, freqMap.getOrDefault(newFreq, 0) + 1);\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(numMap.containsKey(number)){\\n            \\n            int currFreq = numMap.getOrDefault(number, 0);\\n        \\n            if(currFreq > 0 ){\\n                freqMap.put(currFreq, freqMap.get(currFreq) - 1);\\n\\n                if(freqMap.get(currFreq) == 0){\\n                    freqMap.remove(currFreq);\\n                }\\n            }\\n            \\n            numMap.put(number, numMap.get(number) - 1);\\n            \\n            int newFreq = numMap.get(number);\\n\\n            if(newFreq == 0){\\n                numMap.remove(number);\\n            }else{\\n                freqMap.put(newFreq, freqMap.getOrDefault(newFreq, 0) + 1);\\n            }\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freqMap.containsKey(frequency);\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n\\n    private Map<Integer, Integer> numMap;\\n    private Map<Integer, Integer> freqMap;\\n    \\n    public FrequencyTracker() {\\n        numMap = new HashMap<>();\\n        freqMap = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        int currFreq = numMap.getOrDefault(number, 0);\\n        \\n        if(currFreq > 0 ){\\n            freqMap.put(currFreq, freqMap.get(currFreq) - 1);\\n            \\n            if(freqMap.get(currFreq) == 0){\\n                freqMap.remove(currFreq);\\n            }\\n        }\\n        \\n        numMap.put(number, numMap.getOrDefault(number, 0) + 1);\\n        \\n        int newFreq = numMap.get(number);\\n        \\n        freqMap.put(newFreq, freqMap.getOrDefault(newFreq, 0) + 1);\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(numMap.containsKey(number)){\\n            \\n            int currFreq = numMap.getOrDefault(number, 0);\\n        \\n            if(currFreq > 0 ){\\n                freqMap.put(currFreq, freqMap.get(currFreq) - 1);\\n\\n                if(freqMap.get(currFreq) == 0){\\n                    freqMap.remove(currFreq);\\n                }\\n            }\\n            \\n            numMap.put(number, numMap.get(number) - 1);\\n            \\n            int newFreq = numMap.get(number);\\n\\n            if(newFreq == 0){\\n                numMap.remove(number);\\n            }else{\\n                freqMap.put(newFreq, freqMap.getOrDefault(newFreq, 0) + 1);\\n            }\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freqMap.containsKey(frequency);\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497202,
                "title": "easy-solution",
                "content": "```\\nclass FrequencyTracker {\\n    unordered_map<int, int> freq, freqCnt;\\npublic:\\n    FrequencyTracker() {}\\n    \\n    void add(int number) \\n    {\\n        freqCnt[freq[number]]--;\\n        freq[number]++;\\n        freqCnt[freq[number]]++;\\n    }\\n    \\n    void deleteOne(int number) \\n    {\\n        if(freq[number] == 0) return;\\n        \\n        freqCnt[freq[number]]--;\\n        freq[number]--;\\n        freqCnt[freq[number]]++;\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freqCnt[frequency];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass FrequencyTracker {\\n    unordered_map<int, int> freq, freqCnt;\\npublic:\\n    FrequencyTracker() {}\\n    \\n    void add(int number) \\n    {\\n        freqCnt[freq[number]]--;\\n        freq[number]++;\\n        freqCnt[freq[number]]++;\\n    }\\n    \\n    void deleteOne(int number) \\n    {\\n        if(freq[number] == 0) return;\\n        \\n        freqCnt[freq[number]]--;\\n        freq[number]--;\\n        freqCnt[freq[number]]++;\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freqCnt[frequency];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497100,
                "title": "scala-two-mutable-map",
                "content": "# Code\\n```\\nclass FrequencyTracker() {\\n\\n  val counts = scala.collection.mutable.Map.empty[Int, Int].withDefaultValue(0)\\n\\n  val frequencies = scala.collection.mutable.Map.empty[Int, Int].withDefaultValue(0)\\n\\n  def add(number: Int): Unit = {\\n    val frequency = counts(number)\\n    frequencies(frequency) -= 1\\n    frequencies(frequency + 1) += 1\\n    counts(number) += 1\\n  }\\n\\n  def deleteOne(number: Int): Unit = {\\n    val frequency = counts(number)\\n    if (frequency > 0) {\\n      frequencies(frequency) -= 1\\n      frequencies(frequency - 1) += 1\\n      counts(number) -= 1\\n    }\\n  }\\n\\n  def hasFrequency(frequency: Int): Boolean =\\n    frequencies(frequency) > 0\\n}\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * var obj = new FrequencyTracker()\\n * obj.add(number)\\n * obj.deleteOne(number)\\n * var param_3 = obj.hasFrequency(frequency)\\n */\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nclass FrequencyTracker() {\\n\\n  val counts = scala.collection.mutable.Map.empty[Int, Int].withDefaultValue(0)\\n\\n  val frequencies = scala.collection.mutable.Map.empty[Int, Int].withDefaultValue(0)\\n\\n  def add(number: Int): Unit = {\\n    val frequency = counts(number)\\n    frequencies(frequency) -= 1\\n    frequencies(frequency + 1) += 1\\n    counts(number) += 1\\n  }\\n\\n  def deleteOne(number: Int): Unit = {\\n    val frequency = counts(number)\\n    if (frequency > 0) {\\n      frequencies(frequency) -= 1\\n      frequencies(frequency - 1) += 1\\n      counts(number) -= 1\\n    }\\n  }\\n\\n  def hasFrequency(frequency: Int): Boolean =\\n    frequencies(frequency) > 0\\n}\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * var obj = new FrequencyTracker()\\n * obj.add(number)\\n * obj.deleteOne(number)\\n * var param_3 = obj.hasFrequency(frequency)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497084,
                "title": "python3-o-1-methods",
                "content": "Also allows to see each frequency count\\n\\n```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.dct = collections.Counter()\\n        self.freq = collections.Counter()\\n\\n    def add(self, number: int) -> None:\\n        curFreq = self.dct[number]\\n        if curFreq > 0:\\n            self.freq[curFreq] -= 1\\n            self.freq[curFreq+1] +=1\\n        elif curFreq == 0:\\n            self.freq[1] += 1\\n        self.dct[number] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        curFreq = self.dct[number]\\n        if curFreq > 0:\\n            self.freq[curFreq] -= 1\\n            self.freq[curFreq - 1] += 1\\n            self.dct[number] -= 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.dct = collections.Counter()\\n        self.freq = collections.Counter()\\n\\n    def add(self, number: int) -> None:\\n        curFreq = self.dct[number]\\n        if curFreq > 0:\\n            self.freq[curFreq] -= 1\\n            self.freq[curFreq+1] +=1\\n        elif curFreq == 0:\\n            self.freq[1] += 1\\n        self.dct[number] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        curFreq = self.dct[number]\\n        if curFreq > 0:\\n            self.freq[curFreq] -= 1\\n            self.freq[curFreq - 1] += 1\\n            self.dct[number] -= 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497036,
                "title": "solution-using-two-hash-maps",
                "content": "# Intuitio\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    int flag =1;\\n    HashMap<Integer,Integer> hs = new HashMap<>();\\n    HashMap<Integer,Integer> hs1 = new HashMap<>();\\n    public FrequencyTracker() {}\\n    \\n    public void add(int number) {\\n        \\n        \\n        hs.put(number,hs.getOrDefault(number, 0)+1);\\n        hs1.put(hs.get(number),hs1.getOrDefault(hs.get(number), 0)+1 );\\n        if(hs.get(number)!=1)\\n         hs1.put(hs.get(number)-1,hs1.get(hs.get(number)-1)-1 );\\n        \\n    }\\n    \\n    \\n    public void deleteOne(int number) {\\n        if(hs.get(number)!=null)\\n        {\\n        if(hs.get(number)>=1)\\n        { hs1.put(hs.get(number), hs1.get(hs.get(number))-1);\\n         hs.replace(number,hs.get(number)-1);\\n          if(hs.get(number)!=0)\\n          hs1.put(hs.get(number),hs1.get(hs.get(number))+1);\\n           \\n       \\n      \\n      // \\n             \\n        }\\n    }\\n    }\\n\\n    \\n    public boolean hasFrequency(int frequency) {\\n        \\n        if(hs1.get(frequency)==null)\\n         {return false;}\\n         else{\\n             if(hs1.get(frequency)>0)\\n             return true;\\n         else\\n                 return false;\\n         }\\n            \\n    }\\n   \\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    int flag =1;\\n    HashMap<Integer,Integer> hs = new HashMap<>();\\n    HashMap<Integer,Integer> hs1 = new HashMap<>();\\n    public FrequencyTracker() {}\\n    \\n    public void add(int number) {\\n        \\n        \\n        hs.put(number,hs.getOrDefault(number, 0)+1);\\n        hs1.put(hs.get(number),hs1.getOrDefault(hs.get(number), 0)+1 );\\n        if(hs.get(number)!=1)\\n         hs1.put(hs.get(number)-1,hs1.get(hs.get(number)-1)-1 );\\n        \\n    }\\n    \\n    \\n    public void deleteOne(int number) {\\n        if(hs.get(number)!=null)\\n        {\\n        if(hs.get(number)>=1)\\n        { hs1.put(hs.get(number), hs1.get(hs.get(number))-1);\\n         hs.replace(number,hs.get(number)-1);\\n          if(hs.get(number)!=0)\\n          hs1.put(hs.get(number),hs1.get(hs.get(number))+1);\\n           \\n       \\n      \\n      // \\n             \\n        }\\n    }\\n    }\\n\\n    \\n    public boolean hasFrequency(int frequency) {\\n        \\n        if(hs1.get(frequency)==null)\\n         {return false;}\\n         else{\\n             if(hs1.get(frequency)>0)\\n             return true;\\n         else\\n                 return false;\\n         }\\n            \\n    }\\n   \\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496907,
                "title": "c-2-hash-maps-add-0-frequency-to-avoid-edge-case",
                "content": "```\\nclass FrequencyTracker {\\n    unordered_map<int, int> freq, ffreq;\\npublic:\\n    void add(int n) {\\n        --ffreq[freq[n]];\\n        ++ffreq[++freq[n]];\\n    }\\n    \\n    void deleteOne(int n) {\\n        if(freq[n] > 0) {\\n            --ffreq[freq[n]];\\n            ++ffreq[--freq[n]];\\n        }\\n    }\\n    \\n    bool hasFrequency(int f) {\\n        return ffreq[f] > 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    unordered_map<int, int> freq, ffreq;\\npublic:\\n    void add(int n) {\\n        --ffreq[freq[n]];\\n        ++ffreq[++freq[n]];\\n    }\\n    \\n    void deleteOne(int n) {\\n        if(freq[n] > 0) {\\n            --ffreq[freq[n]];\\n            ++ffreq[--freq[n]];\\n        }\\n    }\\n    \\n    bool hasFrequency(int f) {\\n        return ffreq[f] > 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496804,
                "title": "simple-commented-with-time-complexity-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\non add just erase the value of freq from mi map and simunateously increase cnt of ele in map table \\ndelete m just see    if present , then decrease the mi vluae one then afon \\\\\\\\                                 \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    map<int,int>mp;//no --> cnt\\n     map<int,int>mi;//to check the freq present or not freq-->cnt\\n\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n     mp[number]++;\\n      if(mp[number]>0) {// tht means already present so have to first erase the cur freq from mi map to in order to add new coming to mp \\n      mi[mp[number]-1]--;\\n      }\\n      mi[mp[number]]++; //inserting new freq to mi  so tht we can maintain the new freq cnt in  map\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]==0)return ;\\n         //checking if it present so have to change in both map \\n        \\n            mi[mp[number]]--;\\n            mp[number]--;\\n            if(mp[number]>0)\\n            mi[mp[number]]++; //adding new freq to mi map \\n        \\n        \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n         return mi[frequency] ;\\n        \\n    }\\n};\\ntc isO((n))\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    map<int,int>mp;//no --> cnt\\n     map<int,int>mi;//to check the freq present or not freq-->cnt\\n\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n     mp[number]++;\\n      if(mp[number]>0) {// tht means already present so have to first erase the cur freq from mi map to in order to add new coming to mp \\n      mi[mp[number]-1]--;\\n      }\\n      mi[mp[number]]++; //inserting new freq to mi  so tht we can maintain the new freq cnt in  map\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]==0)return ;\\n         //checking if it present so have to change in both map \\n        \\n            mi[mp[number]]--;\\n            mp[number]--;\\n            if(mp[number]>0)\\n            mi[mp[number]]++; //adding new freq to mi map \\n        \\n        \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n         return mi[frequency] ;\\n        \\n    }\\n};\\ntc isO((n))\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496801,
                "title": "easy-hash-maps-implementation-using-unordered-maps",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTwo hashmaps, count and freq are maintained, one which keeps the total occurences of the elements being inserted/deleted and the 2nd which keeps a count of the frequencies.\\n<!-- # Complex -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map <int, int> count;\\n    unordered_map <int, int> freq;\\n    FrequencyTracker() {}\\n    void add(int number) {\\n        if(freq[count[number]]>0)\\n            freq[count[number]]--;\\n        ++count[number];\\n        ++freq[count[number]];\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(count[number]>0){\\n            freq[count[number]]--;\\n            count[number]--;\\n            freq[count[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(freq[frequency]>0)\\n            return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map <int, int> count;\\n    unordered_map <int, int> freq;\\n    FrequencyTracker() {}\\n    void add(int number) {\\n        if(freq[count[number]]>0)\\n            freq[count[number]]--;\\n        ++count[number];\\n        ++freq[count[number]];\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(count[number]>0){\\n            freq[count[number]]--;\\n            count[number]--;\\n            freq[count[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(freq[frequency]>0)\\n            return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1885712,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1886897,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1885604,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1885453,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1885385,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 2024758,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1926023,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1918318,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1912759,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1896763,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1885712,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1886897,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1885604,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1885453,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1885385,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 2024758,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1926023,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1918318,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1912759,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1896763,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            }
        ]
    }
]