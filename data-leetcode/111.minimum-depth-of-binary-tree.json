[
    {
        "title": "Minimum Depth of Binary Tree",
        "question_content": "Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nNote:&nbsp;A leaf is a node with no children.\n&nbsp;\nExample 1:\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: 2\n\nExample 2:\n\nInput: root = [2,null,3,null,4,null,5,null,6]\nOutput: 5\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [0, 105].\n\t-1000 <= Node.val <= 1000",
        "solutions": [
            {
                "id": 36045,
                "title": "my-4-line-java-solution",
                "content": "    public class Solution {\\n        public int minDepth(TreeNode root) {\\n            if(root == null) return 0;\\n            int left = minDepth(root.left);\\n            int right = minDepth(root.right);\\n            return (left == 0 || right == 0) ? left + right + 1: Math.min(left,right) + 1;\\n           \\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int minDepth(TreeNode root) {\\n            if(root == null) return 0;\\n            int left = minDepth(root.left);\\n            int right = minDepth(root.right);\\n            return (left == 0 || right == 0) ? left + right + 1: Math.min(left,right) + 1;\\n           \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36060,
                "title": "3-lines-in-every-language",
                "content": "We need to add the smaller one of the child depths - except if that's zero, then add the larger one. The first Python solution is the clearest because it lets me directly say exactly that.\\n\\n**Python versions:**\\n\\n    def minDepth(self, root):\\n        if not root: return 0\\n        d = map(self.minDepth, (root.left, root.right))\\n        return 1 + (min(d) or max(d))\\n\\n    def minDepth(self, root):\\n        if not root: return 0\\n        d, D = sorted(map(self.minDepth, (root.left, root.right)))\\n        return 1 + (d or D)\\n\\n**C++ versions:**\\n\\n    int minDepth(TreeNode* root) {\\n        if (!root) return 0;\\n        int L = minDepth(root->left), R = minDepth(root->right);\\n        return 1 + (min(L, R) ? min(L, R) : max(L, R));\\n    }\\n\\n    int minDepth(TreeNode* root) {\\n        if (!root) return 0;\\n        int L = minDepth(root->left), R = minDepth(root->right);\\n        return 1 + (L && R ? min(L, R) : max(L, R));\\n    }\\n\\n    int minDepth(TreeNode* root) {\\n        if (!root) return 0;\\n        int L = minDepth(root->left), R = minDepth(root->right);\\n        return 1 + (!L-!R ? max(L, R) : min(L, R));\\n    }\\n\\n    int minDepth(TreeNode* root) {\\n        if (!root) return 0;\\n        int L = minDepth(root->left), R = minDepth(root->right);\\n        return L<R && L || !R ? 1+L : 1+R;\\n    }\\n\\n**Java versions:**\\n\\n    public int minDepth(TreeNode root) {\\n        if (root == null) return 0;\\n        int L = minDepth(root.left), R = minDepth(root.right);\\n        return 1 + (Math.min(L, R) > 0 ? Math.min(L, R) : Math.max(L, R));\\n    }\\n\\n    public int minDepth(TreeNode root) {\\n        if (root == null) return 0;\\n        int L = minDepth(root.left), R = minDepth(root.right), m = Math.min(L, R);\\n        return 1 + (m > 0 ? m : Math.max(L, R));\\n    }\\n\\n    public int minDepth(TreeNode root) {\\n        if (root == null) return 0;\\n        int L = minDepth(root.left), R = minDepth(root.right);\\n        return L<R && L>0 || R<1 ? 1+L : 1+R;\\n    }\\n\\n**Ruby version:**\\n\\n    def min_depth(root)\\n        return 0 if !root\\n        d, e = [min_depth(root.left), min_depth(root.right)].sort\\n        1 + (d>0 ? d : e)\\n    end\\n\\n**Javascript version:**\\n\\n    var minDepth = function(root) {\\n        if (!root) return 0\\n        var L = minDepth(root.left), R = minDepth(root.right)\\n        return 1 + (Math.min(L, R) || Math.max(L, R))\\n    };\\n\\n**C version:**\\n\\n    int minDepth(struct TreeNode* root) {\\n        if (!root) return 0;\\n        int L = minDepth(root->left), R = minDepth(root->right);\\n        return L<R && L || !R ? 1+L : 1+R;\\n    }\\n\\n**C# version:**\\n\\n    public int MinDepth(TreeNode root) {\\n        if (root == null) return 0;\\n        int L = MinDepth(root.left), R = MinDepth(root.right);\\n        return L<R && L>0 || R<1 ? 1+L : 1+R;\\n    }",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "We need to add the smaller one of the child depths - except if that's zero, then add the larger one. The first Python solution is the clearest because it lets me directly say exactly that.\\n\\n**Python versions:**\\n\\n    def minDepth(self, root):\\n        if not root: return 0\\n        d = map(self.minDepth, (root.left, root.right))\\n        return 1 + (min(d) or max(d))\\n\\n    def minDepth(self, root):\\n        if not root: return 0\\n        d, D = sorted(map(self.minDepth, (root.left, root.right)))\\n        return 1 + (d or D)\\n\\n**C++ versions:**\\n\\n    int minDepth(TreeNode* root) {\\n        if (!root) return 0;\\n        int L = minDepth(root->left), R = minDepth(root->right);\\n        return 1 + (min(L, R) ? min(L, R) : max(L, R));\\n    }\\n\\n    int minDepth(TreeNode* root) {\\n        if (!root) return 0;\\n        int L = minDepth(root->left), R = minDepth(root->right);\\n        return 1 + (L && R ? min(L, R) : max(L, R));\\n    }\\n\\n    int minDepth(TreeNode* root) {\\n        if (!root) return 0;\\n        int L = minDepth(root->left), R = minDepth(root->right);\\n        return 1 + (!L-!R ? max(L, R) : min(L, R));\\n    }\\n\\n    int minDepth(TreeNode* root) {\\n        if (!root) return 0;\\n        int L = minDepth(root->left), R = minDepth(root->right);\\n        return L<R && L || !R ? 1+L : 1+R;\\n    }\\n\\n**Java versions:**\\n\\n    public int minDepth(TreeNode root) {\\n        if (root == null) return 0;\\n        int L = minDepth(root.left), R = minDepth(root.right);\\n        return 1 + (Math.min(L, R) > 0 ? Math.min(L, R) : Math.max(L, R));\\n    }\\n\\n    public int minDepth(TreeNode root) {\\n        if (root == null) return 0;\\n        int L = minDepth(root.left), R = minDepth(root.right), m = Math.min(L, R);\\n        return 1 + (m > 0 ? m : Math.max(L, R));\\n    }\\n\\n    public int minDepth(TreeNode root) {\\n        if (root == null) return 0;\\n        int L = minDepth(root.left), R = minDepth(root.right);\\n        return L<R && L>0 || R<1 ? 1+L : 1+R;\\n    }\\n\\n**Ruby version:**\\n\\n    def min_depth(root)\\n        return 0 if !root\\n        d, e = [min_depth(root.left), min_depth(root.right)].sort\\n        1 + (d>0 ? d : e)\\n    end\\n\\n**Javascript version:**\\n\\n    var minDepth = function(root) {\\n        if (!root) return 0\\n        var L = minDepth(root.left), R = minDepth(root.right)\\n        return 1 + (Math.min(L, R) || Math.max(L, R))\\n    };\\n\\n**C version:**\\n\\n    int minDepth(struct TreeNode* root) {\\n        if (!root) return 0;\\n        int L = minDepth(root->left), R = minDepth(root->right);\\n        return L<R && L || !R ? 1+L : 1+R;\\n    }\\n\\n**C# version:**\\n\\n    public int MinDepth(TreeNode root) {\\n        if (root == null) return 0;\\n        int L = MinDepth(root.left), R = MinDepth(root.right);\\n        return L<R && L>0 || R<1 ? 1+L : 1+R;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 36071,
                "title": "bfs-c-8ms-beats-99-94-submissions",
                "content": "    int minDepth(TreeNode* root) {\\n        if (root == NULL) return 0;\\n        queue<TreeNode*> Q;\\n        Q.push(root);\\n        int i = 0;\\n        while (!Q.empty()) {\\n            i++;\\n            int k = Q.size();\\n            for (int j=0; j<k; j++) {\\n                TreeNode* rt = Q.front();\\n                if (rt->left) Q.push(rt->left);\\n                if (rt->right) Q.push(rt->right);\\n                Q.pop();\\n                if (rt->left==NULL && rt->right==NULL) return i;\\n            }\\n        }\\n        return -1; //For the compiler thing. The code never runs here.\\n    }",
                "solutionTags": [],
                "code": "    int minDepth(TreeNode* root) {\\n        if (root == NULL) return 0;\\n        queue<TreeNode*> Q;\\n        Q.push(root);\\n        int i = 0;\\n        while (!Q.empty()) {\\n            i++;\\n            int k = Q.size();\\n            for (int j=0; j<k; j++) {\\n                TreeNode* rt = Q.front();\\n                if (rt->left) Q.push(rt->left);\\n                if (rt->right) Q.push(rt->right);\\n                Q.pop();\\n                if (rt->left==NULL && rt->right==NULL) return i;\\n            }\\n        }\\n        return -1; //For the compiler thing. The code never runs here.\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36239,
                "title": "python-bfs-and-dfs-solutions",
                "content": "        \\n    # DFS\\n    def minDepth1(self, root):\\n        if not root:\\n            return 0\\n        if None in [root.left, root.right]:\\n            return max(self.minDepth(root.left), self.minDepth(root.right)) + 1\\n        else:\\n            return min(self.minDepth(root.left), self.minDepth(root.right)) + 1\\n     \\n    # BFS   \\n    def minDepth(self, root):\\n        if not root:\\n            return 0\\n        queue = collections.deque([(root, 1)])\\n        while queue:\\n            node, level = queue.popleft()\\n            if node:\\n                if not node.left and not node.right:\\n                    return level\\n                else:\\n                    queue.append((node.left, level+1))\\n                    queue.append((node.right, level+1))",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "        \\n    # DFS\\n    def minDepth1(self, root):\\n        if not root:\\n            return 0\\n        if None in [root.left, root.right]:\\n            return max(self.minDepth(root.left), self.minDepth(root.right)) + 1\\n        else:\\n            return min(self.minDepth(root.left), self.minDepth(root.right)) + 1\\n     \\n    # BFS   \\n    def minDepth(self, root):\\n        if not root:\\n            return 0\\n        queue = collections.deque([(root, 1)])\\n        while queue:\\n            node, level = queue.popleft()\\n            if node:\\n                if not node.left and not node.right:\\n                    return level\\n                else:\\n                    queue.append((node.left, level+1))\\n                    queue.append((node.right, level+1))",
                "codeTag": "Python3"
            },
            {
                "id": 36153,
                "title": "my-concise-c-solution",
                "content": "\\n\\n    class Solution {\\n    public:\\n        int minDepth(TreeNode *root) {\\n            if(!root) return 0;\\n            if(!root->left) return 1 + minDepth(root->right);\\n            if(!root->right) return 1 + minDepth(root->left);\\n            return 1+min(minDepth(root->left),minDepth(root->right));\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int minDepth(TreeNode *root) {\\n            if(!root) return 0;\\n            if(!root->left) return 1 + minDepth(root->right);\\n            if(!root->right) return 1 + minDepth(root->left);\\n            return 1+min(minDepth(root->left),minDepth(root->right));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2429057,
                "title": "very-easy-100-fully-explained-c-java-python-js-c-python3",
                "content": "# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        // Base case...\\n        // If the subtree is empty i.e. root is NULL, return depth as 0...\\n        if(root == NULL)  return 0;\\n        // Initialize the depth of two subtrees...\\n        int leftDepth = minDepth(root->left);\\n        int rightDepth = minDepth(root->right);\\n        // If the both subtrees are empty...\\n        if(root->left == NULL && root->right == NULL)\\n            return 1;\\n        // If the left subtree is empty, return the depth of right subtree after adding 1 to it...\\n        if(root->left == NULL)\\n            return 1 + rightDepth;\\n        // If the right subtree is empty, return the depth of left subtree after adding 1 to it...\\n        if(root->right == NULL)\\n            return 1 + leftDepth;\\n        // When the two child function return its depth...\\n        // Pick the minimum out of these two subtrees and return this value after adding 1 to it...\\n        return min(leftDepth, rightDepth) + 1;    // Adding 1 is the current node which is the parent of the two subtrees...\\n    }\\n};\\n```\\n\\n# **Java Solution:**\\n```\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        // Base case...\\n        // If the subtree is empty i.e. root is NULL, return depth as 0...\\n        if(root == null)  return 0;\\n        // Initialize the depth of two subtrees...\\n        int leftDepth = minDepth(root.left);\\n        int rightDepth = minDepth(root.right);\\n        // If the both subtrees are empty...\\n        if(root.left == null && root.right == null)\\n            return 1;\\n        // If the left subtree is empty, return the depth of right subtree after adding 1 to it...\\n        if(root.left == null)\\n            return 1 + rightDepth;\\n        // If the right subtree is empty, return the depth of left subtree after adding 1 to it...\\n        if(root.right == null)\\n            return 1 + leftDepth;\\n        // When the two child function return its depth...\\n        // Pick the minimum out of these two subtrees and return this value after adding 1 to it...\\n        return Math.min(leftDepth, rightDepth) + 1;    // Adding 1 is the current node which is the parent of the two subtrees...\\n    }\\n}\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def minDepth(self, root):\\n        # Base case...\\n        # If the subtree is empty i.e. root is NULL, return depth as 0...\\n        if root is None:  return 0\\n        # Initialize the depth of two subtrees...\\n        leftDepth = self.minDepth(root.left)\\n        rightDepth = self.minDepth(root.right)\\n        # If the both subtrees are empty...\\n        if root.left is None and root.right is None:\\n            return 1\\n        # If the left subtree is empty, return the depth of right subtree after adding 1 to it...\\n        if root.left is None:\\n            return 1 + rightDepth\\n        # If the right subtree is empty, return the depth of left subtree after adding 1 to it...\\n        if root.right is None:\\n            return 1 + leftDepth\\n        # When the two child function return its depth...\\n        # Pick the minimum out of these two subtrees and return this value after adding 1 to it...\\n        return min(leftDepth, rightDepth) + 1;    # Adding 1 is the current node which is the parent of the two subtrees...\\n```\\n                \\n# **JavaScript Solution:**\\n```\\nvar minDepth = function(root) {\\n    // Base case...\\n    // If the subtree is empty i.e. root is NULL, return depth as 0...\\n    if(root == null)  return 0;\\n    // If the both subtrees are empty...\\n    if(root.left == null && root.right == null)\\n        return 1;\\n    // If the left subtree is empty, return the depth of right subtree after adding 1 to it...\\n    if(root.left == null)\\n        return 1 + minDepth(root.right);\\n    // If the right subtree is empty, return the depth of left subtree after adding 1 to it...\\n    if(root.right == null)\\n        return 1 + minDepth(root.left);\\n    // When the two child function return its depth...\\n    // Pick the minimum out of these two subtrees and return this value after adding 1 to it...\\n    return Math.min(minDepth(root.left), minDepth(root.right)) + 1;    // Adding 1 is the current node which is the parent of the two subtrees...\\n};\\n```\\n\\n# **C Language:**\\n```\\nint minDepth(struct TreeNode* root){\\n    if(root == NULL)\\n        return 0;\\n    else {\\n        int leftDepth = minDepth(root->left);\\n        int rightDepth = minDepth(root->right);\\n        if(leftDepth > rightDepth)\\n            return rightDepth + 1;\\n        else\\n            return leftDepth + 1;\\n    }\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        # Base case...\\n        # If the subtree is empty i.e. root is NULL, return depth as 0...\\n        if root is None:  return 0\\n        # Initialize the depth of two subtrees...\\n        leftDepth = self.minDepth(root.left)\\n        rightDepth = self.minDepth(root.right)\\n        # If the both subtrees are empty...\\n        if root.left is None and root.right is None:\\n            return 1\\n        # If the left subtree is empty, return the depth of right subtree after adding 1 to it...\\n        if root.left is None:\\n            return 1 + rightDepth\\n        # If the right subtree is empty, return the depth of left subtree after adding 1 to it...\\n        if root.right is None:\\n            return 1 + leftDepth\\n        # When the two child function return its depth...\\n        # Pick the minimum out of these two subtrees and return this value after adding 1 to it...\\n        return min(leftDepth, rightDepth) + 1;    # Adding 1 is the current node which is the parent of the two subtrees...\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        // Base case...\\n        // If the subtree is empty i.e. root is NULL, return depth as 0...\\n        if(root == NULL)  return 0;\\n        // Initialize the depth of two subtrees...\\n        int leftDepth = minDepth(root->left);\\n        int rightDepth = minDepth(root->right);\\n        // If the both subtrees are empty...\\n        if(root->left == NULL && root->right == NULL)\\n            return 1;\\n        // If the left subtree is empty, return the depth of right subtree after adding 1 to it...\\n        if(root->left == NULL)\\n            return 1 + rightDepth;\\n        // If the right subtree is empty, return the depth of left subtree after adding 1 to it...\\n        if(root->right == NULL)\\n            return 1 + leftDepth;\\n        // When the two child function return its depth...\\n        // Pick the minimum out of these two subtrees and return this value after adding 1 to it...\\n        return min(leftDepth, rightDepth) + 1;    // Adding 1 is the current node which is the parent of the two subtrees...\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        // Base case...\\n        // If the subtree is empty i.e. root is NULL, return depth as 0...\\n        if(root == null)  return 0;\\n        // Initialize the depth of two subtrees...\\n        int leftDepth = minDepth(root.left);\\n        int rightDepth = minDepth(root.right);\\n        // If the both subtrees are empty...\\n        if(root.left == null && root.right == null)\\n            return 1;\\n        // If the left subtree is empty, return the depth of right subtree after adding 1 to it...\\n        if(root.left == null)\\n            return 1 + rightDepth;\\n        // If the right subtree is empty, return the depth of left subtree after adding 1 to it...\\n        if(root.right == null)\\n            return 1 + leftDepth;\\n        // When the two child function return its depth...\\n        // Pick the minimum out of these two subtrees and return this value after adding 1 to it...\\n        return Math.min(leftDepth, rightDepth) + 1;    // Adding 1 is the current node which is the parent of the two subtrees...\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def minDepth(self, root):\\n        # Base case...\\n        # If the subtree is empty i.e. root is NULL, return depth as 0...\\n        if root is None:  return 0\\n        # Initialize the depth of two subtrees...\\n        leftDepth = self.minDepth(root.left)\\n        rightDepth = self.minDepth(root.right)\\n        # If the both subtrees are empty...\\n        if root.left is None and root.right is None:\\n            return 1\\n        # If the left subtree is empty, return the depth of right subtree after adding 1 to it...\\n        if root.left is None:\\n            return 1 + rightDepth\\n        # If the right subtree is empty, return the depth of left subtree after adding 1 to it...\\n        if root.right is None:\\n            return 1 + leftDepth\\n        # When the two child function return its depth...\\n        # Pick the minimum out of these two subtrees and return this value after adding 1 to it...\\n        return min(leftDepth, rightDepth) + 1;    # Adding 1 is the current node which is the parent of the two subtrees...\\n```\n```\\nvar minDepth = function(root) {\\n    // Base case...\\n    // If the subtree is empty i.e. root is NULL, return depth as 0...\\n    if(root == null)  return 0;\\n    // If the both subtrees are empty...\\n    if(root.left == null && root.right == null)\\n        return 1;\\n    // If the left subtree is empty, return the depth of right subtree after adding 1 to it...\\n    if(root.left == null)\\n        return 1 + minDepth(root.right);\\n    // If the right subtree is empty, return the depth of left subtree after adding 1 to it...\\n    if(root.right == null)\\n        return 1 + minDepth(root.left);\\n    // When the two child function return its depth...\\n    // Pick the minimum out of these two subtrees and return this value after adding 1 to it...\\n    return Math.min(minDepth(root.left), minDepth(root.right)) + 1;    // Adding 1 is the current node which is the parent of the two subtrees...\\n};\\n```\n```\\nint minDepth(struct TreeNode* root){\\n    if(root == NULL)\\n        return 0;\\n    else {\\n        int leftDepth = minDepth(root->left);\\n        int rightDepth = minDepth(root->right);\\n        if(leftDepth > rightDepth)\\n            return rightDepth + 1;\\n        else\\n            return leftDepth + 1;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        # Base case...\\n        # If the subtree is empty i.e. root is NULL, return depth as 0...\\n        if root is None:  return 0\\n        # Initialize the depth of two subtrees...\\n        leftDepth = self.minDepth(root.left)\\n        rightDepth = self.minDepth(root.right)\\n        # If the both subtrees are empty...\\n        if root.left is None and root.right is None:\\n            return 1\\n        # If the left subtree is empty, return the depth of right subtree after adding 1 to it...\\n        if root.left is None:\\n            return 1 + rightDepth\\n        # If the right subtree is empty, return the depth of left subtree after adding 1 to it...\\n        if root.right is None:\\n            return 1 + leftDepth\\n        # When the two child function return its depth...\\n        # Pick the minimum out of these two subtrees and return this value after adding 1 to it...\\n        return min(leftDepth, rightDepth) + 1;    # Adding 1 is the current node which is the parent of the two subtrees...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36199,
                "title": "easy-solution-using-bfs-in-java",
                "content": "    public int minDepth(TreeNode root) {\\n        if(root == null) return 0;\\n        int depth = 1;\\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            // for each level\\n            for(int i=0;i<size;i++){\\n                TreeNode node = q.poll();\\n                if(node.left == null && node.right == null){\\n                    return depth;\\n                }\\n                if(node.left != null){\\n                    q.offer(node.left);\\n                }\\n                if(node.right != null){\\n                    q.offer(node.right);\\n                }\\n            }\\n            depth++;\\n        }\\n        return depth;\\n    }",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "    public int minDepth(TreeNode root) {\\n        if(root == null) return 0;\\n        int depth = 1;\\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            // for each level\\n            for(int i=0;i<size;i++){\\n                TreeNode node = q.poll();\\n                if(node.left == null && node.right == null){\\n                    return depth;\\n                }\\n                if(node.left != null){\\n                    q.offer(node.left);\\n                }\\n                if(node.right != null){\\n                    q.offer(node.right);\\n                }\\n            }\\n            depth++;\\n        }\\n        return depth;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36094,
                "title": "my-solution-in-python",
                "content": "The idea is to use recursion, the accepted short python code looks like follows:\\n\\n    class Solution:\\n        # @param root, a tree node\\n        # @return an integer    \\n        def minDepth(self, root):\\n            if root == None:\\n                return 0\\n            if root.left==None or root.right==None:\\n                return self.minDepth(root.left)+self.minDepth(root.right)+1\\n            return min(self.minDepth(root.right),self.minDepth(root.left))+1",
                "solutionTags": [
                    "Python"
                ],
                "code": "The idea is to use recursion, the accepted short python code looks like follows:\\n\\n    class Solution:\\n        # @param root, a tree node\\n        # @return an integer    \\n        def minDepth(self, root):\\n            if root == None:\\n                return 0\\n            if root.left==None or root.right==None:\\n                return self.minDepth(root.left)+self.minDepth(root.right)+1\\n            return min(self.minDepth(root.right),self.minDepth(root.left))+1",
                "codeTag": "Java"
            },
            {
                "id": 36061,
                "title": "my-solution-used-level-order-traversal",
                "content": "level-order traversal and record current level depth, when meet a node which both child is null then return, no need to go farther\\n\\n    public class Solution {\\n    public int minDepth(TreeNode root) {\\n\\t\\tif (root == null)\\n\\t\\t\\treturn 0;\\n\\t\\tint depth = 1;\\n\\t\\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\\n\\t\\tTreeNode temp,magic = new TreeNode(0);\\n\\t\\tqueue.add(root);\\n\\t\\tqueue.add(magic);\\n\\t\\twhile(!queue.isEmpty()){\\n\\t\\t\\ttemp = queue.poll();\\n\\t\\t\\tif(temp.equals(magic)){\\n\\t\\t\\t    if(!queue.isEmpty()){\\n\\t\\t\\t        depth++;\\n\\t\\t\\t\\t    queue.add(magic);\\n\\t\\t\\t    }\\n\\t\\t\\t    continue;\\n\\t\\t\\t}\\n\\t\\t\\tif(temp.left == null && temp.right == null)\\n\\t\\t\\t\\treturn depth;\\n\\t\\t\\tif(temp.left != null)\\n\\t\\t\\t\\tqueue.add(temp.left);\\n\\t\\t\\tif(temp.right != null)\\n\\t\\t\\t\\tqueue.add(temp.right);\\n\\t\\t}\\n\\t\\treturn depth;\\n\\t}\\n    }\\nAny better solution?",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minDepth(TreeNode root) {\\n\\t\\tif (root == null)\\n\\t\\t\\treturn 0;\\n\\t\\tint depth = 1;\\n\\t\\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\\n\\t\\tTreeNode temp,magic = new TreeNode(0);\\n\\t\\tqueue.add(root);\\n\\t\\tqueue.add(magic);\\n\\t\\twhile(!queue.isEmpty()){\\n\\t\\t\\ttemp = queue.poll();\\n\\t\\t\\tif(temp.equals(magic)){\\n\\t\\t\\t    if(!queue.isEmpty()){\\n\\t\\t\\t        depth++;\\n\\t\\t\\t\\t    queue.add(magic);\\n\\t\\t\\t    }",
                "codeTag": "Java"
            },
            {
                "id": 36296,
                "title": "share-my-python-solution-with-explanation",
                "content": "    class Solution:\\n        # @param root, a tree node\\n        # @return an integer\\n        def minDepth(self, root):\\n            if not root:\\n                return 0\\n            else:\\n                # if one of the subtree is None, you should return the depth of another subtree.\\n                # if all of the subtree is not None, you should return the minimum depth of the two subtrees\\n                if root.left is None:\\n                    return self.minDepth(root.right) + 1\\n                elif root.right is None:\\n                    return self.minDepth(root.left) + 1\\n                else:\\n                    return min(self.minDepth(root.left), self.minDepth(root.right)) + 1",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param root, a tree node\\n        # @return an integer\\n        def minDepth(self, root):\\n            if not root:\\n                return 0\\n            else:\\n                # if one of the subtree is None, you should return the depth of another subtree.\\n                # if all of the subtree is not None, you should return the minimum depth of the two subtrees\\n                if root.left is None:\\n                    return self.minDepth(root.right) + 1\\n                elif root.right is None:\\n                    return self.minDepth(root.left) + 1\\n                else:\\n                    return min(self.minDepth(root.left), self.minDepth(root.right)) + 1",
                "codeTag": "Java"
            },
            {
                "id": 905414,
                "title": "c-java-python-bfs-dfs-clean-concise-o-n",
                "content": "**Solution 1: DFS**\\n<iframe src=\"https://leetcode.com/playground/WjTUtSNB/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe>\\n\\nComplexity:\\n- Time: `O(N)`. Because each node is visited exactly once.\\n- Space: `O(H)`, where `H` is the height of the tree, it\\'s the cost for depth of recursion stack memory.\\n\\n**Solution 2: BFS**\\nThe drawback of the DFS approach in this case is that all nodes should be visited to ensure that the minimum depth would be found. Therefore, this results in `O(N)` complexity. One way to optimize the complexity is to use the BFS strategy. We iterate the tree level by level, and the first leaf we reach corresponds to the minimum depth. As a result, we do not need to iterate all nodes.\\n\\n<iframe src=\"https://leetcode.com/playground/Rx4ebhGX/shared\" frameBorder=\"0\" width=\"100%\" height=\"450\"></iframe>\\n\\nComplexity:\\n- Time: In the worst case for a balanced tree, we need to visit all nodes level by level up to the tree height, that excludes the bottom level only. This way we visit `N/2` nodes, and thus the time complexity is `O(N)`.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "**Solution 1: DFS**\\n<iframe src=\"https://leetcode.com/playground/WjTUtSNB/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe>\\n\\nComplexity:\\n- Time: `O(N)`. Because each node is visited exactly once.\\n- Space: `O(H)`, where `H` is the height of the tree, it\\'s the cost for depth of recursion stack memory.\\n\\n**Solution 2: BFS**\\nThe drawback of the DFS approach in this case is that all nodes should be visited to ensure that the minimum depth would be found. Therefore, this results in `O(N)` complexity. One way to optimize the complexity is to use the BFS strategy. We iterate the tree level by level, and the first leaf we reach corresponds to the minimum depth. As a result, we do not need to iterate all nodes.\\n\\n<iframe src=\"https://leetcode.com/playground/Rx4ebhGX/shared\" frameBorder=\"0\" width=\"100%\" height=\"450\"></iframe>\\n\\nComplexity:\\n- Time: In the worst case for a balanced tree, we need to visit all nodes level by level up to the tree height, that excludes the bottom level only. This way we visit `N/2` nodes, and thus the time complexity is `O(N)`.\\n- Space: `O(N)`",
                "codeTag": "Unknown"
            },
            {
                "id": 36188,
                "title": "very-easy-with-recursion-1ms-java-solution",
                "content": "\\n    public int minDepth(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        if (root.left != null && root.right != null)\\n            return Math.min(minDepth(root.left), minDepth(root.right))+1;\\n        else\\n            return Math.max(minDepth(root.left), minDepth(root.right))+1;\\n    }",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "\\n    public int minDepth(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        if (root.left != null && root.right != null)\\n            return Math.min(minDepth(root.left), minDepth(root.right))+1;\\n        else\\n            return Math.max(minDepth(root.left), minDepth(root.right))+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1304167,
                "title": "easy-c-solution-using-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minDepth(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        int lh=minDepth(root->left);\\n        int rh=minDepth(root->right);\\n        if(lh==0) return 1+rh; //lh=0 means there is no left subtree,so we cannot compare its height to right subtree\\n        else if(rh==0) return 1+lh; //rh=0 means there is no right subtree\\n        else return 1+ min(lh,rh);\\n    }\\n};\\n```\\nHope you found this useful :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minDepth(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        int lh=minDepth(root->left);\\n        int rh=minDepth(root->right);\\n        if(lh==0) return 1+rh; //lh=0 means there is no left subtree,so we cannot compare its height to right subtree\\n        else if(rh==0) return 1+lh; //rh=0 means there is no right subtree\\n        else return 1+ min(lh,rh);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174041,
                "title": "c-bfs-level-order-traversal-recursion-dfs-4-easy-solutions",
                "content": "**BFS - 1**\\n\\n```\\nclass Solution {\\npublic:\\n    int level = 0;\\n    int minDepth(TreeNode* root) {\\n        if(!root){ return 0;}\\n        \\n        queue<TreeNode*> q;\\n        int level = 0;\\n        \\n        q.push(root);\\n        while(!q.empty()){\\n            int breadth = q.size();\\n            level++;\\n            for(int i=0; i<breadth; i++){\\n                TreeNode* parent = q.front(); \\n                q.pop();\\n                \\n                if(parent->left) q.push(parent->left);\\n                if(parent->right) q.push(parent->right);\\n                \\n                if(!parent->left && !parent->right) return level; //leaf node\\n            }\\n        }\\n        \\n        return level;\\n    }\\n};\\n```\\n\\n**BFS - 2 (Optimized)**\\n\\n```\\nclass Solution {\\npublic:\\nint minDepth(TreeNode* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            return 1;\\n        }\\n        else if( root->left != NULL && root->right == NULL){\\n            return minDepth(root->left) + 1;\\n        }\\n        else if( root->left == NULL && root->right != NULL ){\\n            return minDepth(root->right) + 1;\\n        }\\n        else{\\n            return min(minDepth(root->left),minDepth(root->right)) + 1;\\n        }\\n    }\\n}\\n```\\n\\n**Recursion / DFS - 1**\\n\\n```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(root==NULL){ return 0;}\\n        int l = minDepth(root->left), r = minDepth(root->right);\\n        return 1 + (min(l, r) ? min(l, r) : max(l, r));\\n    }\\n};\\n```\\n\\n**Recursion / DFS - 2**\\n\\n```\\nint minDepth(TreeNode* root) {\\n    if (!root)  \\n        return 0;\\n    if (root->left && root->right)  \\n        return min(minDepth(root->left), minDepth(root->right))+1;\\n    return max(minDepth(root->left), minDepth(root->right))+1;\\n}\\n\\n```\\n\\n\\n*Time Complexity of BFS/Recursion/DFS = **O(V+E)**   [where V is vertices and E is edges]*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int level = 0;\\n    int minDepth(TreeNode* root) {\\n        if(!root){ return 0;}\\n        \\n        queue<TreeNode*> q;\\n        int level = 0;\\n        \\n        q.push(root);\\n        while(!q.empty()){\\n            int breadth = q.size();\\n            level++;\\n            for(int i=0; i<breadth; i++){\\n                TreeNode* parent = q.front(); \\n                q.pop();\\n                \\n                if(parent->left) q.push(parent->left);\\n                if(parent->right) q.push(parent->right);\\n                \\n                if(!parent->left && !parent->right) return level; //leaf node\\n            }\\n        }\\n        \\n        return level;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint minDepth(TreeNode* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            return 1;\\n        }\\n        else if( root->left != NULL && root->right == NULL){\\n            return minDepth(root->left) + 1;\\n        }\\n        else if( root->left == NULL && root->right != NULL ){\\n            return minDepth(root->right) + 1;\\n        }\\n        else{\\n            return min(minDepth(root->left),minDepth(root->right)) + 1;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(root==NULL){ return 0;}\\n        int l = minDepth(root->left), r = minDepth(root->right);\\n        return 1 + (min(l, r) ? min(l, r) : max(l, r));\\n    }\\n};\\n```\n```\\nint minDepth(TreeNode* root) {\\n    if (!root)  \\n        return 0;\\n    if (root->left && root->right)  \\n        return min(minDepth(root->left), minDepth(root->right))+1;\\n    return max(minDepth(root->left), minDepth(root->right))+1;\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36145,
                "title": "4-lines-short-and-neat-recursive-code-java",
                "content": "    public int minDepth(TreeNode root) {\\n        if(root == null) return 0;\\n        if(root.left == null || root.right == null) \\n        return 1 + Math.max(minDepth(root.left), minDepth(root.right));\\n        return 1 + Math.min(minDepth(root.left), minDepth(root.right));\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int minDepth(TreeNode root) {\\n        if(root == null) return 0;\\n        if(root.left == null || root.right == null) \\n        return 1 + Math.max(minDepth(root.left), minDepth(root.right));\\n        return 1 + Math.min(minDepth(root.left), minDepth(root.right));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36190,
                "title": "easy-reading-12ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        int minDepth(TreeNode* root) {\\n            if (root==nullptr){\\n                return 0;\\n            }\\n            else if (root->right==nullptr||root->left==nullptr){\\n                return max(minDepth(root->left),minDepth(root->right))+1;\\n            }\\n            else{\\n                return min(minDepth(root->left),minDepth(root->right))+1;\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int minDepth(TreeNode* root) {\\n            if (root==nullptr){\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 36317,
                "title": "share-my-clean-java-code",
                "content": "\\n    public int minDepth(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        return helper(root);\\n    }\\n    \\n    public int helper(TreeNode root) {\\n        if(root == null){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(root.left == null && root.right == null){\\n            return 1;\\n        }\\n        \\n        int depthLeft = helper(root.left);\\n        int depthRight = helper(root.right);\\n        \\n        return Math.min(depthLeft, depthRight) + 1;\\n    }",
                "solutionTags": [],
                "code": "\\n    public int minDepth(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        return helper(root);\\n    }\\n    \\n    public int helper(TreeNode root) {\\n        if(root == null){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(root.left == null && root.right == null){\\n            return 1;\\n        }\\n        \\n        int depthLeft = helper(root.left);\\n        int depthRight = helper(root.right);\\n        \\n        return Math.min(depthLeft, depthRight) + 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 905643,
                "title": "python-simple-dfs-explained",
                "content": "All we need to do in this problem is traverse our graph with dfs or bfs and collect information about nodes depths. Let us use axuilary function `dfs` and:\\n\\n1. If we reached `None`, then we return infinity.\\n2. If we reached leaf, then we return `1`, depth of our leaf\\n3. Finally, for node we return minumum of its children depths plus `1`. Note, that if one of the children is not exist, then is value for its depth will be infinity, so in fact we consider only existing children.\\n\\n**Complexity**: time complexity is `O(n)`, space complexity is `O(h)`. \\n\\n**PS** Do not be afraid, that this code is only faster than `5%` of submissions: the reason is that tests were updated resently and results of time distributions are not relevant.\\n\\n```\\nclass Solution:\\n    def minDepth(self, root):\\n        def dfs(node):\\n            if not node: return float(\"inf\")\\n            if not node.left and not node.right: return 1\\n            return min(dfs(node.left), dfs(node.right)) + 1\\n        \\n        res = dfs(root)\\n        return res if res != float(\"inf\") else 0\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minDepth(self, root):\\n        def dfs(node):\\n            if not node: return float(\"inf\")\\n            if not node.left and not node.right: return 1\\n            return min(dfs(node.left), dfs(node.right)) + 1\\n        \\n        res = dfs(root)\\n        return res if res != float(\"inf\") else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383538,
                "title": "javascript-clear-solution",
                "content": "```javascript\\nvar minDepth = function(root) {\\n    if (root === null) return 0;\\n    if (root.left === null) return minDepth(root.right) + 1;\\n    if (root.right === null) return minDepth(root.left) + 1;\\n    return Math.min( minDepth(root.left), minDepth(root.right) ) + 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar minDepth = function(root) {\\n    if (root === null) return 0;\\n    if (root.left === null) return minDepth(root.right) + 1;\\n    if (root.right === null) return minDepth(root.left) + 1;\\n    return Math.min( minDepth(root.left), minDepth(root.right) ) + 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36287,
                "title": "4-line-13-ms-c-code",
                "content": "some minor change to the recursive solution of the maximum depth problem\\n\\n    class Solution {\\n    public:\\n        int minDepth(TreeNode *root) {\\n            if (!root) return 0;\\n            if (!root->left) return 1 + minDepth(root->right);\\n            else if (!root->right) return 1 + minDepth(root->left);\\n            return 1 + min(minDepth(root->left), minDepth(root->right));\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int minDepth(TreeNode *root) {\\n            if (!root) return 0;\\n            if (!root->left) return 1 + minDepth(root->right);\\n            else if (!root->right) return 1 + minDepth(root->left);\\n            return 1 + min(minDepth(root->left), minDepth(root->right));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1467207,
                "title": "python3-recursive-self-understandable-easy-understanding",
                "content": "```\\nclass Solution:\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        def recurse(root):\\n            if root.left is None and root.right is None:\\n                return 1\\n            if root.left is None and root.right:\\n                return 1+recurse(root.right)\\n            if root.left and root.right is  None:\\n                return 1+recurse(root.left)\\n            if root.left and root.right:\\n                return min(1+recurse(root.right),1+recurse(root.left))\\n        return recurse(root) if root else 0\\n```\\n\\n***Please Upvote if you found my solution  helpful  :)***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        def recurse(root):\\n            if root.left is None and root.right is None:\\n                return 1\\n            if root.left is None and root.right:\\n                return 1+recurse(root.right)\\n            if root.left and root.right is  None:\\n                return 1+recurse(root.left)\\n            if root.left and root.right:\\n                return min(1+recurse(root.right),1+recurse(root.left))\\n        return recurse(root) if root else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 629657,
                "title": "python-o-n-by-dfs-and-bfs-85-w-comment",
                "content": "Python O(n) by DFS and BFS \\n\\n---\\n\\n**Implementation** by DFS:\\n\\n```\\nclass Solution:\\n    def minDepth(self, root: TreeNode) -> int:\\n        \\n        if not root:\\n\\t\\t\\t# base case for empty node or empty tree\\n            return 0\\n        \\n        if not root.left and not root.right:\\n\\t\\t\\t# leaf node\\n            return 1\\n        \\n        elif not root.right:\\n\\t\\t\\t# only has left sub-tree\\n            return self.minDepth(root.left) + 1\\n        \\n        elif not root.left:\\n\\t\\t\\t# only has right sub-tree\\n            return self.minDepth(root.right) + 1\\n        \\n        else:\\n\\t\\t\\t# has left sub-tree and right sub-tree\\n            return min( map(self.minDepth, (root.left, root.right) ) ) + 1\\n```\\n\\n---\\n\\n**Implementation** by BFS:\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def minDepth(self, root: TreeNode) -> int:\\n\\n        visit_queue = deque([(root, 1)])\\n\\n        while len(visit_queue) != 0:\\n            # BFS Traversal\\n\\n            next_visit, cur_depth =visit_queue.popleft()\\n\\n            if next_visit is None:\\n                # empty node or empty tree\\n                continue\\n            \\n            if next_visit.left is None and next_visit.right is None:\\n                # reach a leaf node\\n                # get the minimal depth of binary tree, early return\\n                return cur_depth\\n\\n            #append left and right child into visit_queue, increase current depth by 1\\n            visit_queue.append( (next_visit.left, cur_depth+1) )\\n            visit_queue.append( (next_visit.right, cur_depth + 1) )\\n\\n        # depth 0 for empty-tree\\n        return 0\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #104 Maximum Depth of Binary Tree ](https://leetcode.com/problems/maximum-depth-of-binary-tree)\\n\\n[Leetcode #559 Maximum Depth of N-ary Tree](https://leetcode.com/problems/maximum-depth-of-n-ary-tree/)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minDepth(self, root: TreeNode) -> int:\\n        \\n        if not root:\\n\\t\\t\\t# base case for empty node or empty tree\\n            return 0\\n        \\n        if not root.left and not root.right:\\n\\t\\t\\t# leaf node\\n            return 1\\n        \\n        elif not root.right:\\n\\t\\t\\t# only has left sub-tree\\n            return self.minDepth(root.left) + 1\\n        \\n        elif not root.left:\\n\\t\\t\\t# only has right sub-tree\\n            return self.minDepth(root.right) + 1\\n        \\n        else:\\n\\t\\t\\t# has left sub-tree and right sub-tree\\n            return min( map(self.minDepth, (root.left, root.right) ) ) + 1\\n```\n```\\nfrom collections import deque\\nclass Solution:\\n    def minDepth(self, root: TreeNode) -> int:\\n\\n        visit_queue = deque([(root, 1)])\\n\\n        while len(visit_queue) != 0:\\n            # BFS Traversal\\n\\n            next_visit, cur_depth =visit_queue.popleft()\\n\\n            if next_visit is None:\\n                # empty node or empty tree\\n                continue\\n            \\n            if next_visit.left is None and next_visit.right is None:\\n                # reach a leaf node\\n                # get the minimal depth of binary tree, early return\\n                return cur_depth\\n\\n            #append left and right child into visit_queue, increase current depth by 1\\n            visit_queue.append( (next_visit.left, cur_depth+1) )\\n            visit_queue.append( (next_visit.right, cur_depth + 1) )\\n\\n        # depth 0 for empty-tree\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502345,
                "title": "java-recursive-explained-beats-100",
                "content": "Simple recursive solution - the only catch is that in case one of the children is null need to drop it from result and return only the second child\\n```\\n    public int minDepth(TreeNode root) {\\n\\t   //base case\\n       if (root == null)\\n            return 0;\\n\\t\\t//if there is only right child get depth of it\\n        if (root.left == null)\\n            return minDepth(root.right) + 1;\\n\\t\\t//similarly if there is only left child  get depth of it\\n        else if (root.right == null)\\n            return minDepth(root.left) + 1;\\n\\t\\t//in case there are both  get the min of both\\n        return Math.min(minDepth(root.right), minDepth(root.left)) + 1; \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n    public int minDepth(TreeNode root) {\\n\\t   //base case\\n       if (root == null)\\n            return 0;\\n\\t\\t//if there is only right child get depth of it\\n        if (root.left == null)\\n            return minDepth(root.right) + 1;\\n\\t\\t//similarly if there is only left child  get depth of it\\n        else if (root.right == null)\\n            return minDepth(root.left) + 1;\\n\\t\\t//in case there are both  get the min of both\\n        return Math.min(minDepth(root.right), minDepth(root.left)) + 1; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3743211,
                "title": "bfs-dfs-100-fast-why-bfs-explained-c-java-python-video",
                "content": "\\n\\n# Intuition\\n<!-- Describe your approach to solving the problem. -->\\nTree question so it can solve by different traversal here order of nots doesnot matter because we are only calculating depth so we can solve by BfS and DFS\\n\\nFor detailed explanation you can refer to my youtube channel (Hindi Language)\\nhttps://youtu.be/oeWzqODtq3k\\n or link in my profile.Here,you can find any solution in playlists monthwise from June 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\nor\\nsearch \\uD83D\\uDC49`Substring With Largest Variance by Let\\'s Code Together` on youtube\\n\\n# Why BFS is preffered over DFS\\n\\nThe efficiency of breadth-first search (BFS) and depth-first search (DFS) depends on the structure and size of the tree or graph being traversed. In the given code, BFS is likely to be faster than DFS in finding the minimum depth of a binary tree for the following reasons:\\n\\n1. Early termination: In BFS, the traversal starts from the root and explores all the nodes level by level. By using a queue, it ensures that nodes at the same level are processed before moving to the next level. This means that when we encounter a leaf node (a node without any children), we can immediately return the current depth as the minimum depth. BFS has a higher chance of finding the minimum depth earlier in the traversal, leading to early termination.\\n\\n2. Reduced search space: In BFS, we explore all nodes at the current level before moving to the next level. This property makes BFS more suitable for finding the minimum depth because it reduces the search space at each level. In contrast, DFS explores one branch as deeply as possible before backtracking. If the tree is unbalanced or skewed, DFS may explore a long branch before finding a leaf node, resulting in unnecessary exploration of a larger portion of the tree.\\n\\n3. Space complexity: BFS uses a queue to store the nodes, and the space complexity is proportional to the maximum number of nodes at any level. In the worst case, this can be equal to the maximum width of the tree. On the other hand, DFS typically uses the call stack for recursive calls, which can grow linearly with the depth of the tree. If the tree is unbalanced and has a large depth, DFS may require more stack space, potentially causing stack overflow.\\n\\nHowever, it\\'s important to note that the relative efficiency of BFS and DFS can vary depending on the specific characteristics of the tree or graph being traversed. In some cases, DFS may be more efficient, especially when the desired node or solution is likely to be found deeper in the search space. Both algorithms have their strengths and weaknesses, and the choice between them depends on the problem\\'s requirements and the structure of the input data.\\n\\n# Code 1 BFS\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if (root==NULL) \\n            return 0;\\n\\n        int mndepth = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while (!q.empty()) {\\n            int size = q.size();\\n            mndepth++;\\n          while (size--) {\\n                TreeNode* cur = q.front(); \\n                q.pop();\\n                if (cur->left)\\n                    q.push(cur->left);\\n                if (cur->right)\\n                    q.push(cur->right);\\n                if (cur->left == NULL && cur->right == NULL) {\\n                    return mndepth;\\n                }\\n            }\\n        }\\n        return mndepth;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity:$$O(mindepth)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code 2 DFS\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n       if(root==NULL){\\n           return 0;\\n       }\\n      if(!root->left && !root->right){\\n          return 1;\\n      }\\n     if(root->left==NULL){\\n         return 1+minDepth(root->right);\\n     }\\n     if(root->right==NULL){\\n         return 1+minDepth(root->left);\\n     }\\n      return 1 +min (minDepth(root->left),minDepth(root->right)); \\n    }\\n};\\n```\\n# Complexity\\n- Time complexity:$$O(maxdepth)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(maxdepth)$$ (stack space for recursive call)+$$O(1)$$ (extra space)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![upvote-this-you.jpg](https://assets.leetcode.com/users/images/18e8aabc-7b66-4019-a1d5-01a36ea03032_1688961678.886742.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if (root==NULL) \\n            return 0;\\n\\n        int mndepth = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while (!q.empty()) {\\n            int size = q.size();\\n            mndepth++;\\n          while (size--) {\\n                TreeNode* cur = q.front(); \\n                q.pop();\\n                if (cur->left)\\n                    q.push(cur->left);\\n                if (cur->right)\\n                    q.push(cur->right);\\n                if (cur->left == NULL && cur->right == NULL) {\\n                    return mndepth;\\n                }\\n            }\\n        }\\n        return mndepth;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n       if(root==NULL){\\n           return 0;\\n       }\\n      if(!root->left && !root->right){\\n          return 1;\\n      }\\n     if(root->left==NULL){\\n         return 1+minDepth(root->right);\\n     }\\n     if(root->right==NULL){\\n         return 1+minDepth(root->left);\\n     }\\n      return 1 +min (minDepth(root->left),minDepth(root->right)); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743042,
                "title": "c-bfs-fast-solution",
                "content": "# Approach 1: BFS (Faster Solution)\\n# Complexity\\n**n** is the amount of nodes in the binary tree.\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if (!root) \\n            return 0;\\n\\n        int depth = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while (!q.empty()) {\\n            int size = q.size();\\n            depth++;\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* cur = q.front(); \\n                q.pop();\\n                if (cur->left)\\n                    q.push(cur->left);\\n                if (cur->right)\\n                    q.push(cur->right);\\n                if (cur->left == NULL && cur->right == NULL) {\\n                    return depth;\\n                }\\n            }\\n        }\\n        return depth;\\n    }\\n};\\n\\n```\\n# Approach 2: DFS\\n# Complexity\\n**n** is the amount of nodes in the binary tree.\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if (!root) {\\n            return 0;\\n        } else if (root->left == NULL && root->right == NULL) {\\n            return 1;\\n        } else if (root->left == NULL) {\\n            return 1 + minDepth(root->right);\\n        } else if (root->right == NULL) {\\n            return 1 + minDepth(root->left);\\n        }// we now know both right and left are not NULL\\n        return min(minDepth(root->left), minDepth(root->right)) + 1;\\n    }\\n};\\n```\\n```\\n       1\\n     /   \\\\\\n    2     3\\n   / \\\\   \\n  4   5 \\n```\\n# Why BFS is faster than DFS\\n- The first code is faster(BFS) because it processes the tree level by level, checking if each node is a leaf node. If it is, it returns the depth. This avoids unnecessary calculations. The second code(DFS) uses recursion and may do extra work by repeating calculations, which makes it slower.\\n- To add the DFS approach will always go and check every node. Starting from the nodes without children (4 and 5), it will recursively check the minimum depth from the left and right sides. It will continue this process until it reaches the top again, which is node 1. The answer will be the minimum depth returned from the left and right sides of each node. In this example, the DFS approach will go through nodes 1, 2, 4, 5, and 3 to determine the minimum depth.\\n- The BFS approach will go through and check only nodes 1, 2, and 3. At the end of the code, it checks if nodes 2 and 3 have any children. Since node 3 has no children, the BFS code returns the level (depth) at which it currently is, which is 2.\\n\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if (!root) \\n            return 0;\\n\\n        int depth = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while (!q.empty()) {\\n            int size = q.size();\\n            depth++;\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* cur = q.front(); \\n                q.pop();\\n                if (cur->left)\\n                    q.push(cur->left);\\n                if (cur->right)\\n                    q.push(cur->right);\\n                if (cur->left == NULL && cur->right == NULL) {\\n                    return depth;\\n                }\\n            }\\n        }\\n        return depth;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if (!root) {\\n            return 0;\\n        } else if (root->left == NULL && root->right == NULL) {\\n            return 1;\\n        } else if (root->left == NULL) {\\n            return 1 + minDepth(root->right);\\n        } else if (root->right == NULL) {\\n            return 1 + minDepth(root->left);\\n        }// we now know both right and left are not NULL\\n        return min(minDepth(root->left), minDepth(root->right)) + 1;\\n    }\\n};\\n```\n```\\n       1\\n     /   \\\\\\n    2     3\\n   / \\\\   \\n  4   5 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 228109,
                "title": "javascript-simple-bfs-100",
                "content": "```\\nvar minDepth = function(root) {\\n    if(!root) return 0;\\n    let depth = 1;\\n    let queue = [root];\\n    if(!root.left && !root.right) return depth;\\n\\n    while(queue.length > 0 ){\\n      let queueLength = queue.length;\\n\\n      for(let i = 0; i < queueLength; i++){\\n        let node = queue.shift();\\n\\n        if(!node.left && !node.right) return depth;\\n        else{\\n          if(node.left) queue.push(node.left);\\n          if(node.right) queue.push(node.right);\\n        }\\n      }\\n\\n      depth++;\\n    }\\n\\n    return depth;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar minDepth = function(root) {\\n    if(!root) return 0;\\n    let depth = 1;\\n    let queue = [root];\\n    if(!root.left && !root.right) return depth;\\n\\n    while(queue.length > 0 ){\\n      let queueLength = queue.length;\\n\\n      for(let i = 0; i < queueLength; i++){\\n        let node = queue.shift();\\n\\n        if(!node.left && !node.right) return depth;\\n        else{\\n          if(node.left) queue.push(node.left);\\n          if(node.right) queue.push(node.right);\\n        }\\n      }\\n\\n      depth++;\\n    }\\n\\n    return depth;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3300840,
                "title": "easiest-solution-out-there-in-5-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nPlsssssss Up Vote -> \\uD83D\\uDE2D\\n# Code\\n```\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        if(root==null)  return 0;\\n        if(root.left==null && root.right==null) return 1;\\n        if(root.left==null) return 1+minDepth(root.right);\\n        if(root.right==null) return 1+minDepth(root.left);\\n        return Math.min(minDepth(root.left), minDepth(root.right))+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        if(root==null)  return 0;\\n        if(root.left==null && root.right==null) return 1;\\n        if(root.left==null) return 1+minDepth(root.right);\\n        if(root.right==null) return 1+minDepth(root.left);\\n        return Math.min(minDepth(root.left), minDepth(root.right))+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188412,
                "title": "problem-111-c-bfs-dfs-solutions-with-explanations",
                "content": "### Solution 1: Recursion/DFS\\n\\nRecursion is a natural choice here, as it often is for binary trees. If we know the depth (height?) of each of our children, we can take the smaller one and add 1 to get our current node\\'s depth. So we implement that idea recursively.\\n\\nWe just need to be careful not to count the depth of dead ends. Imagine a completely unbalanced tree i.e. no node has left children. Then the minimum depth should not consider going left from the root to be a complete path because it did not reach a leaf. So we only recurse on a child if it\\'s not null.\\n\\n```cpp\\nint minDepth(TreeNode* root) {\\n  if (!root) return 0;\\n  if (!root->left && !root->right) return 1;\\n\\n  int left = (root->left ? minDepth(root->left) : INT_MAX);\\n  int right = (root->right ? minDepth(root->right) : INT_MAX);\\n\\n  return 1 + min(left, right);\\n}\\n```\\n\\n### Solution 2: Queue/BFS\\n\\nWe can also do BFS by using a queue. We just need to be careful to process one layer at a time so that we can keep track of the current depth. We do that by noticing that at the beginning of each iteration of the while loop, the nodes in the queue are all the nodes of the current layer.\\n\\n```cpp\\nint minDepth(TreeNode* root) {\\n  if (!root) return 0;\\n\\n  queue<TreeNode*> q;\\n  q.push(root);\\n  int depth = 1;\\n\\n  while (!q.empty()) {\\n    int level_size = q.size();\\n    for (int i = 0; i < level_size; i++) {\\n      TreeNode* curr_node = q.front();\\n      q.pop();\\n      if (!curr_node->left && !curr_node->right)\\n        return depth;  // first leaf we reach\\n\\n      if (curr_node->left) q.push(curr_node->left);\\n      if (curr_node->right) q.push(curr_node->right);\\n    }\\n\\n    depth++;\\n  }\\n\\n  return depth;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nint minDepth(TreeNode* root) {\\n  if (!root) return 0;\\n  if (!root->left && !root->right) return 1;\\n\\n  int left = (root->left ? minDepth(root->left) : INT_MAX);\\n  int right = (root->right ? minDepth(root->right) : INT_MAX);\\n\\n  return 1 + min(left, right);\\n}\\n```\n```cpp\\nint minDepth(TreeNode* root) {\\n  if (!root) return 0;\\n\\n  queue<TreeNode*> q;\\n  q.push(root);\\n  int depth = 1;\\n\\n  while (!q.empty()) {\\n    int level_size = q.size();\\n    for (int i = 0; i < level_size; i++) {\\n      TreeNode* curr_node = q.front();\\n      q.pop();\\n      if (!curr_node->left && !curr_node->right)\\n        return depth;  // first leaf we reach\\n\\n      if (curr_node->left) q.push(curr_node->left);\\n      if (curr_node->right) q.push(curr_node->right);\\n    }\\n\\n    depth++;\\n  }\\n\\n  return depth;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36204,
                "title": "c-dfs-and-bfs-solutions",
                "content": "        \\n    // DFS\\n    int minDepth(TreeNode* root) {\\n        if (!root)  \\n            return 0;\\n        if (root->left && root->right)  \\n            return min(minDepth(root->left), minDepth(root->right))+1;\\n        return max(minDepth(root->left), minDepth(root->right))+1;\\n    }\\n    \\n    // BFS\\n    int minDepth1(TreeNode *root) {\\n        int res = 0;\\n        queue<TreeNode *> myQueue;\\n        if (root)\\n            myQueue.push(root);\\n        while (!myQueue.empty()) {\\n            int l = myQueue.size();\\n            res++;\\n            for (int i = 0; i < l; i++) {\\n                TreeNode *tmp = myQueue.front();\\n                if (!(tmp->left) && !(tmp->right))\\n                    return res;\\n                if (tmp->left)\\n                    myQueue.push(tmp->left);\\n                if (tmp->right)\\n                    myQueue.push(tmp->right);\\n                myQueue.pop();\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "        \\n    // DFS\\n    int minDepth(TreeNode* root) {\\n        if (!root)  \\n            return 0;\\n        if (root->left && root->right)  \\n            return min(minDepth(root->left), minDepth(root->right))+1;\\n        return max(minDepth(root->left), minDepth(root->right))+1;\\n    }\\n    \\n    // BFS\\n    int minDepth1(TreeNode *root) {\\n        int res = 0;\\n        queue<TreeNode *> myQueue;\\n        if (root)\\n            myQueue.push(root);\\n        while (!myQueue.empty()) {\\n            int l = myQueue.size();\\n            res++;\\n            for (int i = 0; i < l; i++) {\\n                TreeNode *tmp = myQueue.front();\\n                if (!(tmp->left) && !(tmp->right))\\n                    return res;\\n                if (tmp->left)\\n                    myQueue.push(tmp->left);\\n                if (tmp->right)\\n                    myQueue.push(tmp->right);\\n                myQueue.pop();\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3743288,
                "title": "c-easy-dfs",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int depth(TreeNode* root){\\n        if(root==NULL)return INT_MAX;\\n        if(root->left==NULL && root->right==NULL)return 1;\\n        return 1 + min(depth(root->left),depth(root->right));\\n    }\\n    int minDepth(TreeNode* root) {\\n        if(root==NULL)return 0;\\n        return depth(root);\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/4a4d03a5-a3fb-4513-80b9-3b4ec64eb7f3_1688958728.7707012.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int depth(TreeNode* root){\\n        if(root==NULL)return INT_MAX;\\n        if(root->left==NULL && root->right==NULL)return 1;\\n        return 1 + min(depth(root->left),depth(root->right));\\n    }\\n    int minDepth(TreeNode* root) {\\n        if(root==NULL)return 0;\\n        return depth(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158303,
                "title": "python-dfs",
                "content": "### 111. Minimum Depth of Binary Tree\\n```\\n> Time Complexity O(N)\\n> Space Complexity O(1)\\n```\\n\\n\\u8FD9\\u91CC\\u601D\\u8DEF\\u5F88\\u7B80\\u5355\\uFF0C\\u5206\\u5236\\u4EE5\\u540E\\u518D\\u8FD4\\u56DE\\u7684\\u65F6\\u5019\\u589E\\u52A0\\u5C42\\u7EA7\\u3002\\n\\u552F\\u4E00\\u8981\\u6CE8\\u610F\\u7684\\u662F\\u4E00\\u5B9A\\u8981\\u6709\\u4E2AEdge\\u60C5\\u51B5\\uFF0C\\u5982\\u679C\\u5DE6\\u53F3\\u5B69\\u5B50\\u4E00\\u8FB9\\u4E3A\\u7A7A\\uFF0C\\u4F8B\\u5982\\u5730\\u4E0B\\u767D\\u677F\\u7684\\u4F8B\\u5B50\\uFF0C\\u5C31\\u4E0D\\u80FD\\u8FD4\\u56DE`min(left, right)`\\uFF0C\\u56E0\\u4E3A\\u7A7A\\u7684\\u4E00\\u8FB9\\u4E3A0\\uFF0C\\u6240\\u4EE5\\u4F1A\\u8FD4\\u56DE\\u9519\\u8BEF\\u7684\\u6570\\u3002\\n\\u8FD9\\u79CDedge\\u6211\\u4EEC\\u5219\\u8FD4\\u56DE: `left + right + 1`\\n\\n```python\\nclass Solution(object):\\n    def minDepth(self, root):\\n        if not root: \\n            return 0;\\n        left = self.minDepth(root.left);\\n        right = self.minDepth(root.right);\\n        if left == 0 or right == 0:\\n            return left + right + 1\\n        return min(left, right) + 1\\n```\\n<br><br>\\n#### **\\u767D\\u677F**\\n![](https://raw.githubusercontent.com/yuzhoujr/spazzatura/master/img_box/111.jpeg)",
                "solutionTags": [],
                "code": "```\\n> Time Complexity O(N)\\n> Space Complexity O(1)\\n```\n```python\\nclass Solution(object):\\n    def minDepth(self, root):\\n        if not root: \\n            return 0;\\n        left = self.minDepth(root.left);\\n        right = self.minDepth(root.right);\\n        if left == 0 or right == 0:\\n            return left + right + 1\\n        return min(left, right) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520998,
                "title": "c-simple-recursive-solution",
                "content": "**C++ :**\\n\\n```\\nint minDepth(TreeNode* root) {\\n\\tif(!root) return 0;\\n\\tif(!root -> left && !root -> right) return 1;\\n\\tif(!root -> left) return 1 + minDepth(root -> right);\\n\\tif(!root -> right) return 1 + minDepth(root -> left);\\n\\telse\\n\\t\\treturn 1 + min(minDepth(root -> left), minDepth(root -> right));\\n}\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nint minDepth(TreeNode* root) {\\n\\tif(!root) return 0;\\n\\tif(!root -> left && !root -> right) return 1;\\n\\tif(!root -> left) return 1 + minDepth(root -> right);\\n\\tif(!root -> right) return 1 + minDepth(root -> left);\\n\\telse\\n\\t\\treturn 1 + min(minDepth(root -> left), minDepth(root -> right));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1087559,
                "title": "python-solutions-bfs-and-dfs",
                "content": "bfs:\\n```\\nclass Solution:\\n    def minDepth(self, root: TreeNode) -> int:\\n        #      \\n        ## level order transversal\\n        if not root: return 0\\n        que,depth = deque([root]),1\\n        while que:\\n            for i in range(len(que)):\\n                node = que.popleft()\\n                if not node: continue\\n                elif not (node.left or node.right):\\n                    return depth\\n                else:\\n                    que.append(node.left)\\n                    que.append(node.right)\\n            depth += 1\\n        return depth\\n```\\n\\ndfs:\\n```\\nclass Solution:\\n    def minDepth(self, root: TreeNode) -> int:\\n        #\\n        ## dfs\\n        def dfs(root):\\n            if not root: return 0\\n            left = dfs(root.left)\\n            right = dfs(root.right)\\n            if left == 0: return right+1\\n            if right == 0: return left+1\\n            return min(left,right)+1\\n        return dfs(root)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minDepth(self, root: TreeNode) -> int:\\n        #      \\n        ## level order transversal\\n        if not root: return 0\\n        que,depth = deque([root]),1\\n        while que:\\n            for i in range(len(que)):\\n                node = que.popleft()\\n                if not node: continue\\n                elif not (node.left or node.right):\\n                    return depth\\n                else:\\n                    que.append(node.left)\\n                    que.append(node.right)\\n            depth += 1\\n        return depth\\n```\n```\\nclass Solution:\\n    def minDepth(self, root: TreeNode) -> int:\\n        #\\n        ## dfs\\n        def dfs(root):\\n            if not root: return 0\\n            left = dfs(root.left)\\n            right = dfs(root.right)\\n            if left == 0: return right+1\\n            if right == 0: return left+1\\n            return min(left,right)+1\\n        return dfs(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265750,
                "title": "clean-c-solutions-using-dfs-and-bfs-approaches",
                "content": "# Depth-First Search\\n```\\npublic class Solution \\n{\\n    public int MinDepth(TreeNode root)\\n    {\\n        if (root == null)\\n        {\\n            return 0;\\n        }\\n\\n        var leftMinDepth = MinDepth(root.left);\\n        var rightMinDepth = MinDepth(root.right);\\n\\n        if (leftMinDepth == 0 || rightMinDepth == 0)\\n        {\\n            return Math.Max(leftMinDepth, rightMinDepth) + 1;\\n        }\\n\\n        return Math.Min(leftMinDepth, rightMinDepth) + 1;\\n    }\\n}\\n```\\n\\n# Breadth-First Search\\n```\\npublic class Solution \\n{\\n    public int MinDepth(TreeNode root)\\n    {\\n        if (root == null)\\n        {\\n            return 0;\\n        }\\n\\n        var queue = new Queue<TreeNode>();\\n        queue.Enqueue(root);\\n\\n        var depth = 0;\\n\\n        while (queue.Count != 0)\\n        {\\n            var size = queue.Count;\\n\\n            for (var i = 0; i < size; i++)\\n            {\\n                var current = queue.Dequeue();\\n\\n                if (current.left != null)\\n                {\\n                    queue.Enqueue(current.left);\\n                }\\n\\n                if (current.right != null)\\n                {\\n                    queue.Enqueue(current.right);\\n                }\\n\\n                if (current.left == null && current.right == null)\\n                {\\n                    return depth + 1;\\n                }\\n            }\\n\\n            depth++;\\n        }\\n\\n        return 0;\\n    }\\n}\\n```\\n\\n![pleaseupvote.jpg](https://assets.leetcode.com/users/images/334c77cb-43d1-4abf-86fd-57de73540297_1678125692.4437.jpeg)\\n",
                "solutionTags": [
                    "C#",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int MinDepth(TreeNode root)\\n    {\\n        if (root == null)\\n        {\\n            return 0;\\n        }\\n\\n        var leftMinDepth = MinDepth(root.left);\\n        var rightMinDepth = MinDepth(root.right);\\n\\n        if (leftMinDepth == 0 || rightMinDepth == 0)\\n        {\\n            return Math.Max(leftMinDepth, rightMinDepth) + 1;\\n        }\\n\\n        return Math.Min(leftMinDepth, rightMinDepth) + 1;\\n    }\\n}\\n```\n```\\npublic class Solution \\n{\\n    public int MinDepth(TreeNode root)\\n    {\\n        if (root == null)\\n        {\\n            return 0;\\n        }\\n\\n        var queue = new Queue<TreeNode>();\\n        queue.Enqueue(root);\\n\\n        var depth = 0;\\n\\n        while (queue.Count != 0)\\n        {\\n            var size = queue.Count;\\n\\n            for (var i = 0; i < size; i++)\\n            {\\n                var current = queue.Dequeue();\\n\\n                if (current.left != null)\\n                {\\n                    queue.Enqueue(current.left);\\n                }\\n\\n                if (current.right != null)\\n                {\\n                    queue.Enqueue(current.right);\\n                }\\n\\n                if (current.left == null && current.right == null)\\n                {\\n                    return depth + 1;\\n                }\\n            }\\n\\n            depth++;\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644685,
                "title": "java-simple-solution-dfs",
                "content": "# PLEASE UPVOTE IF IT IS HELPFULL\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n       if(root == null) return 0;\\n\\n       int left = minDepth(root.left);\\n       int right = minDepth(root.right);\\n\\n       return (left == 0 || right == 0) ? left + right + 1 : Math.min(left, right) + 1; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n       if(root == null) return 0;\\n\\n       int left = minDepth(root.left);\\n       int right = minDepth(root.right);\\n\\n       return (left == 0 || right == 0) ? left + right + 1 : Math.min(left, right) + 1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928068,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(n), where n is the number of nodes in the binary tree.\\n\\n    func minDepth(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n        \\n        var queue: [TreeNode] = [root]\\n        var index = 1\\n        \\n        loop:\\n        while queue.count > 0 {\\n            var level: [TreeNode] = []\\n            for node in queue {\\n                if node.left == nil && node.right == nil { break loop }\\n                if let left = node.left { level.append(left) }\\n                if let right = node.right { level.append(right) }\\n            }\\n            queue = level\\n            index += 1\\n        }\\n        \\n        return index\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(n), where n is the number of nodes in the binary tree.\\n\\n    func minDepth(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n        \\n        var queue: [TreeNode] = [root]\\n        var index = 1\\n        \\n        loop:\\n        while queue.count > 0 {\\n            var level: [TreeNode] = []\\n            for node in queue {\\n                if node.left == nil && node.right == nil { break loop }\\n                if let left = node.left { level.append(left) }\\n                if let right = node.right { level.append(right) }\\n            }\\n            queue = level\\n            index += 1\\n        }\\n        \\n        return index\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317316,
                "title": "java-simple-solution-2-approach-o-n-with-explanation",
                "content": "```\\n1)\\n//Recursive Approach \\nclass Solution\\n{\\n    int minDepth= Integer.MAX_VALUE;//identity of minimum//global\\n    public int minDepth(TreeNode root) \\n    {\\n        if(root == null)//base case when we are provide with a null graph \\n            return 0;\\n        depthCal(root, 1);//it calculates the min depth on the basis of node \\n        return minDepth;\\n    }\\n    public int depthCal(TreeNode root, int height)\\n    {//we are using the postorder traversal(LEFT RIGHT ROOT) because we want to know the child information first and then the parent informaion \\n        if(root == null)//base case when we reach to null node, we return 0\\n            return 0;\\n        \\n        int left= depthCal(root.left, height + 1);//traversing down the left subtree and parallelly calulating the height//knowing about the left child //LEFT\\n        int right= depthCal(root.right, height + 1);//traversing down the right subtree and parallelly calulating the height//knowing about the right child //RIGHT\\n         \\n        //ROOT\\n        if(root.left == null && root.right == null)//calculating the minimum depth//leaf node\\n            minDepth= Math.min(minDepth, height);//comparing with previous depth and updating \\n        \\n        return height;//returmning the currnt height \\n    }\\n}//Please do Upvote, it helps a lot \\n```\\n```\\n2)\\n//BSF Approach\\nclass Solution\\n{//BFS\\n    public int minDepth(TreeNode root) \\n    {\\n        if(root==null)//base case \\n            return 0;\\n        \\n        Queue<TreeNode> q=new ArrayDeque<>();//Queue to store the child and parent and popping them  \\n        \\n        q.offer(root);\\n        int depth=1;//level 1\\n        \\n        while(!q.isEmpty())//till the Queueis Not Empty \\n        {\\n            int size= q.size();//popping constraint \\n            while(size-->0)\\n            {\\n               TreeNode temp=q.peek();\\n            \\n               if(temp.left==null && temp.right==null)//leaf node \\n                   return depth;//depth  contains the node (like ST)\\n               else \\n               {//pushing thechils node if it is not null \\n                  if(temp.left!= null)\\n                     q.offer(temp.left);\\n            \\n                  if(temp.right!= null)\\n                      q.offer(temp.right);\\n                }\\n                q.poll();//popping the node which has been checked \\n            }\\n            depth+=1;//increasing the level \\n        }\\n        return 0;\\n    }\\n}//Please do Upvote, it helps a lot \\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\n1)\\n//Recursive Approach \\nclass Solution\\n{\\n    int minDepth= Integer.MAX_VALUE;//identity of minimum//global\\n    public int minDepth(TreeNode root) \\n    {\\n        if(root == null)//base case when we are provide with a null graph \\n            return 0;\\n        depthCal(root, 1);//it calculates the min depth on the basis of node \\n        return minDepth;\\n    }\\n    public int depthCal(TreeNode root, int height)\\n    {//we are using the postorder traversal(LEFT RIGHT ROOT) because we want to know the child information first and then the parent informaion \\n        if(root == null)//base case when we reach to null node, we return 0\\n            return 0;\\n        \\n        int left= depthCal(root.left, height + 1);//traversing down the left subtree and parallelly calulating the height//knowing about the left child //LEFT\\n        int right= depthCal(root.right, height + 1);//traversing down the right subtree and parallelly calulating the height//knowing about the right child //RIGHT\\n         \\n        //ROOT\\n        if(root.left == null && root.right == null)//calculating the minimum depth//leaf node\\n            minDepth= Math.min(minDepth, height);//comparing with previous depth and updating \\n        \\n        return height;//returmning the currnt height \\n    }\\n}//Please do Upvote, it helps a lot \\n```\n```\\n2)\\n//BSF Approach\\nclass Solution\\n{//BFS\\n    public int minDepth(TreeNode root) \\n    {\\n        if(root==null)//base case \\n            return 0;\\n        \\n        Queue<TreeNode> q=new ArrayDeque<>();//Queue to store the child and parent and popping them  \\n        \\n        q.offer(root);\\n        int depth=1;//level 1\\n        \\n        while(!q.isEmpty())//till the Queueis Not Empty \\n        {\\n            int size= q.size();//popping constraint \\n            while(size-->0)\\n            {\\n               TreeNode temp=q.peek();\\n            \\n               if(temp.left==null && temp.right==null)//leaf node \\n                   return depth;//depth  contains the node (like ST)\\n               else \\n               {//pushing thechils node if it is not null \\n                  if(temp.left!= null)\\n                     q.offer(temp.left);\\n            \\n                  if(temp.right!= null)\\n                      q.offer(temp.right);\\n                }\\n                q.poll();//popping the node which has been checked \\n            }\\n            depth+=1;//increasing the level \\n        }\\n        return 0;\\n    }\\n}//Please do Upvote, it helps a lot \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147375,
                "title": "python-easy-to-understand-dfs-logic-with-comments",
                "content": "This is an easy to understand basic DFS approach.\\nat any node the recurions basically tries to find out the min depth (either from left path or from right path) and add 1 for current node and then return back to previous function call as the overall minimum depth for that particular node.\\n**If only one child exists then only that path is considered** \\n\\n```\\nclass Solution:\\n    def minDepth(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0  # return 0 as depth if empty tree\\n        elif not root.left and not root.right:\\n            return 1 # base case handling\\n        elif not root.left:\\n            return self.minDepth(root.right)+1 # if no left child then only path is right, so consider right depth\\n        elif not root.right:\\n            return self.minDepth(root.left)+1  # if no right child then only path is left, so consider left depth\\n        else:\\n            return min(self.minDepth(root.left), self.minDepth(root.right))+1 # if both child exist then pick the minimum one, add one for current node and return min depth\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def minDepth(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0  # return 0 as depth if empty tree\\n        elif not root.left and not root.right:\\n            return 1 # base case handling\\n        elif not root.left:\\n            return self.minDepth(root.right)+1 # if no left child then only path is right, so consider right depth\\n        elif not root.right:\\n            return self.minDepth(root.left)+1  # if no right child then only path is left, so consider left depth\\n        else:\\n            return min(self.minDepth(root.left), self.minDepth(root.right))+1 # if both child exist then pick the minimum one, add one for current node and return min depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36202,
                "title": "c-bfs-solution",
                "content": "    int minDepth(TreeNode* root) {\\n        if (root == NULL) return 0;\\n        queue<pair<TreeNode*, int>> q;\\n        q.push(pair<TreeNode*, int>(root, 1));\\n        while (!q.empty()) {\\n            auto temp = q.front();\\n            q.pop();\\n            TreeNode* cur = temp.first;\\n            int depth = temp.second;\\n            if (cur->left == NULL && cur->right == NULL) return depth;\\n            if (cur->left != NULL) {\\n                q.push(pair<TreeNode*, int>(cur->left, depth + 1));\\n            }\\n            if (cur->right != NULL) {\\n                q.push(pair<TreeNode*, int>(cur->right, depth + 1));\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    int minDepth(TreeNode* root) {\\n        if (root == NULL) return 0;\\n        queue<pair<TreeNode*, int>> q;\\n        q.push(pair<TreeNode*, int>(root, 1));\\n        while (!q.empty()) {\\n            auto temp = q.front();\\n            q.pop();\\n            TreeNode* cur = temp.first;\\n            int depth = temp.second;\\n            if (cur->left == NULL && cur->right == NULL) return depth;\\n            if (cur->left != NULL) {\\n                q.push(pair<TreeNode*, int>(cur->left, depth + 1));\\n            }\\n            if (cur->right != NULL) {\\n                q.push(pair<TreeNode*, int>(cur->right, depth + 1));\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1439829,
                "title": "js-heavily-commented-bfs-and-dfs-solution",
                "content": "DFS:\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar minDepth = function(root) {\\n    // If node is empty return 0\\n    if (!root) return 0;\\n    \\n    // If the left node is empty DFS into right node\\n    if (!root.left) return minDepth(root.right) + 1;\\n    \\n    // If the right node is empty DFS into left node\\n    if (!root.right) return minDepth(root.left) + 1;\\n    \\n    // If neither left nor right nodes are empty, find the minium of the each DFS traversal\\n    return Math.min(minDepth(root.left), minDepth(root.right)) + 1;\\n};\\n```\\n\\nBFS:\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar minDepth = function(root) {\\n    if (!root) return [];\\n    \\n    let queue = [root];\\n    let depth = 1;\\n    \\n    while (queue[0]) {\\n        let size = queue.length;\\n        \\n        while (size--) {\\n            let curr = queue.shift(); // dequeue\\n            if (!curr.left && !curr.right) return depth;\\n            \\n            if (curr.left) queue.push(curr.left); // enqueue\\n            if (curr.right) queue.push(curr.right); // enqueue\\n            \\n        }\\n        \\n        depth++;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar minDepth = function(root) {\\n    // If node is empty return 0\\n    if (!root) return 0;\\n    \\n    // If the left node is empty DFS into right node\\n    if (!root.left) return minDepth(root.right) + 1;\\n    \\n    // If the right node is empty DFS into left node\\n    if (!root.right) return minDepth(root.left) + 1;\\n    \\n    // If neither left nor right nodes are empty, find the minium of the each DFS traversal\\n    return Math.min(minDepth(root.left), minDepth(root.right)) + 1;\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar minDepth = function(root) {\\n    if (!root) return [];\\n    \\n    let queue = [root];\\n    let depth = 1;\\n    \\n    while (queue[0]) {\\n        let size = queue.length;\\n        \\n        while (size--) {\\n            let curr = queue.shift(); // dequeue\\n            if (!curr.left && !curr.right) return depth;\\n            \\n            if (curr.left) queue.push(curr.left); // enqueue\\n            if (curr.right) queue.push(curr.right); // enqueue\\n            \\n        }\\n        \\n        depth++;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36088,
                "title": "c-solution",
                "content": "```\\n    public int MinDepth(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        else if (root.left == null)\\n            return MinDepth(root.right) + 1;\\n        else if (root.right == null)\\n            return MinDepth(root.left) + 1;\\n        else\\n            return Math.Min(MinDepth(root.left), MinDepth(root.right)) + 1;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int MinDepth(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        else if (root.left == null)\\n            return MinDepth(root.right) + 1;\\n        else if (root.right == null)\\n            return MinDepth(root.left) + 1;\\n        else\\n            return Math.Min(MinDepth(root.left), MinDepth(root.right)) + 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3193138,
                "title": "minimum-depth-of-binary-tree-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can solve this problem using Depth First Search(DFS) or Breadth First Search(BFS) algorithm. Here, we will use the BFS algorithm, i.e., level order traversal to find the minimum depth of a binary tree.\\n\\nIn the level order traversal, we traverse the tree level by level starting from the root node. We maintain a queue of nodes to be traversed. The minimum depth is the level at which we encounter the first leaf node.\\n\\nAlgorithm:\\n\\n1. If the root is None, then the minimum depth is 0, and we return.\\n2. We initialize a queue and append the root node to it.\\n3. We loop through the queue until it becomes empty.\\n4. For each level, we increment the level counter by 1.\\n5. We iterate over the nodes at the current level and check if they are leaf nodes.\\n6. If any of the nodes are leaf nodes, we return the current level.\\n7. If none of the nodes are leaf nodes, we add their children to the queue for the next level.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this algorithm is O(N), where N is the number of nodes in the tree.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def minDepth(self, root: TreeNode) -> int:\\n        \\n        # if root is None, return 0\\n        if not root:\\n            return 0\\n        \\n        # initialize queue with the root node\\n        queue = deque([root])\\n        \\n        # initialize level counter to 1\\n        level = 1\\n        \\n        while queue:\\n            \\n            # loop through the nodes at current level\\n            for i in range(len(queue)):\\n                \\n                # pop the node from the left of the queue\\n                node = queue.popleft()\\n                \\n                # if the node is a leaf node, return the current level\\n                if not node.left and not node.right:\\n                    return level\\n                \\n                # add the children of the current node to the queue\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            \\n            # increment level counter for next level\\n            level += 1\\n            \\n        return level\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def minDepth(self, root: TreeNode) -> int:\\n        \\n        # if root is None, return 0\\n        if not root:\\n            return 0\\n        \\n        # initialize queue with the root node\\n        queue = deque([root])\\n        \\n        # initialize level counter to 1\\n        level = 1\\n        \\n        while queue:\\n            \\n            # loop through the nodes at current level\\n            for i in range(len(queue)):\\n                \\n                # pop the node from the left of the queue\\n                node = queue.popleft()\\n                \\n                # if the node is a leaf node, return the current level\\n                if not node.left and not node.right:\\n                    return level\\n                \\n                # add the children of the current node to the queue\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            \\n            # increment level counter for next level\\n            level += 1\\n            \\n        return level\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2705726,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        \\n        int left = minDepth(root.left);\\n        int right = minDepth(root.right);\\n        \\n        return (left==0 || right == 0) ? left + right + 1 : Math.min(left, right)+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        \\n        int left = minDepth(root.left);\\n        int right = minDepth(root.right);\\n        \\n        return (left==0 || right == 0) ? left + right + 1 : Math.min(left, right)+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1484025,
                "title": "my-3-lines-in-c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        if(!root->left || !root->right) return max(minDepth(root->left), minDepth(root->right)) + 1;\\n        return min(minDepth(root->left), minDepth(root->right)) + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        if(!root->left || !root->right) return max(minDepth(root->left), minDepth(root->right)) + 1;\\n        return min(minDepth(root->left), minDepth(root->right)) + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1220037,
                "title": "c-easy-to-understand-straight-forward-recursive-solution",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING :)**\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(root==NULL)\\n        return 0;\\n        int left=minDepth(root->left);\\n        int right=minDepth(root->right);\\n        if(min(left,right)==0)\\n        return max(left,right)+1;\\n        else\\n        return min(left,right)+1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(root==NULL)\\n        return 0;\\n        int left=minDepth(root->left);\\n        int right=minDepth(root->right);\\n        if(min(left,right)==0)\\n        return max(left,right)+1;\\n        else\\n        return min(left,right)+1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 905563,
                "title": "minimum-depth-of-binary-tree-broken-python",
                "content": "I can\\'t get a good time significantly below 800ms, even when I copy-paste the top submission which are at about 16ms - I still get a time of 770ms.\\n\\nIs there something broken with the tests or so?\\nI know timing is not 100% accurate, but a factor of 50 seems excessive.\\n\\nCode is:\\n```\\nclass Solution(object):\\n    def minDepth(self, root):\\n        if root is None:\\n            return 0\\n          \\n        if not root.right:\\n          return self.minDepth(root.left) +1\\n        if not root.left:\\n          return self.minDepth(root.right) +1\\n        \\n        return min(self.minDepth(root.left)+1, self.minDepth(root.right)+1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minDepth(self, root):\\n        if root is None:\\n            return 0\\n          \\n        if not root.right:\\n          return self.minDepth(root.left) +1\\n        if not root.left:\\n          return self.minDepth(root.right) +1\\n        \\n        return min(self.minDepth(root.left)+1, self.minDepth(root.right)+1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 905531,
                "title": "c-c-super-simple-and-short-recursive-solution",
                "content": "**C:**\\n```\\nint minDepth(struct TreeNode* root){\\n    if (!root) return 0;\\n    \\n    if (!root->left && !root->right) return 1;\\n    \\n    if(!root->left) return minDepth(root->right)+1;\\n    \\n    if(!root->right) return minDepth(root->left)+1;\\n    \\n    int l = minDepth(root->left), r = minDepth(root->right);\\n    return l > r ? r+1 : l+1;\\n}\\n```\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if (!root) return 0;\\n    \\n        if (!root->left && !root->right) return 1;\\n\\n        if(!root->left) return minDepth(root->right)+1;\\n\\n        if(!root->right) return minDepth(root->left)+1;\\n\\n        return min(minDepth(root->left)+1, minDepth(root->right)+1);\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minDepth(struct TreeNode* root){\\n    if (!root) return 0;\\n    \\n    if (!root->left && !root->right) return 1;\\n    \\n    if(!root->left) return minDepth(root->right)+1;\\n    \\n    if(!root->right) return minDepth(root->left)+1;\\n    \\n    int l = minDepth(root->left), r = minDepth(root->right);\\n    return l > r ? r+1 : l+1;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if (!root) return 0;\\n    \\n        if (!root->left && !root->right) return 1;\\n\\n        if(!root->left) return minDepth(root->right)+1;\\n\\n        if(!root->right) return minDepth(root->left)+1;\\n\\n        return min(minDepth(root->left)+1, minDepth(root->right)+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 188162,
                "title": "javascript-solution-60ms-100-faster-with-bfs",
                "content": "```javascript\n\nvar minDepth = function(root) {\n  if(!root) return 0;\n  const queue = [{ node: root, height: 1 }]\n  while(queue.length) {\n    const current = queue.shift();\n    if (!current.node.left && !current.node.right)  {\n\t\t// as soon as we get the first height we break out of loop\n      return current.height;\n    }\n    if(current.node.left) queue.push({ node: current.node.left, height: current.height + 1});\n    if(current.node.right) queue.push({ node: current.node.right, height: current.height + 1});\n  }\n}\n```",
                "solutionTags": [],
                "code": "```javascript\n\nvar minDepth = function(root) {\n  if(!root) return 0;\n  const queue = [{ node: root, height: 1 }]\n  while(queue.length) {\n    const current = queue.shift();\n    if (!current.node.left && !current.node.right)  {\n\t\t// as soon as we get the first height we break out of loop\n      return current.height;\n    }\n    if(current.node.left) queue.push({ node: current.node.left, height: current.height + 1});\n    if(current.node.right) queue.push({ node: current.node.right, height: current.height + 1});\n  }\n}\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36191,
                "title": "an-easy-and-short-answer-of-cpp",
                "content": "    class Solution {\\n        public:\\n        int minDepth(TreeNode* root) {\\n            if (root ==NULL)\\n                return 0;\\n            int l = minDepth(root->left) ;\\n            int r = minDepth(root->right) ;\\n            if (l==0 || r==0)\\n                return l+r+1 ;\\n            return (l>r?r:l)+1 ;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        public:\\n        int minDepth(TreeNode* root) {\\n            if (root ==NULL)\\n                return 0;\\n            int l = minDepth(root->left) ;\\n            int r = minDepth(root->right) ;\\n            if (l==0 || r==0)\\n                return l+r+1 ;\\n            return (l>r?r:l)+1 ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3744348,
                "title": "simple-approach-c-commented-explaination",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution // Main Logic for the function\\n{\\npublic:\\n    int minDepth(TreeNode *root)\\n    {\\n        // If The root is End Point, Return 0\\n        if (root == NULL)\\n            return 0;\\n        // If the left node of the current node doesn\\'t exist\\n        // Go check the depth of the right sub-tree\\n        if (root->left == NULL)\\n            return 1 + minDepth(root->right);\\n        // If the right node of the current node doesn\\'t exist\\n        // Go check the depth of the left sub-tree\\n        if (root->right == NULL)\\n            return 1 + minDepth(root->left);\\n        // If both left and right nodes exists for a current node\\n        // Get the minimum of the left and right subtrees of the current node\\n        return 1 + min(minDepth(root->left), minDepth(root->right));\\n    }\\n};\\n```\\n\\n__Please Upvote :)__![upvote.jpeg](https://assets.leetcode.com/users/images/93a3920e-122e-4860-82f7-16226abaa330_1688976639.1270204.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution // Main Logic for the function\\n{\\npublic:\\n    int minDepth(TreeNode *root)\\n    {\\n        // If The root is End Point, Return 0\\n        if (root == NULL)\\n            return 0;\\n        // If the left node of the current node doesn\\'t exist\\n        // Go check the depth of the right sub-tree\\n        if (root->left == NULL)\\n            return 1 + minDepth(root->right);\\n        // If the right node of the current node doesn\\'t exist\\n        // Go check the depth of the left sub-tree\\n        if (root->right == NULL)\\n            return 1 + minDepth(root->left);\\n        // If both left and right nodes exists for a current node\\n        // Get the minimum of the left and right subtrees of the current node\\n        return 1 + min(minDepth(root->left), minDepth(root->right));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519712,
                "title": "c-deep-search-dfs",
                "content": "# Intuition\\nDirect tree traversal\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m), m = 2 * n;\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int ReturningTheNumberOfBranches(TreeNode *this_node) {\\n        if (this_node == nullptr) return 0;\\n        int sum_left = ReturningTheNumberOfBranches(this_node -> left);\\n        int sum_right = ReturningTheNumberOfBranches(this_node -> right);\\n        if (sum_left == 0 || sum_right == 0) return sum_left + sum_right + 1;\\n        return (sum_left >= sum_right) ? sum_right + 1: sum_left + 1;\\n    }\\n\\npublic:\\n    int minDepth(TreeNode* root) {\\n        return ReturningTheNumberOfBranches(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int ReturningTheNumberOfBranches(TreeNode *this_node) {\\n        if (this_node == nullptr) return 0;\\n        int sum_left = ReturningTheNumberOfBranches(this_node -> left);\\n        int sum_right = ReturningTheNumberOfBranches(this_node -> right);\\n        if (sum_left == 0 || sum_right == 0) return sum_left + sum_right + 1;\\n        return (sum_left >= sum_right) ? sum_right + 1: sum_left + 1;\\n    }\\n\\npublic:\\n    int minDepth(TreeNode* root) {\\n        return ReturningTheNumberOfBranches(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416537,
                "title": "minimum-depth-of-the-given-binary-tree-in-python",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can use append/pop (linear) method to traverse the tree . If the current node is None, we return 0. If the current node is a leaf node (i.e. it has no left and right child nodes), we return 1. If the current node has only left child node, we  traverse the left subtree and add 1 to the minimum depth. Similarly, if the current node has only right child node, we  traverse the right subtree and add 1 to the minimum depth. If the current node has both left and right child nodes, we traverse both the left and right subtrees and add 1 to the minimum depth. Finally, we return the minimum depth.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        if root is None:\\n            return 0\\n        queue = [root]\\n        depth, rightMost = 1, root\\n        while len(queue) > 0:\\n            node = queue.pop(0)\\n            if node.left is None and node.right is None:\\n                break\\n            if node.left is not None:\\n                queue.append(node.left)\\n            if node.right is not None:\\n                queue.append(node.right)\\n            if node == rightMost:\\n                # reach the current level end\\n                depth += 1\\n                if node.right is not None:\\n                    rightMost = node.right\\n                else:\\n                    rightMost = node.left\\n        return depth\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        if root is None:\\n            return 0\\n        queue = [root]\\n        depth, rightMost = 1, root\\n        while len(queue) > 0:\\n            node = queue.pop(0)\\n            if node.left is None and node.right is None:\\n                break\\n            if node.left is not None:\\n                queue.append(node.left)\\n            if node.right is not None:\\n                queue.append(node.right)\\n            if node == rightMost:\\n                # reach the current level end\\n                depth += 1\\n                if node.right is not None:\\n                    rightMost = node.right\\n                else:\\n                    rightMost = node.left\\n        return depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833120,
                "title": "java-bfs",
                "content": "If you like it pls upvote\\n\\n```\\n    public int minDepth(TreeNode root) {\\n        int depth = 1;\\n        if (root == null) {\\n            return 0;\\n        } else {\\n            Queue<TreeNode> queue = new LinkedList<>();\\n            queue.add(root);\\n\\n            while (!queue.isEmpty()) {\\n                int size = queue.size();\\n                for (int i = 0; i < size; i++) {\\n                    TreeNode node = queue.poll();\\n\\n                    if (node.left == null && node.right == null) {\\n                        return depth;\\n                    }\\n                    if (node.left != null) {\\n                        queue.add(node.left);\\n                    }\\n                    if (node.right != null) {\\n                        queue.add(node.right);\\n                    }\\n                }\\n                depth += 1;\\n            }\\n            return -1;\\n        }\\n    }\\n\\n```",
                "solutionTags": [
                    "Linked List",
                    "Breadth-First Search"
                ],
                "code": "```\\n    public int minDepth(TreeNode root) {\\n        int depth = 1;\\n        if (root == null) {\\n            return 0;\\n        } else {\\n            Queue<TreeNode> queue = new LinkedList<>();\\n            queue.add(root);\\n\\n            while (!queue.isEmpty()) {\\n                int size = queue.size();\\n                for (int i = 0; i < size; i++) {\\n                    TreeNode node = queue.poll();\\n\\n                    if (node.left == null && node.right == null) {\\n                        return depth;\\n                    }\\n                    if (node.left != null) {\\n                        queue.add(node.left);\\n                    }\\n                    if (node.right != null) {\\n                        queue.add(node.right);\\n                    }\\n                }\\n                depth += 1;\\n            }\\n            return -1;\\n        }\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 450709,
                "title": "javascript-dfs-recursive-solution",
                "content": "```\\nvar minDepth = function(root) {\\n    if (!root) return 0;\\n    \\n    let min = Infinity;\\n    \\n    const dfs = (node, depth) => {\\n        if (!node.left && !node.right) {\\n            if (depth < min) {\\n                min = depth;\\n            }\\n        }\\n        \\n        if (node.left) {\\n            dfs(node.left, depth + 1);\\n        }\\n        if (node.right) {\\n            dfs(node.right, depth + 1);\\n        }\\n    }\\n    \\n    dfs(root, 1);\\n    \\n    return min;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minDepth = function(root) {\\n    if (!root) return 0;\\n    \\n    let min = Infinity;\\n    \\n    const dfs = (node, depth) => {\\n        if (!node.left && !node.right) {\\n            if (depth < min) {\\n                min = depth;\\n            }\\n        }\\n        \\n        if (node.left) {\\n            dfs(node.left, depth + 1);\\n        }\\n        if (node.right) {\\n            dfs(node.right, depth + 1);\\n        }\\n    }\\n    \\n    dfs(root, 1);\\n    \\n    return min;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 167705,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def minDepth(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if not root:\\n            return 0\\n        elif not root.left and not root.right:\\n            return 1\\n        elif not root.left:\\n            return self.minDepth(root.right)+1\\n        elif not root.right:\\n            return self.minDepth(root.left)+1\\n        else:\\n            l = self.minDepth(root.left)\\n            r = self.minDepth(root.right)\\n            return min(l,r)+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minDepth(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if not root:\\n            return 0\\n        elif not root.left and not root.right:\\n            return 1\\n        elif not root.left:\\n            return self.minDepth(root.right)+1\\n        elif not root.right:\\n            return self.minDepth(root.left)+1\\n        else:\\n            l = self.minDepth(root.left)\\n            r = self.minDepth(root.right)\\n            return min(l,r)+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36165,
                "title": "java-solution-recursive-iteration-bfs",
                "content": "1. recursive , need to rule out the null child.\\n        \\n        public int minDepth(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        int depth=0;\\n        if(root.left!=null&&root.right!=null){\\n            int lh=minDepth(root.left);\\n            int rh=minDepth(root.right);\\n            depth=Math.min(lh,rh);\\n        }\\n        else if(root.left!=null){\\n            depth=minDepth(root.left);\\n        }\\n        else if(root.right!=null){\\n            depth=minDepth(root.right);\\n        }\\n        \\n        return depth+1;\\n    }\\n2. Iteration(BFS), no need to access all the tree nodes.\\n\\n        public int minDepth(TreeNode root) {\\n        int depth=0;\\n        if(root==null)\\n            return depth;\\n        Queue<TreeNode> q=new LinkedList<TreeNode>();\\n        q.offer(root);\\n        while(q.peek()!=null){\\n            depth++;\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                 TreeNode node=q.poll();\\n                 if(node.left==null&&node.right==null)  \\n                    return depth;\\n                 if(node.left!=null)\\n                    q.offer(node.left);\\n                 if(node.right!=null)\\n                    q.offer(node.right);\\n            }\\n           \\n        }\\n        return 0;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "1. recursive , need to rule out the null child.\\n        \\n        public int minDepth(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        int depth=0;\\n        if(root.left!=null&&root.right!=null){\\n            int lh=minDepth(root.left);\\n            int rh=minDepth(root.right);\\n            depth=Math.min(lh,rh);\\n        }\\n        else if(root.left!=null){\\n            depth=minDepth(root.left);\\n        }\\n        else if(root.right!=null){\\n            depth=minDepth(root.right);\\n        }\\n        \\n        return depth+1;\\n    }\\n2. Iteration(BFS), no need to access all the tree nodes.\\n\\n        public int minDepth(TreeNode root) {\\n        int depth=0;\\n        if(root==null)\\n            return depth;\\n        Queue<TreeNode> q=new LinkedList<TreeNode>();\\n        q.offer(root);\\n        while(q.peek()!=null){\\n            depth++;\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                 TreeNode node=q.poll();\\n                 if(node.left==null&&node.right==null)  \\n                    return depth;\\n                 if(node.left!=null)\\n                    q.offer(node.left);\\n                 if(node.right!=null)\\n                    q.offer(node.right);\\n            }\\n           \\n        }\\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36147,
                "title": "fast-pyhon-iterative-and-recursive-solutions-56ms",
                "content": "Most people use recursive solutions. I'm sharing my iterative solutions, which would be faster since it doesn't have to go through the entire tree (especially for extremely unbalanced trees). The ideas is based on Binary Tree Level Order Traversal. The best runtimes on OJ is 56ms.<br><br>\\nSolution 1-4 are based on similar ideas. Solution 4 is longer but easier to understand and should be the fastest. <br>\\n(I did some test, for big balanced trees, iterative Solution 3 and 4 are the fastest, faster than 1,2, and recursive solutions)\\n\\n<br><br>\\n**Solution 1, iterative, shortest, 6 lines**<br>\\n\\n    def minDepth(self, root):\\n        depth, level = 0, [root]\\n        while level and level[0]:\\n            depth += 1\\n            NotLast = (None,None) not in [(n.left, n.right) for n in level ]\\n            level = NotLast and [k for n in level for k in (n.left,n.right) if k]\\n        return depth\\n\\n(note: if `NotLast`=False, it would turn `level` into  `False` and then leave the while loop)<br><br>\\n<br>\\n**Solution 2, iterative, 8 lines**<br>\\n\\n    def minDepth(self, root):\\n        depth, level = 0, [root]\\n        while level and level[0]:\\n            depth += 1\\n            for n in level:\\n                if not n.left and not n.right:\\n                    return depth\\n            level = [kid for n in level for kid in (n.left,n.right) if kid] \\n        return depth \\n\\n<br><br>\\n**Solution 3, iterative, 10 lines**\\n\\n    def minDepth(self, root):\\n        depth, level = 0, [root]\\n        while level and level[0]:\\n            depth += 1\\n            temp = []\\n            for n in level:\\n                if not n.left and not n.right:\\n                    return depth\\n                temp.extend([kid for kid in (n.left, n.right) if kid])\\n            level = temp\\n        return depth\\n\\n<br><br>\\n**Soltion 4, iterative, 14 lines.** (An expansion of 1-3, easier to understand)\\n\\n    def minDepth(self, root):\\n        depth, level = 0, [root]\\n        while level and level[0]:\\n            depth += 1\\n            temp = []\\n            for n in level:\\n                l, r = n.left, n.right\\n                if not l and not r:\\n                    return depth\\n                if l:\\n                    temp.append(l)\\n                if r:\\n                    temp.append(r)\\n            level = temp\\n        return depth   \\n\\n<br><br>\\n**Solution 5, recursive, 5 lines**\\n\\n    def minDepth(self, root):\\n        if not root:\\n            return 0\\n        if not root.left or not root.right:\\n            return 1+max(self.minDepth(root.left),self.minDepth(root.right))\\n        return 1+min(self.minDepth(root.left),self.minDepth(root.right))",
                "solutionTags": [
                    "Python"
                ],
                "code": "Most people use recursive solutions. I'm sharing my iterative solutions, which would be faster since it doesn't have to go through the entire tree (especially for extremely unbalanced trees). The ideas is based on Binary Tree Level Order Traversal. The best runtimes on OJ is 56ms.<br><br>\\nSolution 1-4 are based on similar ideas. Solution 4 is longer but easier to understand and should be the fastest. <br>\\n(I did some test, for big balanced trees, iterative Solution 3 and 4 are the fastest, faster than 1,2, and recursive solutions)\\n\\n<br><br>\\n**Solution 1, iterative, shortest, 6 lines**<br>\\n\\n    def minDepth(self, root):\\n        depth, level = 0, [root]\\n        while level and level[0]:\\n            depth += 1\\n            NotLast = (None,None) not in [(n.left, n.right) for n in level ]\\n            level = NotLast and [k for n in level for k in (n.left,n.right) if k]\\n        return depth\\n\\n(note: if `NotLast`=False, it would turn `level` into  `False` and then leave the while loop)<br><br>\\n<br>\\n**Solution 2, iterative, 8 lines**<br>\\n\\n    def minDepth(self, root):\\n        depth, level = 0, [root]\\n        while level and level[0]:\\n            depth += 1\\n            for n in level:\\n                if not n.left and not n.right:\\n                    return depth\\n            level = [kid for n in level for kid in (n.left,n.right) if kid] \\n        return depth \\n\\n<br><br>\\n**Solution 3, iterative, 10 lines**\\n\\n    def minDepth(self, root):\\n        depth, level = 0, [root]\\n        while level and level[0]:\\n            depth += 1\\n            temp = []\\n            for n in level:\\n                if not n.left and not n.right:\\n                    return depth\\n                temp.extend([kid for kid in (n.left, n.right) if kid])\\n            level = temp\\n        return depth\\n\\n<br><br>\\n**Soltion 4, iterative, 14 lines.** (An expansion of 1-3, easier to understand)\\n\\n    def minDepth(self, root):\\n        depth, level = 0, [root]\\n        while level and level[0]:\\n            depth += 1\\n            temp = []\\n            for n in level:\\n                l, r = n.left, n.right\\n                if not l and not r:\\n                    return depth\\n                if l:\\n                    temp.append(l)\\n                if r:\\n                    temp.append(r)\\n            level = temp\\n        return depth   \\n\\n<br><br>\\n**Solution 5, recursive, 5 lines**\\n\\n    def minDepth(self, root):\\n        if not root:\\n            return 0\\n        if not root.left or not root.right:\\n            return 1+max(self.minDepth(root.left),self.minDepth(root.right))\\n        return 1+min(self.minDepth(root.left),self.minDepth(root.right))",
                "codeTag": "Python3"
            },
            {
                "id": 36253,
                "title": "12ms-recursive-bfs-c-solutions",
                "content": "This problem is just similar to [Minimum Depth of Binary Tree][1].\\n\\nThe first solution also uses recursion (not sure whether it can be called DFS).\\n\\n    class Solution {\\n    public:\\n        int minDepth(TreeNode* root) {\\n            if (!root) return 0;\\n            if (!(root -> left)) return minDepth(root -> right) + 1;\\n            if (!(root -> right)) return minDepth(root -> left) + 1;\\n            return min(minDepth(root -> left), minDepth(root -> right)) + 1;\\n        }\\n    }; \\n\\nWell, the above code may be compressed into 1 line using nested conditional statements. But I tend to keep its logic clear.\\n\\nThe second solution adopts a level-order traversal (BFS) with a queue. We use two `bool` variables `lt` and `rt` to detect leaf nodes. \\n\\n    class Solution {\\n    public:\\n        int minDepth(TreeNode* root) {\\n            int depth = 0;\\n            if (!root) return depth;\\n            queue<TreeNode*> level;\\n            level.push(root);\\n            while (!level.empty()) {\\n                depth++;\\n                int n = level.size();\\n                for (int i = 0; i < n; i++) {\\n                    bool lt = true, rt = true;\\n                    TreeNode* node = level.front();\\n                    level.pop();\\n                    if (node -> left) level.push(node -> left);\\n                    else lt = false;\\n                    if (node -> right) level.push(node -> right);\\n                    else rt = false;\\n                    if (!lt && !rt) return depth;\\n                }\\n            }\\n        } \\n    };\\n\\n  [1]: https://leetcode.com/problems/maximum-depth-of-binary-tree/",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n        int minDepth(TreeNode* root) {\\n            if (!root) return 0;\\n            if (!(root -> left)) return minDepth(root -> right) + 1;\\n            if (!(root -> right)) return minDepth(root -> left) + 1;\\n            return min(minDepth(root -> left), minDepth(root -> right)) + 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36290,
                "title": "c-3-line-simple-and-concise",
                "content": "\\n\\nclass Solution {\\n\\n\\npublic:\\n       int minDepth(TreeNode *root) {\\n\\n        if(!root)                       return 0;\\n        if(root->left && root->right)   return min(minDepth(root->left),minDepth(root->right))+1;\\n        else                            return max(minDepth(root->left),minDepth(root->right))+1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\n\\npublic:\\n       int minDepth(TreeNode *root) {\\n\\n        if(!root)                       return 0;\\n        if(root->left && root->right)   return min(minDepth(root->left),minDepth(root->right))+1;\\n        else                            return max(minDepth(root->left),minDepth(root->right))+1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3746316,
                "title": "python-java-c-easy-solution-with-explanation",
                "content": "# DFS Solution\\n1. If the root is null, return 0 because there are no nodes in an empty tree.\\n2. If both the left and right child of the root are null, return 1 because the root itself is a leaf node.\\n3. If the left child of the root is null, recursively calculate the minimum depth of the right subtree and add 1 to it (to account for the root node).\\n4. If the right child of the root is null, recursively calculate the minimum depth of the left subtree and add 1 to it.\\n5. If both the left and right child of the root are not null, recursively calculate the minimum depth of both subtrees, and return the minimum of the two depths plus 1 (to account for the root node).\\n\\n# DFS Code\\n```python []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        def dfs(root):\\n            if not root:\\n                return 0\\n            if not root.left and root.right:\\n                return 1 + dfs(root.right)\\n            elif not root.right and root.left:\\n                return 1 + dfs(root.left)\\n            else:\\n                return 1 + min(dfs(root.left), dfs(root.right))\\n        return dfs(root)\\n```\\n```java []\\nclass Solution {\\n    private int dfs(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        \\n        // If only one of child is non-null, then go into that recursion.\\n        if (root.left == null) {\\n            return 1 + dfs(root.right);\\n        } else if (root.right == null) {\\n            return 1 + dfs(root.left);\\n        }\\n        \\n        // Both children are non-null, hence call for both childs.\\n        return 1 + Math.min(dfs(root.left), dfs(root.right));\\n    }\\n    \\n    public int minDepth(TreeNode root) {\\n        return dfs(root);\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root) {\\n        if (root == NULL) {\\n            return 0;\\n        }\\n        \\n        // If only one of child is non-null, then go into that recursion.\\n        if (!root->left) {\\n            return 1 + dfs(root->right);\\n        } else if (!root->right) {\\n            return 1 + dfs(root->left);\\n        }\\n        \\n        // Both children are non-null, hence call for both childs.\\n        return 1 + min(dfs(root->left), dfs(root->right));\\n    }\\n    \\n    int minDepth(TreeNode* root) {\\n        return dfs(root);\\n    }\\n};\\n```\\n# BFS Solution\\nHere\\'s the step-by-step algorithm for the BFS solution:\\n\\n1. If the root is null, return 0 because there are no nodes in an empty tree.\\n2. Initialize a queue to perform BFS. Add the root node to the queue along with its corresponding depth, which is 1.\\n3. Perform a while loop until the queue is empty:\\n    - Remove the node and its depth from the front of the queue.\\n    - If the node is a leaf node (i.e., both its left and right children are null), return the depth because we have found the minimum depth.\\n    - If the node has a left child, add it to the queue along with its depth (depth + 1).\\n    - If the node has a right child, add it to the queue along with its depth (depth + 1).\\n4. If the loop finishes without finding a leaf node, return 0 as there are no leaf nodes in the tree.\\n\\n# BFS Code\\n```python []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        if not root:\\n            return 0\\n    \\n        queue = deque([])\\n        queue.append(root)\\n        depth = 1\\n        while queue:\\n            for i in range(len(queue)):\\n                node = queue.popleft()\\n                if not node:\\n                    continue\\n                if not node.left and not node.right:\\n                    return depth\\n                queue.append(node.left)\\n                queue.append(node.right)\\n            depth += 1\\n        \\n\\n         \\n```\\n```java []\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        \\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        int depth = 1;\\n        \\n        while (q.isEmpty() == false) {\\n            int qSize = q.size();\\n            \\n            while (qSize > 0) {\\n                qSize--;\\n                \\n                TreeNode node = q.remove();\\n                // Since we added nodes without checking null, we need to skip them here.\\n                if (node == null) {\\n                    continue;\\n                }\\n                \\n                // The first leaf would be at minimum depth, hence return it.\\n                if (node.left == null && node.right == null) {\\n                    return depth;\\n                }\\n                \\n                q.add(node.left);\\n                q.add(node.right);\\n            }\\n            depth++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if (!root) {\\n            return 0;\\n        }\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int depth = 1;\\n        \\n        while (!q.empty()) {\\n            int qSize = q.size();\\n            \\n            while (qSize--) {\\n                TreeNode* node = q.front(); q.pop();\\n                // Since we added nodes without checking null, we need to skip them here.\\n                if (!node) {\\n                    continue;\\n                }\\n                \\n                // The first leaf would be at minimum depth, hence return it.\\n                if (!node->left && !node->right) {\\n                    return depth;\\n                }\\n                \\n                q.push({node->left});\\n                q.push({node->right});\\n            }\\n            \\n            depth++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n# Video Explanation\\nhttps://youtu.be/5Wo5DxOu3uU\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(N), where N is the number of nodes in the binary tree\\n- Space complexity:\\nDFS - O(n) [Call Stack is used on recursion]\\nBFS - O(n) [Queue for storing child nodes]\\n\\n#### Upvote if find useful \\uD83D\\uDC4D\\uD83C\\uDFFB\\uD83D\\uDE01\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```python []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        def dfs(root):\\n            if not root:\\n                return 0\\n            if not root.left and root.right:\\n                return 1 + dfs(root.right)\\n            elif not root.right and root.left:\\n                return 1 + dfs(root.left)\\n            else:\\n                return 1 + min(dfs(root.left), dfs(root.right))\\n        return dfs(root)\\n```\n```java []\\nclass Solution {\\n    private int dfs(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        \\n        // If only one of child is non-null, then go into that recursion.\\n        if (root.left == null) {\\n            return 1 + dfs(root.right);\\n        } else if (root.right == null) {\\n            return 1 + dfs(root.left);\\n        }\\n        \\n        // Both children are non-null, hence call for both childs.\\n        return 1 + Math.min(dfs(root.left), dfs(root.right));\\n    }\\n    \\n    public int minDepth(TreeNode root) {\\n        return dfs(root);\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root) {\\n        if (root == NULL) {\\n            return 0;\\n        }\\n        \\n        // If only one of child is non-null, then go into that recursion.\\n        if (!root->left) {\\n            return 1 + dfs(root->right);\\n        } else if (!root->right) {\\n            return 1 + dfs(root->left);\\n        }\\n        \\n        // Both children are non-null, hence call for both childs.\\n        return 1 + min(dfs(root->left), dfs(root->right));\\n    }\\n    \\n    int minDepth(TreeNode* root) {\\n        return dfs(root);\\n    }\\n};\\n```\n```python []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        if not root:\\n            return 0\\n    \\n        queue = deque([])\\n        queue.append(root)\\n        depth = 1\\n        while queue:\\n            for i in range(len(queue)):\\n                node = queue.popleft()\\n                if not node:\\n                    continue\\n                if not node.left and not node.right:\\n                    return depth\\n                queue.append(node.left)\\n                queue.append(node.right)\\n            depth += 1\\n        \\n\\n         \\n```\n```java []\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        \\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        int depth = 1;\\n        \\n        while (q.isEmpty() == false) {\\n            int qSize = q.size();\\n            \\n            while (qSize > 0) {\\n                qSize--;\\n                \\n                TreeNode node = q.remove();\\n                // Since we added nodes without checking null, we need to skip them here.\\n                if (node == null) {\\n                    continue;\\n                }\\n                \\n                // The first leaf would be at minimum depth, hence return it.\\n                if (node.left == null && node.right == null) {\\n                    return depth;\\n                }\\n                \\n                q.add(node.left);\\n                q.add(node.right);\\n            }\\n            depth++;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if (!root) {\\n            return 0;\\n        }\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int depth = 1;\\n        \\n        while (!q.empty()) {\\n            int qSize = q.size();\\n            \\n            while (qSize--) {\\n                TreeNode* node = q.front(); q.pop();\\n                // Since we added nodes without checking null, we need to skip them here.\\n                if (!node) {\\n                    continue;\\n                }\\n                \\n                // The first leaf would be at minimum depth, hence return it.\\n                if (!node->left && !node->right) {\\n                    return depth;\\n                }\\n                \\n                q.push({node->left});\\n                q.push({node->right});\\n            }\\n            \\n            depth++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743581,
                "title": "c-two-easy-methods-suit-yourself",
                "content": "# Method 1: Recursion \\u26A1 78.73 \\uD83D\\uDCE6 85.25\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int helper(TreeNode* root){\\n        if(!root)return 1e8;\\n        if(!root->left&&!root->right)return 1;\\n        return 1+min(helper(root->left),helper(root->right));\\n    }\\n    int minDepth(TreeNode* root) {\\n        if(!root)return 0;\\n        return helper(root);\\n    }\\n};\\n```\\n\\n# Method 2: BFS \\u26A1 64.58 \\uD83D\\uDCE6 57.99\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(!root)return 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int count=0;\\n        while(!q.empty()){\\n            int n = q.size();\\n            for(int i = 0; i<n; i++){\\n                auto temp = q.front();\\n                q.pop();\\n                if(!temp->left&&!temp->right)return count+1;\\n                if(!temp->left){\\n                    q.push(temp->right);\\n                    continue;\\n                }\\n                if(!temp->right){\\n                    q.push(temp->left);\\n                    continue;\\n                }\\n                q.push(temp->right);\\n                q.push(temp->left);\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n\\n```\\n\\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int helper(TreeNode* root){\\n        if(!root)return 1e8;\\n        if(!root->left&&!root->right)return 1;\\n        return 1+min(helper(root->left),helper(root->right));\\n    }\\n    int minDepth(TreeNode* root) {\\n        if(!root)return 0;\\n        return helper(root);\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(!root)return 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int count=0;\\n        while(!q.empty()){\\n            int n = q.size();\\n            for(int i = 0; i<n; i++){\\n                auto temp = q.front();\\n                q.pop();\\n                if(!temp->left&&!temp->right)return count+1;\\n                if(!temp->left){\\n                    q.push(temp->right);\\n                    continue;\\n                }\\n                if(!temp->right){\\n                    q.push(temp->left);\\n                    continue;\\n                }\\n                q.push(temp->right);\\n                q.push(temp->left);\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\n\\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743365,
                "title": "easy-c-code-highly-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:Stack space for recursion\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(root==NULL)\\n        return 0;\\n        if(root->left==NULL and root->right==NULL)\\n        return 1;\\n        \\n        int m1=INT_MAX;\\n\\n        if(root->right){\\n            \\n            m1=  min(minDepth(root->right),m1);\\n\\n        }\\n        if(root->left){\\n             m1= min(minDepth(root->left),m1);\\n        }\\n        return m1+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(root==NULL)\\n        return 0;\\n        if(root->left==NULL and root->right==NULL)\\n        return 1;\\n        \\n        int m1=INT_MAX;\\n\\n        if(root->right){\\n            \\n            m1=  min(minDepth(root->right),m1);\\n\\n        }\\n        if(root->left){\\n             m1= min(minDepth(root->left),m1);\\n        }\\n        return m1+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289310,
                "title": "easy-java-dfs-depth-first-search",
                "content": "# Intuition\\nIf you don\\'t know much about the problem well it\\'s about the DFS traversal of the tree you can learn it about on youtube better then reading my solution and if you are gonna go and learn DFS make sure to learn BFS as well.\\n\\n# Approach\\nApproach is simple we got three Cases\\n1.) If root is null return 0.\\n2.) If the left of root is null we will traverse right and return 1 + right depth (1 + rightDepht) why 1+? Where is the root, we also have to include root so. 1+ is for the root\\n3.) Same thing if the right is empty we return 1 + leftDepth.\\n\\n# Complexity\\n- Time complexity:\\n- `O(V+E) where V is vertices and E is edges`\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDepth(TreeNode root)\\n    {\\n        if(root == null) return 0;\\n\\n        int leftDepth = minDepth(root.left);\\n        int rightDepth = minDepth(root.right);\\n\\n        // three cases in this problem if it\\'s the leaf node return 1\\n        if(root.left == null && root.right == null ) return 1;\\n        // if left is null then traverse it\\'s right and add the height of it\\'s right tree to the root and return it.\\n        if(root.left == null) return 1 + rightDepth;\\n        // same case if the right is null then traverse it\\'s left and return 1 + leftDepth (1+ is because we have to include root itself.)\\n        if(root.right == null) return 1 + leftDepth;\\n\\n        return Math.min(leftDepth,rightDepth) + 1;\\n    }\\n}\\n```\\n![UPVote.jpg](https://assets.leetcode.com/users/images/4365694a-f019-4a5b-9328-597903085702_1678642969.0310588.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDepth(TreeNode root)\\n    {\\n        if(root == null) return 0;\\n\\n        int leftDepth = minDepth(root.left);\\n        int rightDepth = minDepth(root.right);\\n\\n        // three cases in this problem if it\\'s the leaf node return 1\\n        if(root.left == null && root.right == null ) return 1;\\n        // if left is null then traverse it\\'s right and add the height of it\\'s right tree to the root and return it.\\n        if(root.left == null) return 1 + rightDepth;\\n        // same case if the right is null then traverse it\\'s left and return 1 + leftDepth (1+ is because we have to include root itself.)\\n        if(root.right == null) return 1 + leftDepth;\\n\\n        return Math.min(leftDepth,rightDepth) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106568,
                "title": "java-easy",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        if(root == null) return 0;\\n        \\n        int lh=minDepth(root.left);\\n        int rh=minDepth(root.right);\\n        \\n        if(lh==0 || rh==0){                  //For skew trees.\\n            return 1+Math.max(rh,lh);\\n        }\\n       \\n        return 1+ Math.min(lh,rh);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        if(root == null) return 0;\\n        \\n        int lh=minDepth(root.left);\\n        int rh=minDepth(root.right);\\n        \\n        if(lh==0 || rh==0){                  //For skew trees.\\n            return 1+Math.max(rh,lh);\\n        }\\n       \\n        return 1+ Math.min(lh,rh);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065194,
                "title": "c-recursive-and-iterative-easy-100-faster",
                "content": "**BFS**\\n\\n```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        int minimumDepth = 1;\\n        if(!root) return 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            for(int i=0,n=q.size();i<n;i++){\\n                TreeNode* p = q.front();\\n                q.pop();\\n                if(p->left==NULL && p->right==NULL) return minimumDepth;\\n                if(p->left) q.push(p->left);\\n                if(p->right) q.push(p->right);\\n            }\\n            minimumDepth++;\\n        }\\n        return minimumDepth;\\n    }\\n};\\n```\\n**DFS**\\n```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if (root == NULL) {\\n            return 0;\\n        }\\n        if (root->left == NULL) {\\n            return 1 + minDepth(root->right);\\n        }\\n        if (root->right == NULL) {\\n            return 1 + minDepth(root->left);\\n        }\\n        return 1 + min(minDepth(root->left), minDepth(root->right));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        int minimumDepth = 1;\\n        if(!root) return 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            for(int i=0,n=q.size();i<n;i++){\\n                TreeNode* p = q.front();\\n                q.pop();\\n                if(p->left==NULL && p->right==NULL) return minimumDepth;\\n                if(p->left) q.push(p->left);\\n                if(p->right) q.push(p->right);\\n            }\\n            minimumDepth++;\\n        }\\n        return minimumDepth;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if (root == NULL) {\\n            return 0;\\n        }\\n        if (root->left == NULL) {\\n            return 1 + minDepth(root->right);\\n        }\\n        if (root->right == NULL) {\\n            return 1 + minDepth(root->left);\\n        }\\n        return 1 + min(minDepth(root->left), minDepth(root->right));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 905443,
                "title": "java-only-3-lines-of-code-o-n",
                "content": "```\\n\\tpublic int minDepth(TreeNode root) {\\n        if(root == null) return 0;\\n\\t\\t\\n        if(root.left == null || root.right == null)\\n            return 1 + Math.max(minDepth(root.left), minDepth(root.right));\\n\\t\\t\\t\\n        return 1 + Math.min(minDepth(root.left), minDepth(root.right));\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic int minDepth(TreeNode root) {\\n        if(root == null) return 0;\\n\\t\\t\\n        if(root.left == null || root.right == null)\\n            return 1 + Math.max(minDepth(root.left), minDepth(root.right));\\n\\t\\t\\t\\n        return 1 + Math.min(minDepth(root.left), minDepth(root.right));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 795454,
                "title": "c-simplest-recursive-solution-5-lines",
                "content": "```\\nint minDepth(struct TreeNode* root){\\n    if (!root) return 0;\\n    \\n    if (!root->left && !root->right) return 1;\\n    \\n    if(!root->left) return minDepth(root->right)+1;\\n    \\n    if(!root->right) return minDepth(root->left)+1;\\n    \\n    return minDepth(root->left) > minDepth(root->right) ? minDepth(root->right)+1 : minDepth(root->left)+1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minDepth(struct TreeNode* root){\\n    if (!root) return 0;\\n    \\n    if (!root->left && !root->right) return 1;\\n    \\n    if(!root->left) return minDepth(root->right)+1;\\n    \\n    if(!root->right) return minDepth(root->left)+1;\\n    \\n    return minDepth(root->left) > minDepth(root->right) ? minDepth(root->right)+1 : minDepth(root->left)+1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 540114,
                "title": "c-three-line-simple-recursion",
                "content": "```c++\\nif(root == NULL) return 0;\\nif(!root->left) return minDepth(root->right) + 1; // only right subtree\\nelse if(!root->right) return minDepth(root->left) + 1; // only left subtree\\nelse return min(minDepth(root->left), minDepth(root->right)) + 1;\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```c++\\nif(root == NULL) return 0;\\nif(!root->left) return minDepth(root->right) + 1; // only right subtree\\nelse if(!root->right) return minDepth(root->left) + 1; // only left subtree\\nelse return min(minDepth(root->left), minDepth(root->right)) + 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 264076,
                "title": "golang-4ms-recursive",
                "content": "```\\nfunc minDepth(root *TreeNode) int {\\n\\tif root == nil {\\n\\t\\treturn 0\\n\\t}\\n\\tleft, right := minDepth(root.Left), minDepth(root.Right)\\n\\tif left == 0 || right == 0 {\\n\\t\\treturn left + right + 1\\n\\t}\\n\\treturn min(left, right) + 1\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nfunc minDepth(root *TreeNode) int {\\n\\tif root == nil {\\n\\t\\treturn 0\\n\\t}\\n\\tleft, right := minDepth(root.Left), minDepth(root.Right)\\n\\tif left == 0 || right == 0 {\\n\\t\\treturn left + right + 1\\n\\t}\\n\\treturn min(left, right) + 1\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36182,
                "title": "my-4-lines-java-solution",
                "content": "    public class Solution {\\n        public int minDepth(TreeNode root) {\\n            if(root==null) return 0;\\n            if(root.left==null) return minDepth(root.right)+1;\\n            if(root.right==null) return minDepth(root.left)+1;\\n            return Math.min(minDepth(root.left)+1,minDepth(root.right)+1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int minDepth(TreeNode root) {\\n            if(root==null) return 0;\\n            if(root.left==null) return minDepth(root.right)+1;\\n            if(root.right==null) return minDepth(root.left)+1;\\n            return Math.min(minDepth(root.left)+1,minDepth(root.right)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36212,
                "title": "java-bfs-solution",
                "content": "        if(root == null) return 0;\\n        int dep = 1;\\n        List<TreeNode> que = new ArrayList<TreeNode>();\\n        que.add(root);\\n        while(!que.isEmpty()) {\\n            int size = que.size();\\n            for(int i = 0; i < size; i++) {\\n                TreeNode cur = que.remove(0);\\n                if(cur.left == null && cur.right == null) return dep;\\n                if(cur.left != null) que.add(cur.left);\\n                if(cur.right != null) que.add(cur.right);\\n            }\\n            dep++;\\n        }\\n        return dep;",
                "solutionTags": [],
                "code": "        if(root == null) return 0;\\n        int dep = 1;\\n        List<TreeNode> que = new ArrayList<TreeNode>();\\n        que.add(root);\\n        while(!que.isEmpty()) {\\n            int size = que.size();\\n            for(int i = 0; i < size; i++) {\\n                TreeNode cur = que.remove(0);\\n                if(cur.left == null && cur.right == null) return dep;\\n                if(cur.left != null) que.add(cur.left);\\n                if(cur.right != null) que.add(cur.right);\\n            }\\n            dep++;\\n        }\\n        return dep;",
                "codeTag": "Unknown"
            },
            {
                "id": 36262,
                "title": "my-accepted-223ms-java-solution",
                "content": "        public class Solution {\\n        public int minDepth(TreeNode root) {\\n            if(root == null)    //base case\\n                return 0;\\n            if(root.left == null || root.right == null)\\n                return 1 + (root.left == null ? minDepth(root.right) : minDepth(root.left));\\n            return 1 + Math.min(minDepth(root.left), minDepth(root.right));\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int minDepth(TreeNode root) {\\n            if(root == null)    //base case\\n                return 0;\\n            if(root.left == null || root.right == null)\\n                return 1 + (root.left == null ? minDepth(root.right) : minDepth(root.left));\\n            return 1 + Math.min(minDepth(root.left), minDepth(root.right));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36325,
                "title": "my-simple-iterative-bfs-solution-in-python",
                "content": "    class Solution:\\n        # @param root, a tree node\\n        # @return an integer\\n        def minDepth(self, root):\\n            if not root:\\n                return 0\\n            explored = [(root, 1)]\\n            while explored:\\n                (node, depth) = explored.pop(0)\\n                if node.left is node.right is None:\\n                    return depth\\n                if node.left:\\n                    explored.append((node.left, depth+1))\\n                if node.right:\\n                    explored.append((node.right, depth+1))\\n\\nI store explored nodes with their depth. Notice that I add new nodes to the end (`.append()`) while I take them from the head (`.pop(0)`) -- in this way I am sure to always find the shortest depth nodes first.",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "    class Solution:\\n        # @param root, a tree node\\n        # @return an integer\\n        def minDepth(self, root):\\n            if not root:\\n                return 0\\n            explored = [(root, 1)]\\n            while explored:\\n                (node, depth) = explored.pop(0)\\n                if node.left is node.right is None:\\n                    return depth\\n                if node.left:\\n                    explored.append((node.left, depth+1))\\n                if node.right:\\n                    explored.append((node.right, depth+1))\\n\\nI store explored nodes with their depth. Notice that I add new nodes to the end (`.append()`) while I take them from the head (`.pop(0)`) -- in this way I am sure to always find the shortest depth nodes first.",
                "codeTag": "Java"
            },
            {
                "id": 3743229,
                "title": "beats-100-video-java-c-python",
                "content": "## Intuition\\nBFS is faster in this case, becasue in dfs, every node has to be explored, but BFS stops once we have reached a leaf node.\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/iQEA3AuFfaY\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        int depth = 1;\\n        int size = 0;\\n        TreeNode removed;\\n        while (!queue.isEmpty()){\\n            size = queue.size();\\n            for(int i = 0;i<size;i++){\\n                removed = queue.remove();\\n                if(removed==null)continue;\\n                if(removed.left==null && removed.right==null) return depth;\\n                queue.add(removed.left);\\n                queue.add(removed.right);\\n            }\\n            depth++;\\n        }\\n        return 0;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        std::queue<TreeNode*> queue;\\n        queue.push(root);\\n        int depth = 1;\\n        int size = 0;\\n        TreeNode* removed;\\n        \\n        while (!queue.empty()) {\\n            size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                removed = queue.front();\\n                queue.pop();\\n                if (removed == nullptr) continue;\\n                if (removed->left == nullptr && removed->right == nullptr)\\n                    return depth;\\n                queue.push(removed->left);\\n                queue.push(removed->right);\\n            }\\n            depth++;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def minDepth(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        \\n        queue = deque()\\n        queue.append(root)\\n        depth = 1\\n        \\n        while queue:\\n            size = len(queue)\\n            \\n            for _ in range(size):\\n                removed = queue.popleft()\\n                \\n                if not removed:\\n                    continue\\n                \\n                if not removed.left and not removed.right:\\n                    return depth\\n                \\n                if removed.left:\\n                    queue.append(removed.left)\\n                \\n                if removed.right:\\n                    queue.append(removed.right)\\n            \\n            depth += 1\\n        \\n        return 0\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        int depth = 1;\\n        int size = 0;\\n        TreeNode removed;\\n        while (!queue.isEmpty()){\\n            size = queue.size();\\n            for(int i = 0;i<size;i++){\\n                removed = queue.remove();\\n                if(removed==null)continue;\\n                if(removed.left==null && removed.right==null) return depth;\\n                queue.add(removed.left);\\n                queue.add(removed.right);\\n            }\\n            depth++;\\n        }\\n        return 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        std::queue<TreeNode*> queue;\\n        queue.push(root);\\n        int depth = 1;\\n        int size = 0;\\n        TreeNode* removed;\\n        \\n        while (!queue.empty()) {\\n            size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                removed = queue.front();\\n                queue.pop();\\n                if (removed == nullptr) continue;\\n                if (removed->left == nullptr && removed->right == nullptr)\\n                    return depth;\\n                queue.push(removed->left);\\n                queue.push(removed->right);\\n            }\\n            depth++;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minDepth(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        \\n        queue = deque()\\n        queue.append(root)\\n        depth = 1\\n        \\n        while queue:\\n            size = len(queue)\\n            \\n            for _ in range(size):\\n                removed = queue.popleft()\\n                \\n                if not removed:\\n                    continue\\n                \\n                if not removed.left and not removed.right:\\n                    return depth\\n                \\n                if removed.left:\\n                    queue.append(removed.left)\\n                \\n                if removed.right:\\n                    queue.append(removed.right)\\n            \\n            depth += 1\\n        \\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742971,
                "title": "easy-c-python-recursion-for-binary-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe minimum depth of a binary tree is defined as the shortest path from the root to any leaf node. In this implementation, the minDepth function utilizes the dfs function to traverse the tree and find the minimum depth starting from the root node.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIn the worst case, if the binary tree is skewed $O(N)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is determined by the maximum depth of the recursive call stack. $O(N)$\\n# Code\\n```C++ []\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root, int level){\\n        if (!root->left && !root->right) return level;\\n        int ans=INT_MAX;\\n        if (root->left) \\n            ans=min(ans, dfs(root->left, level+1));\\n        if (root->right)\\n            ans=min(ans, dfs(root->right, level+1));\\n        return ans;\\n    }\\n    int minDepth(TreeNode* root) {\\n        if (root==NULL) return 0;\\n        return dfs(root, 1);\\n    }\\n};\\n```\\n```python []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        def dfs(root, level):\\n            if  not root.left and  not root.right:\\n                return level\\n            ans=2**31\\n            if root.left:\\n                ans=min(ans, dfs(root.left, level+1))\\n            if root.right:\\n                ans=min(ans, dfs(root.right, level+1))\\n            return ans\\n        \\n        if not root: \\n            return 0\\n        return dfs(root, 1)\\n```\\n\\n# Code with Explanation in comments\\n\\n```\\n/**\\n * This code defines a binary tree structure called TreeNode.\\n * Each TreeNode has three members: val (the value stored in the node),\\n * left (a pointer to the left child node), and right (a pointer to the right child node).\\n * The TreeNode structure provides three constructors:\\n * - The default constructor initializes val to 0 and sets both left and right pointers to nullptr.\\n * - The constructor with a single parameter initializes val with the provided value and sets left and right pointers to nullptr.\\n * - The constructor with three parameters initializes val with the provided value and sets the left and right pointers to the provided child nodes.\\n */\\n\\nclass Solution {\\npublic:\\n    /**\\n     * This function performs a depth-first search (DFS) traversal of the binary tree.\\n     * It takes two parameters: root (a pointer to the current node being visited) and level (the depth or level of the current node).\\n     * The function returns the minimum depth of the tree from the current node.\\n     * It recursively calls itself on the left and right child nodes, updating the level parameter accordingly.\\n     */\\n    int dfs(TreeNode* root, int level){\\n        if (!root->left && !root->right) return level;\\n        int ans=INT_MAX;\\n        if (root->left) \\n            ans=min(ans, dfs(root->left, level+1));\\n        if (root->right)\\n            ans=min(ans, dfs(root->right, level+1));\\n        return ans;\\n    }\\n    \\n    /**\\n     * This function calculates the minimum depth of a binary tree.\\n     * It takes a root parameter (a pointer to the root node of the tree).\\n     * If the root is NULL, indicating an empty tree, the function returns 0.\\n     * Otherwise, it calls the dfs function with the root node and an initial level of 1.\\n     */\\n    int minDepth(TreeNode* root) {\\n        if (root==NULL) return 0;\\n        return dfs(root, 1);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```C++ []\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root, int level){\\n        if (!root->left && !root->right) return level;\\n        int ans=INT_MAX;\\n        if (root->left) \\n            ans=min(ans, dfs(root->left, level+1));\\n        if (root->right)\\n            ans=min(ans, dfs(root->right, level+1));\\n        return ans;\\n    }\\n    int minDepth(TreeNode* root) {\\n        if (root==NULL) return 0;\\n        return dfs(root, 1);\\n    }\\n};\\n```\n```python []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        def dfs(root, level):\\n            if  not root.left and  not root.right:\\n                return level\\n            ans=2**31\\n            if root.left:\\n                ans=min(ans, dfs(root.left, level+1))\\n            if root.right:\\n                ans=min(ans, dfs(root.right, level+1))\\n            return ans\\n        \\n        if not root: \\n            return 0\\n        return dfs(root, 1)\\n```\n```\\n/**\\n * This code defines a binary tree structure called TreeNode.\\n * Each TreeNode has three members: val (the value stored in the node),\\n * left (a pointer to the left child node), and right (a pointer to the right child node).\\n * The TreeNode structure provides three constructors:\\n * - The default constructor initializes val to 0 and sets both left and right pointers to nullptr.\\n * - The constructor with a single parameter initializes val with the provided value and sets left and right pointers to nullptr.\\n * - The constructor with three parameters initializes val with the provided value and sets the left and right pointers to the provided child nodes.\\n */\\n\\nclass Solution {\\npublic:\\n    /**\\n     * This function performs a depth-first search (DFS) traversal of the binary tree.\\n     * It takes two parameters: root (a pointer to the current node being visited) and level (the depth or level of the current node).\\n     * The function returns the minimum depth of the tree from the current node.\\n     * It recursively calls itself on the left and right child nodes, updating the level parameter accordingly.\\n     */\\n    int dfs(TreeNode* root, int level){\\n        if (!root->left && !root->right) return level;\\n        int ans=INT_MAX;\\n        if (root->left) \\n            ans=min(ans, dfs(root->left, level+1));\\n        if (root->right)\\n            ans=min(ans, dfs(root->right, level+1));\\n        return ans;\\n    }\\n    \\n    /**\\n     * This function calculates the minimum depth of a binary tree.\\n     * It takes a root parameter (a pointer to the root node of the tree).\\n     * If the root is NULL, indicating an empty tree, the function returns 0.\\n     * Otherwise, it calls the dfs function with the root node and an initial level of 1.\\n     */\\n    int minDepth(TreeNode* root) {\\n        if (root==NULL) return 0;\\n        return dfs(root, 1);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479416,
                "title": "bfs-algorythm-easy-solution",
                "content": "The breadth-first search or BFS algorithm is used to search a tree or graph data structure for a node that meets a set of criteria. It begins at the root of the tree or graph and investigates all nodes at the current depth level before moving on to nodes at the next depth level\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        List<Double> result = new ArrayList<>();\\n\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        int minDepth = 1;\\n\\n        while(!queue.isEmpty()) {\\n            int levelSize = queue.size();\\n\\n            for (int i = 0; i < levelSize; i++) {\\n                TreeNode node = queue.poll();\\n\\n                if (node.left == null && node.right == null) {\\n                    return minDepth;\\n                }\\n\\n                if (node.left != null) {\\n                    queue.offer(node.left);\\n                }\\n                if (node.right != null) {\\n                    queue.offer(node.right);\\n                }\\n            }\\n            minDepth++;\\n        }\\n\\n        return minDepth;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        List<Double> result = new ArrayList<>();\\n\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        int minDepth = 1;\\n\\n        while(!queue.isEmpty()) {\\n            int levelSize = queue.size();\\n\\n            for (int i = 0; i < levelSize; i++) {\\n                TreeNode node = queue.poll();\\n\\n                if (node.left == null && node.right == null) {\\n                    return minDepth;\\n                }\\n\\n                if (node.left != null) {\\n                    queue.offer(node.left);\\n                }\\n                if (node.right != null) {\\n                    queue.offer(node.right);\\n                }\\n            }\\n            minDepth++;\\n        }\\n\\n        return minDepth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292334,
                "title": "minimum-depth-of-binary-tree-bfs-dfs-java-solution",
                "content": "# Time Complexity\\n- O(n)\\n# DFS \\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        if (root==null)\\n            return 0;\\n        else if(root.left==null && root.right == null)\\n            return 1;\\n        else if(root.left == null)\\n            return 1 + minDepth(root.right);\\n        else if(root.right == null)\\n            return 1 + minDepth(root.left);\\n        else\\n            return 1 + Math.min(minDepth(root.left), minDepth(root.right));\\n    }\\n}\\n```\\n\\n# BFS\\n- In BFS we go level by level traversal\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        if (root==null)\\n            return 0;\\n        Queue<TreeNode> q = new LinkedList();\\n        q.add(root);\\n        int depth=1;\\n\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            while(size-- >0)\\n            {\\n                root = q.poll();\\n                if(root.left == null && root.right == null)\\n                    return depth;\\n                if(root.left!=null)\\n                    q.add(root.left);\\n                if(root.right != null)\\n                    q.add(root.right);\\n            }\\n            depth++;\\n        }\\n        return 0;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        if (root==null)\\n            return 0;\\n        else if(root.left==null && root.right == null)\\n            return 1;\\n        else if(root.left == null)\\n            return 1 + minDepth(root.right);\\n        else if(root.right == null)\\n            return 1 + minDepth(root.left);\\n        else\\n            return 1 + Math.min(minDepth(root.left), minDepth(root.right));\\n    }\\n}\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        if (root==null)\\n            return 0;\\n        Queue<TreeNode> q = new LinkedList();\\n        q.add(root);\\n        int depth=1;\\n\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            while(size-- >0)\\n            {\\n                root = q.poll();\\n                if(root.left == null && root.right == null)\\n                    return depth;\\n                if(root.left!=null)\\n                    q.add(root.left);\\n                if(root.right != null)\\n                    q.add(root.right);\\n            }\\n            depth++;\\n        }\\n        return 0;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205069,
                "title": "python3-easiest-solution-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Using DFS traversal we can solve this.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- if current node is leaf node then meassure distance from root if minimum then previous then update minimum.\\n- if not then move to left and right nodes and repeat same.\\n- if current node is None then return from that node.\\n- now return mini+1, because nodes = level + 1\\n- if root is None return 0.\\n\\n# Complexity\\n- Time complexity: O(H)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(H)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        if root == None:\\n            return 0\\n        mini = float(\"inf\")\\n        def dfs(curr = root, level = 0):\\n            nonlocal mini\\n            if curr:\\n                if curr.left==None and curr.right==None:\\n                    mini = min(mini, level)\\n                else:\\n                    dfs(curr.left, level + 1)\\n                    dfs(curr.right, level + 1)\\n            return\\n        dfs()\\n        return mini+1\\n```\\n# Please like and comment below.\\n# (\\u3063\\uFF3E\\u25BF\\uFF3E)\\u06F6\\uD83C\\uDF78\\uD83C\\uDF1F\\uD83C\\uDF7A\\u0669(\\u02D8\\u25E1\\u02D8 )",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        if root == None:\\n            return 0\\n        mini = float(\"inf\")\\n        def dfs(curr = root, level = 0):\\n            nonlocal mini\\n            if curr:\\n                if curr.left==None and curr.right==None:\\n                    mini = min(mini, level)\\n                else:\\n                    dfs(curr.left, level + 1)\\n                    dfs(curr.right, level + 1)\\n            return\\n        dfs()\\n        return mini+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944411,
                "title": "clean-easy-to-understand-recursive-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(log(N)) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        if(root == null)\\n            return 0;\\n\\n        //Your are at leaf node, done call further just return \\n        if(root.left == null && root.right==null)\\n            return 1;\\n        \\n        int l = minDepth(root.left);\\n        int r = minDepth(root.right);\\n\\n        //edge case very important \\n        if(root.left == null || root.right==null)\\n            return 1+Math.max(l,r);\\n\\n        return 1+Math.min(l,r);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        if(root == null)\\n            return 0;\\n\\n        //Your are at leaf node, done call further just return \\n        if(root.left == null && root.right==null)\\n            return 1;\\n        \\n        int l = minDepth(root.left);\\n        int r = minDepth(root.right);\\n\\n        //edge case very important \\n        if(root.left == null || root.right==null)\\n            return 1+Math.max(l,r);\\n\\n        return 1+Math.min(l,r);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753110,
                "title": "java-easy-1ms-beats-99-bfs-dfs-solution-with-explanation",
                "content": "**Approach 1: BFS approach/level order traversal. Faster compared to DFS. Here we are using the concept of level order traversal to check if we encountered any leaf node. Simple**\\n```\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n      Queue<TreeNode> q = new LinkedList<>();\\n        if(root == null)\\n            return 0;\\n        int minDepth = 0;\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i=0; i< size;i++ ){\\n                TreeNode node = q.poll();\\n                if(node.left == null && node.right == null)\\n                    return minDepth+1;\\n                if(node.left != null)\\n                    q.add(node.left);\\n                if(node.right != null)\\n                    q.add(node.right);\\n            }\\n            minDepth++;\\n            \\n        }\\n        return minDepth;\\n    }   \\n      \\n}\\n```\\n**Approach 2: The usual DFS/recursive: FInd the height of left subtree and right subtree and take minimum of the two. One edge case if all that if either of left node/right node is completely null like below.**\\n**In that case we the length of left subtree will be 0 and assuming right substree is non zero. min(left,right) will give 0+1 =1 which is WA. To avoid that case we are doing ( left == 0 || right == 0)? right + left+1.**\\n\\n*Note second approach is slower as we are going to the depth of each sub tree whereas bfs only checks for the leaf node.*\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t1\\n\\t\\t\\t\\t  \\\\\\n\\t\\t\\t\\t\\t2\\n\\t\\t\\t\\t\\t  \\\\\\n\\t\\t\\t\\t\\t\\t3\\n\\t\\t\\t\\t\\t\\t  \\\\\\n\\t\\t\\t\\t\\t\\t    4\\n\\n```\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n       return cal(root) ;\\n    }\\n    public int cal(TreeNode root){\\n        if(root == null)\\n           return 0;\\n        int left = cal(root.left);\\n        \\n        \\n        int right = cal(root.right);\\n        \\n        return( left == 0 || right == 0)? right + left+1 : 1 + Math.min(left,right);\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n      Queue<TreeNode> q = new LinkedList<>();\\n        if(root == null)\\n            return 0;\\n        int minDepth = 0;\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i=0; i< size;i++ ){\\n                TreeNode node = q.poll();\\n                if(node.left == null && node.right == null)\\n                    return minDepth+1;\\n                if(node.left != null)\\n                    q.add(node.left);\\n                if(node.right != null)\\n                    q.add(node.right);\\n            }\\n            minDepth++;\\n            \\n        }\\n        return minDepth;\\n    }   \\n      \\n}\\n```\n```\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n       return cal(root) ;\\n    }\\n    public int cal(TreeNode root){\\n        if(root == null)\\n           return 0;\\n        int left = cal(root.left);\\n        \\n        \\n        int right = cal(root.right);\\n        \\n        return( left == 0 || right == 0)? right + left+1 : 1 + Math.min(left,right);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2523590,
                "title": "java-solution-using-bfs-easy-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        if(root == null){\\n            return 0;\\n        }\\n        int depth = 1;\\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode node = q.poll();\\n                if(node.left == null && node.right == null){\\n                    return depth;\\n                }\\n                if(node.left != null){\\n                    q.offer(node.left);\\n                }\\n                if(node.right != null){\\n                    q.offer(node.right);\\n                }\\n            }\\n            depth++;\\n        }\\n        return depth;\\n    }\\n}\\n```\\n**Happy Coding**",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        if(root == null){\\n            return 0;\\n        }\\n        int depth = 1;\\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode node = q.poll();\\n                if(node.left == null && node.right == null){\\n                    return depth;\\n                }\\n                if(node.left != null){\\n                    q.offer(node.left);\\n                }\\n                if(node.right != null){\\n                    q.offer(node.right);\\n                }\\n            }\\n            depth++;\\n        }\\n        return depth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2193075,
                "title": "c-bfs-solution-explained",
                "content": "> Please upvote if this helped!\\n\\nRuntime Complexity: **`O(n)`**\\nExplanation: We have to visit each node once.\\nSpace Complexity: **`O(n)`**\\nAt worst, we have to store the entire bottom level of the tree in our BFS\\'s queue(n/2 + 1 nodes).\\n\\nThe idea is to go layer by layer starting from the root node until one layer contains a leaf node. We can check if a node is a leaf node by checking if `node.left is null && node.right is null`. To go layer by layer, we simply use a queue to enqueue each layer(note that since the queue size is changing, we need to store the original size externally).\\n\\n```\\npublic class Solution {\\n    public int MinDepth(TreeNode root) {\\n        if(root is null){return 0;}\\n        \\n        Queue<TreeNode> queue = new Queue<TreeNode>();\\n        queue.Enqueue(root); //have to start with the root\\n        int depth = 1; //root node is counted as a layer\\n        \\n        while(queue.Count > 0){\\n            int size = queue.Count; //Get the current # of nodes so we can enqueue their children\\n            for(int i = 0; i < size; i++){\\n                TreeNode node = queue.Dequeue();\\n                if(node.left is null && node.right is null){return depth;} //If a node has no children then it is a leaf node and we return\\n                if(node.left != null){queue.Enqueue(node.left);}\\n                if(node.right != null){queue.Enqueue(node.right);}\\n            }\\n            depth++;\\n        }\\n        return depth;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinDepth(TreeNode root) {\\n        if(root is null){return 0;}\\n        \\n        Queue<TreeNode> queue = new Queue<TreeNode>();\\n        queue.Enqueue(root); //have to start with the root\\n        int depth = 1; //root node is counted as a layer\\n        \\n        while(queue.Count > 0){\\n            int size = queue.Count; //Get the current # of nodes so we can enqueue their children\\n            for(int i = 0; i < size; i++){\\n                TreeNode node = queue.Dequeue();\\n                if(node.left is null && node.right is null){return depth;} //If a node has no children then it is a leaf node and we return\\n                if(node.left != null){queue.Enqueue(node.left);}\\n                if(node.right != null){queue.Enqueue(node.right);}\\n            }\\n            depth++;\\n        }\\n        return depth;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181987,
                "title": "easy-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if (root == NULL) {\\n            return 0;\\n        }\\n        int l = minDepth(root -> left), r = minDepth(root -> right);\\n        return (l == 0 or r == 0) ? 1 + max(l, r) : 1 + min(l, r);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if (root == NULL) {\\n            return 0;\\n        }\\n        int l = minDepth(root -> left), r = minDepth(root -> right);\\n        return (l == 0 or r == 0) ? 1 + max(l, r) : 1 + min(l, r);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541464,
                "title": "c-beats-97-5-with-comments-easy-bfs",
                "content": "\\t\\t\\n\\tclass Solution {\\n\\tpublic:\\n    int minDepth(TreeNode* root) {\\n        queue<TreeNode*>q;\\n\\t\\t\\n        if(root==NULL)\\n            return 0;\\n\\t\\t\\t\\n        q.push(root);\\n        q.push(NULL);\\n        int lev=1;\\n        while(!(q.front()==NULL and q.back()==NULL))\\n        {\\n            TreeNode* x=q.front();\\n            q.pop();\\n        \\n            if(!x)\\n            {\\n                q.push(NULL);                        // a NULL encountered means the currrent level is traversed and we proceed to next level\\n                lev++;\\n            }\\n            else\\n            {\\n                if(x->left)\\n                    q.push(x->left);\\n                else if(!x->right)                  // neither left nor right child\\n                    return lev;                  \\n\\t\\t\\t\\t\\t\\n                if(x->right)\\n                    q.push(x->right);\\n            }\\n        }\\n        return lev;             //un-needed return statement, only the return statement inside the loop will do the job\\n    }\\n\\t};\\n\\t\\n***Pls UPVOTE if this helps!***\\n*Let me know your dbts in comments and I will try answering them ! *",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue",
                    "Iterator"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int minDepth(TreeNode* root) {\\n        queue<TreeNode*>q;\\n\\t\\t\\n        if(root==NULL)\\n            return 0;\\n\\t\\t\\t\\n        q.push(root);\\n        q.push(NULL);\\n        int lev=1;\\n        while(!(q.front()==NULL and q.back()==NULL))\\n        {\\n            TreeNode* x=q.front();\\n            q.pop();\\n        \\n            if(!x)\\n            {\\n                q.push(NULL);                        // a NULL encountered means the currrent level is traversed and we proceed to next level\\n                lev++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 725984,
                "title": "python-3-easy-understanding-dfs-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minDepth(self, root: TreeNode) -> int:\\n        # DFS\\n        if not root:\\n            return 0\\n        \\n        if not root.left:\\n            return self.minDepth(root.right) + 1\\n        \\n        if not root.right:\\n            return self.minDepth(root.left) + 1\\n        \\n        else:\\n            return min(self.minDepth(root.left), self.minDepth(root.right)) + 1\\n        \\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minDepth(self, root: TreeNode) -> int:\\n        # DFS\\n        if not root:\\n            return 0\\n        \\n        if not root.left:\\n            return self.minDepth(root.right) + 1\\n        \\n        if not root.right:\\n            return self.minDepth(root.left) + 1\\n        \\n        else:\\n            return min(self.minDepth(root.left), self.minDepth(root.right)) + 1\\n        \\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254240,
                "title": "readable-code-from-the-definition-of-the-minimum-depth",
                "content": "**minDepth() vs MaxDepth()/getHeight()**\\n\\nAt the first look, I thought it is the same as the `maxDepth/getHeight()` problem, just change `Math.max()` to `Math.min()`, but I was **wrong**!!!\\n\\nFor the `maxDepth()/getHeight()` problem, **leaf nodes will always be in the longest path**. So we do not need to care about anything. But for `minDepth()`, if there is one branch for a node, path has to go that branch rather than stop here because it is not a leaf node. For example:\\n\\n```\\n\\t\\t6\\n\\t   /  \\\\\\n\\t  4*   7\\n\\t   \\\\\\n\\t\\t6*\\n\\t   /\\n\\t  5 \\n```\\n\\nFor node 4, the minDepth is `3`.\\nFor node 6, the minDepth is `2`.\\n...\\n\\n---\\nBasically we are looking for the paths where leaf nodes exist. And find the shortest path. So the base case in recursion should be: **if the current node is leaf node**.\\n\\n```java\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        if(root == null) return 0;\\n        \\n        if(root.left == null && root.right == null) return 1; //leaf node\\n        \\n\\t\\tint left = minDepth(root.left);\\n        int right = minDepth(root.right);\\n        if(root.left == null) return right + 1; // leaf nodes are in right subtree\\n        if(root.right == null) return left + 1; // leaf nodes are in left subtree\\n\\n        // if left/right subtrees both contains leaf nodes\\n        return Math.min(left, right) + 1;\\n    }\\n}\\n```\\n\\n---\\nTime complexity: `O(n)`\\nSpace complexity: `O(height)`",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\t6\\n\\t   /  \\\\\\n\\t  4*   7\\n\\t   \\\\\\n\\t\\t6*\\n\\t   /\\n\\t  5 \\n```\n```java\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        if(root == null) return 0;\\n        \\n        if(root.left == null && root.right == null) return 1; //leaf node\\n        \\n\\t\\tint left = minDepth(root.left);\\n        int right = minDepth(root.right);\\n        if(root.left == null) return right + 1; // leaf nodes are in right subtree\\n        if(root.right == null) return left + 1; // leaf nodes are in left subtree\\n\\n        // if left/right subtrees both contains leaf nodes\\n        return Math.min(left, right) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 111101,
                "title": "javascript-dfs-solution",
                "content": "```\\nvar minDepth = function(root) {\\n    if(!root) return 0;\\n    var result;\\n    function minHeight(root, depth){\\n        if(!root.left && !root.right){\\n            result = Math.min(result || depth, depth)\\n        }\\n        if(root.left) minHeight(root.left, depth + 1);\\n        if(root.right) minHeight(root.right, depth + 1);\\n    }\\n    minHeight(root, 1);\\n    return result;\\n};",
                "solutionTags": [],
                "code": "```\\nvar minDepth = function(root) {\\n    if(!root) return 0;\\n    var result;\\n    function minHeight(root, depth){\\n        if(!root.left && !root.right){\\n            result = Math.min(result || depth, depth)\\n        }\\n        if(root.left) minHeight(root.left, depth + 1);\\n        if(root.right) minHeight(root.right, depth + 1);\\n    }\\n    minHeight(root, 1);\\n    return result;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 36136,
                "title": "clean-c",
                "content": "```\\nint minDepth(struct TreeNode* root) {\\n    if(root == NULL) return 0;\\n    int l = minDepth(root->left);\\n    int r = minDepth(root->right);\\n    if(l == 0 || r == 0) return 1 + l + r;\\n    return 1 + (l > r ? r : l);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minDepth(struct TreeNode* root) {\\n    if(root == NULL) return 0;\\n    int l = minDepth(root->left);\\n    int r = minDepth(root->right);\\n    if(l == 0 || r == 0) return 1 + l + r;\\n    return 1 + (l > r ? r : l);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36159,
                "title": "3-java-solutions-include-recursive-bfs-dfs",
                "content": "recursive:\\n\\n    public int minDepth(TreeNode root){\\n        if(root==null) return 0;\\n        if(root.left!=null&&root.right!=null)return Math.min(minDepth(root.left),minDepth(root.right))+1;\\n        else if(root.left==null) return minDepth(root.right)+1;\\n        else if(root.right==null) return minDepth(root.left)+1;\\n        else return 1;\\n        \\n    }\\n\\nBFS:\\n\\n    public int minDepth(TreeNode root) {\\n        if(root==null) return 0;\\n        Queue<TreeNode> queue=new LinkedList<TreeNode>();\\n        queue.add(root);\\n        int size,level=1;\\n        TreeNode tn;\\n        while(!queue.isEmpty()){\\n            size=queue.size();\\n            for(int i=0;i<size;i++){\\n                tn=queue.remove();\\n                if(tn.left==null&&tn.right==null){\\n                    return level;\\n                }else{\\n                    if(tn.left!=null) queue.add(tn.left);\\n                    if(tn.right!=null) queue.add(tn.right);\\n                }\\n            }\\n            level++;\\n        }\\n        return level;\\n    }\\n\\nDFS:\\n\\n    public int minDepth(TreeNode root){\\n        if(root==null) return 0;\\n        Stack<TreeNode> stack=new Stack<TreeNode>();\\n        TreeNode tp,lastVisited=null,n;\\n        int min=Integer.MAX_VALUE;\\n        while(root!=null||!stack.isEmpty()){\\n            if(root!=null){\\n                stack.push(root);\\n                root=root.left;\\n            }else{\\n                tp=stack.peek();\\n                if(tp.right!=null&&tp.right!=lastVisited){\\n                    root=tp.right;\\n                }else{\\n                    if(tp.left==null&&tp.right==null){\\n                        if(stack.size()<min) min=stack.size();\\n                    }\\n                    lastVisited=stack.pop();\\n                }\\n            }\\n        }\\n        return min;\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "recursive:\\n\\n    public int minDepth(TreeNode root){\\n        if(root==null) return 0;\\n        if(root.left!=null&&root.right!=null)return Math.min(minDepth(root.left),minDepth(root.right))+1;\\n        else if(root.left==null) return minDepth(root.right)+1;\\n        else if(root.right==null) return minDepth(root.left)+1;\\n        else return 1;\\n        \\n    }\\n\\nBFS:\\n\\n    public int minDepth(TreeNode root) {\\n        if(root==null) return 0;\\n        Queue<TreeNode> queue=new LinkedList<TreeNode>();\\n        queue.add(root);\\n        int size,level=1;\\n        TreeNode tn;\\n        while(!queue.isEmpty()){\\n            size=queue.size();\\n            for(int i=0;i<size;i++){\\n                tn=queue.remove();\\n                if(tn.left==null&&tn.right==null){\\n                    return level;\\n                }else{\\n                    if(tn.left!=null) queue.add(tn.left);\\n                    if(tn.right!=null) queue.add(tn.right);\\n                }\\n            }\\n            level++;\\n        }\\n        return level;\\n    }\\n\\nDFS:\\n\\n    public int minDepth(TreeNode root){\\n        if(root==null) return 0;\\n        Stack<TreeNode> stack=new Stack<TreeNode>();\\n        TreeNode tp,lastVisited=null,n;\\n        int min=Integer.MAX_VALUE;\\n        while(root!=null||!stack.isEmpty()){\\n            if(root!=null){\\n                stack.push(root);\\n                root=root.left;\\n            }else{\\n                tp=stack.peek();\\n                if(tp.right!=null&&tp.right!=lastVisited){\\n                    root=tp.right;\\n                }else{\\n                    if(tp.left==null&&tp.right==null){\\n                        if(stack.size()<min) min=stack.size();\\n                    }\\n                    lastVisited=stack.pop();\\n                }\\n            }\\n        }\\n        return min;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36173,
                "title": "java-0ms-answer-same-idea-as-maximum-depth-of-bt",
                "content": "public class Solution {\\n    \\n    public int minDepth(TreeNode root) {\\n        \\n        if(root == null) return 0;\\n        \\n        if(root.left != null && root.right != null){\\n            return Math.min(minDepth(root.left),minDepth(root.right)) + 1;\\n        }else{\\n            return Math.max(minDepth(root.left),minDepth(root.right)) + 1;\\n        }\\n            \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public int minDepth(TreeNode root) {\\n        \\n        if(root == null) return 0;\\n        \\n        if(root.left != null && root.right != null){\\n            return Math.min(minDepth(root.left),minDepth(root.right)) + 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36099,
                "title": "4-ms-c-solution-easy-to-understand",
                "content": "    int minDepth(struct TreeNode* root) {\\n     if( root == NULL ) return 0;\\n     int rDepth = minDepth( root->right ) + 1;\\n     int lDepth = minDepth( root->left ) + 1;\\n     if( root->right == NULL )\\n     {\\n         return lDepth;\\n     }\\n     else if( root->left == NULL )\\n     {\\n         return rDepth;\\n     }\\n     else\\n     {\\n         return rDepth < lDepth ? rDepth : lDepth;\\n     }\\n    \\n    }",
                "solutionTags": [],
                "code": "    int minDepth(struct TreeNode* root) {\\n     if( root == NULL ) return 0;\\n     int rDepth = minDepth( root->right ) + 1;\\n     int lDepth = minDepth( root->left ) + 1;\\n     if( root->right == NULL )\\n     {\\n         return lDepth;\\n     }\\n     else if( root->left == NULL )\\n     {\\n         return rDepth;\\n     }\\n     else\\n     {\\n         return rDepth < lDepth ? rDepth : lDepth;\\n     }\\n    \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4087308,
                "title": "best-o-n-solution",
                "content": "# Approach\\nDFS Traversal\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if (!root)\\n            return 0;\\n        if (!root->left && !root->right)\\n            return 1;\\n        int leftDepth = INT_MAX;\\n        if (root->left)\\n            leftDepth = minDepth(root->left);\\n        int rightDepth = INT_MAX;\\n        if (root->right)\\n            rightDepth = minDepth(root->right);\\n\\n        return min (leftDepth, rightDepth) + 1;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if (!root)\\n            return 0;\\n        if (!root->left && !root->right)\\n            return 1;\\n        int leftDepth = INT_MAX;\\n        if (root->left)\\n            leftDepth = minDepth(root->left);\\n        int rightDepth = INT_MAX;\\n        if (root->right)\\n            rightDepth = minDepth(root->right);\\n\\n        return min (leftDepth, rightDepth) + 1;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745781,
                "title": "easy-c-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\nThe problem asks for the minimum depth of a binary tree, which is defined as the number of nodes along the **shortest** path from the root node to the nearest leaf node.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we can use a recursive approach. We\\'ll start from the root node and traverse the tree. We\\'ll consider two cases:\\n\\n1. If the current node is a leaf node (i.e., it has no children), we\\'ll return 1, indicating that this is the minimum depth at this point.\\n2. If the current node has only one child (either left or right), we\\'ll recursively calculate the minimum depth of that child and add 1 to it.\\n- If neither of the above cases applies, it means the current node has both left and right children. In this case, we\\'ll recursively calculate the minimum depth of both children and return the minimum of the two, plus 1 (to account for the current node).\\n# Complexity\\n- Time complexity:  $$O(N)$$\\n     -    where N is the number of nodes in the binary tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(H)$$ \\n    -    where H is the height of the binary tree\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   int minDepth(TreeNode* root) {\\n    // Base case: If the root is null, the depth is 0.\\n    if (!root)\\n        return 0;\\n    \\n    // Case 1: Only left child exists, return 1 plus the minimum depth of the left subtree.\\n    if (root->left && !root->right)\\n        return 1 + minDepth(root->left);\\n    \\n    // Case 2: Only right child exists, return 1 plus the minimum depth of the right subtree.\\n    else if (root->right && !root->left)\\n        return 1 + minDepth(root->right);\\n    \\n    // Case 3: Both left and right children exist, return 1 plus the minimum depth among both subtrees.\\n    else {\\n        int left = minDepth(root->left);\\n        int right = minDepth(root->right);\\n        return 1 + min(left, right);\\n    }\\n    \\n    // Default return (not necessary in this case, as all possible scenarios are covered above).\\n    return 0;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   int minDepth(TreeNode* root) {\\n    // Base case: If the root is null, the depth is 0.\\n    if (!root)\\n        return 0;\\n    \\n    // Case 1: Only left child exists, return 1 plus the minimum depth of the left subtree.\\n    if (root->left && !root->right)\\n        return 1 + minDepth(root->left);\\n    \\n    // Case 2: Only right child exists, return 1 plus the minimum depth of the right subtree.\\n    else if (root->right && !root->left)\\n        return 1 + minDepth(root->right);\\n    \\n    // Case 3: Both left and right children exist, return 1 plus the minimum depth among both subtrees.\\n    else {\\n        int left = minDepth(root->left);\\n        int right = minDepth(root->right);\\n        return 1 + min(left, right);\\n    }\\n    \\n    // Default return (not necessary in this case, as all possible scenarios are covered above).\\n    return 0;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743620,
                "title": "python-3-9-lines-stack-t-m-94-99",
                "content": "```\\nclass Solution: \\n    def minDepth(self, root: TreeNode) -> int:\\n\\n        if not root: return 0\\n        level, queue = 0, deque([root]) \\n\\n        while queue:\\n\\n            level+= 1\\n\\n            for x in range(len(queue)):\\n\\n                n = queue.popleft()\\n                if not n.left and not n.right: return level\\n\\n                if n.left : queue.append(n. left)\\n                if n.right: queue.append(n.right)\\n```\\n[https://leetcode.com/problems/minimum-depth-of-binary-tree/submissions/1059358766/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*B*), in which *N* ~ `len(nums)` and *B* ~ width of the tree.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution: \\n    def minDepth(self, root: TreeNode) -> int:\\n\\n        if not root: return 0\\n        level, queue = 0, deque([root]) \\n\\n        while queue:\\n\\n            level+= 1\\n\\n            for x in range(len(queue)):\\n\\n                n = queue.popleft()\\n                if not n.left and not n.right: return level\\n\\n                if n.left : queue.append(n. left)\\n                if n.right: queue.append(n.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743524,
                "title": "c-depth-first-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->My initial thoughts on how to solve this problem would be as follows:\\n\\n1. We need to find the minimum depth of a binary tree, which is the shortest path from the root node to any leaf node.\\n2. To find the minimum depth, we can perform a level-order traversal of the tree.\\n3. We can use a queue data structure to keep track of the nodes at each level as we traverse the tree.\\n4. Start by checking if the root is null. If it is, the minimum depth is 0, and we can return that.\\n5. Initialize the minimum depth as 0 and create an empty queue.\\n6. Add the root node to the queue.\\n7. While the queue is not empty, perform the following steps:\\n   - Get the number of nodes at the current level by checking the size of the queue.\\n   - Increment the minimum depth since we are moving to the next level.\\n   - Process all the nodes at the current level by using a loop that runs for the number of nodes at that level.\\n   - For each node, check if it has a left child. If it does, add it to the queue.\\n   - Similarly, check if the node has a right child and add it to the queue if it exists.\\n   - If the current node is a leaf node (i.e., it has no left or right child), return the minimum depth, as we have found the shortest path.\\n8. If we have traversed the entire tree and haven\\'t encountered a leaf node, return the minimum depth as the final result.\\n\\nThis approach ensures that we traverse the tree level by level and find the minimum depth by keeping track of the current level using the queue and a variable for the minimum depth.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->To solve the problem of finding the minimum depth of a binary tree, I would use a level-order traversal approach. Here is a step-by-step explanation of the approach:\\n\\n1. First, we need to handle the base case where the root is null. If the root is null, it means the tree is empty, so the minimum depth is 0. In this case, we can simply return 0.\\n\\n2. We will use a queue to perform a level-order traversal of the tree. We start by pushing the root node into the queue.\\n\\n3. We enter a loop that continues until the queue becomes empty. This loop represents the level-order traversal.\\n\\n4. Inside the loop, we keep track of the number of nodes at the current level by getting the size of the queue before processing the nodes. We store this size in a variable.\\n\\n5. We increment a variable called `minDepth` to keep track of the current level we are traversing. This variable will represent the minimum depth of the tree.\\n\\n6. We enter another loop that iterates `size` times. This loop represents processing all the nodes at the current level.\\n\\n7. For each node, we dequeue it from the queue and check if it has a left child. If it does, we enqueue the left child into the queue.\\n\\n8. Similarly, we check if the current node has a right child. If it does, we enqueue the right child into the queue.\\n\\n9. After enqueuing the child nodes, we check if the current node is a leaf node, which means it has no left or right child. If it is a leaf node, we have found the shortest path from the root to a leaf node. In this case, we can return the current value of `minDepth` as the minimum depth of the tree.\\n\\n10. If we have processed all the nodes at the current level and haven\\'t found a leaf node, we move to the next level by continuing the outer loop.\\n\\n11. If the outer loop terminates, it means we have traversed the entire tree without finding a leaf node. In this case, we can return the current value of `minDepth` as the minimum depth of the tree.\\n\\nBy performing a level-order traversal using a queue and keeping track of the current level, we can efficiently find the minimum depth of the binary tree.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        // Check if the root is null\\n        if(root==NULL)\\n            return 0;\\n        \\n        // Initialize minimum depth as 0\\n        int minDepth=0;\\n        \\n        // Create a queue to perform level-order traversal\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        // Perform level-order traversal\\n        while(!q.empty()){\\n            // Get the number of nodes at the current level\\n            int size = q.size();\\n            \\n            // Increment the minimum depth\\n            minDepth++;\\n\\n            // Process all nodes at the current level\\n            while(size--){\\n                // Get the front node in the queue\\n                TreeNode* cur = q.front();\\n                q.pop();\\n                \\n                // Check if the current node has a left child\\n                // If it does, add it to the queue\\n                if(cur->left)\\n                    q.push(cur->left);\\n                \\n                // Check if the current node has a right child\\n                // If it does, add it to the queue\\n                if(cur->right)\\n                    q.push(cur->right);\\n                \\n                // Check if the current node is a leaf node\\n                // If it is, return the minimum depth\\n                if(cur->left == NULL && cur->right == NULL)\\n                    return minDepth;\\n            }\\n        }\\n        \\n        // Return the minimum depth of the tree\\n        return minDepth; \\n    }\\n};\\n\\n```\\n![Leetcode.jpeg](https://assets.leetcode.com/users/images/5afcc1c8-4853-4e99-8cc5-035e81919bfd_1688963444.9649549.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        // Check if the root is null\\n        if(root==NULL)\\n            return 0;\\n        \\n        // Initialize minimum depth as 0\\n        int minDepth=0;\\n        \\n        // Create a queue to perform level-order traversal\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        // Perform level-order traversal\\n        while(!q.empty()){\\n            // Get the number of nodes at the current level\\n            int size = q.size();\\n            \\n            // Increment the minimum depth\\n            minDepth++;\\n\\n            // Process all nodes at the current level\\n            while(size--){\\n                // Get the front node in the queue\\n                TreeNode* cur = q.front();\\n                q.pop();\\n                \\n                // Check if the current node has a left child\\n                // If it does, add it to the queue\\n                if(cur->left)\\n                    q.push(cur->left);\\n                \\n                // Check if the current node has a right child\\n                // If it does, add it to the queue\\n                if(cur->right)\\n                    q.push(cur->right);\\n                \\n                // Check if the current node is a leaf node\\n                // If it is, return the minimum depth\\n                if(cur->left == NULL && cur->right == NULL)\\n                    return minDepth;\\n            }\\n        }\\n        \\n        // Return the minimum depth of the tree\\n        return minDepth; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743269,
                "title": "c-bfs-dfs",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n<b>BFS</b>\\n```\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int minDepth(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int d=1;\\n        while(q.size()>0){\\n            int size=q.size();\\n            while(size--){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                \\n                if(node->left==NULL && node->right==NULL) return d;\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n            }\\n            if(q.size()) d++;\\n        }\\n        return d;\\n    }\\n};\\n```\\n\\n<b>DFS</b>\\n```\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int depth(TreeNode* root){\\n        if(root==NULL) return INT_MAX;\\n        \\n        if(root->left==NULL && root->right==NULL) return 1;\\n        int x=depth(root->left);\\n        int y=depth(root->right);\\n        \\n        return min(x,y)+1;\\n    } \\n    \\n    int minDepth(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        return depth(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int minDepth(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int d=1;\\n        while(q.size()>0){\\n            int size=q.size();\\n            while(size--){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                \\n                if(node->left==NULL && node->right==NULL) return d;\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n            }\\n            if(q.size()) d++;\\n        }\\n        return d;\\n    }\\n};\\n```\n```\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int depth(TreeNode* root){\\n        if(root==NULL) return INT_MAX;\\n        \\n        if(root->left==NULL && root->right==NULL) return 1;\\n        int x=depth(root->left);\\n        int y=depth(root->right);\\n        \\n        return min(x,y)+1;\\n    } \\n    \\n    int minDepth(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        return depth(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743183,
                "title": "c-solution-for-minimum-depth-of-binary-tree-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to find the minimum depth of a binary tree by recursively traversing its nodes and determining the depth of each subtree.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. If the root node is null, the minimum depth is 0.\\n1. If both the left and right child nodes are null, the minimum depth is 1.\\n1. If either the left or right child node is null, recursively find the minimum depth on the non-null subtree and add 1.\\n1. If both the left and right child nodes exist, recursively find the minimum depth on both subtrees and take the minimum depth, then add 1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(N), where N is the number of nodes in the binary tree. In the worst case, we may need to visit all nodes of the tree to find the minimum depth.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(H), where H is the height of the binary tree. This space is used for the recursive call stack. In the worst case, the height of the binary tree can be N, resulting in O(N) space complexity.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int MinDepth(TreeNode root) {\\n         // If the root is null, the minimum depth is 0.\\n        if (root == null)\\n            return 0;\\n        \\n        // If both left and right child nodes are null, the minimum depth is 1.\\n        if (root.left == null && root.right == null)\\n            return 1;\\n        \\n        // If the left child node is null, recursively find the minimum depth on the right subtree.\\n        if (root.left == null)\\n            return MinDepth(root.right) + 1;\\n        \\n        // If the right child node is null, recursively find the minimum depth on the left subtree.\\n        if (root.right == null)\\n            return MinDepth(root.left) + 1;\\n        \\n        // If both left and right child nodes exist, recursively find the minimum depth on both subtrees and take the minimum.\\n        return Math.Min(MinDepth(root.left), MinDepth(root.right)) + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int MinDepth(TreeNode root) {\\n         // If the root is null, the minimum depth is 0.\\n        if (root == null)\\n            return 0;\\n        \\n        // If both left and right child nodes are null, the minimum depth is 1.\\n        if (root.left == null && root.right == null)\\n            return 1;\\n        \\n        // If the left child node is null, recursively find the minimum depth on the right subtree.\\n        if (root.left == null)\\n            return MinDepth(root.right) + 1;\\n        \\n        // If the right child node is null, recursively find the minimum depth on the left subtree.\\n        if (root.right == null)\\n            return MinDepth(root.left) + 1;\\n        \\n        // If both left and right child nodes exist, recursively find the minimum depth on both subtrees and take the minimum.\\n        return Math.Min(MinDepth(root.left), MinDepth(root.right)) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743016,
                "title": "python3-solution",
                "content": "\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def minDepth(self,root:Optional[TreeNode])->int:\\n        if not root:\\n            return 0\\n\\n        if not root.left and not root.right:\\n            return 1\\n\\n        left=self.minDepth(root.left) if root.left else float(\\'inf\\')\\n        right=self.minDepth(root.right) if root.right else float(\\'inf\\')\\n\\n        return 1+min(left,right)               \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def minDepth(self,root:Optional[TreeNode])->int:\\n        if not root:\\n            return 0\\n\\n        if not root.left and not root.right:\\n            return 1\\n\\n        left=self.minDepth(root.left) if root.left else float(\\'inf\\')\\n        right=self.minDepth(root.right) if root.right else float(\\'inf\\')\\n\\n        return 1+min(left,right)               \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699503,
                "title": "simple-fast-recursive-approach",
                "content": "```\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        if(root == null){\\n\\t\\t//base condition\\n            return 0;\\n        } \\n        int left = minDepth(root.left)+1;\\n\\t\\t//left recursive call now it will traverse until the left is null and count increment also\\n        int right = minDepth(root.right)+1;\\n\\t\\t//right recursive call now it will traverse until the right is null and count increment also\\n        if(root.left == null){   //this will solve the edge cases in which the tree is only one sided\\n            return right;\\n        }\\n        if(root.right == null){  //this will solve the edge cases in which the tree is only one sided\\n            return left;\\n        }\\n        int depth = Math.min(left,right);\\n\\t\\t//calculating the work question asked by getting the minimum and returning it\\n        return depth;\\n    }\\n}\\n```\\n**FEEL FREE TO ASK ANY DOUBT IN THE COMMENTS HAPPY TO HELP!!!**\\n*UPVOTE IF YOU LIKE*",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        if(root == null){\\n\\t\\t//base condition\\n            return 0;\\n        } \\n        int left = minDepth(root.left)+1;\\n\\t\\t//left recursive call now it will traverse until the left is null and count increment also\\n        int right = minDepth(root.right)+1;\\n\\t\\t//right recursive call now it will traverse until the right is null and count increment also\\n        if(root.left == null){   //this will solve the edge cases in which the tree is only one sided\\n            return right;\\n        }\\n        if(root.right == null){  //this will solve the edge cases in which the tree is only one sided\\n            return left;\\n        }\\n        int depth = Math.min(left,right);\\n\\t\\t//calculating the work question asked by getting the minimum and returning it\\n        return depth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3191727,
                "title": "python-recursive-code-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        def count(root):\\n            if root is None:\\n                return 0\\n            if root.left is None:\\n                return count(root.right) + 1\\n            if root.right is None:\\n                return count(root.left) + 1\\n            return min(count(root.left), count(root.right)) + 1\\n        return count(root)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        def count(root):\\n            if root is None:\\n                return 0\\n            if root.left is None:\\n                return count(root.right) + 1\\n            if root.right is None:\\n                return count(root.left) + 1\\n            return min(count(root.left), count(root.right)) + 1\\n        return count(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135655,
                "title": "easy-beginner-friendly-recursion-code-with-explanation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReturn 0 when we reach leaf node and add 1 to it to count the node itself\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nthere are two main cases\\n\\nCase 1\\nWhen your root node has both left and right node then you simply find the minimum of the left subtree and right subtree and add 1 to it to count the root node\\n\\nCase 2\\nwhen you either have left or right node but not both. Then you simply return the maximum height of the available subtree\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\nBecause we r travelling to every node\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\nFor test cases having a linked list like tree meaning we find the  height of the tree which has maximum of n function calls where n is number of nodes.\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        if(root->left != NULL && root->right != NULL){\\n            return (1+min(minDepth(root->left), minDepth(root->right)));\\n        }\\n        else{\\n            return (1+max(minDepth(root->left), minDepth(root->right)));\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        if(root->left != NULL && root->right != NULL){\\n            return (1+min(minDepth(root->left), minDepth(root->right)));\\n        }\\n        else{\\n            return (1+max(minDepth(root->left), minDepth(root->right)));\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083247,
                "title": "c-recursion-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(logn)$$\\n\\n- Space complexity:$$O(logn)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(!root){\\n            return 0;\\n        }\\n        else if(!root->left){\\n            return 1+minDepth(root->right);\\n        }\\n        else if(!root->right){\\n            return 1+minDepth(root->left);\\n        }\\n        return 1+min(minDepth(root->left), minDepth(root->right));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(!root){\\n            return 0;\\n        }\\n        else if(!root->left){\\n            return 1+minDepth(root->right);\\n        }\\n        else if(!root->right){\\n            return 1+minDepth(root->left);\\n        }\\n        return 1+min(minDepth(root->left), minDepth(root->right));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039964,
                "title": "dfs-solution-with-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe perform a depth first search to keep track of the minimum depth among the left and right subtrees recursively.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have the following observations:\\n\\n1) When we reach a leaf node, we must return 0.\\n\\n2) When we reach a position (anywhere in the tree) wherein we have a skewed binary tree then we must end up returning 1 + maximum of depths of left and right subtree. This is because we need the minimum depth from a LEAF NODE, not from any node which the parent of a skewed tree.\\n\\n3) When a node has its left and right children, then we simply return one more than the max of depths of left and right subtree.\\n\\nThe recursive formulation can be done as follows:\\n\\n```\\n    if(root->left == NULL || root->right == NULL)\\n        return 1 + max(depthOfleftSubtree), depthOfrightSubTree)\\n    else\\n        return 1 + min(depthOfleftSubtree), depthOfrightSubTree)\\n```\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        int leftSubTree = INT_MAX,rightSubTree = INT_MAX;\\n        leftSubTree = minDepth(root->left);\\n        rightSubTree = minDepth(root->right);\\n        if(!(root->left) || !(root->right))\\n            return 1 + max(leftSubTree,rightSubTree);\\n        return 1 + min(leftSubTree,rightSubTree);\\n    }\\n};\\n```\\n\\n### IF YOU LIKED THE SOLUTION, PLEASE CONSIDER UPVOTING IT! IT PROVIDES A LOT OF MOTIVATION TO WRITE ARTICLES LIKE THIS \\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n    if(root->left == NULL || root->right == NULL)\\n        return 1 + max(depthOfleftSubtree), depthOfrightSubTree)\\n    else\\n        return 1 + min(depthOfleftSubtree), depthOfrightSubTree)\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        int leftSubTree = INT_MAX,rightSubTree = INT_MAX;\\n        leftSubTree = minDepth(root->left);\\n        rightSubTree = minDepth(root->right);\\n        if(!(root->left) || !(root->right))\\n            return 1 + max(leftSubTree,rightSubTree);\\n        return 1 + min(leftSubTree,rightSubTree);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039695,
                "title": "easy-java-solution-dfs",
                "content": "Hope this helps.\\nDo Upvote if you like it !!\\n\\nThanks :)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n         if(root==null){\\n            return 0;\\n        }\\n        if(root.left == null && root.right==null)\\n            return 1;\\n        int lh=minDepth(root.left);\\n        int rh=minDepth(root.right);\\n        return lh==0||rh==0?1+lh+rh:Math.min(lh,rh)+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n         if(root==null){\\n            return 0;\\n        }\\n        if(root.left == null && root.right==null)\\n            return 1;\\n        int lh=minDepth(root.left);\\n        int rh=minDepth(root.right);\\n        return lh==0||rh==0?1+lh+rh:Math.min(lh,rh)+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710825,
                "title": "java-breadth-first-linear-time-extra-memory-grows-with-number-of-nodes",
                "content": "- After playing with a depth first solution for a while, I eventually understood \"minimum path length\" right.\\n- The DF solution turned out to be relatively slow, mainly because it does not guarntee to find the shortest path first. Instead, my DF approach touched every leaf in the tree before giving the result.\\n- The BF approach goes down through the tree, level by level, and each level left to right. So the first leaf (i.e. both pointers are null) must be the end point of the shortest path. The current level count must be the length of the shortest leaf path.\\n- It turns out, breadth first is the fastest approach, because it doesn\\'t exhaustively search extra paths. It stops as early as possible.\\n```java\\n    public int minDepth(TreeNode root) {\\n\\n        if (root != null) {\\n\\n            Queue<TreeNode> queue = new LinkedList<>();\\n            queue.add(root);\\n\\n            int depth = 1;\\n            while (!queue.isEmpty()) {\\n\\n                int width = queue.size();\\n                while (width > 0) {\\n                    TreeNode current = queue.remove();\\n                    if (current.left == null && current.right == null) return depth;\\n                    if (current.left != null) queue.add(current.left);\\n                    if (current.right != null) queue.add(current.right);\\n                    width -= 1;\\n                }\\n\\n                depth += 1;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n    public int minDepth(TreeNode root) {\\n\\n        if (root != null) {\\n\\n            Queue<TreeNode> queue = new LinkedList<>();\\n            queue.add(root);\\n\\n            int depth = 1;\\n            while (!queue.isEmpty()) {\\n\\n                int width = queue.size();\\n                while (width > 0) {\\n                    TreeNode current = queue.remove();\\n                    if (current.left == null && current.right == null) return depth;\\n                    if (current.left != null) queue.add(current.left);\\n                    if (current.right != null) queue.add(current.right);\\n                    width -= 1;\\n                }\\n\\n                depth += 1;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2632384,
                "title": "python-elegant-short-dfs",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n)\\n    Memory: O(n)\\n    \"\"\"\\n\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        if root is None:\\n            return 0\\n\\n        left_depth = self.minDepth(root.left)\\n        right_depth = self.minDepth(root.right)\\n\\n        return 1 + (\\n            min(left_depth, right_depth) or\\n            max(left_depth, right_depth)\\n        )\\n```\\nIf you like this solution remember to **upvote it** to let me know.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n)\\n    Memory: O(n)\\n    \"\"\"\\n\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        if root is None:\\n            return 0\\n\\n        left_depth = self.minDepth(root.left)\\n        right_depth = self.minDepth(root.right)\\n\\n        return 1 + (\\n            min(left_depth, right_depth) or\\n            max(left_depth, right_depth)\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642038,
                "title": "5-ms-java-solution",
                "content": "```\\nclass Solution {\\n    int min=Integer.MAX_VALUE;\\n    public int minDepth(TreeNode root) {\\n        helper(root,1);\\n        if(min==2147483647)\\n        {\\n            return 0;\\n        }\\n        return min;\\n    }\\n    public void helper (TreeNode root,int depth) {\\n        if(root==null)\\n        {\\n            return;\\n        }\\n        if(root.left==null && root.right==null)\\n        {\\n            min=Math.min(min,depth);\\n        }\\n        helper(root.left,depth+1);\\n        helper(root.right,depth+1);\\n       }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int min=Integer.MAX_VALUE;\\n    public int minDepth(TreeNode root) {\\n        helper(root,1);\\n        if(min==2147483647)\\n        {\\n            return 0;\\n        }\\n        return min;\\n    }\\n    public void helper (TreeNode root,int depth) {\\n        if(root==null)\\n        {\\n            return;\\n        }\\n        if(root.left==null && root.right==null)\\n        {\\n            min=Math.min(min,depth);\\n        }\\n        helper(root.left,depth+1);\\n        helper(root.right,depth+1);\\n       }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637298,
                "title": "python-bfs-approach-iterative",
                "content": "BFS approach capitalizes on the fact that we will be scanning the tree level by level and from left to right. This essentially means that the very first node without children can be considered as the node at the shallowest level. Even if we have sibling nodes on the same level which has the same depth, all we need for this exercise is to return the minimum depth and this is enough. If the exercise asks for `all the paths that are minimum depth`, then we have to keep looking and collect all possible paths which are minimum depth of this tree.\\n\\nWe have to carry over the `level` information during our level by level scanning so that we can return the level immediately as soon as we find a node without any children. For every node, once we start to scan the left and right children of the node, we add the `level` by `1`.\\n\\n``` Python\\nclass Solution:\\n    def minDepth(self, root):\\n        if root is None:\\n            return 0\\n        # We will be using a queue\\n\\t\\t# For example, a binary tree\\n\\t\\t#             1\\n\\t\\t#           /   \\\\\\n\\t\\t#         2       3\\n\\t\\t#          \\\\     / \\\\\\n\\t\\t#           4   5   6\\n\\t\\t# If we populate the queue for all the nodes, the queue will look like:\\n\\t\\t# [1,2,3,4,5,6] <- inserted level by level, from left to right\\n\\t\\t# However, we always want to carry over the level information so here, we are creating\\n\\t\\t# a queue with tuples of tree node, level for elements\\n        queue = deque([(root, 1)])\\n\\n        while len(queue) != 0:\\n            node, level = queue.popleft()\\n            if node:\\n                if node.left is None and node.right is None:\\n\\t\\t\\t\\t# This is the leaf node, and if we find this node, \\n\\t\\t\\t\\t# we can surely say this is the shallowest path in the tree\\n\\t\\t\\t\\t# Imagine this tree\\n\\t\\t\\t\\t#          1\\n\\t\\t\\t\\t#        /   \\\\\\n\\t\\t\\t\\t#      2       3\\n\\t\\t\\t\\t#     /\\n\\t\\t\\t\\t#   4\\n\\t\\t\\t\\t# Since we are scanning from top-down, left-right, once we get to the node 3, we\\n\\t\\t\\t\\t# can immediately tell that it is the shallowest path\\n                    return level\\n                else:\\n                    queue.append((node.left, level+1))\\n                    queue.append((node.right, level+1))\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "``` Python\\nclass Solution:\\n    def minDepth(self, root):\\n        if root is None:\\n            return 0\\n        # We will be using a queue\\n\\t\\t# For example, a binary tree\\n\\t\\t#             1\\n\\t\\t#           /   \\\\\\n\\t\\t#         2       3\\n\\t\\t#          \\\\     / \\\\\\n\\t\\t#           4   5   6\\n\\t\\t# If we populate the queue for all the nodes, the queue will look like:\\n\\t\\t# [1,2,3,4,5,6] <- inserted level by level, from left to right\\n\\t\\t# However, we always want to carry over the level information so here, we are creating\\n\\t\\t# a queue with tuples of tree node, level for elements\\n        queue = deque([(root, 1)])\\n\\n        while len(queue) != 0:\\n            node, level = queue.popleft()\\n            if node:\\n                if node.left is None and node.right is None:\\n\\t\\t\\t\\t# This is the leaf node, and if we find this node, \\n\\t\\t\\t\\t# we can surely say this is the shallowest path in the tree\\n\\t\\t\\t\\t# Imagine this tree\\n\\t\\t\\t\\t#          1\\n\\t\\t\\t\\t#        /   \\\\\\n\\t\\t\\t\\t#      2       3\\n\\t\\t\\t\\t#     /\\n\\t\\t\\t\\t#   4\\n\\t\\t\\t\\t# Since we are scanning from top-down, left-right, once we get to the node 3, we\\n\\t\\t\\t\\t# can immediately tell that it is the shallowest path\\n                    return level\\n                else:\\n                    queue.append((node.left, level+1))\\n                    queue.append((node.right, level+1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1319313,
                "title": "c-4-line-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) \\n    {\\n        if (root == nullptr)                                         return 0;\\n        else if (root->left == nullptr && root->right != nullptr)    return 1 + minDepth(root->right);\\n        else if (root->left != nullptr && root->right == nullptr)    return 1 + minDepth(root->left);\\n        else                                                         return 1 + min(minDepth(root->left), minDepth(root->right));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) \\n    {\\n        if (root == nullptr)                                         return 0;\\n        else if (root->left == nullptr && root->right != nullptr)    return 1 + minDepth(root->right);\\n        else if (root->left != nullptr && root->right == nullptr)    return 1 + minDepth(root->left);\\n        else                                                         return 1 + min(minDepth(root->left), minDepth(root->right));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292325,
                "title": "intuitive-python3-bfs-based-on-level-order-traversal",
                "content": "- Keep track of the current level in an integer\\n- Before adding more nodes to the queue, check if we have found the leaf\\n\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def minDepth(self, root: TreeNode) -> int:\\n        if not root: return 0\\n        \\n        level = 0\\n        queue = deque()\\n        queue.append(root)\\n        while queue:\\n            n = len(queue)\\n            level += 1\\n            \\n            for i in range(n):\\n                cur = queue.popleft()\\n                if not cur.left and not cur.right:\\n                    return level\\n                if cur.left:\\n                    queue.append(cur.left)\\n                if cur.right:\\n                    queue.append(cur.right)\\n```\\n\\n![image](https://assets.leetcode.com/users/images/811269bf-55a0-49eb-bb26-9b46211978b6_1624460773.775393.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def minDepth(self, root: TreeNode) -> int:\\n        if not root: return 0\\n        \\n        level = 0\\n        queue = deque()\\n        queue.append(root)\\n        while queue:\\n            n = len(queue)\\n            level += 1\\n            \\n            for i in range(n):\\n                cur = queue.popleft()\\n                if not cur.left and not cur.right:\\n                    return level\\n                if cur.left:\\n                    queue.append(cur.left)\\n                if cur.right:\\n                    queue.append(cur.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653618,
                "title": "c-bfs",
                "content": "```\\npublic class Solution {\\n    public int MinDepth(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        var queue = new Queue<TreeNode>();\\n        queue.Enqueue(root);\\n        \\n        int depth = 0;\\n        while (queue.Count != 0)\\n        {\\n            int size = queue.Count;\\n            depth++;\\n            for (int i = 0; i < size; ++i)\\n            {\\n                var curr = queue.Dequeue();\\n                \\n                if (curr.left == null && curr.right == null)\\n                {\\n                    return depth;\\n                }\\n                \\n                if (curr.left != null) queue.Enqueue(curr.left);\\n                \\n                if (curr.right != null) queue.Enqueue(curr.right);\\n            }\\n        }\\n        return depth;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinDepth(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        var queue = new Queue<TreeNode>();\\n        queue.Enqueue(root);\\n        \\n        int depth = 0;\\n        while (queue.Count != 0)\\n        {\\n            int size = queue.Count;\\n            depth++;\\n            for (int i = 0; i < size; ++i)\\n            {\\n                var curr = queue.Dequeue();\\n                \\n                if (curr.left == null && curr.right == null)\\n                {\\n                    return depth;\\n                }\\n                \\n                if (curr.left != null) queue.Enqueue(curr.left);\\n                \\n                if (curr.right != null) queue.Enqueue(curr.right);\\n            }\\n        }\\n        return depth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 320629,
                "title": "c-using-level-order-o-n-requires-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        vector<TreeNode *> aQueue;\\n        int aDepth = 0;\\n        if (root != NULL) { aQueue.push_back(root); }\\n        while (!aQueue.empty()) {\\n            ++aDepth;\\n            vector <TreeNode *> aClone = aQueue;\\n            aQueue.clear();\\n            for (auto t : aClone) {\\n                if (t->left == NULL && t->right == NULL) { return aDepth; }   \\n                if (t->left != NULL) { aQueue.push_back(t->left); }\\n                if (t->right != NULL) { aQueue.push_back(t->right); }\\n            }    \\n        }\\n        return aDepth;\\n    }\\n};\\n```\\n\\nHmm, this is one way to do it. The recursive solution that I tried did not cut the mustard.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        vector<TreeNode *> aQueue;\\n        int aDepth = 0;\\n        if (root != NULL) { aQueue.push_back(root); }\\n        while (!aQueue.empty()) {\\n            ++aDepth;\\n            vector <TreeNode *> aClone = aQueue;\\n            aQueue.clear();\\n            for (auto t : aClone) {\\n                if (t->left == NULL && t->right == NULL) { return aDepth; }   \\n                if (t->left != NULL) { aQueue.push_back(t->left); }\\n                if (t->right != NULL) { aQueue.push_back(t->right); }\\n            }    \\n        }\\n        return aDepth;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36154,
                "title": "aug-my-bfs-java-explaination-thought-it-will-be-faster-than-dfs-but-it-doesn-t-you-know-why",
                "content": "```\\npublic int minDepth(TreeNode root) {\\n                int res = 0 ;\\n\\t\\tif(root == null) return res;\\n\\t\\tLinkedList<TreeNode> queue = new LinkedList<>();//Always like linkedList\\n\\t\\tqueue.offer(root);//offer the root\\n\\t\\twhile(queue.size() > 0)//let do the level traverse\\n\\t\\t{\\n\\t\\t\\tres++;// res add one when we are at a new level\\n\\t\\t\\tint size = queue.size();//Remember the level size so you do not mess up\\n\\t\\t\\tfor(int i = 0 ; i < size ; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tTreeNode node = queue.poll();\\n//If there is a node who do not have any child, then it is a leaf and we can stop here.\\n\\t\\t\\t\\tif(node.left == null&&node.right == null)\\n\\t\\t\\t\\t\\treturn res;\\n//offer the child or children to the queue for the analysis of the next level\\n\\t\\t\\t\\tif(node.left != null)\\n\\t\\t\\t\\t\\tqueue.offer(node.left);\\n\\t\\t\\t\\tif(node.right != null)\\n\\t\\t\\t\\t\\tqueue.offer(node.right);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n```\\n1 ms, not bad. If you like it, please thumb me up or leave you comments bellow to communicate.",
                "solutionTags": [],
                "code": "```\\npublic int minDepth(TreeNode root) {\\n                int res = 0 ;\\n\\t\\tif(root == null) return res;\\n\\t\\tLinkedList<TreeNode> queue = new LinkedList<>();//Always like linkedList\\n\\t\\tqueue.offer(root);//offer the root\\n\\t\\twhile(queue.size() > 0)//let do the level traverse\\n\\t\\t{\\n\\t\\t\\tres++;// res add one when we are at a new level\\n\\t\\t\\tint size = queue.size();//Remember the level size so you do not mess up\\n\\t\\t\\tfor(int i = 0 ; i < size ; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tTreeNode node = queue.poll();\\n//If there is a node who do not have any child, then it is a leaf and we can stop here.\\n\\t\\t\\t\\tif(node.left == null&&node.right == null)\\n\\t\\t\\t\\t\\treturn res;\\n//offer the child or children to the queue for the analysis of the next level\\n\\t\\t\\t\\tif(node.left != null)\\n\\t\\t\\t\\t\\tqueue.offer(node.left);\\n\\t\\t\\t\\tif(node.right != null)\\n\\t\\t\\t\\t\\tqueue.offer(node.right);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36320,
                "title": "my-soluation-without-a-depth-table-array-by-java",
                "content": "\\n    public class Solution {\\n       public int minDepth(TreeNode root)\\n       {\\n           if(root == null) return 0;\\n        \\n           int left = 1+minDepth(root.left);\\n        \\n           int right = 1+minDepth(root.right);\\n        \\n           if(left == 1 ) return right;\\n        \\n           if(right == 1 ) return left;\\n        \\n           if( left > right )\\n               return right;\\n           else\\n               return left;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n       public int minDepth(TreeNode root)\\n       {\\n           if(root == null) return 0;\\n        \\n           int left = 1+minDepth(root.left);\\n        \\n           int right = 1+minDepth(root.right);\\n        \\n           if(left == 1 ) return right;\\n        \\n           if(right == 1 ) return left;\\n        \\n           if( left > right )\\n               return right;\\n           else\\n               return left;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36343,
                "title": "java-solution-java",
                "content": "    public int minDepth(TreeNode root) {\\n            if(root==null) \\n                return 0;\\n            int a = minDepth(root.left);\\n            int b = minDepth(root.right);\\n            if((a+b)==0)\\n                return 1;\\n            if(a*b==0)\\n                return a+b+1;\\n            if(a<b)\\n            {return a+1;}\\n            else {return b+1;}\\n        }",
                "solutionTags": [],
                "code": "    public int minDepth(TreeNode root) {\\n            if(root==null) \\n                return 0;\\n            int a = minDepth(root.left);\\n            int b = minDepth(root.right);\\n            if((a+b)==0)\\n                return 1;\\n            if(a*b==0)\\n                return a+b+1;\\n            if(a<b)\\n            {return a+1;}\\n            else {return b+1;}\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 36344,
                "title": "my-accepted-java-solution-in-o-n-times",
                "content": "The key point of my solution is travel the tree by level order. So I can get the answer by find out the first leaf\\n\\n1.Create two queues,*nodeQueue* for TreeNode,*depthQueue* for current node's level.\\n\\n2.Add root to *nodeQueue*,and add 1 to *depthQueue*\\n\\n3.Do below steps until find out the first leaf\\n\\n   a.Give the last element of *nodeQueue* to *node*,and give the last element of *depthQueue* to Depth\\n\\n   b.If *node* is a leaf, then return Depth\\n \\n   c.If *node.left!=null* then add *node.left* to the *nodeQueue*,add *Depth+1* to *depthQueue*.\\n\\n   d.If *node.right!=null* then add *node.right* to the *nodeQueue*,add *Depth+1* to *depthQueue*.\\n\\nI know my description is really hard to understand,cause I'm not a English native speaker.\\n\\nThanks so much for you patience!\\n\\n\\n    public class Solution {\\n        public int minDepth(TreeNode root) {\\n            if(root==null) return 0;\\n            Queue<TreeNode> nodeQueue=new ArrayDeque<TreeNode>();\\n            Queue<Integer> depthQueue=new ArrayDeque<Integer>();\\n            int Depth=0;\\n            nodeQueue.add(root);\\n            depthQueue.add(1);\\n            while(!nodeQueue.isEmpty())\\n            {\\n                TreeNode node=nodeQueue.remove();\\n                Depth=depthQueue.remove();\\n                if(node.left==null && node.right==null)\\n                {\\n                    return Depth;\\n                }\\n                if(node.left!=null)\\n                {\\n                    nodeQueue.add(node.left);\\n                    depthQueue.add(Depth+1);\\n                }\\n                if(node.right!=null)\\n                {\\n                    nodeQueue.add(node.right);\\n                    depthQueue.add(Depth+1);\\n                }\\n            }\\n            return Depth;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int minDepth(TreeNode root) {\\n            if(root==null) return 0;\\n            Queue<TreeNode> nodeQueue=new ArrayDeque<TreeNode>();\\n            Queue<Integer> depthQueue=new ArrayDeque<Integer>();\\n            int Depth=0;\\n            nodeQueue.add(root);\\n            depthQueue.add(1);\\n            while(!nodeQueue.isEmpty())\\n            {\\n                TreeNode node=nodeQueue.remove();\\n                Depth=depthQueue.remove();\\n                if(node.left==null && node.right==null)\\n                {\\n                    return Depth;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 36351,
                "title": "short-and-sweet-solution",
                "content": "    class Solution {\\n    public:\\n        int minDepth(TreeNode *root) {\\n            if(!root)return 0;\\n            if(!(root->left))return 1+minDepth(root->right);\\n            if(!(root->right))return 1+minDepth(root->left);\\n            return 1+min(minDepth(root->left),minDepth(root->right));\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int minDepth(TreeNode *root) {\\n            if(!root)return 0;\\n            if(!(root->left))return 1+minDepth(root->right);\\n            if(!(root->right))return 1+minDepth(root->left);\\n            return 1+min(minDepth(root->left),minDepth(root->right));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3962563,
                "title": "easiest-4-liner-solution-in-java",
                "content": "# Intuition\\nWe can recursively traverse the nodes of the tree and find minimum depth of the tree similarly we have found the maximum depth of the tree.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. If the root node is null, the minimum depth is 0.\\n\\n2. If either the left or right child node is null, recursively find the minimum depth on the non-null subtree and add 1.\\n\\n3. If both the left and right child nodes exist, recursively find the minimum depth on both subtrees and take the minimum depth, then add 1.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(h)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Similar Questions\\n\\n![image.png](https://assets.leetcode.com/users/images/0731e8af-be50-4a83-ac44-e05d839a0bcb_1693048176.7246525.png)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n       if(root == null) return 0;\\n\\n       if(root.left == null) return minDepth(root.right)+1;\\n\\n       if(root.right == null) return minDepth(root.left)+1;\\n\\n       return (Math.min(minDepth(root.left),minDepth(root.right))+1);\\n    }\\n}\\n```\\n\\n# If you like the Solution then please upvote me.",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n       if(root == null) return 0;\\n\\n       if(root.left == null) return minDepth(root.right)+1;\\n\\n       if(root.right == null) return minDepth(root.left)+1;\\n\\n       return (Math.min(minDepth(root.left),minDepth(root.right))+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879546,
                "title": "explained-recursion-java-c-simple-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet\\'s break down the code step by step:\\n\\n1. The minDepth function is defined within the Solution class, and it returns an integer representing the minimum depth of the binary tree rooted at the given root.\\n\\n2. The first condition checks if the root is NULL, meaning the tree is empty. If so, the function returns 0 as the depth of an empty tree is zero.\\n\\n3. The second condition checks if the root has no left or right child, which means it\\'s a leaf node. In this case, the function returns 1 because the depth of a single node is considered to be 1.\\n\\n4. The next two conditions check if either the left or right child is NULL, indicating that the tree is only branching towards one side. In either case, the function returns the minimum depth of the non-null subtree plus 1.\\n\\n5. If none of the above conditions are satisfied, the function calculates the minimum depth of both the left and right subtrees recursively using the minDepth function itself, and then returns the minimum of these two depths plus 1.\\n\\n6. Overall, this code snippet uses a recursive approach to traverse the binary tree and calculate its minimum depth. It handles different cases such as empty trees, leaf nodes, and cases where one subtree is deeper than the other. By recursively calculating the minimum depth of subtrees, it accurately computes the minimum depth of the entire binary tree.\\n\\n`Note: While the code is correct and functional, it could be optimized by combining the conditions for left and right child null checks into a single condition using logical operators. This would help reduce the code redundancy.`\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n`- The time complexity of the minDepth function largely depends on the number of nodes in the binary tree. In the worst case, the algorithm visits every node once to determine its depth. Since each node is visited exactly once, the time complexity is O(n), where n is the number of nodes in the tree.`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`- The space complexity of the algorithm is determined by the depth of the recursion stack. In the worst case, where the binary tree is completely unbalanced (essentially a linked list), the maximum depth of the recursion stack will be n (number of nodes in the tree). This is because the algorithm might need to traverse all nodes in a linear fashion. Therefore, the space complexity is O(n).`\\n```\\n       // \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root)\\n     {\\n        if(root==NULL)\\n        {return 0;}\\n         if(root->left==NULL && root->right==NULL)\\n         {\\n             return 1;\\n         }\\n         else if(root->right==NULL && root->left!=NULL)\\n         {\\n              return minDepth(root->left)+1;\\n         }\\n           else if(root->left==NULL && root->right!=NULL)\\n         {\\n              return minDepth(root->right)+1;\\n         }\\n       else{\\n         return min(minDepth(root->left),minDepth(root->right))+1;\\n       }\\n    }\\n};\\n       \\n```\\n```JAVA []\\n\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n            if(root==null)\\n                return 0;\\n            if (root.left == null && root.right == null)\\n                return 1;\\n            if (root.left == null)\\n                return 1 + minDepth(root.right);\\n            if (root.right == null)\\n                return 1 + minDepth(root.left);\\n       return 1+ Math.min(minDepth(root.left), minDepth(root.right)); \\n      \\n    }\\n}\\n```\\n\\n\\n\\n     \\n  ``",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n       // \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root)\\n     {\\n        if(root==NULL)\\n        {return 0;}\\n         if(root->left==NULL && root->right==NULL)\\n         {\\n             return 1;\\n         }\\n         else if(root->right==NULL && root->left!=NULL)\\n         {\\n              return minDepth(root->left)+1;\\n         }\\n           else if(root->left==NULL && root->right!=NULL)\\n         {\\n              return minDepth(root->right)+1;\\n         }\\n       else{\\n         return min(minDepth(root->left),minDepth(root->right))+1;\\n       }\\n    }\\n};\\n       \\n```\n```JAVA []\\n\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n            if(root==null)\\n                return 0;\\n            if (root.left == null && root.right == null)\\n                return 1;\\n            if (root.left == null)\\n                return 1 + minDepth(root.right);\\n            if (root.right == null)\\n                return 1 + minDepth(root.left);\\n       return 1+ Math.min(minDepth(root.left), minDepth(root.right)); \\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827077,
                "title": "c-solutions-simple-logic-easy-to-understand",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n\\n        int left = minDepth(root->left);\\n        int right = minDepth(root->right);\\n\\n        if (left == 0 || right == 0) {\\n            return 1 + max(left, right);\\n        }\\n\\n        return 1 + min(left,right);\\n    }\\n   \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n\\n        int left = minDepth(root->left);\\n        int right = minDepth(root->right);\\n\\n        if (left == 0 || right == 0) {\\n            return 1 + max(left, right);\\n        }\\n\\n        return 1 + min(left,right);\\n    }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750259,
                "title": "100-accepted-easiest-js-sol-understandable-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n-     Using Depth-First Search (DFS) algorithm.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n- In this code, we define a **TreeNode** class to represent the nodes of the binary tree. \\n- The **minDepth** function takes a root node as input and recursively calculates the minimum depth of the tree.\\n\\n- ### We handle several base cases in this problem :-\\n\\n1. If the ***root*** is ***null***, the ***tree*** ***is*** ***empty***, so the minimum depth is 0.\\n2. If the root has ***no children*** (i.e., both left and right are null), it is a ***leaf node***, and the minimum depth is 1.\\n3. If the root ***has*** ***only one child*** (either left or right), we recursively calculate the minimum depth of that child and add 1.\\n4. If the root ***has*** ***both left and right children***, we recursively calculate the minimum depth of both children and take the minimum of the two depths, then add 1 to account for the current level.\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n1. Here n is the number of nodes in the binary tree. \\n2. This is because we visit each node once during the depth-first search traversal. \\n3. In the worst case, we need to visit all nodes of the tree to calculate the minimum depth.\\n\\n\\n\\n\\n\\n\\n\\n- Space complexity: $$O(h)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n1. Here h is the height of the binary tree. \\n2. In the worst case, the height of the tree is equal to the number of nodes, resulting in ***O(n) space complexity***. \\n3. This occurs when the binary tree is ***skewed***, and each node only has one child. \\n4. The space complexity is determined by *the maximum number of recursive calls on the call stack at any given time, which is equal to the height of the tree*.\\n5. However, in a ***balanced*** ***binary tree***, the height is approximately log(n), resulting in **O(log n)** space complexity.\\n\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar minDepth = function(root) {\\n  \\n  if (root === null) {\\n    return 0;\\n  }\\n\\n  if (root.left === null && root.right === null) {\\n    return 1;\\n  }\\n\\n  if (root.left === null) {\\n    return minDepth(root.right) + 1;\\n  }\\n\\n  if (root.right === null) {\\n    return minDepth(root.left) + 1;\\n  }\\n\\n  return Math.min(minDepth(root.left), minDepth(root.right)) + 1;  \\n};\\n```\\n\\n![cat img for upvote on LC.jpeg](https://assets.leetcode.com/users/images/065270ec-72fd-46a8-903e-615210706db3_1689074424.6991858.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar minDepth = function(root) {\\n  \\n  if (root === null) {\\n    return 0;\\n  }\\n\\n  if (root.left === null && root.right === null) {\\n    return 1;\\n  }\\n\\n  if (root.left === null) {\\n    return minDepth(root.right) + 1;\\n  }\\n\\n  if (root.right === null) {\\n    return minDepth(root.left) + 1;\\n  }\\n\\n  return Math.min(minDepth(root.left), minDepth(root.right)) + 1;  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3743996,
                "title": "easy-bfs-and-dfs-solution-100-faster-easy-java",
                "content": "# Method - 1\\nSimple DFS\\n\\n## Approach\\nDepth First Search Approach\\n\\n## Complexity\\n- Time complexity: O(n)\\n- Whole tree will be traversed\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n- Stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n###### \\n```\\nclass Solution {\\n    public int minDepth__dfs(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        return depth(root);\\n    }\\n    private int depth(TreeNode root){\\n        if (root == null)\\n            return (int)1e9;\\n        if (root.left == null && root.right == null)\\n            return 1;\\n        \\n        int leftDepth = depth(root.left);\\n        int rightDepth = depth(root.right);\\n        return 1 + Math.min(leftDepth, rightDepth);\\n    }\\n}\\n```\\n\\n\\n# Method - 2\\nSimple BFS\\n\\n## Approach\\nBreadth First Search Approach\\n\\n## Complexity\\n- Time complexity: O(n)\\n- Whole tree will traversed till minimum pdeth\\n\\n- Space complexity: O(n)\\n- Queue space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n###### \\n```\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        int minDepth = 0;\\n        Queue<TreeNode> queue = new ArrayDeque<>();\\n        queue.add(root);\\n\\n        while (!queue.isEmpty()){\\n            minDepth++;\\n            int size = queue.size();\\n            while (size-- > 0){\\n                TreeNode node = queue.remove();\\n                if (node.left == null && node.right == null)\\n                    return minDepth;\\n                if (node.left != null)\\n                    queue.add(node.left);\\n                if (node.right != null)\\n                    queue.add(node.right);\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```\\n\\n# Conclusion:\\n- BFS will be faster than DFS, bcoz here in BFS we don\\'t traverse entire tree (only till minDepth).\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDepth__dfs(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        return depth(root);\\n    }\\n    private int depth(TreeNode root){\\n        if (root == null)\\n            return (int)1e9;\\n        if (root.left == null && root.right == null)\\n            return 1;\\n        \\n        int leftDepth = depth(root.left);\\n        int rightDepth = depth(root.right);\\n        return 1 + Math.min(leftDepth, rightDepth);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        int minDepth = 0;\\n        Queue<TreeNode> queue = new ArrayDeque<>();\\n        queue.add(root);\\n\\n        while (!queue.isEmpty()){\\n            minDepth++;\\n            int size = queue.size();\\n            while (size-- > 0){\\n                TreeNode node = queue.remove();\\n                if (node.left == null && node.right == null)\\n                    return minDepth;\\n                if (node.left != null)\\n                    queue.add(node.left);\\n                if (node.right != null)\\n                    queue.add(node.right);\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743995,
                "title": "java-python-c",
                "content": "# Super Simple and Easy Code : \\n\\n```java []\\nclass Solution {\\n    public int findAnswer(TreeNode root)\\n    {\\n        if(root == null)    return Integer.MAX_VALUE;\\n        if(root.left == null && root.right == null)    return 1;\\n        return Math.min(findAnswer(root.left),findAnswer(root.right))+1; \\n    }\\n    public int minDepth(TreeNode root) {\\n        if(root == null)    return 0;\\n        return findAnswer(root);\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        if root is None:\\n            return float(\\'inf\\')\\n        if root.left is None and root.right is None:\\n            return 1\\n        return min(self.findAnswer(root.left), self.findAnswer(root.right)) + 1\\n\\n    def minDepth(self, root):\\n        if root is None:\\n            return 0\\n        return self.findAnswer(root)\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int findAnswer(TreeNode* root) {\\n        if (root == nullptr)\\n            return std::numeric_limits<int>::max();\\n        if (root->left == nullptr && root->right == nullptr)\\n            return 1;\\n        return std::min(findAnswer(root->left), findAnswer(root->right)) + 1;\\n    }\\n\\n    int minDepth(TreeNode* root) {\\n        if (root == nullptr)\\n            return 0;\\n        return findAnswer(root);\\n    }\\n};\\n\\n```\\n---\\n#### *Please don\\'t forget to upvote if you\\'ve liked my solution.* \\uD83C\\uDF40\\n---",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```java []\\nclass Solution {\\n    public int findAnswer(TreeNode root)\\n    {\\n        if(root == null)    return Integer.MAX_VALUE;\\n        if(root.left == null && root.right == null)    return 1;\\n        return Math.min(findAnswer(root.left),findAnswer(root.right))+1; \\n    }\\n    public int minDepth(TreeNode root) {\\n        if(root == null)    return 0;\\n        return findAnswer(root);\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        if root is None:\\n            return float(\\'inf\\')\\n        if root.left is None and root.right is None:\\n            return 1\\n        return min(self.findAnswer(root.left), self.findAnswer(root.right)) + 1\\n\\n    def minDepth(self, root):\\n        if root is None:\\n            return 0\\n        return self.findAnswer(root)\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int findAnswer(TreeNode* root) {\\n        if (root == nullptr)\\n            return std::numeric_limits<int>::max();\\n        if (root->left == nullptr && root->right == nullptr)\\n            return 1;\\n        return std::min(findAnswer(root->left), findAnswer(root->right)) + 1;\\n    }\\n\\n    int minDepth(TreeNode* root) {\\n        if (root == nullptr)\\n            return 0;\\n        return findAnswer(root);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743368,
                "title": "straightforward-c-solution-using-bfs",
                "content": "### Please upvote if you liked it!\\n\\n```\\n    int minDepth(TreeNode* root) {\\n        if(!root){return 0;}\\n        queue<TreeNode*> q;\\n        int depth = 0;\\n        q.push(root);\\n        while(!q.empty()){\\n            int s=q.size();\\n            for(int i=0;i<s;++i){\\n                TreeNode * temp = q.front();\\n                q.pop();\\n                if(!temp->left && !temp->right){return depth+1;}\\n                if(temp->left){q.push(temp->left);}\\n                if(temp->right){q.push(temp->right);}\\n            }\\n            ++depth;\\n        }\\n        return depth;\\n    }",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "### Please upvote if you liked it!\\n\\n```\\n    int minDepth(TreeNode* root) {\\n        if(!root){return 0;}\\n        queue<TreeNode*> q;\\n        int depth = 0;\\n        q.push(root);\\n        while(!q.empty()){\\n            int s=q.size();\\n            for(int i=0;i<s;++i){\\n                TreeNode * temp = q.front();\\n                q.pop();\\n                if(!temp->left && !temp->right){return depth+1;}\\n                if(temp->left){q.push(temp->left);}\\n                if(temp->right){q.push(temp->right);}\\n            }\\n            ++depth;\\n        }\\n        return depth;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3743293,
                "title": "minimum-depth-of-binary-tree-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n // The minimum depth of a binary tree is the number of nodes along the shortest path\\n        // from the root node down to the nearest leaf node. We can use a breadth-first search (BFS)\\n        // algorithm to find the minimum depth by traversing the tree level by level.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n   1. We start with the root node of the binary tree.\\n\\n    2. We use a queue data structure to perform a breadth-first search (BFS) traversal of the binary tree.\\n\\n    3. Initialize a variable depth to keep track of the current depth level. We set it to 1 initially.\\n\\n    4. While the queue is not empty, we process each level of the binary tree:\\n        Get the size of the current level by checking the size of the queue.\\n    5.   Iterate through the nodes in the current level by removing them from the queue.\\n        For each node, check if it is a leaf node (i.e., it has no left and right children).\\n            If it is a leaf node, we have found the minimum depth, so we return the current depth.\\n    6.    If the node has a left child, enqueue the left child into the queue.\\n        If the node has a right child, enqueue the right child into the queue.\\n\\n7.    If the loop completes without finding a leaf node, it means the tree is empty or has no leaf nodes. In this case, we return 0.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.LinkedList;\\nimport java.util.Queue;\\n\\nclass TreeNode {\\n    int val;\\n    TreeNode left;\\n    TreeNode right;\\n\\n    TreeNode(int val) {\\n        this.val = val;\\n    }\\n}\\n\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        int depth = 1;\\n\\n        while (!queue.isEmpty()) {\\n            int levelSize = queue.size();\\n\\n            for (int i = 0; i < levelSize; i++) {\\n                TreeNode node = queue.poll();\\n\\n                if (node.left == null && node.right == null) {\\n                    return depth;\\n                }\\n\\n                if (node.left != null) {\\n                    queue.offer(node.left);\\n                }\\n\\n                if (node.right != null) {\\n                    queue.offer(node.right);\\n                }\\n            }\\n\\n            depth++;\\n        }\\n\\n        return depth;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nimport java.util.LinkedList;\\nimport java.util.Queue;\\n\\nclass TreeNode {\\n    int val;\\n    TreeNode left;\\n    TreeNode right;\\n\\n    TreeNode(int val) {\\n        this.val = val;\\n    }\\n}\\n\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        int depth = 1;\\n\\n        while (!queue.isEmpty()) {\\n            int levelSize = queue.size();\\n\\n            for (int i = 0; i < levelSize; i++) {\\n                TreeNode node = queue.poll();\\n\\n                if (node.left == null && node.right == null) {\\n                    return depth;\\n                }\\n\\n                if (node.left != null) {\\n                    queue.offer(node.left);\\n                }\\n\\n                if (node.right != null) {\\n                    queue.offer(node.right);\\n                }\\n            }\\n\\n            depth++;\\n        }\\n\\n        return depth;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743190,
                "title": "java-bfs-beats-99-clean-code",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int minDepth(TreeNode root) {\\n    if (root == null) return 0;\\n\\n    var queue = new ArrayDeque<TreeNode>();\\n    queue.offer(root);\\n\\n    for (var depth = 1; !queue.isEmpty(); depth++) {\\n      for (var i = queue.size(); i > 0; i--) {\\n        var node = queue.poll();\\n\\n        if (node.left == null && node.right == null)\\n          return depth;\\n\\n        if (node.left != null) queue.offer(node.left);\\n        if (node.right != null) queue.offer(node.right);\\n      }\\n    }\\n    return -1;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n  public int minDepth(TreeNode root) {\\n    if (root == null) return 0;\\n\\n    var queue = new ArrayDeque<TreeNode>();\\n    queue.offer(root);\\n\\n    for (var depth = 1; !queue.isEmpty(); depth++) {\\n      for (var i = queue.size(); i > 0; i--) {\\n        var node = queue.poll();\\n\\n        if (node.left == null && node.right == null)\\n          return depth;\\n\\n        if (node.left != null) queue.offer(node.left);\\n        if (node.right != null) queue.offer(node.right);\\n      }\\n    }\\n    return -1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425866,
                "title": "binbin-s-answer-beats-99-99-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        if root is None: \\n            return 0\\n        def find_depth(node,l):\\n            if node.left is not None and node.right is not None:\\n                return min(find_depth(node.right, l+1),find_depth(node.left, l+1))\\n            \\n            if node.right is not None:\\n                return find_depth(node.right, l+1)\\n            if node.left is not None:\\n                return find_depth(node.left, l+1)\\n            return l\\n        return find_depth(root,1)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        if root is None: \\n            return 0\\n        def find_depth(node,l):\\n            if node.left is not None and node.right is not None:\\n                return min(find_depth(node.right, l+1),find_depth(node.left, l+1))\\n            \\n            if node.right is not None:\\n                return find_depth(node.right, l+1)\\n            if node.left is not None:\\n                return find_depth(node.left, l+1)\\n            return l\\n        return find_depth(root,1)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306596,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n\\n        int left = minDepth(root->left);\\n        int right = minDepth(root->right);\\n\\n        if(left==0 || right==0){\\n            return (1 + left + right);\\n        }\\n        else{\\n            return 1 + min(left,right);\\n        }}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n\\n        int left = minDepth(root->left);\\n        int right = minDepth(root->right);\\n\\n        if(left==0 || right==0){\\n            return (1 + left + right);\\n        }\\n        else{\\n            return 1 + min(left,right);\\n        }}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306586,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n\\n        int left = minDepth(root->left);\\n        int right = minDepth(root->right);\\n\\n        if(left==0 || right==0){\\n            return (1 + left + right);\\n        }\\n        else{\\n            return 1 + min(left,right);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n\\n        int left = minDepth(root->left);\\n        int right = minDepth(root->right);\\n\\n        if(left==0 || right==0){\\n            return (1 + left + right);\\n        }\\n        else{\\n            return 1 + min(left,right);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266364,
                "title": "easiest-typescript-solution-dfs",
                "content": "\\n# Tips\\n- When you solve a problem like this, always try to take an advantage of given funciton, instead of declaring a new one.\\n\\n# Code (DFS)\\n- if `root` is null, it has 0 level, so return 0\\n- Get the lowest depth from the `left`/`right` side\\n- if `left` side was null, return only `right` and like wise for opposite side\\n- return the minimum level from `left` or `right`\\n```\\n\\nfunction minDepth(root: TreeNode | null): number {\\n    if (root === null) return 0\\n\\n    const left = minDepth(root.left) + 1\\n    const right = minDepth(root.right) + 1\\n\\n    if (!root.left) return right\\n    if (!root.right) return left\\n\\n    return Math.min(left, right)\\n};\\n```\\n\\n# Thank you\\n\\nUpvote if you like \\u2B06\\uFE0F\\nIf you have any questions, please let me know in the comment section.",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n\\nfunction minDepth(root: TreeNode | null): number {\\n    if (root === null) return 0\\n\\n    const left = minDepth(root.left) + 1\\n    const right = minDepth(root.right) + 1\\n\\n    if (!root.left) return right\\n    if (!root.right) return left\\n\\n    return Math.min(left, right)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3198405,
                "title": "finding-the-minimum-depth-of-a-binary-tree-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to find the minimum depth of the given binary tree. Minimum depth is defined as the number of nodes from root to the nearest leaf node. A leaf node is a node that has no child nodes. To solve this problem, we can traverse the tree in a recursive manner and find the minimum depth of the tree.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use depth-first search (DFS) to traverse the tree recursively. If the current node is None, we return 0. If the current node is a leaf node (i.e. it has no left and right child nodes), we return 1. If the current node has only left child node, we recursively traverse the left subtree and add 1 to the minimum depth. Similarly, if the current node has only right child node, we recursively traverse the right subtree and add 1 to the minimum depth. If the current node has both left and right child nodes, we recursively traverse both the left and right subtrees and add 1 to the minimum depth. Finally, we return the minimum depth.\\n\\n# Complexity\\n- Time complexity:$O(n)$ - We traverse each node of the tree once, so the time complexity is $ O(n)$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(h) $ - We use the recursive stack to store the call stack. The maximum space used by the call stack is equal to the height of the tree. In the worst case, the tree may be a skewed tree (i.e. all the nodes are on one side), so the height of the tree can be $O(n)$. Therefore, the space complexity is $O(n)$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        if not root:\\n            return 0\\n        if not root.left and not root.right:\\n            return 1\\n        if not root.left:\\n            return self.minDepth(root.right) + 1\\n        if not root.right:\\n            return self.minDepth(root.left) + 1\\n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        if not root:\\n            return 0\\n        if not root.left and not root.right:\\n            return 1\\n        if not root.left:\\n            return self.minDepth(root.right) + 1\\n        if not root.right:\\n            return self.minDepth(root.left) + 1\\n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070842,
                "title": "simple-beginner-friendly-solution-faster-than-other-dfs",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(!root)return 0;\\n        int lh=minDepth(root->left);\\n        int rh=minDepth(root->right);\\n        if(lh==0 && rh==0)return 1;\\n        else if(lh==0)\\n            return 1+rh;\\n        else if(rh==0)\\n            return 1+lh;\\n        return 1+min(lh,rh);\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(!root)return 0;\\n        int lh=minDepth(root->left);\\n        int rh=minDepth(root->right);\\n        if(lh==0 && rh==0)return 1;\\n        else if(lh==0)\\n            return 1+rh;\\n        else if(rh==0)\\n            return 1+lh;\\n        return 1+min(lh,rh);\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744570,
                "title": "solution-with-explanation-using-recursion",
                "content": "\\tdef minDepth(self, root: Optional[TreeNode]) -> int:\\n        if root is None:\\n            return 0\\n        left_height = self.minDepth(root.left)\\n        right_height = self.minDepth(root.right)\\n        \\n        # If left or right height is zero from it\\'s respective parent, then the minimum possible height is node that is without zero value. \\n        if left_height == 0:\\n            return right_height + 1\\n        if right_height == 0:\\n            return left_height + 1\\n        # If both are non zero, then among left children height and right children height, we have to take the minimum height possible and add 1 in order to take count of parent height \\n        return min(right_height , left_height) + 1\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "\\tdef minDepth(self, root: Optional[TreeNode]) -> int:\\n        if root is None:\\n            return 0\\n        left_height = self.minDepth(root.left)\\n        right_height = self.minDepth(root.right)\\n        \\n        # If left or right height is zero from it\\'s respective parent, then the minimum possible height is node that is without zero value. \\n        if left_height == 0:\\n            return right_height + 1\\n        if right_height == 0:\\n            return left_height + 1\\n        # If both are non zero, then among left children height and right children height, we have to take the minimum height possible and add 1 in order to take count of parent height \\n        return min(right_height , left_height) + 1\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2717347,
                "title": "c-solution-dfs-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        if(!root->left)\\n            return 1 + minDepth(root->right);\\n        if(!root->right)\\n            return 1 + minDepth(root->left);\\n        return 1 + min(minDepth(root->right), minDepth(root->left));       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        if(!root->left)\\n            return 1 + minDepth(root->right);\\n        if(!root->right)\\n            return 1 + minDepth(root->left);\\n        return 1 + min(minDepth(root->right), minDepth(root->left));       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673807,
                "title": "python-simplest-solution",
                "content": "```\\nclass Solution:\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        if root == None: return 0\\n        lf = self.minDepth(root.left)\\n        rt = self.minDepth(root.right)\\n        \\n        if lf != 0 and rt != 0: \\n            return min(lf, rt) + 1\\n        \\n        return lf + rt + 1\\n```",
                "solutionTags": [
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        if root == None: return 0\\n        lf = self.minDepth(root.left)\\n        rt = self.minDepth(root.right)\\n        \\n        if lf != 0 and rt != 0: \\n            return min(lf, rt) + 1\\n        \\n        return lf + rt + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600509,
                "title": "easy-recursive-python-solution",
                "content": "The reason for the `else float(inf)` in both left and right, is in case a node has either a left or a right, otherwise, it will raise an error that veriable left (or right) are undefined.\\n\\n```\\nclass Solution:\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        if not root: return 0\\n        if not root.left and not root.right: return 1\\n        \\n        left=self.minDepth(root.left) if root.left else float(\\'inf\\') \\n    \\n        right=self.minDepth(root.right) if root.right else float(\\'inf\\')\\n        return 1+ min(left,right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def minDepth(self, root: Optional[TreeNode]) -> int:\\n        if not root: return 0\\n        if not root.left and not root.right: return 1\\n        \\n        left=self.minDepth(root.left) if root.left else float(\\'inf\\') \\n    \\n        right=self.minDepth(root.right) if root.right else float(\\'inf\\')\\n        return 1+ min(left,right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547920,
                "title": "python-solution",
                "content": "```\\ndef minDepth(self, root: Optional[TreeNode]) -> int:\\n        if(root==None):\\n            return 0\\n        else:\\n            lh,rh=self.minDepth(root.left),self.minDepth(root.right)\\n            if(lh==0 or rh==0):\\n                return 1+max(lh,rh)\\n            else:\\n                return 1+min(lh,rh)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\ndef minDepth(self, root: Optional[TreeNode]) -> int:\\n        if(root==None):\\n            return 0\\n        else:\\n            lh,rh=self.minDepth(root.left),self.minDepth(root.right)\\n            if(lh==0 or rh==0):\\n                return 1+max(lh,rh)\\n            else:\\n                return 1+min(lh,rh)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1879287,
                "title": "2-lines-of-code-cpp-minimum-depth-of-binary-tree",
                "content": "# **[@iprincekumark](https://leetcode.com/iprincekumark/)**\\nVISIT MY PROFILE\\n**CODE**\\n```\\nint minDepth(TreeNode* root) {\\n        if(root == NULL) \\n            return 0;\\n        int l = minDepth(root->left), r = minDepth(root->right);\\n        return 1 + (min(l,r) ? min(l,r) : max(l,r));\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nint minDepth(TreeNode* root) {\\n        if(root == NULL) \\n            return 0;\\n        int l = minDepth(root->left), r = minDepth(root->right);\\n        return 1 + (min(l,r) ? min(l,r) : max(l,r));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1860841,
                "title": "truly-1-line-of-code-c-ternary-operator-super-unreadable-totally-not-helpful-for-interviews",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        return root?(!root->left?(!root->right?1:(1+minDepth(root->right))):(!root->right?1+minDepth(root->left):1+min(minDepth(root->left),minDepth(root->right)))):0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        return root?(!root->left?(!root->right?1:(1+minDepth(root->right))):(!root->right?1+minDepth(root->left):1+min(minDepth(root->left),minDepth(root->right)))):0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827942,
                "title": "4-line-of-code-java-c",
                "content": "**JAVA SOLUTION**\\n\\n\\n        \\n\\t\\tpublic int minDepth(TreeNode root) {\\n        \\n        if(root==null) return 0;\\n        \\n        int L=minDepth(root.left);\\n        \\n        int R= minDepth(root.right);\\n        \\n        return (L==0 || R ==0 ) ? L+R+1: Math.min(L,R)+1; \\n    }\\n    \\n\\t** C++ SOLUTION **\\n\\t\\n    int minDepth(TreeNode* root) {\\n        \\n        if(root==NULL) return 0;\\n        \\n        int L=minDepth(root->left);\\n        \\n        int R= minDepth(root->right);\\n        \\n        return L==NULL || R==NULL ? L+R+1: min(L,R)+1;     \\n    }",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "**JAVA SOLUTION**\\n\\n\\n        \\n\\t\\tpublic int minDepth(TreeNode root) {\\n        \\n        if(root==null) return 0;\\n        \\n        int L=minDepth(root.left);\\n        \\n        int R= minDepth(root.right);\\n        \\n        return (L==0 || R ==0 ) ? L+R+1: Math.min(L,R)+1; \\n    }\\n    \\n\\t** C++ SOLUTION **\\n\\t\\n    int minDepth(TreeNode* root) {\\n        \\n        if(root==NULL) return 0;\\n        \\n        int L=minDepth(root->left);\\n        \\n        int R= minDepth(root->right);\\n        \\n        return L==NULL || R==NULL ? L+R+1: min(L,R)+1;     \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1770949,
                "title": "minimum-depth-of-binary-tree",
                "content": "```\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        if(root == null){\\n            return 0;\\n        }\\n        int left = minDepth(root.left);\\n        int right = minDepth(root.right);\\n        if(left == 0 || right == 0)return 1+Math.max(left,right);//skewed tree\\n        return 1+Math.min(left,right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDepth(TreeNode root) {\\n        if(root == null){\\n            return 0;\\n        }\\n        int left = minDepth(root.left);\\n        int right = minDepth(root.right);\\n        if(left == 0 || right == 0)return 1+Math.max(left,right);//skewed tree\\n        return 1+Math.min(left,right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557471,
                "title": "c-97-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    void depth(TreeNode* root,int dep,int &ans)\\n    {\\n        if(!root) return;\\n        if(!root->left and !root->right)\\n        {\\n            ans = min(dep,ans);\\n            return;\\n        }\\n        depth(root->left,dep+1,ans);\\n        depth(root->right,dep+1,ans);\\n    }\\n    int minDepth(TreeNode* root) {\\n        if(!root) return 0;\\n        int ans=INT_MAX;\\n        depth(root,1,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void depth(TreeNode* root,int dep,int &ans)\\n    {\\n        if(!root) return;\\n        if(!root->left and !root->right)\\n        {\\n            ans = min(dep,ans);\\n            return;\\n        }\\n        depth(root->left,dep+1,ans);\\n        depth(root->right,dep+1,ans);\\n    }\\n    int minDepth(TreeNode* root) {\\n        if(!root) return 0;\\n        int ans=INT_MAX;\\n        depth(root,1,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478705,
                "title": "dfs-solution-c",
                "content": "DFS Solution\\n```int minDepth(TreeNode* root) {\\n         if(root==NULL){\\n            return 0;\\n        }\\n        int l=minDepth(root->left);\\n        int r=minDepth(root->right);\\n        if(l==0 || r==0)return max(l,r)+1; // For skewed trees like [1 2] [1 NULL 2 NULL NULL 6]\\n       return 1+min(l,r);\\n        \\n    }```\\n\\t",
                "solutionTags": [],
                "code": "```int minDepth(TreeNode* root) {\\n         if(root==NULL){\\n            return 0;\\n        }\\n        int l=minDepth(root->left);\\n        int r=minDepth(root->right);\\n        if(l==0 || r==0)return max(l,r)+1; // For skewed trees like [1 2] [1 NULL 2 NULL NULL 6]\\n       return 1+min(l,r);\\n        \\n    }```",
                "codeTag": "Unknown"
            },
            {
                "id": 1462787,
                "title": "most-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int lh=minDepth(root->left);\\n        int rh=minDepth(root->right);\\n        if(root->left==NULL){\\n            return 1+rh;\\n        }\\n        if(root->right==NULL){\\n            return 1+lh;\\n        }\\n        return 1+min(lh,rh);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int lh=minDepth(root->left);\\n        int rh=minDepth(root->right);\\n        if(root->left==NULL){\\n            return 1+rh;\\n        }\\n        if(root->right==NULL){\\n            return 1+lh;\\n        }\\n        return 1+min(lh,rh);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279470,
                "title": "c-self-explanatory-bfs-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        \\n        if(!root)\\n            return 0;\\n        \\n        int depth = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            int level = q.size();\\n            depth++;\\n            for(int i=0; i<level; i++){\\n                TreeNode* curr = q.front();\\n                q.pop();\\n                if(!curr->left && !curr->right)\\n                    return depth;\\n                if(curr->left)\\n                    q.push(curr->left);\\n                if(curr->right)\\n                    q.push(curr->right);\\n            }\\n        }\\n        return depth;\\n    }\\n};\\n```\\n**Time Complexity: O(n)**\\n**Space Complexity: O(n)**",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        \\n        if(!root)\\n            return 0;\\n        \\n        int depth = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            int level = q.size();\\n            depth++;\\n            for(int i=0; i<level; i++){\\n                TreeNode* curr = q.front();\\n                q.pop();\\n                if(!curr->left && !curr->right)\\n                    return depth;\\n                if(curr->left)\\n                    q.push(curr->left);\\n                if(curr->right)\\n                    q.push(curr->right);\\n            }\\n        }\\n        return depth;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214340,
                "title": "simple-java-solution-using-dfs",
                "content": "class Solution {\\n    public int minDepth(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        return helper(root,1);\\n    }\\n    \\n    int helper(TreeNode root, int count){\\n        if(root==null)\\n            return Integer.MAX_VALUE;\\n        if(root.left==null && root.right==null)\\n            return count;\\n        int left = helper(root.left, count+1);\\n        int right = helper(root.right, count+1);\\n        \\n        return Math.min(left,right);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int minDepth(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        return helper(root,1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1001337,
                "title": "kotlin-short-simple-and-fast",
                "content": "```kotlin\\nfun minDepth(root: TreeNode?): Int = when {\\n    root == null -> 0\\n    root.left == null -> minDepth(root.right) + 1\\n    root.right == null -> minDepth(root.left) + 1\\n    else -> minOf(minDepth(root.left), minDepth(root.right)) + 1\\n}\\n```",
                "solutionTags": [],
                "code": "```kotlin\\nfun minDepth(root: TreeNode?): Int = when {\\n    root == null -> 0\\n    root.left == null -> minDepth(root.right) + 1\\n    root.right == null -> minDepth(root.left) + 1\\n    else -> minOf(minDepth(root.left), minDepth(root.right)) + 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 985186,
                "title": "python-3-bfs-99-faster",
                "content": "\\tif not root:\\n\\t\\treturn 0\\n\\n\\tif not root.right and not root.left:\\n\\t\\treturn 1\\n\\n\\tqueue = [root]\\n\\n\\tdepth = 1\\n\\n\\twhile queue:\\n\\n\\t\\tsize = len(queue)\\n\\n\\t\\twhile size:\\n\\t\\t\\tnode = queue.pop(0)\\n\\n\\t\\t\\tif not node.left and not node.right:\\n\\t\\t\\t\\treturn depth\\n\\n\\t\\t\\tif node.left:\\n\\t\\t\\t\\tqueue.append(node.left)\\n\\n\\t\\t\\tif node.right:\\n\\t\\t\\t\\tqueue.append(node.right)\\n\\n\\t\\t\\tsize-=1\\n\\n\\t\\tdepth+=1\\n\\n\\treturn depth \\n\\t\\nUsing BFS, you can find the shortest path that hits a leaf first. A leaf is defined as a node with no left and no right child (so we check that using if not node.left and not node.right). By using the inner while loop, we can iterate an entire level and that allows us to accurately track the depth.",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "\\tif not root:\\n\\t\\treturn 0\\n\\n\\tif not root.right and not root.left:\\n\\t\\treturn 1\\n\\n\\tqueue = [root]\\n\\n\\tdepth = 1\\n\\n\\twhile queue:\\n\\n\\t\\tsize = len(queue)\\n\\n\\t\\twhile size:\\n\\t\\t\\tnode = queue.pop(0)\\n\\n\\t\\t\\tif not node.left and not node.right:\\n\\t\\t\\t\\treturn depth\\n\\n\\t\\t\\tif node.left:\\n\\t\\t\\t\\tqueue.append(node.left)\\n\\n\\t\\t\\tif node.right:\\n\\t\\t\\t\\tqueue.append(node.right)\\n\\n\\t\\t\\tsize-=1\\n\\n\\t\\tdepth+=1\\n\\n\\treturn depth \\n\\t\\nUsing BFS, you can find the shortest path that hits a leaf first. A leaf is defined as a node with no left and no right child (so we check that using if not node.left and not node.right). By using the inner while loop, we can iterate an entire level and that allows us to accurately track the depth.",
                "codeTag": "Unknown"
            },
            {
                "id": 961681,
                "title": "java-bfs-dfs-solution",
                "content": "```\\nclass Solution {\\n    \\n    public int minDepth(TreeNode root) {\\n        return bfs(root);\\n    }\\n    \\n    private int dfs(TreeNode root) {\\n        if (root == null) return 0;\\n        if (root.left == null) return dfs(root.right) + 1;\\n        if (root.right == null) return dfs(root.left) + 1;\\n        \\n        int l = dfs(root.left);\\n        int r = dfs(root.right);\\n        \\n        return Math.min(l, r) + 1;\\n    }\\n    \\n    private int bfs(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        \\n        int level = 1;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                TreeNode cur = queue.poll();\\n                if (cur.left == null && cur.right == null) return level;\\n                if (cur.left != null) queue.offer(cur.left);\\n                if (cur.right != null) queue.offer(cur.right);\\n            }\\n            \\n            level += 1;\\n        }\\n        \\n        return level;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int minDepth(TreeNode root) {\\n        return bfs(root);\\n    }\\n    \\n    private int dfs(TreeNode root) {\\n        if (root == null) return 0;\\n        if (root.left == null) return dfs(root.right) + 1;\\n        if (root.right == null) return dfs(root.left) + 1;\\n        \\n        int l = dfs(root.left);\\n        int r = dfs(root.right);\\n        \\n        return Math.min(l, r) + 1;\\n    }\\n    \\n    private int bfs(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        \\n        int level = 1;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                TreeNode cur = queue.poll();\\n                if (cur.left == null && cur.right == null) return level;\\n                if (cur.left != null) queue.offer(cur.left);\\n                if (cur.right != null) queue.offer(cur.right);\\n            }\\n            \\n            level += 1;\\n        }\\n        \\n        return level;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 960618,
                "title": "my-best-bfs-dfs-c-code",
                "content": "**Non-Recursive BFS code using Queue**\\n```\\nint minDepth(TreeNode* root) {\\n        if(!root)return 0;\\n        queue<TreeNode*> q;\\n        int counter = 0;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            counter++;\\n            while(size--){\\n                root = q.front();\\n                q.pop();\\n                if(!root->left and !root->right)return counter;\\n                if(root->left)q.push(root->left);\\n                if(root->right)q.push(root->right);\\n            }\\n        }\\n        return 0;\\n    }\\n```\\n**Recursive DFS code**\\n```\\nint minDepth(TreeNode* root) {\\n        if(!root)return 0;\\n        int leftDepth = 0, rightDepth = 0;\\n        if(root->left)leftDepth = minDepth(root->left);\\n        if(root->right)rightDepth = minDepth(root->right);\\n        if(!leftDepth)return 1 + rightDepth;\\n        if(!rightDepth)return 1 + leftDepth;\\n        return 1 + min(leftDepth,rightDepth);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minDepth(TreeNode* root) {\\n        if(!root)return 0;\\n        queue<TreeNode*> q;\\n        int counter = 0;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            counter++;\\n            while(size--){\\n                root = q.front();\\n                q.pop();\\n                if(!root->left and !root->right)return counter;\\n                if(root->left)q.push(root->left);\\n                if(root->right)q.push(root->right);\\n            }\\n        }\\n        return 0;\\n    }\\n```\n```\\nint minDepth(TreeNode* root) {\\n        if(!root)return 0;\\n        int leftDepth = 0, rightDepth = 0;\\n        if(root->left)leftDepth = minDepth(root->left);\\n        if(root->right)rightDepth = minDepth(root->right);\\n        if(!leftDepth)return 1 + rightDepth;\\n        if(!rightDepth)return 1 + leftDepth;\\n        return 1 + min(leftDepth,rightDepth);\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1576459,
                "content": [
                    {
                        "username": "ewmiao",
                        "content": "I don\\'t know how to show this tree in a graph, and it\\'s hard to believe that its min depth is 5. However, my code fails on this test case. Anyone explains to me?\\n\\nExample 2:\\n\\nInput: root = [2,null,3,null,4,null,5,null,6]\\nOutput: 5"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "[@huttarl](/huttarl)  The second example shows a Binary tree that is \\'right skewed\\'. [2-3-4-5-6] 6 being the leaf node with min height 5."
                    },
                    {
                        "username": "huttarl",
                        "content": "[@ronitak33](/ronitak33) Unfortunately this would give a tree in which the nodes labeled \"4\" and \"6\" have no parents."
                    },
                    {
                        "username": "huttarl",
                        "content": "Unfortunately, the \"input\" in the test cases, an array of ints, is not the same as the parameter passed to minDepth(), which is the root node of a tree. And Leetcode doesn't seem to define how the format of the test case \"input\" translates into a tree. In another problem, it was stored like this: https://en.wikipedia.org/wiki/Binary_tree#Arrays, where node i is the parent of nodes 2i+1 and 2i+2. But in this case, that would mean the nodes with values \"4\" and \"6\" have null parents (which apparently means no parents). The data structure (in Kotlin at least) doesn't allow nodes with null values.\nWe could then guess that the array omits values for nodes whose parents don't exist. But we shouldn't have to *guess* about the meaning of the example input."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "We\\'re looking for the minimum depth of a binary tree from root to leaf. The keyword here is leaf. A leaf is a node that contains no children nodes. So 2 - 3 - 4 - 5 aren\\'t leafs, but 6 is. Once you get to 6 you have a depth of 5, and since that is the only leaf - 5 is what you return."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) Can please explain the logic behind this?"
                    },
                    {
                        "username": "deepti21aug",
                        "content": "[@mariam_meky](/mariam_meky)  I guess it should be 0."
                    },
                    {
                        "username": "mariam_meky",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) what does \"ans\" stand for?"
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": "bro this input is a skwe tree where probably your code is getting struck as node having one children the other children depth is considered 0 zero. try this solution\\n if(root== NULL){\\n            return ans;\\n        }\\n        int l=minDepth(root->left); \\n        int r=minDepth(root->right);\\n        if((l==0 && r==0) || (l!=0 && r!=0))\\n        return 1+min(l,r);\\n\\n        return  1+max(l,r);"
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form...this is like a linked list forming to the right."
                    },
                    {
                        "username": "mkohar",
                        "content": "you can paste above in testcase and leetcode will show you a visual representation of the graph"
                    },
                    {
                        "username": "ahmedelewa79",
                        "content": "the left child for any index will be ( 2*idx + 1)\\nand the right child will be (2*idx + 2)\\nand you can get the parent element for any child by Math.floor((idx-1)/2)"
                    },
                    {
                        "username": "Oliviaaa-EPFL",
                        "content": "This tree is actually a line (2->3->4->5->6). If your answer is 1, you are counting the node with only one child as the leave, so the recursion returns at the first node."
                    },
                    {
                        "username": "nik-1207",
                        "content": "please anyone can explain why the minimum height of the tree [2,null,3,null,4,null,5,null,6] is 5 not 1"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree\n2->3->4->5->6\nnon of these elements have a left child, only right child is available;\n2\n->3\n -->4\n ---->5\n  ----->6\nthis is the representation"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "because bro we see the leaf node which have both child null "
                    },
                    {
                        "username": "matthewmcconaha",
                        "content": "Let's define a \"leaf node\" as a node which does not have any children. So for a leaf node, left is null and right is also null.\nThen let's define the depth of any node as being the number of layers down the tree you have to travel in order to reach that node, starting at 1. So the very top of the tree is at depth 1, the next layer is depth 2, and so on.\nFinally, let's define the minimum depth as the tree as the leaf node with the minimum depth.\n\nIn the example you reference, the top node is not a leaf node. left is null, but right is not null. So the depth can't be 1. There is actually only one leaf node in that tree, and it is at depth 5.\n\nThe answer of 1 would be for the depth where you run into the first \"closed road\". The first time you see a path that you cannot take because the node in that direction is null. However, there is still an \"open road\" in the other direction, so you need to go down that other road. What you are looking for is a \"dead end\", when both possible roads are closed and you cannot go any deeper."
                    },
                    {
                        "username": "mattesko",
                        "content": "The depth of a tree starts at 0 and not at 1! A \\'tree\\' with only a root node and no children is a tree with depth 0, not 1 like the solution entails!\\n\\nhttps://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height"
                    },
                    {
                        "username": "huttarl",
                        "content": "It may be common to define the depth of a tree the way you do, but the description for this problem clearly defines the minimum depth as the number of **nodes** along the shortest path from root to nearest leaf."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Over the years I have seen mix of people: those who use height as in \"height of nodes\", and then \"height of edges\" which causes the 0/1 difference. It is better to clarify which ones is intended one."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Ultron03](/Ultron03) this question says that depth is the number of nodes whereas in the tree properties it said it would the number of edges"
                    },
                    {
                        "username": "Ultron03",
                        "content": "But in this question it is given that if only root node is there the  depth will be 1!!..\\n"
                    },
                    {
                        "username": "msu227",
                        "content": "I dont know if I am seeing this wrong but the example  [2,null,3,null,4,null,5,null,6] is a a bad test case. How doess a null node have a left and right node???? Also even if it the null node is accounted for how is the mindepth 5 for this it should 3 if the null nodes are accounted for and 1 if they aren\\'t accounted for. Am I seeing this wrong or is this actually wrong. Someone please let me know!!![image](https://assets.leetcode.com/users/images/e132a50d-2ded-4656-a11a-2125b9545062_1613348516.5328968.png)\\n"
                    },
                    {
                        "username": "huttarl",
                        "content": "[@joelmathew2809](/joelmathew2809) Thank you. I didn\\'t know about this. Too bad you have to open a different panel to understand the examples given in the problem. But it\\'s better than nothing."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "FUN FACT !\nThe test case panel also renders the tree for you. This way you can clearly understand what this input means. The input here is pretty confusing but it is just for representation. "
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form"
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "[@user2244fP](/user2244fP) \\n\\nno no the null node is not accounted for ,  basically here the left node of every node in the given tree is null \\nbut there will exsist a right node , only number 6 has its left as well as right value as null \\n\\nso , this tree kinda looks like a linked list \\n2-> 3 -> 4 -> 5 -> 6 , hence depth of this will be five \\n\\n"
                    },
                    {
                        "username": "user2244fP",
                        "content": "So I wasn\\'t the only one who faced this."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Learn data structure. It\\'s quite standard. But pay attention to NULL"
                    },
                    {
                        "username": "sreejeet",
                        "content": "1. Why is 2 the answer for test case [1,2]?\\nA: Because the path has to contain *the root* and *a leaf node*. So the path on the right does not count, as it does not contain a leaf node.\\n\\n2. The depth definition is wrong!\\nA: Yes the definition seems wrong, the qustion is wrongly worded; they simply mean the number of nodes in the path to the nearest leaf node. Try to understand it this way: a tree with no root (no nodes) has no depth, therefore 0 depth. A tree with at least 1 node has 1 depth and so on."
                    },
                    {
                        "username": "DemonLeo",
                        "content": "where [1,2]`s  Minimum Depth is 2\\uFF1F"
                    },
                    {
                        "username": "Leetcode_Wat",
                        "content": "The question requires to count the \"number of nodes\" from root to its nearest leaf node. It contains 2 nodes in your given example."
                    },
                    {
                        "username": "luyao0604",
                        "content": "Many of the trees generated for the test cases are wrong. And why is the minDepth defined as distance to its nearest child without any children? Why is it NOT distance to its nearest null child? Doesn\\'t that make more sense?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "[@HapticBovine](/HapticBovine) Actually, it seems that the array representation is different, [2,null,3,null,4,null,5,null,6] is supposed to be a simple path from 2->6. The question is, what is this format, and how can we interpret it unambiguously?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I will explain why this is true then flag the above comment since we can't have nice things (ie., a feature to report incorrect Test Cases).\n\nThe depth of a (binary) Tree is the number of edges to the most distant leaf node. A minimum depth should be the number of edges to the closest leaf node.\n\nRe. Test Case 2:\n\nIf the values are given as array elements in the array [2,null,3,null,4,null,5,null,6], and the expected depth is 5, then we must have a tree with minimum depth/height of 5, meaning the path from the root to _every_ leaf must be >= 5, or in other words, the binary tree has a (min) height of 5, meaning there are 5 edges or 6 nodes in the shortest path from the root a the leaf. The smallest tree in which this could occur is a Perfect Binary Tree, in which there are 63 nodes (2^(h+1) - 1 nodes).\n\nHowever the input [2,null,3,null,4,null,5,null,6] only contains 9 nodes!\n\nWhat a PITA, this is a pretty good platform, can you please make (or improve if it exists) a feature to report incorrect test cases? I want a button similar to the \"submit test case\" button."
                    },
                    {
                        "username": "Ekut",
                        "content": "So I read online(stack overflow, wikipedia) that the depth of a node is the number of edges to the root node. How come in this question, the minimum depth is 2 when there is a leaf node that is only one edge away from the root (direct child). \\nI'm probably missing something. I would appreciate if someone could explain.\\nThanks!"
                    },
                    {
                        "username": "nishantv",
                        "content": "No you are not missing anything. The first example seems incorrect."
                    },
                    {
                        "username": "atulgupta002",
                        "content": "Exactly my question. The min depth is 1. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "In this problem the depth is considered the number of nodes present from the root to the leaf node"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "the first test case right? i got the same doubt"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Some tips: if root is null, return 0. Otherwise keep in mind that roots depth starts at 1, not 0.\nOnly check min depth for leaf nodes - meaning a node who has two NULL children. Some people make the mistake of updating min on every single node when they should only update it for leaf nodes.  \nIf you're doing it recursively, you can save runtime by adding in \"If (depth >= min){return;}\" that way you wont check deeper than you need to."
                    }
                ]
            },
            {
                "id": 1575157,
                "content": [
                    {
                        "username": "ewmiao",
                        "content": "I don\\'t know how to show this tree in a graph, and it\\'s hard to believe that its min depth is 5. However, my code fails on this test case. Anyone explains to me?\\n\\nExample 2:\\n\\nInput: root = [2,null,3,null,4,null,5,null,6]\\nOutput: 5"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "[@huttarl](/huttarl)  The second example shows a Binary tree that is \\'right skewed\\'. [2-3-4-5-6] 6 being the leaf node with min height 5."
                    },
                    {
                        "username": "huttarl",
                        "content": "[@ronitak33](/ronitak33) Unfortunately this would give a tree in which the nodes labeled \"4\" and \"6\" have no parents."
                    },
                    {
                        "username": "huttarl",
                        "content": "Unfortunately, the \"input\" in the test cases, an array of ints, is not the same as the parameter passed to minDepth(), which is the root node of a tree. And Leetcode doesn't seem to define how the format of the test case \"input\" translates into a tree. In another problem, it was stored like this: https://en.wikipedia.org/wiki/Binary_tree#Arrays, where node i is the parent of nodes 2i+1 and 2i+2. But in this case, that would mean the nodes with values \"4\" and \"6\" have null parents (which apparently means no parents). The data structure (in Kotlin at least) doesn't allow nodes with null values.\nWe could then guess that the array omits values for nodes whose parents don't exist. But we shouldn't have to *guess* about the meaning of the example input."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "We\\'re looking for the minimum depth of a binary tree from root to leaf. The keyword here is leaf. A leaf is a node that contains no children nodes. So 2 - 3 - 4 - 5 aren\\'t leafs, but 6 is. Once you get to 6 you have a depth of 5, and since that is the only leaf - 5 is what you return."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) Can please explain the logic behind this?"
                    },
                    {
                        "username": "deepti21aug",
                        "content": "[@mariam_meky](/mariam_meky)  I guess it should be 0."
                    },
                    {
                        "username": "mariam_meky",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) what does \"ans\" stand for?"
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": "bro this input is a skwe tree where probably your code is getting struck as node having one children the other children depth is considered 0 zero. try this solution\\n if(root== NULL){\\n            return ans;\\n        }\\n        int l=minDepth(root->left); \\n        int r=minDepth(root->right);\\n        if((l==0 && r==0) || (l!=0 && r!=0))\\n        return 1+min(l,r);\\n\\n        return  1+max(l,r);"
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form...this is like a linked list forming to the right."
                    },
                    {
                        "username": "mkohar",
                        "content": "you can paste above in testcase and leetcode will show you a visual representation of the graph"
                    },
                    {
                        "username": "ahmedelewa79",
                        "content": "the left child for any index will be ( 2*idx + 1)\\nand the right child will be (2*idx + 2)\\nand you can get the parent element for any child by Math.floor((idx-1)/2)"
                    },
                    {
                        "username": "Oliviaaa-EPFL",
                        "content": "This tree is actually a line (2->3->4->5->6). If your answer is 1, you are counting the node with only one child as the leave, so the recursion returns at the first node."
                    },
                    {
                        "username": "nik-1207",
                        "content": "please anyone can explain why the minimum height of the tree [2,null,3,null,4,null,5,null,6] is 5 not 1"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree\n2->3->4->5->6\nnon of these elements have a left child, only right child is available;\n2\n->3\n -->4\n ---->5\n  ----->6\nthis is the representation"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "because bro we see the leaf node which have both child null "
                    },
                    {
                        "username": "matthewmcconaha",
                        "content": "Let's define a \"leaf node\" as a node which does not have any children. So for a leaf node, left is null and right is also null.\nThen let's define the depth of any node as being the number of layers down the tree you have to travel in order to reach that node, starting at 1. So the very top of the tree is at depth 1, the next layer is depth 2, and so on.\nFinally, let's define the minimum depth as the tree as the leaf node with the minimum depth.\n\nIn the example you reference, the top node is not a leaf node. left is null, but right is not null. So the depth can't be 1. There is actually only one leaf node in that tree, and it is at depth 5.\n\nThe answer of 1 would be for the depth where you run into the first \"closed road\". The first time you see a path that you cannot take because the node in that direction is null. However, there is still an \"open road\" in the other direction, so you need to go down that other road. What you are looking for is a \"dead end\", when both possible roads are closed and you cannot go any deeper."
                    },
                    {
                        "username": "mattesko",
                        "content": "The depth of a tree starts at 0 and not at 1! A \\'tree\\' with only a root node and no children is a tree with depth 0, not 1 like the solution entails!\\n\\nhttps://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height"
                    },
                    {
                        "username": "huttarl",
                        "content": "It may be common to define the depth of a tree the way you do, but the description for this problem clearly defines the minimum depth as the number of **nodes** along the shortest path from root to nearest leaf."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Over the years I have seen mix of people: those who use height as in \"height of nodes\", and then \"height of edges\" which causes the 0/1 difference. It is better to clarify which ones is intended one."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Ultron03](/Ultron03) this question says that depth is the number of nodes whereas in the tree properties it said it would the number of edges"
                    },
                    {
                        "username": "Ultron03",
                        "content": "But in this question it is given that if only root node is there the  depth will be 1!!..\\n"
                    },
                    {
                        "username": "msu227",
                        "content": "I dont know if I am seeing this wrong but the example  [2,null,3,null,4,null,5,null,6] is a a bad test case. How doess a null node have a left and right node???? Also even if it the null node is accounted for how is the mindepth 5 for this it should 3 if the null nodes are accounted for and 1 if they aren\\'t accounted for. Am I seeing this wrong or is this actually wrong. Someone please let me know!!![image](https://assets.leetcode.com/users/images/e132a50d-2ded-4656-a11a-2125b9545062_1613348516.5328968.png)\\n"
                    },
                    {
                        "username": "huttarl",
                        "content": "[@joelmathew2809](/joelmathew2809) Thank you. I didn\\'t know about this. Too bad you have to open a different panel to understand the examples given in the problem. But it\\'s better than nothing."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "FUN FACT !\nThe test case panel also renders the tree for you. This way you can clearly understand what this input means. The input here is pretty confusing but it is just for representation. "
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form"
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "[@user2244fP](/user2244fP) \\n\\nno no the null node is not accounted for ,  basically here the left node of every node in the given tree is null \\nbut there will exsist a right node , only number 6 has its left as well as right value as null \\n\\nso , this tree kinda looks like a linked list \\n2-> 3 -> 4 -> 5 -> 6 , hence depth of this will be five \\n\\n"
                    },
                    {
                        "username": "user2244fP",
                        "content": "So I wasn\\'t the only one who faced this."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Learn data structure. It\\'s quite standard. But pay attention to NULL"
                    },
                    {
                        "username": "sreejeet",
                        "content": "1. Why is 2 the answer for test case [1,2]?\\nA: Because the path has to contain *the root* and *a leaf node*. So the path on the right does not count, as it does not contain a leaf node.\\n\\n2. The depth definition is wrong!\\nA: Yes the definition seems wrong, the qustion is wrongly worded; they simply mean the number of nodes in the path to the nearest leaf node. Try to understand it this way: a tree with no root (no nodes) has no depth, therefore 0 depth. A tree with at least 1 node has 1 depth and so on."
                    },
                    {
                        "username": "DemonLeo",
                        "content": "where [1,2]`s  Minimum Depth is 2\\uFF1F"
                    },
                    {
                        "username": "Leetcode_Wat",
                        "content": "The question requires to count the \"number of nodes\" from root to its nearest leaf node. It contains 2 nodes in your given example."
                    },
                    {
                        "username": "luyao0604",
                        "content": "Many of the trees generated for the test cases are wrong. And why is the minDepth defined as distance to its nearest child without any children? Why is it NOT distance to its nearest null child? Doesn\\'t that make more sense?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "[@HapticBovine](/HapticBovine) Actually, it seems that the array representation is different, [2,null,3,null,4,null,5,null,6] is supposed to be a simple path from 2->6. The question is, what is this format, and how can we interpret it unambiguously?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I will explain why this is true then flag the above comment since we can't have nice things (ie., a feature to report incorrect Test Cases).\n\nThe depth of a (binary) Tree is the number of edges to the most distant leaf node. A minimum depth should be the number of edges to the closest leaf node.\n\nRe. Test Case 2:\n\nIf the values are given as array elements in the array [2,null,3,null,4,null,5,null,6], and the expected depth is 5, then we must have a tree with minimum depth/height of 5, meaning the path from the root to _every_ leaf must be >= 5, or in other words, the binary tree has a (min) height of 5, meaning there are 5 edges or 6 nodes in the shortest path from the root a the leaf. The smallest tree in which this could occur is a Perfect Binary Tree, in which there are 63 nodes (2^(h+1) - 1 nodes).\n\nHowever the input [2,null,3,null,4,null,5,null,6] only contains 9 nodes!\n\nWhat a PITA, this is a pretty good platform, can you please make (or improve if it exists) a feature to report incorrect test cases? I want a button similar to the \"submit test case\" button."
                    },
                    {
                        "username": "Ekut",
                        "content": "So I read online(stack overflow, wikipedia) that the depth of a node is the number of edges to the root node. How come in this question, the minimum depth is 2 when there is a leaf node that is only one edge away from the root (direct child). \\nI'm probably missing something. I would appreciate if someone could explain.\\nThanks!"
                    },
                    {
                        "username": "nishantv",
                        "content": "No you are not missing anything. The first example seems incorrect."
                    },
                    {
                        "username": "atulgupta002",
                        "content": "Exactly my question. The min depth is 1. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "In this problem the depth is considered the number of nodes present from the root to the leaf node"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "the first test case right? i got the same doubt"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Some tips: if root is null, return 0. Otherwise keep in mind that roots depth starts at 1, not 0.\nOnly check min depth for leaf nodes - meaning a node who has two NULL children. Some people make the mistake of updating min on every single node when they should only update it for leaf nodes.  \nIf you're doing it recursively, you can save runtime by adding in \"If (depth >= min){return;}\" that way you wont check deeper than you need to."
                    }
                ]
            },
            {
                "id": 1566112,
                "content": [
                    {
                        "username": "ewmiao",
                        "content": "I don\\'t know how to show this tree in a graph, and it\\'s hard to believe that its min depth is 5. However, my code fails on this test case. Anyone explains to me?\\n\\nExample 2:\\n\\nInput: root = [2,null,3,null,4,null,5,null,6]\\nOutput: 5"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "[@huttarl](/huttarl)  The second example shows a Binary tree that is \\'right skewed\\'. [2-3-4-5-6] 6 being the leaf node with min height 5."
                    },
                    {
                        "username": "huttarl",
                        "content": "[@ronitak33](/ronitak33) Unfortunately this would give a tree in which the nodes labeled \"4\" and \"6\" have no parents."
                    },
                    {
                        "username": "huttarl",
                        "content": "Unfortunately, the \"input\" in the test cases, an array of ints, is not the same as the parameter passed to minDepth(), which is the root node of a tree. And Leetcode doesn't seem to define how the format of the test case \"input\" translates into a tree. In another problem, it was stored like this: https://en.wikipedia.org/wiki/Binary_tree#Arrays, where node i is the parent of nodes 2i+1 and 2i+2. But in this case, that would mean the nodes with values \"4\" and \"6\" have null parents (which apparently means no parents). The data structure (in Kotlin at least) doesn't allow nodes with null values.\nWe could then guess that the array omits values for nodes whose parents don't exist. But we shouldn't have to *guess* about the meaning of the example input."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "We\\'re looking for the minimum depth of a binary tree from root to leaf. The keyword here is leaf. A leaf is a node that contains no children nodes. So 2 - 3 - 4 - 5 aren\\'t leafs, but 6 is. Once you get to 6 you have a depth of 5, and since that is the only leaf - 5 is what you return."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) Can please explain the logic behind this?"
                    },
                    {
                        "username": "deepti21aug",
                        "content": "[@mariam_meky](/mariam_meky)  I guess it should be 0."
                    },
                    {
                        "username": "mariam_meky",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) what does \"ans\" stand for?"
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": "bro this input is a skwe tree where probably your code is getting struck as node having one children the other children depth is considered 0 zero. try this solution\\n if(root== NULL){\\n            return ans;\\n        }\\n        int l=minDepth(root->left); \\n        int r=minDepth(root->right);\\n        if((l==0 && r==0) || (l!=0 && r!=0))\\n        return 1+min(l,r);\\n\\n        return  1+max(l,r);"
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form...this is like a linked list forming to the right."
                    },
                    {
                        "username": "mkohar",
                        "content": "you can paste above in testcase and leetcode will show you a visual representation of the graph"
                    },
                    {
                        "username": "ahmedelewa79",
                        "content": "the left child for any index will be ( 2*idx + 1)\\nand the right child will be (2*idx + 2)\\nand you can get the parent element for any child by Math.floor((idx-1)/2)"
                    },
                    {
                        "username": "Oliviaaa-EPFL",
                        "content": "This tree is actually a line (2->3->4->5->6). If your answer is 1, you are counting the node with only one child as the leave, so the recursion returns at the first node."
                    },
                    {
                        "username": "nik-1207",
                        "content": "please anyone can explain why the minimum height of the tree [2,null,3,null,4,null,5,null,6] is 5 not 1"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree\n2->3->4->5->6\nnon of these elements have a left child, only right child is available;\n2\n->3\n -->4\n ---->5\n  ----->6\nthis is the representation"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "because bro we see the leaf node which have both child null "
                    },
                    {
                        "username": "matthewmcconaha",
                        "content": "Let's define a \"leaf node\" as a node which does not have any children. So for a leaf node, left is null and right is also null.\nThen let's define the depth of any node as being the number of layers down the tree you have to travel in order to reach that node, starting at 1. So the very top of the tree is at depth 1, the next layer is depth 2, and so on.\nFinally, let's define the minimum depth as the tree as the leaf node with the minimum depth.\n\nIn the example you reference, the top node is not a leaf node. left is null, but right is not null. So the depth can't be 1. There is actually only one leaf node in that tree, and it is at depth 5.\n\nThe answer of 1 would be for the depth where you run into the first \"closed road\". The first time you see a path that you cannot take because the node in that direction is null. However, there is still an \"open road\" in the other direction, so you need to go down that other road. What you are looking for is a \"dead end\", when both possible roads are closed and you cannot go any deeper."
                    },
                    {
                        "username": "mattesko",
                        "content": "The depth of a tree starts at 0 and not at 1! A \\'tree\\' with only a root node and no children is a tree with depth 0, not 1 like the solution entails!\\n\\nhttps://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height"
                    },
                    {
                        "username": "huttarl",
                        "content": "It may be common to define the depth of a tree the way you do, but the description for this problem clearly defines the minimum depth as the number of **nodes** along the shortest path from root to nearest leaf."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Over the years I have seen mix of people: those who use height as in \"height of nodes\", and then \"height of edges\" which causes the 0/1 difference. It is better to clarify which ones is intended one."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Ultron03](/Ultron03) this question says that depth is the number of nodes whereas in the tree properties it said it would the number of edges"
                    },
                    {
                        "username": "Ultron03",
                        "content": "But in this question it is given that if only root node is there the  depth will be 1!!..\\n"
                    },
                    {
                        "username": "msu227",
                        "content": "I dont know if I am seeing this wrong but the example  [2,null,3,null,4,null,5,null,6] is a a bad test case. How doess a null node have a left and right node???? Also even if it the null node is accounted for how is the mindepth 5 for this it should 3 if the null nodes are accounted for and 1 if they aren\\'t accounted for. Am I seeing this wrong or is this actually wrong. Someone please let me know!!![image](https://assets.leetcode.com/users/images/e132a50d-2ded-4656-a11a-2125b9545062_1613348516.5328968.png)\\n"
                    },
                    {
                        "username": "huttarl",
                        "content": "[@joelmathew2809](/joelmathew2809) Thank you. I didn\\'t know about this. Too bad you have to open a different panel to understand the examples given in the problem. But it\\'s better than nothing."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "FUN FACT !\nThe test case panel also renders the tree for you. This way you can clearly understand what this input means. The input here is pretty confusing but it is just for representation. "
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form"
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "[@user2244fP](/user2244fP) \\n\\nno no the null node is not accounted for ,  basically here the left node of every node in the given tree is null \\nbut there will exsist a right node , only number 6 has its left as well as right value as null \\n\\nso , this tree kinda looks like a linked list \\n2-> 3 -> 4 -> 5 -> 6 , hence depth of this will be five \\n\\n"
                    },
                    {
                        "username": "user2244fP",
                        "content": "So I wasn\\'t the only one who faced this."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Learn data structure. It\\'s quite standard. But pay attention to NULL"
                    },
                    {
                        "username": "sreejeet",
                        "content": "1. Why is 2 the answer for test case [1,2]?\\nA: Because the path has to contain *the root* and *a leaf node*. So the path on the right does not count, as it does not contain a leaf node.\\n\\n2. The depth definition is wrong!\\nA: Yes the definition seems wrong, the qustion is wrongly worded; they simply mean the number of nodes in the path to the nearest leaf node. Try to understand it this way: a tree with no root (no nodes) has no depth, therefore 0 depth. A tree with at least 1 node has 1 depth and so on."
                    },
                    {
                        "username": "DemonLeo",
                        "content": "where [1,2]`s  Minimum Depth is 2\\uFF1F"
                    },
                    {
                        "username": "Leetcode_Wat",
                        "content": "The question requires to count the \"number of nodes\" from root to its nearest leaf node. It contains 2 nodes in your given example."
                    },
                    {
                        "username": "luyao0604",
                        "content": "Many of the trees generated for the test cases are wrong. And why is the minDepth defined as distance to its nearest child without any children? Why is it NOT distance to its nearest null child? Doesn\\'t that make more sense?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "[@HapticBovine](/HapticBovine) Actually, it seems that the array representation is different, [2,null,3,null,4,null,5,null,6] is supposed to be a simple path from 2->6. The question is, what is this format, and how can we interpret it unambiguously?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I will explain why this is true then flag the above comment since we can't have nice things (ie., a feature to report incorrect Test Cases).\n\nThe depth of a (binary) Tree is the number of edges to the most distant leaf node. A minimum depth should be the number of edges to the closest leaf node.\n\nRe. Test Case 2:\n\nIf the values are given as array elements in the array [2,null,3,null,4,null,5,null,6], and the expected depth is 5, then we must have a tree with minimum depth/height of 5, meaning the path from the root to _every_ leaf must be >= 5, or in other words, the binary tree has a (min) height of 5, meaning there are 5 edges or 6 nodes in the shortest path from the root a the leaf. The smallest tree in which this could occur is a Perfect Binary Tree, in which there are 63 nodes (2^(h+1) - 1 nodes).\n\nHowever the input [2,null,3,null,4,null,5,null,6] only contains 9 nodes!\n\nWhat a PITA, this is a pretty good platform, can you please make (or improve if it exists) a feature to report incorrect test cases? I want a button similar to the \"submit test case\" button."
                    },
                    {
                        "username": "Ekut",
                        "content": "So I read online(stack overflow, wikipedia) that the depth of a node is the number of edges to the root node. How come in this question, the minimum depth is 2 when there is a leaf node that is only one edge away from the root (direct child). \\nI'm probably missing something. I would appreciate if someone could explain.\\nThanks!"
                    },
                    {
                        "username": "nishantv",
                        "content": "No you are not missing anything. The first example seems incorrect."
                    },
                    {
                        "username": "atulgupta002",
                        "content": "Exactly my question. The min depth is 1. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "In this problem the depth is considered the number of nodes present from the root to the leaf node"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "the first test case right? i got the same doubt"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Some tips: if root is null, return 0. Otherwise keep in mind that roots depth starts at 1, not 0.\nOnly check min depth for leaf nodes - meaning a node who has two NULL children. Some people make the mistake of updating min on every single node when they should only update it for leaf nodes.  \nIf you're doing it recursively, you can save runtime by adding in \"If (depth >= min){return;}\" that way you wont check deeper than you need to."
                    }
                ]
            },
            {
                "id": 1574956,
                "content": [
                    {
                        "username": "ewmiao",
                        "content": "I don\\'t know how to show this tree in a graph, and it\\'s hard to believe that its min depth is 5. However, my code fails on this test case. Anyone explains to me?\\n\\nExample 2:\\n\\nInput: root = [2,null,3,null,4,null,5,null,6]\\nOutput: 5"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "[@huttarl](/huttarl)  The second example shows a Binary tree that is \\'right skewed\\'. [2-3-4-5-6] 6 being the leaf node with min height 5."
                    },
                    {
                        "username": "huttarl",
                        "content": "[@ronitak33](/ronitak33) Unfortunately this would give a tree in which the nodes labeled \"4\" and \"6\" have no parents."
                    },
                    {
                        "username": "huttarl",
                        "content": "Unfortunately, the \"input\" in the test cases, an array of ints, is not the same as the parameter passed to minDepth(), which is the root node of a tree. And Leetcode doesn't seem to define how the format of the test case \"input\" translates into a tree. In another problem, it was stored like this: https://en.wikipedia.org/wiki/Binary_tree#Arrays, where node i is the parent of nodes 2i+1 and 2i+2. But in this case, that would mean the nodes with values \"4\" and \"6\" have null parents (which apparently means no parents). The data structure (in Kotlin at least) doesn't allow nodes with null values.\nWe could then guess that the array omits values for nodes whose parents don't exist. But we shouldn't have to *guess* about the meaning of the example input."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "We\\'re looking for the minimum depth of a binary tree from root to leaf. The keyword here is leaf. A leaf is a node that contains no children nodes. So 2 - 3 - 4 - 5 aren\\'t leafs, but 6 is. Once you get to 6 you have a depth of 5, and since that is the only leaf - 5 is what you return."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) Can please explain the logic behind this?"
                    },
                    {
                        "username": "deepti21aug",
                        "content": "[@mariam_meky](/mariam_meky)  I guess it should be 0."
                    },
                    {
                        "username": "mariam_meky",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) what does \"ans\" stand for?"
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": "bro this input is a skwe tree where probably your code is getting struck as node having one children the other children depth is considered 0 zero. try this solution\\n if(root== NULL){\\n            return ans;\\n        }\\n        int l=minDepth(root->left); \\n        int r=minDepth(root->right);\\n        if((l==0 && r==0) || (l!=0 && r!=0))\\n        return 1+min(l,r);\\n\\n        return  1+max(l,r);"
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form...this is like a linked list forming to the right."
                    },
                    {
                        "username": "mkohar",
                        "content": "you can paste above in testcase and leetcode will show you a visual representation of the graph"
                    },
                    {
                        "username": "ahmedelewa79",
                        "content": "the left child for any index will be ( 2*idx + 1)\\nand the right child will be (2*idx + 2)\\nand you can get the parent element for any child by Math.floor((idx-1)/2)"
                    },
                    {
                        "username": "Oliviaaa-EPFL",
                        "content": "This tree is actually a line (2->3->4->5->6). If your answer is 1, you are counting the node with only one child as the leave, so the recursion returns at the first node."
                    },
                    {
                        "username": "nik-1207",
                        "content": "please anyone can explain why the minimum height of the tree [2,null,3,null,4,null,5,null,6] is 5 not 1"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree\n2->3->4->5->6\nnon of these elements have a left child, only right child is available;\n2\n->3\n -->4\n ---->5\n  ----->6\nthis is the representation"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "because bro we see the leaf node which have both child null "
                    },
                    {
                        "username": "matthewmcconaha",
                        "content": "Let's define a \"leaf node\" as a node which does not have any children. So for a leaf node, left is null and right is also null.\nThen let's define the depth of any node as being the number of layers down the tree you have to travel in order to reach that node, starting at 1. So the very top of the tree is at depth 1, the next layer is depth 2, and so on.\nFinally, let's define the minimum depth as the tree as the leaf node with the minimum depth.\n\nIn the example you reference, the top node is not a leaf node. left is null, but right is not null. So the depth can't be 1. There is actually only one leaf node in that tree, and it is at depth 5.\n\nThe answer of 1 would be for the depth where you run into the first \"closed road\". The first time you see a path that you cannot take because the node in that direction is null. However, there is still an \"open road\" in the other direction, so you need to go down that other road. What you are looking for is a \"dead end\", when both possible roads are closed and you cannot go any deeper."
                    },
                    {
                        "username": "mattesko",
                        "content": "The depth of a tree starts at 0 and not at 1! A \\'tree\\' with only a root node and no children is a tree with depth 0, not 1 like the solution entails!\\n\\nhttps://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height"
                    },
                    {
                        "username": "huttarl",
                        "content": "It may be common to define the depth of a tree the way you do, but the description for this problem clearly defines the minimum depth as the number of **nodes** along the shortest path from root to nearest leaf."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Over the years I have seen mix of people: those who use height as in \"height of nodes\", and then \"height of edges\" which causes the 0/1 difference. It is better to clarify which ones is intended one."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Ultron03](/Ultron03) this question says that depth is the number of nodes whereas in the tree properties it said it would the number of edges"
                    },
                    {
                        "username": "Ultron03",
                        "content": "But in this question it is given that if only root node is there the  depth will be 1!!..\\n"
                    },
                    {
                        "username": "msu227",
                        "content": "I dont know if I am seeing this wrong but the example  [2,null,3,null,4,null,5,null,6] is a a bad test case. How doess a null node have a left and right node???? Also even if it the null node is accounted for how is the mindepth 5 for this it should 3 if the null nodes are accounted for and 1 if they aren\\'t accounted for. Am I seeing this wrong or is this actually wrong. Someone please let me know!!![image](https://assets.leetcode.com/users/images/e132a50d-2ded-4656-a11a-2125b9545062_1613348516.5328968.png)\\n"
                    },
                    {
                        "username": "huttarl",
                        "content": "[@joelmathew2809](/joelmathew2809) Thank you. I didn\\'t know about this. Too bad you have to open a different panel to understand the examples given in the problem. But it\\'s better than nothing."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "FUN FACT !\nThe test case panel also renders the tree for you. This way you can clearly understand what this input means. The input here is pretty confusing but it is just for representation. "
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form"
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "[@user2244fP](/user2244fP) \\n\\nno no the null node is not accounted for ,  basically here the left node of every node in the given tree is null \\nbut there will exsist a right node , only number 6 has its left as well as right value as null \\n\\nso , this tree kinda looks like a linked list \\n2-> 3 -> 4 -> 5 -> 6 , hence depth of this will be five \\n\\n"
                    },
                    {
                        "username": "user2244fP",
                        "content": "So I wasn\\'t the only one who faced this."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Learn data structure. It\\'s quite standard. But pay attention to NULL"
                    },
                    {
                        "username": "sreejeet",
                        "content": "1. Why is 2 the answer for test case [1,2]?\\nA: Because the path has to contain *the root* and *a leaf node*. So the path on the right does not count, as it does not contain a leaf node.\\n\\n2. The depth definition is wrong!\\nA: Yes the definition seems wrong, the qustion is wrongly worded; they simply mean the number of nodes in the path to the nearest leaf node. Try to understand it this way: a tree with no root (no nodes) has no depth, therefore 0 depth. A tree with at least 1 node has 1 depth and so on."
                    },
                    {
                        "username": "DemonLeo",
                        "content": "where [1,2]`s  Minimum Depth is 2\\uFF1F"
                    },
                    {
                        "username": "Leetcode_Wat",
                        "content": "The question requires to count the \"number of nodes\" from root to its nearest leaf node. It contains 2 nodes in your given example."
                    },
                    {
                        "username": "luyao0604",
                        "content": "Many of the trees generated for the test cases are wrong. And why is the minDepth defined as distance to its nearest child without any children? Why is it NOT distance to its nearest null child? Doesn\\'t that make more sense?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "[@HapticBovine](/HapticBovine) Actually, it seems that the array representation is different, [2,null,3,null,4,null,5,null,6] is supposed to be a simple path from 2->6. The question is, what is this format, and how can we interpret it unambiguously?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I will explain why this is true then flag the above comment since we can't have nice things (ie., a feature to report incorrect Test Cases).\n\nThe depth of a (binary) Tree is the number of edges to the most distant leaf node. A minimum depth should be the number of edges to the closest leaf node.\n\nRe. Test Case 2:\n\nIf the values are given as array elements in the array [2,null,3,null,4,null,5,null,6], and the expected depth is 5, then we must have a tree with minimum depth/height of 5, meaning the path from the root to _every_ leaf must be >= 5, or in other words, the binary tree has a (min) height of 5, meaning there are 5 edges or 6 nodes in the shortest path from the root a the leaf. The smallest tree in which this could occur is a Perfect Binary Tree, in which there are 63 nodes (2^(h+1) - 1 nodes).\n\nHowever the input [2,null,3,null,4,null,5,null,6] only contains 9 nodes!\n\nWhat a PITA, this is a pretty good platform, can you please make (or improve if it exists) a feature to report incorrect test cases? I want a button similar to the \"submit test case\" button."
                    },
                    {
                        "username": "Ekut",
                        "content": "So I read online(stack overflow, wikipedia) that the depth of a node is the number of edges to the root node. How come in this question, the minimum depth is 2 when there is a leaf node that is only one edge away from the root (direct child). \\nI'm probably missing something. I would appreciate if someone could explain.\\nThanks!"
                    },
                    {
                        "username": "nishantv",
                        "content": "No you are not missing anything. The first example seems incorrect."
                    },
                    {
                        "username": "atulgupta002",
                        "content": "Exactly my question. The min depth is 1. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "In this problem the depth is considered the number of nodes present from the root to the leaf node"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "the first test case right? i got the same doubt"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Some tips: if root is null, return 0. Otherwise keep in mind that roots depth starts at 1, not 0.\nOnly check min depth for leaf nodes - meaning a node who has two NULL children. Some people make the mistake of updating min on every single node when they should only update it for leaf nodes.  \nIf you're doing it recursively, you can save runtime by adding in \"If (depth >= min){return;}\" that way you wont check deeper than you need to."
                    }
                ]
            },
            {
                "id": 1963651,
                "content": [
                    {
                        "username": "ewmiao",
                        "content": "I don\\'t know how to show this tree in a graph, and it\\'s hard to believe that its min depth is 5. However, my code fails on this test case. Anyone explains to me?\\n\\nExample 2:\\n\\nInput: root = [2,null,3,null,4,null,5,null,6]\\nOutput: 5"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "[@huttarl](/huttarl)  The second example shows a Binary tree that is \\'right skewed\\'. [2-3-4-5-6] 6 being the leaf node with min height 5."
                    },
                    {
                        "username": "huttarl",
                        "content": "[@ronitak33](/ronitak33) Unfortunately this would give a tree in which the nodes labeled \"4\" and \"6\" have no parents."
                    },
                    {
                        "username": "huttarl",
                        "content": "Unfortunately, the \"input\" in the test cases, an array of ints, is not the same as the parameter passed to minDepth(), which is the root node of a tree. And Leetcode doesn't seem to define how the format of the test case \"input\" translates into a tree. In another problem, it was stored like this: https://en.wikipedia.org/wiki/Binary_tree#Arrays, where node i is the parent of nodes 2i+1 and 2i+2. But in this case, that would mean the nodes with values \"4\" and \"6\" have null parents (which apparently means no parents). The data structure (in Kotlin at least) doesn't allow nodes with null values.\nWe could then guess that the array omits values for nodes whose parents don't exist. But we shouldn't have to *guess* about the meaning of the example input."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "We\\'re looking for the minimum depth of a binary tree from root to leaf. The keyword here is leaf. A leaf is a node that contains no children nodes. So 2 - 3 - 4 - 5 aren\\'t leafs, but 6 is. Once you get to 6 you have a depth of 5, and since that is the only leaf - 5 is what you return."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) Can please explain the logic behind this?"
                    },
                    {
                        "username": "deepti21aug",
                        "content": "[@mariam_meky](/mariam_meky)  I guess it should be 0."
                    },
                    {
                        "username": "mariam_meky",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) what does \"ans\" stand for?"
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": "bro this input is a skwe tree where probably your code is getting struck as node having one children the other children depth is considered 0 zero. try this solution\\n if(root== NULL){\\n            return ans;\\n        }\\n        int l=minDepth(root->left); \\n        int r=minDepth(root->right);\\n        if((l==0 && r==0) || (l!=0 && r!=0))\\n        return 1+min(l,r);\\n\\n        return  1+max(l,r);"
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form...this is like a linked list forming to the right."
                    },
                    {
                        "username": "mkohar",
                        "content": "you can paste above in testcase and leetcode will show you a visual representation of the graph"
                    },
                    {
                        "username": "ahmedelewa79",
                        "content": "the left child for any index will be ( 2*idx + 1)\\nand the right child will be (2*idx + 2)\\nand you can get the parent element for any child by Math.floor((idx-1)/2)"
                    },
                    {
                        "username": "Oliviaaa-EPFL",
                        "content": "This tree is actually a line (2->3->4->5->6). If your answer is 1, you are counting the node with only one child as the leave, so the recursion returns at the first node."
                    },
                    {
                        "username": "nik-1207",
                        "content": "please anyone can explain why the minimum height of the tree [2,null,3,null,4,null,5,null,6] is 5 not 1"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree\n2->3->4->5->6\nnon of these elements have a left child, only right child is available;\n2\n->3\n -->4\n ---->5\n  ----->6\nthis is the representation"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "because bro we see the leaf node which have both child null "
                    },
                    {
                        "username": "matthewmcconaha",
                        "content": "Let's define a \"leaf node\" as a node which does not have any children. So for a leaf node, left is null and right is also null.\nThen let's define the depth of any node as being the number of layers down the tree you have to travel in order to reach that node, starting at 1. So the very top of the tree is at depth 1, the next layer is depth 2, and so on.\nFinally, let's define the minimum depth as the tree as the leaf node with the minimum depth.\n\nIn the example you reference, the top node is not a leaf node. left is null, but right is not null. So the depth can't be 1. There is actually only one leaf node in that tree, and it is at depth 5.\n\nThe answer of 1 would be for the depth where you run into the first \"closed road\". The first time you see a path that you cannot take because the node in that direction is null. However, there is still an \"open road\" in the other direction, so you need to go down that other road. What you are looking for is a \"dead end\", when both possible roads are closed and you cannot go any deeper."
                    },
                    {
                        "username": "mattesko",
                        "content": "The depth of a tree starts at 0 and not at 1! A \\'tree\\' with only a root node and no children is a tree with depth 0, not 1 like the solution entails!\\n\\nhttps://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height"
                    },
                    {
                        "username": "huttarl",
                        "content": "It may be common to define the depth of a tree the way you do, but the description for this problem clearly defines the minimum depth as the number of **nodes** along the shortest path from root to nearest leaf."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Over the years I have seen mix of people: those who use height as in \"height of nodes\", and then \"height of edges\" which causes the 0/1 difference. It is better to clarify which ones is intended one."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Ultron03](/Ultron03) this question says that depth is the number of nodes whereas in the tree properties it said it would the number of edges"
                    },
                    {
                        "username": "Ultron03",
                        "content": "But in this question it is given that if only root node is there the  depth will be 1!!..\\n"
                    },
                    {
                        "username": "msu227",
                        "content": "I dont know if I am seeing this wrong but the example  [2,null,3,null,4,null,5,null,6] is a a bad test case. How doess a null node have a left and right node???? Also even if it the null node is accounted for how is the mindepth 5 for this it should 3 if the null nodes are accounted for and 1 if they aren\\'t accounted for. Am I seeing this wrong or is this actually wrong. Someone please let me know!!![image](https://assets.leetcode.com/users/images/e132a50d-2ded-4656-a11a-2125b9545062_1613348516.5328968.png)\\n"
                    },
                    {
                        "username": "huttarl",
                        "content": "[@joelmathew2809](/joelmathew2809) Thank you. I didn\\'t know about this. Too bad you have to open a different panel to understand the examples given in the problem. But it\\'s better than nothing."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "FUN FACT !\nThe test case panel also renders the tree for you. This way you can clearly understand what this input means. The input here is pretty confusing but it is just for representation. "
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form"
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "[@user2244fP](/user2244fP) \\n\\nno no the null node is not accounted for ,  basically here the left node of every node in the given tree is null \\nbut there will exsist a right node , only number 6 has its left as well as right value as null \\n\\nso , this tree kinda looks like a linked list \\n2-> 3 -> 4 -> 5 -> 6 , hence depth of this will be five \\n\\n"
                    },
                    {
                        "username": "user2244fP",
                        "content": "So I wasn\\'t the only one who faced this."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Learn data structure. It\\'s quite standard. But pay attention to NULL"
                    },
                    {
                        "username": "sreejeet",
                        "content": "1. Why is 2 the answer for test case [1,2]?\\nA: Because the path has to contain *the root* and *a leaf node*. So the path on the right does not count, as it does not contain a leaf node.\\n\\n2. The depth definition is wrong!\\nA: Yes the definition seems wrong, the qustion is wrongly worded; they simply mean the number of nodes in the path to the nearest leaf node. Try to understand it this way: a tree with no root (no nodes) has no depth, therefore 0 depth. A tree with at least 1 node has 1 depth and so on."
                    },
                    {
                        "username": "DemonLeo",
                        "content": "where [1,2]`s  Minimum Depth is 2\\uFF1F"
                    },
                    {
                        "username": "Leetcode_Wat",
                        "content": "The question requires to count the \"number of nodes\" from root to its nearest leaf node. It contains 2 nodes in your given example."
                    },
                    {
                        "username": "luyao0604",
                        "content": "Many of the trees generated for the test cases are wrong. And why is the minDepth defined as distance to its nearest child without any children? Why is it NOT distance to its nearest null child? Doesn\\'t that make more sense?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "[@HapticBovine](/HapticBovine) Actually, it seems that the array representation is different, [2,null,3,null,4,null,5,null,6] is supposed to be a simple path from 2->6. The question is, what is this format, and how can we interpret it unambiguously?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I will explain why this is true then flag the above comment since we can't have nice things (ie., a feature to report incorrect Test Cases).\n\nThe depth of a (binary) Tree is the number of edges to the most distant leaf node. A minimum depth should be the number of edges to the closest leaf node.\n\nRe. Test Case 2:\n\nIf the values are given as array elements in the array [2,null,3,null,4,null,5,null,6], and the expected depth is 5, then we must have a tree with minimum depth/height of 5, meaning the path from the root to _every_ leaf must be >= 5, or in other words, the binary tree has a (min) height of 5, meaning there are 5 edges or 6 nodes in the shortest path from the root a the leaf. The smallest tree in which this could occur is a Perfect Binary Tree, in which there are 63 nodes (2^(h+1) - 1 nodes).\n\nHowever the input [2,null,3,null,4,null,5,null,6] only contains 9 nodes!\n\nWhat a PITA, this is a pretty good platform, can you please make (or improve if it exists) a feature to report incorrect test cases? I want a button similar to the \"submit test case\" button."
                    },
                    {
                        "username": "Ekut",
                        "content": "So I read online(stack overflow, wikipedia) that the depth of a node is the number of edges to the root node. How come in this question, the minimum depth is 2 when there is a leaf node that is only one edge away from the root (direct child). \\nI'm probably missing something. I would appreciate if someone could explain.\\nThanks!"
                    },
                    {
                        "username": "nishantv",
                        "content": "No you are not missing anything. The first example seems incorrect."
                    },
                    {
                        "username": "atulgupta002",
                        "content": "Exactly my question. The min depth is 1. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "In this problem the depth is considered the number of nodes present from the root to the leaf node"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "the first test case right? i got the same doubt"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Some tips: if root is null, return 0. Otherwise keep in mind that roots depth starts at 1, not 0.\nOnly check min depth for leaf nodes - meaning a node who has two NULL children. Some people make the mistake of updating min on every single node when they should only update it for leaf nodes.  \nIf you're doing it recursively, you can save runtime by adding in \"If (depth >= min){return;}\" that way you wont check deeper than you need to."
                    }
                ]
            },
            {
                "id": 1570150,
                "content": [
                    {
                        "username": "ewmiao",
                        "content": "I don\\'t know how to show this tree in a graph, and it\\'s hard to believe that its min depth is 5. However, my code fails on this test case. Anyone explains to me?\\n\\nExample 2:\\n\\nInput: root = [2,null,3,null,4,null,5,null,6]\\nOutput: 5"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "[@huttarl](/huttarl)  The second example shows a Binary tree that is \\'right skewed\\'. [2-3-4-5-6] 6 being the leaf node with min height 5."
                    },
                    {
                        "username": "huttarl",
                        "content": "[@ronitak33](/ronitak33) Unfortunately this would give a tree in which the nodes labeled \"4\" and \"6\" have no parents."
                    },
                    {
                        "username": "huttarl",
                        "content": "Unfortunately, the \"input\" in the test cases, an array of ints, is not the same as the parameter passed to minDepth(), which is the root node of a tree. And Leetcode doesn't seem to define how the format of the test case \"input\" translates into a tree. In another problem, it was stored like this: https://en.wikipedia.org/wiki/Binary_tree#Arrays, where node i is the parent of nodes 2i+1 and 2i+2. But in this case, that would mean the nodes with values \"4\" and \"6\" have null parents (which apparently means no parents). The data structure (in Kotlin at least) doesn't allow nodes with null values.\nWe could then guess that the array omits values for nodes whose parents don't exist. But we shouldn't have to *guess* about the meaning of the example input."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "We\\'re looking for the minimum depth of a binary tree from root to leaf. The keyword here is leaf. A leaf is a node that contains no children nodes. So 2 - 3 - 4 - 5 aren\\'t leafs, but 6 is. Once you get to 6 you have a depth of 5, and since that is the only leaf - 5 is what you return."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) Can please explain the logic behind this?"
                    },
                    {
                        "username": "deepti21aug",
                        "content": "[@mariam_meky](/mariam_meky)  I guess it should be 0."
                    },
                    {
                        "username": "mariam_meky",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) what does \"ans\" stand for?"
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": "bro this input is a skwe tree where probably your code is getting struck as node having one children the other children depth is considered 0 zero. try this solution\\n if(root== NULL){\\n            return ans;\\n        }\\n        int l=minDepth(root->left); \\n        int r=minDepth(root->right);\\n        if((l==0 && r==0) || (l!=0 && r!=0))\\n        return 1+min(l,r);\\n\\n        return  1+max(l,r);"
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form...this is like a linked list forming to the right."
                    },
                    {
                        "username": "mkohar",
                        "content": "you can paste above in testcase and leetcode will show you a visual representation of the graph"
                    },
                    {
                        "username": "ahmedelewa79",
                        "content": "the left child for any index will be ( 2*idx + 1)\\nand the right child will be (2*idx + 2)\\nand you can get the parent element for any child by Math.floor((idx-1)/2)"
                    },
                    {
                        "username": "Oliviaaa-EPFL",
                        "content": "This tree is actually a line (2->3->4->5->6). If your answer is 1, you are counting the node with only one child as the leave, so the recursion returns at the first node."
                    },
                    {
                        "username": "nik-1207",
                        "content": "please anyone can explain why the minimum height of the tree [2,null,3,null,4,null,5,null,6] is 5 not 1"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree\n2->3->4->5->6\nnon of these elements have a left child, only right child is available;\n2\n->3\n -->4\n ---->5\n  ----->6\nthis is the representation"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "because bro we see the leaf node which have both child null "
                    },
                    {
                        "username": "matthewmcconaha",
                        "content": "Let's define a \"leaf node\" as a node which does not have any children. So for a leaf node, left is null and right is also null.\nThen let's define the depth of any node as being the number of layers down the tree you have to travel in order to reach that node, starting at 1. So the very top of the tree is at depth 1, the next layer is depth 2, and so on.\nFinally, let's define the minimum depth as the tree as the leaf node with the minimum depth.\n\nIn the example you reference, the top node is not a leaf node. left is null, but right is not null. So the depth can't be 1. There is actually only one leaf node in that tree, and it is at depth 5.\n\nThe answer of 1 would be for the depth where you run into the first \"closed road\". The first time you see a path that you cannot take because the node in that direction is null. However, there is still an \"open road\" in the other direction, so you need to go down that other road. What you are looking for is a \"dead end\", when both possible roads are closed and you cannot go any deeper."
                    },
                    {
                        "username": "mattesko",
                        "content": "The depth of a tree starts at 0 and not at 1! A \\'tree\\' with only a root node and no children is a tree with depth 0, not 1 like the solution entails!\\n\\nhttps://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height"
                    },
                    {
                        "username": "huttarl",
                        "content": "It may be common to define the depth of a tree the way you do, but the description for this problem clearly defines the minimum depth as the number of **nodes** along the shortest path from root to nearest leaf."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Over the years I have seen mix of people: those who use height as in \"height of nodes\", and then \"height of edges\" which causes the 0/1 difference. It is better to clarify which ones is intended one."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Ultron03](/Ultron03) this question says that depth is the number of nodes whereas in the tree properties it said it would the number of edges"
                    },
                    {
                        "username": "Ultron03",
                        "content": "But in this question it is given that if only root node is there the  depth will be 1!!..\\n"
                    },
                    {
                        "username": "msu227",
                        "content": "I dont know if I am seeing this wrong but the example  [2,null,3,null,4,null,5,null,6] is a a bad test case. How doess a null node have a left and right node???? Also even if it the null node is accounted for how is the mindepth 5 for this it should 3 if the null nodes are accounted for and 1 if they aren\\'t accounted for. Am I seeing this wrong or is this actually wrong. Someone please let me know!!![image](https://assets.leetcode.com/users/images/e132a50d-2ded-4656-a11a-2125b9545062_1613348516.5328968.png)\\n"
                    },
                    {
                        "username": "huttarl",
                        "content": "[@joelmathew2809](/joelmathew2809) Thank you. I didn\\'t know about this. Too bad you have to open a different panel to understand the examples given in the problem. But it\\'s better than nothing."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "FUN FACT !\nThe test case panel also renders the tree for you. This way you can clearly understand what this input means. The input here is pretty confusing but it is just for representation. "
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form"
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "[@user2244fP](/user2244fP) \\n\\nno no the null node is not accounted for ,  basically here the left node of every node in the given tree is null \\nbut there will exsist a right node , only number 6 has its left as well as right value as null \\n\\nso , this tree kinda looks like a linked list \\n2-> 3 -> 4 -> 5 -> 6 , hence depth of this will be five \\n\\n"
                    },
                    {
                        "username": "user2244fP",
                        "content": "So I wasn\\'t the only one who faced this."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Learn data structure. It\\'s quite standard. But pay attention to NULL"
                    },
                    {
                        "username": "sreejeet",
                        "content": "1. Why is 2 the answer for test case [1,2]?\\nA: Because the path has to contain *the root* and *a leaf node*. So the path on the right does not count, as it does not contain a leaf node.\\n\\n2. The depth definition is wrong!\\nA: Yes the definition seems wrong, the qustion is wrongly worded; they simply mean the number of nodes in the path to the nearest leaf node. Try to understand it this way: a tree with no root (no nodes) has no depth, therefore 0 depth. A tree with at least 1 node has 1 depth and so on."
                    },
                    {
                        "username": "DemonLeo",
                        "content": "where [1,2]`s  Minimum Depth is 2\\uFF1F"
                    },
                    {
                        "username": "Leetcode_Wat",
                        "content": "The question requires to count the \"number of nodes\" from root to its nearest leaf node. It contains 2 nodes in your given example."
                    },
                    {
                        "username": "luyao0604",
                        "content": "Many of the trees generated for the test cases are wrong. And why is the minDepth defined as distance to its nearest child without any children? Why is it NOT distance to its nearest null child? Doesn\\'t that make more sense?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "[@HapticBovine](/HapticBovine) Actually, it seems that the array representation is different, [2,null,3,null,4,null,5,null,6] is supposed to be a simple path from 2->6. The question is, what is this format, and how can we interpret it unambiguously?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I will explain why this is true then flag the above comment since we can't have nice things (ie., a feature to report incorrect Test Cases).\n\nThe depth of a (binary) Tree is the number of edges to the most distant leaf node. A minimum depth should be the number of edges to the closest leaf node.\n\nRe. Test Case 2:\n\nIf the values are given as array elements in the array [2,null,3,null,4,null,5,null,6], and the expected depth is 5, then we must have a tree with minimum depth/height of 5, meaning the path from the root to _every_ leaf must be >= 5, or in other words, the binary tree has a (min) height of 5, meaning there are 5 edges or 6 nodes in the shortest path from the root a the leaf. The smallest tree in which this could occur is a Perfect Binary Tree, in which there are 63 nodes (2^(h+1) - 1 nodes).\n\nHowever the input [2,null,3,null,4,null,5,null,6] only contains 9 nodes!\n\nWhat a PITA, this is a pretty good platform, can you please make (or improve if it exists) a feature to report incorrect test cases? I want a button similar to the \"submit test case\" button."
                    },
                    {
                        "username": "Ekut",
                        "content": "So I read online(stack overflow, wikipedia) that the depth of a node is the number of edges to the root node. How come in this question, the minimum depth is 2 when there is a leaf node that is only one edge away from the root (direct child). \\nI'm probably missing something. I would appreciate if someone could explain.\\nThanks!"
                    },
                    {
                        "username": "nishantv",
                        "content": "No you are not missing anything. The first example seems incorrect."
                    },
                    {
                        "username": "atulgupta002",
                        "content": "Exactly my question. The min depth is 1. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "In this problem the depth is considered the number of nodes present from the root to the leaf node"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "the first test case right? i got the same doubt"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Some tips: if root is null, return 0. Otherwise keep in mind that roots depth starts at 1, not 0.\nOnly check min depth for leaf nodes - meaning a node who has two NULL children. Some people make the mistake of updating min on every single node when they should only update it for leaf nodes.  \nIf you're doing it recursively, you can save runtime by adding in \"If (depth >= min){return;}\" that way you wont check deeper than you need to."
                    }
                ]
            },
            {
                "id": 1566120,
                "content": [
                    {
                        "username": "ewmiao",
                        "content": "I don\\'t know how to show this tree in a graph, and it\\'s hard to believe that its min depth is 5. However, my code fails on this test case. Anyone explains to me?\\n\\nExample 2:\\n\\nInput: root = [2,null,3,null,4,null,5,null,6]\\nOutput: 5"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "[@huttarl](/huttarl)  The second example shows a Binary tree that is \\'right skewed\\'. [2-3-4-5-6] 6 being the leaf node with min height 5."
                    },
                    {
                        "username": "huttarl",
                        "content": "[@ronitak33](/ronitak33) Unfortunately this would give a tree in which the nodes labeled \"4\" and \"6\" have no parents."
                    },
                    {
                        "username": "huttarl",
                        "content": "Unfortunately, the \"input\" in the test cases, an array of ints, is not the same as the parameter passed to minDepth(), which is the root node of a tree. And Leetcode doesn't seem to define how the format of the test case \"input\" translates into a tree. In another problem, it was stored like this: https://en.wikipedia.org/wiki/Binary_tree#Arrays, where node i is the parent of nodes 2i+1 and 2i+2. But in this case, that would mean the nodes with values \"4\" and \"6\" have null parents (which apparently means no parents). The data structure (in Kotlin at least) doesn't allow nodes with null values.\nWe could then guess that the array omits values for nodes whose parents don't exist. But we shouldn't have to *guess* about the meaning of the example input."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "We\\'re looking for the minimum depth of a binary tree from root to leaf. The keyword here is leaf. A leaf is a node that contains no children nodes. So 2 - 3 - 4 - 5 aren\\'t leafs, but 6 is. Once you get to 6 you have a depth of 5, and since that is the only leaf - 5 is what you return."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) Can please explain the logic behind this?"
                    },
                    {
                        "username": "deepti21aug",
                        "content": "[@mariam_meky](/mariam_meky)  I guess it should be 0."
                    },
                    {
                        "username": "mariam_meky",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) what does \"ans\" stand for?"
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": "bro this input is a skwe tree where probably your code is getting struck as node having one children the other children depth is considered 0 zero. try this solution\\n if(root== NULL){\\n            return ans;\\n        }\\n        int l=minDepth(root->left); \\n        int r=minDepth(root->right);\\n        if((l==0 && r==0) || (l!=0 && r!=0))\\n        return 1+min(l,r);\\n\\n        return  1+max(l,r);"
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form...this is like a linked list forming to the right."
                    },
                    {
                        "username": "mkohar",
                        "content": "you can paste above in testcase and leetcode will show you a visual representation of the graph"
                    },
                    {
                        "username": "ahmedelewa79",
                        "content": "the left child for any index will be ( 2*idx + 1)\\nand the right child will be (2*idx + 2)\\nand you can get the parent element for any child by Math.floor((idx-1)/2)"
                    },
                    {
                        "username": "Oliviaaa-EPFL",
                        "content": "This tree is actually a line (2->3->4->5->6). If your answer is 1, you are counting the node with only one child as the leave, so the recursion returns at the first node."
                    },
                    {
                        "username": "nik-1207",
                        "content": "please anyone can explain why the minimum height of the tree [2,null,3,null,4,null,5,null,6] is 5 not 1"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree\n2->3->4->5->6\nnon of these elements have a left child, only right child is available;\n2\n->3\n -->4\n ---->5\n  ----->6\nthis is the representation"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "because bro we see the leaf node which have both child null "
                    },
                    {
                        "username": "matthewmcconaha",
                        "content": "Let's define a \"leaf node\" as a node which does not have any children. So for a leaf node, left is null and right is also null.\nThen let's define the depth of any node as being the number of layers down the tree you have to travel in order to reach that node, starting at 1. So the very top of the tree is at depth 1, the next layer is depth 2, and so on.\nFinally, let's define the minimum depth as the tree as the leaf node with the minimum depth.\n\nIn the example you reference, the top node is not a leaf node. left is null, but right is not null. So the depth can't be 1. There is actually only one leaf node in that tree, and it is at depth 5.\n\nThe answer of 1 would be for the depth where you run into the first \"closed road\". The first time you see a path that you cannot take because the node in that direction is null. However, there is still an \"open road\" in the other direction, so you need to go down that other road. What you are looking for is a \"dead end\", when both possible roads are closed and you cannot go any deeper."
                    },
                    {
                        "username": "mattesko",
                        "content": "The depth of a tree starts at 0 and not at 1! A \\'tree\\' with only a root node and no children is a tree with depth 0, not 1 like the solution entails!\\n\\nhttps://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height"
                    },
                    {
                        "username": "huttarl",
                        "content": "It may be common to define the depth of a tree the way you do, but the description for this problem clearly defines the minimum depth as the number of **nodes** along the shortest path from root to nearest leaf."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Over the years I have seen mix of people: those who use height as in \"height of nodes\", and then \"height of edges\" which causes the 0/1 difference. It is better to clarify which ones is intended one."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Ultron03](/Ultron03) this question says that depth is the number of nodes whereas in the tree properties it said it would the number of edges"
                    },
                    {
                        "username": "Ultron03",
                        "content": "But in this question it is given that if only root node is there the  depth will be 1!!..\\n"
                    },
                    {
                        "username": "msu227",
                        "content": "I dont know if I am seeing this wrong but the example  [2,null,3,null,4,null,5,null,6] is a a bad test case. How doess a null node have a left and right node???? Also even if it the null node is accounted for how is the mindepth 5 for this it should 3 if the null nodes are accounted for and 1 if they aren\\'t accounted for. Am I seeing this wrong or is this actually wrong. Someone please let me know!!![image](https://assets.leetcode.com/users/images/e132a50d-2ded-4656-a11a-2125b9545062_1613348516.5328968.png)\\n"
                    },
                    {
                        "username": "huttarl",
                        "content": "[@joelmathew2809](/joelmathew2809) Thank you. I didn\\'t know about this. Too bad you have to open a different panel to understand the examples given in the problem. But it\\'s better than nothing."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "FUN FACT !\nThe test case panel also renders the tree for you. This way you can clearly understand what this input means. The input here is pretty confusing but it is just for representation. "
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form"
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "[@user2244fP](/user2244fP) \\n\\nno no the null node is not accounted for ,  basically here the left node of every node in the given tree is null \\nbut there will exsist a right node , only number 6 has its left as well as right value as null \\n\\nso , this tree kinda looks like a linked list \\n2-> 3 -> 4 -> 5 -> 6 , hence depth of this will be five \\n\\n"
                    },
                    {
                        "username": "user2244fP",
                        "content": "So I wasn\\'t the only one who faced this."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Learn data structure. It\\'s quite standard. But pay attention to NULL"
                    },
                    {
                        "username": "sreejeet",
                        "content": "1. Why is 2 the answer for test case [1,2]?\\nA: Because the path has to contain *the root* and *a leaf node*. So the path on the right does not count, as it does not contain a leaf node.\\n\\n2. The depth definition is wrong!\\nA: Yes the definition seems wrong, the qustion is wrongly worded; they simply mean the number of nodes in the path to the nearest leaf node. Try to understand it this way: a tree with no root (no nodes) has no depth, therefore 0 depth. A tree with at least 1 node has 1 depth and so on."
                    },
                    {
                        "username": "DemonLeo",
                        "content": "where [1,2]`s  Minimum Depth is 2\\uFF1F"
                    },
                    {
                        "username": "Leetcode_Wat",
                        "content": "The question requires to count the \"number of nodes\" from root to its nearest leaf node. It contains 2 nodes in your given example."
                    },
                    {
                        "username": "luyao0604",
                        "content": "Many of the trees generated for the test cases are wrong. And why is the minDepth defined as distance to its nearest child without any children? Why is it NOT distance to its nearest null child? Doesn\\'t that make more sense?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "[@HapticBovine](/HapticBovine) Actually, it seems that the array representation is different, [2,null,3,null,4,null,5,null,6] is supposed to be a simple path from 2->6. The question is, what is this format, and how can we interpret it unambiguously?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I will explain why this is true then flag the above comment since we can't have nice things (ie., a feature to report incorrect Test Cases).\n\nThe depth of a (binary) Tree is the number of edges to the most distant leaf node. A minimum depth should be the number of edges to the closest leaf node.\n\nRe. Test Case 2:\n\nIf the values are given as array elements in the array [2,null,3,null,4,null,5,null,6], and the expected depth is 5, then we must have a tree with minimum depth/height of 5, meaning the path from the root to _every_ leaf must be >= 5, or in other words, the binary tree has a (min) height of 5, meaning there are 5 edges or 6 nodes in the shortest path from the root a the leaf. The smallest tree in which this could occur is a Perfect Binary Tree, in which there are 63 nodes (2^(h+1) - 1 nodes).\n\nHowever the input [2,null,3,null,4,null,5,null,6] only contains 9 nodes!\n\nWhat a PITA, this is a pretty good platform, can you please make (or improve if it exists) a feature to report incorrect test cases? I want a button similar to the \"submit test case\" button."
                    },
                    {
                        "username": "Ekut",
                        "content": "So I read online(stack overflow, wikipedia) that the depth of a node is the number of edges to the root node. How come in this question, the minimum depth is 2 when there is a leaf node that is only one edge away from the root (direct child). \\nI'm probably missing something. I would appreciate if someone could explain.\\nThanks!"
                    },
                    {
                        "username": "nishantv",
                        "content": "No you are not missing anything. The first example seems incorrect."
                    },
                    {
                        "username": "atulgupta002",
                        "content": "Exactly my question. The min depth is 1. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "In this problem the depth is considered the number of nodes present from the root to the leaf node"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "the first test case right? i got the same doubt"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Some tips: if root is null, return 0. Otherwise keep in mind that roots depth starts at 1, not 0.\nOnly check min depth for leaf nodes - meaning a node who has two NULL children. Some people make the mistake of updating min on every single node when they should only update it for leaf nodes.  \nIf you're doing it recursively, you can save runtime by adding in \"If (depth >= min){return;}\" that way you wont check deeper than you need to."
                    }
                ]
            },
            {
                "id": 1568084,
                "content": [
                    {
                        "username": "ewmiao",
                        "content": "I don\\'t know how to show this tree in a graph, and it\\'s hard to believe that its min depth is 5. However, my code fails on this test case. Anyone explains to me?\\n\\nExample 2:\\n\\nInput: root = [2,null,3,null,4,null,5,null,6]\\nOutput: 5"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "[@huttarl](/huttarl)  The second example shows a Binary tree that is \\'right skewed\\'. [2-3-4-5-6] 6 being the leaf node with min height 5."
                    },
                    {
                        "username": "huttarl",
                        "content": "[@ronitak33](/ronitak33) Unfortunately this would give a tree in which the nodes labeled \"4\" and \"6\" have no parents."
                    },
                    {
                        "username": "huttarl",
                        "content": "Unfortunately, the \"input\" in the test cases, an array of ints, is not the same as the parameter passed to minDepth(), which is the root node of a tree. And Leetcode doesn't seem to define how the format of the test case \"input\" translates into a tree. In another problem, it was stored like this: https://en.wikipedia.org/wiki/Binary_tree#Arrays, where node i is the parent of nodes 2i+1 and 2i+2. But in this case, that would mean the nodes with values \"4\" and \"6\" have null parents (which apparently means no parents). The data structure (in Kotlin at least) doesn't allow nodes with null values.\nWe could then guess that the array omits values for nodes whose parents don't exist. But we shouldn't have to *guess* about the meaning of the example input."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "We\\'re looking for the minimum depth of a binary tree from root to leaf. The keyword here is leaf. A leaf is a node that contains no children nodes. So 2 - 3 - 4 - 5 aren\\'t leafs, but 6 is. Once you get to 6 you have a depth of 5, and since that is the only leaf - 5 is what you return."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) Can please explain the logic behind this?"
                    },
                    {
                        "username": "deepti21aug",
                        "content": "[@mariam_meky](/mariam_meky)  I guess it should be 0."
                    },
                    {
                        "username": "mariam_meky",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) what does \"ans\" stand for?"
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": "bro this input is a skwe tree where probably your code is getting struck as node having one children the other children depth is considered 0 zero. try this solution\\n if(root== NULL){\\n            return ans;\\n        }\\n        int l=minDepth(root->left); \\n        int r=minDepth(root->right);\\n        if((l==0 && r==0) || (l!=0 && r!=0))\\n        return 1+min(l,r);\\n\\n        return  1+max(l,r);"
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form...this is like a linked list forming to the right."
                    },
                    {
                        "username": "mkohar",
                        "content": "you can paste above in testcase and leetcode will show you a visual representation of the graph"
                    },
                    {
                        "username": "ahmedelewa79",
                        "content": "the left child for any index will be ( 2*idx + 1)\\nand the right child will be (2*idx + 2)\\nand you can get the parent element for any child by Math.floor((idx-1)/2)"
                    },
                    {
                        "username": "Oliviaaa-EPFL",
                        "content": "This tree is actually a line (2->3->4->5->6). If your answer is 1, you are counting the node with only one child as the leave, so the recursion returns at the first node."
                    },
                    {
                        "username": "nik-1207",
                        "content": "please anyone can explain why the minimum height of the tree [2,null,3,null,4,null,5,null,6] is 5 not 1"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree\n2->3->4->5->6\nnon of these elements have a left child, only right child is available;\n2\n->3\n -->4\n ---->5\n  ----->6\nthis is the representation"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "because bro we see the leaf node which have both child null "
                    },
                    {
                        "username": "matthewmcconaha",
                        "content": "Let's define a \"leaf node\" as a node which does not have any children. So for a leaf node, left is null and right is also null.\nThen let's define the depth of any node as being the number of layers down the tree you have to travel in order to reach that node, starting at 1. So the very top of the tree is at depth 1, the next layer is depth 2, and so on.\nFinally, let's define the minimum depth as the tree as the leaf node with the minimum depth.\n\nIn the example you reference, the top node is not a leaf node. left is null, but right is not null. So the depth can't be 1. There is actually only one leaf node in that tree, and it is at depth 5.\n\nThe answer of 1 would be for the depth where you run into the first \"closed road\". The first time you see a path that you cannot take because the node in that direction is null. However, there is still an \"open road\" in the other direction, so you need to go down that other road. What you are looking for is a \"dead end\", when both possible roads are closed and you cannot go any deeper."
                    },
                    {
                        "username": "mattesko",
                        "content": "The depth of a tree starts at 0 and not at 1! A \\'tree\\' with only a root node and no children is a tree with depth 0, not 1 like the solution entails!\\n\\nhttps://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height"
                    },
                    {
                        "username": "huttarl",
                        "content": "It may be common to define the depth of a tree the way you do, but the description for this problem clearly defines the minimum depth as the number of **nodes** along the shortest path from root to nearest leaf."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Over the years I have seen mix of people: those who use height as in \"height of nodes\", and then \"height of edges\" which causes the 0/1 difference. It is better to clarify which ones is intended one."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Ultron03](/Ultron03) this question says that depth is the number of nodes whereas in the tree properties it said it would the number of edges"
                    },
                    {
                        "username": "Ultron03",
                        "content": "But in this question it is given that if only root node is there the  depth will be 1!!..\\n"
                    },
                    {
                        "username": "msu227",
                        "content": "I dont know if I am seeing this wrong but the example  [2,null,3,null,4,null,5,null,6] is a a bad test case. How doess a null node have a left and right node???? Also even if it the null node is accounted for how is the mindepth 5 for this it should 3 if the null nodes are accounted for and 1 if they aren\\'t accounted for. Am I seeing this wrong or is this actually wrong. Someone please let me know!!![image](https://assets.leetcode.com/users/images/e132a50d-2ded-4656-a11a-2125b9545062_1613348516.5328968.png)\\n"
                    },
                    {
                        "username": "huttarl",
                        "content": "[@joelmathew2809](/joelmathew2809) Thank you. I didn\\'t know about this. Too bad you have to open a different panel to understand the examples given in the problem. But it\\'s better than nothing."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "FUN FACT !\nThe test case panel also renders the tree for you. This way you can clearly understand what this input means. The input here is pretty confusing but it is just for representation. "
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form"
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "[@user2244fP](/user2244fP) \\n\\nno no the null node is not accounted for ,  basically here the left node of every node in the given tree is null \\nbut there will exsist a right node , only number 6 has its left as well as right value as null \\n\\nso , this tree kinda looks like a linked list \\n2-> 3 -> 4 -> 5 -> 6 , hence depth of this will be five \\n\\n"
                    },
                    {
                        "username": "user2244fP",
                        "content": "So I wasn\\'t the only one who faced this."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Learn data structure. It\\'s quite standard. But pay attention to NULL"
                    },
                    {
                        "username": "sreejeet",
                        "content": "1. Why is 2 the answer for test case [1,2]?\\nA: Because the path has to contain *the root* and *a leaf node*. So the path on the right does not count, as it does not contain a leaf node.\\n\\n2. The depth definition is wrong!\\nA: Yes the definition seems wrong, the qustion is wrongly worded; they simply mean the number of nodes in the path to the nearest leaf node. Try to understand it this way: a tree with no root (no nodes) has no depth, therefore 0 depth. A tree with at least 1 node has 1 depth and so on."
                    },
                    {
                        "username": "DemonLeo",
                        "content": "where [1,2]`s  Minimum Depth is 2\\uFF1F"
                    },
                    {
                        "username": "Leetcode_Wat",
                        "content": "The question requires to count the \"number of nodes\" from root to its nearest leaf node. It contains 2 nodes in your given example."
                    },
                    {
                        "username": "luyao0604",
                        "content": "Many of the trees generated for the test cases are wrong. And why is the minDepth defined as distance to its nearest child without any children? Why is it NOT distance to its nearest null child? Doesn\\'t that make more sense?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "[@HapticBovine](/HapticBovine) Actually, it seems that the array representation is different, [2,null,3,null,4,null,5,null,6] is supposed to be a simple path from 2->6. The question is, what is this format, and how can we interpret it unambiguously?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I will explain why this is true then flag the above comment since we can't have nice things (ie., a feature to report incorrect Test Cases).\n\nThe depth of a (binary) Tree is the number of edges to the most distant leaf node. A minimum depth should be the number of edges to the closest leaf node.\n\nRe. Test Case 2:\n\nIf the values are given as array elements in the array [2,null,3,null,4,null,5,null,6], and the expected depth is 5, then we must have a tree with minimum depth/height of 5, meaning the path from the root to _every_ leaf must be >= 5, or in other words, the binary tree has a (min) height of 5, meaning there are 5 edges or 6 nodes in the shortest path from the root a the leaf. The smallest tree in which this could occur is a Perfect Binary Tree, in which there are 63 nodes (2^(h+1) - 1 nodes).\n\nHowever the input [2,null,3,null,4,null,5,null,6] only contains 9 nodes!\n\nWhat a PITA, this is a pretty good platform, can you please make (or improve if it exists) a feature to report incorrect test cases? I want a button similar to the \"submit test case\" button."
                    },
                    {
                        "username": "Ekut",
                        "content": "So I read online(stack overflow, wikipedia) that the depth of a node is the number of edges to the root node. How come in this question, the minimum depth is 2 when there is a leaf node that is only one edge away from the root (direct child). \\nI'm probably missing something. I would appreciate if someone could explain.\\nThanks!"
                    },
                    {
                        "username": "nishantv",
                        "content": "No you are not missing anything. The first example seems incorrect."
                    },
                    {
                        "username": "atulgupta002",
                        "content": "Exactly my question. The min depth is 1. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "In this problem the depth is considered the number of nodes present from the root to the leaf node"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "the first test case right? i got the same doubt"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Some tips: if root is null, return 0. Otherwise keep in mind that roots depth starts at 1, not 0.\nOnly check min depth for leaf nodes - meaning a node who has two NULL children. Some people make the mistake of updating min on every single node when they should only update it for leaf nodes.  \nIf you're doing it recursively, you can save runtime by adding in \"If (depth >= min){return;}\" that way you wont check deeper than you need to."
                    }
                ]
            },
            {
                "id": 1567859,
                "content": [
                    {
                        "username": "ewmiao",
                        "content": "I don\\'t know how to show this tree in a graph, and it\\'s hard to believe that its min depth is 5. However, my code fails on this test case. Anyone explains to me?\\n\\nExample 2:\\n\\nInput: root = [2,null,3,null,4,null,5,null,6]\\nOutput: 5"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "[@huttarl](/huttarl)  The second example shows a Binary tree that is \\'right skewed\\'. [2-3-4-5-6] 6 being the leaf node with min height 5."
                    },
                    {
                        "username": "huttarl",
                        "content": "[@ronitak33](/ronitak33) Unfortunately this would give a tree in which the nodes labeled \"4\" and \"6\" have no parents."
                    },
                    {
                        "username": "huttarl",
                        "content": "Unfortunately, the \"input\" in the test cases, an array of ints, is not the same as the parameter passed to minDepth(), which is the root node of a tree. And Leetcode doesn't seem to define how the format of the test case \"input\" translates into a tree. In another problem, it was stored like this: https://en.wikipedia.org/wiki/Binary_tree#Arrays, where node i is the parent of nodes 2i+1 and 2i+2. But in this case, that would mean the nodes with values \"4\" and \"6\" have null parents (which apparently means no parents). The data structure (in Kotlin at least) doesn't allow nodes with null values.\nWe could then guess that the array omits values for nodes whose parents don't exist. But we shouldn't have to *guess* about the meaning of the example input."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "We\\'re looking for the minimum depth of a binary tree from root to leaf. The keyword here is leaf. A leaf is a node that contains no children nodes. So 2 - 3 - 4 - 5 aren\\'t leafs, but 6 is. Once you get to 6 you have a depth of 5, and since that is the only leaf - 5 is what you return."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) Can please explain the logic behind this?"
                    },
                    {
                        "username": "deepti21aug",
                        "content": "[@mariam_meky](/mariam_meky)  I guess it should be 0."
                    },
                    {
                        "username": "mariam_meky",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) what does \"ans\" stand for?"
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": "bro this input is a skwe tree where probably your code is getting struck as node having one children the other children depth is considered 0 zero. try this solution\\n if(root== NULL){\\n            return ans;\\n        }\\n        int l=minDepth(root->left); \\n        int r=minDepth(root->right);\\n        if((l==0 && r==0) || (l!=0 && r!=0))\\n        return 1+min(l,r);\\n\\n        return  1+max(l,r);"
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form...this is like a linked list forming to the right."
                    },
                    {
                        "username": "mkohar",
                        "content": "you can paste above in testcase and leetcode will show you a visual representation of the graph"
                    },
                    {
                        "username": "ahmedelewa79",
                        "content": "the left child for any index will be ( 2*idx + 1)\\nand the right child will be (2*idx + 2)\\nand you can get the parent element for any child by Math.floor((idx-1)/2)"
                    },
                    {
                        "username": "Oliviaaa-EPFL",
                        "content": "This tree is actually a line (2->3->4->5->6). If your answer is 1, you are counting the node with only one child as the leave, so the recursion returns at the first node."
                    },
                    {
                        "username": "nik-1207",
                        "content": "please anyone can explain why the minimum height of the tree [2,null,3,null,4,null,5,null,6] is 5 not 1"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree\n2->3->4->5->6\nnon of these elements have a left child, only right child is available;\n2\n->3\n -->4\n ---->5\n  ----->6\nthis is the representation"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "because bro we see the leaf node which have both child null "
                    },
                    {
                        "username": "matthewmcconaha",
                        "content": "Let's define a \"leaf node\" as a node which does not have any children. So for a leaf node, left is null and right is also null.\nThen let's define the depth of any node as being the number of layers down the tree you have to travel in order to reach that node, starting at 1. So the very top of the tree is at depth 1, the next layer is depth 2, and so on.\nFinally, let's define the minimum depth as the tree as the leaf node with the minimum depth.\n\nIn the example you reference, the top node is not a leaf node. left is null, but right is not null. So the depth can't be 1. There is actually only one leaf node in that tree, and it is at depth 5.\n\nThe answer of 1 would be for the depth where you run into the first \"closed road\". The first time you see a path that you cannot take because the node in that direction is null. However, there is still an \"open road\" in the other direction, so you need to go down that other road. What you are looking for is a \"dead end\", when both possible roads are closed and you cannot go any deeper."
                    },
                    {
                        "username": "mattesko",
                        "content": "The depth of a tree starts at 0 and not at 1! A \\'tree\\' with only a root node and no children is a tree with depth 0, not 1 like the solution entails!\\n\\nhttps://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height"
                    },
                    {
                        "username": "huttarl",
                        "content": "It may be common to define the depth of a tree the way you do, but the description for this problem clearly defines the minimum depth as the number of **nodes** along the shortest path from root to nearest leaf."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Over the years I have seen mix of people: those who use height as in \"height of nodes\", and then \"height of edges\" which causes the 0/1 difference. It is better to clarify which ones is intended one."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Ultron03](/Ultron03) this question says that depth is the number of nodes whereas in the tree properties it said it would the number of edges"
                    },
                    {
                        "username": "Ultron03",
                        "content": "But in this question it is given that if only root node is there the  depth will be 1!!..\\n"
                    },
                    {
                        "username": "msu227",
                        "content": "I dont know if I am seeing this wrong but the example  [2,null,3,null,4,null,5,null,6] is a a bad test case. How doess a null node have a left and right node???? Also even if it the null node is accounted for how is the mindepth 5 for this it should 3 if the null nodes are accounted for and 1 if they aren\\'t accounted for. Am I seeing this wrong or is this actually wrong. Someone please let me know!!![image](https://assets.leetcode.com/users/images/e132a50d-2ded-4656-a11a-2125b9545062_1613348516.5328968.png)\\n"
                    },
                    {
                        "username": "huttarl",
                        "content": "[@joelmathew2809](/joelmathew2809) Thank you. I didn\\'t know about this. Too bad you have to open a different panel to understand the examples given in the problem. But it\\'s better than nothing."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "FUN FACT !\nThe test case panel also renders the tree for you. This way you can clearly understand what this input means. The input here is pretty confusing but it is just for representation. "
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form"
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "[@user2244fP](/user2244fP) \\n\\nno no the null node is not accounted for ,  basically here the left node of every node in the given tree is null \\nbut there will exsist a right node , only number 6 has its left as well as right value as null \\n\\nso , this tree kinda looks like a linked list \\n2-> 3 -> 4 -> 5 -> 6 , hence depth of this will be five \\n\\n"
                    },
                    {
                        "username": "user2244fP",
                        "content": "So I wasn\\'t the only one who faced this."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Learn data structure. It\\'s quite standard. But pay attention to NULL"
                    },
                    {
                        "username": "sreejeet",
                        "content": "1. Why is 2 the answer for test case [1,2]?\\nA: Because the path has to contain *the root* and *a leaf node*. So the path on the right does not count, as it does not contain a leaf node.\\n\\n2. The depth definition is wrong!\\nA: Yes the definition seems wrong, the qustion is wrongly worded; they simply mean the number of nodes in the path to the nearest leaf node. Try to understand it this way: a tree with no root (no nodes) has no depth, therefore 0 depth. A tree with at least 1 node has 1 depth and so on."
                    },
                    {
                        "username": "DemonLeo",
                        "content": "where [1,2]`s  Minimum Depth is 2\\uFF1F"
                    },
                    {
                        "username": "Leetcode_Wat",
                        "content": "The question requires to count the \"number of nodes\" from root to its nearest leaf node. It contains 2 nodes in your given example."
                    },
                    {
                        "username": "luyao0604",
                        "content": "Many of the trees generated for the test cases are wrong. And why is the minDepth defined as distance to its nearest child without any children? Why is it NOT distance to its nearest null child? Doesn\\'t that make more sense?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "[@HapticBovine](/HapticBovine) Actually, it seems that the array representation is different, [2,null,3,null,4,null,5,null,6] is supposed to be a simple path from 2->6. The question is, what is this format, and how can we interpret it unambiguously?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I will explain why this is true then flag the above comment since we can't have nice things (ie., a feature to report incorrect Test Cases).\n\nThe depth of a (binary) Tree is the number of edges to the most distant leaf node. A minimum depth should be the number of edges to the closest leaf node.\n\nRe. Test Case 2:\n\nIf the values are given as array elements in the array [2,null,3,null,4,null,5,null,6], and the expected depth is 5, then we must have a tree with minimum depth/height of 5, meaning the path from the root to _every_ leaf must be >= 5, or in other words, the binary tree has a (min) height of 5, meaning there are 5 edges or 6 nodes in the shortest path from the root a the leaf. The smallest tree in which this could occur is a Perfect Binary Tree, in which there are 63 nodes (2^(h+1) - 1 nodes).\n\nHowever the input [2,null,3,null,4,null,5,null,6] only contains 9 nodes!\n\nWhat a PITA, this is a pretty good platform, can you please make (or improve if it exists) a feature to report incorrect test cases? I want a button similar to the \"submit test case\" button."
                    },
                    {
                        "username": "Ekut",
                        "content": "So I read online(stack overflow, wikipedia) that the depth of a node is the number of edges to the root node. How come in this question, the minimum depth is 2 when there is a leaf node that is only one edge away from the root (direct child). \\nI'm probably missing something. I would appreciate if someone could explain.\\nThanks!"
                    },
                    {
                        "username": "nishantv",
                        "content": "No you are not missing anything. The first example seems incorrect."
                    },
                    {
                        "username": "atulgupta002",
                        "content": "Exactly my question. The min depth is 1. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "In this problem the depth is considered the number of nodes present from the root to the leaf node"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "the first test case right? i got the same doubt"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Some tips: if root is null, return 0. Otherwise keep in mind that roots depth starts at 1, not 0.\nOnly check min depth for leaf nodes - meaning a node who has two NULL children. Some people make the mistake of updating min on every single node when they should only update it for leaf nodes.  \nIf you're doing it recursively, you can save runtime by adding in \"If (depth >= min){return;}\" that way you wont check deeper than you need to."
                    }
                ]
            },
            {
                "id": 1963683,
                "content": [
                    {
                        "username": "ewmiao",
                        "content": "I don\\'t know how to show this tree in a graph, and it\\'s hard to believe that its min depth is 5. However, my code fails on this test case. Anyone explains to me?\\n\\nExample 2:\\n\\nInput: root = [2,null,3,null,4,null,5,null,6]\\nOutput: 5"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "[@huttarl](/huttarl)  The second example shows a Binary tree that is \\'right skewed\\'. [2-3-4-5-6] 6 being the leaf node with min height 5."
                    },
                    {
                        "username": "huttarl",
                        "content": "[@ronitak33](/ronitak33) Unfortunately this would give a tree in which the nodes labeled \"4\" and \"6\" have no parents."
                    },
                    {
                        "username": "huttarl",
                        "content": "Unfortunately, the \"input\" in the test cases, an array of ints, is not the same as the parameter passed to minDepth(), which is the root node of a tree. And Leetcode doesn't seem to define how the format of the test case \"input\" translates into a tree. In another problem, it was stored like this: https://en.wikipedia.org/wiki/Binary_tree#Arrays, where node i is the parent of nodes 2i+1 and 2i+2. But in this case, that would mean the nodes with values \"4\" and \"6\" have null parents (which apparently means no parents). The data structure (in Kotlin at least) doesn't allow nodes with null values.\nWe could then guess that the array omits values for nodes whose parents don't exist. But we shouldn't have to *guess* about the meaning of the example input."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "We\\'re looking for the minimum depth of a binary tree from root to leaf. The keyword here is leaf. A leaf is a node that contains no children nodes. So 2 - 3 - 4 - 5 aren\\'t leafs, but 6 is. Once you get to 6 you have a depth of 5, and since that is the only leaf - 5 is what you return."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) Can please explain the logic behind this?"
                    },
                    {
                        "username": "deepti21aug",
                        "content": "[@mariam_meky](/mariam_meky)  I guess it should be 0."
                    },
                    {
                        "username": "mariam_meky",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) what does \"ans\" stand for?"
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": "bro this input is a skwe tree where probably your code is getting struck as node having one children the other children depth is considered 0 zero. try this solution\\n if(root== NULL){\\n            return ans;\\n        }\\n        int l=minDepth(root->left); \\n        int r=minDepth(root->right);\\n        if((l==0 && r==0) || (l!=0 && r!=0))\\n        return 1+min(l,r);\\n\\n        return  1+max(l,r);"
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form...this is like a linked list forming to the right."
                    },
                    {
                        "username": "mkohar",
                        "content": "you can paste above in testcase and leetcode will show you a visual representation of the graph"
                    },
                    {
                        "username": "ahmedelewa79",
                        "content": "the left child for any index will be ( 2*idx + 1)\\nand the right child will be (2*idx + 2)\\nand you can get the parent element for any child by Math.floor((idx-1)/2)"
                    },
                    {
                        "username": "Oliviaaa-EPFL",
                        "content": "This tree is actually a line (2->3->4->5->6). If your answer is 1, you are counting the node with only one child as the leave, so the recursion returns at the first node."
                    },
                    {
                        "username": "nik-1207",
                        "content": "please anyone can explain why the minimum height of the tree [2,null,3,null,4,null,5,null,6] is 5 not 1"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree\n2->3->4->5->6\nnon of these elements have a left child, only right child is available;\n2\n->3\n -->4\n ---->5\n  ----->6\nthis is the representation"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "because bro we see the leaf node which have both child null "
                    },
                    {
                        "username": "matthewmcconaha",
                        "content": "Let's define a \"leaf node\" as a node which does not have any children. So for a leaf node, left is null and right is also null.\nThen let's define the depth of any node as being the number of layers down the tree you have to travel in order to reach that node, starting at 1. So the very top of the tree is at depth 1, the next layer is depth 2, and so on.\nFinally, let's define the minimum depth as the tree as the leaf node with the minimum depth.\n\nIn the example you reference, the top node is not a leaf node. left is null, but right is not null. So the depth can't be 1. There is actually only one leaf node in that tree, and it is at depth 5.\n\nThe answer of 1 would be for the depth where you run into the first \"closed road\". The first time you see a path that you cannot take because the node in that direction is null. However, there is still an \"open road\" in the other direction, so you need to go down that other road. What you are looking for is a \"dead end\", when both possible roads are closed and you cannot go any deeper."
                    },
                    {
                        "username": "mattesko",
                        "content": "The depth of a tree starts at 0 and not at 1! A \\'tree\\' with only a root node and no children is a tree with depth 0, not 1 like the solution entails!\\n\\nhttps://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height"
                    },
                    {
                        "username": "huttarl",
                        "content": "It may be common to define the depth of a tree the way you do, but the description for this problem clearly defines the minimum depth as the number of **nodes** along the shortest path from root to nearest leaf."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Over the years I have seen mix of people: those who use height as in \"height of nodes\", and then \"height of edges\" which causes the 0/1 difference. It is better to clarify which ones is intended one."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Ultron03](/Ultron03) this question says that depth is the number of nodes whereas in the tree properties it said it would the number of edges"
                    },
                    {
                        "username": "Ultron03",
                        "content": "But in this question it is given that if only root node is there the  depth will be 1!!..\\n"
                    },
                    {
                        "username": "msu227",
                        "content": "I dont know if I am seeing this wrong but the example  [2,null,3,null,4,null,5,null,6] is a a bad test case. How doess a null node have a left and right node???? Also even if it the null node is accounted for how is the mindepth 5 for this it should 3 if the null nodes are accounted for and 1 if they aren\\'t accounted for. Am I seeing this wrong or is this actually wrong. Someone please let me know!!![image](https://assets.leetcode.com/users/images/e132a50d-2ded-4656-a11a-2125b9545062_1613348516.5328968.png)\\n"
                    },
                    {
                        "username": "huttarl",
                        "content": "[@joelmathew2809](/joelmathew2809) Thank you. I didn\\'t know about this. Too bad you have to open a different panel to understand the examples given in the problem. But it\\'s better than nothing."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "FUN FACT !\nThe test case panel also renders the tree for you. This way you can clearly understand what this input means. The input here is pretty confusing but it is just for representation. "
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form"
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "[@user2244fP](/user2244fP) \\n\\nno no the null node is not accounted for ,  basically here the left node of every node in the given tree is null \\nbut there will exsist a right node , only number 6 has its left as well as right value as null \\n\\nso , this tree kinda looks like a linked list \\n2-> 3 -> 4 -> 5 -> 6 , hence depth of this will be five \\n\\n"
                    },
                    {
                        "username": "user2244fP",
                        "content": "So I wasn\\'t the only one who faced this."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Learn data structure. It\\'s quite standard. But pay attention to NULL"
                    },
                    {
                        "username": "sreejeet",
                        "content": "1. Why is 2 the answer for test case [1,2]?\\nA: Because the path has to contain *the root* and *a leaf node*. So the path on the right does not count, as it does not contain a leaf node.\\n\\n2. The depth definition is wrong!\\nA: Yes the definition seems wrong, the qustion is wrongly worded; they simply mean the number of nodes in the path to the nearest leaf node. Try to understand it this way: a tree with no root (no nodes) has no depth, therefore 0 depth. A tree with at least 1 node has 1 depth and so on."
                    },
                    {
                        "username": "DemonLeo",
                        "content": "where [1,2]`s  Minimum Depth is 2\\uFF1F"
                    },
                    {
                        "username": "Leetcode_Wat",
                        "content": "The question requires to count the \"number of nodes\" from root to its nearest leaf node. It contains 2 nodes in your given example."
                    },
                    {
                        "username": "luyao0604",
                        "content": "Many of the trees generated for the test cases are wrong. And why is the minDepth defined as distance to its nearest child without any children? Why is it NOT distance to its nearest null child? Doesn\\'t that make more sense?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "[@HapticBovine](/HapticBovine) Actually, it seems that the array representation is different, [2,null,3,null,4,null,5,null,6] is supposed to be a simple path from 2->6. The question is, what is this format, and how can we interpret it unambiguously?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I will explain why this is true then flag the above comment since we can't have nice things (ie., a feature to report incorrect Test Cases).\n\nThe depth of a (binary) Tree is the number of edges to the most distant leaf node. A minimum depth should be the number of edges to the closest leaf node.\n\nRe. Test Case 2:\n\nIf the values are given as array elements in the array [2,null,3,null,4,null,5,null,6], and the expected depth is 5, then we must have a tree with minimum depth/height of 5, meaning the path from the root to _every_ leaf must be >= 5, or in other words, the binary tree has a (min) height of 5, meaning there are 5 edges or 6 nodes in the shortest path from the root a the leaf. The smallest tree in which this could occur is a Perfect Binary Tree, in which there are 63 nodes (2^(h+1) - 1 nodes).\n\nHowever the input [2,null,3,null,4,null,5,null,6] only contains 9 nodes!\n\nWhat a PITA, this is a pretty good platform, can you please make (or improve if it exists) a feature to report incorrect test cases? I want a button similar to the \"submit test case\" button."
                    },
                    {
                        "username": "Ekut",
                        "content": "So I read online(stack overflow, wikipedia) that the depth of a node is the number of edges to the root node. How come in this question, the minimum depth is 2 when there is a leaf node that is only one edge away from the root (direct child). \\nI'm probably missing something. I would appreciate if someone could explain.\\nThanks!"
                    },
                    {
                        "username": "nishantv",
                        "content": "No you are not missing anything. The first example seems incorrect."
                    },
                    {
                        "username": "atulgupta002",
                        "content": "Exactly my question. The min depth is 1. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "In this problem the depth is considered the number of nodes present from the root to the leaf node"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "the first test case right? i got the same doubt"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Some tips: if root is null, return 0. Otherwise keep in mind that roots depth starts at 1, not 0.\nOnly check min depth for leaf nodes - meaning a node who has two NULL children. Some people make the mistake of updating min on every single node when they should only update it for leaf nodes.  \nIf you're doing it recursively, you can save runtime by adding in \"If (depth >= min){return;}\" that way you wont check deeper than you need to."
                    }
                ]
            },
            {
                "id": 1576459,
                "content": [
                    {
                        "username": "ewmiao",
                        "content": "I don\\'t know how to show this tree in a graph, and it\\'s hard to believe that its min depth is 5. However, my code fails on this test case. Anyone explains to me?\\n\\nExample 2:\\n\\nInput: root = [2,null,3,null,4,null,5,null,6]\\nOutput: 5"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "[@huttarl](/huttarl)  The second example shows a Binary tree that is \\'right skewed\\'. [2-3-4-5-6] 6 being the leaf node with min height 5."
                    },
                    {
                        "username": "huttarl",
                        "content": "[@ronitak33](/ronitak33) Unfortunately this would give a tree in which the nodes labeled \"4\" and \"6\" have no parents."
                    },
                    {
                        "username": "huttarl",
                        "content": "Unfortunately, the \"input\" in the test cases, an array of ints, is not the same as the parameter passed to minDepth(), which is the root node of a tree. And Leetcode doesn't seem to define how the format of the test case \"input\" translates into a tree. In another problem, it was stored like this: https://en.wikipedia.org/wiki/Binary_tree#Arrays, where node i is the parent of nodes 2i+1 and 2i+2. But in this case, that would mean the nodes with values \"4\" and \"6\" have null parents (which apparently means no parents). The data structure (in Kotlin at least) doesn't allow nodes with null values.\nWe could then guess that the array omits values for nodes whose parents don't exist. But we shouldn't have to *guess* about the meaning of the example input."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "We\\'re looking for the minimum depth of a binary tree from root to leaf. The keyword here is leaf. A leaf is a node that contains no children nodes. So 2 - 3 - 4 - 5 aren\\'t leafs, but 6 is. Once you get to 6 you have a depth of 5, and since that is the only leaf - 5 is what you return."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) Can please explain the logic behind this?"
                    },
                    {
                        "username": "deepti21aug",
                        "content": "[@mariam_meky](/mariam_meky)  I guess it should be 0."
                    },
                    {
                        "username": "mariam_meky",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) what does \"ans\" stand for?"
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": "bro this input is a skwe tree where probably your code is getting struck as node having one children the other children depth is considered 0 zero. try this solution\\n if(root== NULL){\\n            return ans;\\n        }\\n        int l=minDepth(root->left); \\n        int r=minDepth(root->right);\\n        if((l==0 && r==0) || (l!=0 && r!=0))\\n        return 1+min(l,r);\\n\\n        return  1+max(l,r);"
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form...this is like a linked list forming to the right."
                    },
                    {
                        "username": "mkohar",
                        "content": "you can paste above in testcase and leetcode will show you a visual representation of the graph"
                    },
                    {
                        "username": "ahmedelewa79",
                        "content": "the left child for any index will be ( 2*idx + 1)\\nand the right child will be (2*idx + 2)\\nand you can get the parent element for any child by Math.floor((idx-1)/2)"
                    },
                    {
                        "username": "Oliviaaa-EPFL",
                        "content": "This tree is actually a line (2->3->4->5->6). If your answer is 1, you are counting the node with only one child as the leave, so the recursion returns at the first node."
                    },
                    {
                        "username": "nik-1207",
                        "content": "please anyone can explain why the minimum height of the tree [2,null,3,null,4,null,5,null,6] is 5 not 1"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree\n2->3->4->5->6\nnon of these elements have a left child, only right child is available;\n2\n->3\n -->4\n ---->5\n  ----->6\nthis is the representation"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "because bro we see the leaf node which have both child null "
                    },
                    {
                        "username": "matthewmcconaha",
                        "content": "Let's define a \"leaf node\" as a node which does not have any children. So for a leaf node, left is null and right is also null.\nThen let's define the depth of any node as being the number of layers down the tree you have to travel in order to reach that node, starting at 1. So the very top of the tree is at depth 1, the next layer is depth 2, and so on.\nFinally, let's define the minimum depth as the tree as the leaf node with the minimum depth.\n\nIn the example you reference, the top node is not a leaf node. left is null, but right is not null. So the depth can't be 1. There is actually only one leaf node in that tree, and it is at depth 5.\n\nThe answer of 1 would be for the depth where you run into the first \"closed road\". The first time you see a path that you cannot take because the node in that direction is null. However, there is still an \"open road\" in the other direction, so you need to go down that other road. What you are looking for is a \"dead end\", when both possible roads are closed and you cannot go any deeper."
                    },
                    {
                        "username": "mattesko",
                        "content": "The depth of a tree starts at 0 and not at 1! A \\'tree\\' with only a root node and no children is a tree with depth 0, not 1 like the solution entails!\\n\\nhttps://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height"
                    },
                    {
                        "username": "huttarl",
                        "content": "It may be common to define the depth of a tree the way you do, but the description for this problem clearly defines the minimum depth as the number of **nodes** along the shortest path from root to nearest leaf."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Over the years I have seen mix of people: those who use height as in \"height of nodes\", and then \"height of edges\" which causes the 0/1 difference. It is better to clarify which ones is intended one."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Ultron03](/Ultron03) this question says that depth is the number of nodes whereas in the tree properties it said it would the number of edges"
                    },
                    {
                        "username": "Ultron03",
                        "content": "But in this question it is given that if only root node is there the  depth will be 1!!..\\n"
                    },
                    {
                        "username": "msu227",
                        "content": "I dont know if I am seeing this wrong but the example  [2,null,3,null,4,null,5,null,6] is a a bad test case. How doess a null node have a left and right node???? Also even if it the null node is accounted for how is the mindepth 5 for this it should 3 if the null nodes are accounted for and 1 if they aren\\'t accounted for. Am I seeing this wrong or is this actually wrong. Someone please let me know!!![image](https://assets.leetcode.com/users/images/e132a50d-2ded-4656-a11a-2125b9545062_1613348516.5328968.png)\\n"
                    },
                    {
                        "username": "huttarl",
                        "content": "[@joelmathew2809](/joelmathew2809) Thank you. I didn\\'t know about this. Too bad you have to open a different panel to understand the examples given in the problem. But it\\'s better than nothing."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "FUN FACT !\nThe test case panel also renders the tree for you. This way you can clearly understand what this input means. The input here is pretty confusing but it is just for representation. "
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form"
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "[@user2244fP](/user2244fP) \\n\\nno no the null node is not accounted for ,  basically here the left node of every node in the given tree is null \\nbut there will exsist a right node , only number 6 has its left as well as right value as null \\n\\nso , this tree kinda looks like a linked list \\n2-> 3 -> 4 -> 5 -> 6 , hence depth of this will be five \\n\\n"
                    },
                    {
                        "username": "user2244fP",
                        "content": "So I wasn\\'t the only one who faced this."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Learn data structure. It\\'s quite standard. But pay attention to NULL"
                    },
                    {
                        "username": "sreejeet",
                        "content": "1. Why is 2 the answer for test case [1,2]?\\nA: Because the path has to contain *the root* and *a leaf node*. So the path on the right does not count, as it does not contain a leaf node.\\n\\n2. The depth definition is wrong!\\nA: Yes the definition seems wrong, the qustion is wrongly worded; they simply mean the number of nodes in the path to the nearest leaf node. Try to understand it this way: a tree with no root (no nodes) has no depth, therefore 0 depth. A tree with at least 1 node has 1 depth and so on."
                    },
                    {
                        "username": "DemonLeo",
                        "content": "where [1,2]`s  Minimum Depth is 2\\uFF1F"
                    },
                    {
                        "username": "Leetcode_Wat",
                        "content": "The question requires to count the \"number of nodes\" from root to its nearest leaf node. It contains 2 nodes in your given example."
                    },
                    {
                        "username": "luyao0604",
                        "content": "Many of the trees generated for the test cases are wrong. And why is the minDepth defined as distance to its nearest child without any children? Why is it NOT distance to its nearest null child? Doesn\\'t that make more sense?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "[@HapticBovine](/HapticBovine) Actually, it seems that the array representation is different, [2,null,3,null,4,null,5,null,6] is supposed to be a simple path from 2->6. The question is, what is this format, and how can we interpret it unambiguously?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I will explain why this is true then flag the above comment since we can't have nice things (ie., a feature to report incorrect Test Cases).\n\nThe depth of a (binary) Tree is the number of edges to the most distant leaf node. A minimum depth should be the number of edges to the closest leaf node.\n\nRe. Test Case 2:\n\nIf the values are given as array elements in the array [2,null,3,null,4,null,5,null,6], and the expected depth is 5, then we must have a tree with minimum depth/height of 5, meaning the path from the root to _every_ leaf must be >= 5, or in other words, the binary tree has a (min) height of 5, meaning there are 5 edges or 6 nodes in the shortest path from the root a the leaf. The smallest tree in which this could occur is a Perfect Binary Tree, in which there are 63 nodes (2^(h+1) - 1 nodes).\n\nHowever the input [2,null,3,null,4,null,5,null,6] only contains 9 nodes!\n\nWhat a PITA, this is a pretty good platform, can you please make (or improve if it exists) a feature to report incorrect test cases? I want a button similar to the \"submit test case\" button."
                    },
                    {
                        "username": "Ekut",
                        "content": "So I read online(stack overflow, wikipedia) that the depth of a node is the number of edges to the root node. How come in this question, the minimum depth is 2 when there is a leaf node that is only one edge away from the root (direct child). \\nI'm probably missing something. I would appreciate if someone could explain.\\nThanks!"
                    },
                    {
                        "username": "nishantv",
                        "content": "No you are not missing anything. The first example seems incorrect."
                    },
                    {
                        "username": "atulgupta002",
                        "content": "Exactly my question. The min depth is 1. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "In this problem the depth is considered the number of nodes present from the root to the leaf node"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "the first test case right? i got the same doubt"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Some tips: if root is null, return 0. Otherwise keep in mind that roots depth starts at 1, not 0.\nOnly check min depth for leaf nodes - meaning a node who has two NULL children. Some people make the mistake of updating min on every single node when they should only update it for leaf nodes.  \nIf you're doing it recursively, you can save runtime by adding in \"If (depth >= min){return;}\" that way you wont check deeper than you need to."
                    }
                ]
            },
            {
                "id": 1575157,
                "content": [
                    {
                        "username": "ewmiao",
                        "content": "I don\\'t know how to show this tree in a graph, and it\\'s hard to believe that its min depth is 5. However, my code fails on this test case. Anyone explains to me?\\n\\nExample 2:\\n\\nInput: root = [2,null,3,null,4,null,5,null,6]\\nOutput: 5"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "[@huttarl](/huttarl)  The second example shows a Binary tree that is \\'right skewed\\'. [2-3-4-5-6] 6 being the leaf node with min height 5."
                    },
                    {
                        "username": "huttarl",
                        "content": "[@ronitak33](/ronitak33) Unfortunately this would give a tree in which the nodes labeled \"4\" and \"6\" have no parents."
                    },
                    {
                        "username": "huttarl",
                        "content": "Unfortunately, the \"input\" in the test cases, an array of ints, is not the same as the parameter passed to minDepth(), which is the root node of a tree. And Leetcode doesn't seem to define how the format of the test case \"input\" translates into a tree. In another problem, it was stored like this: https://en.wikipedia.org/wiki/Binary_tree#Arrays, where node i is the parent of nodes 2i+1 and 2i+2. But in this case, that would mean the nodes with values \"4\" and \"6\" have null parents (which apparently means no parents). The data structure (in Kotlin at least) doesn't allow nodes with null values.\nWe could then guess that the array omits values for nodes whose parents don't exist. But we shouldn't have to *guess* about the meaning of the example input."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "We\\'re looking for the minimum depth of a binary tree from root to leaf. The keyword here is leaf. A leaf is a node that contains no children nodes. So 2 - 3 - 4 - 5 aren\\'t leafs, but 6 is. Once you get to 6 you have a depth of 5, and since that is the only leaf - 5 is what you return."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) Can please explain the logic behind this?"
                    },
                    {
                        "username": "deepti21aug",
                        "content": "[@mariam_meky](/mariam_meky)  I guess it should be 0."
                    },
                    {
                        "username": "mariam_meky",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) what does \"ans\" stand for?"
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": "bro this input is a skwe tree where probably your code is getting struck as node having one children the other children depth is considered 0 zero. try this solution\\n if(root== NULL){\\n            return ans;\\n        }\\n        int l=minDepth(root->left); \\n        int r=minDepth(root->right);\\n        if((l==0 && r==0) || (l!=0 && r!=0))\\n        return 1+min(l,r);\\n\\n        return  1+max(l,r);"
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form...this is like a linked list forming to the right."
                    },
                    {
                        "username": "mkohar",
                        "content": "you can paste above in testcase and leetcode will show you a visual representation of the graph"
                    },
                    {
                        "username": "ahmedelewa79",
                        "content": "the left child for any index will be ( 2*idx + 1)\\nand the right child will be (2*idx + 2)\\nand you can get the parent element for any child by Math.floor((idx-1)/2)"
                    },
                    {
                        "username": "Oliviaaa-EPFL",
                        "content": "This tree is actually a line (2->3->4->5->6). If your answer is 1, you are counting the node with only one child as the leave, so the recursion returns at the first node."
                    },
                    {
                        "username": "nik-1207",
                        "content": "please anyone can explain why the minimum height of the tree [2,null,3,null,4,null,5,null,6] is 5 not 1"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree\n2->3->4->5->6\nnon of these elements have a left child, only right child is available;\n2\n->3\n -->4\n ---->5\n  ----->6\nthis is the representation"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "because bro we see the leaf node which have both child null "
                    },
                    {
                        "username": "matthewmcconaha",
                        "content": "Let's define a \"leaf node\" as a node which does not have any children. So for a leaf node, left is null and right is also null.\nThen let's define the depth of any node as being the number of layers down the tree you have to travel in order to reach that node, starting at 1. So the very top of the tree is at depth 1, the next layer is depth 2, and so on.\nFinally, let's define the minimum depth as the tree as the leaf node with the minimum depth.\n\nIn the example you reference, the top node is not a leaf node. left is null, but right is not null. So the depth can't be 1. There is actually only one leaf node in that tree, and it is at depth 5.\n\nThe answer of 1 would be for the depth where you run into the first \"closed road\". The first time you see a path that you cannot take because the node in that direction is null. However, there is still an \"open road\" in the other direction, so you need to go down that other road. What you are looking for is a \"dead end\", when both possible roads are closed and you cannot go any deeper."
                    },
                    {
                        "username": "mattesko",
                        "content": "The depth of a tree starts at 0 and not at 1! A \\'tree\\' with only a root node and no children is a tree with depth 0, not 1 like the solution entails!\\n\\nhttps://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height"
                    },
                    {
                        "username": "huttarl",
                        "content": "It may be common to define the depth of a tree the way you do, but the description for this problem clearly defines the minimum depth as the number of **nodes** along the shortest path from root to nearest leaf."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Over the years I have seen mix of people: those who use height as in \"height of nodes\", and then \"height of edges\" which causes the 0/1 difference. It is better to clarify which ones is intended one."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Ultron03](/Ultron03) this question says that depth is the number of nodes whereas in the tree properties it said it would the number of edges"
                    },
                    {
                        "username": "Ultron03",
                        "content": "But in this question it is given that if only root node is there the  depth will be 1!!..\\n"
                    },
                    {
                        "username": "msu227",
                        "content": "I dont know if I am seeing this wrong but the example  [2,null,3,null,4,null,5,null,6] is a a bad test case. How doess a null node have a left and right node???? Also even if it the null node is accounted for how is the mindepth 5 for this it should 3 if the null nodes are accounted for and 1 if they aren\\'t accounted for. Am I seeing this wrong or is this actually wrong. Someone please let me know!!![image](https://assets.leetcode.com/users/images/e132a50d-2ded-4656-a11a-2125b9545062_1613348516.5328968.png)\\n"
                    },
                    {
                        "username": "huttarl",
                        "content": "[@joelmathew2809](/joelmathew2809) Thank you. I didn\\'t know about this. Too bad you have to open a different panel to understand the examples given in the problem. But it\\'s better than nothing."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "FUN FACT !\nThe test case panel also renders the tree for you. This way you can clearly understand what this input means. The input here is pretty confusing but it is just for representation. "
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form"
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "[@user2244fP](/user2244fP) \\n\\nno no the null node is not accounted for ,  basically here the left node of every node in the given tree is null \\nbut there will exsist a right node , only number 6 has its left as well as right value as null \\n\\nso , this tree kinda looks like a linked list \\n2-> 3 -> 4 -> 5 -> 6 , hence depth of this will be five \\n\\n"
                    },
                    {
                        "username": "user2244fP",
                        "content": "So I wasn\\'t the only one who faced this."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Learn data structure. It\\'s quite standard. But pay attention to NULL"
                    },
                    {
                        "username": "sreejeet",
                        "content": "1. Why is 2 the answer for test case [1,2]?\\nA: Because the path has to contain *the root* and *a leaf node*. So the path on the right does not count, as it does not contain a leaf node.\\n\\n2. The depth definition is wrong!\\nA: Yes the definition seems wrong, the qustion is wrongly worded; they simply mean the number of nodes in the path to the nearest leaf node. Try to understand it this way: a tree with no root (no nodes) has no depth, therefore 0 depth. A tree with at least 1 node has 1 depth and so on."
                    },
                    {
                        "username": "DemonLeo",
                        "content": "where [1,2]`s  Minimum Depth is 2\\uFF1F"
                    },
                    {
                        "username": "Leetcode_Wat",
                        "content": "The question requires to count the \"number of nodes\" from root to its nearest leaf node. It contains 2 nodes in your given example."
                    },
                    {
                        "username": "luyao0604",
                        "content": "Many of the trees generated for the test cases are wrong. And why is the minDepth defined as distance to its nearest child without any children? Why is it NOT distance to its nearest null child? Doesn\\'t that make more sense?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "[@HapticBovine](/HapticBovine) Actually, it seems that the array representation is different, [2,null,3,null,4,null,5,null,6] is supposed to be a simple path from 2->6. The question is, what is this format, and how can we interpret it unambiguously?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I will explain why this is true then flag the above comment since we can't have nice things (ie., a feature to report incorrect Test Cases).\n\nThe depth of a (binary) Tree is the number of edges to the most distant leaf node. A minimum depth should be the number of edges to the closest leaf node.\n\nRe. Test Case 2:\n\nIf the values are given as array elements in the array [2,null,3,null,4,null,5,null,6], and the expected depth is 5, then we must have a tree with minimum depth/height of 5, meaning the path from the root to _every_ leaf must be >= 5, or in other words, the binary tree has a (min) height of 5, meaning there are 5 edges or 6 nodes in the shortest path from the root a the leaf. The smallest tree in which this could occur is a Perfect Binary Tree, in which there are 63 nodes (2^(h+1) - 1 nodes).\n\nHowever the input [2,null,3,null,4,null,5,null,6] only contains 9 nodes!\n\nWhat a PITA, this is a pretty good platform, can you please make (or improve if it exists) a feature to report incorrect test cases? I want a button similar to the \"submit test case\" button."
                    },
                    {
                        "username": "Ekut",
                        "content": "So I read online(stack overflow, wikipedia) that the depth of a node is the number of edges to the root node. How come in this question, the minimum depth is 2 when there is a leaf node that is only one edge away from the root (direct child). \\nI'm probably missing something. I would appreciate if someone could explain.\\nThanks!"
                    },
                    {
                        "username": "nishantv",
                        "content": "No you are not missing anything. The first example seems incorrect."
                    },
                    {
                        "username": "atulgupta002",
                        "content": "Exactly my question. The min depth is 1. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "In this problem the depth is considered the number of nodes present from the root to the leaf node"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "the first test case right? i got the same doubt"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Some tips: if root is null, return 0. Otherwise keep in mind that roots depth starts at 1, not 0.\nOnly check min depth for leaf nodes - meaning a node who has two NULL children. Some people make the mistake of updating min on every single node when they should only update it for leaf nodes.  \nIf you're doing it recursively, you can save runtime by adding in \"If (depth >= min){return;}\" that way you wont check deeper than you need to."
                    }
                ]
            },
            {
                "id": 1566112,
                "content": [
                    {
                        "username": "ewmiao",
                        "content": "I don\\'t know how to show this tree in a graph, and it\\'s hard to believe that its min depth is 5. However, my code fails on this test case. Anyone explains to me?\\n\\nExample 2:\\n\\nInput: root = [2,null,3,null,4,null,5,null,6]\\nOutput: 5"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "[@huttarl](/huttarl)  The second example shows a Binary tree that is \\'right skewed\\'. [2-3-4-5-6] 6 being the leaf node with min height 5."
                    },
                    {
                        "username": "huttarl",
                        "content": "[@ronitak33](/ronitak33) Unfortunately this would give a tree in which the nodes labeled \"4\" and \"6\" have no parents."
                    },
                    {
                        "username": "huttarl",
                        "content": "Unfortunately, the \"input\" in the test cases, an array of ints, is not the same as the parameter passed to minDepth(), which is the root node of a tree. And Leetcode doesn't seem to define how the format of the test case \"input\" translates into a tree. In another problem, it was stored like this: https://en.wikipedia.org/wiki/Binary_tree#Arrays, where node i is the parent of nodes 2i+1 and 2i+2. But in this case, that would mean the nodes with values \"4\" and \"6\" have null parents (which apparently means no parents). The data structure (in Kotlin at least) doesn't allow nodes with null values.\nWe could then guess that the array omits values for nodes whose parents don't exist. But we shouldn't have to *guess* about the meaning of the example input."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "We\\'re looking for the minimum depth of a binary tree from root to leaf. The keyword here is leaf. A leaf is a node that contains no children nodes. So 2 - 3 - 4 - 5 aren\\'t leafs, but 6 is. Once you get to 6 you have a depth of 5, and since that is the only leaf - 5 is what you return."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) Can please explain the logic behind this?"
                    },
                    {
                        "username": "deepti21aug",
                        "content": "[@mariam_meky](/mariam_meky)  I guess it should be 0."
                    },
                    {
                        "username": "mariam_meky",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) what does \"ans\" stand for?"
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": "bro this input is a skwe tree where probably your code is getting struck as node having one children the other children depth is considered 0 zero. try this solution\\n if(root== NULL){\\n            return ans;\\n        }\\n        int l=minDepth(root->left); \\n        int r=minDepth(root->right);\\n        if((l==0 && r==0) || (l!=0 && r!=0))\\n        return 1+min(l,r);\\n\\n        return  1+max(l,r);"
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form...this is like a linked list forming to the right."
                    },
                    {
                        "username": "mkohar",
                        "content": "you can paste above in testcase and leetcode will show you a visual representation of the graph"
                    },
                    {
                        "username": "ahmedelewa79",
                        "content": "the left child for any index will be ( 2*idx + 1)\\nand the right child will be (2*idx + 2)\\nand you can get the parent element for any child by Math.floor((idx-1)/2)"
                    },
                    {
                        "username": "Oliviaaa-EPFL",
                        "content": "This tree is actually a line (2->3->4->5->6). If your answer is 1, you are counting the node with only one child as the leave, so the recursion returns at the first node."
                    },
                    {
                        "username": "nik-1207",
                        "content": "please anyone can explain why the minimum height of the tree [2,null,3,null,4,null,5,null,6] is 5 not 1"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree\n2->3->4->5->6\nnon of these elements have a left child, only right child is available;\n2\n->3\n -->4\n ---->5\n  ----->6\nthis is the representation"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "because bro we see the leaf node which have both child null "
                    },
                    {
                        "username": "matthewmcconaha",
                        "content": "Let's define a \"leaf node\" as a node which does not have any children. So for a leaf node, left is null and right is also null.\nThen let's define the depth of any node as being the number of layers down the tree you have to travel in order to reach that node, starting at 1. So the very top of the tree is at depth 1, the next layer is depth 2, and so on.\nFinally, let's define the minimum depth as the tree as the leaf node with the minimum depth.\n\nIn the example you reference, the top node is not a leaf node. left is null, but right is not null. So the depth can't be 1. There is actually only one leaf node in that tree, and it is at depth 5.\n\nThe answer of 1 would be for the depth where you run into the first \"closed road\". The first time you see a path that you cannot take because the node in that direction is null. However, there is still an \"open road\" in the other direction, so you need to go down that other road. What you are looking for is a \"dead end\", when both possible roads are closed and you cannot go any deeper."
                    },
                    {
                        "username": "mattesko",
                        "content": "The depth of a tree starts at 0 and not at 1! A \\'tree\\' with only a root node and no children is a tree with depth 0, not 1 like the solution entails!\\n\\nhttps://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height"
                    },
                    {
                        "username": "huttarl",
                        "content": "It may be common to define the depth of a tree the way you do, but the description for this problem clearly defines the minimum depth as the number of **nodes** along the shortest path from root to nearest leaf."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Over the years I have seen mix of people: those who use height as in \"height of nodes\", and then \"height of edges\" which causes the 0/1 difference. It is better to clarify which ones is intended one."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Ultron03](/Ultron03) this question says that depth is the number of nodes whereas in the tree properties it said it would the number of edges"
                    },
                    {
                        "username": "Ultron03",
                        "content": "But in this question it is given that if only root node is there the  depth will be 1!!..\\n"
                    },
                    {
                        "username": "msu227",
                        "content": "I dont know if I am seeing this wrong but the example  [2,null,3,null,4,null,5,null,6] is a a bad test case. How doess a null node have a left and right node???? Also even if it the null node is accounted for how is the mindepth 5 for this it should 3 if the null nodes are accounted for and 1 if they aren\\'t accounted for. Am I seeing this wrong or is this actually wrong. Someone please let me know!!![image](https://assets.leetcode.com/users/images/e132a50d-2ded-4656-a11a-2125b9545062_1613348516.5328968.png)\\n"
                    },
                    {
                        "username": "huttarl",
                        "content": "[@joelmathew2809](/joelmathew2809) Thank you. I didn\\'t know about this. Too bad you have to open a different panel to understand the examples given in the problem. But it\\'s better than nothing."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "FUN FACT !\nThe test case panel also renders the tree for you. This way you can clearly understand what this input means. The input here is pretty confusing but it is just for representation. "
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form"
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "[@user2244fP](/user2244fP) \\n\\nno no the null node is not accounted for ,  basically here the left node of every node in the given tree is null \\nbut there will exsist a right node , only number 6 has its left as well as right value as null \\n\\nso , this tree kinda looks like a linked list \\n2-> 3 -> 4 -> 5 -> 6 , hence depth of this will be five \\n\\n"
                    },
                    {
                        "username": "user2244fP",
                        "content": "So I wasn\\'t the only one who faced this."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Learn data structure. It\\'s quite standard. But pay attention to NULL"
                    },
                    {
                        "username": "sreejeet",
                        "content": "1. Why is 2 the answer for test case [1,2]?\\nA: Because the path has to contain *the root* and *a leaf node*. So the path on the right does not count, as it does not contain a leaf node.\\n\\n2. The depth definition is wrong!\\nA: Yes the definition seems wrong, the qustion is wrongly worded; they simply mean the number of nodes in the path to the nearest leaf node. Try to understand it this way: a tree with no root (no nodes) has no depth, therefore 0 depth. A tree with at least 1 node has 1 depth and so on."
                    },
                    {
                        "username": "DemonLeo",
                        "content": "where [1,2]`s  Minimum Depth is 2\\uFF1F"
                    },
                    {
                        "username": "Leetcode_Wat",
                        "content": "The question requires to count the \"number of nodes\" from root to its nearest leaf node. It contains 2 nodes in your given example."
                    },
                    {
                        "username": "luyao0604",
                        "content": "Many of the trees generated for the test cases are wrong. And why is the minDepth defined as distance to its nearest child without any children? Why is it NOT distance to its nearest null child? Doesn\\'t that make more sense?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "[@HapticBovine](/HapticBovine) Actually, it seems that the array representation is different, [2,null,3,null,4,null,5,null,6] is supposed to be a simple path from 2->6. The question is, what is this format, and how can we interpret it unambiguously?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I will explain why this is true then flag the above comment since we can't have nice things (ie., a feature to report incorrect Test Cases).\n\nThe depth of a (binary) Tree is the number of edges to the most distant leaf node. A minimum depth should be the number of edges to the closest leaf node.\n\nRe. Test Case 2:\n\nIf the values are given as array elements in the array [2,null,3,null,4,null,5,null,6], and the expected depth is 5, then we must have a tree with minimum depth/height of 5, meaning the path from the root to _every_ leaf must be >= 5, or in other words, the binary tree has a (min) height of 5, meaning there are 5 edges or 6 nodes in the shortest path from the root a the leaf. The smallest tree in which this could occur is a Perfect Binary Tree, in which there are 63 nodes (2^(h+1) - 1 nodes).\n\nHowever the input [2,null,3,null,4,null,5,null,6] only contains 9 nodes!\n\nWhat a PITA, this is a pretty good platform, can you please make (or improve if it exists) a feature to report incorrect test cases? I want a button similar to the \"submit test case\" button."
                    },
                    {
                        "username": "Ekut",
                        "content": "So I read online(stack overflow, wikipedia) that the depth of a node is the number of edges to the root node. How come in this question, the minimum depth is 2 when there is a leaf node that is only one edge away from the root (direct child). \\nI'm probably missing something. I would appreciate if someone could explain.\\nThanks!"
                    },
                    {
                        "username": "nishantv",
                        "content": "No you are not missing anything. The first example seems incorrect."
                    },
                    {
                        "username": "atulgupta002",
                        "content": "Exactly my question. The min depth is 1. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "In this problem the depth is considered the number of nodes present from the root to the leaf node"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "the first test case right? i got the same doubt"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Some tips: if root is null, return 0. Otherwise keep in mind that roots depth starts at 1, not 0.\nOnly check min depth for leaf nodes - meaning a node who has two NULL children. Some people make the mistake of updating min on every single node when they should only update it for leaf nodes.  \nIf you're doing it recursively, you can save runtime by adding in \"If (depth >= min){return;}\" that way you wont check deeper than you need to."
                    }
                ]
            },
            {
                "id": 1574956,
                "content": [
                    {
                        "username": "ewmiao",
                        "content": "I don\\'t know how to show this tree in a graph, and it\\'s hard to believe that its min depth is 5. However, my code fails on this test case. Anyone explains to me?\\n\\nExample 2:\\n\\nInput: root = [2,null,3,null,4,null,5,null,6]\\nOutput: 5"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "[@huttarl](/huttarl)  The second example shows a Binary tree that is \\'right skewed\\'. [2-3-4-5-6] 6 being the leaf node with min height 5."
                    },
                    {
                        "username": "huttarl",
                        "content": "[@ronitak33](/ronitak33) Unfortunately this would give a tree in which the nodes labeled \"4\" and \"6\" have no parents."
                    },
                    {
                        "username": "huttarl",
                        "content": "Unfortunately, the \"input\" in the test cases, an array of ints, is not the same as the parameter passed to minDepth(), which is the root node of a tree. And Leetcode doesn't seem to define how the format of the test case \"input\" translates into a tree. In another problem, it was stored like this: https://en.wikipedia.org/wiki/Binary_tree#Arrays, where node i is the parent of nodes 2i+1 and 2i+2. But in this case, that would mean the nodes with values \"4\" and \"6\" have null parents (which apparently means no parents). The data structure (in Kotlin at least) doesn't allow nodes with null values.\nWe could then guess that the array omits values for nodes whose parents don't exist. But we shouldn't have to *guess* about the meaning of the example input."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "We\\'re looking for the minimum depth of a binary tree from root to leaf. The keyword here is leaf. A leaf is a node that contains no children nodes. So 2 - 3 - 4 - 5 aren\\'t leafs, but 6 is. Once you get to 6 you have a depth of 5, and since that is the only leaf - 5 is what you return."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) Can please explain the logic behind this?"
                    },
                    {
                        "username": "deepti21aug",
                        "content": "[@mariam_meky](/mariam_meky)  I guess it should be 0."
                    },
                    {
                        "username": "mariam_meky",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) what does \"ans\" stand for?"
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": "bro this input is a skwe tree where probably your code is getting struck as node having one children the other children depth is considered 0 zero. try this solution\\n if(root== NULL){\\n            return ans;\\n        }\\n        int l=minDepth(root->left); \\n        int r=minDepth(root->right);\\n        if((l==0 && r==0) || (l!=0 && r!=0))\\n        return 1+min(l,r);\\n\\n        return  1+max(l,r);"
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form...this is like a linked list forming to the right."
                    },
                    {
                        "username": "mkohar",
                        "content": "you can paste above in testcase and leetcode will show you a visual representation of the graph"
                    },
                    {
                        "username": "ahmedelewa79",
                        "content": "the left child for any index will be ( 2*idx + 1)\\nand the right child will be (2*idx + 2)\\nand you can get the parent element for any child by Math.floor((idx-1)/2)"
                    },
                    {
                        "username": "Oliviaaa-EPFL",
                        "content": "This tree is actually a line (2->3->4->5->6). If your answer is 1, you are counting the node with only one child as the leave, so the recursion returns at the first node."
                    },
                    {
                        "username": "nik-1207",
                        "content": "please anyone can explain why the minimum height of the tree [2,null,3,null,4,null,5,null,6] is 5 not 1"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree\n2->3->4->5->6\nnon of these elements have a left child, only right child is available;\n2\n->3\n -->4\n ---->5\n  ----->6\nthis is the representation"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "because bro we see the leaf node which have both child null "
                    },
                    {
                        "username": "matthewmcconaha",
                        "content": "Let's define a \"leaf node\" as a node which does not have any children. So for a leaf node, left is null and right is also null.\nThen let's define the depth of any node as being the number of layers down the tree you have to travel in order to reach that node, starting at 1. So the very top of the tree is at depth 1, the next layer is depth 2, and so on.\nFinally, let's define the minimum depth as the tree as the leaf node with the minimum depth.\n\nIn the example you reference, the top node is not a leaf node. left is null, but right is not null. So the depth can't be 1. There is actually only one leaf node in that tree, and it is at depth 5.\n\nThe answer of 1 would be for the depth where you run into the first \"closed road\". The first time you see a path that you cannot take because the node in that direction is null. However, there is still an \"open road\" in the other direction, so you need to go down that other road. What you are looking for is a \"dead end\", when both possible roads are closed and you cannot go any deeper."
                    },
                    {
                        "username": "mattesko",
                        "content": "The depth of a tree starts at 0 and not at 1! A \\'tree\\' with only a root node and no children is a tree with depth 0, not 1 like the solution entails!\\n\\nhttps://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height"
                    },
                    {
                        "username": "huttarl",
                        "content": "It may be common to define the depth of a tree the way you do, but the description for this problem clearly defines the minimum depth as the number of **nodes** along the shortest path from root to nearest leaf."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Over the years I have seen mix of people: those who use height as in \"height of nodes\", and then \"height of edges\" which causes the 0/1 difference. It is better to clarify which ones is intended one."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Ultron03](/Ultron03) this question says that depth is the number of nodes whereas in the tree properties it said it would the number of edges"
                    },
                    {
                        "username": "Ultron03",
                        "content": "But in this question it is given that if only root node is there the  depth will be 1!!..\\n"
                    },
                    {
                        "username": "msu227",
                        "content": "I dont know if I am seeing this wrong but the example  [2,null,3,null,4,null,5,null,6] is a a bad test case. How doess a null node have a left and right node???? Also even if it the null node is accounted for how is the mindepth 5 for this it should 3 if the null nodes are accounted for and 1 if they aren\\'t accounted for. Am I seeing this wrong or is this actually wrong. Someone please let me know!!![image](https://assets.leetcode.com/users/images/e132a50d-2ded-4656-a11a-2125b9545062_1613348516.5328968.png)\\n"
                    },
                    {
                        "username": "huttarl",
                        "content": "[@joelmathew2809](/joelmathew2809) Thank you. I didn\\'t know about this. Too bad you have to open a different panel to understand the examples given in the problem. But it\\'s better than nothing."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "FUN FACT !\nThe test case panel also renders the tree for you. This way you can clearly understand what this input means. The input here is pretty confusing but it is just for representation. "
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form"
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "[@user2244fP](/user2244fP) \\n\\nno no the null node is not accounted for ,  basically here the left node of every node in the given tree is null \\nbut there will exsist a right node , only number 6 has its left as well as right value as null \\n\\nso , this tree kinda looks like a linked list \\n2-> 3 -> 4 -> 5 -> 6 , hence depth of this will be five \\n\\n"
                    },
                    {
                        "username": "user2244fP",
                        "content": "So I wasn\\'t the only one who faced this."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Learn data structure. It\\'s quite standard. But pay attention to NULL"
                    },
                    {
                        "username": "sreejeet",
                        "content": "1. Why is 2 the answer for test case [1,2]?\\nA: Because the path has to contain *the root* and *a leaf node*. So the path on the right does not count, as it does not contain a leaf node.\\n\\n2. The depth definition is wrong!\\nA: Yes the definition seems wrong, the qustion is wrongly worded; they simply mean the number of nodes in the path to the nearest leaf node. Try to understand it this way: a tree with no root (no nodes) has no depth, therefore 0 depth. A tree with at least 1 node has 1 depth and so on."
                    },
                    {
                        "username": "DemonLeo",
                        "content": "where [1,2]`s  Minimum Depth is 2\\uFF1F"
                    },
                    {
                        "username": "Leetcode_Wat",
                        "content": "The question requires to count the \"number of nodes\" from root to its nearest leaf node. It contains 2 nodes in your given example."
                    },
                    {
                        "username": "luyao0604",
                        "content": "Many of the trees generated for the test cases are wrong. And why is the minDepth defined as distance to its nearest child without any children? Why is it NOT distance to its nearest null child? Doesn\\'t that make more sense?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "[@HapticBovine](/HapticBovine) Actually, it seems that the array representation is different, [2,null,3,null,4,null,5,null,6] is supposed to be a simple path from 2->6. The question is, what is this format, and how can we interpret it unambiguously?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I will explain why this is true then flag the above comment since we can't have nice things (ie., a feature to report incorrect Test Cases).\n\nThe depth of a (binary) Tree is the number of edges to the most distant leaf node. A minimum depth should be the number of edges to the closest leaf node.\n\nRe. Test Case 2:\n\nIf the values are given as array elements in the array [2,null,3,null,4,null,5,null,6], and the expected depth is 5, then we must have a tree with minimum depth/height of 5, meaning the path from the root to _every_ leaf must be >= 5, or in other words, the binary tree has a (min) height of 5, meaning there are 5 edges or 6 nodes in the shortest path from the root a the leaf. The smallest tree in which this could occur is a Perfect Binary Tree, in which there are 63 nodes (2^(h+1) - 1 nodes).\n\nHowever the input [2,null,3,null,4,null,5,null,6] only contains 9 nodes!\n\nWhat a PITA, this is a pretty good platform, can you please make (or improve if it exists) a feature to report incorrect test cases? I want a button similar to the \"submit test case\" button."
                    },
                    {
                        "username": "Ekut",
                        "content": "So I read online(stack overflow, wikipedia) that the depth of a node is the number of edges to the root node. How come in this question, the minimum depth is 2 when there is a leaf node that is only one edge away from the root (direct child). \\nI'm probably missing something. I would appreciate if someone could explain.\\nThanks!"
                    },
                    {
                        "username": "nishantv",
                        "content": "No you are not missing anything. The first example seems incorrect."
                    },
                    {
                        "username": "atulgupta002",
                        "content": "Exactly my question. The min depth is 1. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "In this problem the depth is considered the number of nodes present from the root to the leaf node"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "the first test case right? i got the same doubt"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Some tips: if root is null, return 0. Otherwise keep in mind that roots depth starts at 1, not 0.\nOnly check min depth for leaf nodes - meaning a node who has two NULL children. Some people make the mistake of updating min on every single node when they should only update it for leaf nodes.  \nIf you're doing it recursively, you can save runtime by adding in \"If (depth >= min){return;}\" that way you wont check deeper than you need to."
                    }
                ]
            },
            {
                "id": 1963651,
                "content": [
                    {
                        "username": "ewmiao",
                        "content": "I don\\'t know how to show this tree in a graph, and it\\'s hard to believe that its min depth is 5. However, my code fails on this test case. Anyone explains to me?\\n\\nExample 2:\\n\\nInput: root = [2,null,3,null,4,null,5,null,6]\\nOutput: 5"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "[@huttarl](/huttarl)  The second example shows a Binary tree that is \\'right skewed\\'. [2-3-4-5-6] 6 being the leaf node with min height 5."
                    },
                    {
                        "username": "huttarl",
                        "content": "[@ronitak33](/ronitak33) Unfortunately this would give a tree in which the nodes labeled \"4\" and \"6\" have no parents."
                    },
                    {
                        "username": "huttarl",
                        "content": "Unfortunately, the \"input\" in the test cases, an array of ints, is not the same as the parameter passed to minDepth(), which is the root node of a tree. And Leetcode doesn't seem to define how the format of the test case \"input\" translates into a tree. In another problem, it was stored like this: https://en.wikipedia.org/wiki/Binary_tree#Arrays, where node i is the parent of nodes 2i+1 and 2i+2. But in this case, that would mean the nodes with values \"4\" and \"6\" have null parents (which apparently means no parents). The data structure (in Kotlin at least) doesn't allow nodes with null values.\nWe could then guess that the array omits values for nodes whose parents don't exist. But we shouldn't have to *guess* about the meaning of the example input."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "We\\'re looking for the minimum depth of a binary tree from root to leaf. The keyword here is leaf. A leaf is a node that contains no children nodes. So 2 - 3 - 4 - 5 aren\\'t leafs, but 6 is. Once you get to 6 you have a depth of 5, and since that is the only leaf - 5 is what you return."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) Can please explain the logic behind this?"
                    },
                    {
                        "username": "deepti21aug",
                        "content": "[@mariam_meky](/mariam_meky)  I guess it should be 0."
                    },
                    {
                        "username": "mariam_meky",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) what does \"ans\" stand for?"
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": "bro this input is a skwe tree where probably your code is getting struck as node having one children the other children depth is considered 0 zero. try this solution\\n if(root== NULL){\\n            return ans;\\n        }\\n        int l=minDepth(root->left); \\n        int r=minDepth(root->right);\\n        if((l==0 && r==0) || (l!=0 && r!=0))\\n        return 1+min(l,r);\\n\\n        return  1+max(l,r);"
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form...this is like a linked list forming to the right."
                    },
                    {
                        "username": "mkohar",
                        "content": "you can paste above in testcase and leetcode will show you a visual representation of the graph"
                    },
                    {
                        "username": "ahmedelewa79",
                        "content": "the left child for any index will be ( 2*idx + 1)\\nand the right child will be (2*idx + 2)\\nand you can get the parent element for any child by Math.floor((idx-1)/2)"
                    },
                    {
                        "username": "Oliviaaa-EPFL",
                        "content": "This tree is actually a line (2->3->4->5->6). If your answer is 1, you are counting the node with only one child as the leave, so the recursion returns at the first node."
                    },
                    {
                        "username": "nik-1207",
                        "content": "please anyone can explain why the minimum height of the tree [2,null,3,null,4,null,5,null,6] is 5 not 1"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree\n2->3->4->5->6\nnon of these elements have a left child, only right child is available;\n2\n->3\n -->4\n ---->5\n  ----->6\nthis is the representation"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "because bro we see the leaf node which have both child null "
                    },
                    {
                        "username": "matthewmcconaha",
                        "content": "Let's define a \"leaf node\" as a node which does not have any children. So for a leaf node, left is null and right is also null.\nThen let's define the depth of any node as being the number of layers down the tree you have to travel in order to reach that node, starting at 1. So the very top of the tree is at depth 1, the next layer is depth 2, and so on.\nFinally, let's define the minimum depth as the tree as the leaf node with the minimum depth.\n\nIn the example you reference, the top node is not a leaf node. left is null, but right is not null. So the depth can't be 1. There is actually only one leaf node in that tree, and it is at depth 5.\n\nThe answer of 1 would be for the depth where you run into the first \"closed road\". The first time you see a path that you cannot take because the node in that direction is null. However, there is still an \"open road\" in the other direction, so you need to go down that other road. What you are looking for is a \"dead end\", when both possible roads are closed and you cannot go any deeper."
                    },
                    {
                        "username": "mattesko",
                        "content": "The depth of a tree starts at 0 and not at 1! A \\'tree\\' with only a root node and no children is a tree with depth 0, not 1 like the solution entails!\\n\\nhttps://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height"
                    },
                    {
                        "username": "huttarl",
                        "content": "It may be common to define the depth of a tree the way you do, but the description for this problem clearly defines the minimum depth as the number of **nodes** along the shortest path from root to nearest leaf."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Over the years I have seen mix of people: those who use height as in \"height of nodes\", and then \"height of edges\" which causes the 0/1 difference. It is better to clarify which ones is intended one."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Ultron03](/Ultron03) this question says that depth is the number of nodes whereas in the tree properties it said it would the number of edges"
                    },
                    {
                        "username": "Ultron03",
                        "content": "But in this question it is given that if only root node is there the  depth will be 1!!..\\n"
                    },
                    {
                        "username": "msu227",
                        "content": "I dont know if I am seeing this wrong but the example  [2,null,3,null,4,null,5,null,6] is a a bad test case. How doess a null node have a left and right node???? Also even if it the null node is accounted for how is the mindepth 5 for this it should 3 if the null nodes are accounted for and 1 if they aren\\'t accounted for. Am I seeing this wrong or is this actually wrong. Someone please let me know!!![image](https://assets.leetcode.com/users/images/e132a50d-2ded-4656-a11a-2125b9545062_1613348516.5328968.png)\\n"
                    },
                    {
                        "username": "huttarl",
                        "content": "[@joelmathew2809](/joelmathew2809) Thank you. I didn\\'t know about this. Too bad you have to open a different panel to understand the examples given in the problem. But it\\'s better than nothing."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "FUN FACT !\nThe test case panel also renders the tree for you. This way you can clearly understand what this input means. The input here is pretty confusing but it is just for representation. "
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form"
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "[@user2244fP](/user2244fP) \\n\\nno no the null node is not accounted for ,  basically here the left node of every node in the given tree is null \\nbut there will exsist a right node , only number 6 has its left as well as right value as null \\n\\nso , this tree kinda looks like a linked list \\n2-> 3 -> 4 -> 5 -> 6 , hence depth of this will be five \\n\\n"
                    },
                    {
                        "username": "user2244fP",
                        "content": "So I wasn\\'t the only one who faced this."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Learn data structure. It\\'s quite standard. But pay attention to NULL"
                    },
                    {
                        "username": "sreejeet",
                        "content": "1. Why is 2 the answer for test case [1,2]?\\nA: Because the path has to contain *the root* and *a leaf node*. So the path on the right does not count, as it does not contain a leaf node.\\n\\n2. The depth definition is wrong!\\nA: Yes the definition seems wrong, the qustion is wrongly worded; they simply mean the number of nodes in the path to the nearest leaf node. Try to understand it this way: a tree with no root (no nodes) has no depth, therefore 0 depth. A tree with at least 1 node has 1 depth and so on."
                    },
                    {
                        "username": "DemonLeo",
                        "content": "where [1,2]`s  Minimum Depth is 2\\uFF1F"
                    },
                    {
                        "username": "Leetcode_Wat",
                        "content": "The question requires to count the \"number of nodes\" from root to its nearest leaf node. It contains 2 nodes in your given example."
                    },
                    {
                        "username": "luyao0604",
                        "content": "Many of the trees generated for the test cases are wrong. And why is the minDepth defined as distance to its nearest child without any children? Why is it NOT distance to its nearest null child? Doesn\\'t that make more sense?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "[@HapticBovine](/HapticBovine) Actually, it seems that the array representation is different, [2,null,3,null,4,null,5,null,6] is supposed to be a simple path from 2->6. The question is, what is this format, and how can we interpret it unambiguously?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I will explain why this is true then flag the above comment since we can't have nice things (ie., a feature to report incorrect Test Cases).\n\nThe depth of a (binary) Tree is the number of edges to the most distant leaf node. A minimum depth should be the number of edges to the closest leaf node.\n\nRe. Test Case 2:\n\nIf the values are given as array elements in the array [2,null,3,null,4,null,5,null,6], and the expected depth is 5, then we must have a tree with minimum depth/height of 5, meaning the path from the root to _every_ leaf must be >= 5, or in other words, the binary tree has a (min) height of 5, meaning there are 5 edges or 6 nodes in the shortest path from the root a the leaf. The smallest tree in which this could occur is a Perfect Binary Tree, in which there are 63 nodes (2^(h+1) - 1 nodes).\n\nHowever the input [2,null,3,null,4,null,5,null,6] only contains 9 nodes!\n\nWhat a PITA, this is a pretty good platform, can you please make (or improve if it exists) a feature to report incorrect test cases? I want a button similar to the \"submit test case\" button."
                    },
                    {
                        "username": "Ekut",
                        "content": "So I read online(stack overflow, wikipedia) that the depth of a node is the number of edges to the root node. How come in this question, the minimum depth is 2 when there is a leaf node that is only one edge away from the root (direct child). \\nI'm probably missing something. I would appreciate if someone could explain.\\nThanks!"
                    },
                    {
                        "username": "nishantv",
                        "content": "No you are not missing anything. The first example seems incorrect."
                    },
                    {
                        "username": "atulgupta002",
                        "content": "Exactly my question. The min depth is 1. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "In this problem the depth is considered the number of nodes present from the root to the leaf node"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "the first test case right? i got the same doubt"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Some tips: if root is null, return 0. Otherwise keep in mind that roots depth starts at 1, not 0.\nOnly check min depth for leaf nodes - meaning a node who has two NULL children. Some people make the mistake of updating min on every single node when they should only update it for leaf nodes.  \nIf you're doing it recursively, you can save runtime by adding in \"If (depth >= min){return;}\" that way you wont check deeper than you need to."
                    }
                ]
            },
            {
                "id": 1570150,
                "content": [
                    {
                        "username": "ewmiao",
                        "content": "I don\\'t know how to show this tree in a graph, and it\\'s hard to believe that its min depth is 5. However, my code fails on this test case. Anyone explains to me?\\n\\nExample 2:\\n\\nInput: root = [2,null,3,null,4,null,5,null,6]\\nOutput: 5"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "[@huttarl](/huttarl)  The second example shows a Binary tree that is \\'right skewed\\'. [2-3-4-5-6] 6 being the leaf node with min height 5."
                    },
                    {
                        "username": "huttarl",
                        "content": "[@ronitak33](/ronitak33) Unfortunately this would give a tree in which the nodes labeled \"4\" and \"6\" have no parents."
                    },
                    {
                        "username": "huttarl",
                        "content": "Unfortunately, the \"input\" in the test cases, an array of ints, is not the same as the parameter passed to minDepth(), which is the root node of a tree. And Leetcode doesn't seem to define how the format of the test case \"input\" translates into a tree. In another problem, it was stored like this: https://en.wikipedia.org/wiki/Binary_tree#Arrays, where node i is the parent of nodes 2i+1 and 2i+2. But in this case, that would mean the nodes with values \"4\" and \"6\" have null parents (which apparently means no parents). The data structure (in Kotlin at least) doesn't allow nodes with null values.\nWe could then guess that the array omits values for nodes whose parents don't exist. But we shouldn't have to *guess* about the meaning of the example input."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "We\\'re looking for the minimum depth of a binary tree from root to leaf. The keyword here is leaf. A leaf is a node that contains no children nodes. So 2 - 3 - 4 - 5 aren\\'t leafs, but 6 is. Once you get to 6 you have a depth of 5, and since that is the only leaf - 5 is what you return."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) Can please explain the logic behind this?"
                    },
                    {
                        "username": "deepti21aug",
                        "content": "[@mariam_meky](/mariam_meky)  I guess it should be 0."
                    },
                    {
                        "username": "mariam_meky",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) what does \"ans\" stand for?"
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": "bro this input is a skwe tree where probably your code is getting struck as node having one children the other children depth is considered 0 zero. try this solution\\n if(root== NULL){\\n            return ans;\\n        }\\n        int l=minDepth(root->left); \\n        int r=minDepth(root->right);\\n        if((l==0 && r==0) || (l!=0 && r!=0))\\n        return 1+min(l,r);\\n\\n        return  1+max(l,r);"
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form...this is like a linked list forming to the right."
                    },
                    {
                        "username": "mkohar",
                        "content": "you can paste above in testcase and leetcode will show you a visual representation of the graph"
                    },
                    {
                        "username": "ahmedelewa79",
                        "content": "the left child for any index will be ( 2*idx + 1)\\nand the right child will be (2*idx + 2)\\nand you can get the parent element for any child by Math.floor((idx-1)/2)"
                    },
                    {
                        "username": "Oliviaaa-EPFL",
                        "content": "This tree is actually a line (2->3->4->5->6). If your answer is 1, you are counting the node with only one child as the leave, so the recursion returns at the first node."
                    },
                    {
                        "username": "nik-1207",
                        "content": "please anyone can explain why the minimum height of the tree [2,null,3,null,4,null,5,null,6] is 5 not 1"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree\n2->3->4->5->6\nnon of these elements have a left child, only right child is available;\n2\n->3\n -->4\n ---->5\n  ----->6\nthis is the representation"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "because bro we see the leaf node which have both child null "
                    },
                    {
                        "username": "matthewmcconaha",
                        "content": "Let's define a \"leaf node\" as a node which does not have any children. So for a leaf node, left is null and right is also null.\nThen let's define the depth of any node as being the number of layers down the tree you have to travel in order to reach that node, starting at 1. So the very top of the tree is at depth 1, the next layer is depth 2, and so on.\nFinally, let's define the minimum depth as the tree as the leaf node with the minimum depth.\n\nIn the example you reference, the top node is not a leaf node. left is null, but right is not null. So the depth can't be 1. There is actually only one leaf node in that tree, and it is at depth 5.\n\nThe answer of 1 would be for the depth where you run into the first \"closed road\". The first time you see a path that you cannot take because the node in that direction is null. However, there is still an \"open road\" in the other direction, so you need to go down that other road. What you are looking for is a \"dead end\", when both possible roads are closed and you cannot go any deeper."
                    },
                    {
                        "username": "mattesko",
                        "content": "The depth of a tree starts at 0 and not at 1! A \\'tree\\' with only a root node and no children is a tree with depth 0, not 1 like the solution entails!\\n\\nhttps://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height"
                    },
                    {
                        "username": "huttarl",
                        "content": "It may be common to define the depth of a tree the way you do, but the description for this problem clearly defines the minimum depth as the number of **nodes** along the shortest path from root to nearest leaf."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Over the years I have seen mix of people: those who use height as in \"height of nodes\", and then \"height of edges\" which causes the 0/1 difference. It is better to clarify which ones is intended one."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Ultron03](/Ultron03) this question says that depth is the number of nodes whereas in the tree properties it said it would the number of edges"
                    },
                    {
                        "username": "Ultron03",
                        "content": "But in this question it is given that if only root node is there the  depth will be 1!!..\\n"
                    },
                    {
                        "username": "msu227",
                        "content": "I dont know if I am seeing this wrong but the example  [2,null,3,null,4,null,5,null,6] is a a bad test case. How doess a null node have a left and right node???? Also even if it the null node is accounted for how is the mindepth 5 for this it should 3 if the null nodes are accounted for and 1 if they aren\\'t accounted for. Am I seeing this wrong or is this actually wrong. Someone please let me know!!![image](https://assets.leetcode.com/users/images/e132a50d-2ded-4656-a11a-2125b9545062_1613348516.5328968.png)\\n"
                    },
                    {
                        "username": "huttarl",
                        "content": "[@joelmathew2809](/joelmathew2809) Thank you. I didn\\'t know about this. Too bad you have to open a different panel to understand the examples given in the problem. But it\\'s better than nothing."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "FUN FACT !\nThe test case panel also renders the tree for you. This way you can clearly understand what this input means. The input here is pretty confusing but it is just for representation. "
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form"
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "[@user2244fP](/user2244fP) \\n\\nno no the null node is not accounted for ,  basically here the left node of every node in the given tree is null \\nbut there will exsist a right node , only number 6 has its left as well as right value as null \\n\\nso , this tree kinda looks like a linked list \\n2-> 3 -> 4 -> 5 -> 6 , hence depth of this will be five \\n\\n"
                    },
                    {
                        "username": "user2244fP",
                        "content": "So I wasn\\'t the only one who faced this."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Learn data structure. It\\'s quite standard. But pay attention to NULL"
                    },
                    {
                        "username": "sreejeet",
                        "content": "1. Why is 2 the answer for test case [1,2]?\\nA: Because the path has to contain *the root* and *a leaf node*. So the path on the right does not count, as it does not contain a leaf node.\\n\\n2. The depth definition is wrong!\\nA: Yes the definition seems wrong, the qustion is wrongly worded; they simply mean the number of nodes in the path to the nearest leaf node. Try to understand it this way: a tree with no root (no nodes) has no depth, therefore 0 depth. A tree with at least 1 node has 1 depth and so on."
                    },
                    {
                        "username": "DemonLeo",
                        "content": "where [1,2]`s  Minimum Depth is 2\\uFF1F"
                    },
                    {
                        "username": "Leetcode_Wat",
                        "content": "The question requires to count the \"number of nodes\" from root to its nearest leaf node. It contains 2 nodes in your given example."
                    },
                    {
                        "username": "luyao0604",
                        "content": "Many of the trees generated for the test cases are wrong. And why is the minDepth defined as distance to its nearest child without any children? Why is it NOT distance to its nearest null child? Doesn\\'t that make more sense?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "[@HapticBovine](/HapticBovine) Actually, it seems that the array representation is different, [2,null,3,null,4,null,5,null,6] is supposed to be a simple path from 2->6. The question is, what is this format, and how can we interpret it unambiguously?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I will explain why this is true then flag the above comment since we can't have nice things (ie., a feature to report incorrect Test Cases).\n\nThe depth of a (binary) Tree is the number of edges to the most distant leaf node. A minimum depth should be the number of edges to the closest leaf node.\n\nRe. Test Case 2:\n\nIf the values are given as array elements in the array [2,null,3,null,4,null,5,null,6], and the expected depth is 5, then we must have a tree with minimum depth/height of 5, meaning the path from the root to _every_ leaf must be >= 5, or in other words, the binary tree has a (min) height of 5, meaning there are 5 edges or 6 nodes in the shortest path from the root a the leaf. The smallest tree in which this could occur is a Perfect Binary Tree, in which there are 63 nodes (2^(h+1) - 1 nodes).\n\nHowever the input [2,null,3,null,4,null,5,null,6] only contains 9 nodes!\n\nWhat a PITA, this is a pretty good platform, can you please make (or improve if it exists) a feature to report incorrect test cases? I want a button similar to the \"submit test case\" button."
                    },
                    {
                        "username": "Ekut",
                        "content": "So I read online(stack overflow, wikipedia) that the depth of a node is the number of edges to the root node. How come in this question, the minimum depth is 2 when there is a leaf node that is only one edge away from the root (direct child). \\nI'm probably missing something. I would appreciate if someone could explain.\\nThanks!"
                    },
                    {
                        "username": "nishantv",
                        "content": "No you are not missing anything. The first example seems incorrect."
                    },
                    {
                        "username": "atulgupta002",
                        "content": "Exactly my question. The min depth is 1. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "In this problem the depth is considered the number of nodes present from the root to the leaf node"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "the first test case right? i got the same doubt"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Some tips: if root is null, return 0. Otherwise keep in mind that roots depth starts at 1, not 0.\nOnly check min depth for leaf nodes - meaning a node who has two NULL children. Some people make the mistake of updating min on every single node when they should only update it for leaf nodes.  \nIf you're doing it recursively, you can save runtime by adding in \"If (depth >= min){return;}\" that way you wont check deeper than you need to."
                    }
                ]
            },
            {
                "id": 1566120,
                "content": [
                    {
                        "username": "ewmiao",
                        "content": "I don\\'t know how to show this tree in a graph, and it\\'s hard to believe that its min depth is 5. However, my code fails on this test case. Anyone explains to me?\\n\\nExample 2:\\n\\nInput: root = [2,null,3,null,4,null,5,null,6]\\nOutput: 5"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "[@huttarl](/huttarl)  The second example shows a Binary tree that is \\'right skewed\\'. [2-3-4-5-6] 6 being the leaf node with min height 5."
                    },
                    {
                        "username": "huttarl",
                        "content": "[@ronitak33](/ronitak33) Unfortunately this would give a tree in which the nodes labeled \"4\" and \"6\" have no parents."
                    },
                    {
                        "username": "huttarl",
                        "content": "Unfortunately, the \"input\" in the test cases, an array of ints, is not the same as the parameter passed to minDepth(), which is the root node of a tree. And Leetcode doesn't seem to define how the format of the test case \"input\" translates into a tree. In another problem, it was stored like this: https://en.wikipedia.org/wiki/Binary_tree#Arrays, where node i is the parent of nodes 2i+1 and 2i+2. But in this case, that would mean the nodes with values \"4\" and \"6\" have null parents (which apparently means no parents). The data structure (in Kotlin at least) doesn't allow nodes with null values.\nWe could then guess that the array omits values for nodes whose parents don't exist. But we shouldn't have to *guess* about the meaning of the example input."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "We\\'re looking for the minimum depth of a binary tree from root to leaf. The keyword here is leaf. A leaf is a node that contains no children nodes. So 2 - 3 - 4 - 5 aren\\'t leafs, but 6 is. Once you get to 6 you have a depth of 5, and since that is the only leaf - 5 is what you return."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) Can please explain the logic behind this?"
                    },
                    {
                        "username": "deepti21aug",
                        "content": "[@mariam_meky](/mariam_meky)  I guess it should be 0."
                    },
                    {
                        "username": "mariam_meky",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) what does \"ans\" stand for?"
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": "bro this input is a skwe tree where probably your code is getting struck as node having one children the other children depth is considered 0 zero. try this solution\\n if(root== NULL){\\n            return ans;\\n        }\\n        int l=minDepth(root->left); \\n        int r=minDepth(root->right);\\n        if((l==0 && r==0) || (l!=0 && r!=0))\\n        return 1+min(l,r);\\n\\n        return  1+max(l,r);"
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form...this is like a linked list forming to the right."
                    },
                    {
                        "username": "mkohar",
                        "content": "you can paste above in testcase and leetcode will show you a visual representation of the graph"
                    },
                    {
                        "username": "ahmedelewa79",
                        "content": "the left child for any index will be ( 2*idx + 1)\\nand the right child will be (2*idx + 2)\\nand you can get the parent element for any child by Math.floor((idx-1)/2)"
                    },
                    {
                        "username": "Oliviaaa-EPFL",
                        "content": "This tree is actually a line (2->3->4->5->6). If your answer is 1, you are counting the node with only one child as the leave, so the recursion returns at the first node."
                    },
                    {
                        "username": "nik-1207",
                        "content": "please anyone can explain why the minimum height of the tree [2,null,3,null,4,null,5,null,6] is 5 not 1"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree\n2->3->4->5->6\nnon of these elements have a left child, only right child is available;\n2\n->3\n -->4\n ---->5\n  ----->6\nthis is the representation"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "because bro we see the leaf node which have both child null "
                    },
                    {
                        "username": "matthewmcconaha",
                        "content": "Let's define a \"leaf node\" as a node which does not have any children. So for a leaf node, left is null and right is also null.\nThen let's define the depth of any node as being the number of layers down the tree you have to travel in order to reach that node, starting at 1. So the very top of the tree is at depth 1, the next layer is depth 2, and so on.\nFinally, let's define the minimum depth as the tree as the leaf node with the minimum depth.\n\nIn the example you reference, the top node is not a leaf node. left is null, but right is not null. So the depth can't be 1. There is actually only one leaf node in that tree, and it is at depth 5.\n\nThe answer of 1 would be for the depth where you run into the first \"closed road\". The first time you see a path that you cannot take because the node in that direction is null. However, there is still an \"open road\" in the other direction, so you need to go down that other road. What you are looking for is a \"dead end\", when both possible roads are closed and you cannot go any deeper."
                    },
                    {
                        "username": "mattesko",
                        "content": "The depth of a tree starts at 0 and not at 1! A \\'tree\\' with only a root node and no children is a tree with depth 0, not 1 like the solution entails!\\n\\nhttps://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height"
                    },
                    {
                        "username": "huttarl",
                        "content": "It may be common to define the depth of a tree the way you do, but the description for this problem clearly defines the minimum depth as the number of **nodes** along the shortest path from root to nearest leaf."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Over the years I have seen mix of people: those who use height as in \"height of nodes\", and then \"height of edges\" which causes the 0/1 difference. It is better to clarify which ones is intended one."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Ultron03](/Ultron03) this question says that depth is the number of nodes whereas in the tree properties it said it would the number of edges"
                    },
                    {
                        "username": "Ultron03",
                        "content": "But in this question it is given that if only root node is there the  depth will be 1!!..\\n"
                    },
                    {
                        "username": "msu227",
                        "content": "I dont know if I am seeing this wrong but the example  [2,null,3,null,4,null,5,null,6] is a a bad test case. How doess a null node have a left and right node???? Also even if it the null node is accounted for how is the mindepth 5 for this it should 3 if the null nodes are accounted for and 1 if they aren\\'t accounted for. Am I seeing this wrong or is this actually wrong. Someone please let me know!!![image](https://assets.leetcode.com/users/images/e132a50d-2ded-4656-a11a-2125b9545062_1613348516.5328968.png)\\n"
                    },
                    {
                        "username": "huttarl",
                        "content": "[@joelmathew2809](/joelmathew2809) Thank you. I didn\\'t know about this. Too bad you have to open a different panel to understand the examples given in the problem. But it\\'s better than nothing."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "FUN FACT !\nThe test case panel also renders the tree for you. This way you can clearly understand what this input means. The input here is pretty confusing but it is just for representation. "
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form"
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "[@user2244fP](/user2244fP) \\n\\nno no the null node is not accounted for ,  basically here the left node of every node in the given tree is null \\nbut there will exsist a right node , only number 6 has its left as well as right value as null \\n\\nso , this tree kinda looks like a linked list \\n2-> 3 -> 4 -> 5 -> 6 , hence depth of this will be five \\n\\n"
                    },
                    {
                        "username": "user2244fP",
                        "content": "So I wasn\\'t the only one who faced this."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Learn data structure. It\\'s quite standard. But pay attention to NULL"
                    },
                    {
                        "username": "sreejeet",
                        "content": "1. Why is 2 the answer for test case [1,2]?\\nA: Because the path has to contain *the root* and *a leaf node*. So the path on the right does not count, as it does not contain a leaf node.\\n\\n2. The depth definition is wrong!\\nA: Yes the definition seems wrong, the qustion is wrongly worded; they simply mean the number of nodes in the path to the nearest leaf node. Try to understand it this way: a tree with no root (no nodes) has no depth, therefore 0 depth. A tree with at least 1 node has 1 depth and so on."
                    },
                    {
                        "username": "DemonLeo",
                        "content": "where [1,2]`s  Minimum Depth is 2\\uFF1F"
                    },
                    {
                        "username": "Leetcode_Wat",
                        "content": "The question requires to count the \"number of nodes\" from root to its nearest leaf node. It contains 2 nodes in your given example."
                    },
                    {
                        "username": "luyao0604",
                        "content": "Many of the trees generated for the test cases are wrong. And why is the minDepth defined as distance to its nearest child without any children? Why is it NOT distance to its nearest null child? Doesn\\'t that make more sense?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "[@HapticBovine](/HapticBovine) Actually, it seems that the array representation is different, [2,null,3,null,4,null,5,null,6] is supposed to be a simple path from 2->6. The question is, what is this format, and how can we interpret it unambiguously?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I will explain why this is true then flag the above comment since we can't have nice things (ie., a feature to report incorrect Test Cases).\n\nThe depth of a (binary) Tree is the number of edges to the most distant leaf node. A minimum depth should be the number of edges to the closest leaf node.\n\nRe. Test Case 2:\n\nIf the values are given as array elements in the array [2,null,3,null,4,null,5,null,6], and the expected depth is 5, then we must have a tree with minimum depth/height of 5, meaning the path from the root to _every_ leaf must be >= 5, or in other words, the binary tree has a (min) height of 5, meaning there are 5 edges or 6 nodes in the shortest path from the root a the leaf. The smallest tree in which this could occur is a Perfect Binary Tree, in which there are 63 nodes (2^(h+1) - 1 nodes).\n\nHowever the input [2,null,3,null,4,null,5,null,6] only contains 9 nodes!\n\nWhat a PITA, this is a pretty good platform, can you please make (or improve if it exists) a feature to report incorrect test cases? I want a button similar to the \"submit test case\" button."
                    },
                    {
                        "username": "Ekut",
                        "content": "So I read online(stack overflow, wikipedia) that the depth of a node is the number of edges to the root node. How come in this question, the minimum depth is 2 when there is a leaf node that is only one edge away from the root (direct child). \\nI'm probably missing something. I would appreciate if someone could explain.\\nThanks!"
                    },
                    {
                        "username": "nishantv",
                        "content": "No you are not missing anything. The first example seems incorrect."
                    },
                    {
                        "username": "atulgupta002",
                        "content": "Exactly my question. The min depth is 1. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "In this problem the depth is considered the number of nodes present from the root to the leaf node"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "the first test case right? i got the same doubt"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Some tips: if root is null, return 0. Otherwise keep in mind that roots depth starts at 1, not 0.\nOnly check min depth for leaf nodes - meaning a node who has two NULL children. Some people make the mistake of updating min on every single node when they should only update it for leaf nodes.  \nIf you're doing it recursively, you can save runtime by adding in \"If (depth >= min){return;}\" that way you wont check deeper than you need to."
                    }
                ]
            },
            {
                "id": 1568084,
                "content": [
                    {
                        "username": "ewmiao",
                        "content": "I don\\'t know how to show this tree in a graph, and it\\'s hard to believe that its min depth is 5. However, my code fails on this test case. Anyone explains to me?\\n\\nExample 2:\\n\\nInput: root = [2,null,3,null,4,null,5,null,6]\\nOutput: 5"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "[@huttarl](/huttarl)  The second example shows a Binary tree that is \\'right skewed\\'. [2-3-4-5-6] 6 being the leaf node with min height 5."
                    },
                    {
                        "username": "huttarl",
                        "content": "[@ronitak33](/ronitak33) Unfortunately this would give a tree in which the nodes labeled \"4\" and \"6\" have no parents."
                    },
                    {
                        "username": "huttarl",
                        "content": "Unfortunately, the \"input\" in the test cases, an array of ints, is not the same as the parameter passed to minDepth(), which is the root node of a tree. And Leetcode doesn't seem to define how the format of the test case \"input\" translates into a tree. In another problem, it was stored like this: https://en.wikipedia.org/wiki/Binary_tree#Arrays, where node i is the parent of nodes 2i+1 and 2i+2. But in this case, that would mean the nodes with values \"4\" and \"6\" have null parents (which apparently means no parents). The data structure (in Kotlin at least) doesn't allow nodes with null values.\nWe could then guess that the array omits values for nodes whose parents don't exist. But we shouldn't have to *guess* about the meaning of the example input."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "We\\'re looking for the minimum depth of a binary tree from root to leaf. The keyword here is leaf. A leaf is a node that contains no children nodes. So 2 - 3 - 4 - 5 aren\\'t leafs, but 6 is. Once you get to 6 you have a depth of 5, and since that is the only leaf - 5 is what you return."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) Can please explain the logic behind this?"
                    },
                    {
                        "username": "deepti21aug",
                        "content": "[@mariam_meky](/mariam_meky)  I guess it should be 0."
                    },
                    {
                        "username": "mariam_meky",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) what does \"ans\" stand for?"
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": "bro this input is a skwe tree where probably your code is getting struck as node having one children the other children depth is considered 0 zero. try this solution\\n if(root== NULL){\\n            return ans;\\n        }\\n        int l=minDepth(root->left); \\n        int r=minDepth(root->right);\\n        if((l==0 && r==0) || (l!=0 && r!=0))\\n        return 1+min(l,r);\\n\\n        return  1+max(l,r);"
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form...this is like a linked list forming to the right."
                    },
                    {
                        "username": "mkohar",
                        "content": "you can paste above in testcase and leetcode will show you a visual representation of the graph"
                    },
                    {
                        "username": "ahmedelewa79",
                        "content": "the left child for any index will be ( 2*idx + 1)\\nand the right child will be (2*idx + 2)\\nand you can get the parent element for any child by Math.floor((idx-1)/2)"
                    },
                    {
                        "username": "Oliviaaa-EPFL",
                        "content": "This tree is actually a line (2->3->4->5->6). If your answer is 1, you are counting the node with only one child as the leave, so the recursion returns at the first node."
                    },
                    {
                        "username": "nik-1207",
                        "content": "please anyone can explain why the minimum height of the tree [2,null,3,null,4,null,5,null,6] is 5 not 1"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree\n2->3->4->5->6\nnon of these elements have a left child, only right child is available;\n2\n->3\n -->4\n ---->5\n  ----->6\nthis is the representation"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "because bro we see the leaf node which have both child null "
                    },
                    {
                        "username": "matthewmcconaha",
                        "content": "Let's define a \"leaf node\" as a node which does not have any children. So for a leaf node, left is null and right is also null.\nThen let's define the depth of any node as being the number of layers down the tree you have to travel in order to reach that node, starting at 1. So the very top of the tree is at depth 1, the next layer is depth 2, and so on.\nFinally, let's define the minimum depth as the tree as the leaf node with the minimum depth.\n\nIn the example you reference, the top node is not a leaf node. left is null, but right is not null. So the depth can't be 1. There is actually only one leaf node in that tree, and it is at depth 5.\n\nThe answer of 1 would be for the depth where you run into the first \"closed road\". The first time you see a path that you cannot take because the node in that direction is null. However, there is still an \"open road\" in the other direction, so you need to go down that other road. What you are looking for is a \"dead end\", when both possible roads are closed and you cannot go any deeper."
                    },
                    {
                        "username": "mattesko",
                        "content": "The depth of a tree starts at 0 and not at 1! A \\'tree\\' with only a root node and no children is a tree with depth 0, not 1 like the solution entails!\\n\\nhttps://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height"
                    },
                    {
                        "username": "huttarl",
                        "content": "It may be common to define the depth of a tree the way you do, but the description for this problem clearly defines the minimum depth as the number of **nodes** along the shortest path from root to nearest leaf."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Over the years I have seen mix of people: those who use height as in \"height of nodes\", and then \"height of edges\" which causes the 0/1 difference. It is better to clarify which ones is intended one."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Ultron03](/Ultron03) this question says that depth is the number of nodes whereas in the tree properties it said it would the number of edges"
                    },
                    {
                        "username": "Ultron03",
                        "content": "But in this question it is given that if only root node is there the  depth will be 1!!..\\n"
                    },
                    {
                        "username": "msu227",
                        "content": "I dont know if I am seeing this wrong but the example  [2,null,3,null,4,null,5,null,6] is a a bad test case. How doess a null node have a left and right node???? Also even if it the null node is accounted for how is the mindepth 5 for this it should 3 if the null nodes are accounted for and 1 if they aren\\'t accounted for. Am I seeing this wrong or is this actually wrong. Someone please let me know!!![image](https://assets.leetcode.com/users/images/e132a50d-2ded-4656-a11a-2125b9545062_1613348516.5328968.png)\\n"
                    },
                    {
                        "username": "huttarl",
                        "content": "[@joelmathew2809](/joelmathew2809) Thank you. I didn\\'t know about this. Too bad you have to open a different panel to understand the examples given in the problem. But it\\'s better than nothing."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "FUN FACT !\nThe test case panel also renders the tree for you. This way you can clearly understand what this input means. The input here is pretty confusing but it is just for representation. "
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form"
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "[@user2244fP](/user2244fP) \\n\\nno no the null node is not accounted for ,  basically here the left node of every node in the given tree is null \\nbut there will exsist a right node , only number 6 has its left as well as right value as null \\n\\nso , this tree kinda looks like a linked list \\n2-> 3 -> 4 -> 5 -> 6 , hence depth of this will be five \\n\\n"
                    },
                    {
                        "username": "user2244fP",
                        "content": "So I wasn\\'t the only one who faced this."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Learn data structure. It\\'s quite standard. But pay attention to NULL"
                    },
                    {
                        "username": "sreejeet",
                        "content": "1. Why is 2 the answer for test case [1,2]?\\nA: Because the path has to contain *the root* and *a leaf node*. So the path on the right does not count, as it does not contain a leaf node.\\n\\n2. The depth definition is wrong!\\nA: Yes the definition seems wrong, the qustion is wrongly worded; they simply mean the number of nodes in the path to the nearest leaf node. Try to understand it this way: a tree with no root (no nodes) has no depth, therefore 0 depth. A tree with at least 1 node has 1 depth and so on."
                    },
                    {
                        "username": "DemonLeo",
                        "content": "where [1,2]`s  Minimum Depth is 2\\uFF1F"
                    },
                    {
                        "username": "Leetcode_Wat",
                        "content": "The question requires to count the \"number of nodes\" from root to its nearest leaf node. It contains 2 nodes in your given example."
                    },
                    {
                        "username": "luyao0604",
                        "content": "Many of the trees generated for the test cases are wrong. And why is the minDepth defined as distance to its nearest child without any children? Why is it NOT distance to its nearest null child? Doesn\\'t that make more sense?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "[@HapticBovine](/HapticBovine) Actually, it seems that the array representation is different, [2,null,3,null,4,null,5,null,6] is supposed to be a simple path from 2->6. The question is, what is this format, and how can we interpret it unambiguously?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I will explain why this is true then flag the above comment since we can't have nice things (ie., a feature to report incorrect Test Cases).\n\nThe depth of a (binary) Tree is the number of edges to the most distant leaf node. A minimum depth should be the number of edges to the closest leaf node.\n\nRe. Test Case 2:\n\nIf the values are given as array elements in the array [2,null,3,null,4,null,5,null,6], and the expected depth is 5, then we must have a tree with minimum depth/height of 5, meaning the path from the root to _every_ leaf must be >= 5, or in other words, the binary tree has a (min) height of 5, meaning there are 5 edges or 6 nodes in the shortest path from the root a the leaf. The smallest tree in which this could occur is a Perfect Binary Tree, in which there are 63 nodes (2^(h+1) - 1 nodes).\n\nHowever the input [2,null,3,null,4,null,5,null,6] only contains 9 nodes!\n\nWhat a PITA, this is a pretty good platform, can you please make (or improve if it exists) a feature to report incorrect test cases? I want a button similar to the \"submit test case\" button."
                    },
                    {
                        "username": "Ekut",
                        "content": "So I read online(stack overflow, wikipedia) that the depth of a node is the number of edges to the root node. How come in this question, the minimum depth is 2 when there is a leaf node that is only one edge away from the root (direct child). \\nI'm probably missing something. I would appreciate if someone could explain.\\nThanks!"
                    },
                    {
                        "username": "nishantv",
                        "content": "No you are not missing anything. The first example seems incorrect."
                    },
                    {
                        "username": "atulgupta002",
                        "content": "Exactly my question. The min depth is 1. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "In this problem the depth is considered the number of nodes present from the root to the leaf node"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "the first test case right? i got the same doubt"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Some tips: if root is null, return 0. Otherwise keep in mind that roots depth starts at 1, not 0.\nOnly check min depth for leaf nodes - meaning a node who has two NULL children. Some people make the mistake of updating min on every single node when they should only update it for leaf nodes.  \nIf you're doing it recursively, you can save runtime by adding in \"If (depth >= min){return;}\" that way you wont check deeper than you need to."
                    }
                ]
            },
            {
                "id": 1567859,
                "content": [
                    {
                        "username": "ewmiao",
                        "content": "I don\\'t know how to show this tree in a graph, and it\\'s hard to believe that its min depth is 5. However, my code fails on this test case. Anyone explains to me?\\n\\nExample 2:\\n\\nInput: root = [2,null,3,null,4,null,5,null,6]\\nOutput: 5"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "[@huttarl](/huttarl)  The second example shows a Binary tree that is \\'right skewed\\'. [2-3-4-5-6] 6 being the leaf node with min height 5."
                    },
                    {
                        "username": "huttarl",
                        "content": "[@ronitak33](/ronitak33) Unfortunately this would give a tree in which the nodes labeled \"4\" and \"6\" have no parents."
                    },
                    {
                        "username": "huttarl",
                        "content": "Unfortunately, the \"input\" in the test cases, an array of ints, is not the same as the parameter passed to minDepth(), which is the root node of a tree. And Leetcode doesn't seem to define how the format of the test case \"input\" translates into a tree. In another problem, it was stored like this: https://en.wikipedia.org/wiki/Binary_tree#Arrays, where node i is the parent of nodes 2i+1 and 2i+2. But in this case, that would mean the nodes with values \"4\" and \"6\" have null parents (which apparently means no parents). The data structure (in Kotlin at least) doesn't allow nodes with null values.\nWe could then guess that the array omits values for nodes whose parents don't exist. But we shouldn't have to *guess* about the meaning of the example input."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "We\\'re looking for the minimum depth of a binary tree from root to leaf. The keyword here is leaf. A leaf is a node that contains no children nodes. So 2 - 3 - 4 - 5 aren\\'t leafs, but 6 is. Once you get to 6 you have a depth of 5, and since that is the only leaf - 5 is what you return."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) Can please explain the logic behind this?"
                    },
                    {
                        "username": "deepti21aug",
                        "content": "[@mariam_meky](/mariam_meky)  I guess it should be 0."
                    },
                    {
                        "username": "mariam_meky",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) what does \"ans\" stand for?"
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": "bro this input is a skwe tree where probably your code is getting struck as node having one children the other children depth is considered 0 zero. try this solution\\n if(root== NULL){\\n            return ans;\\n        }\\n        int l=minDepth(root->left); \\n        int r=minDepth(root->right);\\n        if((l==0 && r==0) || (l!=0 && r!=0))\\n        return 1+min(l,r);\\n\\n        return  1+max(l,r);"
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form...this is like a linked list forming to the right."
                    },
                    {
                        "username": "mkohar",
                        "content": "you can paste above in testcase and leetcode will show you a visual representation of the graph"
                    },
                    {
                        "username": "ahmedelewa79",
                        "content": "the left child for any index will be ( 2*idx + 1)\\nand the right child will be (2*idx + 2)\\nand you can get the parent element for any child by Math.floor((idx-1)/2)"
                    },
                    {
                        "username": "Oliviaaa-EPFL",
                        "content": "This tree is actually a line (2->3->4->5->6). If your answer is 1, you are counting the node with only one child as the leave, so the recursion returns at the first node."
                    },
                    {
                        "username": "nik-1207",
                        "content": "please anyone can explain why the minimum height of the tree [2,null,3,null,4,null,5,null,6] is 5 not 1"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree\n2->3->4->5->6\nnon of these elements have a left child, only right child is available;\n2\n->3\n -->4\n ---->5\n  ----->6\nthis is the representation"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "because bro we see the leaf node which have both child null "
                    },
                    {
                        "username": "matthewmcconaha",
                        "content": "Let's define a \"leaf node\" as a node which does not have any children. So for a leaf node, left is null and right is also null.\nThen let's define the depth of any node as being the number of layers down the tree you have to travel in order to reach that node, starting at 1. So the very top of the tree is at depth 1, the next layer is depth 2, and so on.\nFinally, let's define the minimum depth as the tree as the leaf node with the minimum depth.\n\nIn the example you reference, the top node is not a leaf node. left is null, but right is not null. So the depth can't be 1. There is actually only one leaf node in that tree, and it is at depth 5.\n\nThe answer of 1 would be for the depth where you run into the first \"closed road\". The first time you see a path that you cannot take because the node in that direction is null. However, there is still an \"open road\" in the other direction, so you need to go down that other road. What you are looking for is a \"dead end\", when both possible roads are closed and you cannot go any deeper."
                    },
                    {
                        "username": "mattesko",
                        "content": "The depth of a tree starts at 0 and not at 1! A \\'tree\\' with only a root node and no children is a tree with depth 0, not 1 like the solution entails!\\n\\nhttps://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height"
                    },
                    {
                        "username": "huttarl",
                        "content": "It may be common to define the depth of a tree the way you do, but the description for this problem clearly defines the minimum depth as the number of **nodes** along the shortest path from root to nearest leaf."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Over the years I have seen mix of people: those who use height as in \"height of nodes\", and then \"height of edges\" which causes the 0/1 difference. It is better to clarify which ones is intended one."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Ultron03](/Ultron03) this question says that depth is the number of nodes whereas in the tree properties it said it would the number of edges"
                    },
                    {
                        "username": "Ultron03",
                        "content": "But in this question it is given that if only root node is there the  depth will be 1!!..\\n"
                    },
                    {
                        "username": "msu227",
                        "content": "I dont know if I am seeing this wrong but the example  [2,null,3,null,4,null,5,null,6] is a a bad test case. How doess a null node have a left and right node???? Also even if it the null node is accounted for how is the mindepth 5 for this it should 3 if the null nodes are accounted for and 1 if they aren\\'t accounted for. Am I seeing this wrong or is this actually wrong. Someone please let me know!!![image](https://assets.leetcode.com/users/images/e132a50d-2ded-4656-a11a-2125b9545062_1613348516.5328968.png)\\n"
                    },
                    {
                        "username": "huttarl",
                        "content": "[@joelmathew2809](/joelmathew2809) Thank you. I didn\\'t know about this. Too bad you have to open a different panel to understand the examples given in the problem. But it\\'s better than nothing."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "FUN FACT !\nThe test case panel also renders the tree for you. This way you can clearly understand what this input means. The input here is pretty confusing but it is just for representation. "
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form"
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "[@user2244fP](/user2244fP) \\n\\nno no the null node is not accounted for ,  basically here the left node of every node in the given tree is null \\nbut there will exsist a right node , only number 6 has its left as well as right value as null \\n\\nso , this tree kinda looks like a linked list \\n2-> 3 -> 4 -> 5 -> 6 , hence depth of this will be five \\n\\n"
                    },
                    {
                        "username": "user2244fP",
                        "content": "So I wasn\\'t the only one who faced this."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Learn data structure. It\\'s quite standard. But pay attention to NULL"
                    },
                    {
                        "username": "sreejeet",
                        "content": "1. Why is 2 the answer for test case [1,2]?\\nA: Because the path has to contain *the root* and *a leaf node*. So the path on the right does not count, as it does not contain a leaf node.\\n\\n2. The depth definition is wrong!\\nA: Yes the definition seems wrong, the qustion is wrongly worded; they simply mean the number of nodes in the path to the nearest leaf node. Try to understand it this way: a tree with no root (no nodes) has no depth, therefore 0 depth. A tree with at least 1 node has 1 depth and so on."
                    },
                    {
                        "username": "DemonLeo",
                        "content": "where [1,2]`s  Minimum Depth is 2\\uFF1F"
                    },
                    {
                        "username": "Leetcode_Wat",
                        "content": "The question requires to count the \"number of nodes\" from root to its nearest leaf node. It contains 2 nodes in your given example."
                    },
                    {
                        "username": "luyao0604",
                        "content": "Many of the trees generated for the test cases are wrong. And why is the minDepth defined as distance to its nearest child without any children? Why is it NOT distance to its nearest null child? Doesn\\'t that make more sense?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "[@HapticBovine](/HapticBovine) Actually, it seems that the array representation is different, [2,null,3,null,4,null,5,null,6] is supposed to be a simple path from 2->6. The question is, what is this format, and how can we interpret it unambiguously?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I will explain why this is true then flag the above comment since we can't have nice things (ie., a feature to report incorrect Test Cases).\n\nThe depth of a (binary) Tree is the number of edges to the most distant leaf node. A minimum depth should be the number of edges to the closest leaf node.\n\nRe. Test Case 2:\n\nIf the values are given as array elements in the array [2,null,3,null,4,null,5,null,6], and the expected depth is 5, then we must have a tree with minimum depth/height of 5, meaning the path from the root to _every_ leaf must be >= 5, or in other words, the binary tree has a (min) height of 5, meaning there are 5 edges or 6 nodes in the shortest path from the root a the leaf. The smallest tree in which this could occur is a Perfect Binary Tree, in which there are 63 nodes (2^(h+1) - 1 nodes).\n\nHowever the input [2,null,3,null,4,null,5,null,6] only contains 9 nodes!\n\nWhat a PITA, this is a pretty good platform, can you please make (or improve if it exists) a feature to report incorrect test cases? I want a button similar to the \"submit test case\" button."
                    },
                    {
                        "username": "Ekut",
                        "content": "So I read online(stack overflow, wikipedia) that the depth of a node is the number of edges to the root node. How come in this question, the minimum depth is 2 when there is a leaf node that is only one edge away from the root (direct child). \\nI'm probably missing something. I would appreciate if someone could explain.\\nThanks!"
                    },
                    {
                        "username": "nishantv",
                        "content": "No you are not missing anything. The first example seems incorrect."
                    },
                    {
                        "username": "atulgupta002",
                        "content": "Exactly my question. The min depth is 1. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "In this problem the depth is considered the number of nodes present from the root to the leaf node"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "the first test case right? i got the same doubt"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Some tips: if root is null, return 0. Otherwise keep in mind that roots depth starts at 1, not 0.\nOnly check min depth for leaf nodes - meaning a node who has two NULL children. Some people make the mistake of updating min on every single node when they should only update it for leaf nodes.  \nIf you're doing it recursively, you can save runtime by adding in \"If (depth >= min){return;}\" that way you wont check deeper than you need to."
                    }
                ]
            },
            {
                "id": 1963683,
                "content": [
                    {
                        "username": "ewmiao",
                        "content": "I don\\'t know how to show this tree in a graph, and it\\'s hard to believe that its min depth is 5. However, my code fails on this test case. Anyone explains to me?\\n\\nExample 2:\\n\\nInput: root = [2,null,3,null,4,null,5,null,6]\\nOutput: 5"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "[@huttarl](/huttarl)  The second example shows a Binary tree that is \\'right skewed\\'. [2-3-4-5-6] 6 being the leaf node with min height 5."
                    },
                    {
                        "username": "huttarl",
                        "content": "[@ronitak33](/ronitak33) Unfortunately this would give a tree in which the nodes labeled \"4\" and \"6\" have no parents."
                    },
                    {
                        "username": "huttarl",
                        "content": "Unfortunately, the \"input\" in the test cases, an array of ints, is not the same as the parameter passed to minDepth(), which is the root node of a tree. And Leetcode doesn't seem to define how the format of the test case \"input\" translates into a tree. In another problem, it was stored like this: https://en.wikipedia.org/wiki/Binary_tree#Arrays, where node i is the parent of nodes 2i+1 and 2i+2. But in this case, that would mean the nodes with values \"4\" and \"6\" have null parents (which apparently means no parents). The data structure (in Kotlin at least) doesn't allow nodes with null values.\nWe could then guess that the array omits values for nodes whose parents don't exist. But we shouldn't have to *guess* about the meaning of the example input."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "We\\'re looking for the minimum depth of a binary tree from root to leaf. The keyword here is leaf. A leaf is a node that contains no children nodes. So 2 - 3 - 4 - 5 aren\\'t leafs, but 6 is. Once you get to 6 you have a depth of 5, and since that is the only leaf - 5 is what you return."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) Can please explain the logic behind this?"
                    },
                    {
                        "username": "deepti21aug",
                        "content": "[@mariam_meky](/mariam_meky)  I guess it should be 0."
                    },
                    {
                        "username": "mariam_meky",
                        "content": "[@LEOFRAGGER](/LEOFRAGGER) what does \"ans\" stand for?"
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": "bro this input is a skwe tree where probably your code is getting struck as node having one children the other children depth is considered 0 zero. try this solution\\n if(root== NULL){\\n            return ans;\\n        }\\n        int l=minDepth(root->left); \\n        int r=minDepth(root->right);\\n        if((l==0 && r==0) || (l!=0 && r!=0))\\n        return 1+min(l,r);\\n\\n        return  1+max(l,r);"
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form...this is like a linked list forming to the right."
                    },
                    {
                        "username": "mkohar",
                        "content": "you can paste above in testcase and leetcode will show you a visual representation of the graph"
                    },
                    {
                        "username": "ahmedelewa79",
                        "content": "the left child for any index will be ( 2*idx + 1)\\nand the right child will be (2*idx + 2)\\nand you can get the parent element for any child by Math.floor((idx-1)/2)"
                    },
                    {
                        "username": "Oliviaaa-EPFL",
                        "content": "This tree is actually a line (2->3->4->5->6). If your answer is 1, you are counting the node with only one child as the leave, so the recursion returns at the first node."
                    },
                    {
                        "username": "nik-1207",
                        "content": "please anyone can explain why the minimum height of the tree [2,null,3,null,4,null,5,null,6] is 5 not 1"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "its a right skewed binary tree\n2->3->4->5->6\nnon of these elements have a left child, only right child is available;\n2\n->3\n -->4\n ---->5\n  ----->6\nthis is the representation"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "because bro we see the leaf node which have both child null "
                    },
                    {
                        "username": "matthewmcconaha",
                        "content": "Let's define a \"leaf node\" as a node which does not have any children. So for a leaf node, left is null and right is also null.\nThen let's define the depth of any node as being the number of layers down the tree you have to travel in order to reach that node, starting at 1. So the very top of the tree is at depth 1, the next layer is depth 2, and so on.\nFinally, let's define the minimum depth as the tree as the leaf node with the minimum depth.\n\nIn the example you reference, the top node is not a leaf node. left is null, but right is not null. So the depth can't be 1. There is actually only one leaf node in that tree, and it is at depth 5.\n\nThe answer of 1 would be for the depth where you run into the first \"closed road\". The first time you see a path that you cannot take because the node in that direction is null. However, there is still an \"open road\" in the other direction, so you need to go down that other road. What you are looking for is a \"dead end\", when both possible roads are closed and you cannot go any deeper."
                    },
                    {
                        "username": "mattesko",
                        "content": "The depth of a tree starts at 0 and not at 1! A \\'tree\\' with only a root node and no children is a tree with depth 0, not 1 like the solution entails!\\n\\nhttps://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height"
                    },
                    {
                        "username": "huttarl",
                        "content": "It may be common to define the depth of a tree the way you do, but the description for this problem clearly defines the minimum depth as the number of **nodes** along the shortest path from root to nearest leaf."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Over the years I have seen mix of people: those who use height as in \"height of nodes\", and then \"height of edges\" which causes the 0/1 difference. It is better to clarify which ones is intended one."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Ultron03](/Ultron03) this question says that depth is the number of nodes whereas in the tree properties it said it would the number of edges"
                    },
                    {
                        "username": "Ultron03",
                        "content": "But in this question it is given that if only root node is there the  depth will be 1!!..\\n"
                    },
                    {
                        "username": "msu227",
                        "content": "I dont know if I am seeing this wrong but the example  [2,null,3,null,4,null,5,null,6] is a a bad test case. How doess a null node have a left and right node???? Also even if it the null node is accounted for how is the mindepth 5 for this it should 3 if the null nodes are accounted for and 1 if they aren\\'t accounted for. Am I seeing this wrong or is this actually wrong. Someone please let me know!!![image](https://assets.leetcode.com/users/images/e132a50d-2ded-4656-a11a-2125b9545062_1613348516.5328968.png)\\n"
                    },
                    {
                        "username": "huttarl",
                        "content": "[@joelmathew2809](/joelmathew2809) Thank you. I didn\\'t know about this. Too bad you have to open a different panel to understand the examples given in the problem. But it\\'s better than nothing."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "FUN FACT !\nThe test case panel also renders the tree for you. This way you can clearly understand what this input means. The input here is pretty confusing but it is just for representation. "
                    },
                    {
                        "username": "ronitak33",
                        "content": "the input is in the format [root, root->left, root->right, root->left->left, root->left->right, root->right->left, root->right->right] and so on try drawing a tree in this form"
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "[@user2244fP](/user2244fP) \\n\\nno no the null node is not accounted for ,  basically here the left node of every node in the given tree is null \\nbut there will exsist a right node , only number 6 has its left as well as right value as null \\n\\nso , this tree kinda looks like a linked list \\n2-> 3 -> 4 -> 5 -> 6 , hence depth of this will be five \\n\\n"
                    },
                    {
                        "username": "user2244fP",
                        "content": "So I wasn\\'t the only one who faced this."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Learn data structure. It\\'s quite standard. But pay attention to NULL"
                    },
                    {
                        "username": "sreejeet",
                        "content": "1. Why is 2 the answer for test case [1,2]?\\nA: Because the path has to contain *the root* and *a leaf node*. So the path on the right does not count, as it does not contain a leaf node.\\n\\n2. The depth definition is wrong!\\nA: Yes the definition seems wrong, the qustion is wrongly worded; they simply mean the number of nodes in the path to the nearest leaf node. Try to understand it this way: a tree with no root (no nodes) has no depth, therefore 0 depth. A tree with at least 1 node has 1 depth and so on."
                    },
                    {
                        "username": "DemonLeo",
                        "content": "where [1,2]`s  Minimum Depth is 2\\uFF1F"
                    },
                    {
                        "username": "Leetcode_Wat",
                        "content": "The question requires to count the \"number of nodes\" from root to its nearest leaf node. It contains 2 nodes in your given example."
                    },
                    {
                        "username": "luyao0604",
                        "content": "Many of the trees generated for the test cases are wrong. And why is the minDepth defined as distance to its nearest child without any children? Why is it NOT distance to its nearest null child? Doesn\\'t that make more sense?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "[@HapticBovine](/HapticBovine) Actually, it seems that the array representation is different, [2,null,3,null,4,null,5,null,6] is supposed to be a simple path from 2->6. The question is, what is this format, and how can we interpret it unambiguously?"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I will explain why this is true then flag the above comment since we can't have nice things (ie., a feature to report incorrect Test Cases).\n\nThe depth of a (binary) Tree is the number of edges to the most distant leaf node. A minimum depth should be the number of edges to the closest leaf node.\n\nRe. Test Case 2:\n\nIf the values are given as array elements in the array [2,null,3,null,4,null,5,null,6], and the expected depth is 5, then we must have a tree with minimum depth/height of 5, meaning the path from the root to _every_ leaf must be >= 5, or in other words, the binary tree has a (min) height of 5, meaning there are 5 edges or 6 nodes in the shortest path from the root a the leaf. The smallest tree in which this could occur is a Perfect Binary Tree, in which there are 63 nodes (2^(h+1) - 1 nodes).\n\nHowever the input [2,null,3,null,4,null,5,null,6] only contains 9 nodes!\n\nWhat a PITA, this is a pretty good platform, can you please make (or improve if it exists) a feature to report incorrect test cases? I want a button similar to the \"submit test case\" button."
                    },
                    {
                        "username": "Ekut",
                        "content": "So I read online(stack overflow, wikipedia) that the depth of a node is the number of edges to the root node. How come in this question, the minimum depth is 2 when there is a leaf node that is only one edge away from the root (direct child). \\nI'm probably missing something. I would appreciate if someone could explain.\\nThanks!"
                    },
                    {
                        "username": "nishantv",
                        "content": "No you are not missing anything. The first example seems incorrect."
                    },
                    {
                        "username": "atulgupta002",
                        "content": "Exactly my question. The min depth is 1. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "In this problem the depth is considered the number of nodes present from the root to the leaf node"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "the first test case right? i got the same doubt"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Some tips: if root is null, return 0. Otherwise keep in mind that roots depth starts at 1, not 0.\nOnly check min depth for leaf nodes - meaning a node who has two NULL children. Some people make the mistake of updating min on every single node when they should only update it for leaf nodes.  \nIf you're doing it recursively, you can save runtime by adding in \"If (depth >= min){return;}\" that way you wont check deeper than you need to."
                    }
                ]
            },
            {
                "id": 1963977,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "First experience working with trees.... I liked it, but should this really be considered an easy problem?  Trees kinda seem like an intermediate topic NGL"
                    },
                    {
                        "username": "ogcooke",
                        "content": "yes, simple traversals without modifications should be considered easy. don\\'t worry, proficiency comes with experience)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Recursively traversing trees to collect data (height, node count etc) is a pretty standard operation. Practice a few problems like these and you will also find this easy."
                    },
                    {
                        "username": "Abdul_Muktadir_Bhuyan",
                        "content": "How in the name of god this problem is easy, this should intermediate. "
                    },
                    {
                        "username": "bortengineer",
                        "content": "The output for the test case \"[]\" should not be the 0. As stated in the problem: The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node (A leaf is a node with no children). So for \"[]\"  not such path exist, as there are no leaf nodes, so \"0\" is incorrect."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Yes, it should  be -1, cause the length of path between two nonexistent places is not 0, it is *undefined*"
                    },
                    {
                        "username": "psionl0",
                        "content": "Any other number you returned from an empty tree would also be \"incorrect\". However, this is the only time you have to worry about what to return. In all other cases, there is an actual root node and a path to a leaf node."
                    },
                    {
                        "username": "rbenb",
                        "content": "Yeah this one doesn't make sense, I'm using swift and since TreeNode() results in val being 0, running this with my local compiler/Xcode results in a different answer.  For the leetcode solution I had to write if root == nil || root?.val == nil { return 0 } to pass the test case, but the initializer for TreeNode sets val to 0 so that shouldn't work.  Don't know why it does here.  Based on their definition of a TreeNode, [] and [0] both are the same.   Both nodes have a val of 0.  Maybe it means to input nil instead of TreeNode()?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "In my opinion, the \"minimum depth\" of a null tree is not properly defined in the problem statement.\\n\\nIn one sense, the depth of the tree could be considered zero, but to my knowledge, a null node is not a leaf node (if there is a definition for this, I would appreciate if someone could point to a reference for that).\\n\\nIf a null node cannot itself be considered a leaf node, then there is no distance which could be traversed to reach a leaf node, so the distance is undefined."
                    },
                    {
                        "username": "OnlyFaangs",
                        "content": "What does \"Optional\" stand for in function definition *minDepth(self, root: **Optional**[TreeNode])*?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "That means that the type of `root` can be either a `TreeNode` or `None` : it\\'s up to you to check what has been passed to the function."
                    },
                    {
                        "username": "theMonkbphc",
                        "content": "Minimum Depth of Binary Tree problem:\\nI have coded a BFS solution to this and my runtime is 680ms. Checking the runtime distribution, I found some solutions claiming ~30ms using DFS. Logically, it doesnt make sense. I coded the same and resubmitted. My runtime was now around 780ms. What is the deal here? Can someone explain the runtime distribution graph\\'s behaviour over here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The programming language used for your solution is a major factor in the time taken."
                    },
                    {
                        "username": "user3918M",
                        "content": "I am confused with this input [1,2,3,4,5]. Could anyone tell me how the tree looks like? Is it same as [1,2,3,4,5,null,null]?"
                    },
                    {
                        "username": "Rishil96",
                        "content": "starting with 1 every node moving ahead will be the right child as its greater than its parent and 5 is the last node so it will have both children as null"
                    },
                    {
                        "username": "user4191LD",
                        "content": "yes"
                    },
                    {
                        "username": "JerryYe",
                        "content": "why we can\\'t regard the root node as a part of  left tree or right tree?\\nI think it\\'s resonable.Could someone help me ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "When we talk about a binary tree, we usually conceptualize it in terms of a root node and its two subtrees: the left subtree and the right subtree. The root node is seen as a separate entity that connects these two subtrees.\\n\\nThis view of the binary tree is useful for recursive algorithms, where we solve a problem on the tree by solving the same problem on the left subtree and the right subtree and combining these solutions in some way.\\n\\nFrom another perspective, you could say that the root node is part of both the left and right subtrees, because it is an ancestor of all nodes in both subtrees. But this viewpoint is less useful for most algorithmic problems on binary trees, because it doesn\\'t allow us to easily divide the tree into smaller parts that we can solve independently.\\n\\nIn the end, whether we regard the root as part of the left subtree, the right subtree, both, or neither depends on what is most useful for the problem we are trying to solve. However, the conventional view is to see the root as a separate entity that connects the left and right subtrees, and this view is the most useful in a majority of cases."
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "Question rephrase: Find number of nodes between root node and nearest leaf node from the root node (both included)"
                    },
                    {
                        "username": "aryan_",
                        "content": "yeah that\\'s the correct way \\n"
                    },
                    {
                        "username": "rauanktl",
                        "content": "Monday\\'s cakewalk :)"
                    }
                ]
            },
            {
                "id": 1873889,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "First experience working with trees.... I liked it, but should this really be considered an easy problem?  Trees kinda seem like an intermediate topic NGL"
                    },
                    {
                        "username": "ogcooke",
                        "content": "yes, simple traversals without modifications should be considered easy. don\\'t worry, proficiency comes with experience)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Recursively traversing trees to collect data (height, node count etc) is a pretty standard operation. Practice a few problems like these and you will also find this easy."
                    },
                    {
                        "username": "Abdul_Muktadir_Bhuyan",
                        "content": "How in the name of god this problem is easy, this should intermediate. "
                    },
                    {
                        "username": "bortengineer",
                        "content": "The output for the test case \"[]\" should not be the 0. As stated in the problem: The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node (A leaf is a node with no children). So for \"[]\"  not such path exist, as there are no leaf nodes, so \"0\" is incorrect."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Yes, it should  be -1, cause the length of path between two nonexistent places is not 0, it is *undefined*"
                    },
                    {
                        "username": "psionl0",
                        "content": "Any other number you returned from an empty tree would also be \"incorrect\". However, this is the only time you have to worry about what to return. In all other cases, there is an actual root node and a path to a leaf node."
                    },
                    {
                        "username": "rbenb",
                        "content": "Yeah this one doesn't make sense, I'm using swift and since TreeNode() results in val being 0, running this with my local compiler/Xcode results in a different answer.  For the leetcode solution I had to write if root == nil || root?.val == nil { return 0 } to pass the test case, but the initializer for TreeNode sets val to 0 so that shouldn't work.  Don't know why it does here.  Based on their definition of a TreeNode, [] and [0] both are the same.   Both nodes have a val of 0.  Maybe it means to input nil instead of TreeNode()?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "In my opinion, the \"minimum depth\" of a null tree is not properly defined in the problem statement.\\n\\nIn one sense, the depth of the tree could be considered zero, but to my knowledge, a null node is not a leaf node (if there is a definition for this, I would appreciate if someone could point to a reference for that).\\n\\nIf a null node cannot itself be considered a leaf node, then there is no distance which could be traversed to reach a leaf node, so the distance is undefined."
                    },
                    {
                        "username": "OnlyFaangs",
                        "content": "What does \"Optional\" stand for in function definition *minDepth(self, root: **Optional**[TreeNode])*?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "That means that the type of `root` can be either a `TreeNode` or `None` : it\\'s up to you to check what has been passed to the function."
                    },
                    {
                        "username": "theMonkbphc",
                        "content": "Minimum Depth of Binary Tree problem:\\nI have coded a BFS solution to this and my runtime is 680ms. Checking the runtime distribution, I found some solutions claiming ~30ms using DFS. Logically, it doesnt make sense. I coded the same and resubmitted. My runtime was now around 780ms. What is the deal here? Can someone explain the runtime distribution graph\\'s behaviour over here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The programming language used for your solution is a major factor in the time taken."
                    },
                    {
                        "username": "user3918M",
                        "content": "I am confused with this input [1,2,3,4,5]. Could anyone tell me how the tree looks like? Is it same as [1,2,3,4,5,null,null]?"
                    },
                    {
                        "username": "Rishil96",
                        "content": "starting with 1 every node moving ahead will be the right child as its greater than its parent and 5 is the last node so it will have both children as null"
                    },
                    {
                        "username": "user4191LD",
                        "content": "yes"
                    },
                    {
                        "username": "JerryYe",
                        "content": "why we can\\'t regard the root node as a part of  left tree or right tree?\\nI think it\\'s resonable.Could someone help me ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "When we talk about a binary tree, we usually conceptualize it in terms of a root node and its two subtrees: the left subtree and the right subtree. The root node is seen as a separate entity that connects these two subtrees.\\n\\nThis view of the binary tree is useful for recursive algorithms, where we solve a problem on the tree by solving the same problem on the left subtree and the right subtree and combining these solutions in some way.\\n\\nFrom another perspective, you could say that the root node is part of both the left and right subtrees, because it is an ancestor of all nodes in both subtrees. But this viewpoint is less useful for most algorithmic problems on binary trees, because it doesn\\'t allow us to easily divide the tree into smaller parts that we can solve independently.\\n\\nIn the end, whether we regard the root as part of the left subtree, the right subtree, both, or neither depends on what is most useful for the problem we are trying to solve. However, the conventional view is to see the root as a separate entity that connects the left and right subtrees, and this view is the most useful in a majority of cases."
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "Question rephrase: Find number of nodes between root node and nearest leaf node from the root node (both included)"
                    },
                    {
                        "username": "aryan_",
                        "content": "yeah that\\'s the correct way \\n"
                    },
                    {
                        "username": "rauanktl",
                        "content": "Monday\\'s cakewalk :)"
                    }
                ]
            },
            {
                "id": 1815872,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "First experience working with trees.... I liked it, but should this really be considered an easy problem?  Trees kinda seem like an intermediate topic NGL"
                    },
                    {
                        "username": "ogcooke",
                        "content": "yes, simple traversals without modifications should be considered easy. don\\'t worry, proficiency comes with experience)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Recursively traversing trees to collect data (height, node count etc) is a pretty standard operation. Practice a few problems like these and you will also find this easy."
                    },
                    {
                        "username": "Abdul_Muktadir_Bhuyan",
                        "content": "How in the name of god this problem is easy, this should intermediate. "
                    },
                    {
                        "username": "bortengineer",
                        "content": "The output for the test case \"[]\" should not be the 0. As stated in the problem: The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node (A leaf is a node with no children). So for \"[]\"  not such path exist, as there are no leaf nodes, so \"0\" is incorrect."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Yes, it should  be -1, cause the length of path between two nonexistent places is not 0, it is *undefined*"
                    },
                    {
                        "username": "psionl0",
                        "content": "Any other number you returned from an empty tree would also be \"incorrect\". However, this is the only time you have to worry about what to return. In all other cases, there is an actual root node and a path to a leaf node."
                    },
                    {
                        "username": "rbenb",
                        "content": "Yeah this one doesn't make sense, I'm using swift and since TreeNode() results in val being 0, running this with my local compiler/Xcode results in a different answer.  For the leetcode solution I had to write if root == nil || root?.val == nil { return 0 } to pass the test case, but the initializer for TreeNode sets val to 0 so that shouldn't work.  Don't know why it does here.  Based on their definition of a TreeNode, [] and [0] both are the same.   Both nodes have a val of 0.  Maybe it means to input nil instead of TreeNode()?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "In my opinion, the \"minimum depth\" of a null tree is not properly defined in the problem statement.\\n\\nIn one sense, the depth of the tree could be considered zero, but to my knowledge, a null node is not a leaf node (if there is a definition for this, I would appreciate if someone could point to a reference for that).\\n\\nIf a null node cannot itself be considered a leaf node, then there is no distance which could be traversed to reach a leaf node, so the distance is undefined."
                    },
                    {
                        "username": "OnlyFaangs",
                        "content": "What does \"Optional\" stand for in function definition *minDepth(self, root: **Optional**[TreeNode])*?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "That means that the type of `root` can be either a `TreeNode` or `None` : it\\'s up to you to check what has been passed to the function."
                    },
                    {
                        "username": "theMonkbphc",
                        "content": "Minimum Depth of Binary Tree problem:\\nI have coded a BFS solution to this and my runtime is 680ms. Checking the runtime distribution, I found some solutions claiming ~30ms using DFS. Logically, it doesnt make sense. I coded the same and resubmitted. My runtime was now around 780ms. What is the deal here? Can someone explain the runtime distribution graph\\'s behaviour over here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The programming language used for your solution is a major factor in the time taken."
                    },
                    {
                        "username": "user3918M",
                        "content": "I am confused with this input [1,2,3,4,5]. Could anyone tell me how the tree looks like? Is it same as [1,2,3,4,5,null,null]?"
                    },
                    {
                        "username": "Rishil96",
                        "content": "starting with 1 every node moving ahead will be the right child as its greater than its parent and 5 is the last node so it will have both children as null"
                    },
                    {
                        "username": "user4191LD",
                        "content": "yes"
                    },
                    {
                        "username": "JerryYe",
                        "content": "why we can\\'t regard the root node as a part of  left tree or right tree?\\nI think it\\'s resonable.Could someone help me ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "When we talk about a binary tree, we usually conceptualize it in terms of a root node and its two subtrees: the left subtree and the right subtree. The root node is seen as a separate entity that connects these two subtrees.\\n\\nThis view of the binary tree is useful for recursive algorithms, where we solve a problem on the tree by solving the same problem on the left subtree and the right subtree and combining these solutions in some way.\\n\\nFrom another perspective, you could say that the root node is part of both the left and right subtrees, because it is an ancestor of all nodes in both subtrees. But this viewpoint is less useful for most algorithmic problems on binary trees, because it doesn\\'t allow us to easily divide the tree into smaller parts that we can solve independently.\\n\\nIn the end, whether we regard the root as part of the left subtree, the right subtree, both, or neither depends on what is most useful for the problem we are trying to solve. However, the conventional view is to see the root as a separate entity that connects the left and right subtrees, and this view is the most useful in a majority of cases."
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "Question rephrase: Find number of nodes between root node and nearest leaf node from the root node (both included)"
                    },
                    {
                        "username": "aryan_",
                        "content": "yeah that\\'s the correct way \\n"
                    },
                    {
                        "username": "rauanktl",
                        "content": "Monday\\'s cakewalk :)"
                    }
                ]
            },
            {
                "id": 1756941,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "First experience working with trees.... I liked it, but should this really be considered an easy problem?  Trees kinda seem like an intermediate topic NGL"
                    },
                    {
                        "username": "ogcooke",
                        "content": "yes, simple traversals without modifications should be considered easy. don\\'t worry, proficiency comes with experience)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Recursively traversing trees to collect data (height, node count etc) is a pretty standard operation. Practice a few problems like these and you will also find this easy."
                    },
                    {
                        "username": "Abdul_Muktadir_Bhuyan",
                        "content": "How in the name of god this problem is easy, this should intermediate. "
                    },
                    {
                        "username": "bortengineer",
                        "content": "The output for the test case \"[]\" should not be the 0. As stated in the problem: The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node (A leaf is a node with no children). So for \"[]\"  not such path exist, as there are no leaf nodes, so \"0\" is incorrect."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Yes, it should  be -1, cause the length of path between two nonexistent places is not 0, it is *undefined*"
                    },
                    {
                        "username": "psionl0",
                        "content": "Any other number you returned from an empty tree would also be \"incorrect\". However, this is the only time you have to worry about what to return. In all other cases, there is an actual root node and a path to a leaf node."
                    },
                    {
                        "username": "rbenb",
                        "content": "Yeah this one doesn't make sense, I'm using swift and since TreeNode() results in val being 0, running this with my local compiler/Xcode results in a different answer.  For the leetcode solution I had to write if root == nil || root?.val == nil { return 0 } to pass the test case, but the initializer for TreeNode sets val to 0 so that shouldn't work.  Don't know why it does here.  Based on their definition of a TreeNode, [] and [0] both are the same.   Both nodes have a val of 0.  Maybe it means to input nil instead of TreeNode()?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "In my opinion, the \"minimum depth\" of a null tree is not properly defined in the problem statement.\\n\\nIn one sense, the depth of the tree could be considered zero, but to my knowledge, a null node is not a leaf node (if there is a definition for this, I would appreciate if someone could point to a reference for that).\\n\\nIf a null node cannot itself be considered a leaf node, then there is no distance which could be traversed to reach a leaf node, so the distance is undefined."
                    },
                    {
                        "username": "OnlyFaangs",
                        "content": "What does \"Optional\" stand for in function definition *minDepth(self, root: **Optional**[TreeNode])*?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "That means that the type of `root` can be either a `TreeNode` or `None` : it\\'s up to you to check what has been passed to the function."
                    },
                    {
                        "username": "theMonkbphc",
                        "content": "Minimum Depth of Binary Tree problem:\\nI have coded a BFS solution to this and my runtime is 680ms. Checking the runtime distribution, I found some solutions claiming ~30ms using DFS. Logically, it doesnt make sense. I coded the same and resubmitted. My runtime was now around 780ms. What is the deal here? Can someone explain the runtime distribution graph\\'s behaviour over here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The programming language used for your solution is a major factor in the time taken."
                    },
                    {
                        "username": "user3918M",
                        "content": "I am confused with this input [1,2,3,4,5]. Could anyone tell me how the tree looks like? Is it same as [1,2,3,4,5,null,null]?"
                    },
                    {
                        "username": "Rishil96",
                        "content": "starting with 1 every node moving ahead will be the right child as its greater than its parent and 5 is the last node so it will have both children as null"
                    },
                    {
                        "username": "user4191LD",
                        "content": "yes"
                    },
                    {
                        "username": "JerryYe",
                        "content": "why we can\\'t regard the root node as a part of  left tree or right tree?\\nI think it\\'s resonable.Could someone help me ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "When we talk about a binary tree, we usually conceptualize it in terms of a root node and its two subtrees: the left subtree and the right subtree. The root node is seen as a separate entity that connects these two subtrees.\\n\\nThis view of the binary tree is useful for recursive algorithms, where we solve a problem on the tree by solving the same problem on the left subtree and the right subtree and combining these solutions in some way.\\n\\nFrom another perspective, you could say that the root node is part of both the left and right subtrees, because it is an ancestor of all nodes in both subtrees. But this viewpoint is less useful for most algorithmic problems on binary trees, because it doesn\\'t allow us to easily divide the tree into smaller parts that we can solve independently.\\n\\nIn the end, whether we regard the root as part of the left subtree, the right subtree, both, or neither depends on what is most useful for the problem we are trying to solve. However, the conventional view is to see the root as a separate entity that connects the left and right subtrees, and this view is the most useful in a majority of cases."
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "Question rephrase: Find number of nodes between root node and nearest leaf node from the root node (both included)"
                    },
                    {
                        "username": "aryan_",
                        "content": "yeah that\\'s the correct way \\n"
                    },
                    {
                        "username": "rauanktl",
                        "content": "Monday\\'s cakewalk :)"
                    }
                ]
            },
            {
                "id": 1575625,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "First experience working with trees.... I liked it, but should this really be considered an easy problem?  Trees kinda seem like an intermediate topic NGL"
                    },
                    {
                        "username": "ogcooke",
                        "content": "yes, simple traversals without modifications should be considered easy. don\\'t worry, proficiency comes with experience)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Recursively traversing trees to collect data (height, node count etc) is a pretty standard operation. Practice a few problems like these and you will also find this easy."
                    },
                    {
                        "username": "Abdul_Muktadir_Bhuyan",
                        "content": "How in the name of god this problem is easy, this should intermediate. "
                    },
                    {
                        "username": "bortengineer",
                        "content": "The output for the test case \"[]\" should not be the 0. As stated in the problem: The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node (A leaf is a node with no children). So for \"[]\"  not such path exist, as there are no leaf nodes, so \"0\" is incorrect."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Yes, it should  be -1, cause the length of path between two nonexistent places is not 0, it is *undefined*"
                    },
                    {
                        "username": "psionl0",
                        "content": "Any other number you returned from an empty tree would also be \"incorrect\". However, this is the only time you have to worry about what to return. In all other cases, there is an actual root node and a path to a leaf node."
                    },
                    {
                        "username": "rbenb",
                        "content": "Yeah this one doesn't make sense, I'm using swift and since TreeNode() results in val being 0, running this with my local compiler/Xcode results in a different answer.  For the leetcode solution I had to write if root == nil || root?.val == nil { return 0 } to pass the test case, but the initializer for TreeNode sets val to 0 so that shouldn't work.  Don't know why it does here.  Based on their definition of a TreeNode, [] and [0] both are the same.   Both nodes have a val of 0.  Maybe it means to input nil instead of TreeNode()?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "In my opinion, the \"minimum depth\" of a null tree is not properly defined in the problem statement.\\n\\nIn one sense, the depth of the tree could be considered zero, but to my knowledge, a null node is not a leaf node (if there is a definition for this, I would appreciate if someone could point to a reference for that).\\n\\nIf a null node cannot itself be considered a leaf node, then there is no distance which could be traversed to reach a leaf node, so the distance is undefined."
                    },
                    {
                        "username": "OnlyFaangs",
                        "content": "What does \"Optional\" stand for in function definition *minDepth(self, root: **Optional**[TreeNode])*?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "That means that the type of `root` can be either a `TreeNode` or `None` : it\\'s up to you to check what has been passed to the function."
                    },
                    {
                        "username": "theMonkbphc",
                        "content": "Minimum Depth of Binary Tree problem:\\nI have coded a BFS solution to this and my runtime is 680ms. Checking the runtime distribution, I found some solutions claiming ~30ms using DFS. Logically, it doesnt make sense. I coded the same and resubmitted. My runtime was now around 780ms. What is the deal here? Can someone explain the runtime distribution graph\\'s behaviour over here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The programming language used for your solution is a major factor in the time taken."
                    },
                    {
                        "username": "user3918M",
                        "content": "I am confused with this input [1,2,3,4,5]. Could anyone tell me how the tree looks like? Is it same as [1,2,3,4,5,null,null]?"
                    },
                    {
                        "username": "Rishil96",
                        "content": "starting with 1 every node moving ahead will be the right child as its greater than its parent and 5 is the last node so it will have both children as null"
                    },
                    {
                        "username": "user4191LD",
                        "content": "yes"
                    },
                    {
                        "username": "JerryYe",
                        "content": "why we can\\'t regard the root node as a part of  left tree or right tree?\\nI think it\\'s resonable.Could someone help me ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "When we talk about a binary tree, we usually conceptualize it in terms of a root node and its two subtrees: the left subtree and the right subtree. The root node is seen as a separate entity that connects these two subtrees.\\n\\nThis view of the binary tree is useful for recursive algorithms, where we solve a problem on the tree by solving the same problem on the left subtree and the right subtree and combining these solutions in some way.\\n\\nFrom another perspective, you could say that the root node is part of both the left and right subtrees, because it is an ancestor of all nodes in both subtrees. But this viewpoint is less useful for most algorithmic problems on binary trees, because it doesn\\'t allow us to easily divide the tree into smaller parts that we can solve independently.\\n\\nIn the end, whether we regard the root as part of the left subtree, the right subtree, both, or neither depends on what is most useful for the problem we are trying to solve. However, the conventional view is to see the root as a separate entity that connects the left and right subtrees, and this view is the most useful in a majority of cases."
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "Question rephrase: Find number of nodes between root node and nearest leaf node from the root node (both included)"
                    },
                    {
                        "username": "aryan_",
                        "content": "yeah that\\'s the correct way \\n"
                    },
                    {
                        "username": "rauanktl",
                        "content": "Monday\\'s cakewalk :)"
                    }
                ]
            },
            {
                "id": 1574512,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "First experience working with trees.... I liked it, but should this really be considered an easy problem?  Trees kinda seem like an intermediate topic NGL"
                    },
                    {
                        "username": "ogcooke",
                        "content": "yes, simple traversals without modifications should be considered easy. don\\'t worry, proficiency comes with experience)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Recursively traversing trees to collect data (height, node count etc) is a pretty standard operation. Practice a few problems like these and you will also find this easy."
                    },
                    {
                        "username": "Abdul_Muktadir_Bhuyan",
                        "content": "How in the name of god this problem is easy, this should intermediate. "
                    },
                    {
                        "username": "bortengineer",
                        "content": "The output for the test case \"[]\" should not be the 0. As stated in the problem: The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node (A leaf is a node with no children). So for \"[]\"  not such path exist, as there are no leaf nodes, so \"0\" is incorrect."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Yes, it should  be -1, cause the length of path between two nonexistent places is not 0, it is *undefined*"
                    },
                    {
                        "username": "psionl0",
                        "content": "Any other number you returned from an empty tree would also be \"incorrect\". However, this is the only time you have to worry about what to return. In all other cases, there is an actual root node and a path to a leaf node."
                    },
                    {
                        "username": "rbenb",
                        "content": "Yeah this one doesn't make sense, I'm using swift and since TreeNode() results in val being 0, running this with my local compiler/Xcode results in a different answer.  For the leetcode solution I had to write if root == nil || root?.val == nil { return 0 } to pass the test case, but the initializer for TreeNode sets val to 0 so that shouldn't work.  Don't know why it does here.  Based on their definition of a TreeNode, [] and [0] both are the same.   Both nodes have a val of 0.  Maybe it means to input nil instead of TreeNode()?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "In my opinion, the \"minimum depth\" of a null tree is not properly defined in the problem statement.\\n\\nIn one sense, the depth of the tree could be considered zero, but to my knowledge, a null node is not a leaf node (if there is a definition for this, I would appreciate if someone could point to a reference for that).\\n\\nIf a null node cannot itself be considered a leaf node, then there is no distance which could be traversed to reach a leaf node, so the distance is undefined."
                    },
                    {
                        "username": "OnlyFaangs",
                        "content": "What does \"Optional\" stand for in function definition *minDepth(self, root: **Optional**[TreeNode])*?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "That means that the type of `root` can be either a `TreeNode` or `None` : it\\'s up to you to check what has been passed to the function."
                    },
                    {
                        "username": "theMonkbphc",
                        "content": "Minimum Depth of Binary Tree problem:\\nI have coded a BFS solution to this and my runtime is 680ms. Checking the runtime distribution, I found some solutions claiming ~30ms using DFS. Logically, it doesnt make sense. I coded the same and resubmitted. My runtime was now around 780ms. What is the deal here? Can someone explain the runtime distribution graph\\'s behaviour over here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The programming language used for your solution is a major factor in the time taken."
                    },
                    {
                        "username": "user3918M",
                        "content": "I am confused with this input [1,2,3,4,5]. Could anyone tell me how the tree looks like? Is it same as [1,2,3,4,5,null,null]?"
                    },
                    {
                        "username": "Rishil96",
                        "content": "starting with 1 every node moving ahead will be the right child as its greater than its parent and 5 is the last node so it will have both children as null"
                    },
                    {
                        "username": "user4191LD",
                        "content": "yes"
                    },
                    {
                        "username": "JerryYe",
                        "content": "why we can\\'t regard the root node as a part of  left tree or right tree?\\nI think it\\'s resonable.Could someone help me ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "When we talk about a binary tree, we usually conceptualize it in terms of a root node and its two subtrees: the left subtree and the right subtree. The root node is seen as a separate entity that connects these two subtrees.\\n\\nThis view of the binary tree is useful for recursive algorithms, where we solve a problem on the tree by solving the same problem on the left subtree and the right subtree and combining these solutions in some way.\\n\\nFrom another perspective, you could say that the root node is part of both the left and right subtrees, because it is an ancestor of all nodes in both subtrees. But this viewpoint is less useful for most algorithmic problems on binary trees, because it doesn\\'t allow us to easily divide the tree into smaller parts that we can solve independently.\\n\\nIn the end, whether we regard the root as part of the left subtree, the right subtree, both, or neither depends on what is most useful for the problem we are trying to solve. However, the conventional view is to see the root as a separate entity that connects the left and right subtrees, and this view is the most useful in a majority of cases."
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "Question rephrase: Find number of nodes between root node and nearest leaf node from the root node (both included)"
                    },
                    {
                        "username": "aryan_",
                        "content": "yeah that\\'s the correct way \\n"
                    },
                    {
                        "username": "rauanktl",
                        "content": "Monday\\'s cakewalk :)"
                    }
                ]
            },
            {
                "id": 1574244,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "First experience working with trees.... I liked it, but should this really be considered an easy problem?  Trees kinda seem like an intermediate topic NGL"
                    },
                    {
                        "username": "ogcooke",
                        "content": "yes, simple traversals without modifications should be considered easy. don\\'t worry, proficiency comes with experience)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Recursively traversing trees to collect data (height, node count etc) is a pretty standard operation. Practice a few problems like these and you will also find this easy."
                    },
                    {
                        "username": "Abdul_Muktadir_Bhuyan",
                        "content": "How in the name of god this problem is easy, this should intermediate. "
                    },
                    {
                        "username": "bortengineer",
                        "content": "The output for the test case \"[]\" should not be the 0. As stated in the problem: The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node (A leaf is a node with no children). So for \"[]\"  not such path exist, as there are no leaf nodes, so \"0\" is incorrect."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Yes, it should  be -1, cause the length of path between two nonexistent places is not 0, it is *undefined*"
                    },
                    {
                        "username": "psionl0",
                        "content": "Any other number you returned from an empty tree would also be \"incorrect\". However, this is the only time you have to worry about what to return. In all other cases, there is an actual root node and a path to a leaf node."
                    },
                    {
                        "username": "rbenb",
                        "content": "Yeah this one doesn't make sense, I'm using swift and since TreeNode() results in val being 0, running this with my local compiler/Xcode results in a different answer.  For the leetcode solution I had to write if root == nil || root?.val == nil { return 0 } to pass the test case, but the initializer for TreeNode sets val to 0 so that shouldn't work.  Don't know why it does here.  Based on their definition of a TreeNode, [] and [0] both are the same.   Both nodes have a val of 0.  Maybe it means to input nil instead of TreeNode()?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "In my opinion, the \"minimum depth\" of a null tree is not properly defined in the problem statement.\\n\\nIn one sense, the depth of the tree could be considered zero, but to my knowledge, a null node is not a leaf node (if there is a definition for this, I would appreciate if someone could point to a reference for that).\\n\\nIf a null node cannot itself be considered a leaf node, then there is no distance which could be traversed to reach a leaf node, so the distance is undefined."
                    },
                    {
                        "username": "OnlyFaangs",
                        "content": "What does \"Optional\" stand for in function definition *minDepth(self, root: **Optional**[TreeNode])*?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "That means that the type of `root` can be either a `TreeNode` or `None` : it\\'s up to you to check what has been passed to the function."
                    },
                    {
                        "username": "theMonkbphc",
                        "content": "Minimum Depth of Binary Tree problem:\\nI have coded a BFS solution to this and my runtime is 680ms. Checking the runtime distribution, I found some solutions claiming ~30ms using DFS. Logically, it doesnt make sense. I coded the same and resubmitted. My runtime was now around 780ms. What is the deal here? Can someone explain the runtime distribution graph\\'s behaviour over here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The programming language used for your solution is a major factor in the time taken."
                    },
                    {
                        "username": "user3918M",
                        "content": "I am confused with this input [1,2,3,4,5]. Could anyone tell me how the tree looks like? Is it same as [1,2,3,4,5,null,null]?"
                    },
                    {
                        "username": "Rishil96",
                        "content": "starting with 1 every node moving ahead will be the right child as its greater than its parent and 5 is the last node so it will have both children as null"
                    },
                    {
                        "username": "user4191LD",
                        "content": "yes"
                    },
                    {
                        "username": "JerryYe",
                        "content": "why we can\\'t regard the root node as a part of  left tree or right tree?\\nI think it\\'s resonable.Could someone help me ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "When we talk about a binary tree, we usually conceptualize it in terms of a root node and its two subtrees: the left subtree and the right subtree. The root node is seen as a separate entity that connects these two subtrees.\\n\\nThis view of the binary tree is useful for recursive algorithms, where we solve a problem on the tree by solving the same problem on the left subtree and the right subtree and combining these solutions in some way.\\n\\nFrom another perspective, you could say that the root node is part of both the left and right subtrees, because it is an ancestor of all nodes in both subtrees. But this viewpoint is less useful for most algorithmic problems on binary trees, because it doesn\\'t allow us to easily divide the tree into smaller parts that we can solve independently.\\n\\nIn the end, whether we regard the root as part of the left subtree, the right subtree, both, or neither depends on what is most useful for the problem we are trying to solve. However, the conventional view is to see the root as a separate entity that connects the left and right subtrees, and this view is the most useful in a majority of cases."
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "Question rephrase: Find number of nodes between root node and nearest leaf node from the root node (both included)"
                    },
                    {
                        "username": "aryan_",
                        "content": "yeah that\\'s the correct way \\n"
                    },
                    {
                        "username": "rauanktl",
                        "content": "Monday\\'s cakewalk :)"
                    }
                ]
            },
            {
                "id": 1569284,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "First experience working with trees.... I liked it, but should this really be considered an easy problem?  Trees kinda seem like an intermediate topic NGL"
                    },
                    {
                        "username": "ogcooke",
                        "content": "yes, simple traversals without modifications should be considered easy. don\\'t worry, proficiency comes with experience)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Recursively traversing trees to collect data (height, node count etc) is a pretty standard operation. Practice a few problems like these and you will also find this easy."
                    },
                    {
                        "username": "Abdul_Muktadir_Bhuyan",
                        "content": "How in the name of god this problem is easy, this should intermediate. "
                    },
                    {
                        "username": "bortengineer",
                        "content": "The output for the test case \"[]\" should not be the 0. As stated in the problem: The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node (A leaf is a node with no children). So for \"[]\"  not such path exist, as there are no leaf nodes, so \"0\" is incorrect."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Yes, it should  be -1, cause the length of path between two nonexistent places is not 0, it is *undefined*"
                    },
                    {
                        "username": "psionl0",
                        "content": "Any other number you returned from an empty tree would also be \"incorrect\". However, this is the only time you have to worry about what to return. In all other cases, there is an actual root node and a path to a leaf node."
                    },
                    {
                        "username": "rbenb",
                        "content": "Yeah this one doesn't make sense, I'm using swift and since TreeNode() results in val being 0, running this with my local compiler/Xcode results in a different answer.  For the leetcode solution I had to write if root == nil || root?.val == nil { return 0 } to pass the test case, but the initializer for TreeNode sets val to 0 so that shouldn't work.  Don't know why it does here.  Based on their definition of a TreeNode, [] and [0] both are the same.   Both nodes have a val of 0.  Maybe it means to input nil instead of TreeNode()?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "In my opinion, the \"minimum depth\" of a null tree is not properly defined in the problem statement.\\n\\nIn one sense, the depth of the tree could be considered zero, but to my knowledge, a null node is not a leaf node (if there is a definition for this, I would appreciate if someone could point to a reference for that).\\n\\nIf a null node cannot itself be considered a leaf node, then there is no distance which could be traversed to reach a leaf node, so the distance is undefined."
                    },
                    {
                        "username": "OnlyFaangs",
                        "content": "What does \"Optional\" stand for in function definition *minDepth(self, root: **Optional**[TreeNode])*?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "That means that the type of `root` can be either a `TreeNode` or `None` : it\\'s up to you to check what has been passed to the function."
                    },
                    {
                        "username": "theMonkbphc",
                        "content": "Minimum Depth of Binary Tree problem:\\nI have coded a BFS solution to this and my runtime is 680ms. Checking the runtime distribution, I found some solutions claiming ~30ms using DFS. Logically, it doesnt make sense. I coded the same and resubmitted. My runtime was now around 780ms. What is the deal here? Can someone explain the runtime distribution graph\\'s behaviour over here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The programming language used for your solution is a major factor in the time taken."
                    },
                    {
                        "username": "user3918M",
                        "content": "I am confused with this input [1,2,3,4,5]. Could anyone tell me how the tree looks like? Is it same as [1,2,3,4,5,null,null]?"
                    },
                    {
                        "username": "Rishil96",
                        "content": "starting with 1 every node moving ahead will be the right child as its greater than its parent and 5 is the last node so it will have both children as null"
                    },
                    {
                        "username": "user4191LD",
                        "content": "yes"
                    },
                    {
                        "username": "JerryYe",
                        "content": "why we can\\'t regard the root node as a part of  left tree or right tree?\\nI think it\\'s resonable.Could someone help me ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "When we talk about a binary tree, we usually conceptualize it in terms of a root node and its two subtrees: the left subtree and the right subtree. The root node is seen as a separate entity that connects these two subtrees.\\n\\nThis view of the binary tree is useful for recursive algorithms, where we solve a problem on the tree by solving the same problem on the left subtree and the right subtree and combining these solutions in some way.\\n\\nFrom another perspective, you could say that the root node is part of both the left and right subtrees, because it is an ancestor of all nodes in both subtrees. But this viewpoint is less useful for most algorithmic problems on binary trees, because it doesn\\'t allow us to easily divide the tree into smaller parts that we can solve independently.\\n\\nIn the end, whether we regard the root as part of the left subtree, the right subtree, both, or neither depends on what is most useful for the problem we are trying to solve. However, the conventional view is to see the root as a separate entity that connects the left and right subtrees, and this view is the most useful in a majority of cases."
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "Question rephrase: Find number of nodes between root node and nearest leaf node from the root node (both included)"
                    },
                    {
                        "username": "aryan_",
                        "content": "yeah that\\'s the correct way \\n"
                    },
                    {
                        "username": "rauanktl",
                        "content": "Monday\\'s cakewalk :)"
                    }
                ]
            },
            {
                "id": 1964080,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "First experience working with trees.... I liked it, but should this really be considered an easy problem?  Trees kinda seem like an intermediate topic NGL"
                    },
                    {
                        "username": "ogcooke",
                        "content": "yes, simple traversals without modifications should be considered easy. don\\'t worry, proficiency comes with experience)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Recursively traversing trees to collect data (height, node count etc) is a pretty standard operation. Practice a few problems like these and you will also find this easy."
                    },
                    {
                        "username": "Abdul_Muktadir_Bhuyan",
                        "content": "How in the name of god this problem is easy, this should intermediate. "
                    },
                    {
                        "username": "bortengineer",
                        "content": "The output for the test case \"[]\" should not be the 0. As stated in the problem: The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node (A leaf is a node with no children). So for \"[]\"  not such path exist, as there are no leaf nodes, so \"0\" is incorrect."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Yes, it should  be -1, cause the length of path between two nonexistent places is not 0, it is *undefined*"
                    },
                    {
                        "username": "psionl0",
                        "content": "Any other number you returned from an empty tree would also be \"incorrect\". However, this is the only time you have to worry about what to return. In all other cases, there is an actual root node and a path to a leaf node."
                    },
                    {
                        "username": "rbenb",
                        "content": "Yeah this one doesn't make sense, I'm using swift and since TreeNode() results in val being 0, running this with my local compiler/Xcode results in a different answer.  For the leetcode solution I had to write if root == nil || root?.val == nil { return 0 } to pass the test case, but the initializer for TreeNode sets val to 0 so that shouldn't work.  Don't know why it does here.  Based on their definition of a TreeNode, [] and [0] both are the same.   Both nodes have a val of 0.  Maybe it means to input nil instead of TreeNode()?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "In my opinion, the \"minimum depth\" of a null tree is not properly defined in the problem statement.\\n\\nIn one sense, the depth of the tree could be considered zero, but to my knowledge, a null node is not a leaf node (if there is a definition for this, I would appreciate if someone could point to a reference for that).\\n\\nIf a null node cannot itself be considered a leaf node, then there is no distance which could be traversed to reach a leaf node, so the distance is undefined."
                    },
                    {
                        "username": "OnlyFaangs",
                        "content": "What does \"Optional\" stand for in function definition *minDepth(self, root: **Optional**[TreeNode])*?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "That means that the type of `root` can be either a `TreeNode` or `None` : it\\'s up to you to check what has been passed to the function."
                    },
                    {
                        "username": "theMonkbphc",
                        "content": "Minimum Depth of Binary Tree problem:\\nI have coded a BFS solution to this and my runtime is 680ms. Checking the runtime distribution, I found some solutions claiming ~30ms using DFS. Logically, it doesnt make sense. I coded the same and resubmitted. My runtime was now around 780ms. What is the deal here? Can someone explain the runtime distribution graph\\'s behaviour over here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The programming language used for your solution is a major factor in the time taken."
                    },
                    {
                        "username": "user3918M",
                        "content": "I am confused with this input [1,2,3,4,5]. Could anyone tell me how the tree looks like? Is it same as [1,2,3,4,5,null,null]?"
                    },
                    {
                        "username": "Rishil96",
                        "content": "starting with 1 every node moving ahead will be the right child as its greater than its parent and 5 is the last node so it will have both children as null"
                    },
                    {
                        "username": "user4191LD",
                        "content": "yes"
                    },
                    {
                        "username": "JerryYe",
                        "content": "why we can\\'t regard the root node as a part of  left tree or right tree?\\nI think it\\'s resonable.Could someone help me ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "When we talk about a binary tree, we usually conceptualize it in terms of a root node and its two subtrees: the left subtree and the right subtree. The root node is seen as a separate entity that connects these two subtrees.\\n\\nThis view of the binary tree is useful for recursive algorithms, where we solve a problem on the tree by solving the same problem on the left subtree and the right subtree and combining these solutions in some way.\\n\\nFrom another perspective, you could say that the root node is part of both the left and right subtrees, because it is an ancestor of all nodes in both subtrees. But this viewpoint is less useful for most algorithmic problems on binary trees, because it doesn\\'t allow us to easily divide the tree into smaller parts that we can solve independently.\\n\\nIn the end, whether we regard the root as part of the left subtree, the right subtree, both, or neither depends on what is most useful for the problem we are trying to solve. However, the conventional view is to see the root as a separate entity that connects the left and right subtrees, and this view is the most useful in a majority of cases."
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "Question rephrase: Find number of nodes between root node and nearest leaf node from the root node (both included)"
                    },
                    {
                        "username": "aryan_",
                        "content": "yeah that\\'s the correct way \\n"
                    },
                    {
                        "username": "rauanktl",
                        "content": "Monday\\'s cakewalk :)"
                    }
                ]
            },
            {
                "id": 1964033,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "First experience working with trees.... I liked it, but should this really be considered an easy problem?  Trees kinda seem like an intermediate topic NGL"
                    },
                    {
                        "username": "ogcooke",
                        "content": "yes, simple traversals without modifications should be considered easy. don\\'t worry, proficiency comes with experience)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Recursively traversing trees to collect data (height, node count etc) is a pretty standard operation. Practice a few problems like these and you will also find this easy."
                    },
                    {
                        "username": "Abdul_Muktadir_Bhuyan",
                        "content": "How in the name of god this problem is easy, this should intermediate. "
                    },
                    {
                        "username": "bortengineer",
                        "content": "The output for the test case \"[]\" should not be the 0. As stated in the problem: The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node (A leaf is a node with no children). So for \"[]\"  not such path exist, as there are no leaf nodes, so \"0\" is incorrect."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Yes, it should  be -1, cause the length of path between two nonexistent places is not 0, it is *undefined*"
                    },
                    {
                        "username": "psionl0",
                        "content": "Any other number you returned from an empty tree would also be \"incorrect\". However, this is the only time you have to worry about what to return. In all other cases, there is an actual root node and a path to a leaf node."
                    },
                    {
                        "username": "rbenb",
                        "content": "Yeah this one doesn't make sense, I'm using swift and since TreeNode() results in val being 0, running this with my local compiler/Xcode results in a different answer.  For the leetcode solution I had to write if root == nil || root?.val == nil { return 0 } to pass the test case, but the initializer for TreeNode sets val to 0 so that shouldn't work.  Don't know why it does here.  Based on their definition of a TreeNode, [] and [0] both are the same.   Both nodes have a val of 0.  Maybe it means to input nil instead of TreeNode()?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "In my opinion, the \"minimum depth\" of a null tree is not properly defined in the problem statement.\\n\\nIn one sense, the depth of the tree could be considered zero, but to my knowledge, a null node is not a leaf node (if there is a definition for this, I would appreciate if someone could point to a reference for that).\\n\\nIf a null node cannot itself be considered a leaf node, then there is no distance which could be traversed to reach a leaf node, so the distance is undefined."
                    },
                    {
                        "username": "OnlyFaangs",
                        "content": "What does \"Optional\" stand for in function definition *minDepth(self, root: **Optional**[TreeNode])*?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "That means that the type of `root` can be either a `TreeNode` or `None` : it\\'s up to you to check what has been passed to the function."
                    },
                    {
                        "username": "theMonkbphc",
                        "content": "Minimum Depth of Binary Tree problem:\\nI have coded a BFS solution to this and my runtime is 680ms. Checking the runtime distribution, I found some solutions claiming ~30ms using DFS. Logically, it doesnt make sense. I coded the same and resubmitted. My runtime was now around 780ms. What is the deal here? Can someone explain the runtime distribution graph\\'s behaviour over here?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The programming language used for your solution is a major factor in the time taken."
                    },
                    {
                        "username": "user3918M",
                        "content": "I am confused with this input [1,2,3,4,5]. Could anyone tell me how the tree looks like? Is it same as [1,2,3,4,5,null,null]?"
                    },
                    {
                        "username": "Rishil96",
                        "content": "starting with 1 every node moving ahead will be the right child as its greater than its parent and 5 is the last node so it will have both children as null"
                    },
                    {
                        "username": "user4191LD",
                        "content": "yes"
                    },
                    {
                        "username": "JerryYe",
                        "content": "why we can\\'t regard the root node as a part of  left tree or right tree?\\nI think it\\'s resonable.Could someone help me ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "When we talk about a binary tree, we usually conceptualize it in terms of a root node and its two subtrees: the left subtree and the right subtree. The root node is seen as a separate entity that connects these two subtrees.\\n\\nThis view of the binary tree is useful for recursive algorithms, where we solve a problem on the tree by solving the same problem on the left subtree and the right subtree and combining these solutions in some way.\\n\\nFrom another perspective, you could say that the root node is part of both the left and right subtrees, because it is an ancestor of all nodes in both subtrees. But this viewpoint is less useful for most algorithmic problems on binary trees, because it doesn\\'t allow us to easily divide the tree into smaller parts that we can solve independently.\\n\\nIn the end, whether we regard the root as part of the left subtree, the right subtree, both, or neither depends on what is most useful for the problem we are trying to solve. However, the conventional view is to see the root as a separate entity that connects the left and right subtrees, and this view is the most useful in a majority of cases."
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "Question rephrase: Find number of nodes between root node and nearest leaf node from the root node (both included)"
                    },
                    {
                        "username": "aryan_",
                        "content": "yeah that\\'s the correct way \\n"
                    },
                    {
                        "username": "rauanktl",
                        "content": "Monday\\'s cakewalk :)"
                    }
                ]
            },
            {
                "id": 1963747,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Although this problem is quite straightforward, readers should be aware that this problem is using a unique definition for the height of a tree. In the usual definition, the height of a tree is considered to be the number of edges between the root node and a leaf node (more correctly, this is the depth of the leaf node).\\n\\nUnder that definition, a leaf node has a height of 0 and a NULL node has a height of -1.\\n\\nThe definition used here is the number of nodes between the root and leaf node including the root and leaf node. This means that a leaf node has a height of 1 and a NULL node has a height of 0.\\n\\nNote that a path that doesn\\'t terminate on a leaf node is not included. That is why in the second test case, the height is 5 and not 1."
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally Monday starts with easy ...\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE0E"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "the depth of the root is not 1. It should be 0."
                    },
                    {
                        "username": "aacharyadeepak100",
                        "content": "Can anyone construct a tree for me with input being **[1,2]**?\\n\\n**Thanks in advance.**"
                    },
                    {
                        "username": "Aadil42",
                        "content": "You can just paste the input in console. The tree will be drawn for you."
                    },
                    {
                        "username": "psionl0",
                        "content": "```\\n     1\\n    / \\\\\\n   2   .\\n  / \\\\\\n .   .\\n```\\n "
                    },
                    {
                        "username": "john77",
                        "content": "Why [1,2] should return 2 not 1?\\nand [1,null,2] should return 2 not 1?\\nand [1,2,3,4,null,null,5] should return 3 not 2?"
                    },
                    {
                        "username": "regeter",
                        "content": "    Input: [1,null,2]\\n    Output: 1\\n    Expected:2\\n\\nDoes this mean it creates one TreeNode with Left = 1st | Right = null?\\nAnd the first is Left = 2nd, Right undefined.\\n\\nI need to understand the test cases input in order to fix my code."
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "My C++ Solution\\n\\n\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(root==NULL)\\n        return 0;\\n     if(!root->left) return 1 + minDepth(root->right);\\n        if(!root->right) return 1 + minDepth(root->left);\\n        return 1+min(minDepth(root->left),minDepth(root->right));\\n    }\\n};"
                    },
                    {
                        "username": "user2987Qa",
                        "content": "i don\\'t think your solutions should go here, because it would be visible by non-attempted coder, or spoiling the real answer. Sadly there isn\\'t a mark spoiler button like CodeWar here."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "Update your `counter` variable only when the left ***and*** right branch of the node is `null`"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "The root argument can be null"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "I have used the Breath First Sear approach to solve this problem. As BFS helps to traverse the tree level by level, and the first leaf node encountered will give us the minimum depth.\nAdditionally, i have 'dequeue' data structure for this.\nAnd i worked."
                    }
                ]
            },
            {
                "id": 1963728,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Although this problem is quite straightforward, readers should be aware that this problem is using a unique definition for the height of a tree. In the usual definition, the height of a tree is considered to be the number of edges between the root node and a leaf node (more correctly, this is the depth of the leaf node).\\n\\nUnder that definition, a leaf node has a height of 0 and a NULL node has a height of -1.\\n\\nThe definition used here is the number of nodes between the root and leaf node including the root and leaf node. This means that a leaf node has a height of 1 and a NULL node has a height of 0.\\n\\nNote that a path that doesn\\'t terminate on a leaf node is not included. That is why in the second test case, the height is 5 and not 1."
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally Monday starts with easy ...\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE0E"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "the depth of the root is not 1. It should be 0."
                    },
                    {
                        "username": "aacharyadeepak100",
                        "content": "Can anyone construct a tree for me with input being **[1,2]**?\\n\\n**Thanks in advance.**"
                    },
                    {
                        "username": "Aadil42",
                        "content": "You can just paste the input in console. The tree will be drawn for you."
                    },
                    {
                        "username": "psionl0",
                        "content": "```\\n     1\\n    / \\\\\\n   2   .\\n  / \\\\\\n .   .\\n```\\n "
                    },
                    {
                        "username": "john77",
                        "content": "Why [1,2] should return 2 not 1?\\nand [1,null,2] should return 2 not 1?\\nand [1,2,3,4,null,null,5] should return 3 not 2?"
                    },
                    {
                        "username": "regeter",
                        "content": "    Input: [1,null,2]\\n    Output: 1\\n    Expected:2\\n\\nDoes this mean it creates one TreeNode with Left = 1st | Right = null?\\nAnd the first is Left = 2nd, Right undefined.\\n\\nI need to understand the test cases input in order to fix my code."
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "My C++ Solution\\n\\n\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(root==NULL)\\n        return 0;\\n     if(!root->left) return 1 + minDepth(root->right);\\n        if(!root->right) return 1 + minDepth(root->left);\\n        return 1+min(minDepth(root->left),minDepth(root->right));\\n    }\\n};"
                    },
                    {
                        "username": "user2987Qa",
                        "content": "i don\\'t think your solutions should go here, because it would be visible by non-attempted coder, or spoiling the real answer. Sadly there isn\\'t a mark spoiler button like CodeWar here."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "Update your `counter` variable only when the left ***and*** right branch of the node is `null`"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "The root argument can be null"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "I have used the Breath First Sear approach to solve this problem. As BFS helps to traverse the tree level by level, and the first leaf node encountered will give us the minimum depth.\nAdditionally, i have 'dequeue' data structure for this.\nAnd i worked."
                    }
                ]
            },
            {
                "id": 1574312,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Although this problem is quite straightforward, readers should be aware that this problem is using a unique definition for the height of a tree. In the usual definition, the height of a tree is considered to be the number of edges between the root node and a leaf node (more correctly, this is the depth of the leaf node).\\n\\nUnder that definition, a leaf node has a height of 0 and a NULL node has a height of -1.\\n\\nThe definition used here is the number of nodes between the root and leaf node including the root and leaf node. This means that a leaf node has a height of 1 and a NULL node has a height of 0.\\n\\nNote that a path that doesn\\'t terminate on a leaf node is not included. That is why in the second test case, the height is 5 and not 1."
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally Monday starts with easy ...\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE0E"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "the depth of the root is not 1. It should be 0."
                    },
                    {
                        "username": "aacharyadeepak100",
                        "content": "Can anyone construct a tree for me with input being **[1,2]**?\\n\\n**Thanks in advance.**"
                    },
                    {
                        "username": "Aadil42",
                        "content": "You can just paste the input in console. The tree will be drawn for you."
                    },
                    {
                        "username": "psionl0",
                        "content": "```\\n     1\\n    / \\\\\\n   2   .\\n  / \\\\\\n .   .\\n```\\n "
                    },
                    {
                        "username": "john77",
                        "content": "Why [1,2] should return 2 not 1?\\nand [1,null,2] should return 2 not 1?\\nand [1,2,3,4,null,null,5] should return 3 not 2?"
                    },
                    {
                        "username": "regeter",
                        "content": "    Input: [1,null,2]\\n    Output: 1\\n    Expected:2\\n\\nDoes this mean it creates one TreeNode with Left = 1st | Right = null?\\nAnd the first is Left = 2nd, Right undefined.\\n\\nI need to understand the test cases input in order to fix my code."
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "My C++ Solution\\n\\n\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(root==NULL)\\n        return 0;\\n     if(!root->left) return 1 + minDepth(root->right);\\n        if(!root->right) return 1 + minDepth(root->left);\\n        return 1+min(minDepth(root->left),minDepth(root->right));\\n    }\\n};"
                    },
                    {
                        "username": "user2987Qa",
                        "content": "i don\\'t think your solutions should go here, because it would be visible by non-attempted coder, or spoiling the real answer. Sadly there isn\\'t a mark spoiler button like CodeWar here."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "Update your `counter` variable only when the left ***and*** right branch of the node is `null`"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "The root argument can be null"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "I have used the Breath First Sear approach to solve this problem. As BFS helps to traverse the tree level by level, and the first leaf node encountered will give us the minimum depth.\nAdditionally, i have 'dequeue' data structure for this.\nAnd i worked."
                    }
                ]
            },
            {
                "id": 1573548,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Although this problem is quite straightforward, readers should be aware that this problem is using a unique definition for the height of a tree. In the usual definition, the height of a tree is considered to be the number of edges between the root node and a leaf node (more correctly, this is the depth of the leaf node).\\n\\nUnder that definition, a leaf node has a height of 0 and a NULL node has a height of -1.\\n\\nThe definition used here is the number of nodes between the root and leaf node including the root and leaf node. This means that a leaf node has a height of 1 and a NULL node has a height of 0.\\n\\nNote that a path that doesn\\'t terminate on a leaf node is not included. That is why in the second test case, the height is 5 and not 1."
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally Monday starts with easy ...\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE0E"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "the depth of the root is not 1. It should be 0."
                    },
                    {
                        "username": "aacharyadeepak100",
                        "content": "Can anyone construct a tree for me with input being **[1,2]**?\\n\\n**Thanks in advance.**"
                    },
                    {
                        "username": "Aadil42",
                        "content": "You can just paste the input in console. The tree will be drawn for you."
                    },
                    {
                        "username": "psionl0",
                        "content": "```\\n     1\\n    / \\\\\\n   2   .\\n  / \\\\\\n .   .\\n```\\n "
                    },
                    {
                        "username": "john77",
                        "content": "Why [1,2] should return 2 not 1?\\nand [1,null,2] should return 2 not 1?\\nand [1,2,3,4,null,null,5] should return 3 not 2?"
                    },
                    {
                        "username": "regeter",
                        "content": "    Input: [1,null,2]\\n    Output: 1\\n    Expected:2\\n\\nDoes this mean it creates one TreeNode with Left = 1st | Right = null?\\nAnd the first is Left = 2nd, Right undefined.\\n\\nI need to understand the test cases input in order to fix my code."
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "My C++ Solution\\n\\n\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(root==NULL)\\n        return 0;\\n     if(!root->left) return 1 + minDepth(root->right);\\n        if(!root->right) return 1 + minDepth(root->left);\\n        return 1+min(minDepth(root->left),minDepth(root->right));\\n    }\\n};"
                    },
                    {
                        "username": "user2987Qa",
                        "content": "i don\\'t think your solutions should go here, because it would be visible by non-attempted coder, or spoiling the real answer. Sadly there isn\\'t a mark spoiler button like CodeWar here."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "Update your `counter` variable only when the left ***and*** right branch of the node is `null`"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "The root argument can be null"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "I have used the Breath First Sear approach to solve this problem. As BFS helps to traverse the tree level by level, and the first leaf node encountered will give us the minimum depth.\nAdditionally, i have 'dequeue' data structure for this.\nAnd i worked."
                    }
                ]
            },
            {
                "id": 1571231,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Although this problem is quite straightforward, readers should be aware that this problem is using a unique definition for the height of a tree. In the usual definition, the height of a tree is considered to be the number of edges between the root node and a leaf node (more correctly, this is the depth of the leaf node).\\n\\nUnder that definition, a leaf node has a height of 0 and a NULL node has a height of -1.\\n\\nThe definition used here is the number of nodes between the root and leaf node including the root and leaf node. This means that a leaf node has a height of 1 and a NULL node has a height of 0.\\n\\nNote that a path that doesn\\'t terminate on a leaf node is not included. That is why in the second test case, the height is 5 and not 1."
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally Monday starts with easy ...\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE0E"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "the depth of the root is not 1. It should be 0."
                    },
                    {
                        "username": "aacharyadeepak100",
                        "content": "Can anyone construct a tree for me with input being **[1,2]**?\\n\\n**Thanks in advance.**"
                    },
                    {
                        "username": "Aadil42",
                        "content": "You can just paste the input in console. The tree will be drawn for you."
                    },
                    {
                        "username": "psionl0",
                        "content": "```\\n     1\\n    / \\\\\\n   2   .\\n  / \\\\\\n .   .\\n```\\n "
                    },
                    {
                        "username": "john77",
                        "content": "Why [1,2] should return 2 not 1?\\nand [1,null,2] should return 2 not 1?\\nand [1,2,3,4,null,null,5] should return 3 not 2?"
                    },
                    {
                        "username": "regeter",
                        "content": "    Input: [1,null,2]\\n    Output: 1\\n    Expected:2\\n\\nDoes this mean it creates one TreeNode with Left = 1st | Right = null?\\nAnd the first is Left = 2nd, Right undefined.\\n\\nI need to understand the test cases input in order to fix my code."
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "My C++ Solution\\n\\n\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(root==NULL)\\n        return 0;\\n     if(!root->left) return 1 + minDepth(root->right);\\n        if(!root->right) return 1 + minDepth(root->left);\\n        return 1+min(minDepth(root->left),minDepth(root->right));\\n    }\\n};"
                    },
                    {
                        "username": "user2987Qa",
                        "content": "i don\\'t think your solutions should go here, because it would be visible by non-attempted coder, or spoiling the real answer. Sadly there isn\\'t a mark spoiler button like CodeWar here."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "Update your `counter` variable only when the left ***and*** right branch of the node is `null`"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "The root argument can be null"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "I have used the Breath First Sear approach to solve this problem. As BFS helps to traverse the tree level by level, and the first leaf node encountered will give us the minimum depth.\nAdditionally, i have 'dequeue' data structure for this.\nAnd i worked."
                    }
                ]
            },
            {
                "id": 1571232,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Although this problem is quite straightforward, readers should be aware that this problem is using a unique definition for the height of a tree. In the usual definition, the height of a tree is considered to be the number of edges between the root node and a leaf node (more correctly, this is the depth of the leaf node).\\n\\nUnder that definition, a leaf node has a height of 0 and a NULL node has a height of -1.\\n\\nThe definition used here is the number of nodes between the root and leaf node including the root and leaf node. This means that a leaf node has a height of 1 and a NULL node has a height of 0.\\n\\nNote that a path that doesn\\'t terminate on a leaf node is not included. That is why in the second test case, the height is 5 and not 1."
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally Monday starts with easy ...\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE0E"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "the depth of the root is not 1. It should be 0."
                    },
                    {
                        "username": "aacharyadeepak100",
                        "content": "Can anyone construct a tree for me with input being **[1,2]**?\\n\\n**Thanks in advance.**"
                    },
                    {
                        "username": "Aadil42",
                        "content": "You can just paste the input in console. The tree will be drawn for you."
                    },
                    {
                        "username": "psionl0",
                        "content": "```\\n     1\\n    / \\\\\\n   2   .\\n  / \\\\\\n .   .\\n```\\n "
                    },
                    {
                        "username": "john77",
                        "content": "Why [1,2] should return 2 not 1?\\nand [1,null,2] should return 2 not 1?\\nand [1,2,3,4,null,null,5] should return 3 not 2?"
                    },
                    {
                        "username": "regeter",
                        "content": "    Input: [1,null,2]\\n    Output: 1\\n    Expected:2\\n\\nDoes this mean it creates one TreeNode with Left = 1st | Right = null?\\nAnd the first is Left = 2nd, Right undefined.\\n\\nI need to understand the test cases input in order to fix my code."
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "My C++ Solution\\n\\n\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(root==NULL)\\n        return 0;\\n     if(!root->left) return 1 + minDepth(root->right);\\n        if(!root->right) return 1 + minDepth(root->left);\\n        return 1+min(minDepth(root->left),minDepth(root->right));\\n    }\\n};"
                    },
                    {
                        "username": "user2987Qa",
                        "content": "i don\\'t think your solutions should go here, because it would be visible by non-attempted coder, or spoiling the real answer. Sadly there isn\\'t a mark spoiler button like CodeWar here."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "Update your `counter` variable only when the left ***and*** right branch of the node is `null`"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "The root argument can be null"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "I have used the Breath First Sear approach to solve this problem. As BFS helps to traverse the tree level by level, and the first leaf node encountered will give us the minimum depth.\nAdditionally, i have 'dequeue' data structure for this.\nAnd i worked."
                    }
                ]
            },
            {
                "id": 1741637,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Although this problem is quite straightforward, readers should be aware that this problem is using a unique definition for the height of a tree. In the usual definition, the height of a tree is considered to be the number of edges between the root node and a leaf node (more correctly, this is the depth of the leaf node).\\n\\nUnder that definition, a leaf node has a height of 0 and a NULL node has a height of -1.\\n\\nThe definition used here is the number of nodes between the root and leaf node including the root and leaf node. This means that a leaf node has a height of 1 and a NULL node has a height of 0.\\n\\nNote that a path that doesn\\'t terminate on a leaf node is not included. That is why in the second test case, the height is 5 and not 1."
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally Monday starts with easy ...\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE0E"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "the depth of the root is not 1. It should be 0."
                    },
                    {
                        "username": "aacharyadeepak100",
                        "content": "Can anyone construct a tree for me with input being **[1,2]**?\\n\\n**Thanks in advance.**"
                    },
                    {
                        "username": "Aadil42",
                        "content": "You can just paste the input in console. The tree will be drawn for you."
                    },
                    {
                        "username": "psionl0",
                        "content": "```\\n     1\\n    / \\\\\\n   2   .\\n  / \\\\\\n .   .\\n```\\n "
                    },
                    {
                        "username": "john77",
                        "content": "Why [1,2] should return 2 not 1?\\nand [1,null,2] should return 2 not 1?\\nand [1,2,3,4,null,null,5] should return 3 not 2?"
                    },
                    {
                        "username": "regeter",
                        "content": "    Input: [1,null,2]\\n    Output: 1\\n    Expected:2\\n\\nDoes this mean it creates one TreeNode with Left = 1st | Right = null?\\nAnd the first is Left = 2nd, Right undefined.\\n\\nI need to understand the test cases input in order to fix my code."
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "My C++ Solution\\n\\n\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(root==NULL)\\n        return 0;\\n     if(!root->left) return 1 + minDepth(root->right);\\n        if(!root->right) return 1 + minDepth(root->left);\\n        return 1+min(minDepth(root->left),minDepth(root->right));\\n    }\\n};"
                    },
                    {
                        "username": "user2987Qa",
                        "content": "i don\\'t think your solutions should go here, because it would be visible by non-attempted coder, or spoiling the real answer. Sadly there isn\\'t a mark spoiler button like CodeWar here."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "Update your `counter` variable only when the left ***and*** right branch of the node is `null`"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "The root argument can be null"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "I have used the Breath First Sear approach to solve this problem. As BFS helps to traverse the tree level by level, and the first leaf node encountered will give us the minimum depth.\nAdditionally, i have 'dequeue' data structure for this.\nAnd i worked."
                    }
                ]
            },
            {
                "id": 2051513,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Although this problem is quite straightforward, readers should be aware that this problem is using a unique definition for the height of a tree. In the usual definition, the height of a tree is considered to be the number of edges between the root node and a leaf node (more correctly, this is the depth of the leaf node).\\n\\nUnder that definition, a leaf node has a height of 0 and a NULL node has a height of -1.\\n\\nThe definition used here is the number of nodes between the root and leaf node including the root and leaf node. This means that a leaf node has a height of 1 and a NULL node has a height of 0.\\n\\nNote that a path that doesn\\'t terminate on a leaf node is not included. That is why in the second test case, the height is 5 and not 1."
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally Monday starts with easy ...\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE0E"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "the depth of the root is not 1. It should be 0."
                    },
                    {
                        "username": "aacharyadeepak100",
                        "content": "Can anyone construct a tree for me with input being **[1,2]**?\\n\\n**Thanks in advance.**"
                    },
                    {
                        "username": "Aadil42",
                        "content": "You can just paste the input in console. The tree will be drawn for you."
                    },
                    {
                        "username": "psionl0",
                        "content": "```\\n     1\\n    / \\\\\\n   2   .\\n  / \\\\\\n .   .\\n```\\n "
                    },
                    {
                        "username": "john77",
                        "content": "Why [1,2] should return 2 not 1?\\nand [1,null,2] should return 2 not 1?\\nand [1,2,3,4,null,null,5] should return 3 not 2?"
                    },
                    {
                        "username": "regeter",
                        "content": "    Input: [1,null,2]\\n    Output: 1\\n    Expected:2\\n\\nDoes this mean it creates one TreeNode with Left = 1st | Right = null?\\nAnd the first is Left = 2nd, Right undefined.\\n\\nI need to understand the test cases input in order to fix my code."
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "My C++ Solution\\n\\n\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(root==NULL)\\n        return 0;\\n     if(!root->left) return 1 + minDepth(root->right);\\n        if(!root->right) return 1 + minDepth(root->left);\\n        return 1+min(minDepth(root->left),minDepth(root->right));\\n    }\\n};"
                    },
                    {
                        "username": "user2987Qa",
                        "content": "i don\\'t think your solutions should go here, because it would be visible by non-attempted coder, or spoiling the real answer. Sadly there isn\\'t a mark spoiler button like CodeWar here."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "Update your `counter` variable only when the left ***and*** right branch of the node is `null`"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "The root argument can be null"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "I have used the Breath First Sear approach to solve this problem. As BFS helps to traverse the tree level by level, and the first leaf node encountered will give us the minimum depth.\nAdditionally, i have 'dequeue' data structure for this.\nAnd i worked."
                    }
                ]
            },
            {
                "id": 2041524,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Although this problem is quite straightforward, readers should be aware that this problem is using a unique definition for the height of a tree. In the usual definition, the height of a tree is considered to be the number of edges between the root node and a leaf node (more correctly, this is the depth of the leaf node).\\n\\nUnder that definition, a leaf node has a height of 0 and a NULL node has a height of -1.\\n\\nThe definition used here is the number of nodes between the root and leaf node including the root and leaf node. This means that a leaf node has a height of 1 and a NULL node has a height of 0.\\n\\nNote that a path that doesn\\'t terminate on a leaf node is not included. That is why in the second test case, the height is 5 and not 1."
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally Monday starts with easy ...\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE0E"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "the depth of the root is not 1. It should be 0."
                    },
                    {
                        "username": "aacharyadeepak100",
                        "content": "Can anyone construct a tree for me with input being **[1,2]**?\\n\\n**Thanks in advance.**"
                    },
                    {
                        "username": "Aadil42",
                        "content": "You can just paste the input in console. The tree will be drawn for you."
                    },
                    {
                        "username": "psionl0",
                        "content": "```\\n     1\\n    / \\\\\\n   2   .\\n  / \\\\\\n .   .\\n```\\n "
                    },
                    {
                        "username": "john77",
                        "content": "Why [1,2] should return 2 not 1?\\nand [1,null,2] should return 2 not 1?\\nand [1,2,3,4,null,null,5] should return 3 not 2?"
                    },
                    {
                        "username": "regeter",
                        "content": "    Input: [1,null,2]\\n    Output: 1\\n    Expected:2\\n\\nDoes this mean it creates one TreeNode with Left = 1st | Right = null?\\nAnd the first is Left = 2nd, Right undefined.\\n\\nI need to understand the test cases input in order to fix my code."
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "My C++ Solution\\n\\n\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(root==NULL)\\n        return 0;\\n     if(!root->left) return 1 + minDepth(root->right);\\n        if(!root->right) return 1 + minDepth(root->left);\\n        return 1+min(minDepth(root->left),minDepth(root->right));\\n    }\\n};"
                    },
                    {
                        "username": "user2987Qa",
                        "content": "i don\\'t think your solutions should go here, because it would be visible by non-attempted coder, or spoiling the real answer. Sadly there isn\\'t a mark spoiler button like CodeWar here."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "Update your `counter` variable only when the left ***and*** right branch of the node is `null`"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "The root argument can be null"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "I have used the Breath First Sear approach to solve this problem. As BFS helps to traverse the tree level by level, and the first leaf node encountered will give us the minimum depth.\nAdditionally, i have 'dequeue' data structure for this.\nAnd i worked."
                    }
                ]
            },
            {
                "id": 1977022,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Although this problem is quite straightforward, readers should be aware that this problem is using a unique definition for the height of a tree. In the usual definition, the height of a tree is considered to be the number of edges between the root node and a leaf node (more correctly, this is the depth of the leaf node).\\n\\nUnder that definition, a leaf node has a height of 0 and a NULL node has a height of -1.\\n\\nThe definition used here is the number of nodes between the root and leaf node including the root and leaf node. This means that a leaf node has a height of 1 and a NULL node has a height of 0.\\n\\nNote that a path that doesn\\'t terminate on a leaf node is not included. That is why in the second test case, the height is 5 and not 1."
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally Monday starts with easy ...\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE0E"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "the depth of the root is not 1. It should be 0."
                    },
                    {
                        "username": "aacharyadeepak100",
                        "content": "Can anyone construct a tree for me with input being **[1,2]**?\\n\\n**Thanks in advance.**"
                    },
                    {
                        "username": "Aadil42",
                        "content": "You can just paste the input in console. The tree will be drawn for you."
                    },
                    {
                        "username": "psionl0",
                        "content": "```\\n     1\\n    / \\\\\\n   2   .\\n  / \\\\\\n .   .\\n```\\n "
                    },
                    {
                        "username": "john77",
                        "content": "Why [1,2] should return 2 not 1?\\nand [1,null,2] should return 2 not 1?\\nand [1,2,3,4,null,null,5] should return 3 not 2?"
                    },
                    {
                        "username": "regeter",
                        "content": "    Input: [1,null,2]\\n    Output: 1\\n    Expected:2\\n\\nDoes this mean it creates one TreeNode with Left = 1st | Right = null?\\nAnd the first is Left = 2nd, Right undefined.\\n\\nI need to understand the test cases input in order to fix my code."
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "My C++ Solution\\n\\n\\nclass Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        if(root==NULL)\\n        return 0;\\n     if(!root->left) return 1 + minDepth(root->right);\\n        if(!root->right) return 1 + minDepth(root->left);\\n        return 1+min(minDepth(root->left),minDepth(root->right));\\n    }\\n};"
                    },
                    {
                        "username": "user2987Qa",
                        "content": "i don\\'t think your solutions should go here, because it would be visible by non-attempted coder, or spoiling the real answer. Sadly there isn\\'t a mark spoiler button like CodeWar here."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "Update your `counter` variable only when the left ***and*** right branch of the node is `null`"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "The root argument can be null"
                    },
                    {
                        "username": "sameerk2k01",
                        "content": "I have used the Breath First Sear approach to solve this problem. As BFS helps to traverse the tree level by level, and the first leaf node encountered will give us the minimum depth.\nAdditionally, i have 'dequeue' data structure for this.\nAnd i worked."
                    }
                ]
            },
            {
                "id": 1977014,
                "content": [
                    {
                        "username": "sameerk2k01",
                        "content": "If this is a case that it is a right skewed binary tree then what approach should be used to get to the leaf node\\'s height.\\nBecause the simple and obvious answer works perfect for other cases expect this skewed binary tree."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "the breadth first search solution is quite tricky and beautiful !"
                    },
                    {
                        "username": "peterfarrell66",
                        "content": "So the numbers in the root array are already TreeNodes?"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Use BFS is a good idea, until you find the first node that has no left and right children"
                    },
                    {
                        "username": "ritvik12_",
                        "content": "easy question if you know traversal of tree then it\\'s peanut for you"
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "why so many downvotes?"
                    },
                    {
                        "username": "RoyTiya",
                        "content": "create a function similar to dfs"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Annoyed by the [] input, but other than that nice BFS question "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "started with Tree... It will become a forest by the end of this week"
                    },
                    {
                        "username": "user7784OB",
                        "content": "I must have missed something.\\nHow to run it locally to test?"
                    },
                    {
                        "username": "0x6B0",
                        "content": "The button \\'Run\\' beside the \\'Submit\\'. You can also provide custom testcases by going into the \\'Testcase\\' tab in the console. "
                    }
                ]
            },
            {
                "id": 1965242,
                "content": [
                    {
                        "username": "sameerk2k01",
                        "content": "If this is a case that it is a right skewed binary tree then what approach should be used to get to the leaf node\\'s height.\\nBecause the simple and obvious answer works perfect for other cases expect this skewed binary tree."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "the breadth first search solution is quite tricky and beautiful !"
                    },
                    {
                        "username": "peterfarrell66",
                        "content": "So the numbers in the root array are already TreeNodes?"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Use BFS is a good idea, until you find the first node that has no left and right children"
                    },
                    {
                        "username": "ritvik12_",
                        "content": "easy question if you know traversal of tree then it\\'s peanut for you"
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "why so many downvotes?"
                    },
                    {
                        "username": "RoyTiya",
                        "content": "create a function similar to dfs"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Annoyed by the [] input, but other than that nice BFS question "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "started with Tree... It will become a forest by the end of this week"
                    },
                    {
                        "username": "user7784OB",
                        "content": "I must have missed something.\\nHow to run it locally to test?"
                    },
                    {
                        "username": "0x6B0",
                        "content": "The button \\'Run\\' beside the \\'Submit\\'. You can also provide custom testcases by going into the \\'Testcase\\' tab in the console. "
                    }
                ]
            },
            {
                "id": 1964895,
                "content": [
                    {
                        "username": "sameerk2k01",
                        "content": "If this is a case that it is a right skewed binary tree then what approach should be used to get to the leaf node\\'s height.\\nBecause the simple and obvious answer works perfect for other cases expect this skewed binary tree."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "the breadth first search solution is quite tricky and beautiful !"
                    },
                    {
                        "username": "peterfarrell66",
                        "content": "So the numbers in the root array are already TreeNodes?"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Use BFS is a good idea, until you find the first node that has no left and right children"
                    },
                    {
                        "username": "ritvik12_",
                        "content": "easy question if you know traversal of tree then it\\'s peanut for you"
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "why so many downvotes?"
                    },
                    {
                        "username": "RoyTiya",
                        "content": "create a function similar to dfs"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Annoyed by the [] input, but other than that nice BFS question "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "started with Tree... It will become a forest by the end of this week"
                    },
                    {
                        "username": "user7784OB",
                        "content": "I must have missed something.\\nHow to run it locally to test?"
                    },
                    {
                        "username": "0x6B0",
                        "content": "The button \\'Run\\' beside the \\'Submit\\'. You can also provide custom testcases by going into the \\'Testcase\\' tab in the console. "
                    }
                ]
            },
            {
                "id": 1964669,
                "content": [
                    {
                        "username": "sameerk2k01",
                        "content": "If this is a case that it is a right skewed binary tree then what approach should be used to get to the leaf node\\'s height.\\nBecause the simple and obvious answer works perfect for other cases expect this skewed binary tree."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "the breadth first search solution is quite tricky and beautiful !"
                    },
                    {
                        "username": "peterfarrell66",
                        "content": "So the numbers in the root array are already TreeNodes?"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Use BFS is a good idea, until you find the first node that has no left and right children"
                    },
                    {
                        "username": "ritvik12_",
                        "content": "easy question if you know traversal of tree then it\\'s peanut for you"
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "why so many downvotes?"
                    },
                    {
                        "username": "RoyTiya",
                        "content": "create a function similar to dfs"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Annoyed by the [] input, but other than that nice BFS question "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "started with Tree... It will become a forest by the end of this week"
                    },
                    {
                        "username": "user7784OB",
                        "content": "I must have missed something.\\nHow to run it locally to test?"
                    },
                    {
                        "username": "0x6B0",
                        "content": "The button \\'Run\\' beside the \\'Submit\\'. You can also provide custom testcases by going into the \\'Testcase\\' tab in the console. "
                    }
                ]
            },
            {
                "id": 1964600,
                "content": [
                    {
                        "username": "sameerk2k01",
                        "content": "If this is a case that it is a right skewed binary tree then what approach should be used to get to the leaf node\\'s height.\\nBecause the simple and obvious answer works perfect for other cases expect this skewed binary tree."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "the breadth first search solution is quite tricky and beautiful !"
                    },
                    {
                        "username": "peterfarrell66",
                        "content": "So the numbers in the root array are already TreeNodes?"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Use BFS is a good idea, until you find the first node that has no left and right children"
                    },
                    {
                        "username": "ritvik12_",
                        "content": "easy question if you know traversal of tree then it\\'s peanut for you"
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "why so many downvotes?"
                    },
                    {
                        "username": "RoyTiya",
                        "content": "create a function similar to dfs"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Annoyed by the [] input, but other than that nice BFS question "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "started with Tree... It will become a forest by the end of this week"
                    },
                    {
                        "username": "user7784OB",
                        "content": "I must have missed something.\\nHow to run it locally to test?"
                    },
                    {
                        "username": "0x6B0",
                        "content": "The button \\'Run\\' beside the \\'Submit\\'. You can also provide custom testcases by going into the \\'Testcase\\' tab in the console. "
                    }
                ]
            },
            {
                "id": 1964496,
                "content": [
                    {
                        "username": "sameerk2k01",
                        "content": "If this is a case that it is a right skewed binary tree then what approach should be used to get to the leaf node\\'s height.\\nBecause the simple and obvious answer works perfect for other cases expect this skewed binary tree."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "the breadth first search solution is quite tricky and beautiful !"
                    },
                    {
                        "username": "peterfarrell66",
                        "content": "So the numbers in the root array are already TreeNodes?"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Use BFS is a good idea, until you find the first node that has no left and right children"
                    },
                    {
                        "username": "ritvik12_",
                        "content": "easy question if you know traversal of tree then it\\'s peanut for you"
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "why so many downvotes?"
                    },
                    {
                        "username": "RoyTiya",
                        "content": "create a function similar to dfs"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Annoyed by the [] input, but other than that nice BFS question "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "started with Tree... It will become a forest by the end of this week"
                    },
                    {
                        "username": "user7784OB",
                        "content": "I must have missed something.\\nHow to run it locally to test?"
                    },
                    {
                        "username": "0x6B0",
                        "content": "The button \\'Run\\' beside the \\'Submit\\'. You can also provide custom testcases by going into the \\'Testcase\\' tab in the console. "
                    }
                ]
            },
            {
                "id": 1964404,
                "content": [
                    {
                        "username": "sameerk2k01",
                        "content": "If this is a case that it is a right skewed binary tree then what approach should be used to get to the leaf node\\'s height.\\nBecause the simple and obvious answer works perfect for other cases expect this skewed binary tree."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "the breadth first search solution is quite tricky and beautiful !"
                    },
                    {
                        "username": "peterfarrell66",
                        "content": "So the numbers in the root array are already TreeNodes?"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Use BFS is a good idea, until you find the first node that has no left and right children"
                    },
                    {
                        "username": "ritvik12_",
                        "content": "easy question if you know traversal of tree then it\\'s peanut for you"
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "why so many downvotes?"
                    },
                    {
                        "username": "RoyTiya",
                        "content": "create a function similar to dfs"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Annoyed by the [] input, but other than that nice BFS question "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "started with Tree... It will become a forest by the end of this week"
                    },
                    {
                        "username": "user7784OB",
                        "content": "I must have missed something.\\nHow to run it locally to test?"
                    },
                    {
                        "username": "0x6B0",
                        "content": "The button \\'Run\\' beside the \\'Submit\\'. You can also provide custom testcases by going into the \\'Testcase\\' tab in the console. "
                    }
                ]
            },
            {
                "id": 1964226,
                "content": [
                    {
                        "username": "sameerk2k01",
                        "content": "If this is a case that it is a right skewed binary tree then what approach should be used to get to the leaf node\\'s height.\\nBecause the simple and obvious answer works perfect for other cases expect this skewed binary tree."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "the breadth first search solution is quite tricky and beautiful !"
                    },
                    {
                        "username": "peterfarrell66",
                        "content": "So the numbers in the root array are already TreeNodes?"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Use BFS is a good idea, until you find the first node that has no left and right children"
                    },
                    {
                        "username": "ritvik12_",
                        "content": "easy question if you know traversal of tree then it\\'s peanut for you"
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "why so many downvotes?"
                    },
                    {
                        "username": "RoyTiya",
                        "content": "create a function similar to dfs"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Annoyed by the [] input, but other than that nice BFS question "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "started with Tree... It will become a forest by the end of this week"
                    },
                    {
                        "username": "user7784OB",
                        "content": "I must have missed something.\\nHow to run it locally to test?"
                    },
                    {
                        "username": "0x6B0",
                        "content": "The button \\'Run\\' beside the \\'Submit\\'. You can also provide custom testcases by going into the \\'Testcase\\' tab in the console. "
                    }
                ]
            },
            {
                "id": 1964208,
                "content": [
                    {
                        "username": "sameerk2k01",
                        "content": "If this is a case that it is a right skewed binary tree then what approach should be used to get to the leaf node\\'s height.\\nBecause the simple and obvious answer works perfect for other cases expect this skewed binary tree."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "the breadth first search solution is quite tricky and beautiful !"
                    },
                    {
                        "username": "peterfarrell66",
                        "content": "So the numbers in the root array are already TreeNodes?"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Use BFS is a good idea, until you find the first node that has no left and right children"
                    },
                    {
                        "username": "ritvik12_",
                        "content": "easy question if you know traversal of tree then it\\'s peanut for you"
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "why so many downvotes?"
                    },
                    {
                        "username": "RoyTiya",
                        "content": "create a function similar to dfs"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Annoyed by the [] input, but other than that nice BFS question "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "started with Tree... It will become a forest by the end of this week"
                    },
                    {
                        "username": "user7784OB",
                        "content": "I must have missed something.\\nHow to run it locally to test?"
                    },
                    {
                        "username": "0x6B0",
                        "content": "The button \\'Run\\' beside the \\'Submit\\'. You can also provide custom testcases by going into the \\'Testcase\\' tab in the console. "
                    }
                ]
            },
            {
                "id": 1964183,
                "content": [
                    {
                        "username": "sameerk2k01",
                        "content": "If this is a case that it is a right skewed binary tree then what approach should be used to get to the leaf node\\'s height.\\nBecause the simple and obvious answer works perfect for other cases expect this skewed binary tree."
                    },
                    {
                        "username": "meetmejerry",
                        "content": "the breadth first search solution is quite tricky and beautiful !"
                    },
                    {
                        "username": "peterfarrell66",
                        "content": "So the numbers in the root array are already TreeNodes?"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Use BFS is a good idea, until you find the first node that has no left and right children"
                    },
                    {
                        "username": "ritvik12_",
                        "content": "easy question if you know traversal of tree then it\\'s peanut for you"
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "why so many downvotes?"
                    },
                    {
                        "username": "RoyTiya",
                        "content": "create a function similar to dfs"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Annoyed by the [] input, but other than that nice BFS question "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "started with Tree... It will become a forest by the end of this week"
                    },
                    {
                        "username": "user7784OB",
                        "content": "I must have missed something.\\nHow to run it locally to test?"
                    },
                    {
                        "username": "0x6B0",
                        "content": "The button \\'Run\\' beside the \\'Submit\\'. You can also provide custom testcases by going into the \\'Testcase\\' tab in the console. "
                    }
                ]
            },
            {
                "id": 1964161,
                "content": [
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "min depth is when both left and right child are NULL not single child "
                    },
                    {
                        "username": "rishabgt",
                        "content": "Low-key BFS tutorial\\n\\nP.S. Can be solved using DFS but BFS will be always the better performing one here."
                    },
                    {
                        "username": "_aka5h",
                        "content": "A leaf node is a node that does not have left and right child, having either of the left or right child makes it a non-leaf node.."
                    },
                    {
                        "username": "raunakmodanwal321",
                        "content": "Anyone explain why testcase2 will give 5 as output not 1."
                    },
                    {
                        "username": "bparanj",
                        "content": "The tree for testcase 2 is represented as [2,null,3,null,4,null,5,null,6], and the actual structure is as follows:\\n\\n```\\n    2\\n     \\\\\\n      3\\n       \\\\\\n        4\\n         \\\\\\n          5\\n           \\\\\\n            6\\n```\\n\\nYou can see that the shortest path from the root node (2) to the nearest leaf node (which is 6) is of length 5, traversing through nodes 3, 4, 5, and 6. \\n\\nThe rule to calculate the minimum depth is from the root node down to the nearest leaf node. A leaf node is a node with no children. In this case, node 6 is the only leaf node. So the minimum depth of the tree is the distance from root node 2 to leaf node 6, which is 5.\\n\\nSo, the output is 5, not 1."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "If you dont watch the testcases in source you get a tree to watch.\\nTell my why the root with depth=1 has no children and is a leaf?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "last been a tough week"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I missed the point **Shortest path from root to nearest leaf node**. However sample tc 2 saved me !!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Now leetcode showing empathy by giving easy question.\n\nsimple question just apply level order traversal until you get a leaf node i.e. node with no child"
                    },
                    {
                        "username": "najwer23",
                        "content": "easy mondays are back!"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS (PreOrder) traversal. Easy Recursive\\n\\n# Approach\\n1. Define a recursive function `rec` that takes three parameters: a `TreeNode*` root, an integer reference `ans`, and an integer `lvl` representing the current level.\\n2. Check if the root node is null (`!root`). If true, return.\\n3. Check if the root node is a leaf node (no left or right child) (`!root->left && !root->right`).\\n   - If true, update the minimum depth (`ans`) by taking the minimum between the current `ans` and the current level (`lvl`) using the `min` function.\\n   - Then, return.\\n4. Recursively call the `rec` function on the left child of the root with an incremented level (`lvl + 1`).\\n5. Recursively call the `rec` function on the right child of the root with an incremented level (`lvl + 1`).\\n6. Define the `minDepth` function that takes a `TreeNode*` root and returns an integer.\\n7. Check if the root node is null (`!root`).\\n   - If true, return 0 since the tree is empty.\\n8. Initialize an integer `ans` with the maximum possible value.\\n9. Call the `rec` function on the root node, passing the root, `ans`, and 1 as the initial level.\\n10. Return the `ans`, which represents the minimum depth of the binary tree.\\n\\n----------------------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h). h=height of binary tree. In worst case upto \"n\" for skewed tree.\\n--------------------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/minimum-depth-of-binary-tree/solutions/3743645/c-dfs-preorder-traversal-easy-recursive/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Ah, finally!! \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    }
                ]
            },
            {
                "id": 1964146,
                "content": [
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "min depth is when both left and right child are NULL not single child "
                    },
                    {
                        "username": "rishabgt",
                        "content": "Low-key BFS tutorial\\n\\nP.S. Can be solved using DFS but BFS will be always the better performing one here."
                    },
                    {
                        "username": "_aka5h",
                        "content": "A leaf node is a node that does not have left and right child, having either of the left or right child makes it a non-leaf node.."
                    },
                    {
                        "username": "raunakmodanwal321",
                        "content": "Anyone explain why testcase2 will give 5 as output not 1."
                    },
                    {
                        "username": "bparanj",
                        "content": "The tree for testcase 2 is represented as [2,null,3,null,4,null,5,null,6], and the actual structure is as follows:\\n\\n```\\n    2\\n     \\\\\\n      3\\n       \\\\\\n        4\\n         \\\\\\n          5\\n           \\\\\\n            6\\n```\\n\\nYou can see that the shortest path from the root node (2) to the nearest leaf node (which is 6) is of length 5, traversing through nodes 3, 4, 5, and 6. \\n\\nThe rule to calculate the minimum depth is from the root node down to the nearest leaf node. A leaf node is a node with no children. In this case, node 6 is the only leaf node. So the minimum depth of the tree is the distance from root node 2 to leaf node 6, which is 5.\\n\\nSo, the output is 5, not 1."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "If you dont watch the testcases in source you get a tree to watch.\\nTell my why the root with depth=1 has no children and is a leaf?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "last been a tough week"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I missed the point **Shortest path from root to nearest leaf node**. However sample tc 2 saved me !!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Now leetcode showing empathy by giving easy question.\n\nsimple question just apply level order traversal until you get a leaf node i.e. node with no child"
                    },
                    {
                        "username": "najwer23",
                        "content": "easy mondays are back!"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS (PreOrder) traversal. Easy Recursive\\n\\n# Approach\\n1. Define a recursive function `rec` that takes three parameters: a `TreeNode*` root, an integer reference `ans`, and an integer `lvl` representing the current level.\\n2. Check if the root node is null (`!root`). If true, return.\\n3. Check if the root node is a leaf node (no left or right child) (`!root->left && !root->right`).\\n   - If true, update the minimum depth (`ans`) by taking the minimum between the current `ans` and the current level (`lvl`) using the `min` function.\\n   - Then, return.\\n4. Recursively call the `rec` function on the left child of the root with an incremented level (`lvl + 1`).\\n5. Recursively call the `rec` function on the right child of the root with an incremented level (`lvl + 1`).\\n6. Define the `minDepth` function that takes a `TreeNode*` root and returns an integer.\\n7. Check if the root node is null (`!root`).\\n   - If true, return 0 since the tree is empty.\\n8. Initialize an integer `ans` with the maximum possible value.\\n9. Call the `rec` function on the root node, passing the root, `ans`, and 1 as the initial level.\\n10. Return the `ans`, which represents the minimum depth of the binary tree.\\n\\n----------------------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h). h=height of binary tree. In worst case upto \"n\" for skewed tree.\\n--------------------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/minimum-depth-of-binary-tree/solutions/3743645/c-dfs-preorder-traversal-easy-recursive/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Ah, finally!! \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    }
                ]
            },
            {
                "id": 1963993,
                "content": [
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "min depth is when both left and right child are NULL not single child "
                    },
                    {
                        "username": "rishabgt",
                        "content": "Low-key BFS tutorial\\n\\nP.S. Can be solved using DFS but BFS will be always the better performing one here."
                    },
                    {
                        "username": "_aka5h",
                        "content": "A leaf node is a node that does not have left and right child, having either of the left or right child makes it a non-leaf node.."
                    },
                    {
                        "username": "raunakmodanwal321",
                        "content": "Anyone explain why testcase2 will give 5 as output not 1."
                    },
                    {
                        "username": "bparanj",
                        "content": "The tree for testcase 2 is represented as [2,null,3,null,4,null,5,null,6], and the actual structure is as follows:\\n\\n```\\n    2\\n     \\\\\\n      3\\n       \\\\\\n        4\\n         \\\\\\n          5\\n           \\\\\\n            6\\n```\\n\\nYou can see that the shortest path from the root node (2) to the nearest leaf node (which is 6) is of length 5, traversing through nodes 3, 4, 5, and 6. \\n\\nThe rule to calculate the minimum depth is from the root node down to the nearest leaf node. A leaf node is a node with no children. In this case, node 6 is the only leaf node. So the minimum depth of the tree is the distance from root node 2 to leaf node 6, which is 5.\\n\\nSo, the output is 5, not 1."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "If you dont watch the testcases in source you get a tree to watch.\\nTell my why the root with depth=1 has no children and is a leaf?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "last been a tough week"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I missed the point **Shortest path from root to nearest leaf node**. However sample tc 2 saved me !!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Now leetcode showing empathy by giving easy question.\n\nsimple question just apply level order traversal until you get a leaf node i.e. node with no child"
                    },
                    {
                        "username": "najwer23",
                        "content": "easy mondays are back!"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS (PreOrder) traversal. Easy Recursive\\n\\n# Approach\\n1. Define a recursive function `rec` that takes three parameters: a `TreeNode*` root, an integer reference `ans`, and an integer `lvl` representing the current level.\\n2. Check if the root node is null (`!root`). If true, return.\\n3. Check if the root node is a leaf node (no left or right child) (`!root->left && !root->right`).\\n   - If true, update the minimum depth (`ans`) by taking the minimum between the current `ans` and the current level (`lvl`) using the `min` function.\\n   - Then, return.\\n4. Recursively call the `rec` function on the left child of the root with an incremented level (`lvl + 1`).\\n5. Recursively call the `rec` function on the right child of the root with an incremented level (`lvl + 1`).\\n6. Define the `minDepth` function that takes a `TreeNode*` root and returns an integer.\\n7. Check if the root node is null (`!root`).\\n   - If true, return 0 since the tree is empty.\\n8. Initialize an integer `ans` with the maximum possible value.\\n9. Call the `rec` function on the root node, passing the root, `ans`, and 1 as the initial level.\\n10. Return the `ans`, which represents the minimum depth of the binary tree.\\n\\n----------------------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h). h=height of binary tree. In worst case upto \"n\" for skewed tree.\\n--------------------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/minimum-depth-of-binary-tree/solutions/3743645/c-dfs-preorder-traversal-easy-recursive/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Ah, finally!! \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    }
                ]
            },
            {
                "id": 1963990,
                "content": [
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "min depth is when both left and right child are NULL not single child "
                    },
                    {
                        "username": "rishabgt",
                        "content": "Low-key BFS tutorial\\n\\nP.S. Can be solved using DFS but BFS will be always the better performing one here."
                    },
                    {
                        "username": "_aka5h",
                        "content": "A leaf node is a node that does not have left and right child, having either of the left or right child makes it a non-leaf node.."
                    },
                    {
                        "username": "raunakmodanwal321",
                        "content": "Anyone explain why testcase2 will give 5 as output not 1."
                    },
                    {
                        "username": "bparanj",
                        "content": "The tree for testcase 2 is represented as [2,null,3,null,4,null,5,null,6], and the actual structure is as follows:\\n\\n```\\n    2\\n     \\\\\\n      3\\n       \\\\\\n        4\\n         \\\\\\n          5\\n           \\\\\\n            6\\n```\\n\\nYou can see that the shortest path from the root node (2) to the nearest leaf node (which is 6) is of length 5, traversing through nodes 3, 4, 5, and 6. \\n\\nThe rule to calculate the minimum depth is from the root node down to the nearest leaf node. A leaf node is a node with no children. In this case, node 6 is the only leaf node. So the minimum depth of the tree is the distance from root node 2 to leaf node 6, which is 5.\\n\\nSo, the output is 5, not 1."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "If you dont watch the testcases in source you get a tree to watch.\\nTell my why the root with depth=1 has no children and is a leaf?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "last been a tough week"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I missed the point **Shortest path from root to nearest leaf node**. However sample tc 2 saved me !!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Now leetcode showing empathy by giving easy question.\n\nsimple question just apply level order traversal until you get a leaf node i.e. node with no child"
                    },
                    {
                        "username": "najwer23",
                        "content": "easy mondays are back!"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS (PreOrder) traversal. Easy Recursive\\n\\n# Approach\\n1. Define a recursive function `rec` that takes three parameters: a `TreeNode*` root, an integer reference `ans`, and an integer `lvl` representing the current level.\\n2. Check if the root node is null (`!root`). If true, return.\\n3. Check if the root node is a leaf node (no left or right child) (`!root->left && !root->right`).\\n   - If true, update the minimum depth (`ans`) by taking the minimum between the current `ans` and the current level (`lvl`) using the `min` function.\\n   - Then, return.\\n4. Recursively call the `rec` function on the left child of the root with an incremented level (`lvl + 1`).\\n5. Recursively call the `rec` function on the right child of the root with an incremented level (`lvl + 1`).\\n6. Define the `minDepth` function that takes a `TreeNode*` root and returns an integer.\\n7. Check if the root node is null (`!root`).\\n   - If true, return 0 since the tree is empty.\\n8. Initialize an integer `ans` with the maximum possible value.\\n9. Call the `rec` function on the root node, passing the root, `ans`, and 1 as the initial level.\\n10. Return the `ans`, which represents the minimum depth of the binary tree.\\n\\n----------------------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h). h=height of binary tree. In worst case upto \"n\" for skewed tree.\\n--------------------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/minimum-depth-of-binary-tree/solutions/3743645/c-dfs-preorder-traversal-easy-recursive/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Ah, finally!! \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    }
                ]
            },
            {
                "id": 1963988,
                "content": [
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "min depth is when both left and right child are NULL not single child "
                    },
                    {
                        "username": "rishabgt",
                        "content": "Low-key BFS tutorial\\n\\nP.S. Can be solved using DFS but BFS will be always the better performing one here."
                    },
                    {
                        "username": "_aka5h",
                        "content": "A leaf node is a node that does not have left and right child, having either of the left or right child makes it a non-leaf node.."
                    },
                    {
                        "username": "raunakmodanwal321",
                        "content": "Anyone explain why testcase2 will give 5 as output not 1."
                    },
                    {
                        "username": "bparanj",
                        "content": "The tree for testcase 2 is represented as [2,null,3,null,4,null,5,null,6], and the actual structure is as follows:\\n\\n```\\n    2\\n     \\\\\\n      3\\n       \\\\\\n        4\\n         \\\\\\n          5\\n           \\\\\\n            6\\n```\\n\\nYou can see that the shortest path from the root node (2) to the nearest leaf node (which is 6) is of length 5, traversing through nodes 3, 4, 5, and 6. \\n\\nThe rule to calculate the minimum depth is from the root node down to the nearest leaf node. A leaf node is a node with no children. In this case, node 6 is the only leaf node. So the minimum depth of the tree is the distance from root node 2 to leaf node 6, which is 5.\\n\\nSo, the output is 5, not 1."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "If you dont watch the testcases in source you get a tree to watch.\\nTell my why the root with depth=1 has no children and is a leaf?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "last been a tough week"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I missed the point **Shortest path from root to nearest leaf node**. However sample tc 2 saved me !!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Now leetcode showing empathy by giving easy question.\n\nsimple question just apply level order traversal until you get a leaf node i.e. node with no child"
                    },
                    {
                        "username": "najwer23",
                        "content": "easy mondays are back!"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS (PreOrder) traversal. Easy Recursive\\n\\n# Approach\\n1. Define a recursive function `rec` that takes three parameters: a `TreeNode*` root, an integer reference `ans`, and an integer `lvl` representing the current level.\\n2. Check if the root node is null (`!root`). If true, return.\\n3. Check if the root node is a leaf node (no left or right child) (`!root->left && !root->right`).\\n   - If true, update the minimum depth (`ans`) by taking the minimum between the current `ans` and the current level (`lvl`) using the `min` function.\\n   - Then, return.\\n4. Recursively call the `rec` function on the left child of the root with an incremented level (`lvl + 1`).\\n5. Recursively call the `rec` function on the right child of the root with an incremented level (`lvl + 1`).\\n6. Define the `minDepth` function that takes a `TreeNode*` root and returns an integer.\\n7. Check if the root node is null (`!root`).\\n   - If true, return 0 since the tree is empty.\\n8. Initialize an integer `ans` with the maximum possible value.\\n9. Call the `rec` function on the root node, passing the root, `ans`, and 1 as the initial level.\\n10. Return the `ans`, which represents the minimum depth of the binary tree.\\n\\n----------------------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h). h=height of binary tree. In worst case upto \"n\" for skewed tree.\\n--------------------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/minimum-depth-of-binary-tree/solutions/3743645/c-dfs-preorder-traversal-easy-recursive/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Ah, finally!! \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    }
                ]
            },
            {
                "id": 1963927,
                "content": [
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "min depth is when both left and right child are NULL not single child "
                    },
                    {
                        "username": "rishabgt",
                        "content": "Low-key BFS tutorial\\n\\nP.S. Can be solved using DFS but BFS will be always the better performing one here."
                    },
                    {
                        "username": "_aka5h",
                        "content": "A leaf node is a node that does not have left and right child, having either of the left or right child makes it a non-leaf node.."
                    },
                    {
                        "username": "raunakmodanwal321",
                        "content": "Anyone explain why testcase2 will give 5 as output not 1."
                    },
                    {
                        "username": "bparanj",
                        "content": "The tree for testcase 2 is represented as [2,null,3,null,4,null,5,null,6], and the actual structure is as follows:\\n\\n```\\n    2\\n     \\\\\\n      3\\n       \\\\\\n        4\\n         \\\\\\n          5\\n           \\\\\\n            6\\n```\\n\\nYou can see that the shortest path from the root node (2) to the nearest leaf node (which is 6) is of length 5, traversing through nodes 3, 4, 5, and 6. \\n\\nThe rule to calculate the minimum depth is from the root node down to the nearest leaf node. A leaf node is a node with no children. In this case, node 6 is the only leaf node. So the minimum depth of the tree is the distance from root node 2 to leaf node 6, which is 5.\\n\\nSo, the output is 5, not 1."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "If you dont watch the testcases in source you get a tree to watch.\\nTell my why the root with depth=1 has no children and is a leaf?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "last been a tough week"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I missed the point **Shortest path from root to nearest leaf node**. However sample tc 2 saved me !!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Now leetcode showing empathy by giving easy question.\n\nsimple question just apply level order traversal until you get a leaf node i.e. node with no child"
                    },
                    {
                        "username": "najwer23",
                        "content": "easy mondays are back!"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS (PreOrder) traversal. Easy Recursive\\n\\n# Approach\\n1. Define a recursive function `rec` that takes three parameters: a `TreeNode*` root, an integer reference `ans`, and an integer `lvl` representing the current level.\\n2. Check if the root node is null (`!root`). If true, return.\\n3. Check if the root node is a leaf node (no left or right child) (`!root->left && !root->right`).\\n   - If true, update the minimum depth (`ans`) by taking the minimum between the current `ans` and the current level (`lvl`) using the `min` function.\\n   - Then, return.\\n4. Recursively call the `rec` function on the left child of the root with an incremented level (`lvl + 1`).\\n5. Recursively call the `rec` function on the right child of the root with an incremented level (`lvl + 1`).\\n6. Define the `minDepth` function that takes a `TreeNode*` root and returns an integer.\\n7. Check if the root node is null (`!root`).\\n   - If true, return 0 since the tree is empty.\\n8. Initialize an integer `ans` with the maximum possible value.\\n9. Call the `rec` function on the root node, passing the root, `ans`, and 1 as the initial level.\\n10. Return the `ans`, which represents the minimum depth of the binary tree.\\n\\n----------------------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h). h=height of binary tree. In worst case upto \"n\" for skewed tree.\\n--------------------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/minimum-depth-of-binary-tree/solutions/3743645/c-dfs-preorder-traversal-easy-recursive/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Ah, finally!! \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    }
                ]
            },
            {
                "id": 1963906,
                "content": [
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "min depth is when both left and right child are NULL not single child "
                    },
                    {
                        "username": "rishabgt",
                        "content": "Low-key BFS tutorial\\n\\nP.S. Can be solved using DFS but BFS will be always the better performing one here."
                    },
                    {
                        "username": "_aka5h",
                        "content": "A leaf node is a node that does not have left and right child, having either of the left or right child makes it a non-leaf node.."
                    },
                    {
                        "username": "raunakmodanwal321",
                        "content": "Anyone explain why testcase2 will give 5 as output not 1."
                    },
                    {
                        "username": "bparanj",
                        "content": "The tree for testcase 2 is represented as [2,null,3,null,4,null,5,null,6], and the actual structure is as follows:\\n\\n```\\n    2\\n     \\\\\\n      3\\n       \\\\\\n        4\\n         \\\\\\n          5\\n           \\\\\\n            6\\n```\\n\\nYou can see that the shortest path from the root node (2) to the nearest leaf node (which is 6) is of length 5, traversing through nodes 3, 4, 5, and 6. \\n\\nThe rule to calculate the minimum depth is from the root node down to the nearest leaf node. A leaf node is a node with no children. In this case, node 6 is the only leaf node. So the minimum depth of the tree is the distance from root node 2 to leaf node 6, which is 5.\\n\\nSo, the output is 5, not 1."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "If you dont watch the testcases in source you get a tree to watch.\\nTell my why the root with depth=1 has no children and is a leaf?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "last been a tough week"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I missed the point **Shortest path from root to nearest leaf node**. However sample tc 2 saved me !!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Now leetcode showing empathy by giving easy question.\n\nsimple question just apply level order traversal until you get a leaf node i.e. node with no child"
                    },
                    {
                        "username": "najwer23",
                        "content": "easy mondays are back!"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS (PreOrder) traversal. Easy Recursive\\n\\n# Approach\\n1. Define a recursive function `rec` that takes three parameters: a `TreeNode*` root, an integer reference `ans`, and an integer `lvl` representing the current level.\\n2. Check if the root node is null (`!root`). If true, return.\\n3. Check if the root node is a leaf node (no left or right child) (`!root->left && !root->right`).\\n   - If true, update the minimum depth (`ans`) by taking the minimum between the current `ans` and the current level (`lvl`) using the `min` function.\\n   - Then, return.\\n4. Recursively call the `rec` function on the left child of the root with an incremented level (`lvl + 1`).\\n5. Recursively call the `rec` function on the right child of the root with an incremented level (`lvl + 1`).\\n6. Define the `minDepth` function that takes a `TreeNode*` root and returns an integer.\\n7. Check if the root node is null (`!root`).\\n   - If true, return 0 since the tree is empty.\\n8. Initialize an integer `ans` with the maximum possible value.\\n9. Call the `rec` function on the root node, passing the root, `ans`, and 1 as the initial level.\\n10. Return the `ans`, which represents the minimum depth of the binary tree.\\n\\n----------------------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h). h=height of binary tree. In worst case upto \"n\" for skewed tree.\\n--------------------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/minimum-depth-of-binary-tree/solutions/3743645/c-dfs-preorder-traversal-easy-recursive/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Ah, finally!! \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    }
                ]
            },
            {
                "id": 1963851,
                "content": [
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "min depth is when both left and right child are NULL not single child "
                    },
                    {
                        "username": "rishabgt",
                        "content": "Low-key BFS tutorial\\n\\nP.S. Can be solved using DFS but BFS will be always the better performing one here."
                    },
                    {
                        "username": "_aka5h",
                        "content": "A leaf node is a node that does not have left and right child, having either of the left or right child makes it a non-leaf node.."
                    },
                    {
                        "username": "raunakmodanwal321",
                        "content": "Anyone explain why testcase2 will give 5 as output not 1."
                    },
                    {
                        "username": "bparanj",
                        "content": "The tree for testcase 2 is represented as [2,null,3,null,4,null,5,null,6], and the actual structure is as follows:\\n\\n```\\n    2\\n     \\\\\\n      3\\n       \\\\\\n        4\\n         \\\\\\n          5\\n           \\\\\\n            6\\n```\\n\\nYou can see that the shortest path from the root node (2) to the nearest leaf node (which is 6) is of length 5, traversing through nodes 3, 4, 5, and 6. \\n\\nThe rule to calculate the minimum depth is from the root node down to the nearest leaf node. A leaf node is a node with no children. In this case, node 6 is the only leaf node. So the minimum depth of the tree is the distance from root node 2 to leaf node 6, which is 5.\\n\\nSo, the output is 5, not 1."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "If you dont watch the testcases in source you get a tree to watch.\\nTell my why the root with depth=1 has no children and is a leaf?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "last been a tough week"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I missed the point **Shortest path from root to nearest leaf node**. However sample tc 2 saved me !!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Now leetcode showing empathy by giving easy question.\n\nsimple question just apply level order traversal until you get a leaf node i.e. node with no child"
                    },
                    {
                        "username": "najwer23",
                        "content": "easy mondays are back!"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS (PreOrder) traversal. Easy Recursive\\n\\n# Approach\\n1. Define a recursive function `rec` that takes three parameters: a `TreeNode*` root, an integer reference `ans`, and an integer `lvl` representing the current level.\\n2. Check if the root node is null (`!root`). If true, return.\\n3. Check if the root node is a leaf node (no left or right child) (`!root->left && !root->right`).\\n   - If true, update the minimum depth (`ans`) by taking the minimum between the current `ans` and the current level (`lvl`) using the `min` function.\\n   - Then, return.\\n4. Recursively call the `rec` function on the left child of the root with an incremented level (`lvl + 1`).\\n5. Recursively call the `rec` function on the right child of the root with an incremented level (`lvl + 1`).\\n6. Define the `minDepth` function that takes a `TreeNode*` root and returns an integer.\\n7. Check if the root node is null (`!root`).\\n   - If true, return 0 since the tree is empty.\\n8. Initialize an integer `ans` with the maximum possible value.\\n9. Call the `rec` function on the root node, passing the root, `ans`, and 1 as the initial level.\\n10. Return the `ans`, which represents the minimum depth of the binary tree.\\n\\n----------------------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h). h=height of binary tree. In worst case upto \"n\" for skewed tree.\\n--------------------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/minimum-depth-of-binary-tree/solutions/3743645/c-dfs-preorder-traversal-easy-recursive/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Ah, finally!! \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    }
                ]
            },
            {
                "id": 1963843,
                "content": [
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "min depth is when both left and right child are NULL not single child "
                    },
                    {
                        "username": "rishabgt",
                        "content": "Low-key BFS tutorial\\n\\nP.S. Can be solved using DFS but BFS will be always the better performing one here."
                    },
                    {
                        "username": "_aka5h",
                        "content": "A leaf node is a node that does not have left and right child, having either of the left or right child makes it a non-leaf node.."
                    },
                    {
                        "username": "raunakmodanwal321",
                        "content": "Anyone explain why testcase2 will give 5 as output not 1."
                    },
                    {
                        "username": "bparanj",
                        "content": "The tree for testcase 2 is represented as [2,null,3,null,4,null,5,null,6], and the actual structure is as follows:\\n\\n```\\n    2\\n     \\\\\\n      3\\n       \\\\\\n        4\\n         \\\\\\n          5\\n           \\\\\\n            6\\n```\\n\\nYou can see that the shortest path from the root node (2) to the nearest leaf node (which is 6) is of length 5, traversing through nodes 3, 4, 5, and 6. \\n\\nThe rule to calculate the minimum depth is from the root node down to the nearest leaf node. A leaf node is a node with no children. In this case, node 6 is the only leaf node. So the minimum depth of the tree is the distance from root node 2 to leaf node 6, which is 5.\\n\\nSo, the output is 5, not 1."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "If you dont watch the testcases in source you get a tree to watch.\\nTell my why the root with depth=1 has no children and is a leaf?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "last been a tough week"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I missed the point **Shortest path from root to nearest leaf node**. However sample tc 2 saved me !!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Now leetcode showing empathy by giving easy question.\n\nsimple question just apply level order traversal until you get a leaf node i.e. node with no child"
                    },
                    {
                        "username": "najwer23",
                        "content": "easy mondays are back!"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS (PreOrder) traversal. Easy Recursive\\n\\n# Approach\\n1. Define a recursive function `rec` that takes three parameters: a `TreeNode*` root, an integer reference `ans`, and an integer `lvl` representing the current level.\\n2. Check if the root node is null (`!root`). If true, return.\\n3. Check if the root node is a leaf node (no left or right child) (`!root->left && !root->right`).\\n   - If true, update the minimum depth (`ans`) by taking the minimum between the current `ans` and the current level (`lvl`) using the `min` function.\\n   - Then, return.\\n4. Recursively call the `rec` function on the left child of the root with an incremented level (`lvl + 1`).\\n5. Recursively call the `rec` function on the right child of the root with an incremented level (`lvl + 1`).\\n6. Define the `minDepth` function that takes a `TreeNode*` root and returns an integer.\\n7. Check if the root node is null (`!root`).\\n   - If true, return 0 since the tree is empty.\\n8. Initialize an integer `ans` with the maximum possible value.\\n9. Call the `rec` function on the root node, passing the root, `ans`, and 1 as the initial level.\\n10. Return the `ans`, which represents the minimum depth of the binary tree.\\n\\n----------------------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h). h=height of binary tree. In worst case upto \"n\" for skewed tree.\\n--------------------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/minimum-depth-of-binary-tree/solutions/3743645/c-dfs-preorder-traversal-easy-recursive/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Ah, finally!! \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    }
                ]
            },
            {
                "id": 1963779,
                "content": [
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "min depth is when both left and right child are NULL not single child "
                    },
                    {
                        "username": "rishabgt",
                        "content": "Low-key BFS tutorial\\n\\nP.S. Can be solved using DFS but BFS will be always the better performing one here."
                    },
                    {
                        "username": "_aka5h",
                        "content": "A leaf node is a node that does not have left and right child, having either of the left or right child makes it a non-leaf node.."
                    },
                    {
                        "username": "raunakmodanwal321",
                        "content": "Anyone explain why testcase2 will give 5 as output not 1."
                    },
                    {
                        "username": "bparanj",
                        "content": "The tree for testcase 2 is represented as [2,null,3,null,4,null,5,null,6], and the actual structure is as follows:\\n\\n```\\n    2\\n     \\\\\\n      3\\n       \\\\\\n        4\\n         \\\\\\n          5\\n           \\\\\\n            6\\n```\\n\\nYou can see that the shortest path from the root node (2) to the nearest leaf node (which is 6) is of length 5, traversing through nodes 3, 4, 5, and 6. \\n\\nThe rule to calculate the minimum depth is from the root node down to the nearest leaf node. A leaf node is a node with no children. In this case, node 6 is the only leaf node. So the minimum depth of the tree is the distance from root node 2 to leaf node 6, which is 5.\\n\\nSo, the output is 5, not 1."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "If you dont watch the testcases in source you get a tree to watch.\\nTell my why the root with depth=1 has no children and is a leaf?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "last been a tough week"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I missed the point **Shortest path from root to nearest leaf node**. However sample tc 2 saved me !!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Now leetcode showing empathy by giving easy question.\n\nsimple question just apply level order traversal until you get a leaf node i.e. node with no child"
                    },
                    {
                        "username": "najwer23",
                        "content": "easy mondays are back!"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS (PreOrder) traversal. Easy Recursive\\n\\n# Approach\\n1. Define a recursive function `rec` that takes three parameters: a `TreeNode*` root, an integer reference `ans`, and an integer `lvl` representing the current level.\\n2. Check if the root node is null (`!root`). If true, return.\\n3. Check if the root node is a leaf node (no left or right child) (`!root->left && !root->right`).\\n   - If true, update the minimum depth (`ans`) by taking the minimum between the current `ans` and the current level (`lvl`) using the `min` function.\\n   - Then, return.\\n4. Recursively call the `rec` function on the left child of the root with an incremented level (`lvl + 1`).\\n5. Recursively call the `rec` function on the right child of the root with an incremented level (`lvl + 1`).\\n6. Define the `minDepth` function that takes a `TreeNode*` root and returns an integer.\\n7. Check if the root node is null (`!root`).\\n   - If true, return 0 since the tree is empty.\\n8. Initialize an integer `ans` with the maximum possible value.\\n9. Call the `rec` function on the root node, passing the root, `ans`, and 1 as the initial level.\\n10. Return the `ans`, which represents the minimum depth of the binary tree.\\n\\n----------------------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h). h=height of binary tree. In worst case upto \"n\" for skewed tree.\\n--------------------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/minimum-depth-of-binary-tree/solutions/3743645/c-dfs-preorder-traversal-easy-recursive/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Ah, finally!! \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    }
                ]
            },
            {
                "id": 1963763,
                "content": [
                    {
                        "username": "Aadil42",
                        "content": "Easy Peasy Lemon Squeezy. Just do DFS."
                    },
                    {
                        "username": "noman598",
                        "content": "Finally after long time a binary tree problem."
                    },
                    {
                        "username": "mrb15",
                        "content": "Was it also a daily question on May 10, 2023?"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Finally an easy problem ,wait what ? "
                    },
                    {
                        "username": "JannisBK",
                        "content": "first time a recursive approach to a tree problem has way more runtime than its iterative counterpart"
                    },
                    {
                        "username": "mrb15",
                        "content": "the tree in second example is:\\n                        2\\n                                3\\n                                        4\\n                                                5\\n                                                        6\\ni.e. a skewed binary tree.\\nand here, according to the question, the answer should be 5 and not 1.\\nif you are doing it by using level order traversal, you code should work fine.\\nbut if you just use recursive approach, you have to take care of the fact that if left subtree is null, then min=1+minDepth(root->right) and vice versa.\\n"
                    },
                    {
                        "username": "user2987Qa",
                        "content": "i got confused by the definition and example no.2. Maybe it\\'s worth noting that *The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node **that is not a null node**.*"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "class Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        \\n        if(root == NULL){\\n            return 0;\\n        }\\n        \\n        if(root -> left == NULL and root -> right == NULL){\\n            return 1;\\n        }\\n        if(root -> left == NULL){\\n           return 1+ minDepth(root -> right);\\n        }\\n\\n        if(root -> right == NULL){\\n            return 1 + minDepth(root -> left);\\n        }\\n\\n        return 1 + min(minDepth(root -> left),minDepth(root -> right));\\n    }\\n};"
                    },
                    {
                        "username": "AditiGupta5",
                        "content": "where can we check the all the test cases of any question? In previous version, I was able to see easily but in newer version its not available. Please advise."
                    },
                    {
                        "username": "Sarita_4",
                        "content": "I don\\'t know how my 2nd test case Fail my Ans=1 but here 5  please check this case [2,null,3,null,4,null,5,null,6]"
                    },
                    {
                        "username": "shin_98",
                        "content": "As statet in description *A leaf is a node with no children*.\\nThis array `[2,null,3,null,4,null,5,null,6]` can be written as\\n`____2`\\n`null 3`\\n`__null 4`\\n`____null 5`\\n`_____null 6`\\nSo root with value 2, has one children with value 3. Next node with value 3, also has one children with value 4. And so on... Every node with values from 2 to 5 has right child, so its not a *leaf*. Only node with value 6 doesn\\'t have children, so it\\'s a leaf. Thus distance from root to leaf is a distance from a node with value 2, to node with value 6."
                    }
                ]
            },
            {
                "id": 1963713,
                "content": [
                    {
                        "username": "Aadil42",
                        "content": "Easy Peasy Lemon Squeezy. Just do DFS."
                    },
                    {
                        "username": "noman598",
                        "content": "Finally after long time a binary tree problem."
                    },
                    {
                        "username": "mrb15",
                        "content": "Was it also a daily question on May 10, 2023?"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Finally an easy problem ,wait what ? "
                    },
                    {
                        "username": "JannisBK",
                        "content": "first time a recursive approach to a tree problem has way more runtime than its iterative counterpart"
                    },
                    {
                        "username": "mrb15",
                        "content": "the tree in second example is:\\n                        2\\n                                3\\n                                        4\\n                                                5\\n                                                        6\\ni.e. a skewed binary tree.\\nand here, according to the question, the answer should be 5 and not 1.\\nif you are doing it by using level order traversal, you code should work fine.\\nbut if you just use recursive approach, you have to take care of the fact that if left subtree is null, then min=1+minDepth(root->right) and vice versa.\\n"
                    },
                    {
                        "username": "user2987Qa",
                        "content": "i got confused by the definition and example no.2. Maybe it\\'s worth noting that *The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node **that is not a null node**.*"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "class Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        \\n        if(root == NULL){\\n            return 0;\\n        }\\n        \\n        if(root -> left == NULL and root -> right == NULL){\\n            return 1;\\n        }\\n        if(root -> left == NULL){\\n           return 1+ minDepth(root -> right);\\n        }\\n\\n        if(root -> right == NULL){\\n            return 1 + minDepth(root -> left);\\n        }\\n\\n        return 1 + min(minDepth(root -> left),minDepth(root -> right));\\n    }\\n};"
                    },
                    {
                        "username": "AditiGupta5",
                        "content": "where can we check the all the test cases of any question? In previous version, I was able to see easily but in newer version its not available. Please advise."
                    },
                    {
                        "username": "Sarita_4",
                        "content": "I don\\'t know how my 2nd test case Fail my Ans=1 but here 5  please check this case [2,null,3,null,4,null,5,null,6]"
                    },
                    {
                        "username": "shin_98",
                        "content": "As statet in description *A leaf is a node with no children*.\\nThis array `[2,null,3,null,4,null,5,null,6]` can be written as\\n`____2`\\n`null 3`\\n`__null 4`\\n`____null 5`\\n`_____null 6`\\nSo root with value 2, has one children with value 3. Next node with value 3, also has one children with value 4. And so on... Every node with values from 2 to 5 has right child, so its not a *leaf*. Only node with value 6 doesn\\'t have children, so it\\'s a leaf. Thus distance from root to leaf is a distance from a node with value 2, to node with value 6."
                    }
                ]
            },
            {
                "id": 1963668,
                "content": [
                    {
                        "username": "Aadil42",
                        "content": "Easy Peasy Lemon Squeezy. Just do DFS."
                    },
                    {
                        "username": "noman598",
                        "content": "Finally after long time a binary tree problem."
                    },
                    {
                        "username": "mrb15",
                        "content": "Was it also a daily question on May 10, 2023?"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Finally an easy problem ,wait what ? "
                    },
                    {
                        "username": "JannisBK",
                        "content": "first time a recursive approach to a tree problem has way more runtime than its iterative counterpart"
                    },
                    {
                        "username": "mrb15",
                        "content": "the tree in second example is:\\n                        2\\n                                3\\n                                        4\\n                                                5\\n                                                        6\\ni.e. a skewed binary tree.\\nand here, according to the question, the answer should be 5 and not 1.\\nif you are doing it by using level order traversal, you code should work fine.\\nbut if you just use recursive approach, you have to take care of the fact that if left subtree is null, then min=1+minDepth(root->right) and vice versa.\\n"
                    },
                    {
                        "username": "user2987Qa",
                        "content": "i got confused by the definition and example no.2. Maybe it\\'s worth noting that *The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node **that is not a null node**.*"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "class Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        \\n        if(root == NULL){\\n            return 0;\\n        }\\n        \\n        if(root -> left == NULL and root -> right == NULL){\\n            return 1;\\n        }\\n        if(root -> left == NULL){\\n           return 1+ minDepth(root -> right);\\n        }\\n\\n        if(root -> right == NULL){\\n            return 1 + minDepth(root -> left);\\n        }\\n\\n        return 1 + min(minDepth(root -> left),minDepth(root -> right));\\n    }\\n};"
                    },
                    {
                        "username": "AditiGupta5",
                        "content": "where can we check the all the test cases of any question? In previous version, I was able to see easily but in newer version its not available. Please advise."
                    },
                    {
                        "username": "Sarita_4",
                        "content": "I don\\'t know how my 2nd test case Fail my Ans=1 but here 5  please check this case [2,null,3,null,4,null,5,null,6]"
                    },
                    {
                        "username": "shin_98",
                        "content": "As statet in description *A leaf is a node with no children*.\\nThis array `[2,null,3,null,4,null,5,null,6]` can be written as\\n`____2`\\n`null 3`\\n`__null 4`\\n`____null 5`\\n`_____null 6`\\nSo root with value 2, has one children with value 3. Next node with value 3, also has one children with value 4. And so on... Every node with values from 2 to 5 has right child, so its not a *leaf*. Only node with value 6 doesn\\'t have children, so it\\'s a leaf. Thus distance from root to leaf is a distance from a node with value 2, to node with value 6."
                    }
                ]
            },
            {
                "id": 1963656,
                "content": [
                    {
                        "username": "Aadil42",
                        "content": "Easy Peasy Lemon Squeezy. Just do DFS."
                    },
                    {
                        "username": "noman598",
                        "content": "Finally after long time a binary tree problem."
                    },
                    {
                        "username": "mrb15",
                        "content": "Was it also a daily question on May 10, 2023?"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Finally an easy problem ,wait what ? "
                    },
                    {
                        "username": "JannisBK",
                        "content": "first time a recursive approach to a tree problem has way more runtime than its iterative counterpart"
                    },
                    {
                        "username": "mrb15",
                        "content": "the tree in second example is:\\n                        2\\n                                3\\n                                        4\\n                                                5\\n                                                        6\\ni.e. a skewed binary tree.\\nand here, according to the question, the answer should be 5 and not 1.\\nif you are doing it by using level order traversal, you code should work fine.\\nbut if you just use recursive approach, you have to take care of the fact that if left subtree is null, then min=1+minDepth(root->right) and vice versa.\\n"
                    },
                    {
                        "username": "user2987Qa",
                        "content": "i got confused by the definition and example no.2. Maybe it\\'s worth noting that *The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node **that is not a null node**.*"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "class Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        \\n        if(root == NULL){\\n            return 0;\\n        }\\n        \\n        if(root -> left == NULL and root -> right == NULL){\\n            return 1;\\n        }\\n        if(root -> left == NULL){\\n           return 1+ minDepth(root -> right);\\n        }\\n\\n        if(root -> right == NULL){\\n            return 1 + minDepth(root -> left);\\n        }\\n\\n        return 1 + min(minDepth(root -> left),minDepth(root -> right));\\n    }\\n};"
                    },
                    {
                        "username": "AditiGupta5",
                        "content": "where can we check the all the test cases of any question? In previous version, I was able to see easily but in newer version its not available. Please advise."
                    },
                    {
                        "username": "Sarita_4",
                        "content": "I don\\'t know how my 2nd test case Fail my Ans=1 but here 5  please check this case [2,null,3,null,4,null,5,null,6]"
                    },
                    {
                        "username": "shin_98",
                        "content": "As statet in description *A leaf is a node with no children*.\\nThis array `[2,null,3,null,4,null,5,null,6]` can be written as\\n`____2`\\n`null 3`\\n`__null 4`\\n`____null 5`\\n`_____null 6`\\nSo root with value 2, has one children with value 3. Next node with value 3, also has one children with value 4. And so on... Every node with values from 2 to 5 has right child, so its not a *leaf*. Only node with value 6 doesn\\'t have children, so it\\'s a leaf. Thus distance from root to leaf is a distance from a node with value 2, to node with value 6."
                    }
                ]
            },
            {
                "id": 1945979,
                "content": [
                    {
                        "username": "Aadil42",
                        "content": "Easy Peasy Lemon Squeezy. Just do DFS."
                    },
                    {
                        "username": "noman598",
                        "content": "Finally after long time a binary tree problem."
                    },
                    {
                        "username": "mrb15",
                        "content": "Was it also a daily question on May 10, 2023?"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Finally an easy problem ,wait what ? "
                    },
                    {
                        "username": "JannisBK",
                        "content": "first time a recursive approach to a tree problem has way more runtime than its iterative counterpart"
                    },
                    {
                        "username": "mrb15",
                        "content": "the tree in second example is:\\n                        2\\n                                3\\n                                        4\\n                                                5\\n                                                        6\\ni.e. a skewed binary tree.\\nand here, according to the question, the answer should be 5 and not 1.\\nif you are doing it by using level order traversal, you code should work fine.\\nbut if you just use recursive approach, you have to take care of the fact that if left subtree is null, then min=1+minDepth(root->right) and vice versa.\\n"
                    },
                    {
                        "username": "user2987Qa",
                        "content": "i got confused by the definition and example no.2. Maybe it\\'s worth noting that *The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node **that is not a null node**.*"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "class Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        \\n        if(root == NULL){\\n            return 0;\\n        }\\n        \\n        if(root -> left == NULL and root -> right == NULL){\\n            return 1;\\n        }\\n        if(root -> left == NULL){\\n           return 1+ minDepth(root -> right);\\n        }\\n\\n        if(root -> right == NULL){\\n            return 1 + minDepth(root -> left);\\n        }\\n\\n        return 1 + min(minDepth(root -> left),minDepth(root -> right));\\n    }\\n};"
                    },
                    {
                        "username": "AditiGupta5",
                        "content": "where can we check the all the test cases of any question? In previous version, I was able to see easily but in newer version its not available. Please advise."
                    },
                    {
                        "username": "Sarita_4",
                        "content": "I don\\'t know how my 2nd test case Fail my Ans=1 but here 5  please check this case [2,null,3,null,4,null,5,null,6]"
                    },
                    {
                        "username": "shin_98",
                        "content": "As statet in description *A leaf is a node with no children*.\\nThis array `[2,null,3,null,4,null,5,null,6]` can be written as\\n`____2`\\n`null 3`\\n`__null 4`\\n`____null 5`\\n`_____null 6`\\nSo root with value 2, has one children with value 3. Next node with value 3, also has one children with value 4. And so on... Every node with values from 2 to 5 has right child, so its not a *leaf*. Only node with value 6 doesn\\'t have children, so it\\'s a leaf. Thus distance from root to leaf is a distance from a node with value 2, to node with value 6."
                    }
                ]
            },
            {
                "id": 1888820,
                "content": [
                    {
                        "username": "Aadil42",
                        "content": "Easy Peasy Lemon Squeezy. Just do DFS."
                    },
                    {
                        "username": "noman598",
                        "content": "Finally after long time a binary tree problem."
                    },
                    {
                        "username": "mrb15",
                        "content": "Was it also a daily question on May 10, 2023?"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Finally an easy problem ,wait what ? "
                    },
                    {
                        "username": "JannisBK",
                        "content": "first time a recursive approach to a tree problem has way more runtime than its iterative counterpart"
                    },
                    {
                        "username": "mrb15",
                        "content": "the tree in second example is:\\n                        2\\n                                3\\n                                        4\\n                                                5\\n                                                        6\\ni.e. a skewed binary tree.\\nand here, according to the question, the answer should be 5 and not 1.\\nif you are doing it by using level order traversal, you code should work fine.\\nbut if you just use recursive approach, you have to take care of the fact that if left subtree is null, then min=1+minDepth(root->right) and vice versa.\\n"
                    },
                    {
                        "username": "user2987Qa",
                        "content": "i got confused by the definition and example no.2. Maybe it\\'s worth noting that *The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node **that is not a null node**.*"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "class Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        \\n        if(root == NULL){\\n            return 0;\\n        }\\n        \\n        if(root -> left == NULL and root -> right == NULL){\\n            return 1;\\n        }\\n        if(root -> left == NULL){\\n           return 1+ minDepth(root -> right);\\n        }\\n\\n        if(root -> right == NULL){\\n            return 1 + minDepth(root -> left);\\n        }\\n\\n        return 1 + min(minDepth(root -> left),minDepth(root -> right));\\n    }\\n};"
                    },
                    {
                        "username": "AditiGupta5",
                        "content": "where can we check the all the test cases of any question? In previous version, I was able to see easily but in newer version its not available. Please advise."
                    },
                    {
                        "username": "Sarita_4",
                        "content": "I don\\'t know how my 2nd test case Fail my Ans=1 but here 5  please check this case [2,null,3,null,4,null,5,null,6]"
                    },
                    {
                        "username": "shin_98",
                        "content": "As statet in description *A leaf is a node with no children*.\\nThis array `[2,null,3,null,4,null,5,null,6]` can be written as\\n`____2`\\n`null 3`\\n`__null 4`\\n`____null 5`\\n`_____null 6`\\nSo root with value 2, has one children with value 3. Next node with value 3, also has one children with value 4. And so on... Every node with values from 2 to 5 has right child, so its not a *leaf*. Only node with value 6 doesn\\'t have children, so it\\'s a leaf. Thus distance from root to leaf is a distance from a node with value 2, to node with value 6."
                    }
                ]
            },
            {
                "id": 1881006,
                "content": [
                    {
                        "username": "Aadil42",
                        "content": "Easy Peasy Lemon Squeezy. Just do DFS."
                    },
                    {
                        "username": "noman598",
                        "content": "Finally after long time a binary tree problem."
                    },
                    {
                        "username": "mrb15",
                        "content": "Was it also a daily question on May 10, 2023?"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Finally an easy problem ,wait what ? "
                    },
                    {
                        "username": "JannisBK",
                        "content": "first time a recursive approach to a tree problem has way more runtime than its iterative counterpart"
                    },
                    {
                        "username": "mrb15",
                        "content": "the tree in second example is:\\n                        2\\n                                3\\n                                        4\\n                                                5\\n                                                        6\\ni.e. a skewed binary tree.\\nand here, according to the question, the answer should be 5 and not 1.\\nif you are doing it by using level order traversal, you code should work fine.\\nbut if you just use recursive approach, you have to take care of the fact that if left subtree is null, then min=1+minDepth(root->right) and vice versa.\\n"
                    },
                    {
                        "username": "user2987Qa",
                        "content": "i got confused by the definition and example no.2. Maybe it\\'s worth noting that *The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node **that is not a null node**.*"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "class Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        \\n        if(root == NULL){\\n            return 0;\\n        }\\n        \\n        if(root -> left == NULL and root -> right == NULL){\\n            return 1;\\n        }\\n        if(root -> left == NULL){\\n           return 1+ minDepth(root -> right);\\n        }\\n\\n        if(root -> right == NULL){\\n            return 1 + minDepth(root -> left);\\n        }\\n\\n        return 1 + min(minDepth(root -> left),minDepth(root -> right));\\n    }\\n};"
                    },
                    {
                        "username": "AditiGupta5",
                        "content": "where can we check the all the test cases of any question? In previous version, I was able to see easily but in newer version its not available. Please advise."
                    },
                    {
                        "username": "Sarita_4",
                        "content": "I don\\'t know how my 2nd test case Fail my Ans=1 but here 5  please check this case [2,null,3,null,4,null,5,null,6]"
                    },
                    {
                        "username": "shin_98",
                        "content": "As statet in description *A leaf is a node with no children*.\\nThis array `[2,null,3,null,4,null,5,null,6]` can be written as\\n`____2`\\n`null 3`\\n`__null 4`\\n`____null 5`\\n`_____null 6`\\nSo root with value 2, has one children with value 3. Next node with value 3, also has one children with value 4. And so on... Every node with values from 2 to 5 has right child, so its not a *leaf*. Only node with value 6 doesn\\'t have children, so it\\'s a leaf. Thus distance from root to leaf is a distance from a node with value 2, to node with value 6."
                    }
                ]
            },
            {
                "id": 1848559,
                "content": [
                    {
                        "username": "Aadil42",
                        "content": "Easy Peasy Lemon Squeezy. Just do DFS."
                    },
                    {
                        "username": "noman598",
                        "content": "Finally after long time a binary tree problem."
                    },
                    {
                        "username": "mrb15",
                        "content": "Was it also a daily question on May 10, 2023?"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Finally an easy problem ,wait what ? "
                    },
                    {
                        "username": "JannisBK",
                        "content": "first time a recursive approach to a tree problem has way more runtime than its iterative counterpart"
                    },
                    {
                        "username": "mrb15",
                        "content": "the tree in second example is:\\n                        2\\n                                3\\n                                        4\\n                                                5\\n                                                        6\\ni.e. a skewed binary tree.\\nand here, according to the question, the answer should be 5 and not 1.\\nif you are doing it by using level order traversal, you code should work fine.\\nbut if you just use recursive approach, you have to take care of the fact that if left subtree is null, then min=1+minDepth(root->right) and vice versa.\\n"
                    },
                    {
                        "username": "user2987Qa",
                        "content": "i got confused by the definition and example no.2. Maybe it\\'s worth noting that *The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node **that is not a null node**.*"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "class Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        \\n        if(root == NULL){\\n            return 0;\\n        }\\n        \\n        if(root -> left == NULL and root -> right == NULL){\\n            return 1;\\n        }\\n        if(root -> left == NULL){\\n           return 1+ minDepth(root -> right);\\n        }\\n\\n        if(root -> right == NULL){\\n            return 1 + minDepth(root -> left);\\n        }\\n\\n        return 1 + min(minDepth(root -> left),minDepth(root -> right));\\n    }\\n};"
                    },
                    {
                        "username": "AditiGupta5",
                        "content": "where can we check the all the test cases of any question? In previous version, I was able to see easily but in newer version its not available. Please advise."
                    },
                    {
                        "username": "Sarita_4",
                        "content": "I don\\'t know how my 2nd test case Fail my Ans=1 but here 5  please check this case [2,null,3,null,4,null,5,null,6]"
                    },
                    {
                        "username": "shin_98",
                        "content": "As statet in description *A leaf is a node with no children*.\\nThis array `[2,null,3,null,4,null,5,null,6]` can be written as\\n`____2`\\n`null 3`\\n`__null 4`\\n`____null 5`\\n`_____null 6`\\nSo root with value 2, has one children with value 3. Next node with value 3, also has one children with value 4. And so on... Every node with values from 2 to 5 has right child, so its not a *leaf*. Only node with value 6 doesn\\'t have children, so it\\'s a leaf. Thus distance from root to leaf is a distance from a node with value 2, to node with value 6."
                    }
                ]
            },
            {
                "id": 1818789,
                "content": [
                    {
                        "username": "Aadil42",
                        "content": "Easy Peasy Lemon Squeezy. Just do DFS."
                    },
                    {
                        "username": "noman598",
                        "content": "Finally after long time a binary tree problem."
                    },
                    {
                        "username": "mrb15",
                        "content": "Was it also a daily question on May 10, 2023?"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Finally an easy problem ,wait what ? "
                    },
                    {
                        "username": "JannisBK",
                        "content": "first time a recursive approach to a tree problem has way more runtime than its iterative counterpart"
                    },
                    {
                        "username": "mrb15",
                        "content": "the tree in second example is:\\n                        2\\n                                3\\n                                        4\\n                                                5\\n                                                        6\\ni.e. a skewed binary tree.\\nand here, according to the question, the answer should be 5 and not 1.\\nif you are doing it by using level order traversal, you code should work fine.\\nbut if you just use recursive approach, you have to take care of the fact that if left subtree is null, then min=1+minDepth(root->right) and vice versa.\\n"
                    },
                    {
                        "username": "user2987Qa",
                        "content": "i got confused by the definition and example no.2. Maybe it\\'s worth noting that *The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node **that is not a null node**.*"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "class Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        \\n        if(root == NULL){\\n            return 0;\\n        }\\n        \\n        if(root -> left == NULL and root -> right == NULL){\\n            return 1;\\n        }\\n        if(root -> left == NULL){\\n           return 1+ minDepth(root -> right);\\n        }\\n\\n        if(root -> right == NULL){\\n            return 1 + minDepth(root -> left);\\n        }\\n\\n        return 1 + min(minDepth(root -> left),minDepth(root -> right));\\n    }\\n};"
                    },
                    {
                        "username": "AditiGupta5",
                        "content": "where can we check the all the test cases of any question? In previous version, I was able to see easily but in newer version its not available. Please advise."
                    },
                    {
                        "username": "Sarita_4",
                        "content": "I don\\'t know how my 2nd test case Fail my Ans=1 but here 5  please check this case [2,null,3,null,4,null,5,null,6]"
                    },
                    {
                        "username": "shin_98",
                        "content": "As statet in description *A leaf is a node with no children*.\\nThis array `[2,null,3,null,4,null,5,null,6]` can be written as\\n`____2`\\n`null 3`\\n`__null 4`\\n`____null 5`\\n`_____null 6`\\nSo root with value 2, has one children with value 3. Next node with value 3, also has one children with value 4. And so on... Every node with values from 2 to 5 has right child, so its not a *leaf*. Only node with value 6 doesn\\'t have children, so it\\'s a leaf. Thus distance from root to leaf is a distance from a node with value 2, to node with value 6."
                    }
                ]
            },
            {
                "id": 1787344,
                "content": [
                    {
                        "username": "Aadil42",
                        "content": "Easy Peasy Lemon Squeezy. Just do DFS."
                    },
                    {
                        "username": "noman598",
                        "content": "Finally after long time a binary tree problem."
                    },
                    {
                        "username": "mrb15",
                        "content": "Was it also a daily question on May 10, 2023?"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Finally an easy problem ,wait what ? "
                    },
                    {
                        "username": "JannisBK",
                        "content": "first time a recursive approach to a tree problem has way more runtime than its iterative counterpart"
                    },
                    {
                        "username": "mrb15",
                        "content": "the tree in second example is:\\n                        2\\n                                3\\n                                        4\\n                                                5\\n                                                        6\\ni.e. a skewed binary tree.\\nand here, according to the question, the answer should be 5 and not 1.\\nif you are doing it by using level order traversal, you code should work fine.\\nbut if you just use recursive approach, you have to take care of the fact that if left subtree is null, then min=1+minDepth(root->right) and vice versa.\\n"
                    },
                    {
                        "username": "user2987Qa",
                        "content": "i got confused by the definition and example no.2. Maybe it\\'s worth noting that *The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node **that is not a null node**.*"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "class Solution {\\npublic:\\n    int minDepth(TreeNode* root) {\\n        \\n        if(root == NULL){\\n            return 0;\\n        }\\n        \\n        if(root -> left == NULL and root -> right == NULL){\\n            return 1;\\n        }\\n        if(root -> left == NULL){\\n           return 1+ minDepth(root -> right);\\n        }\\n\\n        if(root -> right == NULL){\\n            return 1 + minDepth(root -> left);\\n        }\\n\\n        return 1 + min(minDepth(root -> left),minDepth(root -> right));\\n    }\\n};"
                    },
                    {
                        "username": "AditiGupta5",
                        "content": "where can we check the all the test cases of any question? In previous version, I was able to see easily but in newer version its not available. Please advise."
                    },
                    {
                        "username": "Sarita_4",
                        "content": "I don\\'t know how my 2nd test case Fail my Ans=1 but here 5  please check this case [2,null,3,null,4,null,5,null,6]"
                    },
                    {
                        "username": "shin_98",
                        "content": "As statet in description *A leaf is a node with no children*.\\nThis array `[2,null,3,null,4,null,5,null,6]` can be written as\\n`____2`\\n`null 3`\\n`__null 4`\\n`____null 5`\\n`_____null 6`\\nSo root with value 2, has one children with value 3. Next node with value 3, also has one children with value 4. And so on... Every node with values from 2 to 5 has right child, so its not a *leaf*. Only node with value 6 doesn\\'t have children, so it\\'s a leaf. Thus distance from root to leaf is a distance from a node with value 2, to node with value 6."
                    }
                ]
            }
        ]
    }
]